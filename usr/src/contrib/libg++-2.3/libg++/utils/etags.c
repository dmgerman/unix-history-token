begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tags file maker to go with GNU Emacs    Copyright (C) 1984, 1987, 1988, 1989, 1992 Free Software Foundation, Inc. and Ken Arnold  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * Authors:  *	Ctags originally by Ken Arnold.  *	FORTRAN added by Jim Kleckner.  *	Ed Pelegri-Llopart added C typedefs.  *	Gnu Emacs TAGS format and modifications by RMS?  *	Sam Kendall added C++.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strncpy
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|strcmp
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_define
define|#
directive|define
name|notdef
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define the symbol ETAGS to make the program "etags",  which makes emacs-style tag tables by default.  Define CTAGS to make the program "ctags" compatible with the usual one.  Define neither one to get behavior that depends  on the name with which the program is invoked  (but we don't normally compile it that way).  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ETAGS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CTAGS
argument_list|)
end_if

begin_comment
comment|/* If neither is defined, program can be run as either. */
end_comment

begin_define
define|#
directive|define
name|ETAGS
end_define

begin_define
define|#
directive|define
name|CTAGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On VMS, CTAGS is not useful, so always do ETAGS.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|ETAGS
end_ifndef

begin_define
define|#
directive|define
name|ETAGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Exit codes for success and failure.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|GOOD
value|(1)
end_define

begin_define
define|#
directive|define
name|BAD
value|(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GOOD
value|(0)
end_define

begin_define
define|#
directive|define
name|BAD
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The FILEPOS abstract type, which represents a position in a file,  * plus the following accessor functions:  *  *	long GET_CHARNO (pos)  *				returns absolute char number.  *	long GET_COOKIE (pos)  *				returns ftell () cookie.  *	void SET_FILEPOS (pos, fp, charno)  *	    FILE *fp; long charno;  *				sets `pos' from the current file  *				position of `fp' and from `charno',  *				which must be the absolute character  *				number corresponding to the current  *				position of `fp'.  *  * The `pos' parameter is an lvalue expression of type FILEPOS.  * Parameters to the accessor functions are evaluated 0 or more times,  * and so must have no side effects.  *  * FILEPOS objects can also be assigned and passed to and from  * functions in the normal C manner.  *  * Implementation notes: the `+ 0' is to enforce rvalue-ness.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_typedef
typedef|typedef
struct|struct
block|{
name|long
name|cookie
decl_stmt|;
name|long
name|charno
decl_stmt|;
block|}
name|FILEPOS
typedef|;
end_typedef

begin_define
define|#
directive|define
name|GET_CHARNO
parameter_list|(
name|pos
parameter_list|)
value|((pos).charno + 0)
end_define

begin_define
define|#
directive|define
name|GET_COOKIE
parameter_list|(
name|pos
parameter_list|)
value|((pos).cookie + 0)
end_define

begin_define
define|#
directive|define
name|SET_FILEPOS
parameter_list|(
name|pos
parameter_list|,
name|fp
parameter_list|,
name|cno
parameter_list|)
define|\
value|((void) ((pos).cookie = ftell (fp), (pos).charno = (cno)))
end_define

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_comment
comment|/* UNIX real implementation */
end_comment

begin_typedef
typedef|typedef
name|long
name|FILEPOS
typedef|;
end_typedef

begin_define
define|#
directive|define
name|GET_CHARNO
parameter_list|(
name|pos
parameter_list|)
value|((pos) + 0)
end_define

begin_define
define|#
directive|define
name|GET_COOKIE
parameter_list|(
name|pos
parameter_list|)
value|GET_CHARNO (pos)
end_define

begin_define
define|#
directive|define
name|SET_FILEPOS
parameter_list|(
name|pos
parameter_list|,
name|fp
parameter_list|,
name|cno
parameter_list|)
value|((void) ((pos) = (cno)))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* UNIX debugging implementation */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|long
name|charno
decl_stmt|;
block|}
name|FILEPOS
typedef|;
end_typedef

begin_define
define|#
directive|define
name|GET_CHARNO
parameter_list|(
name|pos
parameter_list|)
value|((pos).charno + 0)
end_define

begin_define
define|#
directive|define
name|GET_COOKIE
parameter_list|(
name|pos
parameter_list|)
value|GET_CHARNO (pos)
end_define

begin_define
define|#
directive|define
name|SET_FILEPOS
parameter_list|(
name|pos
parameter_list|,
name|fp
parameter_list|,
name|cno
parameter_list|)
define|\
value|((void) ((pos).charno = (cno),					\ 	     (cno) != ftell (fp) ? (error ("SET_FILEPOS inconsistency"), 0) \ 	     			 : 0))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
value|(strcmp (s, t) == 0)
end_define

begin_define
define|#
directive|define
name|strneq
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
value|(strncmp (s, t, n) == 0)
end_define

begin_define
define|#
directive|define
name|reg
value|register
end_define

begin_define
define|#
directive|define
name|logical
value|char
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|iswhite
parameter_list|(
name|arg
parameter_list|)
value|(_wht[arg])
end_define

begin_comment
comment|/* T if char is white		*/
end_comment

begin_define
define|#
directive|define
name|begtoken
parameter_list|(
name|arg
parameter_list|)
value|(_btk[arg])
end_define

begin_comment
comment|/* T if char can start token	*/
end_comment

begin_define
define|#
directive|define
name|intoken
parameter_list|(
name|arg
parameter_list|)
value|(_itk[arg])
end_define

begin_comment
comment|/* T if char can be in token	*/
end_comment

begin_define
define|#
directive|define
name|endtoken
parameter_list|(
name|arg
parameter_list|)
value|(_etk[arg])
end_define

begin_comment
comment|/* T if char ends tokens	*/
end_comment

begin_define
define|#
directive|define
name|isgood
parameter_list|(
name|arg
parameter_list|)
value|(_gd[arg])
end_define

begin_comment
comment|/* T if char can be after ')'	*/
end_comment

begin_define
define|#
directive|define
name|max
parameter_list|(
name|I1
parameter_list|,
name|I2
parameter_list|)
value|((I1)> (I2) ? (I1) : (I2))
end_define

begin_struct
struct|struct
name|nd_st
block|{
comment|/* sorting structure			*/
name|char
modifier|*
name|name
decl_stmt|;
comment|/* function or type name	*/
name|char
modifier|*
name|file
decl_stmt|;
comment|/* file name			*/
name|logical
name|is_func
decl_stmt|;
comment|/* use pattern or line no	*/
name|logical
name|rewritten
decl_stmt|;
comment|/* list name separately		*/
name|logical
name|been_warned
decl_stmt|;
comment|/* set if noticed dup		*/
name|int
name|lno
decl_stmt|;
comment|/* line number tag is on	*/
name|long
name|cno
decl_stmt|;
comment|/* character number line starts on */
name|char
modifier|*
name|pat
decl_stmt|;
comment|/* search pattern		*/
name|struct
name|nd_st
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
comment|/* left and right sons		*/
block|}
struct|;
end_struct

begin_function_decl
name|long
name|ftell
parameter_list|()
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|struct
name|nd_st
name|NODE
typedef|;
end_typedef

begin_decl_stmt
name|logical
name|gotone
decl_stmt|,
comment|/* found a func already on line	*/
comment|/* boolean "func" (see init)	*/
name|header_file
decl_stmt|,
comment|/* TRUE if .h file, FALSE o.w.  */
name|_wht
index|[
literal|0177
index|]
decl_stmt|,
name|_etk
index|[
literal|0177
index|]
decl_stmt|,
name|_itk
index|[
literal|0177
index|]
decl_stmt|,
name|_btk
index|[
literal|0177
index|]
decl_stmt|,
name|_gd
index|[
literal|0177
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|savenstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|savestr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|L_isdef
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|PF_funcs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|total_size_of_entries
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|logical
name|consider_token
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|logical
name|tail
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|readline
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|Asm_funcs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|C_entries
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|L_funcs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|L_getit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|PAS_funcs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|Scheme_funcs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TEX_funcs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_node
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|find_entries
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free_tree
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|getit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|getline
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|initbuffer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|initbuffer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pfnote
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|process_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|put_entries
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|takeprec
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * MACRO  *	xnew -- allocate storage  *  * SYNOPSIS  *	Type *xnew (int n, Type);  */
end_comment

begin_define
define|#
directive|define
name|xnew
parameter_list|(
name|n
parameter_list|,
name|Type
parameter_list|)
value|((Type *) xmalloc ((n) * sizeof (Type)))
end_define

begin_escape
end_escape

begin_comment
comment|/*  *	Symbol table stuff.  *  * Should probably be implemented with hash table; linked list for now.  */
end_comment

begin_enum
enum|enum
name|sym_type
block|{
name|st_none
block|,
name|st_C_struct
block|,
name|st_C_enum
block|,
name|st_C_define
block|,
name|st_C_typedef
block|,
name|st_C_typespec
block|}
enum|;
end_enum

begin_struct
struct|struct
name|stab_entry
block|{
name|char
modifier|*
name|sym
decl_stmt|;
name|int
name|symlen
decl_stmt|;
name|enum
name|sym_type
name|type
decl_stmt|;
name|struct
name|stab_entry
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|stab_entry
name|Stab_entry
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|Stab_entry
modifier|*
name|Stab
typedef|;
end_typedef

begin_comment
comment|/*  * NAME  *	Stab, Stab_entry, stab_create, stab_search, stab_find -- symbol table  *  * SYNOPSIS  *	Types: Stab, Stab_entry, enum sym_type  *  *	Stab * stab_create ()  *  *	Stab_entry * stab_find (stab, sym)  *	Stab *stab;  *	char *sym;  *  *	Stab_entry * stab_search (stab, sym)  *	Stab *stab;  *	char *sym;  *  * DESCRIPTION  *	stab_create creates a Stab, a symbol table object, and returns a  *	pointer to it.  stab_find finds a symbol in a Stab; it returns a  *	pointer to the Stab_entry if found, otherwise NULL.  stab_search  *	is like stab_find, except that it creates a new Stab_entry,  *	initialized with type = st_none, if one did not exist already  *	(it never returns NULL).  *  *	A Stab_entry is a structure that contains at least the following  *	members:  *  *		char *name;		// must not be modified  *		enum sym_type type;	// should be set  *  *	The type field is initially set to st_none; it should be set to  *	something else by the caller of stab_search.  Other possible values  *	of an enum sym_type can be added.  */
end_comment

begin_function
name|Stab
modifier|*
name|stab_create
parameter_list|()
block|{
name|Stab
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|xnew
argument_list|(
literal|1
argument_list|,
name|Stab
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
name|NULL
expr_stmt|;
comment|/* a Stab starts out as a null Stab_entry* */
return|return
name|sp
return|;
block|}
end_function

begin_function
name|Stab_entry
modifier|*
name|stab_find
parameter_list|(
name|stab
parameter_list|,
name|sym
parameter_list|,
name|symlen
parameter_list|)
name|Stab
modifier|*
name|stab
decl_stmt|;
specifier|register
name|char
modifier|*
name|sym
decl_stmt|;
specifier|register
name|int
name|symlen
decl_stmt|;
block|{
specifier|register
name|Stab_entry
modifier|*
name|se
decl_stmt|;
for|for
control|(
name|se
operator|=
operator|*
name|stab
init|;
name|se
operator|!=
name|NULL
condition|;
name|se
operator|=
name|se
operator|->
name|next
control|)
block|{
if|if
condition|(
name|se
operator|->
name|symlen
operator|==
name|symlen
operator|&&
name|strneq
argument_list|(
name|se
operator|->
name|sym
argument_list|,
name|sym
argument_list|,
name|symlen
argument_list|)
condition|)
return|return
name|se
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Stab_entry
modifier|*
name|stab_search
parameter_list|(
name|stab
parameter_list|,
name|sym
parameter_list|,
name|symlen
parameter_list|)
specifier|register
name|Stab
modifier|*
name|stab
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
name|int
name|symlen
decl_stmt|;
block|{
specifier|register
name|Stab_entry
modifier|*
name|se
decl_stmt|;
name|se
operator|=
name|stab_find
argument_list|(
name|stab
argument_list|,
name|sym
argument_list|,
name|symlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|==
name|NULL
condition|)
block|{
comment|/* make a new one */
name|se
operator|=
name|xnew
argument_list|(
literal|1
argument_list|,
name|Stab_entry
argument_list|)
expr_stmt|;
name|se
operator|->
name|sym
operator|=
name|savenstr
argument_list|(
name|sym
argument_list|,
name|symlen
argument_list|)
expr_stmt|;
name|se
operator|->
name|symlen
operator|=
name|symlen
expr_stmt|;
name|se
operator|->
name|type
operator|=
name|st_none
expr_stmt|;
name|se
operator|->
name|next
operator|=
operator|*
name|stab
expr_stmt|;
operator|*
name|stab
operator|=
name|se
expr_stmt|;
block|}
return|return
name|se
return|;
block|}
end_function

begin_comment
comment|/*  * NAME  *	stab_type -- type of a symbol table entry  *  * SYNOPSIS  *	enum sym_type stab_type (Stab_entry *se);  *  * WARNING  *	May evaluate its argument more than once.  */
end_comment

begin_define
define|#
directive|define
name|stab_type
parameter_list|(
name|se
parameter_list|)
value|((se)==NULL ? st_none : (se)->type)
end_define

begin_escape
end_escape

begin_typedef
typedef|typedef
name|int
name|LINENO
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|FILEPOS
name|linestart
decl_stmt|;
name|LINENO
name|lineno
decl_stmt|;
name|logical
name|rewritten
decl_stmt|;
block|}
name|TOKEN
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* typedefs are recognized using a simple finite automaton.   * tydef is its state variable.   */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|none
block|,
name|begin
block|,
name|middle
block|,
name|end
block|}
name|TYST
typedef|;
end_typedef

begin_decl_stmt
name|TYST
name|tydef
init|=
name|none
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* struct tags for C++ are recognized using another simple   * finite automaton.  `structdef' is its state variable.   * This machinery is only invoked for C++; otherwise structdef   * should remain snone.  However, this machinery can easily be   * adapted to find structure tags in normal C code.   */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|snone
block|,
comment|/* nothing seen yet */
name|skeyseen
block|,
comment|/* struct-like keyword seen */
name|stagseen
block|,
comment|/* struct-like tag seen */
name|scolonseen
block|,
comment|/* colon seen after struct-like tag */
name|sinbody
comment|/* in a class body: recognize member func defs */
block|}
name|STRUCTST
typedef|;
end_typedef

begin_decl_stmt
name|STRUCTST
name|structdef
init|=
name|snone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * When structdef is stagseen, scolonseen, or sinbody, structtag is the  * struct tag, and structkey is the preceding struct-like keyword.  */
end_comment

begin_decl_stmt
name|char
name|structtag
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Stab_entry
modifier|*
name|structkey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Yet another little state machine to deal with preprocessor lines.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|dnone
block|,
comment|/* nothing seen */
name|dsharpseen
block|,
comment|/* '#' seen as first char on line */
name|ddefineseen
block|,
comment|/* '#' and 'define' seen */
name|dignorerest
comment|/* ignore rest of line */
block|}
name|DEFINEST
typedef|;
end_typedef

begin_decl_stmt
name|DEFINEST
name|definedef
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * LEVEL_OK_FOR_FUNCDEF allows C++ function definition within class body.  * Currently tydef and structdef stuff (typedefs and struct definitions) are  * only noticed when level==0, but that may change.  *  * Note that this macro may only be evaluated inside C_entries().  It is  * for self-documentation only.  */
end_comment

begin_define
define|#
directive|define
name|LEVEL_OK_FOR_FUNCDEF
parameter_list|()
define|\
value|(level==0 || (c_ext&& level==1&& structdef==sinbody))
end_define

begin_comment
comment|/*  * next_token_is_func  *	set this to TRUE, and the next token considered is called a function.  */
end_comment

begin_decl_stmt
name|logical
name|next_token_is_func
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C extensions.  Currently all listed extensions are C++ dialects, so  * `c_ext' is used as an abbreviation for `c_ext&C_PLPL'.  If a non-C++  * dialect is added, this must change.  */
end_comment

begin_define
define|#
directive|define
name|C_PLPL
value|0x1
end_define

begin_comment
comment|/* C++ */
end_comment

begin_define
define|#
directive|define
name|C_STAR
value|0x3
end_define

begin_comment
comment|/* C* */
end_comment

begin_decl_stmt
name|char
name|searchar
init|=
literal|'/'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use /.../ searches 		*/
end_comment

begin_decl_stmt
name|LINENO
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number of current line */
end_comment

begin_decl_stmt
name|long
name|charno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current character number */
end_comment

begin_decl_stmt
name|FILEPOS
name|linepos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of line (C only) */
end_comment

begin_decl_stmt
name|FILEPOS
name|prev_linepos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of previous line (C only) */
end_comment

begin_decl_stmt
name|long
name|linecharno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* charno of start of line; not used by C, but 				 * by every other language. 				 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|curfile
decl_stmt|,
comment|/* current input file name		*/
modifier|*
name|outfile
decl_stmt|,
comment|/* output file				*/
modifier|*
name|white
init|=
literal|" \f\t\n"
decl_stmt|,
comment|/* white chars				*/
modifier|*
name|endtk
init|=
literal|" \t\n\"'#()[]{}=-+%*/&|^~!<>;,.:?"
decl_stmt|,
comment|/* token ending chars			*/
modifier|*
name|begtk
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz$"
decl_stmt|,
comment|/* token starting chars			*/
modifier|*
name|intk
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz$0123456789"
decl_stmt|,
comment|/* valid in-token chars			*/
modifier|*
name|notgd
init|=
literal|",;"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-valid after-function chars	*/
end_comment

begin_decl_stmt
name|int
name|append_to_tagfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -a: append to tags */
end_comment

begin_decl_stmt
name|int
name|emacs_tags_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* emacs style output (no -e option any more) */
end_comment

begin_comment
comment|/* The following three default to 1 for etags, but to 0 for ctags.  */
end_comment

begin_decl_stmt
name|int
name|typedefs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -t: create tags for typedefs */
end_comment

begin_decl_stmt
name|int
name|typedefs_and_cplusplus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -T: create tags for typedefs, level */
end_comment

begin_comment
comment|/* 0 struct/enum/union decls, and C++ */
end_comment

begin_comment
comment|/* member functions */
end_comment

begin_decl_stmt
name|int
name|constantypedefs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -d: create tags for C #define and enum */
end_comment

begin_comment
comment|/* constants. Default under etags.  Enum */
end_comment

begin_comment
comment|/* constants not implemented. */
end_comment

begin_comment
comment|/* -D: opposite of -d.  Default under ctags. */
end_comment

begin_decl_stmt
name|int
name|update
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -u: update tags */
end_comment

begin_decl_stmt
name|int
name|vgrind_style
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -v: create vgrind style index output */
end_comment

begin_decl_stmt
name|int
name|no_warnings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -w: suppress warnings */
end_comment

begin_decl_stmt
name|int
name|cxref_style
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -x: create cxref style output */
end_comment

begin_decl_stmt
name|int
name|cplusplus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* .[hc] means C++, not C */
end_comment

begin_decl_stmt
name|int
name|noindentypedefs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -S: ignore indentation in C */
end_comment

begin_comment
comment|/* Name this program was invoked with.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"append"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"backward-search"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'B'
block|}
block|,
block|{
literal|"c++"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
block|{
literal|"cxref"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"defines"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"forward-search"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'H'
block|}
block|,
block|{
literal|"ignore-indentation"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"include"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"no-defines"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"no-warn"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'w'
block|}
block|,
block|{
literal|"output"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
literal|"typedefs"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"typedefs-and-c++"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
block|{
literal|"update"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
literal|"vgrind"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|inf
decl_stmt|,
comment|/* ioptr for current input file		*/
modifier|*
name|outf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ioptr for tags file			*/
end_comment

begin_decl_stmt
name|NODE
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the head of the binary tree of tags	*/
end_comment

begin_decl_stmt
name|int
name|permit_duplicates
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means allow duplicate tags.  */
end_comment

begin_comment
comment|/* A `struct linebuffer' is a structure which holds a line of text.  `readline' reads a line from a stream into a linebuffer  and works regardless of the length of the line.  */
end_comment

begin_struct
struct|struct
name|linebuffer
block|{
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|linebuffer
name|lb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current line */
end_comment

begin_decl_stmt
name|struct
name|linebuffer
name|lb1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sometimes, a previous line in which a token lies */
end_comment

begin_decl_stmt
name|struct
name|linebuffer
name|filename_lb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to read in filenames */
end_comment

begin_escape
end_escape

begin_function
name|void
name|print_version
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|CTAGS
name|printf
argument_list|(
literal|"CTAGS "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ETAGS
name|printf
argument_list|(
literal|"and "
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ETAGS
name|printf
argument_list|(
literal|"ETAGS "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"for Emacs version 19.0.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_help
parameter_list|()
block|{
name|printf
argument_list|(
literal|"These are the options accepted by %s.  You may use unambiguous\n\ abbreviations for the long option names.\n\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ -a, --append\n\         Append tag entries to existing tags file.\n\ -C, --c++\n\         Treat files with `.c' and `.h' extensions as C++ code, not C\n\         code.  Files with `.C', `.H', `.cxx', `.hxx', or `.cc'\n\         extensions are always assumed to be C++ code.\n\ -d, --defines\n\         Create tag entries for #defines, too."
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ETAGS
name|fputs
argument_list|(
literal|"  This is the default\n\         behavior."
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs
argument_list|(
literal|"\n\ -D, --no-defines\n\         Don't create tag entries for #defines."
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CTAGS
name|fputs
argument_list|(
literal|"  This is the default\n\         behavior."
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|puts
argument_list|(
literal|"\n\ -o FILE, --output=FILE\n\         Write the tags to FILE.\n\ -S, --ignore-indentation\n\         Don't rely on indentation quite as much as normal.  Currently,\n\         this means not to assume that a closing brace in the first\n\         column is the final brace of a function or structure\n\         definition.\n\ -t, --typedefs\n\         Generate tag entries for typedefs.  This is the default\n\         behavior.\n\ -T, --typedefs-and-c++\n\         Generate tag entries for typedefs, struct/enum/union tags, and\n\         C++ member functions."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ETAGS
name|puts
argument_list|(
literal|"-i FILE, --include=FILE\n\         Include a note in tag file indicating that, when searching for\n\         a tag, one should also consult the tags file FILE after\n\         checking the current file."
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CTAGS
name|puts
argument_list|(
literal|"-B, --backward-search\n\         Write the search commands for the tag entries using '?', the\n\         backward-search command.\n\ -F, --forward-search\n\         Write the search commands for the tag entries using '/', the\n\         forward-search command.\n\ -u, --update\n\         Update the tag entries for the given files, leaving tag\n\         entries for other files in place.  Currently, this is\n\         implemented by deleting the existing entries for the given\n\         files and then rewriting the new entries at the end of the\n\         tags file.  It is often faster to simply rebuild the entire\n\         tag file than to use this.\n\ -v, --vgrind\n\         Generates an index of items intended for human consumption,\n\         similar to the output of vgrind.  The index is sorted, and\n\         gives the page number of each item.\n\ -x, --cxref\n\         Like --vgrind, but in the style of cxref, rather than vgrind.\n\         The output uses line numbers instead of page numbers, but\n\         beyond that the differences are cosmetic; try both to see\n\         which you like.\n\ -w, --no-warn\n\         Suppress warning messages about entries defined in multiple\n\         files."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|puts
argument_list|(
literal|"-V, --version\n\         Print the version of the program.\n\ -H, --help\n\         Print this help message."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
name|cmd
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|nincluded_files
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|included_files
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|this_file
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|char
name|got_err
decl_stmt|;
specifier|extern
name|char
modifier|*
name|gfnames
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|massage_name
parameter_list|()
function_decl|;
endif|#
directive|endif
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|CTAGS
name|emacs_tags_format
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|emacs_tags_format
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/*    * If etags, always find typedefs and structure tags.  Why not?    * Also default is to find macro constants.    */
if|if
condition|(
name|emacs_tags_format
condition|)
name|typedefs
operator|=
name|typedefs_and_cplusplus
operator|=
name|constantypedefs
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|opt
decl_stmt|;
name|opt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aCdDo:StTi:BFuvxwVH"
argument_list|,
name|longopts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|EOF
condition|)
break|break;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* If getopt returns '\0', then it has already processed a 	     long-named option.  We should do nothing.  */
break|break;
comment|/* Common options. */
case|case
literal|'a'
case|:
name|append_to_tagfile
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|cplusplus
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|constantypedefs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|constantypedefs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|outfile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -o flag may only be given once\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|outfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|noindentypedefs
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|typedefs
operator|++
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|typedefs
operator|++
expr_stmt|;
name|typedefs_and_cplusplus
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|print_version
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|print_help
argument_list|()
expr_stmt|;
break|break;
comment|/* Etags options */
case|case
literal|'i'
case|:
if|if
condition|(
operator|!
name|emacs_tags_format
condition|)
goto|goto
name|usage
goto|;
name|included_files
index|[
name|nincluded_files
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* Ctags options. */
case|case
literal|'B'
case|:
name|searchar
operator|=
literal|'?'
expr_stmt|;
if|if
condition|(
name|emacs_tags_format
condition|)
goto|goto
name|usage
goto|;
break|break;
case|case
literal|'F'
case|:
name|searchar
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|emacs_tags_format
condition|)
goto|goto
name|usage
goto|;
break|break;
case|case
literal|'u'
case|:
name|update
operator|++
expr_stmt|;
if|if
condition|(
name|emacs_tags_format
condition|)
goto|goto
name|usage
goto|;
break|break;
case|case
literal|'v'
case|:
name|vgrind_style
operator|++
expr_stmt|;
comment|/*FALLTHRU*/
case|case
literal|'x'
case|:
name|cxref_style
operator|++
expr_stmt|;
if|if
condition|(
name|emacs_tags_format
condition|)
goto|goto
name|usage
goto|;
break|break;
case|case
literal|'w'
case|:
name|no_warnings
operator|++
expr_stmt|;
if|if
condition|(
name|emacs_tags_format
condition|)
goto|goto
name|usage
goto|;
break|break;
default|default:
goto|goto
name|usage
goto|;
block|}
block|}
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: No input files specified.\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|usage
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Try '%s --help' for a complete list of options.\n"
argument_list|,
name|progname
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outfile
operator|==
literal|0
condition|)
block|{
name|outfile
operator|=
name|emacs_tags_format
condition|?
literal|"TAGS"
else|:
literal|"tags"
expr_stmt|;
block|}
name|init
argument_list|()
expr_stmt|;
comment|/* set up boolean "functions"		*/
name|initbuffer
argument_list|(
operator|&
name|lb
argument_list|)
expr_stmt|;
name|initbuffer
argument_list|(
operator|&
name|lb1
argument_list|)
expr_stmt|;
name|initbuffer
argument_list|(
operator|&
name|filename_lb
argument_list|)
expr_stmt|;
comment|/*    * loop through files finding functions    */
if|if
condition|(
name|emacs_tags_format
condition|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|outfile
argument_list|,
literal|"-"
argument_list|)
condition|)
name|outf
operator|=
name|stdout
expr_stmt|;
else|else
name|outf
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
name|append_to_tagfile
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outf
condition|)
block|{
name|perror
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|VMS
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
while|while
condition|(
name|gfnames
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
operator|&
name|got_err
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|got_err
condition|)
block|{
name|error
argument_list|(
literal|"Can't find file %s\n"
argument_list|,
name|this_file
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
else|else
block|{
name|this_file
operator|=
name|massage_name
argument_list|(
name|this_file
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|}     }
comment|/* solely to balance out the ifdef'd parens above */
endif|#
directive|endif
else|#
directive|else
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|this_file
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
endif|#
directive|endif
comment|/* Input file named "-" means read file names from stdin 	     and use them.  */
if|if
condition|(
name|streq
argument_list|(
name|this_file
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|readline
argument_list|(
operator|&
name|filename_lb
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|filename_lb
operator|.
name|buffer
argument_list|)
operator|>
literal|0
condition|)
name|process_file
argument_list|(
name|filename_lb
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|process_file
argument_list|(
name|this_file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|emacs_tags_format
condition|)
block|{
while|while
condition|(
name|nincluded_files
operator|--
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"\f\n%s,include\n"
argument_list|,
operator|*
name|included_files
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|outf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cxref_style
condition|)
block|{
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update
condition|)
block|{
comment|/* update cannot be set under VMS, so we may assume that argc 	 and argv have not been munged.  */
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"mv %s OTAGS;fgrep -v '\t%s\t' OTAGS>%s;rm OTAGS"
argument_list|,
name|outfile
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|append_to_tagfile
operator|++
expr_stmt|;
block|}
name|outf
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
name|append_to_tagfile
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outf
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
block|}
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|outf
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
condition|)
block|{
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"sort %s -o %s"
argument_list|,
name|outfile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
block|}
comment|/*  * This routine is called on each file argument.  */
name|void
name|process_file
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|stat
name|stat_buf
decl_stmt|;
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|stat_buf
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|S_ISREG
define|#
directive|define
name|S_ISREG
parameter_list|(
name|mode
parameter_list|)
value|(((mode)& S_IFMT) == S_IFREG)
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISLNK
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFLNK
argument_list|)
define|#
directive|define
name|S_ISLNK
parameter_list|(
name|mode
parameter_list|)
value|(((mode)& S_IFMT) == S_IFLNK)
endif|#
directive|endif
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
ifdef|#
directive|ifdef
name|S_ISLNK
operator|&&
operator|!
name|S_ISLNK
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Skipping %s: it is not a regular file.\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|streq
argument_list|(
name|file
argument_list|,
name|outfile
argument_list|)
operator|&&
operator|!
name|streq
argument_list|(
name|outfile
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Skipping inclusion of %s in self.\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|emacs_tags_format
condition|)
block|{
name|char
modifier|*
name|cp
init|=
name|rindex
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
condition|)
operator|++
name|cp
expr_stmt|;
else|else
name|cp
operator|=
name|file
expr_stmt|;
block|}
name|find_entries
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|emacs_tags_format
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"\f\n%s,%d\n"
argument_list|,
name|file
argument_list|,
name|total_size_of_entries
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free_tree
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/*  * This routine sets up the boolean psuedo-functions which work  * by seting boolean flags dependent upon the corresponding character  * Every char which is NOT in that string is not a white char.  Therefore,  * all of the array "_wht" is set to FALSE, and then the elements  * subscripted by the chars in "white" are set to TRUE.  Thus "_wht"  * of a char is TRUE if it is the string "white", else FALSE.  */
name|void
name|init
parameter_list|()
block|{
name|reg
name|char
modifier|*
name|sp
decl_stmt|;
name|reg
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0177
condition|;
name|i
operator|++
control|)
block|{
name|_wht
index|[
name|i
index|]
operator|=
name|_etk
index|[
name|i
index|]
operator|=
name|_itk
index|[
name|i
index|]
operator|=
name|_btk
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
name|_gd
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|white
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_wht
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|endtk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_etk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|intk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_itk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|begtk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_btk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|notgd
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_gd
index|[
operator|*
name|sp
index|]
operator|=
name|FALSE
expr_stmt|;
name|_wht
index|[
literal|0
index|]
operator|=
name|_wht
index|[
literal|'\n'
index|]
expr_stmt|;
name|_etk
index|[
literal|0
index|]
operator|=
name|_etk
index|[
literal|'\n'
index|]
expr_stmt|;
name|_btk
index|[
literal|0
index|]
operator|=
name|_btk
index|[
literal|'\n'
index|]
expr_stmt|;
name|_itk
index|[
literal|0
index|]
operator|=
name|_itk
index|[
literal|'\n'
index|]
expr_stmt|;
name|_gd
index|[
literal|0
index|]
operator|=
name|_gd
index|[
literal|'\n'
index|]
expr_stmt|;
block|}
comment|/*  * This routine opens the specified file and calls the function  * which finds the function and type definitions.  */
name|void
name|find_entries
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|void
name|prolog_funcs
parameter_list|()
function_decl|;
name|inf
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
name|curfile
operator|=
name|savestr
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rindex
argument_list|(
name|file
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|header_file
operator|=
operator|(
name|cp
operator|&&
operator|(
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"h"
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* .tex, .aux or .bbl implies LaTeX source code */
if|if
condition|(
name|cp
operator|&&
operator|(
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"tex"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"aux"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"bbl"
argument_list|)
operator|)
condition|)
block|{
name|TEX_funcs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
goto|goto
name|close_and_return
goto|;
block|}
comment|/* .l or .el or .lisp (or .cl or .clisp or ...) implies lisp source code */
if|if
condition|(
name|cp
operator|&&
operator|(
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"l"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"el"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"lsp"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"lisp"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"cl"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"clisp"
argument_list|)
operator|)
condition|)
block|{
name|L_funcs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
goto|goto
name|close_and_return
goto|;
block|}
comment|/* .scm or .sm or .scheme or ... implies scheme source code */
if|if
condition|(
name|cp
operator|&&
operator|(
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"sm"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"scm"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"scheme"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"t"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"sch"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"SM"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"SCM"
argument_list|)
comment|/* The `SCM' or `scm' prefix with a version number */
operator|||
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'m'
operator|&&
name|cp
index|[
operator|-
literal|2
index|]
operator|==
literal|'c'
operator|&&
name|cp
index|[
operator|-
literal|3
index|]
operator|==
literal|'s'
operator|&&
name|string_numeric_p
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
operator|)
operator|||
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'M'
operator|&&
name|cp
index|[
operator|-
literal|2
index|]
operator|==
literal|'C'
operator|&&
name|cp
index|[
operator|-
literal|3
index|]
operator|==
literal|'S'
operator|&&
name|string_numeric_p
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
operator|)
operator|)
condition|)
block|{
name|Scheme_funcs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Assume that ".s" or ".a" is assembly code. -wolfgang.  */
if|if
condition|(
name|cp
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'s'
operator|||
name|cp
index|[
literal|1
index|]
operator|==
literal|'a'
operator|)
operator|&&
name|cp
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|Asm_funcs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* .C or .H or .cxx or .hxx or .cc: a C++ file */
if|if
condition|(
name|cp
operator|&&
operator|(
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"C"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"H"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"cxx"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"hxx"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"cc"
argument_list|)
operator|)
condition|)
block|{
name|C_entries
argument_list|(
name|C_PLPL
argument_list|)
expr_stmt|;
comment|/* C++ */
goto|goto
name|close_and_return
goto|;
block|}
comment|/* .cs or .hs: a C* file */
if|if
condition|(
name|cp
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'c'
operator|||
name|cp
index|[
literal|1
index|]
operator|==
literal|'h'
operator|)
operator|&&
name|cp
index|[
literal|2
index|]
operator|==
literal|'s'
operator|&&
name|cp
index|[
literal|3
index|]
operator|==
literal|'\0'
condition|)
block|{
name|C_entries
argument_list|(
name|C_STAR
argument_list|)
expr_stmt|;
goto|goto
name|close_and_return
goto|;
block|}
comment|/* .pl implies prolog source code */
if|if
condition|(
name|cp
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"pl"
argument_list|)
condition|)
block|{
name|prolog_funcs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
goto|goto
name|close_and_return
goto|;
block|}
comment|/* .p or .pas: a Pascal file */
if|if
condition|(
name|cp
operator|&&
operator|(
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"p"
argument_list|)
operator|||
name|streq
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"pas"
argument_list|)
operator|)
condition|)
block|{
name|PAS_funcs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
goto|goto
name|close_and_return
goto|;
block|}
comment|/* if not a .c or .h or .y file, try fortran */
elseif|else
if|if
condition|(
name|cp
operator|&&
operator|(
operator|(
name|cp
index|[
literal|1
index|]
operator|!=
literal|'c'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'h'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'y'
operator|)
operator|||
operator|(
name|cp
index|[
literal|1
index|]
operator|!=
literal|0
operator|&&
name|cp
index|[
literal|2
index|]
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|PF_funcs
argument_list|(
name|inf
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|close_and_return
goto|;
name|rewind
argument_list|(
name|inf
argument_list|)
expr_stmt|;
comment|/* no fortran tags found, try C */
block|}
name|C_entries
argument_list|(
name|cplusplus
condition|?
name|C_PLPL
else|:
literal|0
argument_list|)
expr_stmt|;
name|close_and_return
label|:
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
comment|/* Nonzero if string STR is composed of digits.  */
name|int
name|string_numeric_p
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|<
literal|'0'
operator|||
operator|*
name|str
operator|>
literal|'9'
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/* Record a tag. */
comment|/* Should take a TOKEN* instead!! */
name|void
name|pfnote
parameter_list|(
name|name
parameter_list|,
name|is_func
parameter_list|,
name|rewritten
parameter_list|,
name|linestart
parameter_list|,
name|linelen
parameter_list|,
name|lno
parameter_list|,
name|cno
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* tag name */
name|logical
name|is_func
decl_stmt|;
comment|/* function or type name? */
name|logical
name|rewritten
decl_stmt|;
comment|/* tag different from text of definition? */
name|char
modifier|*
name|linestart
decl_stmt|;
name|int
name|linelen
decl_stmt|;
name|int
name|lno
decl_stmt|;
name|long
name|cno
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fp
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|np
decl_stmt|;
name|char
name|tem
index|[
literal|51
index|]
decl_stmt|;
name|char
name|c
decl_stmt|;
name|np
operator|=
operator|(
name|NODE
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|emacs_tags_format
condition|)
block|{
comment|/* It's okay to output early in etags -- it only disrupts the 	   * character count of the tag entries, which is no longer used 	   * by tags.el anyway. 	   */
name|error
argument_list|(
literal|"too many entries to sort"
argument_list|)
expr_stmt|;
block|}
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free_tree
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|NULL
expr_stmt|;
name|np
operator|=
name|xnew
argument_list|(
literal|1
argument_list|,
name|NODE
argument_list|)
expr_stmt|;
block|}
comment|/* If ctags mode, change name "main" to M<thisfilename>. */
if|if
condition|(
operator|!
name|emacs_tags_format
operator|&&
operator|!
name|cxref_style
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
name|fp
operator|=
name|rindex
argument_list|(
name|curfile
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|name
operator|=
name|concat
argument_list|(
literal|"M"
argument_list|,
name|fp
operator|==
literal|0
condition|?
name|curfile
else|:
name|fp
operator|+
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|fp
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|&&
name|fp
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|fp
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|fp
operator|=
literal|0
expr_stmt|;
name|rewritten
operator|=
name|TRUE
expr_stmt|;
block|}
name|np
operator|->
name|name
operator|=
name|savestr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|np
operator|->
name|file
operator|=
name|curfile
expr_stmt|;
name|np
operator|->
name|is_func
operator|=
name|is_func
expr_stmt|;
name|np
operator|->
name|rewritten
operator|=
name|rewritten
expr_stmt|;
name|np
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
comment|/* UNCOMMENT THE +1 HERE: */
name|np
operator|->
name|cno
operator|=
name|cno
comment|/* + 1 */
expr_stmt|;
comment|/* our char numbers are 0-base; emacs's are 1-base */
name|np
operator|->
name|left
operator|=
name|np
operator|->
name|right
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|emacs_tags_format
condition|)
block|{
name|c
operator|=
name|linestart
index|[
name|linelen
index|]
expr_stmt|;
name|linestart
index|[
name|linelen
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cxref_style
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|tem
argument_list|,
name|strlen
argument_list|(
name|linestart
argument_list|)
operator|<
literal|50
condition|?
literal|"%s$"
else|:
literal|"%.50s"
argument_list|,
name|linestart
argument_list|)
expr_stmt|;
name|linestart
operator|=
name|tem
expr_stmt|;
block|}
name|np
operator|->
name|pat
operator|=
name|savestr
argument_list|(
name|linestart
argument_list|)
expr_stmt|;
if|if
condition|(
name|emacs_tags_format
condition|)
block|{
name|linestart
index|[
name|linelen
index|]
operator|=
name|c
expr_stmt|;
block|}
name|add_node
argument_list|(
name|np
argument_list|,
operator|&
name|head
argument_list|)
expr_stmt|;
block|}
comment|/*  * free_tree ()  *	recurse on left children, iterate on right children.  */
name|void
name|free_tree
parameter_list|(
name|node
parameter_list|)
specifier|register
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
while|while
condition|(
name|node
condition|)
block|{
specifier|register
name|NODE
modifier|*
name|node_right
init|=
name|node
operator|->
name|right
decl_stmt|;
name|free_tree
argument_list|(
name|node
operator|->
name|left
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|pat
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|node_right
expr_stmt|;
block|}
block|}
comment|/*  * add_node ()  *	Adds a node to the tree of nodes.  In etags mode, we don't keep  *	it sorted; we just keep a linear list.  In ctags mode, maintain  *	an ordered tree, with no attempt at balancing.  *  *	add_node is the only function allowed to add nodes, so it can  *	maintain state.  */
name|void
name|add_node
parameter_list|(
name|node
parameter_list|,
name|cur_node_p
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|,
decl|*
modifier|*
name|cur_node_p
decl_stmt|;
block|{
specifier|register
name|int
name|dif
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|cur_node
init|=
operator|*
name|cur_node_p
decl_stmt|;
specifier|static
name|NODE
modifier|*
name|last_node
init|=
name|NULL
decl_stmt|;
comment|/* careful */
if|if
condition|(
name|cur_node
operator|==
name|NULL
condition|)
block|{
operator|*
name|cur_node_p
operator|=
name|node
expr_stmt|;
name|last_node
operator|=
name|node
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|emacs_tags_format
condition|)
block|{
comment|/* Etags Mode */
if|if
condition|(
operator|!
name|last_node
condition|)
name|fatal
argument_list|(
literal|"internal error in add_node"
argument_list|)
expr_stmt|;
name|last_node
operator|->
name|right
operator|=
name|node
expr_stmt|;
name|last_node
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
comment|/* Ctags Mode */
name|dif
operator|=
name|strcmp
argument_list|(
name|node
operator|->
name|name
argument_list|,
name|cur_node
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/*        * If this tag name matches an existing one, then        * do not add the node, but maybe print a warning.        */
if|if
condition|(
operator|!
name|dif
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|file
operator|==
name|cur_node
operator|->
name|file
condition|)
block|{
if|if
condition|(
operator|!
name|no_warnings
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate entry in file %s, line %d: %s\n"
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|lineno
argument_list|,
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Second entry ignored\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|cur_node
operator|->
name|been_warned
operator|&&
operator|!
name|no_warnings
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate entry in files %s and %s: %s (Warning only)\n"
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|cur_node
operator|->
name|file
argument_list|,
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|cur_node
operator|->
name|been_warned
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
comment|/* Maybe refuse to add duplicate nodes.  */
if|if
condition|(
operator|!
name|permit_duplicates
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|node
operator|->
name|name
argument_list|,
name|cur_node
operator|->
name|name
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|node
operator|->
name|file
argument_list|,
name|cur_node
operator|->
name|file
argument_list|)
condition|)
return|return;
block|}
comment|/* Actually add the node */
name|add_node
argument_list|(
name|node
argument_list|,
name|dif
operator|<
literal|0
condition|?
operator|&
name|cur_node
operator|->
name|left
else|:
operator|&
name|cur_node
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|put_entries
parameter_list|(
name|node
parameter_list|)
name|reg
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
name|reg
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
comment|/* Output subentries that precede this one */
name|put_entries
argument_list|(
name|node
operator|->
name|left
argument_list|)
expr_stmt|;
comment|/* Output this entry */
if|if
condition|(
name|emacs_tags_format
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|rewritten
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%s\177%s\001%d,%d\n"
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|node
operator|->
name|pat
argument_list|,
name|node
operator|->
name|lno
argument_list|,
name|node
operator|->
name|cno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%s\177%d,%d\n"
argument_list|,
name|node
operator|->
name|pat
argument_list|,
name|node
operator|->
name|lno
argument_list|,
name|node
operator|->
name|cno
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|cxref_style
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%s\t%s\t"
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|node
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|is_func
condition|)
block|{
comment|/* a function */
name|putc
argument_list|(
name|searchar
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'^'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|node
operator|->
name|pat
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\\'
operator|||
operator|*
name|sp
operator|==
name|searchar
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|sp
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|searchar
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* a typedef; text pattern inadequate */
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%d"
argument_list|,
name|node
operator|->
name|lno
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vgrind_style
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s %s %d\n"
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|node
operator|->
name|file
argument_list|,
operator|(
name|node
operator|->
name|lno
operator|+
literal|63
operator|)
operator|/
literal|64
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%-16s %3d %-16s %s\n"
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|node
operator|->
name|lno
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|node
operator|->
name|pat
argument_list|)
expr_stmt|;
comment|/* Output subentries that follow this one */
name|put_entries
argument_list|(
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
comment|/* Length of a number's decimal representation. */
name|int
name|number_len
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
name|num
condition|;
name|num
operator|/=
literal|10
control|)
operator|++
name|len
expr_stmt|;
return|return
name|len
return|;
block|}
comment|/*  * Return total number of characters that put_entries will output for  * the nodes in the subtree of the specified node.  Works only if emacs_tags_format  * is set, but called only in that case.  This count is irrelevant with  * the new tags.el, but is still supplied for backward compatibility.  */
name|int
name|total_size_of_entries
parameter_list|(
name|node
parameter_list|)
name|reg
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
name|reg
name|int
name|total
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|right
control|)
block|{
comment|/* Count left subentries. */
name|total
operator|+=
name|total_size_of_entries
argument_list|(
name|node
operator|->
name|left
argument_list|)
expr_stmt|;
comment|/* Count this entry */
name|total
operator|+=
name|strlen
argument_list|(
name|node
operator|->
name|pat
argument_list|)
operator|+
literal|1
expr_stmt|;
name|total
operator|+=
name|number_len
argument_list|(
operator|(
name|long
operator|)
name|node
operator|->
name|lno
argument_list|)
operator|+
literal|1
operator|+
name|number_len
argument_list|(
name|node
operator|->
name|cno
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|rewritten
condition|)
name|total
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* \001name */
block|}
return|return
name|total
return|;
block|}
comment|/*  * The C symbol tables.  */
name|Stab
modifier|*
name|C_stab
decl_stmt|,
modifier|*
name|C_PLPL_stab
decl_stmt|,
modifier|*
name|C_STAR_stab
decl_stmt|;
comment|/*  * SYNOPSIS  *	Stab *get_C_stab (int c_ext);  */
define|#
directive|define
name|get_C_stab
parameter_list|(
name|c_ext
parameter_list|)
value|((c_ext&C_STAR) ? C_STAR_stab :		\ 			   c_ext ? C_PLPL_stab :			\ 			   C_stab)
name|void
name|add_keyword
parameter_list|(
name|stab
parameter_list|,
name|sym
parameter_list|,
name|type
parameter_list|)
name|Stab
modifier|*
name|stab
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
name|enum
name|sym_type
name|type
decl_stmt|;
block|{
name|stab_search
argument_list|(
name|stab
argument_list|,
name|sym
argument_list|,
name|strlen
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
name|Stab
modifier|*
name|C_create_stab
parameter_list|(
name|c_ext
parameter_list|)
name|int
name|c_ext
decl_stmt|;
block|{
name|Stab
modifier|*
name|stab
decl_stmt|;
name|stab
operator|=
name|stab_create
argument_list|()
expr_stmt|;
comment|/* C, C++ and C* */
if|if
condition|(
name|c_ext
operator|&
name|C_PLPL
condition|)
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"class"
argument_list|,
name|st_C_struct
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_ext
operator|&
name|C_STAR
condition|)
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"domain"
argument_list|,
name|st_C_struct
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"union"
argument_list|,
name|st_C_struct
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"struct"
argument_list|,
name|st_C_struct
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"enum"
argument_list|,
name|st_C_enum
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"typedef"
argument_list|,
name|st_C_typedef
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"define"
argument_list|,
name|st_C_define
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"long"
argument_list|,
name|st_C_typespec
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"short"
argument_list|,
name|st_C_typespec
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"int"
argument_list|,
name|st_C_typespec
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"char"
argument_list|,
name|st_C_typespec
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"float"
argument_list|,
name|st_C_typespec
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"double"
argument_list|,
name|st_C_typespec
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"signed"
argument_list|,
name|st_C_typespec
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"unsigned"
argument_list|,
name|st_C_typespec
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"const"
argument_list|,
name|st_C_typespec
argument_list|)
expr_stmt|;
name|add_keyword
argument_list|(
name|stab
argument_list|,
literal|"volatile"
argument_list|,
name|st_C_typespec
argument_list|)
expr_stmt|;
return|return
name|stab
return|;
block|}
name|void
name|C_create_stabs
parameter_list|()
block|{
name|C_stab
operator|=
name|C_create_stab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|C_PLPL_stab
operator|=
name|C_create_stab
argument_list|(
name|C_PLPL
argument_list|)
expr_stmt|;
name|C_STAR_stab
operator|=
name|C_create_stab
argument_list|(
name|C_STAR
operator||
name|C_PLPL
argument_list|)
expr_stmt|;
block|}
comment|/*  * C_entries ()  *	This routine finds functions and typedefs in C syntax and adds them  *	to the list.  */
define|#
directive|define
name|CNL_SAVE_DEFINEDEF
define|\
value|{									\   prev_linepos = linepos;						\   SET_FILEPOS (linepos, inf, charno);					\   lineno++;								\   charno += readline (&lb, inf);					\   lp = lb.buffer;							\ }
define|#
directive|define
name|CNL
define|\
value|{									\   CNL_SAVE_DEFINEDEF;							\   definedef = dnone;							\ }
name|void
name|C_entries
parameter_list|(
name|c_ext
parameter_list|)
name|int
name|c_ext
decl_stmt|;
comment|/* extension of C? */
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* latest char read; '\0' for end of line */
specifier|register
name|int
name|tokoff
decl_stmt|;
comment|/* offset in line of beginning of latest token */
specifier|register
name|int
name|toklen
decl_stmt|;
comment|/* length of latest token */
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
comment|/* pointer one beyond the character `c' */
name|logical
name|incomm
decl_stmt|,
name|inquote
decl_stmt|,
name|inchar
decl_stmt|,
name|midtoken
decl_stmt|;
name|int
name|level
decl_stmt|;
comment|/* current curly brace level */
name|char
name|tokb
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
name|definedef
operator|=
name|dnone
expr_stmt|;
name|gotone
operator|=
name|midtoken
operator|=
name|inquote
operator|=
name|inchar
operator|=
name|incomm
operator|=
name|FALSE
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
name|tydef
operator|=
name|none
expr_stmt|;
name|next_token_is_func
operator|=
literal|0
expr_stmt|;
name|C_create_stabs
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|inf
argument_list|)
condition|)
block|{
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* If we're at the end of the line, the next character is a 	     '\0'; don't skip it, because it's the thing that tells us 	     to read the next line.  */
if|if
condition|(
operator|*
name|lp
operator|==
literal|0
condition|)
continue|continue;
name|lp
operator|++
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incomm
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
operator|*
name|lp
operator|==
literal|'/'
condition|)
block|{
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
name|incomm
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|inquote
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|inquote
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inchar
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|inchar
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'"'
case|:
name|inquote
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'\''
case|:
name|inchar
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|lp
operator|==
literal|'*'
condition|)
block|{
name|lp
operator|++
expr_stmt|;
name|incomm
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_ext
operator|&&
operator|*
name|lp
operator|==
literal|'/'
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
break|break;
block|}
continue|continue;
case|case
literal|'#'
case|:
if|if
condition|(
name|lp
operator|==
name|lb
operator|.
name|buffer
operator|+
literal|1
operator|&&
name|definedef
operator|==
name|dnone
condition|)
name|definedef
operator|=
name|dsharpseen
expr_stmt|;
continue|continue;
comment|/* 	     * The next two are to help the strucdef state machine. 	     * They break when they are finished, so they don't interfere 	     * with anything else that is going on. 	     */
case|case
literal|':'
case|:
if|if
condition|(
name|structdef
operator|==
name|stagseen
condition|)
name|structdef
operator|=
name|scolonseen
expr_stmt|;
break|break;
comment|/* Not a struct definition when semicolon seen in non-sinbody context. */
case|case
literal|';'
case|:
if|if
condition|(
name|structdef
operator|!=
name|snone
operator|&&
name|structdef
operator|!=
name|sinbody
condition|)
block|{
name|structdef
operator|=
name|snone
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|structtag
argument_list|,
literal|"<error 1>"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'{'
case|:
if|if
condition|(
name|tydef
operator|==
name|begin
condition|)
block|{
name|tydef
operator|=
name|middle
expr_stmt|;
block|}
switch|switch
condition|(
name|structdef
condition|)
block|{
case|case
name|skeyseen
case|:
comment|/* unnamed struct */
name|structtag
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|stagseen
case|:
case|case
name|scolonseen
case|:
comment|/* named struct */
name|structdef
operator|=
name|sinbody
expr_stmt|;
break|break;
block|}
name|level
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'}'
case|:
if|if
condition|(
operator|!
name|noindentypedefs
operator|&&
name|lp
operator|==
name|lb
operator|.
name|buffer
operator|+
literal|1
condition|)
name|level
operator|=
literal|0
expr_stmt|;
comment|/* reset level if first column */
elseif|else
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|level
operator|--
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
operator|&&
name|tydef
operator|==
name|middle
condition|)
block|{
name|tydef
operator|=
name|end
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|structdef
operator|=
name|snone
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|structtag
argument_list|,
literal|"<error 2>"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|LEVEL_OK_FOR_FUNCDEF
argument_list|()
operator|&&
operator|!
name|inquote
operator|&&
operator|!
name|incomm
operator|&&
name|gotone
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|midtoken
condition|)
block|{
if|if
condition|(
name|endtoken
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c_ext
operator|&&
name|c
operator|==
literal|':'
operator|&&
operator|*
name|lp
operator|==
literal|':'
operator|&&
name|intoken
argument_list|(
operator|*
operator|(
name|lp
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
comment|/* 		       * This handles :: in the middle, but not at beginning 		       * of an identifier. 		       */
name|lp
operator|+=
literal|2
expr_stmt|;
name|toklen
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
comment|/* The following is no longer true, 			 now that we advance to the next line 			 at the end of processing the character.  */
comment|/* 		       * We've just finished lexing an identifier. 		       * Note that if `c' is '\0', `lb' is the NEXT 		       * line, `lp' points to the beginning of it, and 		       * old pointers into `lb.buffer' may no longer be 		       * valid, since `lb.buffer' may have been 		       * reallocated.  In this case (which corresponds 		       * to an identifier followed immediately by a 		       * newline), we re-read the line into lb1. 		       * 		       * This would be faster if the previous line's 		       * buffer were always saved. 		       */
name|logical
name|is_func
decl_stmt|;
name|char
modifier|*
name|tok_linebuf
decl_stmt|;
name|TOKEN
name|tok
decl_stmt|;
name|logical
name|bingo
decl_stmt|,
name|tok_at_end_of_line
decl_stmt|;
name|char
modifier|*
name|lp_tmp
decl_stmt|;
comment|/* addressable */
if|#
directive|if
literal|0
block|if (c == '\0') 			{ 			  getline (GET_COOKIE (prev_linepos)); 			  tok_linebuf = lb1.buffer; 			  tok_at_end_of_line = TRUE; 			  tok.linestart = prev_linepos; 			  tok.lineno = lineno - 1; 			} 		      else
endif|#
directive|endif
block|{
name|tok_linebuf
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
name|tok_at_end_of_line
operator|=
name|FALSE
expr_stmt|;
name|tok
operator|.
name|linestart
operator|=
name|linepos
expr_stmt|;
name|tok
operator|.
name|lineno
operator|=
name|lineno
expr_stmt|;
block|}
name|tok
operator|.
name|p
operator|=
name|tok_linebuf
operator|+
name|tokoff
expr_stmt|;
name|tok
operator|.
name|len
operator|=
name|toklen
expr_stmt|;
name|tok
operator|.
name|rewritten
operator|=
name|FALSE
expr_stmt|;
name|lp_tmp
operator|=
name|lp
expr_stmt|;
name|bingo
operator|=
name|consider_token
argument_list|(
name|c
argument_list|,
operator|&
name|lp_tmp
argument_list|,
operator|&
name|tok
argument_list|,
operator|&
name|is_func
argument_list|,
name|c_ext
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|lp
operator|=
name|lp_tmp
expr_stmt|;
if|if
condition|(
name|bingo
condition|)
block|{
if|if
condition|(
name|GET_CHARNO
argument_list|(
name|tok
operator|.
name|linestart
argument_list|)
operator|!=
name|GET_CHARNO
argument_list|(
name|linepos
argument_list|)
operator|&&
operator|!
name|tok_at_end_of_line
condition|)
block|{
comment|/* 			       * Resynchronize tok.p to point into the right 			       * linebuffer. 			       */
name|getline
argument_list|(
name|GET_COOKIE
argument_list|(
name|tok
operator|.
name|linestart
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tok
operator|.
name|rewritten
condition|)
name|tok
operator|.
name|p
operator|=
name|lb1
operator|.
name|buffer
operator|+
operator|(
name|tok
operator|.
name|p
operator|-
name|tok_linebuf
operator|)
expr_stmt|;
name|tok_linebuf
operator|=
name|lb1
operator|.
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|structdef
operator|==
name|sinbody
operator|&&
name|definedef
operator|==
name|dnone
operator|&&
name|is_func
condition|)
block|{
comment|/* function defined in C++ class body */
name|sprintf
argument_list|(
name|tokb
argument_list|,
literal|"%s::%.*s"
argument_list|,
name|structtag
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|?
literal|"_anonymous_"
else|:
name|structtag
argument_list|,
name|tok
operator|.
name|len
argument_list|,
name|tok
operator|.
name|p
argument_list|)
expr_stmt|;
name|tok
operator|.
name|rewritten
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|tokb
argument_list|,
literal|"%.*s"
argument_list|,
name|tok
operator|.
name|len
argument_list|,
name|tok
operator|.
name|p
argument_list|)
expr_stmt|;
block|}
name|pfnote
argument_list|(
name|tokb
argument_list|,
name|is_func
argument_list|,
name|tok
operator|.
name|rewritten
argument_list|,
name|tok_linebuf
argument_list|,
name|tokoff
operator|+
name|toklen
operator|+
operator|(
name|tok_at_end_of_line
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|,
name|tok
operator|.
name|lineno
argument_list|,
name|GET_CHARNO
argument_list|(
name|tok
operator|.
name|linestart
argument_list|)
argument_list|)
expr_stmt|;
name|gotone
operator|=
name|is_func
expr_stmt|;
comment|/* function */
block|}
name|midtoken
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|intoken
argument_list|(
name|c
argument_list|)
condition|)
name|toklen
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|begtoken
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|tokoff
operator|=
name|lp
operator|-
literal|1
operator|-
name|lb
operator|.
name|buffer
expr_stmt|;
name|toklen
operator|=
literal|1
expr_stmt|;
name|midtoken
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Detect end of line, after having handled the last token on the line.  */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|CNL
expr_stmt|;
name|gotone
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|';'
operator|&&
name|tydef
operator|==
name|end
condition|)
comment|/* clean with typedefs */
name|tydef
operator|=
name|none
expr_stmt|;
block|}
block|}
comment|/*  * consider_token ()  *	checks to see if the current token is at the start of a  *	function, or corresponds to a typedef.  It updates the input  *	line pointer *LPP so that the '(' will be in it when it returns.  *  *	*IS_FUNC gets TRUE iff the token is a function.  *	C_EXT is which language we are looking at.  *  *	In the future we will need some way to adjust where the end of  *	the token is; for instance, implementing the C++ keyword  *	`operator' properly will adjust the end of the token to be after  *	whatever follows `operator'.  *  * Globals  *	structdef	IN OUT  *	definedef	IN OUT  *	tydef		IN OUT  */
name|logical
name|consider_token
parameter_list|(
name|c
parameter_list|,
name|lpp
parameter_list|,
name|tokp
parameter_list|,
name|is_func
parameter_list|,
name|c_ext
parameter_list|,
name|level
parameter_list|)
name|reg
name|char
name|c
decl_stmt|;
comment|/* IN: first char after the token */
name|char
modifier|*
modifier|*
name|lpp
decl_stmt|;
comment|/* IN OUT: *lpp points to 2nd char after the token */
name|reg
name|TOKEN
modifier|*
name|tokp
decl_stmt|;
comment|/* IN */
name|logical
modifier|*
name|is_func
decl_stmt|;
comment|/* OUT */
name|int
name|c_ext
decl_stmt|;
comment|/* IN */
name|int
name|level
decl_stmt|;
comment|/* IN */
block|{
name|reg
name|char
modifier|*
name|lp
init|=
operator|*
name|lpp
decl_stmt|;
name|logical
name|firsttok
decl_stmt|;
comment|/* TRUE if have seen first token in ()'s */
name|Stab_entry
modifier|*
name|tokse
init|=
name|stab_find
argument_list|(
name|get_C_stab
argument_list|(
name|c_ext
argument_list|)
argument_list|,
name|tokp
operator|->
name|p
argument_list|,
name|tokp
operator|->
name|len
argument_list|)
decl_stmt|;
name|enum
name|sym_type
name|toktype
init|=
name|stab_type
argument_list|(
name|tokse
argument_list|)
decl_stmt|;
operator|*
name|is_func
operator|=
name|TRUE
expr_stmt|;
comment|/* a function */
comment|/*    * Advance the definedef state machine.  We set `gotone' for good measure;    * it's redundant.    */
switch|switch
condition|(
name|definedef
condition|)
block|{
case|case
name|dnone
case|:
comment|/* We're not on a preprocessor line. */
break|break;
case|case
name|dsharpseen
case|:
if|if
condition|(
name|toktype
operator|==
name|st_C_define
condition|)
block|{
name|definedef
operator|=
name|ddefineseen
expr_stmt|;
name|gotone
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|definedef
operator|=
name|dignorerest
expr_stmt|;
name|gotone
operator|=
name|TRUE
expr_stmt|;
block|}
goto|goto
name|badone
goto|;
case|case
name|ddefineseen
case|:
comment|/*        * Make a tag for any macro.        * This will flub up if there is a newline immediately following        * the macro name.        */
operator|*
name|is_func
operator|=
operator|(
name|c
operator|==
literal|'('
operator|)
expr_stmt|;
name|definedef
operator|=
name|dignorerest
expr_stmt|;
name|gotone
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|is_func
operator|&&
operator|!
name|constantypedefs
condition|)
goto|goto
name|badone
goto|;
goto|goto
name|goodone
goto|;
case|case
name|dignorerest
case|:
goto|goto
name|badone
goto|;
default|default:
name|error
argument_list|(
literal|"internal error: definedef value"
argument_list|)
expr_stmt|;
block|}
comment|/*    * Skip whitespace and comments after the token.  This loop should    * also skip C++ comments.    */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* At whitespace => skip it.  */
if|if
condition|(
name|iswhite
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
block|}
comment|/* At a comment => skip to end of comment.  */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
operator|&&
operator|*
name|lp
operator|==
literal|'*'
condition|)
block|{
comment|/* If we find a comment, skip it.  */
while|while
condition|(
operator|!
operator|(
name|c
operator|==
literal|'*'
operator|&&
operator|*
name|lp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|lp
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
operator|*
name|lp
operator|==
literal|'/'
condition|)
block|{
name|lp
operator|++
expr_stmt|;
comment|/* lp now points past the '/' */
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
comment|/* c is now the --whatever-- after the '/' */
block|}
block|}
else|else
break|break;
comment|/* If we arrived at eof or eol, decide which one it is. 	 If it's eol, advance to the next line.  */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|lp
operator|--
expr_stmt|;
break|break;
block|}
block|}
comment|/*    * If you have custom token types, or when configuration files can    * define custom token types, this switch will be larger.    */
switch|switch
condition|(
name|toktype
condition|)
block|{
case|case
name|st_C_typedef
case|:
if|if
condition|(
name|typedefs
condition|)
block|{
name|tydef
operator|=
name|begin
expr_stmt|;
goto|goto
name|badone
goto|;
block|}
break|break;
case|case
name|st_C_typespec
case|:
if|if
condition|(
name|tydef
operator|==
name|begin
operator|||
name|tydef
operator|==
name|end
condition|)
block|{
name|tydef
operator|=
name|end
expr_stmt|;
goto|goto
name|badone
goto|;
block|}
break|break;
block|}
comment|/*    * This structdef business is currently only invoked when level==0.    * It should be recursively invoked whatever the level, and a stack of    * states kept, to allow for definitions of structs within structs.    *    * This structdef business is NOT invoked when we are ctags and the    * file is plain C.  This is because a struct tag may have the same    * name as another tag, and this loses with ctags.    *    * This if statement deals with the tydef state machine as follows: if    * tydef==begin and token is struct/union/class/enum, goto badone.    * All the other code here is for the structdef state machine.    */
switch|switch
condition|(
name|toktype
condition|)
block|{
case|case
name|st_C_struct
case|:
case|case
name|st_C_enum
case|:
if|if
condition|(
name|tydef
operator|==
name|begin
operator|||
operator|(
name|typedefs_and_cplusplus
operator|&&
name|level
operator|==
literal|0
operator|&&
name|structdef
operator|==
name|snone
operator|)
condition|)
block|{
name|structdef
operator|=
name|skeyseen
expr_stmt|;
name|structkey
operator|=
name|tokse
expr_stmt|;
block|}
goto|goto
name|badone
goto|;
block|}
if|if
condition|(
name|structdef
operator|==
name|skeyseen
condition|)
block|{
comment|/* If next char is '{' or (for C++) ':', found a structure tag. */
if|if
condition|(
name|c
operator|==
literal|'{'
operator|||
operator|(
name|c_ext
operator|&&
name|c
operator|==
literal|':'
operator|)
condition|)
block|{
comment|/* 	   * We should do this slightly differently for straight C: 	   * instead of defining `tag', as we now do, we should define 	   * `struct tag'.  (Do this only if the find-tag defaulting is 	   * done on a sophisticated per-mode basis, so that if the user 	   * says meta-. anywhere in `struct foo', the default comes out 	   * `struct foo', not `struct' or `foo'.)  This will require 	   * remembering which keyword (struct/union/class/enum) we saw, as a 	   * Stab_entry* -- this will also make it possible to merge the 	   * skeyseen and senumseen states, if we want. 	   */
if|if
condition|(
name|stab_type
argument_list|(
name|structkey
argument_list|)
operator|==
name|st_C_struct
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|structtag
argument_list|,
name|tokp
operator|->
name|p
argument_list|,
name|tokp
operator|->
name|len
argument_list|)
expr_stmt|;
name|structtag
index|[
name|tokp
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* for struct/union/class */
name|structdef
operator|=
name|stagseen
expr_stmt|;
block|}
else|else
block|{
name|structtag
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* for enum */
block|}
operator|*
name|is_func
operator|=
name|FALSE
expr_stmt|;
comment|/* not a function */
goto|goto
name|goodone
goto|;
block|}
else|else
block|{
comment|/* Not a definition: reset structdef */
name|structdef
operator|=
name|snone
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|structtag
argument_list|,
literal|"<error 3>"
argument_list|)
expr_stmt|;
block|}
comment|/* Now what?  And how does/should this stuff interact with tydef?? */
comment|/* Also maybe reset lp to *lpp for benefit of the function finding code. */
block|}
if|if
condition|(
name|tydef
operator|==
name|begin
condition|)
block|{
name|tydef
operator|=
name|end
expr_stmt|;
goto|goto
name|badone
goto|;
block|}
if|if
condition|(
name|tydef
operator|==
name|end
condition|)
block|{
operator|*
name|is_func
operator|=
literal|0
expr_stmt|;
goto|goto
name|goodone
goto|;
block|}
comment|/* Detect GNUmacs's function-defining macros. */
if|if
condition|(
name|definedef
operator|==
name|dnone
condition|)
block|{
if|if
condition|(
name|strneq
argument_list|(
name|tokp
operator|->
name|p
argument_list|,
literal|"DEF"
argument_list|,
literal|3
argument_list|)
operator|||
name|strneq
argument_list|(
name|tokp
operator|->
name|p
argument_list|,
literal|"ENTRY"
argument_list|,
literal|5
argument_list|)
operator|||
name|strneq
argument_list|(
name|tokp
operator|->
name|p
argument_list|,
literal|"SYSCALL"
argument_list|,
literal|7
argument_list|)
operator|||
name|strneq
argument_list|(
name|tokp
operator|->
name|p
argument_list|,
literal|"PSEUDO"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|next_token_is_func
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|badone
goto|;
block|}
elseif|else
if|if
condition|(
name|strneq
argument_list|(
name|tokp
operator|->
name|p
argument_list|,
literal|"EXFUN"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|next_token_is_func
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|badone
goto|;
block|}
block|}
if|if
condition|(
name|next_token_is_func
condition|)
block|{
name|next_token_is_func
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|goodone
goto|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
goto|goto
name|badone
goto|;
name|firsttok
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|lp
operator|++
operator|)
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|lp
operator|--
expr_stmt|;
break|break;
block|}
comment|/* 	* This line used to confuse ctags: 	*	int	(*oldhup)(); 	* This fixes it. A nonwhite char before the first 	* token, other than a / (in case of a comment in there) 	* makes this not a declaration. 	*/
if|if
condition|(
name|begtoken
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'/'
condition|)
name|firsttok
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|iswhite
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|firsttok
condition|)
goto|goto
name|badone
goto|;
block|}
while|while
condition|(
name|iswhite
argument_list|(
name|c
operator|=
operator|*
name|lp
operator|++
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|lp
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|isgood
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|badone
goto|;
name|goodone
label|:
operator|*
name|lpp
operator|=
name|lp
operator|-
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
name|badone
label|:
operator|*
name|lpp
operator|=
name|lp
operator|-
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|void
name|getline
parameter_list|(
name|atcookie
parameter_list|)
name|long
name|atcookie
decl_stmt|;
block|{
name|long
name|saveftell
init|=
name|ftell
argument_list|(
name|inf
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|inf
argument_list|,
name|atcookie
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|readline
argument_list|(
operator|&
name|lb1
argument_list|,
name|inf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|inf
argument_list|,
name|saveftell
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Fortran parsing */
name|char
modifier|*
name|dbp
decl_stmt|;
name|int
name|pfcnt
decl_stmt|;
name|int
name|PF_funcs
parameter_list|(
name|fi
parameter_list|)
name|FILE
modifier|*
name|fi
decl_stmt|;
block|{
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|pfcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|=
name|charno
expr_stmt|;
name|charno
operator|+=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|'%'
condition|)
name|dbp
operator|++
expr_stmt|;
comment|/* Ratfor escape to fortran */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
operator|*
name|dbp
operator||
literal|' '
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"integer"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"real"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"logical"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"complex"
argument_list|)
operator|||
name|tail
argument_list|(
literal|"character"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|tail
argument_list|(
literal|"precision"
argument_list|)
condition|)
break|break;
continue|continue;
block|}
break|break;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
operator|*
name|dbp
operator||
literal|' '
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"function"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"subroutine"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"program"
argument_list|)
condition|)
block|{
name|getit
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tail
argument_list|(
literal|"procedure"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
return|return
operator|(
name|pfcnt
operator|)
return|;
block|}
name|logical
name|tail
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|&
operator|~
literal|' '
operator|)
operator|==
operator|(
operator|(
operator|*
operator|(
name|dbp
operator|+
name|len
operator|)
operator|)
operator|&
operator|~
literal|' '
operator|)
condition|)
name|cp
operator|++
operator|,
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
name|dbp
operator|+=
name|len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|void
name|takeprec
parameter_list|()
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|!=
literal|'*'
condition|)
return|return;
name|dbp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
block|{
operator|--
name|dbp
expr_stmt|;
comment|/* force failure */
return|return;
block|}
do|do
name|dbp
operator|++
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
do|;
block|}
name|void
name|getit
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
operator|||
operator|(
operator|!
name|isalpha
argument_list|(
operator|*
name|dbp
argument_list|)
operator|&&
operator|*
name|dbp
operator|!=
literal|'_'
operator|&&
operator|*
name|dbp
operator|!=
literal|'$'
operator|)
condition|)
return|return;
for|for
control|(
name|cp
operator|=
name|dbp
operator|+
literal|1
init|;
operator|*
name|cp
operator|&&
operator|(
name|isalpha
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'_'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'$'
operator|)
operator|)
condition|;
name|cp
operator|++
control|)
continue|continue;
name|c
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nambuf
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|lb
operator|.
name|buffer
argument_list|,
name|cp
operator|-
name|lb
operator|.
name|buffer
operator|+
literal|1
argument_list|,
name|lineno
argument_list|,
name|linecharno
argument_list|)
expr_stmt|;
name|pfcnt
operator|++
expr_stmt|;
block|}
comment|/* Handle a file of assembler code.  */
name|void
name|Asm_funcs
parameter_list|(
name|fi
parameter_list|)
name|FILE
modifier|*
name|fi
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|pfcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|=
name|charno
expr_stmt|;
name|charno
operator|+=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|c
operator|=
name|dbp
index|[
name|i
index|]
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|':'
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|c
operator|==
literal|':'
operator|)
condition|)
name|getit
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Added by Mosur Mohan, 4/22/88 */
comment|/* Pascal parsing                */
define|#
directive|define
name|GET_NEW_LINE
define|\
value|{ \   linecharno = charno; lineno++; \   charno += 1 + readline (&lb, inf); \   dbp = lb.buffer; \ }
comment|/*  Locates tags for procedures& functions.  *  Doesn't do any type- or var-definitions.  *  It does look for the keyword "extern" or "forward"  *  immediately following the procedure statement;  *  if found, the tag is skipped.  */
name|void
name|PAS_funcs
parameter_list|(
name|fi
parameter_list|)
name|FILE
modifier|*
name|fi
decl_stmt|;
block|{
name|struct
name|linebuffer
name|tline
decl_stmt|;
comment|/* mostly copied from C_entries */
name|long
name|save_lcno
decl_stmt|;
name|int
name|save_lineno
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|logical
comment|/* each of these flags is TRUE iff: */
name|incomm1
decl_stmt|,
comment|/* point is inside {..} comment */
name|incomm2
decl_stmt|,
comment|/* point is inside (*..*) comment */
name|inquote
decl_stmt|,
comment|/* point is inside '..' string */
name|get_tagname
decl_stmt|,
comment|/* point is after PROCEDURE/FUNCTION */
comment|/*   keyword, so next item = potential tag */
name|found_tag
decl_stmt|,
comment|/* point is after a potential tag */
name|inparms
decl_stmt|,
comment|/* point is within parameter-list */
name|verify_tag
decl_stmt|;
comment|/* point has passed the parm-list, so the */
comment|/*   next token will determine whether    */
comment|/*   this is a FORWARD/EXTERN to be       */
comment|/*   ignored, or whether it is a real tag */
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
operator|*
name|dbp
operator|=
literal|0
expr_stmt|;
name|initbuffer
argument_list|(
operator|&
name|tline
argument_list|)
expr_stmt|;
name|incomm1
operator|=
name|incomm2
operator|=
name|inquote
operator|=
name|FALSE
expr_stmt|;
name|found_tag
operator|=
name|FALSE
expr_stmt|;
comment|/* have a proc name; check if extern */
name|get_tagname
operator|=
name|FALSE
expr_stmt|;
comment|/* have found "procedure" keyword    */
name|inparms
operator|=
name|FALSE
expr_stmt|;
comment|/* found '(' after "proc"            */
name|verify_tag
operator|=
name|FALSE
expr_stmt|;
comment|/* check if "extern" is ahead        */
comment|/* long main loop to get next char */
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|c
operator|=
operator|*
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
comment|/* if end of line */
block|{
name|GET_NEW_LINE
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
operator|(
name|found_tag
operator|&&
name|verify_tag
operator|)
operator|||
name|get_tagname
operator|)
condition|)
name|c
operator|=
operator|*
name|dbp
operator|++
expr_stmt|;
comment|/* only if don't need *dbp pointing */
comment|/* to the beginning of the name of  */
comment|/* the procedure or function        */
block|}
if|if
condition|(
name|incomm1
condition|)
comment|/* within { - } comments */
block|{
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|incomm1
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|incomm2
condition|)
comment|/* within (* - *) comments */
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|dbp
operator|++
operator|)
operator|==
literal|'*'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|GET_NEW_LINE
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
name|incomm2
operator|=
name|FALSE
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|inquote
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|inquote
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
name|inquote
operator|=
name|TRUE
expr_stmt|;
comment|/* found first quote */
continue|continue;
case|case
literal|'{'
case|:
comment|/* found open-{-comment */
name|incomm1
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'('
case|:
if|if
condition|(
operator|*
name|dbp
operator|==
literal|'*'
condition|)
comment|/* found open-(*-comment */
block|{
name|incomm2
operator|=
name|TRUE
expr_stmt|;
name|dbp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found_tag
condition|)
comment|/* found '(' after tag, i.e., parm-list */
name|inparms
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|')'
case|:
comment|/* end of parms list */
if|if
condition|(
name|inparms
condition|)
name|inparms
operator|=
name|FALSE
expr_stmt|;
continue|continue;
case|case
literal|';'
case|:
if|if
condition|(
operator|(
name|found_tag
operator|)
operator|&&
operator|(
operator|!
name|inparms
operator|)
condition|)
comment|/* end of proc or fn stmt */
block|{
name|verify_tag
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|found_tag
operator|)
operator|&&
operator|(
name|verify_tag
operator|)
operator|&&
operator|(
operator|*
name|dbp
operator|!=
literal|' '
operator|)
condition|)
block|{
comment|/* check if this is an "extern" declaration */
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|*
name|dbp
operator|==
literal|'e'
operator|)
operator|||
operator|(
operator|*
name|dbp
operator|==
literal|'E'
operator|)
condition|)
block|{
if|if
condition|(
name|tail
argument_list|(
literal|"extern"
argument_list|)
condition|)
comment|/* superfluous, really! */
block|{
name|found_tag
operator|=
name|FALSE
expr_stmt|;
name|verify_tag
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|dbp
operator|==
literal|'f'
operator|)
operator|||
operator|(
operator|*
name|dbp
operator|==
literal|'F'
operator|)
condition|)
block|{
if|if
condition|(
name|tail
argument_list|(
literal|"forward"
argument_list|)
condition|)
comment|/*  check for forward reference */
block|{
name|found_tag
operator|=
name|FALSE
expr_stmt|;
name|verify_tag
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|found_tag
operator|)
operator|&&
operator|(
name|verify_tag
operator|)
condition|)
comment|/* not external proc, so make tag */
block|{
name|found_tag
operator|=
name|FALSE
expr_stmt|;
name|verify_tag
operator|=
name|FALSE
expr_stmt|;
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|tline
operator|.
name|buffer
argument_list|,
name|cp
operator|-
name|tline
operator|.
name|buffer
operator|+
literal|1
argument_list|,
name|save_lineno
argument_list|,
name|save_lcno
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|get_tagname
condition|)
comment|/* grab name of proc or fn */
block|{
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
comment|/* save all values for later tagging */
name|tline
operator|.
name|size
operator|=
name|lb
operator|.
name|size
expr_stmt|;
name|strcpy
argument_list|(
name|tline
operator|.
name|buffer
argument_list|,
name|lb
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|save_lineno
operator|=
name|lineno
expr_stmt|;
name|save_lcno
operator|=
name|linecharno
expr_stmt|;
comment|/* grab block name */
for|for
control|(
name|cp
operator|=
name|dbp
operator|+
literal|1
init|;
operator|*
name|cp
operator|&&
operator|(
operator|!
name|endtoken
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|;
name|cp
operator|++
control|)
continue|continue;
name|c
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|nambuf
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|dbp
operator|=
name|cp
expr_stmt|;
comment|/* restore dbp to e-o-token */
name|get_tagname
operator|=
name|FALSE
expr_stmt|;
name|found_tag
operator|=
name|TRUE
expr_stmt|;
continue|continue;
comment|/* and proceed to check for "extern" */
block|}
if|if
condition|(
operator|(
operator|!
name|incomm1
operator|)
operator|&&
operator|(
operator|!
name|incomm2
operator|)
operator|&&
operator|(
operator|!
name|inquote
operator|)
operator|&&
operator|(
operator|!
name|found_tag
operator|)
operator|&&
operator|(
operator|!
name|get_tagname
operator|)
condition|)
block|{
comment|/* check for proc/fn keywords */
switch|switch
condition|(
name|c
operator||
literal|' '
condition|)
block|{
case|case
literal|'p'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"rocedure"
argument_list|)
condition|)
comment|/* c = 'p', dbp has advanced */
name|get_tagname
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"unction"
argument_list|)
condition|)
name|get_tagname
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/* while not e-o-f */
block|}
comment|/*  * lisp tag functions  * just look for (def or (DEF  */
name|void
name|L_funcs
parameter_list|(
name|fi
parameter_list|)
name|FILE
modifier|*
name|fi
decl_stmt|;
block|{
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|pfcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|=
name|charno
expr_stmt|;
name|charno
operator|+=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
name|dbp
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
block|{
if|if
condition|(
name|L_isdef
argument_list|(
name|dbp
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
name|L_getit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Check for (foo::defmumble name-defined ... */
while|while
condition|(
operator|*
name|dbp
operator|&&
operator|*
name|dbp
operator|!=
literal|':'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
operator|&&
operator|*
name|dbp
operator|!=
literal|'('
operator|&&
operator|*
name|dbp
operator|!=
literal|')'
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|':'
condition|)
block|{
while|while
condition|(
operator|*
name|dbp
operator|==
literal|':'
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
name|L_isdef
argument_list|(
name|dbp
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
name|L_getit
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|int
name|L_isdef
parameter_list|(
name|dbp
parameter_list|)
name|char
modifier|*
name|dbp
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|dbp
index|[
literal|1
index|]
operator|==
literal|'D'
operator|||
name|dbp
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|2
index|]
operator|==
literal|'E'
operator|||
name|dbp
index|[
literal|2
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|3
index|]
operator|==
literal|'F'
operator|||
name|dbp
index|[
literal|3
index|]
operator|==
literal|'f'
operator|)
operator|)
return|;
block|}
name|void
name|L_getit
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|cp
operator|=
name|dbp
operator|+
literal|1
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'('
operator|&&
operator|*
name|cp
operator|!=
literal|' '
condition|;
name|cp
operator|++
control|)
continue|continue;
name|c
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nambuf
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|lb
operator|.
name|buffer
argument_list|,
name|cp
operator|-
name|lb
operator|.
name|buffer
operator|+
literal|1
argument_list|,
name|lineno
argument_list|,
name|linecharno
argument_list|)
expr_stmt|;
name|pfcnt
operator|++
expr_stmt|;
block|}
comment|/*  * Scheme tag functions  * look for (def... xyzzy  * look for (def... (xyzzy  * look for (def ... ((...(xyzzy ....  * look for (set! xyzzy  */
specifier|static
name|void
name|get_scheme
parameter_list|()
function_decl|;
name|void
name|Scheme_funcs
parameter_list|(
name|fi
parameter_list|)
name|FILE
modifier|*
name|fi
decl_stmt|;
block|{
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|pfcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|=
name|charno
expr_stmt|;
name|charno
operator|+=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
name|dbp
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
operator|(
name|dbp
index|[
literal|1
index|]
operator|==
literal|'D'
operator|||
name|dbp
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|2
index|]
operator|==
literal|'E'
operator|||
name|dbp
index|[
literal|2
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|3
index|]
operator|==
literal|'F'
operator|||
name|dbp
index|[
literal|3
index|]
operator|==
literal|'f'
operator|)
condition|)
block|{
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
comment|/* Skip over open parens and white space */
while|while
condition|(
operator|*
name|dbp
operator|&&
operator|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
operator|||
operator|*
name|dbp
operator|==
literal|'('
operator|)
condition|)
name|dbp
operator|++
expr_stmt|;
name|get_scheme
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dbp
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
operator|(
name|dbp
index|[
literal|1
index|]
operator|==
literal|'S'
operator|||
name|dbp
index|[
literal|1
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|2
index|]
operator|==
literal|'E'
operator|||
name|dbp
index|[
literal|2
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|3
index|]
operator|==
literal|'T'
operator|||
name|dbp
index|[
literal|3
index|]
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|4
index|]
operator|==
literal|'!'
operator|||
name|dbp
index|[
literal|4
index|]
operator|==
literal|'!'
operator|)
operator|&&
operator|(
name|isspace
argument_list|(
name|dbp
index|[
literal|5
index|]
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
comment|/* Skip over white space */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
name|get_scheme
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|static
name|void
name|get_scheme
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
return|return;
comment|/* Go till you get to white space or a syntactic break */
for|for
control|(
name|cp
operator|=
name|dbp
operator|+
literal|1
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'('
operator|&&
operator|*
name|cp
operator|!=
literal|')'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
continue|continue;
comment|/* Null terminate the string there. */
name|c
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Copy the string */
name|strcpy
argument_list|(
name|nambuf
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
comment|/* Unterminate the string */
name|cp
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
comment|/* Announce the change */
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|lb
operator|.
name|buffer
argument_list|,
name|cp
operator|-
name|lb
operator|.
name|buffer
operator|+
literal|1
argument_list|,
name|lineno
argument_list|,
name|linecharno
argument_list|)
expr_stmt|;
name|pfcnt
operator|++
expr_stmt|;
block|}
comment|/* Find tags in TeX and LaTeX input files.  */
comment|/* TEX_toktab is a table of TeX control sequences that define tags.    Each TEX_tabent records one such control sequence.    CONVERT THIS TO USE THE Stab TYPE!! */
struct|struct
name|TEX_tabent
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
struct|;
name|struct
name|TEX_tabent
modifier|*
name|TEX_toktab
init|=
name|NULL
decl_stmt|;
comment|/* Table with tag tokens */
comment|/* Default set of control sequences to put into TEX_toktab.    The value of environment var TEXTAGS is prepended to this.  */
specifier|static
name|char
modifier|*
name|TEX_defenv
init|=
literal|":chapter:section:subsection:subsubsection:eqno:label:ref:cite:bibitem:typeout"
decl_stmt|;
name|void
name|TEX_mode
parameter_list|()
function_decl|;
name|struct
name|TEX_tabent
modifier|*
name|TEX_decode_env
parameter_list|()
function_decl|;
name|void
name|TEX_getit
parameter_list|()
function_decl|;
name|int
name|TEX_Token
parameter_list|()
function_decl|;
specifier|static
name|char
name|TEX_esc
init|=
literal|'\\'
decl_stmt|;
specifier|static
name|char
name|TEX_opgrp
init|=
literal|'{'
decl_stmt|;
specifier|static
name|char
name|TEX_clgrp
init|=
literal|'}'
decl_stmt|;
comment|/*  * TeX/LaTeX scanning loop.  */
name|void
name|TEX_funcs
parameter_list|(
name|fi
parameter_list|)
name|FILE
modifier|*
name|fi
decl_stmt|;
block|{
name|char
modifier|*
name|lasthit
decl_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|pfcnt
operator|=
literal|0
expr_stmt|;
comment|/* Select either \ or ! as escape character.  */
name|TEX_mode
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* Initialize token table once from environment. */
if|if
condition|(
operator|!
name|TEX_toktab
condition|)
name|TEX_toktab
operator|=
name|TEX_decode_env
argument_list|(
literal|"TEXTAGS"
argument_list|,
name|TEX_defenv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|=
name|charno
expr_stmt|;
name|charno
operator|+=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
name|lasthit
operator|=
name|dbp
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
comment|/* Scan each line in file */
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|=
name|charno
expr_stmt|;
name|charno
operator|+=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
name|lasthit
operator|=
name|dbp
expr_stmt|;
while|while
condition|(
name|dbp
operator|=
name|index
argument_list|(
name|dbp
argument_list|,
name|TEX_esc
argument_list|)
condition|)
comment|/* Look at each escape in line */
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|*
operator|(
operator|++
name|dbp
operator|)
condition|)
break|break;
name|linecharno
operator|+=
name|dbp
operator|-
name|lasthit
expr_stmt|;
name|lasthit
operator|=
name|dbp
expr_stmt|;
name|i
operator|=
name|TEX_Token
argument_list|(
name|lasthit
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|i
condition|)
block|{
name|TEX_getit
argument_list|(
name|lasthit
argument_list|,
name|TEX_toktab
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
break|break;
comment|/* We only save a line once */
block|}
block|}
block|}
block|}
block|}
define|#
directive|define
name|TEX_LESC
value|'\\'
define|#
directive|define
name|TEX_SESC
value|'!'
define|#
directive|define
name|TEX_cmt
value|'%'
comment|/* Figure out whether TeX's escapechar is '\\' or '!' and set grouping */
comment|/* chars accordingly. */
name|void
name|TEX_mode
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
comment|/* Skip to next line if we hit the TeX comment char. */
if|if
condition|(
name|c
operator|==
name|TEX_cmt
condition|)
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|TEX_LESC
operator|||
name|c
operator|==
name|TEX_SESC
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|TEX_LESC
condition|)
block|{
name|TEX_esc
operator|=
name|TEX_LESC
expr_stmt|;
name|TEX_opgrp
operator|=
literal|'{'
expr_stmt|;
name|TEX_clgrp
operator|=
literal|'}'
expr_stmt|;
block|}
else|else
block|{
name|TEX_esc
operator|=
name|TEX_SESC
expr_stmt|;
name|TEX_opgrp
operator|=
literal|'<'
expr_stmt|;
name|TEX_clgrp
operator|=
literal|'>'
expr_stmt|;
block|}
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* Read environment and prepend it to the default string. */
comment|/* Build token table. */
name|struct
name|TEX_tabent
modifier|*
name|TEX_decode_env
parameter_list|(
name|evarname
parameter_list|,
name|defenv
parameter_list|)
name|char
modifier|*
name|evarname
decl_stmt|;
name|char
modifier|*
name|defenv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|env
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|savenstr
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
name|struct
name|TEX_tabent
modifier|*
name|tab
decl_stmt|;
name|int
name|size
decl_stmt|,
name|i
decl_stmt|;
comment|/* Append default string to environment. */
name|env
operator|=
name|getenv
argument_list|(
name|evarname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|env
condition|)
name|env
operator|=
name|defenv
expr_stmt|;
else|else
name|env
operator|=
name|concat
argument_list|(
name|env
argument_list|,
name|defenv
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Allocate a token table */
for|for
control|(
name|size
operator|=
literal|1
operator|,
name|p
operator|=
name|env
init|;
name|p
condition|;
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|*
operator|(
operator|++
name|p
operator|)
condition|)
name|size
operator|++
expr_stmt|;
name|tab
operator|=
name|xnew
argument_list|(
name|size
argument_list|,
expr|struct
name|TEX_tabent
argument_list|)
expr_stmt|;
comment|/* Unpack environment string into token table. Be careful about */
comment|/* zero-length strings (leading ':', "::" and trailing ':') */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|env
condition|;
control|)
block|{
name|p
operator|=
name|index
argument_list|(
name|env
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
comment|/* End of environment string. */
name|p
operator|=
name|env
operator|+
name|strlen
argument_list|(
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|-
name|env
operator|>
literal|0
condition|)
block|{
comment|/* Only non-zero strings. */
name|tab
index|[
name|i
index|]
operator|.
name|name
operator|=
name|savenstr
argument_list|(
name|env
argument_list|,
name|p
operator|-
name|env
argument_list|)
expr_stmt|;
name|tab
index|[
name|i
index|]
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|tab
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
condition|)
name|env
operator|=
name|p
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|tab
index|[
name|i
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
comment|/* Mark end of table. */
name|tab
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
return|return
name|tab
return|;
block|}
comment|/* Record a tag defined by a TeX command of length LEN and starting at NAME.    The name being defined actually starts at (NAME + LEN + 1).    But we seem to include the TeX command in the tag name.  */
name|void
name|TEX_getit
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|name
operator|+
name|len
decl_stmt|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|0
condition|)
return|return;
comment|/* Let tag name extend to next group close (or end of line) */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
name|TEX_clgrp
condition|)
name|p
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|nambuf
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|nambuf
index|[
name|p
operator|-
name|name
index|]
operator|=
literal|0
expr_stmt|;
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|lb
operator|.
name|buffer
argument_list|,
name|strlen
argument_list|(
name|lb
operator|.
name|buffer
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|linecharno
argument_list|)
expr_stmt|;
name|pfcnt
operator|++
expr_stmt|;
block|}
comment|/* If the text at CP matches one of the tag-defining TeX command names,    return the index of that command in TEX_toktab.    Otherwise return -1.  */
comment|/* Keep the capital `T' in `Token' for dumb truncating compilers    (this distinguishes it from `TEX_toktab' */
name|int
name|TEX_Token
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|TEX_toktab
index|[
name|i
index|]
operator|.
name|len
operator|>
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|TEX_toktab
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|cp
argument_list|,
name|TEX_toktab
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Support for Prolog.  */
comment|/* whole head (not only functor, but also arguments)    is gotten in compound term. */
name|void
name|prolog_getit
parameter_list|(
name|s
parameter_list|,
name|lineno
parameter_list|,
name|linecharno
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|long
name|linecharno
decl_stmt|;
block|{
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|save_s
decl_stmt|,
name|tmpc
decl_stmt|;
name|int
name|insquote
decl_stmt|,
name|npar
decl_stmt|;
name|save_s
operator|=
name|s
expr_stmt|;
name|insquote
operator|=
name|FALSE
expr_stmt|;
name|npar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
comment|/* syntax error. */
return|return;
elseif|else
if|if
condition|(
name|insquote
operator|&&
operator|*
name|s
operator|==
literal|'\''
operator|&&
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'\''
condition|)
name|s
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
condition|)
block|{
name|insquote
operator|=
operator|!
name|insquote
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|insquote
operator|&&
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
name|npar
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|insquote
operator|&&
operator|*
name|s
operator|==
literal|')'
condition|)
block|{
name|npar
operator|--
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|npar
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|npar
operator|<
literal|0
condition|)
comment|/* syntax error. */
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|insquote
operator|&&
operator|*
name|s
operator|==
literal|'.'
operator|&&
operator|(
name|isspace
argument_list|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
operator|||
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* fullstop. */
if|if
condition|(
name|npar
operator|!=
literal|0
condition|)
comment|/* syntax error. */
return|return;
name|s
operator|++
expr_stmt|;
break|break;
block|}
else|else
name|s
operator|++
expr_stmt|;
block|}
name|tmpc
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|nambuf
argument_list|,
name|save_s
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|tmpc
expr_stmt|;
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|TRUE
argument_list|,
name|save_s
argument_list|,
name|strlen
argument_list|(
name|nambuf
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|linecharno
argument_list|)
expr_stmt|;
block|}
comment|/* It is assumed that prolog predicate starts from column 0. */
name|void
name|prolog_funcs
parameter_list|(
name|fi
parameter_list|)
name|FILE
modifier|*
name|fi
decl_stmt|;
block|{
name|void
name|skip_comment
argument_list|()
decl_stmt|,
name|prolog_getit
argument_list|()
decl_stmt|;
name|lineno
operator|=
name|linecharno
operator|=
name|charno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|+=
name|charno
expr_stmt|;
name|charno
operator|=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 1 for newline. */
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|dbp
index|[
literal|0
index|]
argument_list|)
condition|)
comment|/* not predicate header. */
continue|continue;
elseif|else
if|if
condition|(
name|dbp
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
comment|/* comment. */
continue|continue;
elseif|else
if|if
condition|(
name|dbp
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|dbp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
comment|/* comment. */
name|skip_comment
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|,
operator|&
name|lineno
argument_list|,
operator|&
name|linecharno
argument_list|)
expr_stmt|;
else|else
comment|/* found. */
name|prolog_getit
argument_list|(
name|dbp
argument_list|,
name|lineno
argument_list|,
name|linecharno
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|skip_comment
parameter_list|(
name|plb
parameter_list|,
name|fi
parameter_list|,
name|plineno
parameter_list|,
name|plinecharno
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|plb
decl_stmt|;
name|FILE
modifier|*
name|fi
decl_stmt|;
name|int
modifier|*
name|plineno
decl_stmt|;
comment|/* result */
name|long
modifier|*
name|plinecharno
decl_stmt|;
comment|/* result */
block|{
while|while
condition|(
operator|!
name|substr
argument_list|(
literal|"*/"
argument_list|,
name|plb
operator|->
name|buffer
argument_list|)
condition|)
block|{
operator|(
operator|*
name|plineno
operator|)
operator|++
expr_stmt|;
operator|*
name|plinecharno
operator|+=
name|readline
argument_list|(
name|plb
argument_list|,
name|fi
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 1 for newline. */
block|}
comment|/* Return TRUE if 'sub' exists somewhere in 's'. */
name|int
name|substr
parameter_list|(
name|sub
parameter_list|,
name|s
parameter_list|)
name|char
modifier|*
name|sub
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|&&
operator|(
name|s
operator|=
name|index
argument_list|(
name|s
argument_list|,
operator|*
name|sub
argument_list|)
operator|)
condition|)
if|if
condition|(
name|prestr
argument_list|(
name|sub
argument_list|,
name|s
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
name|s
operator|++
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Return TRUE if 'pre' is prefix of string 's'. */
name|int
name|prestr
parameter_list|(
name|pre
parameter_list|,
name|s
parameter_list|)
name|char
modifier|*
name|pre
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|pre
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
elseif|else
if|if
condition|(
operator|*
name|pre
operator|==
operator|*
name|s
condition|)
return|return
operator|(
name|prestr
argument_list|(
name|pre
operator|+
literal|1
argument_list|,
name|s
operator|+
literal|1
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Initialize a linebuffer for use */
name|void
name|initbuffer
parameter_list|(
name|linebuffer
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|linebuffer
decl_stmt|;
block|{
name|linebuffer
operator|->
name|size
operator|=
literal|200
expr_stmt|;
name|linebuffer
operator|->
name|buffer
operator|=
name|xnew
argument_list|(
literal|200
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
comment|/*  * Read a line of text from `stream' into `linebuffer'.  * Return the number of characters read from `stream',  * which is the length of the line including the newline, if any.  */
name|long
name|readline
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|linebuffer
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|char
modifier|*
name|buffer
init|=
name|linebuffer
operator|->
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|linebuffer
operator|->
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|pend
decl_stmt|;
name|int
name|newline
decl_stmt|;
comment|/* 1 if ended with newline, 0 if ended with EOF */
name|pend
operator|=
name|p
operator|+
name|linebuffer
operator|->
name|size
expr_stmt|;
comment|/* Separate to avoind 386/IX compiler bug.  */
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|int
name|c
init|=
name|getc
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
block|{
name|linebuffer
operator|->
name|size
operator|*=
literal|2
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|linebuffer
operator|->
name|size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|buffer
operator|-
name|linebuffer
operator|->
name|buffer
expr_stmt|;
name|pend
operator|=
name|buffer
operator|+
name|linebuffer
operator|->
name|size
expr_stmt|;
name|linebuffer
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|newline
operator|=
operator|(
name|c
operator|==
literal|'\n'
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
return|return
name|p
operator|-
name|buffer
operator|+
name|newline
return|;
block|}
name|char
modifier|*
name|savestr
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
return|return
name|savenstr
argument_list|(
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|)
return|;
block|}
name|char
modifier|*
name|savenstr
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|xnew
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|dp
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dp
return|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/*  * Return the ptr in sp at which the character c last  * appears; NULL if not found  *  * Identical to v7 rindex, included for portability.  */
name|char
modifier|*
name|rindex
parameter_list|(
name|sp
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
name|c
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|NULL
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|c
condition|)
name|r
operator|=
name|sp
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|sp
operator|++
condition|)
do|;
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/*  * Return the ptr in sp at which the character c first  * appears; NULL if not found  *  * Identical to v7 index, included for portability.  */
name|char
modifier|*
name|index
parameter_list|(
name|sp
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
name|c
decl_stmt|;
block|{
do|do
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|c
condition|)
return|return
operator|(
name|sp
operator|)
return|;
block|}
do|while
condition|(
operator|*
name|sp
operator|++
condition|)
do|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* notdef */
comment|/* Print error message and exit.  */
comment|/* VARARGS1 */
name|void
name|fatal
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
block|{
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Print error message.  `s1' is printf control string, `s2' is arg for it. */
comment|/* VARARGS1 */
name|void
name|error
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Return a newly-allocated string whose contents concatenate those of s1, s2, s3.  */
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|xnew
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|,
name|char
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|len1
operator|+
name|len2
operator|+
name|len3
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* Like malloc but get fatal error if memory is exhausted.  */
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|char
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

