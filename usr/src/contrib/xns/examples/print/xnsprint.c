begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Header: xnsprint.c,v 2.4 87/01/09 16:34:23 ed Exp $  *  * a program to print InterPress masters on an InterPress printer via  * Ethernet.   Uses xns Courier.  * This version runs on 4.3BSD only!  */
end_comment

begin_comment
comment|/*  * $Log:	xnsprint.c,v $  * Revision 2.4  87/01/09  16:34:23  ed  * Webster version  *   * Revision 2.4  87/01/09  16:34:23  ed  * Added -W flag to wait until printing is completed (from Lee Moore)  *   * Revision 2.3  86/12/11  04:43:34  jqj  * Added support for -s and -m flags.  *   * Revision 2.2  86/09/07  06:57:41  jqj  * Fixed inconsistent calls to attnmsg() by eliminating stderr first arg.  * Changed banner not to use "Cornell Computer Science".  *   * Revision 2.1  86/05/16  11:04:18  jqj  * fix to correspond to new enumeration semantics (tags are now global)  *   * Revision 2.0  85/11/21  07:23:11  jqj  * 4.3BSD standard release  *   * Revision 1.1  85/11/20  13:56:53  jqj  * Initial revision  *   * modified 8-6-85 by jqj.  *  Eliminated any hardwired addresses.  Instead, use CH_Enumerate to  *  find a printer if none is specified.  Also, you can now print multiple  *  files in a single call to xnsprint, and getopt() is used to parse  *  arguments.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/sp.h>
end_include

begin_include
include|#
directive|include
file|"Printing3_defs.h"
end_include

begin_include
include|#
directive|include
file|<xnscourier/Clearinghouse2.h>
end_include

begin_include
include|#
directive|include
file|<xnscourier/except.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|ipfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExitStatus
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* modified lpd conventions: */
end_comment

begin_comment
comment|/* 0 => Job printed.  (successfully sent to print-server) */
end_comment

begin_define
define|#
directive|define
name|X_GOOD
value|0
end_define

begin_comment
comment|/* 1 => Couldn't send job.  Retry forever, should go eventually. */
end_comment

begin_define
define|#
directive|define
name|X_RETRY
value|1
end_define

begin_comment
comment|/* 2 => Couldn't send job,  Strange error, Retry a limited number*/
end_comment

begin_comment
comment|/*		of times.  If it still hasn't worked, give up.	 */
end_comment

begin_define
define|#
directive|define
name|X_LIMRETRY
value|2
end_define

begin_comment
comment|/* 3 => Couldn't send job:  Hard error, don't bother retrying,	 */
end_comment

begin_comment
comment|/*		get rid of the job.				 */
end_comment

begin_define
define|#
directive|define
name|X_NORETRY
value|3
end_define

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|sizename
decl_stmt|;
name|int
name|sizevalue
decl_stmt|;
block|}
name|papersizetable
index|[]
init|=
block|{
literal|"usLetter"
block|,
operator|(
name|int
operator|)
name|usLetter
block|,
comment|/* 1 */
literal|"usLegal"
block|,
operator|(
name|int
operator|)
name|usLegal
block|,
comment|/* 2 */
literal|"a0"
block|,
operator|(
name|int
operator|)
name|a0
block|,
comment|/* 3 */
literal|"a1"
block|,
operator|(
name|int
operator|)
name|a1
block|,
comment|/* 4 */
literal|"a2"
block|,
operator|(
name|int
operator|)
name|a2
block|,
comment|/* 5 */
literal|"a3"
block|,
operator|(
name|int
operator|)
name|a3
block|,
comment|/* 6 */
literal|"a4"
block|,
operator|(
name|int
operator|)
name|a4
block|,
comment|/* 7 */
literal|"a5"
block|,
operator|(
name|int
operator|)
name|a5
block|,
comment|/* 8 */
literal|"a6"
block|,
operator|(
name|int
operator|)
name|a6
block|,
comment|/* 9 */
literal|"a7"
block|,
operator|(
name|int
operator|)
name|a7
block|,
comment|/* 10 */
literal|"a8"
block|,
operator|(
name|int
operator|)
name|a8
block|,
comment|/* 11 */
literal|"a9"
block|,
operator|(
name|int
operator|)
name|a9
block|,
comment|/* 12 */
literal|"a10"
block|,
operator|(
name|int
operator|)
name|a10
block|,
comment|/* 35 */
literal|"isoB0"
block|,
operator|(
name|int
operator|)
name|isoB0
block|,
comment|/* 13 */
literal|"isoB1"
block|,
operator|(
name|int
operator|)
name|isoB1
block|,
comment|/* 14 */
literal|"isoB2"
block|,
operator|(
name|int
operator|)
name|isoB2
block|,
comment|/* 15 */
literal|"isoB3"
block|,
operator|(
name|int
operator|)
name|isoB3
block|,
comment|/* 16 */
literal|"isoB4"
block|,
operator|(
name|int
operator|)
name|isoB4
block|,
comment|/* 17 */
literal|"isoB5"
block|,
operator|(
name|int
operator|)
name|isoB5
block|,
comment|/* 18 */
literal|"isoB6"
block|,
operator|(
name|int
operator|)
name|isoB6
block|,
comment|/* 19 */
literal|"isoB7"
block|,
operator|(
name|int
operator|)
name|isoB7
block|,
comment|/* 20 */
literal|"isoB8"
block|,
operator|(
name|int
operator|)
name|isoB8
block|,
comment|/* 21 */
literal|"isoB9"
block|,
operator|(
name|int
operator|)
name|isoB9
block|,
comment|/* 22 */
literal|"isoB10"
block|,
operator|(
name|int
operator|)
name|isoB10
block|,
comment|/* 23 */
literal|"jisB0"
block|,
operator|(
name|int
operator|)
name|jisB0
block|,
comment|/* 24 */
literal|"jisB1"
block|,
operator|(
name|int
operator|)
name|jisB1
block|,
comment|/* 25 */
literal|"jisB2"
block|,
operator|(
name|int
operator|)
name|jisB2
block|,
comment|/* 26 */
literal|"jisB3"
block|,
operator|(
name|int
operator|)
name|jisB3
block|,
comment|/* 27 */
literal|"jisB4"
block|,
operator|(
name|int
operator|)
name|jisB4
block|,
comment|/* 28 */
literal|"jisB5"
block|,
operator|(
name|int
operator|)
name|jisB5
block|,
comment|/* 29 */
literal|"jisB6"
block|,
operator|(
name|int
operator|)
name|jisB6
block|,
comment|/* 30 */
literal|"jisB7"
block|,
operator|(
name|int
operator|)
name|jisB7
block|,
comment|/* 31 */
literal|"jisB8"
block|,
operator|(
name|int
operator|)
name|jisB8
block|,
comment|/* 32 */
literal|"jisB9"
block|,
operator|(
name|int
operator|)
name|jisB9
block|,
comment|/* 33 */
literal|"jisB10"
block|,
operator|(
name|int
operator|)
name|jisB10
block|,
comment|/* 34 */
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_macro
name|SendSource
argument_list|(
argument|bdtconnection
argument_list|)
end_macro

begin_decl_stmt
name|CourierConnection
modifier|*
name|bdtconnection
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
decl_stmt|;
name|char
name|buffer
index|[
name|SPPMAXDATA
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|count
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|SPPMAXDATA
argument_list|,
name|ipfile
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|BDTwrite
argument_list|(
name|bdtconnection
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
operator|>=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|BDTclosewrite
argument_list|(
name|bdtconnection
argument_list|)
expr_stmt|;
comment|/* last packet with EOM set */
else|else
name|BDTabort
argument_list|(
name|bdtconnection
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * misc externals  */
end_comment

begin_decl_stmt
name|int
name|remove
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|attn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write lpr system STATUS file?	LCP 850415*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|attnfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Status file name.		LCP 850415 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|FileName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|UserName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Banner
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|copies
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Medium
name|paperchoice
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|UserMessage
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Clearinghouse2_Name
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|xnshost
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|WaitFlag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wait until job is printed ? LCM */
end_comment

begin_macro
name|setxnshost
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|Clearinghouse2_ObjectName
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
if|if
condition|(
name|xnshost
operator|==
name|NULL
condition|)
name|xnshost
operator|=
name|strcpy
argument_list|(
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
operator|.
name|object
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|name
operator|.
name|object
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|ns_addr
modifier|*
name|destaddr
decl_stmt|;
name|CourierConnection
modifier|*
name|conn
decl_stmt|;
specifier|extern
name|struct
name|ns_addr
modifier|*
name|getXNSaddr
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|ns_addr
modifier|*
name|CH_LookupAddr
parameter_list|()
function_decl|;
name|Clearinghouse2_Name
name|defaultname
decl_stmt|;
specifier|extern
name|Clearinghouse2_Name
name|CH_StringToName
parameter_list|()
function_decl|;
name|int
name|opt
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|int
name|errflg
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|paperchoice
operator|.
name|designator
operator|=
name|paper
expr_stmt|;
name|paperchoice
operator|.
name|paper_case
operator|.
name|designator
operator|=
name|knownSize
expr_stmt|;
name|paperchoice
operator|.
name|paper_case
operator|.
name|knownSize_case
operator|=
name|usLetter
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:n:b:P:h:rqa:lm:s:W"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* copies */
name|copies
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* user name */
name|UserName
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* file name */
name|Banner
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* printer */
case|case
literal|'h'
case|:
comment|/* host */
name|xnshost
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* remove input file when done */
name|remove
operator|++
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* don't print status messages */
name|quiet
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* Write lpr STATUS file.  Name follows.  LCP 850415 */
name|quiet
operator|++
expr_stmt|;
name|attn
operator|++
expr_stmt|;
name|attnfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* use legal-sized (long) paper */
name|paperchoice
operator|.
name|paper_case
operator|.
name|knownSize_case
operator|=
name|usLegal
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* message field follows (default to XNS name) */
name|UserMessage
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* papersize name follows */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|papersizetable
index|[
name|i
index|]
operator|.
name|sizename
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|papersizetable
index|[
name|i
index|]
operator|.
name|sizename
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|paperchoice
operator|.
name|paper_case
operator|.
name|knownSize_case
operator|=
name|papersizetable
index|[
name|i
index|]
operator|.
name|sizevalue
expr_stmt|;
goto|goto
name|gotsize
goto|;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|paperchoice
operator|.
name|paper_case
operator|.
name|knownSize_case
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|gotsize
label|:
break|break;
case|case
literal|'W'
case|:
comment|/* wait for the job to be printed LCM */
name|WaitFlag
operator|++
expr_stmt|;
break|break;
default|default:
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|errflg
condition|)
block|{
name|attnmsg
argument_list|(
literal|"Usage: %s [-r] [-P host] [-c #] [-n name] [-b banner] [-l] [-s size] [-m message] [-W] file...\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|X_NORETRY
argument_list|)
expr_stmt|;
block|}
comment|/* set User Name for banner if necessary */
if|if
condition|(
name|UserName
operator|==
name|NULL
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|,
modifier|*
name|getpwuid
argument_list|()
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getenv
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
name|UserName
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|UserName
operator|=
name|pwd
operator|->
name|pw_gecos
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|index
argument_list|(
name|UserName
argument_list|,
literal|','
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'\000'
expr_stmt|;
block|}
block|}
comment|/* figure out what address we're sending to */
name|CH_NameDefault
argument_list|(
operator|&
name|defaultname
argument_list|)
expr_stmt|;
comment|/* default from clearinghouse.addresses */
if|if
condition|(
name|xnshost
operator|==
name|NULL
condition|)
block|{
name|xnshost
operator|=
name|getenv
argument_list|(
literal|"PRINTER"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xnshost
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|xnshost
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* find the first object in the local domain of the CH  			 * with a printService property.  setxnshost sets xnshost 			 * to the name part of the object 			 */
name|hostname
operator|=
name|defaultname
expr_stmt|;
name|hostname
operator|.
name|object
operator|=
literal|"*"
expr_stmt|;
name|CH_Enumerate
argument_list|(
name|hostname
argument_list|,
literal|10001
argument_list|,
name|setxnshost
argument_list|)
expr_stmt|;
name|hostname
operator|.
name|object
operator|=
name|xnshost
expr_stmt|;
block|}
else|else
name|hostname
operator|=
name|CH_StringToName
argument_list|(
name|xnshost
argument_list|,
operator|&
name|defaultname
argument_list|)
expr_stmt|;
block|}
else|else
name|hostname
operator|=
name|CH_StringToName
argument_list|(
name|xnshost
argument_list|,
operator|&
name|defaultname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|destaddr
operator|=
name|CH_LookupAddr
argument_list|(
name|hostname
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|attnmsg
argument_list|(
literal|"Invalid address, %s:%s:%s\n"
argument_list|,
name|hostname
operator|.
name|object
argument_list|,
name|hostname
operator|.
name|domain
argument_list|,
name|hostname
operator|.
name|organization
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|X_NORETRY
argument_list|)
expr_stmt|;
block|}
comment|/* make sure the printer is available */
name|checkIPstatus
argument_list|(
name|destaddr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|FileName
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|FileName
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipfile
operator|=
name|stdin
expr_stmt|;
name|FileName
operator|=
literal|"standard input"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ipfile
operator|=
name|fopen
argument_list|(
name|FileName
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|X_NORETRY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Banner
operator|==
name|NULL
condition|)
name|Banner
operator|=
name|FileName
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Sending to %s..."
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sendIPfile
argument_list|(
name|ipfile
argument_list|,
name|destaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipfile
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|ipfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Done.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|X_GOOD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check printer status first so we won't dump big interpress  * files accross the net unless we're fairly confidant that they'll  * be accepted.  */
end_comment

begin_macro
name|checkIPstatus
argument_list|(
argument|destaddr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ns_addr
modifier|*
name|destaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CourierConnection
modifier|*
name|conn
decl_stmt|;
name|GetPrinterStatusResults
name|StatusResult
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Opening connection to %s. "
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Opening connection to %s.\n"
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|conn
operator|=
name|CourierOpen
argument_list|(
name|destaddr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|attnmsg
argument_list|(
literal|"Can't open connection to %s\n"
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
operator|&&
operator|!
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Output left in %s\n"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|X_LIMRETRY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Connected.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Requesting status.\n"
argument_list|)
expr_stmt|;
name|DURING
name|StatusResult
init|=
name|GetPrinterStatus
argument_list|(
name|conn
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|HANDLER
block|{
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
switch|switch
condition|(
name|Exception
operator|.
name|Code
condition|)
block|{
case|case
name|ServiceUnavailable
case|:
name|attnmsg
argument_list|(
literal|"GetStat: Service unavailable\n"
argument_list|)
expr_stmt|;
name|ExitStatus
operator|=
name|X_NORETRY
expr_stmt|;
break|break;
case|case
name|SystemError
case|:
name|attnmsg
argument_list|(
literal|"GetStat: System Error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Undefined
case|:
name|attnmsg
argument_list|(
literal|"GetStat: Undefined error, number %d\n"
argument_list|,
name|CourierErrArgs
argument_list|(
name|UndefinedArgs
argument_list|,
name|problem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REJECT_ERROR
case|:
name|attnmsg
argument_list|(
literal|"GetStat: REJECT:  type = %d\n"
argument_list|,
name|CourierErrArgs
argument_list|(
name|rejectionDetails
argument_list|,
name|designator
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|attnmsg
argument_list|(
literal|"GetStat: Some random error, code %d\n"
argument_list|,
name|Exception
operator|.
name|Code
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|remove
operator|&&
operator|!
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Output left in %s\n"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ExitStatus
argument_list|)
expr_stmt|;
block|}
name|END_HANDLER
expr_stmt|;
name|CourierClose
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|printresults
argument_list|(
name|StatusResult
operator|.
name|status
argument_list|)
operator|!=
literal|0
condition|)
do|;
block|}
end_block

begin_comment
comment|/*   * display printer status, return 0 IFF spooler is available   */
end_comment

begin_function
name|int
name|printresults
parameter_list|(
name|status
parameter_list|)
name|PrinterStatus
name|status
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|typ
decl_stmt|;
specifier|static
name|char
modifier|*
name|spoollist
index|[]
init|=
block|{
literal|"available"
block|,
literal|"busy"
block|,
literal|"disabled"
block|,
literal|"full"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|formatlist
index|[]
init|=
block|{
literal|"available"
block|,
literal|"busy"
block|,
literal|"disabled"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|printlist
index|[]
init|=
block|{
literal|"available"
block|,
literal|"busy"
block|,
literal|"disabled"
block|,
literal|"needs attention"
block|,
literal|"needs key operator"
block|}
decl_stmt|;
name|int
name|error
init|=
literal|1
decl_stmt|;
name|char
name|bufr
index|[
literal|256
index|]
decl_stmt|;
name|bufr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|status
operator|.
name|sequence
index|[
name|i
index|]
operator|.
name|designator
condition|)
block|{
case|case
name|spooler
case|:
name|typ
operator|=
operator|(
name|int
operator|)
name|status
operator|.
name|sequence
index|[
name|i
index|]
operator|.
name|spooler_case
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|||
name|typ
operator|>
literal|1
condition|)
name|sprintf
argument_list|(
name|bufr
operator|+
name|strlen
argument_list|(
name|bufr
argument_list|)
argument_list|,
literal|"Spooler: %s; "
argument_list|,
name|spoollist
index|[
name|typ
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|typ
expr_stmt|;
break|break;
case|case
name|formatter
case|:
name|typ
operator|=
operator|(
name|int
operator|)
name|status
operator|.
name|sequence
index|[
name|i
index|]
operator|.
name|formatter_case
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|||
name|typ
operator|>
literal|1
condition|)
name|sprintf
argument_list|(
name|bufr
operator|+
name|strlen
argument_list|(
name|bufr
argument_list|)
argument_list|,
literal|"Formatter: %s; "
argument_list|,
name|formatlist
index|[
name|typ
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|printer
case|:
name|typ
operator|=
operator|(
name|int
operator|)
name|status
operator|.
name|sequence
index|[
name|i
index|]
operator|.
name|printer_case
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|||
name|typ
operator|>
literal|1
condition|)
name|sprintf
argument_list|(
name|bufr
operator|+
name|strlen
argument_list|(
name|bufr
argument_list|)
argument_list|,
literal|"Printer: %s. "
argument_list|,
name|printlist
index|[
name|typ
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|media
case|:
comment|/* printmedia(status.sequence[i].media_case); */
break|break;
block|}
block|}
if|if
condition|(
name|bufr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"%s\n"
argument_list|,
name|bufr
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|bufr
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Retrying... "
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufr
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Status: Busy.  Retrying...\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|15
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|remove
operator|&&
operator|!
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Output left in %s\n"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_macro
name|attnmsg
argument_list|(
argument|fmt
argument_list|,
argument|a0
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|,
argument|a8
argument_list|,
argument|a9
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|bufr
index|[
literal|256
index|]
decl_stmt|;
name|int
name|af
decl_stmt|;
if|if
condition|(
name|attn
condition|)
block|{
if|if
condition|(
operator|(
name|af
operator|=
name|open
argument_list|(
name|attnfile
argument_list|,
name|O_TRUNC
operator||
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
comment|/* Oh Well. */
name|sprintf
argument_list|(
name|bufr
argument_list|,
name|fmt
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|af
argument_list|,
name|bufr
argument_list|,
name|strlen
argument_list|(
name|bufr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In case of error??? */
name|close
argument_list|(
name|af
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sendIPfile
argument_list|(
argument|ipfile
argument_list|,
argument|destaddr
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|ipfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns_addr
modifier|*
name|destaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PrintResults
name|result
decl_stmt|;
name|CourierConnection
modifier|*
name|conn
decl_stmt|;
name|PrintAttributes
name|attributes
decl_stmt|;
name|PrintOptions
name|options
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/* only use sender name and file name, no date */
name|attributes
operator|.
name|length
operator|=
literal|2
expr_stmt|;
name|attributes
operator|.
name|sequence
operator|=
name|malloc
argument_list|(
name|attributes
operator|.
name|length
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|attributes
operator|.
name|sequence
argument_list|)
argument_list|)
expr_stmt|;
name|attributes
operator|.
name|sequence
index|[
literal|0
index|]
operator|.
name|designator
operator|=
name|printObjectName
expr_stmt|;
name|attributes
operator|.
name|sequence
index|[
literal|0
index|]
operator|.
name|printObjectName_case
operator|=
name|Banner
expr_stmt|;
name|attributes
operator|.
name|sequence
index|[
literal|1
index|]
operator|.
name|designator
operator|=
name|senderName
expr_stmt|;
name|attributes
operator|.
name|sequence
index|[
literal|1
index|]
operator|.
name|senderName_case
operator|=
name|UserName
expr_stmt|;
name|options
operator|.
name|length
operator|=
literal|3
expr_stmt|;
name|options
operator|.
name|sequence
operator|=
name|malloc
argument_list|(
name|options
operator|.
name|length
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|options
operator|.
name|sequence
argument_list|)
argument_list|)
expr_stmt|;
name|options
operator|.
name|sequence
index|[
literal|0
index|]
operator|.
name|designator
operator|=
name|copyCount
expr_stmt|;
name|options
operator|.
name|sequence
index|[
literal|0
index|]
operator|.
name|copyCount_case
operator|=
name|copies
expr_stmt|;
name|options
operator|.
name|sequence
index|[
literal|1
index|]
operator|.
name|designator
operator|=
name|mediumHint
expr_stmt|;
name|options
operator|.
name|sequence
index|[
literal|1
index|]
operator|.
name|mediumHint_case
operator|=
name|paperchoice
expr_stmt|;
name|options
operator|.
name|sequence
index|[
literal|2
index|]
operator|.
name|designator
operator|=
name|message
expr_stmt|;
name|options
operator|.
name|sequence
index|[
literal|2
index|]
operator|.
name|message_case
operator|=
name|UserMessage
condition|?
name|UserMessage
else|:
name|sprintf
argument_list|(
name|malloc
argument_list|(
literal|44
argument_list|)
argument_list|,
literal|"%s:%s:%s"
argument_list|,
name|hostname
operator|.
name|object
argument_list|,
name|hostname
operator|.
name|domain
argument_list|,
name|hostname
operator|.
name|organization
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Opening connection to %s. "
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Opening connection to %s.\n"
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|conn
operator|=
name|CourierOpen
argument_list|(
name|destaddr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|attnmsg
argument_list|(
literal|"Can't open connection to %s\n"
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
operator|&&
operator|!
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Output left in %s\n"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|X_LIMRETRY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Connected.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Sending to %s\n"
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
name|DURING
name|result
init|=
name|Print
argument_list|(
name|conn
argument_list|,
name|SendSource
argument_list|,
name|BulkData1_immediateSource
argument_list|,
name|attributes
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|HANDLER
block|{
name|ExitStatus
operator|=
name|X_RETRY
expr_stmt|;
switch|switch
condition|(
name|Exception
operator|.
name|Code
condition|)
block|{
case|case
name|Busy
case|:
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Busy, retrying...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Busy, retrying...\n"
argument_list|)
expr_stmt|;
name|CourierClose
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|rewind
argument_list|(
name|ipfile
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
literal|"Can't rewind file\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|again
goto|;
case|case
name|ConnectionError
case|:
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
literal|"Connection error, %d\n"
argument_list|,
name|CourierErrArgs
argument_list|(
name|ConnectionErrorArgs
argument_list|,
name|problem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|InsufficientSpoolSpace
case|:
name|attnmsg
argument_list|(
literal|"Insufficient Spool Space error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|InvalidPrintParameters
case|:
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
literal|"InvalidPrintParameters error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MasterTooLarge
case|:
name|ExitStatus
operator|=
name|X_NORETRY
expr_stmt|;
name|attnmsg
argument_list|(
literal|"MasterTooLarge error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MediumUnavailable
case|:
name|ExitStatus
operator|=
name|X_NORETRY
expr_stmt|;
name|attnmsg
argument_list|(
literal|"MediumUnavailable error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ServiceUnavailable
case|:
name|ExitStatus
operator|=
name|X_NORETRY
expr_stmt|;
name|attnmsg
argument_list|(
literal|"ServiceUnavailable error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SpoolingDisabled
case|:
name|attnmsg
argument_list|(
literal|"SpoolingDisabled\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SpoolingQueueFull
case|:
name|attnmsg
argument_list|(
literal|"SpoolingQueueFull error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SystemError
case|:
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
literal|"System Error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TooManyClients
case|:
name|attnmsg
argument_list|(
literal|"TooManyClients error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TransferError
case|:
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
literal|"TransferError error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Undefined
case|:
name|attnmsg
argument_list|(
literal|"Undefined error, number %d\n"
argument_list|,
name|CourierErrArgs
argument_list|(
name|UndefinedArgs
argument_list|,
name|problem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REJECT_ERROR
case|:
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
literal|"REJECT:  type = %d\n"
argument_list|,
name|CourierErrArgs
argument_list|(
name|rejectionDetails
argument_list|,
name|designator
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
literal|"Some random error, code %d\n"
argument_list|,
name|Exception
operator|.
name|Code
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|remove
operator|&&
operator|!
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Output left in %s\n"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ExitStatus
argument_list|)
expr_stmt|;
block|}
name|END_HANDLER
expr_stmt|;
if|if
condition|(
name|WaitFlag
condition|)
comment|/* wait for completion LCM */
name|WaitForCompletion
argument_list|(
name|conn
argument_list|,
name|result
operator|.
name|printRequestID
argument_list|)
expr_stmt|;
name|CourierClose
argument_list|(
name|conn
argument_list|)
expr_stmt|;
comment|/* RETURNS [printRequestID: RequestID] */
if|if
condition|(
name|remove
condition|)
name|unlink
argument_list|(
name|FileName
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Wait for the job to complete  */
end_comment

begin_macro
name|WaitForCompletion
argument_list|(
argument|conn
argument_list|,
argument|printRequestID
argument_list|)
end_macro

begin_decl_stmt
name|CourierConnection
modifier|*
name|conn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Printing3_RequestID
name|printRequestID
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|statusStrings
index|[]
init|=
block|{
literal|"pending"
block|,
literal|"inProgress"
block|,
literal|"completed"
block|,
literal|"completedWithWarning"
block|,
literal|"unknown"
block|,
literal|"rejected"
block|,
literal|"aborted"
block|,
literal|"canceled"
block|,
literal|"held"
block|}
decl_stmt|;
define|#
directive|define
name|DONE
value|0
define|#
directive|define
name|WAIT
value|1
specifier|static
name|char
name|statusActions
index|[]
init|=
block|{
name|WAIT
block|,
name|WAIT
block|,
name|DONE
block|,
name|DONE
block|,
name|DONE
block|,
name|DONE
block|,
name|DONE
block|,
name|DONE
block|,
name|WAIT
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|typ
decl_stmt|,
name|cycle
decl_stmt|,
name|action
decl_stmt|;
name|GetPrintRequestStatusResults
name|result
decl_stmt|;
for|for
control|(
name|cycle
operator|=
literal|0
init|;
condition|;
name|cycle
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"try #%d\n"
argument_list|,
name|cycle
argument_list|)
expr_stmt|;
name|DURING
name|result
init|=
name|GetPrintRequestStatus
argument_list|(
name|conn
argument_list|,
name|NULL
argument_list|,
name|printRequestID
argument_list|)
decl_stmt|;
name|HANDLER
block|{
name|ExitStatus
operator|=
name|X_NORETRY
expr_stmt|;
comment|/* if it got this far... */
switch|switch
condition|(
name|Exception
operator|.
name|Code
condition|)
block|{
case|case
name|ServiceUnavailable
case|:
name|attnmsg
argument_list|(
literal|"GetReqStat: Service unavailable\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SystemError
case|:
name|attnmsg
argument_list|(
literal|"GetReqStat: System error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Undefined
case|:
name|attnmsg
argument_list|(
literal|"GetReqStat: Undefined error, number %d\n"
argument_list|,
name|CourierErrArgs
argument_list|(
name|UndefinedArgs
argument_list|,
name|problem
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|REJECT_ERROR
case|:
name|attnmsg
argument_list|(
literal|"GetReqStat: REJECT: type = %d\n"
argument_list|,
name|CourierErrArgs
argument_list|(
name|rejectionDetails
argument_list|,
name|designator
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|attnmsg
argument_list|(
literal|"GetStat: Some random error, code %d\n"
argument_list|,
name|Exception
operator|.
name|Code
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
name|ExitStatus
argument_list|)
expr_stmt|;
block|}
name|END_HANDLER
expr_stmt|;
name|action
operator|=
name|WAIT
expr_stmt|;
comment|/* check out the returned status */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|result
operator|.
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|result
operator|.
name|status
operator|.
name|sequence
index|[
name|i
index|]
operator|.
name|designator
condition|)
block|{
case|case
name|status
case|:
name|typ
operator|=
operator|(
name|int
operator|)
name|result
operator|.
name|status
operator|.
name|sequence
index|[
name|i
index|]
operator|.
name|status_case
expr_stmt|;
name|action
operator|=
name|statusActions
index|[
name|typ
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"\tstatus: %s\n"
argument_list|,
name|statusStrings
index|[
name|typ
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|statusMessage
case|:
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"\tstatus message (%d bytes): %s\n"
argument_list|,
name|strlen
argument_list|(
name|result
operator|.
name|status
operator|.
name|sequence
index|[
name|i
index|]
operator|.
name|statusMessage_case
argument_list|)
argument_list|,
name|result
operator|.
name|status
operator|.
name|sequence
index|[
name|i
index|]
operator|.
name|statusMessage_case
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"GetReqStatu: help!\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|action
operator|==
name|DONE
condition|)
return|return;
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* wait three seconds before trying again */
block|}
block|}
end_block

end_unit

