begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|RCSid
index|[]
init|=
literal|"$Header: main.c,v 2.3 87/04/01 10:31:37 jqj Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* $Log:	main.c,v $  * Revision 2.3  87/04/01  10:31:37  jqj  * changes from Webster: added -I switch for search path of DEPENDS UPON files  *   * Revision 2.2  87/03/17  09:31:39  ed  * Added -I switch to establish search path for DEPENDS UPON files.  *   * Revision 2.1  86/06/06  07:28:45  jqj  * many mods for better symbol table management:  added CurrentModule,  *  made check_dependency, make_symbol, check_def set/use/use a symbol  *  table instead of a module name string, etc.  Result is that we can  *  now handle DEPENDS UPON 2 versions of same program.  *   * Revision 2.0  85/11/21  07:21:40  jqj  * 4.3BSD standard release  *   * Revision 1.5  85/05/23  06:19:55  jqj  * *** empty log message ***  *   * Revision 1.5  85/05/23  06:19:55  jqj  * Public Beta-test version, released 24 May 1985  *   * Revision 1.4  85/03/26  06:10:07  jqj  * Revised public alpha-test version, released 26 March 1985  *   * Revision 1.3  85/03/11  16:39:42  jqj  * Public alpha-test version, released 11 March 1985  *   * Revision 1.2  85/02/21  11:05:24  jqj  * alpha test version  *   * Revision 1.1  85/02/15  13:55:31  jqj  * Initial revision  *   */
end_comment

begin_include
include|#
directive|include
file|"compiler.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
name|char
modifier|*
name|input_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*NOBASE*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|header_file
index|[
name|MAXSTR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|header
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*NOBASE*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|header1_file
index|[
name|MAXSTR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|header1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*NOBASE*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|support_file1
index|[
name|MAXSTR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|support1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*NOBASE*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|support_file2
index|[
name|MAXSTR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|support2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*NOBASE*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|client_file
index|[
name|MAXSTR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|client
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*NOBASE*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|server_file
index|[
name|MAXSTR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|server
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|list
name|Procedures
decl_stmt|,
name|Errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|recursive_flag
decl_stmt|,
name|errs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|Boolean_type
decl_stmt|,
modifier|*
name|Cardinal_type
decl_stmt|,
modifier|*
name|LongCardinal_type
decl_stmt|,
modifier|*
name|Integer_type
decl_stmt|,
modifier|*
name|LongInteger_type
decl_stmt|,
modifier|*
name|String_type
decl_stmt|,
modifier|*
name|Unspecified_type
decl_stmt|,
modifier|*
name|LongUnspecified_type
decl_stmt|,
modifier|*
name|NilRecord_type
decl_stmt|,
modifier|*
name|StreamEnum_type
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXIDIRS
value|25
end_define

begin_decl_stmt
name|char
modifier|*
name|dirs
index|[
name|MAXIDIRS
index|]
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ndirs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|DebugFlag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|interrupt
argument_list|()
end_macro

begin_block
block|{
name|errs
operator|=
literal|1
expr_stmt|;
name|goodbye
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|opt
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-I include-dir] input_file\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"I:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'I'
case|:
if|if
condition|(
name|ndirs
operator|>
name|MAXIDIRS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many include directories\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dirs
index|[
name|ndirs
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
default|default :
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Illegal commandline option -%c\n"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|input_file
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|input_file
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tempname
argument_list|(
name|header_file
argument_list|)
expr_stmt|;
name|tempname
argument_list|(
name|header1_file
argument_list|)
expr_stmt|;
name|tempname
argument_list|(
name|client_file
argument_list|)
expr_stmt|;
name|tempname
argument_list|(
name|server_file
argument_list|)
expr_stmt|;
name|tempname
argument_list|(
name|support_file1
argument_list|)
expr_stmt|;
name|tempname
argument_list|(
name|support_file2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|header
operator|=
name|fopen
argument_list|(
name|header_file
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|header_file
argument_list|)
expr_stmt|;
name|goodbye
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|header1
operator|=
name|fopen
argument_list|(
name|header1_file
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|header1_file
argument_list|)
expr_stmt|;
name|goodbye
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|client
operator|=
name|fopen
argument_list|(
name|client_file
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|client_file
argument_list|)
expr_stmt|;
name|goodbye
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|server
operator|=
name|fopen
argument_list|(
name|server_file
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|server_file
argument_list|)
expr_stmt|;
name|goodbye
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|support1
operator|=
name|fopen
argument_list|(
name|support_file1
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|support_file1
argument_list|)
expr_stmt|;
name|goodbye
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|support2
operator|=
name|fopen
argument_list|(
name|support_file2
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|support_file2
argument_list|)
expr_stmt|;
name|goodbye
argument_list|()
expr_stmt|;
block|}
name|setup_predefs
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|yyparse
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|header1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|header
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|client
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|errs
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|freopen
argument_list|(
name|support_file2
argument_list|,
literal|"r"
argument_list|,
name|support2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|support2
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
name|c
argument_list|,
name|support1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|support1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|support2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|support_file2
argument_list|)
expr_stmt|;
name|changename
argument_list|(
name|support_file1
argument_list|,
literal|"_support.c"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Procedures
operator|!=
name|NIL
condition|)
block|{
name|changename
argument_list|(
name|client_file
argument_list|,
literal|"_client.c"
argument_list|)
expr_stmt|;
name|changename
argument_list|(
name|server_file
argument_list|,
literal|"_server.c"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|client_file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|server_file
argument_list|)
expr_stmt|;
block|}
name|changename
argument_list|(
name|header_file
argument_list|,
literal|".h"
argument_list|)
expr_stmt|;
name|changename
argument_list|(
name|header1_file
argument_list|,
literal|"_defs.h"
argument_list|)
expr_stmt|;
block|}
name|goodbye
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|goodbye
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|errs
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|header_file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|header1_file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|client_file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|server_file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|support_file1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|support_file2
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|errs
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Rename the source file to be<CurrentProgram><CurrentVersion><suffix> .  */
end_comment

begin_macro
name|changename
argument_list|(
argument|source
argument_list|,
argument|suffix
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|source
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|newname
index|[
name|MAXSTR
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|newname
argument_list|,
literal|"%s%d%s"
argument_list|,
name|CurrentProgram
argument_list|,
name|CurrentVersion
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|source
argument_list|,
name|newname
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
name|newname
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_expr_stmt
name|error
argument_list|(
name|level
argument_list|,
name|s
argument_list|,
name|args
argument_list|)
expr|enum
name|severity
name|level
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|yylineno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %d: "
argument_list|,
name|input_file
argument_list|,
name|yylineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|WARNING
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: "
argument_list|)
expr_stmt|;
name|_doprnt
argument_list|(
name|s
argument_list|,
operator|&
name|args
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|ERROR
condition|)
name|errs
operator|++
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|FATAL
condition|)
name|goodbye
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|yyerror
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|error
argument_list|(
name|ERROR
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|tempname
argument_list|(
argument|bclient
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|bclient
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|n
init|=
literal|0
decl_stmt|;
name|sprintf
argument_list|(
name|bclient
argument_list|,
literal|"tmp%d.%d"
argument_list|,
name|n
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|type
modifier|*
name|predefine_enum_type
parameter_list|(
name|name
parameter_list|,
name|elements
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|elements
decl_stmt|;
block|{
name|struct
name|object
modifier|*
name|symbol
decl_stmt|;
name|list
name|dlist
decl_stmt|;
name|struct
name|type
modifier|*
name|resulttype
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|dlist
operator|=
name|NIL
expr_stmt|;
for|for
control|(
init|;
operator|*
name|elements
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|;
name|elements
operator|+=
literal|2
control|)
block|{
name|id
operator|=
operator|*
name|elements
expr_stmt|;
name|value
operator|=
operator|*
operator|(
name|elements
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|check_def
argument_list|(
name|id
argument_list|,
name|ONIL
argument_list|)
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"in predefine_enum_type, %s already declared"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|make_symbol
argument_list|(
name|id
argument_list|,
name|ONIL
argument_list|)
expr_stmt|;
name|define_enumeration_symbol
argument_list|(
name|symbol
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|dlist
operator|=
name|cons
argument_list|(
name|cons
argument_list|(
operator|(
name|list
operator|)
name|symbol
argument_list|,
operator|(
name|list
operator|)
name|value
argument_list|)
argument_list|,
name|dlist
argument_list|)
expr_stmt|;
block|}
name|resulttype
operator|=
name|enumeration_type
argument_list|(
name|dlist
argument_list|)
expr_stmt|;
name|resulttype
operator|->
name|type_name
operator|=
name|name
expr_stmt|;
name|resulttype
operator|->
name|type_xsize
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|resulttype
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PREDEFINE
parameter_list|(
name|xtype
parameter_list|,
name|xname
parameter_list|,
name|nwords
parameter_list|,
name|constr
parameter_list|)
value|{ \ 	xtype = make_type(constr); \ 	xtype->type_name = xname; \ 	xtype->type_xsize = nwords; \ }
end_define

begin_comment
comment|/*  * This mess is needed because C doesn't handle initialization of unions.  * Note that all of these must correspond to declarations, plus sizeof_,  * externalize_, and internalize_ functions, in courier.h  */
end_comment

begin_macro
name|setup_predefs
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|struct
name|object
modifier|*
name|GlobalSymbols
decl_stmt|;
specifier|static
name|char
modifier|*
name|streamvals
index|[]
init|=
block|{
literal|"nextSegment"
block|,
literal|"0"
block|,
literal|"lastSegment"
block|,
literal|"1"
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
ifndef|#
directive|ifndef
name|lint
name|GlobalSymbols
operator|=
name|make_module
argument_list|(
literal|"*global*"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PREDEFINE
argument_list|(
name|Boolean_type
argument_list|,
literal|"Boolean"
argument_list|,
literal|1
argument_list|,
name|C_BOOLEAN
argument_list|)
expr_stmt|;
name|PREDEFINE
argument_list|(
name|Cardinal_type
argument_list|,
literal|"Cardinal"
argument_list|,
literal|1
argument_list|,
name|C_NUMERIC
argument_list|)
expr_stmt|;
name|PREDEFINE
argument_list|(
name|LongCardinal_type
argument_list|,
literal|"LongCardinal"
argument_list|,
literal|2
argument_list|,
name|C_NUMERIC
argument_list|)
expr_stmt|;
name|PREDEFINE
argument_list|(
name|Integer_type
argument_list|,
literal|"Integer"
argument_list|,
literal|1
argument_list|,
name|C_NUMERIC
argument_list|)
expr_stmt|;
name|PREDEFINE
argument_list|(
name|LongInteger_type
argument_list|,
literal|"LongInteger"
argument_list|,
literal|2
argument_list|,
name|C_NUMERIC
argument_list|)
expr_stmt|;
name|PREDEFINE
argument_list|(
name|String_type
argument_list|,
literal|"String"
argument_list|,
operator|-
literal|1
argument_list|,
name|C_STRING
argument_list|)
expr_stmt|;
name|PREDEFINE
argument_list|(
name|Unspecified_type
argument_list|,
literal|"Unspecified"
argument_list|,
literal|1
argument_list|,
name|C_NUMERIC
argument_list|)
expr_stmt|;
name|PREDEFINE
argument_list|(
name|LongUnspecified_type
argument_list|,
literal|"LongUnspecified"
argument_list|,
literal|2
argument_list|,
name|C_NUMERIC
argument_list|)
expr_stmt|;
name|PREDEFINE
argument_list|(
name|NilRecord_type
argument_list|,
literal|"NilRecord"
argument_list|,
literal|0
argument_list|,
name|C_RECORD
argument_list|)
expr_stmt|;
name|StreamEnum_type
operator|=
name|predefine_enum_type
argument_list|(
literal|"StreamEnumerator"
argument_list|,
name|streamvals
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

end_unit

