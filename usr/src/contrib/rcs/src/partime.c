begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * PARTIME		parse date/time string into a TM structure  *  * Usage:  *      #include "time.h"             -- expanded tm structure  *	char *str; struct tm *tp;  *	partime(str,tp);  * Returns:  *	0 if parsing failed  *	else time values in specified TM structure (unspecified values  *		set to TMNULL)  * Notes:  *	This code is quasi-public; it may be used freely in like software.  *	It is not to be sold, nor used in licensed software without  *	permission of the author.  *	For everyone's benefit, please report bugs and improvements!  * 	Copyright 1980 by Ken Harrenstien, SRI International.  *	(ARPANET: KLH @ SRI)  */
end_comment

begin_comment
comment|/* Hacknotes:  *	If parsing changed so that no backup needed, could perhaps modify  *		to use a FILE input stream.  Need terminator, though.  *	Perhaps should return 0 on success, else a non-zero error val?  *	Flush AMPM from TM structure and handle locally within PARTIME,  *		like midnight/noon?  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/src/local/bin/rcs/src/RCS/partime.c,v 1.4 89/05/01 14:48:46 narten Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* $Log:	partime.c,v $  * Revision 1.4  89/05/01  14:48:46  narten  * fixed #ifdef DEBUG construct  *   * Revision 1.3  88/11/08  12:02:15  narten  * changes from  eggert@sm.unisys.com (Paul Eggert)  *   * Revision 1.3  88/08/28  14:53:40  eggert  * Remove unportable "#endif XXX"s.  *   * Revision 1.2  87/03/27  14:21:53  jenkins  * Port to suns  *   * Revision 1.1  84/01/23  14:50:07  kcs  * Initial revision  *   * Revision 1.1  82/05/06  11:38:26  wft  * Initial revision  *   */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|timeid
index|[]
init|=
name|TIMEID
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|tmwent
block|{
name|char
modifier|*
name|went
decl_stmt|;
name|long
name|wval
decl_stmt|;
comment|/* must be big enough to hold pointer or integer */
name|char
name|wflgs
decl_stmt|;
name|char
name|wtype
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* wflgs */
end_comment

begin_define
define|#
directive|define
name|TWSPEC
value|01
end_define

begin_comment
comment|/* Word wants special processing */
end_comment

begin_define
define|#
directive|define
name|TWTIME
value|02
end_define

begin_comment
comment|/* Word is a time value (absence implies date) */
end_comment

begin_define
define|#
directive|define
name|TWDST
value|04
end_define

begin_comment
comment|/* Word is a DST-type timezone */
end_comment

begin_define
define|#
directive|define
name|TW1200
value|010
end_define

begin_comment
comment|/* Word is NOON or MIDNIGHT (sigh) */
end_comment

begin_function_decl
name|int
name|pt12hack
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ptnoise
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|tmwent
name|tmwords
index|[]
init|=
block|{
block|{
literal|"january"
block|,
literal|0
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"february"
block|,
literal|1
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"march"
block|,
literal|2
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"april"
block|,
literal|3
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"may"
block|,
literal|4
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"june"
block|,
literal|5
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"july"
block|,
literal|6
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"august"
block|,
literal|7
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"september"
block|,
literal|8
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"october"
block|,
literal|9
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"november"
block|,
literal|10
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"december"
block|,
literal|11
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"sunday"
block|,
literal|0
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"monday"
block|,
literal|1
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"tuesday"
block|,
literal|2
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"wednesday"
block|,
literal|3
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"thursday"
block|,
literal|4
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"friday"
block|,
literal|5
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"saturday"
block|,
literal|6
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"gmt"
block|,
literal|0
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Greenwich */
block|{
literal|"gst"
block|,
literal|0
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
block|{
literal|"gdt"
block|,
literal|0
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* ?? */
block|{
literal|"ast"
block|,
literal|4
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Atlantic */
block|{
literal|"est"
block|,
literal|5
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Eastern */
block|{
literal|"cst"
block|,
literal|6
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Central */
block|{
literal|"mst"
block|,
literal|7
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Mountain */
block|{
literal|"pst"
block|,
literal|8
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Pacific */
block|{
literal|"yst"
block|,
literal|9
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Yukon */
block|{
literal|"hst"
block|,
literal|10
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Hawaii */
block|{
literal|"bst"
block|,
literal|11
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Bering */
block|{
literal|"adt"
block|,
literal|4
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Atlantic */
block|{
literal|"edt"
block|,
literal|5
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Eastern */
block|{
literal|"cdt"
block|,
literal|6
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Central */
block|{
literal|"mdt"
block|,
literal|7
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Mountain */
block|{
literal|"pdt"
block|,
literal|8
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Pacific */
block|{
literal|"ydt"
block|,
literal|9
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Yukon */
block|{
literal|"hdt"
block|,
literal|10
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Hawaii */
block|{
literal|"bdt"
block|,
literal|11
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Bering */
block|{
literal|"daylight"
block|,
literal|1
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Local Daylight */
block|{
literal|"standard"
block|,
literal|1
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Local Standard */
block|{
literal|"std"
block|,
literal|1
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/*   "       "    */
block|{
literal|"am"
block|,
literal|1
block|,
name|TWTIME
block|,
name|TM_AMPM
block|}
block|,
block|{
literal|"pm"
block|,
literal|2
block|,
name|TWTIME
block|,
name|TM_AMPM
block|}
block|,
block|{
literal|"noon"
block|,
literal|12
block|,
name|TWTIME
operator|+
name|TW1200
block|,
literal|0
block|}
block|,
comment|/* Special frobs */
block|{
literal|"midnight"
block|,
literal|0
block|,
name|TWTIME
operator|+
name|TW1200
block|,
literal|0
block|}
block|,
block|{
literal|"at"
block|,
operator|(
name|long
operator|)
name|ptnoise
block|,
name|TWSPEC
block|,
literal|0
block|}
block|,
comment|/* Noise word */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Zero entry to terminate searches */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TMWILD
value|(-2)
end_define

begin_comment
comment|/* Value meaning item specified as wild-card */
end_comment

begin_comment
comment|/* (May use someday...) */
end_comment

begin_struct
struct|struct
name|token
block|{
name|char
modifier|*
name|tcp
decl_stmt|;
comment|/* pointer to string */
name|int
name|tcnt
decl_stmt|;
comment|/* # chars */
name|char
name|tbrk
decl_stmt|;
comment|/* "break" char */
name|char
name|tbrkl
decl_stmt|;
comment|/* last break char */
name|char
name|tflg
decl_stmt|;
comment|/* 0 = alpha, 1 = numeric */
union|union
block|{
comment|/* Resulting value; */
name|int
name|tnum
decl_stmt|;
comment|/* either a #, or */
name|struct
name|tmwent
modifier|*
name|ttmw
decl_stmt|;
comment|/* ptr to a tmwent. */
block|}
name|tval
union|;
block|}
struct|;
end_struct

begin_macro
name|partime
argument_list|(
argument|astr
argument_list|,
argument|atm
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|astr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tm
modifier|*
name|atm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|tmwent
modifier|*
name|twp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|token
name|btoken
decl_stmt|,
name|atoken
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|ch
decl_stmt|;
name|int
name|ord
decl_stmt|,
name|midnoon
decl_stmt|;
name|int
function_decl|(
modifier|*
name|aproc
function_decl|)
parameter_list|()
function_decl|;
name|tp
operator|=
operator|(
name|int
operator|*
operator|)
name|atm
expr_stmt|;
name|zaptime
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Initialize the TM structure */
name|midnoon
operator|=
name|TMNULL
expr_stmt|;
comment|/* and our own temp stuff */
name|btoken
operator|.
name|tcnt
operator|=
name|btoken
operator|.
name|tbrkl
operator|=
literal|0
expr_stmt|;
name|btoken
operator|.
name|tcp
operator|=
name|astr
expr_stmt|;
name|domore
label|:
if|if
condition|(
operator|!
name|ptitoken
argument_list|(
name|btoken
operator|.
name|tcp
operator|+
name|btoken
operator|.
name|tcnt
argument_list|,
operator|&
name|btoken
argument_list|)
condition|)
comment|/* Get a token */
block|{
if|if
condition|(
name|btoken
operator|.
name|tval
operator|.
name|tnum
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Read error? */
if|if
condition|(
name|midnoon
operator|!=
name|TMNULL
condition|)
comment|/* EOF, wrap up */
return|return
operator|(
name|pt12hack
argument_list|(
name|tp
argument_list|,
name|midnoon
argument_list|)
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Win return! */
block|}
if|if
condition|(
name|btoken
operator|.
name|tflg
operator|==
literal|0
condition|)
comment|/* Alpha? */
block|{
name|twp
operator|=
name|btoken
operator|.
name|tval
operator|.
name|ttmw
expr_stmt|;
comment|/* Yes, get ptr to entry */
if|if
condition|(
name|twp
operator|->
name|wflgs
operator|&
name|TWSPEC
condition|)
comment|/* Special alpha crock */
block|{
name|aproc
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|twp
operator|->
name|wval
operator|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|aproc
call|)
argument_list|(
name|tp
argument_list|,
name|twp
argument_list|,
operator|&
name|btoken
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: special word err */
goto|goto
name|domore
goto|;
block|}
if|if
condition|(
name|twp
operator|->
name|wflgs
operator|&
name|TW1200
condition|)
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|midnoon
argument_list|,
operator|(
name|int
operator|)
name|twp
operator|->
name|wval
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: noon/midnite clash */
else|else
goto|goto
name|domore
goto|;
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|twp
operator|->
name|wtype
index|]
argument_list|,
operator|(
name|int
operator|)
name|twp
operator|->
name|wval
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: val already set */
if|if
condition|(
name|twp
operator|->
name|wtype
operator|==
name|TM_ZON
condition|)
comment|/* If was zone, hack DST */
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_ISDST
index|]
argument_list|,
operator|(
name|twp
operator|->
name|wflgs
operator|&
name|TWDST
operator|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: DST conflict */
goto|goto
name|domore
goto|;
block|}
comment|/* Token is number.  Lots of hairy heuristics. */
if|if
condition|(
name|btoken
operator|.
name|tcnt
operator|>=
literal|7
condition|)
comment|/* More than 6 digits in string? */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: number too big */
if|if
condition|(
name|btoken
operator|.
name|tcnt
operator|==
literal|6
condition|)
comment|/* 6 digits = HHMMSS.  Needs special crock */
block|{
comment|/* since 6 digits are too big for integer! */
name|i
operator|=
operator|(
name|btoken
operator|.
name|tcp
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
comment|/* Gobble 1st 2 digits */
operator|+
name|btoken
operator|.
name|tcp
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|btoken
operator|.
name|tcnt
operator|=
literal|2
expr_stmt|;
comment|/* re-read last 4 chars */
goto|goto
name|coltime
goto|;
block|}
name|i
operator|=
name|btoken
operator|.
name|tval
operator|.
name|tnum
expr_stmt|;
comment|/* Value now known to be valid; get it. */
if|if
condition|(
name|btoken
operator|.
name|tcnt
operator|==
literal|5
comment|/*  5 digits = HMMSS */
operator|||
name|btoken
operator|.
name|tcnt
operator|==
literal|3
condition|)
comment|/*  3 digits = HMM   */
block|{
if|if
condition|(
name|btoken
operator|.
name|tcnt
operator|!=
literal|3
condition|)
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_SEC
index|]
argument_list|,
name|i
operator|%
literal|100
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: sec conflict */
else|else
name|i
operator|/=
literal|100
expr_stmt|;
name|hhmm4
label|:
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_MIN
index|]
argument_list|,
name|i
operator|%
literal|100
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: min conflict */
name|i
operator|/=
literal|100
expr_stmt|;
name|hh2
label|:
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_HOUR
index|]
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: hour conflict */
goto|goto
name|domore
goto|;
block|}
if|if
condition|(
name|btoken
operator|.
name|tcnt
operator|==
literal|4
condition|)
comment|/* 4 digits = YEAR or HHMM */
block|{
if|if
condition|(
name|tp
index|[
name|TM_YEAR
index|]
operator|!=
name|TMNULL
condition|)
goto|goto
name|hhmm4
goto|;
comment|/* Already got yr? */
if|if
condition|(
name|tp
index|[
name|TM_HOUR
index|]
operator|!=
name|TMNULL
condition|)
goto|goto
name|year4
goto|;
comment|/* Already got hr? */
if|if
condition|(
operator|(
name|i
operator|%
literal|100
operator|)
operator|>
literal|59
condition|)
goto|goto
name|year4
goto|;
comment|/* MM>= 60? */
if|if
condition|(
name|btoken
operator|.
name|tbrk
operator|==
literal|':'
condition|)
comment|/* HHMM:SS ? */
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_HOUR
index|]
argument_list|,
name|i
operator|/
literal|100
argument_list|)
operator|||
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_MIN
index|]
argument_list|,
name|i
operator|%
literal|100
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: hr/min clash */
else|else
goto|goto
name|coltm2
goto|;
comment|/* Go handle SS */
if|if
condition|(
name|btoken
operator|.
name|tbrk
operator|!=
literal|','
operator|&&
name|btoken
operator|.
name|tbrk
operator|!=
literal|'/'
operator|&&
name|ptitoken
argument_list|(
name|btoken
operator|.
name|tcp
operator|+
name|btoken
operator|.
name|tcnt
argument_list|,
operator|&
name|atoken
argument_list|)
comment|/* Peek */
operator|&&
name|atoken
operator|.
name|tflg
operator|==
literal|0
comment|/* alpha */
operator|&&
operator|(
name|atoken
operator|.
name|tval
operator|.
name|ttmw
operator|->
name|wflgs
operator|&
name|TWTIME
operator|)
condition|)
comment|/* HHMM-ZON */
goto|goto
name|hhmm4
goto|;
if|if
condition|(
name|btoken
operator|.
name|tbrkl
operator|==
literal|'-'
comment|/* DD-Mon-YYYY */
operator|||
name|btoken
operator|.
name|tbrkl
operator|==
literal|','
comment|/* Mon DD, YYYY */
operator|||
name|btoken
operator|.
name|tbrkl
operator|==
literal|'/'
comment|/* MM/DD/YYYY */
operator|||
name|btoken
operator|.
name|tbrkl
operator|==
literal|'.'
comment|/* DD.MM.YYYY */
operator|||
name|btoken
operator|.
name|tbrk
operator|==
literal|'-'
comment|/* YYYY-MM-DD */
condition|)
goto|goto
name|year4
goto|;
goto|goto
name|hhmm4
goto|;
comment|/* Give up, assume HHMM. */
block|}
comment|/* From this point on, assume tcnt == 1 or 2 */
comment|/* 2 digits = YY, MM, DD, or HH (MM and SS caught at coltime) */
if|if
condition|(
name|btoken
operator|.
name|tbrk
operator|==
literal|':'
condition|)
comment|/* HH:MM[:SS] */
goto|goto
name|coltime
goto|;
comment|/*  must be part of time. */
if|if
condition|(
name|i
operator|>
literal|31
condition|)
goto|goto
name|yy2
goto|;
comment|/* If>= 32, only YY poss. */
comment|/* Check for numerical-format date */
for|for
control|(
name|cp
operator|=
literal|"/-."
init|;
name|ch
operator|=
operator|*
name|cp
operator|++
condition|;
control|)
block|{
name|ord
operator|=
operator|(
name|ch
operator|==
literal|'.'
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
comment|/* n/m = D/M or M/D */
if|if
condition|(
name|btoken
operator|.
name|tbrk
operator|==
name|ch
condition|)
comment|/* "NN-" */
block|{
if|if
condition|(
name|btoken
operator|.
name|tbrkl
operator|!=
name|ch
condition|)
block|{
if|if
condition|(
name|ptitoken
argument_list|(
name|btoken
operator|.
name|tcp
operator|+
name|btoken
operator|.
name|tcnt
argument_list|,
operator|&
name|atoken
argument_list|)
operator|&&
name|atoken
operator|.
name|tflg
operator|==
literal|0
operator|&&
name|atoken
operator|.
name|tval
operator|.
name|ttmw
operator|->
name|wtype
operator|==
name|TM_MON
condition|)
goto|goto
name|dd2
goto|;
if|if
condition|(
name|ord
condition|)
goto|goto
name|mm2
goto|;
else|else
goto|goto
name|dd2
goto|;
comment|/* "NN-" */
block|}
comment|/* "-NN-" */
if|if
condition|(
name|tp
index|[
name|TM_DAY
index|]
operator|==
name|TMNULL
operator|&&
name|tp
index|[
name|TM_YEAR
index|]
operator|!=
name|TMNULL
condition|)
comment|/* If "YY-NN-" */
goto|goto
name|mm2
goto|;
comment|/* then always MM */
if|if
condition|(
name|ord
condition|)
goto|goto
name|dd2
goto|;
else|else
goto|goto
name|mm2
goto|;
block|}
if|if
condition|(
name|btoken
operator|.
name|tbrkl
operator|==
name|ch
comment|/* "-NN" */
operator|&&
name|tp
index|[
name|ord
condition|?
name|TM_MON
else|:
name|TM_DAY
index|]
operator|!=
name|TMNULL
condition|)
if|if
condition|(
name|tp
index|[
name|ord
condition|?
name|TM_DAY
else|:
name|TM_MON
index|]
operator|==
name|TMNULL
condition|)
comment|/* MM/DD */
if|if
condition|(
name|ord
condition|)
goto|goto
name|dd2
goto|;
else|else
goto|goto
name|mm2
goto|;
else|else
goto|goto
name|yy2
goto|;
comment|/* "-YY" */
block|}
comment|/* At this point only YY, DD, and HH are left. 	 * YY is very unlikely since value is<= 32 and there was 	 * no numerical format date.  Make one last try at YY 	 * before dropping through to DD vs HH code. 	 */
if|if
condition|(
name|btoken
operator|.
name|tcnt
operator|==
literal|2
comment|/* If 2 digits */
operator|&&
name|tp
index|[
name|TM_HOUR
index|]
operator|!=
name|TMNULL
comment|/* and already have hour */
operator|&&
name|tp
index|[
name|TM_DAY
index|]
operator|!=
name|TMNULL
comment|/* and day, but  */
operator|&&
name|tp
index|[
name|TM_YEAR
index|]
operator|==
name|TMNULL
condition|)
comment|/* no year, then assume */
goto|goto
name|yy2
goto|;
comment|/* that's what we have. */
comment|/* Now reduced to choice between HH and DD */
if|if
condition|(
name|tp
index|[
name|TM_HOUR
index|]
operator|!=
name|TMNULL
condition|)
goto|goto
name|dd2
goto|;
comment|/* Have hour? Assume day. */
if|if
condition|(
name|tp
index|[
name|TM_DAY
index|]
operator|!=
name|TMNULL
condition|)
goto|goto
name|hh2
goto|;
comment|/* Have day? Assume hour. */
if|if
condition|(
name|i
operator|>
literal|24
condition|)
goto|goto
name|dd2
goto|;
comment|/* Impossible HH means DD */
if|if
condition|(
operator|!
name|ptitoken
argument_list|(
name|btoken
operator|.
name|tcp
operator|+
name|btoken
operator|.
name|tcnt
argument_list|,
operator|&
name|atoken
argument_list|)
condition|)
comment|/* Read ahead! */
if|if
condition|(
name|atoken
operator|.
name|tval
operator|.
name|tnum
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: bad token */
else|else
goto|goto
name|dd2
goto|;
comment|/* EOF, assume day. */
if|if
condition|(
name|atoken
operator|.
name|tflg
operator|==
literal|0
comment|/* If next token is an alpha */
operator|&&
name|atoken
operator|.
name|tval
operator|.
name|ttmw
operator|->
name|wflgs
operator|&
name|TWTIME
condition|)
comment|/* time-spec, assume hour */
goto|goto
name|hh2
goto|;
comment|/* e.g. "3 PM", "11-EDT"  */
name|dd2
label|:
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_DAY
index|]
argument_list|,
name|i
argument_list|)
condition|)
comment|/* Store day (1 based) */
return|return
operator|(
literal|0
operator|)
return|;
goto|goto
name|domore
goto|;
name|mm2
label|:
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_MON
index|]
argument_list|,
name|i
operator|-
literal|1
argument_list|)
condition|)
comment|/* Store month (make zero based) */
return|return
operator|(
literal|0
operator|)
return|;
goto|goto
name|domore
goto|;
name|yy2
label|:
name|i
operator|+=
literal|1900
expr_stmt|;
name|year4
label|:
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_YEAR
index|]
argument_list|,
name|i
argument_list|)
condition|)
comment|/* Store year (full number) */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: year conflict */
goto|goto
name|domore
goto|;
comment|/* Hack HH:MM[[:]SS] */
name|coltime
label|:
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_HOUR
index|]
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|ptitoken
argument_list|(
name|btoken
operator|.
name|tcp
operator|+
name|btoken
operator|.
name|tcnt
argument_list|,
operator|&
name|btoken
argument_list|)
condition|)
return|return
operator|(
operator|!
name|btoken
operator|.
name|tval
operator|.
name|tnum
operator|)
return|;
if|if
condition|(
operator|!
name|btoken
operator|.
name|tflg
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: HH:<alpha> */
if|if
condition|(
name|btoken
operator|.
name|tcnt
operator|==
literal|4
condition|)
comment|/* MMSS */
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_MIN
index|]
argument_list|,
name|btoken
operator|.
name|tval
operator|.
name|tnum
operator|/
literal|100
argument_list|)
operator|||
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_SEC
index|]
argument_list|,
name|btoken
operator|.
name|tval
operator|.
name|tnum
operator|%
literal|100
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
goto|goto
name|domore
goto|;
if|if
condition|(
name|btoken
operator|.
name|tcnt
operator|!=
literal|2
operator|||
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_MIN
index|]
argument_list|,
name|btoken
operator|.
name|tval
operator|.
name|tnum
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: MM bad */
if|if
condition|(
name|btoken
operator|.
name|tbrk
operator|!=
literal|':'
condition|)
goto|goto
name|domore
goto|;
comment|/* Seconds follow? */
name|coltm2
label|:
if|if
condition|(
operator|!
name|ptitoken
argument_list|(
name|btoken
operator|.
name|tcp
operator|+
name|btoken
operator|.
name|tcnt
argument_list|,
operator|&
name|btoken
argument_list|)
condition|)
return|return
operator|(
operator|!
name|btoken
operator|.
name|tval
operator|.
name|tnum
operator|)
return|;
if|if
condition|(
operator|!
name|btoken
operator|.
name|tflg
operator|||
name|btoken
operator|.
name|tcnt
operator|!=
literal|2
comment|/* Verify SS */
operator|||
name|ptstash
argument_list|(
operator|&
name|tp
index|[
name|TM_SEC
index|]
argument_list|,
name|btoken
operator|.
name|tval
operator|.
name|tnum
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: SS bad */
goto|goto
name|domore
goto|;
block|}
end_block

begin_comment
comment|/* Store date/time value, return 0 if successful.  * Fails if entry already set to a different value.  */
end_comment

begin_macro
name|ptstash
argument_list|(
argument|adr
argument_list|,
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|adr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|a
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|a
operator|=
name|adr
operator|)
operator|!=
name|TMNULL
condition|)
return|return
operator|(
operator|*
name|a
operator|!=
name|val
operator|)
return|;
operator|*
name|a
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* This subroutine is invoked for NOON or MIDNIGHT when wrapping up  * just prior to returning from partime.  */
end_comment

begin_macro
name|pt12hack
argument_list|(
argument|atp
argument_list|,
argument|aval
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|atp
decl_stmt|,
name|aval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|tp
decl_stmt|,
name|i
decl_stmt|,
name|h
decl_stmt|;
name|tp
operator|=
name|atp
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|=
name|tp
index|[
name|TM_MIN
index|]
operator|)
operator|&&
name|i
operator|!=
name|TMNULL
operator|)
comment|/* Ensure mins, secs */
operator|||
operator|(
operator|(
name|i
operator|=
name|tp
index|[
name|TM_SEC
index|]
operator|)
operator|&&
name|i
operator|!=
name|TMNULL
operator|)
condition|)
comment|/* are 0 or unspec'd */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: MM:SS not 00:00 */
name|i
operator|=
name|aval
expr_stmt|;
comment|/* Get 0 or 12 (midnite or noon) */
if|if
condition|(
operator|(
name|h
operator|=
name|tp
index|[
name|TM_HOUR
index|]
operator|)
operator|==
name|TMNULL
comment|/* If hour unspec'd, win */
operator|||
name|h
operator|==
literal|12
condition|)
comment|/* or if 12:00 (matches either) */
name|tp
index|[
name|TM_HOUR
index|]
operator|=
name|i
expr_stmt|;
comment|/* Then set time */
elseif|else
if|if
condition|(
operator|!
operator|(
name|i
operator|==
literal|0
comment|/* Nope, but if midnight and */
operator|&&
operator|(
name|h
operator|==
literal|0
operator|||
name|h
operator|==
literal|24
operator|)
operator|)
condition|)
comment|/* time matches, can pass. */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: HH conflicts */
name|tp
index|[
name|TM_AMPM
index|]
operator|=
name|TMNULL
expr_stmt|;
comment|/* Always reset this value if won */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Null routine for no-op tokens */
end_comment

begin_macro
name|ptnoise
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Get a token and identify it to some degree.  * Returns 0 on failure; token.tval will be 0 for normal EOF, otherwise  * hit error of some sort  */
end_comment

begin_expr_stmt
name|ptitoken
argument_list|(
name|astr
argument_list|,
name|tkp
argument_list|)
specifier|register
expr|struct
name|token
operator|*
name|tkp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|astr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|tkp
operator|->
name|tval
operator|.
name|tnum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pttoken
argument_list|(
name|astr
argument_list|,
name|tkp
argument_list|)
operator|==
literal|0
condition|)
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|VOID
name|printf
argument_list|(
literal|"EOF\n"
argument_list|)
decl_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
name|cp
operator|=
name|tkp
operator|->
name|tcp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|i
operator|=
name|cp
index|[
name|tkp
operator|->
name|tcnt
index|]
expr_stmt|;
name|cp
index|[
name|tkp
operator|->
name|tcnt
index|]
operator|=
literal|0
expr_stmt|;
name|VOID
name|printf
argument_list|(
literal|"Token: \"%s\" "
argument_list|,
name|cp
argument_list|)
decl_stmt|;
name|cp
index|[
name|tkp
operator|->
name|tcnt
index|]
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tkp
operator|->
name|tflg
condition|)
for|for
control|(
name|i
operator|=
name|tkp
operator|->
name|tcnt
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|tkp
operator|->
name|tval
operator|.
name|tnum
operator|=
operator|(
name|int
operator|)
name|tkp
operator|->
name|tval
operator|.
name|tnum
operator|*
literal|10
operator|+
operator|(
operator|(
operator|*
name|cp
operator|++
operator|)
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
block|{
name|i
operator|=
name|ptmatchstr
argument_list|(
name|cp
argument_list|,
name|tkp
operator|->
name|tcnt
argument_list|,
name|tmwords
argument_list|)
expr_stmt|;
name|tkp
operator|->
name|tval
operator|.
name|tnum
operator|=
name|i
condition|?
name|i
else|:
operator|-
literal|1
expr_stmt|;
comment|/* Set -1 for error */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|i
condition|)
name|VOID
name|printf
argument_list|(
literal|"Not found!\n"
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|i
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tkp
operator|->
name|tflg
condition|)
name|VOID
name|printf
argument_list|(
literal|"Val: %d.\n"
argument_list|,
name|tkp
operator|->
name|tval
operator|.
name|tnum
argument_list|)
decl_stmt|;
else|else
name|VOID
name|printf
argument_list|(
literal|"Found: \"%s\", val: %d., type %d\n"
argument_list|,
name|tkp
operator|->
name|tval
operator|.
name|ttmw
operator|->
name|went
argument_list|,
name|tkp
operator|->
name|tval
operator|.
name|ttmw
operator|->
name|wval
argument_list|,
name|tkp
operator|->
name|tval
operator|.
name|ttmw
operator|->
name|wtype
argument_list|)
decl_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Read token from input string into token structure */
end_comment

begin_expr_stmt
name|pttoken
argument_list|(
name|astr
argument_list|,
name|tkp
argument_list|)
specifier|register
expr|struct
name|token
operator|*
name|tkp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|astr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|tkp
operator|->
name|tcp
operator|=
name|cp
operator|=
name|astr
expr_stmt|;
name|tkp
operator|->
name|tbrkl
operator|=
name|tkp
operator|->
name|tbrk
expr_stmt|;
comment|/* Set "last break" */
name|tkp
operator|->
name|tcnt
operator|=
name|tkp
operator|->
name|tbrk
operator|=
name|tkp
operator|->
name|tflg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
comment|/* Flush all whitespace */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|++
operator|)
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
empty_stmt|;
name|cp
operator|--
expr_stmt|;
comment|/* Drop thru to handle brk */
case|case
literal|'('
case|:
case|case
literal|')'
case|:
comment|/* Perhaps any non-alphanum */
case|case
literal|'-'
case|:
case|case
literal|','
case|:
comment|/* shd qualify as break? */
case|case
literal|'/'
case|:
case|case
literal|':'
case|:
case|case
literal|'.'
case|:
comment|/* Break chars */
if|if
condition|(
name|tkp
operator|->
name|tcnt
operator|==
literal|0
condition|)
comment|/* If no token yet */
block|{
name|tkp
operator|->
name|tcp
operator|=
name|cp
expr_stmt|;
comment|/* ignore the brk */
name|tkp
operator|->
name|tbrkl
operator|=
name|c
expr_stmt|;
continue|continue;
comment|/* and go on. */
block|}
name|tkp
operator|->
name|tbrk
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|tkp
operator|->
name|tcnt
operator|)
return|;
block|}
if|if
condition|(
name|tkp
operator|->
name|tcnt
operator|==
literal|0
condition|)
comment|/* If first char of token, */
name|tkp
operator|->
name|tflg
operator|=
name|isdigit
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/*    determine type */
if|if
condition|(
operator|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|&&
name|tkp
operator|->
name|tflg
operator|)
comment|/* If not first, make sure */
operator|||
operator|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|tkp
operator|->
name|tflg
operator|)
condition|)
comment|/*    char matches type */
name|tkp
operator|->
name|tcnt
operator|++
expr_stmt|;
comment|/* Win, add to token. */
else|else
block|{
name|cp
operator|--
expr_stmt|;
comment|/* Wrong type, back up */
name|tkp
operator|->
name|tbrk
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|tkp
operator|->
name|tcnt
operator|)
return|;
block|}
block|}
return|return
operator|(
name|tkp
operator|->
name|tcnt
operator|)
return|;
comment|/* When hit EOF */
block|}
end_block

begin_macro
name|ptmatchstr
argument_list|(
argument|astr
argument_list|,
argument|cnt
argument_list|,
argument|astruc
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|astr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tmwent
modifier|*
name|astruc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|struct
name|tmwent
modifier|*
name|lastptr
decl_stmt|;
struct|struct
name|integ
block|{
name|int
name|word
decl_stmt|;
block|}
struct|;
comment|/* For getting at array ptr */
name|int
name|i
decl_stmt|;
name|lastptr
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|mp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
expr|struct
name|integ
operator|*
operator|)
name|astruc
operator|)
operator|->
name|word
condition|;
name|astruc
operator|+=
literal|1
control|)
block|{
name|cp
operator|=
name|astr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cnt
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|++
operator|)
operator|^
operator|*
name|mp
operator|++
condition|)
comment|/* XOR the chars */
block|{
case|case
literal|0
case|:
continue|continue;
comment|/* Exact match */
case|case
literal|040
case|:
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
if|if
condition|(
operator|*
name|mp
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|unsigned
name|int
operator|)
name|astruc
operator|)
return|;
comment|/* Exact match */
elseif|else
if|if
condition|(
name|lastptr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Ambiguous */
else|else
name|lastptr
operator|=
name|astruc
expr_stmt|;
comment|/* 1st ambig */
block|}
return|return
operator|(
operator|(
name|unsigned
name|int
operator|)
name|lastptr
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|zaptime
argument_list|(
name|tp
argument_list|)
specifier|register
name|int
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* clears tm structure pointed to by tp */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tm
argument_list|)
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
do|do
operator|*
name|tp
operator|++
operator|=
name|TMNULL
expr_stmt|;
comment|/* Set entry to "unspecified" */
do|while
condition|(
operator|--
name|i
condition|)
do|;
comment|/* Faster than FOR */
block|}
end_block

end_unit

