begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)vi.c	8.1 (Berkeley) 6/9/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"vcmd.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|getcmd
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getkeyword
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getmotion
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|MARK
operator|*
operator|,
name|MARK
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * vi --  * 	Main vi command loop.  */
end_comment

begin_function
name|int
name|vi
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|MARK
name|fm
decl_stmt|,
name|tm
decl_stmt|,
name|m
decl_stmt|;
name|VICMDARG
name|cmd
decl_stmt|,
name|dot
decl_stmt|,
name|dotmotion
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|int
name|comcount
decl_stmt|,
name|eval
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
comment|/* Start vi. */
if|if
condition|(
name|v_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Paint the screen. */
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
name|v_end
argument_list|(
name|sp
argument_list|)
operator|)
return|;
comment|/* Command initialization. */
name|cmd
operator|.
name|keyword
operator|=
name|dot
operator|.
name|keyword
operator|=
name|dotmotion
operator|.
name|keyword
operator|=
name|NULL
expr_stmt|;
name|cmd
operator|.
name|kbuflen
operator|=
name|dot
operator|.
name|kbuflen
operator|=
name|dotmotion
operator|.
name|kbuflen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|eval
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|term_more_pseudo
argument_list|(
name|sp
argument_list|)
operator|&&
name|log_cursor
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * We get a command, which may or may not have an associated 		 * motion.  If it does, we get it too, calling its underlying 		 * function to get the resulting mark.  We then call the 		 * command setting the cursor to the resulting mark. 		 */
name|vp
operator|=
operator|&
name|cmd
expr_stmt|;
if|if
condition|(
name|getcmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|dot
argument_list|,
name|vp
argument_list|,
name|NULL
argument_list|,
operator|&
name|comcount
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * Historical practice: if a dot command gets a new count, 		 * any motion component goes away, i.e. "d3w2." deletes a 		 * total of 5 words. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_ISDOT
argument_list|)
operator|&&
name|comcount
condition|)
name|dotmotion
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|flags
operator|=
name|vp
operator|->
name|kp
operator|->
name|flags
expr_stmt|;
comment|/* Get any associated keyword. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_KEYNUM
operator||
name|V_KEYW
argument_list|)
operator|&&
name|getkeyword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|flags
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* If a non-relative movement, set the '' mark. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_ABS
argument_list|)
condition|)
block|{
name|m
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
name|mark_set
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|ABSMARK1
argument_list|,
operator|&
name|m
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* 		 * Do any required motion.  If no motion specified, and it's 		 * a line-oriented command, set the to MARK anyway, it's used 		 * by some commands.  If count specified, then the to MARK is 		 * set to that many lines, counting the current one. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_MOTION
argument_list|)
condition|)
block|{
if|if
condition|(
name|getmotion
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|dotmotion
argument_list|,
name|vp
argument_list|,
operator|&
name|fm
argument_list|,
operator|&
name|tm
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|fm
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|fm
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
operator|->
name|kp
argument_list|,
name|V_LMODE
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|)
block|{
name|tm
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
operator|+
name|vp
operator|->
name|count
operator|-
literal|1
expr_stmt|;
name|tm
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
else|else
name|tm
operator|=
name|fm
expr_stmt|;
block|}
comment|/* 		 * Call the function.  Set the return cursor first for 		 * purely defensive reasons.  Sometimes the underlying 		 * routines forget. 		 */
name|m
operator|=
name|fm
expr_stmt|;
if|if
condition|(
call|(
name|vp
operator|->
name|kp
operator|->
name|func
call|)
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
operator|&
name|fm
argument_list|,
operator|&
name|tm
argument_list|,
operator|&
name|m
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * If that command took us out of vi or changed the screen, 		 * then exit the loop without further action. 		 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MODE_VI
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MAJOR_CHANGE
argument_list|)
condition|)
break|break;
comment|/* Set the dot command structure. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_DOT
argument_list|)
condition|)
block|{
name|dot
operator|=
name|cmd
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|dot
argument_list|,
name|VC_ISDOT
argument_list|)
expr_stmt|;
comment|/* 			 * If a count was supplied for both the command and 			 * its motion, the count was used only for the motion. 			 * Turn the count back on for the dot structure. 			 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1RESET
argument_list|)
condition|)
name|F_SET
argument_list|(
operator|&
name|dot
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Some vi row movements are "attracted" to the last position 		 * set, i.e. the V_RCM commands are moths to the V_RCM_SET 		 * commands' candle.  It's broken into two parts.  Here we deal 		 * with the command flags.  In sp->relative(), we deal with the 		 * screen flags.  If the movement is to the EOL the vi command 		 * handles it.  If it's to the beginning, we handle it here. 		 * 		 * Does this totally violate the screen and editor layering? 		 * You betcha.  As they say, if you think you understand it, 		 * you don't. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_RCM
argument_list|)
condition|)
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|s_relative
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|m
operator|.
name|lno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_RCM_SETFNB
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonblank
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|m
operator|.
name|lno
argument_list|,
operator|&
name|m
operator|.
name|cno
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|sp
operator|->
name|rcmflags
operator|=
name|RCM_FNB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_RCM_SETLAST
argument_list|)
condition|)
name|sp
operator|->
name|rcmflags
operator|=
name|RCM_LAST
expr_stmt|;
comment|/* Update the cursor. */
name|sp
operator|->
name|lno
operator|=
name|m
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|m
operator|.
name|cno
expr_stmt|;
if|if
condition|(
operator|!
name|term_more_pseudo
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|msg_rpt
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
name|err
label|:
name|term_flush_pseudo
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Refresh the screen. */
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
block|{
name|eval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Set the new favorite position. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_RCM_SET
argument_list|)
condition|)
block|{
name|sp
operator|->
name|rcmflags
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rcm
operator|=
name|sp
operator|->
name|sc_col
expr_stmt|;
block|}
block|}
return|return
operator|(
name|v_end
argument_list|(
name|sp
argument_list|)
operator|||
name|eval
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|KEY
parameter_list|(
name|sp
parameter_list|,
name|k
parameter_list|)
value|{							\ 	(k) = term_key(sp, TXT_MAPCOMMAND);				\ 	if (F_ISSET(sp, S_UPDATE_MODE)) {				\ 		F_CLR(sp, S_UPDATE_MODE);				\ 		sp->s_refresh(sp, ep);					\ 	}								\ 	if (sp->special[(k)] == K_VLNEXT)				\ 		(k) = term_key(sp, TXT_MAPCOMMAND);			\ 	if (sp->special[(k)] == K_ESCAPE) {				\ 		if (esc_bell)						\ 		    msgq(sp, M_BERR, "Already in command mode");	\ 		return (1);						\ 	}								\ }
end_define

begin_define
define|#
directive|define
name|GETCOUNT
parameter_list|(
name|sp
parameter_list|,
name|count
parameter_list|)
value|{						\ 	count = 0;							\ 	do {								\ 		hold = count * 10 + key - '0';				\ 		if (count> hold) {					\ 			msgq(sp, M_ERR,					\ 			    "Number larger than %lu", ULONG_MAX);	\ 			return (NULL);					\ 		}							\ 		count = hold;						\ 		KEY(sp, key);						\ 	} while (isdigit(key));						\ }
end_define

begin_comment
comment|/*  * getcmd --  *  * The command structure for vi is less complex than ex (and don't think  * I'm not grateful!)  The command syntax is:  *  *	[count] [buffer] [count] key [[motion] | [buffer] [character]]  *  * and there are several special cases.  The motion value is itself a vi  * command, with the syntax:  *  *	[count] key [character]  */
end_comment

begin_function
specifier|static
name|int
name|getcmd
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|dp
parameter_list|,
name|vp
parameter_list|,
name|ismotion
parameter_list|,
name|comcountp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|dp
decl_stmt|,
decl|*
name|vp
decl_stmt|;
end_function

begin_decl_stmt
name|VICMDARG
modifier|*
name|ismotion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Previous key if getting motion component. */
end_comment

begin_decl_stmt
name|int
modifier|*
name|comcountp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|VIKEYS
specifier|const
modifier|*
name|kp
decl_stmt|;
specifier|register
name|u_int
name|flags
decl_stmt|;
name|u_long
name|hold
decl_stmt|;
name|int
name|esc_bell
decl_stmt|,
name|key
decl_stmt|;
name|memset
argument_list|(
operator|&
name|vp
operator|->
name|vpstartzero
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|vp
operator|->
name|vpendzero
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|vp
operator|->
name|vpstartzero
argument_list|)
expr_stmt|;
comment|/* An escape bells the user only if already in command mode. */
name|esc_bell
operator|=
name|ismotion
operator|==
name|NULL
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|KEY
argument_list|(
argument|sp
argument_list|,
argument|key
argument_list|)
name|esc_bell
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|key
operator|<
literal|0
operator|||
name|key
operator|>
name|MAXVIKEY
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"%s isn't a vi command"
argument_list|,
name|charname
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Pick up optional buffer. */
if|if
condition|(
name|key
operator|==
literal|'"'
condition|)
block|{
name|KEY
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|key
argument_list|)
condition|)
goto|goto
name|ebuf
goto|;
name|vp
operator|->
name|buffer
operator|=
name|key
expr_stmt|;
name|KEY
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
name|vp
operator|->
name|buffer
operator|=
name|OOBCB
expr_stmt|;
comment|/* 	 * Pick up optional count, where a leading 0 is not a count, 	 * it's a command. 	 */
if|if
condition|(
name|isdigit
argument_list|(
name|key
argument_list|)
operator|&&
name|key
operator|!=
literal|'0'
condition|)
block|{
name|GETCOUNT
argument_list|(
name|sp
argument_list|,
name|vp
operator|->
name|count
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
operator|*
name|comcountp
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|comcountp
operator|=
literal|0
expr_stmt|;
comment|/* Pick up optional buffer. */
if|if
condition|(
name|key
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|buffer
operator|!=
name|OOBCB
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Only one buffer can be specified."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|KEY
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|key
argument_list|)
condition|)
goto|goto
name|ebuf
goto|;
name|vp
operator|->
name|buffer
operator|=
name|key
expr_stmt|;
name|KEY
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
comment|/* Find the command. */
name|kp
operator|=
name|vp
operator|->
name|kp
operator|=
operator|&
name|vikeys
index|[
name|vp
operator|->
name|key
operator|=
name|key
index|]
expr_stmt|;
if|if
condition|(
name|kp
operator|->
name|func
operator|==
name|NULL
condition|)
block|{
comment|/* If dot, set new count/buffer, if any, and return. */
if|if
condition|(
name|key
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|dp
argument_list|,
name|VC_ISDOT
argument_list|)
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|)
block|{
name|F_SET
argument_list|(
name|dp
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
name|dp
operator|->
name|count
operator|=
name|vp
operator|->
name|count
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|buffer
operator|!=
name|OOBCB
condition|)
name|dp
operator|->
name|buffer
operator|=
name|vp
operator|->
name|buffer
expr_stmt|;
operator|*
name|vp
operator|=
operator|*
name|dp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No commands which set dot executed yet."
argument_list|)
expr_stmt|;
block|}
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s isn't a command"
argument_list|,
name|charname
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|flags
operator|=
name|kp
operator|->
name|flags
expr_stmt|;
comment|/* Check for illegal count. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|V_CNT
argument_list|)
condition|)
goto|goto
name|usage
goto|;
comment|/* Illegal motion command. */
if|if
condition|(
name|ismotion
operator|==
name|NULL
condition|)
block|{
comment|/* Illegal buffer. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|V_OBUF
argument_list|)
operator|&&
name|vp
operator|->
name|buffer
operator|!=
name|OOBCB
condition|)
goto|goto
name|usage
goto|;
comment|/* Required buffer. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_RBUF
argument_list|)
condition|)
block|{
name|KEY
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
literal|'"'
condition|)
goto|goto
name|usage
goto|;
name|KEY
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|>
name|UCHAR_MAX
condition|)
block|{
name|ebuf
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Invalid buffer name."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|vp
operator|->
name|buffer
operator|=
name|key
expr_stmt|;
block|}
comment|/* 		 * Special case: '[' and ']' commands.  Doesn't the fact 		 * that the *single* characters don't mean anything but 		 * the *doubled* characters do just frost your shorts? 		 */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
literal|'['
operator|||
name|vp
operator|->
name|key
operator|==
literal|']'
condition|)
block|{
name|KEY
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|key
operator|!=
name|key
condition|)
goto|goto
name|usage
goto|;
block|}
comment|/* Special case: 'Z' command. */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
literal|'Z'
condition|)
block|{
name|KEY
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|key
operator|!=
name|key
condition|)
goto|goto
name|usage
goto|;
block|}
comment|/* Special case: 'z' command. */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
literal|'z'
condition|)
block|{
name|KEY
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|GETCOUNT
argument_list|(
name|sp
argument_list|,
name|vp
operator|->
name|count2
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_C2SET
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|character
operator|=
name|key
expr_stmt|;
block|}
block|}
comment|/* 	 * Commands that have motion components can be doubled to 	 * imply the current line. 	 */
elseif|else
if|if
condition|(
name|ismotion
operator|->
name|key
operator|!=
name|key
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|V_MOVE
argument_list|)
condition|)
block|{
name|usage
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Usage: %s"
argument_list|,
name|ismotion
operator|!=
name|NULL
condition|?
name|vikeys
index|[
name|ismotion
operator|->
name|key
index|]
operator|.
name|usage
else|:
name|kp
operator|->
name|usage
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Required character. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_CHAR
argument_list|)
condition|)
name|KEY
argument_list|(
name|sp
argument_list|,
name|vp
operator|->
name|character
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * getmotion --  *  * Get resulting motion mark.  */
end_comment

begin_function
specifier|static
name|int
name|getmotion
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|dm
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|dm
decl_stmt|,
decl|*
name|vp
decl_stmt|;
end_function

begin_decl_stmt
name|MARK
modifier|*
name|fm
decl_stmt|,
modifier|*
name|tm
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|MARK
name|m
decl_stmt|;
name|VICMDARG
name|motion
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|u_long
name|cnt
decl_stmt|;
name|int
name|notused
decl_stmt|;
comment|/* If '.' command, use the dot motion, else get the motion command. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_ISDOT
argument_list|)
condition|)
name|motion
operator|=
operator|*
name|dm
expr_stmt|;
elseif|else
if|if
condition|(
name|getcmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|,
operator|&
name|motion
argument_list|,
name|vp
argument_list|,
operator|&
name|notused
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * A count may be provided both to the command and to the motion, in 	 * which case the count is multiplicative.  For example, "3y4y" is the 	 * same as "12yy".  This count is provided to the motion command and 	 * not to the regular function.  	 */
name|cnt
operator|=
name|motion
operator|.
name|count
operator|=
name|F_ISSET
argument_list|(
operator|&
name|motion
argument_list|,
name|VC_C1SET
argument_list|)
condition|?
name|motion
operator|.
name|count
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|)
block|{
name|motion
operator|.
name|count
operator|*=
name|vp
operator|->
name|count
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|motion
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
comment|/* 		 * Set flags to restore the original values of the command 		 * structure so dot commands can change the count values, 		 * e.g. "2dw" "3." deletes a total of five words. 		 */
name|F_CLR
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_C1RESET
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Some commands can be repeated to indicate the current line.  In 	 * this case, or if the command is a "line command", set the flags 	 * appropriately.  If not a doubled command, run the function to get 	 * the resulting mark.  	 */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
name|motion
operator|.
name|key
condition|)
block|{
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_LMODE
argument_list|)
expr_stmt|;
comment|/* 		 * Set the end of the command; the column is after the 		 * last line. 		 * 		 * If the current line is missing, i.e. the file is empty, 		 * historic vi permitted a "cc" command to change it. 		 */
name|tm
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
operator|+
name|motion
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tm
operator|->
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
operator|!
name|F_ISSET
argument_list|(
name|vp
operator|->
name|kp
argument_list|,
name|VC_C
argument_list|)
operator|||
name|tm
operator|->
name|lno
operator|!=
literal|1
operator|)
condition|)
block|{
name|m
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|tm
operator|->
name|cno
operator|=
name|len
expr_stmt|;
comment|/* 		 * Set the origin of the command.  Don't set the cursor column 		 * value, since some commands use it to set the return column 		 * value -- underlying functions are expected to recognized 		 * line mode without using the column number. 		 */
name|fm
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Motion commands change the underlying movement (*snarl*). 		 * For example, "l" is illegal at the end of a line, but "dl" 		 * is not.  Set flags so the function knows the situation. 		 */
name|F_SET
argument_list|(
operator|&
name|motion
argument_list|,
name|vp
operator|->
name|kp
operator|->
name|flags
operator|&
name|VC_COMMASK
argument_list|)
expr_stmt|;
name|m
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
call|(
name|motion
operator|.
name|kp
operator|->
name|func
call|)
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|motion
argument_list|,
operator|&
name|m
argument_list|,
name|NULL
argument_list|,
name|tm
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 		 * If the underlying motion was a line motion, set the flag 		 * in the command structure. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|motion
operator|.
name|kp
argument_list|,
name|V_LMODE
argument_list|)
condition|)
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_LMODE
argument_list|)
expr_stmt|;
comment|/* 		 * If the motion is in a backward direction, switch the current 		 * location so that we're always moving in the same direction. 		 */
if|if
condition|(
name|tm
operator|->
name|lno
operator|<
name|sp
operator|->
name|lno
operator|||
name|tm
operator|->
name|lno
operator|==
name|sp
operator|->
name|lno
operator|&&
name|tm
operator|->
name|cno
operator|<
name|sp
operator|->
name|cno
condition|)
block|{
operator|*
name|fm
operator|=
operator|*
name|tm
expr_stmt|;
name|tm
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|tm
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
else|else
block|{
name|fm
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|fm
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
block|}
comment|/* 	 * If a dot command save motion structure.  Note that the motion count 	 * was changed above and needs to be reset. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
operator|->
name|kp
argument_list|,
name|V_DOT
argument_list|)
condition|)
block|{
operator|*
name|dm
operator|=
name|motion
expr_stmt|;
name|dm
operator|->
name|count
operator|=
name|cnt
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|innum
parameter_list|(
name|c
parameter_list|)
value|(isdigit(c) || strchr("abcdefABCDEF", c))
end_define

begin_function
specifier|static
name|int
name|getkeyword
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|kp
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|kp
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
specifier|register
name|size_t
name|beg
decl_stmt|,
name|end
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|beg
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* May not be a keyword at all. */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|len
operator|==
literal|0
operator|||
name|LF_ISSET
argument_list|(
name|V_KEYW
argument_list|)
operator|&&
operator|!
name|inword
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
operator|||
name|LF_ISSET
argument_list|(
name|V_KEYNUM
argument_list|)
operator|&&
operator|!
name|innum
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
condition|)
block|{
name|noword
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Cursor not in a %s"
argument_list|,
name|LF_ISSET
argument_list|(
name|V_KEYW
argument_list|)
condition|?
literal|"word"
else|:
literal|"number"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Find the beginning/end of the keyword. */
if|if
condition|(
name|beg
operator|!=
literal|0
condition|)
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_KEYW
argument_list|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
operator|--
name|beg
expr_stmt|;
if|if
condition|(
operator|!
name|inword
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
condition|)
block|{
operator|++
name|beg
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|beg
operator|==
literal|0
condition|)
break|break;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
operator|--
name|beg
expr_stmt|;
if|if
condition|(
operator|!
name|innum
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|beg
operator|>
literal|0
operator|&&
name|p
index|[
name|beg
operator|-
literal|1
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|p
index|[
name|beg
index|]
operator|==
literal|'X'
operator|||
name|p
index|[
name|beg
index|]
operator|==
literal|'x'
operator|)
condition|)
operator|--
name|beg
expr_stmt|;
else|else
operator|++
name|beg
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|beg
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Skip possible leading sign. */
if|if
condition|(
name|beg
operator|!=
literal|0
operator|&&
name|p
index|[
name|beg
index|]
operator|!=
literal|'0'
operator|&&
operator|(
name|p
index|[
name|beg
operator|-
literal|1
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
name|beg
operator|-
literal|1
index|]
operator|==
literal|'-'
operator|)
condition|)
operator|--
name|beg
expr_stmt|;
block|}
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_KEYW
argument_list|)
condition|)
block|{
for|for
control|(
name|end
operator|=
name|sp
operator|->
name|cno
init|;
operator|++
name|end
operator|<
name|len
operator|&&
name|inword
argument_list|(
name|p
index|[
name|end
index|]
argument_list|)
condition|;
control|)
empty_stmt|;
operator|--
name|end
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|end
operator|=
name|sp
operator|->
name|cno
init|;
operator|++
name|end
operator|<
name|len
condition|;
control|)
block|{
if|if
condition|(
name|p
index|[
name|end
index|]
operator|==
literal|'X'
operator|||
name|p
index|[
name|end
index|]
operator|==
literal|'x'
condition|)
block|{
if|if
condition|(
name|end
operator|!=
name|beg
operator|+
literal|1
operator|||
name|p
index|[
name|beg
index|]
operator|!=
literal|'0'
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
operator|!
name|innum
argument_list|(
name|p
index|[
name|end
index|]
argument_list|)
condition|)
break|break;
block|}
comment|/* Just a sign isn't a number. */
if|if
condition|(
name|end
operator|==
name|beg
operator|&&
operator|(
name|p
index|[
name|beg
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
name|beg
index|]
operator|==
literal|'-'
operator|)
condition|)
goto|goto
name|noword
goto|;
operator|--
name|end
expr_stmt|;
block|}
comment|/* 	 * Getting a keyword implies moving the cursor to its beginning. 	 * Refresh now. 	 */
if|if
condition|(
name|beg
operator|!=
name|sp
operator|->
name|cno
condition|)
block|{
name|sp
operator|->
name|cno
operator|=
name|beg
expr_stmt|;
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * 8-bit clean problem.  Numeric keywords are handled using strtol(3) 	 * and friends.  This would have to be fixed in v_increment and here 	 * to not depend on a trailing NULL. 	 */
name|len
operator|=
operator|(
name|end
operator|-
name|beg
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* XXX */
name|kp
operator|->
name|klen
operator|=
operator|(
name|end
operator|-
name|beg
operator|)
operator|+
literal|1
expr_stmt|;
name|BINC
argument_list|(
name|sp
argument_list|,
name|kp
operator|->
name|keyword
argument_list|,
name|kp
operator|->
name|kbuflen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|kp
operator|->
name|keyword
argument_list|,
name|p
operator|+
name|beg
argument_list|,
name|kp
operator|->
name|klen
argument_list|)
expr_stmt|;
name|kp
operator|->
name|keyword
index|[
name|kp
operator|->
name|klen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

