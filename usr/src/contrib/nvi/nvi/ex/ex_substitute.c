begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ex_substitute.c	8.1 (Berkeley) 6/9/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"excmd.h"
end_include

begin_enum
enum|enum
name|which
block|{
name|AGAIN
block|,
name|MUSTSETR
block|,
name|FIRST
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|checkmatchsize
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|regex_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|regsub
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|substitute
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|EXCMDARG
operator|*
operator|,
name|char
operator|*
operator|,
name|regex_t
operator|*
operator|,
expr|enum
name|which
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ex_substitute
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|cmdp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|EXCMDARG
modifier|*
name|cmdp
decl_stmt|;
block|{
name|regex_t
modifier|*
name|re
decl_stmt|,
name|lre
decl_stmt|;
name|int
name|eval
decl_stmt|,
name|reflags
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|,
modifier|*
name|sub
decl_stmt|;
name|char
name|delim
index|[
literal|2
index|]
decl_stmt|;
comment|/* 	 * Historic vi only permitted '/' to begin the substitution command. 	 * We permit ';' as well, since users often want to operate on UNIX 	 * pathnames.  We don't just allow anything because the flag chars 	 * wouldn't work. 	 */
if|if
condition|(
operator|*
name|cmdp
operator|->
name|string
operator|==
literal|'/'
operator|||
operator|*
name|cmdp
operator|->
name|string
operator|==
literal|';'
condition|)
block|{
comment|/* Delimiter is the first character. */
name|delim
index|[
literal|0
index|]
operator|=
name|cmdp
operator|->
name|string
index|[
literal|0
index|]
expr_stmt|;
name|delim
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get the substitute string. */
name|endp
operator|=
name|cmdp
operator|->
name|string
operator|+
literal|1
expr_stmt|;
name|sub
operator|=
name|strsep
argument_list|(
operator|&
name|endp
argument_list|,
name|delim
argument_list|)
expr_stmt|;
comment|/* Get the replacement string, save it off. */
if|if
condition|(
name|endp
operator|==
name|NULL
operator|||
operator|*
name|endp
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No replacement string specified."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sp
operator|->
name|repl
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sp
operator|->
name|repl
argument_list|)
expr_stmt|;
name|sp
operator|->
name|repl
operator|=
name|strsep
argument_list|(
operator|&
name|endp
argument_list|,
name|delim
argument_list|)
expr_stmt|;
name|sp
operator|->
name|repl
operator|=
name|strdup
argument_list|(
name|sp
operator|->
name|repl
argument_list|)
expr_stmt|;
name|sp
operator|->
name|repl_len
operator|=
name|strlen
argument_list|(
name|sp
operator|->
name|repl
argument_list|)
expr_stmt|;
comment|/* If the substitute string is empty, use the last one. */
if|if
condition|(
operator|*
name|sub
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_RE_SET
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No previous regular expression."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|checkmatchsize
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|sre
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|substitute
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|cmdp
argument_list|,
name|endp
condition|?
name|endp
else|:
literal|""
argument_list|,
operator|&
name|sp
operator|->
name|sre
argument_list|,
name|AGAIN
argument_list|)
operator|)
return|;
block|}
comment|/* Set RE flags. */
name|reflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_EXTENDED
argument_list|)
condition|)
name|reflags
operator||=
name|REG_EXTENDED
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_IGNORECASE
argument_list|)
condition|)
name|reflags
operator||=
name|REG_ICASE
expr_stmt|;
comment|/* Compile the RE. */
name|re
operator|=
operator|&
name|lre
expr_stmt|;
if|if
condition|(
name|eval
operator|=
name|regcomp
argument_list|(
name|re
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sub
argument_list|,
name|reflags
argument_list|)
condition|)
block|{
name|re_error
argument_list|(
name|sp
argument_list|,
name|eval
argument_list|,
name|re
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Set saved RE.  Historic practice is that substitutes set 		 * direction as well as the RE. 		 */
name|sp
operator|->
name|sre
operator|=
name|lre
expr_stmt|;
name|sp
operator|->
name|searchdir
operator|=
name|FORWARD
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_RE_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkmatchsize
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|sre
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|substitute
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|cmdp
argument_list|,
name|endp
condition|?
name|endp
else|:
literal|""
argument_list|,
name|re
argument_list|,
name|FIRST
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|substitute
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|cmdp
argument_list|,
name|cmdp
operator|->
name|string
argument_list|,
operator|&
name|sp
operator|->
name|sre
argument_list|,
name|MUSTSETR
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ex_subagain
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|cmdp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|EXCMDARG
modifier|*
name|cmdp
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_RE_SET
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No previous regular expression."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|substitute
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|cmdp
argument_list|,
name|cmdp
operator|->
name|string
argument_list|,
operator|&
name|sp
operator|->
name|sre
argument_list|,
name|AGAIN
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * The nasty part of the substitution is what happens when the replacement  * string contains newlines.  It's a bit tricky -- consider the information  * that has to be retained for "s/f\(o\)o/^M\1^M\1/".  The solution here is  * to build a set of newline offets which we use to break the line up later,  * when the replacement is done.  Don't change it unless you're pretty damned  * confident.  */
end_comment

begin_define
define|#
directive|define
name|NEEDNEWLINE
parameter_list|(
name|sp
parameter_list|)
value|{						\ 	if (sp->newl_len == sp->newl_cnt) {				\ 		sp->newl_len += 25;					\ 		if ((sp->newl = realloc(sp->newl,			\ 		    sp->newl_len * sizeof(size_t))) == NULL) {		\ 			msgq(sp, M_ERR,					\ 			    "Error: %s", strerror(errno));		\ 			sp->newl_len = 0;				\ 			return (1);					\ 		}							\ 	}								\ }
end_define

begin_define
define|#
directive|define
name|BUILD
parameter_list|(
name|sp
parameter_list|,
name|l
parameter_list|,
name|len
parameter_list|)
value|{						\ 	if (lbclen + (len)> lblen) {					\ 		lblen += MAX(lbclen + (len), 256);			\ 		if ((lb = realloc(lb, lblen)) == NULL) {		\ 			msgq(sp, M_ERR,					\ 			    "Error: %s", strerror(errno));		\ 			lbclen = 0;					\ 			return (1);					\ 		}							\ 	}								\ 	memmove(lb + lbclen, l, len);					\ 	lbclen += len;							\ }
end_define

begin_define
define|#
directive|define
name|NEEDSP
parameter_list|(
name|sp
parameter_list|,
name|len
parameter_list|,
name|pnt
parameter_list|)
value|{						\ 	if (lbclen + (len)> lblen) {					\ 		lblen += MAX(lbclen + (len), 256);			\ 		if ((lb = realloc(lb, lblen)) == NULL) {		\ 			msgq(sp, M_ERR,					\ 			    "Error: %s", strerror(errno));		\ 			lbclen = 0;					\ 			return (1);					\ 		}							\ 		pnt = lb + lbclen;					\ 	}								\ }
end_define

begin_comment
comment|/*  * substitute --  *	Do the substitution.  This stuff is *really* tricky.  There are  *	lots of special cases, and general nastiness.  Don't mess with it  * 	unless you're pretty confident.  */
end_comment

begin_function
specifier|static
name|int
name|substitute
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|cmdp
parameter_list|,
name|s
parameter_list|,
name|re
parameter_list|,
name|cmd
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|EXCMDARG
modifier|*
name|cmdp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|regex_t
modifier|*
name|re
decl_stmt|;
name|enum
name|which
name|cmd
decl_stmt|;
block|{
name|MARK
name|from
decl_stmt|,
name|to
decl_stmt|;
name|recno_t
name|elno
decl_stmt|,
name|lno
decl_stmt|,
name|lastline
decl_stmt|;
name|size_t
name|blen
decl_stmt|,
name|cnt
decl_stmt|,
name|last
decl_stmt|,
name|lbclen
decl_stmt|,
name|lblen
decl_stmt|,
name|len
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|eflags
decl_stmt|,
name|eval
decl_stmt|,
name|linechanged
decl_stmt|,
name|quit
decl_stmt|;
name|int
name|cflag
decl_stmt|,
name|gflag
decl_stmt|,
name|lflag
decl_stmt|,
name|nflag
decl_stmt|,
name|pflag
decl_stmt|,
name|rflag
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lb
decl_stmt|;
comment|/* 	 * Historic vi permitted the '#', 'l' and 'p' options in vi mode, 	 * but it only displayed the last change and they really don't 	 * make any sense.  In the current model the problem is combining 	 * them with the 'c' flag -- the screen would have to flip back 	 * and forth between the confirm screen and the ex print screen, 	 * which would be pretty awful.  Not worth the effort. 	 */
name|cflag
operator|=
name|gflag
operator|=
name|lflag
operator|=
name|nflag
operator|=
name|pflag
operator|=
name|rflag
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MODE_VI
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"'#' flag not supported in vi mode."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|nflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|gflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MODE_VI
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"'l' flag not supported in vi mode."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_MODE_VI
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"'p' flag not supported in vi mode."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|pflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|cmd
operator|==
name|FIRST
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Regular expression specified; r flag meaningless."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_RE_SET
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No previous regular expression."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rflag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
name|rflag
operator|==
literal|0
operator|&&
name|cmd
operator|==
name|MUSTSETR
condition|)
block|{
name|usage
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Usage: %s"
argument_list|,
name|cmdp
operator|->
name|cmd
operator|->
name|usage
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Get some space. */
name|GET_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/* 	 * lb:		build buffer pointer. 	 * lbclen:	current length of built buffer. 	 * lblen;	length of build buffer. 	 */
name|lb
operator|=
name|NULL
expr_stmt|;
name|lbclen
operator|=
name|lblen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Since multiple changes can happen in a line, we only increment 	 * the change count on the first change to a line. 	 */
name|lastline
operator|=
name|OOBLNO
expr_stmt|;
comment|/* For each line... */
for|for
control|(
name|quit
operator|=
literal|0
operator|,
name|lno
operator|=
name|cmdp
operator|->
name|addr1
operator|.
name|lno
operator|,
name|elno
operator|=
name|cmdp
operator|->
name|addr2
operator|.
name|lno
init|;
operator|!
name|quit
operator|&&
name|lno
operator|<=
name|elno
condition|;
operator|++
name|lno
control|)
block|{
comment|/* Get the line. */
if|if
condition|(
operator|(
name|s
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Make a local copy if doing confirmation -- when calling 		 * the confirm routine we're likely to lose our cached copy. 		 */
if|if
condition|(
name|cflag
condition|)
block|{
name|ADD_SPACE
argument_list|(
argument|sp
argument_list|,
argument|bp
argument_list|,
argument|blen
argument_list|,
argument|len
argument_list|)
name|memmove
argument_list|(
name|bp
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|=
name|bp
expr_stmt|;
block|}
comment|/* Reset the buffer pointer. */
name|lbclen
operator|=
literal|0
expr_stmt|;
comment|/* 		 * We don't want to have to do a setline if the line didn't 		 * change -- keep track of whether or not this line changed. 		 */
name|linechanged
operator|=
literal|0
expr_stmt|;
comment|/* It's not nul terminated, but we pretend it is. */
name|eflags
operator|=
name|REG_STARTEND
expr_stmt|;
comment|/* The search area is from 's' to the end of the line. */
name|nextmatch
label|:
name|sp
operator|->
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|=
name|len
expr_stmt|;
comment|/* Get the next match. */
name|skipmatch
label|:
name|eval
operator|=
name|regexec
argument_list|(
name|re
argument_list|,
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
name|re
operator|->
name|re_nsub
operator|+
literal|1
argument_list|,
name|sp
operator|->
name|match
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
comment|/* 		 * There wasn't a match -- if there was an error, deal with 		 * it.  If there was a previous match in this line, resolve 		 * the changes into the database.  Otherwise, just move on. 		 */
if|if
condition|(
name|eval
operator|==
name|REG_NOMATCH
condition|)
block|{
if|if
condition|(
name|linechanged
condition|)
goto|goto
name|endmatch
goto|;
continue|continue;
block|}
if|if
condition|(
name|eval
operator|!=
literal|0
condition|)
block|{
name|re_error
argument_list|(
name|sp
argument_list|,
name|eval
argument_list|,
name|re
argument_list|)
expr_stmt|;
goto|goto
name|ret1
goto|;
block|}
comment|/* Confirm change. */
if|if
condition|(
name|cflag
condition|)
block|{
comment|/* 			 * Set the cursor position for confirmation.  Note, 			 * if we matched on a '$', the cursor may be past 			 * the end of line. 			 * 			 * XXX 			 * May want to "fix" this in the confirm routine; 			 * the confirm routine may be able to display a 			 * cursor past EOL. 			 */
name|from
operator|.
name|lno
operator|=
name|lno
expr_stmt|;
name|from
operator|.
name|cno
operator|=
name|sp
operator|->
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
expr_stmt|;
name|to
operator|.
name|lno
operator|=
name|lno
expr_stmt|;
name|to
operator|.
name|cno
operator|=
name|sp
operator|->
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|to
operator|.
name|cno
operator|>=
name|len
condition|)
name|to
operator|.
name|cno
operator|=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|cno
operator|>=
name|len
condition|)
name|from
operator|.
name|cno
operator|=
name|len
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|sp
operator|->
name|s_confirm
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
condition|)
block|{
case|case
name|YES
case|:
break|break;
case|case
name|NO
case|:
comment|/* 				 * Copy the bytes before the match and the 				 * bytes in the match into the build buffer. 				 */
name|BUILD
argument_list|(
name|sp
argument_list|,
name|s
argument_list|,
name|sp
operator|->
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
case|case
name|QUIT
case|:
comment|/* Set the quit flag. */
name|quit
operator|=
literal|1
expr_stmt|;
comment|/* If in a global, pass the info back. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_GLOBAL
argument_list|)
condition|)
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_GLOBAL_QUIT
argument_list|)
expr_stmt|;
comment|/* 				 * If any changes, resolve them, otherwise 				 * return to the main loop. 				 */
if|if
condition|(
name|linechanged
condition|)
goto|goto
name|endmatch
goto|;
continue|continue;
block|}
block|}
comment|/* Copy the bytes before the match into the build buffer. */
name|BUILD
argument_list|(
name|sp
argument_list|,
name|s
argument_list|,
name|sp
operator|->
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
argument_list|)
expr_stmt|;
comment|/* Substitute the matching bytes. */
if|if
condition|(
name|regsub
argument_list|(
name|sp
argument_list|,
name|s
argument_list|,
operator|&
name|lb
argument_list|,
operator|&
name|lbclen
argument_list|,
operator|&
name|lblen
argument_list|)
condition|)
goto|goto
name|ret1
goto|;
comment|/* Set the change flag so we know this line was modified. */
name|linechanged
operator|=
literal|1
expr_stmt|;
comment|/* Move the pointers past the matched bytes. */
name|skip
label|:
name|s
operator|+=
name|sp
operator|->
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
name|len
operator|-=
name|sp
operator|->
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
comment|/* 		 * If doing a global change with confirmation, we have to 		 * update the screen.  The basic idea is to store the line 		 * so the screen update routines can find it, but start at 		 * the old offset. 		 */
if|if
condition|(
name|linechanged
operator|&&
name|gflag
operator|&&
name|cflag
condition|)
block|{
comment|/* Save offset. */
name|offset
operator|=
name|lbclen
expr_stmt|;
comment|/* Copy the suffix. */
if|if
condition|(
name|len
condition|)
name|BUILD
argument_list|(
argument|sp
argument_list|,
argument|s
argument_list|,
argument|len
argument_list|)
comment|/* Store inserted lines, adjusting the build buffer. */
name|last
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|newl_cnt
condition|)
block|{
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|sp
operator|->
name|newl_cnt
condition|;
operator|++
name|cnt
operator|,
operator|++
name|lno
operator|,
operator|++
name|elno
operator|,
operator|++
name|lastline
control|)
block|{
if|if
condition|(
name|file_iline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|lb
operator|+
name|last
argument_list|,
name|sp
operator|->
name|newl
index|[
name|cnt
index|]
operator|-
name|last
argument_list|)
condition|)
goto|goto
name|ret1
goto|;
name|last
operator|=
name|sp
operator|->
name|newl
index|[
name|cnt
index|]
operator|+
literal|1
expr_stmt|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_ADDED
index|]
expr_stmt|;
block|}
name|lbclen
operator|-=
name|last
expr_stmt|;
name|offset
operator|-=
name|last
expr_stmt|;
name|sp
operator|->
name|newl_cnt
operator|=
literal|0
expr_stmt|;
name|linechanged
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Store the changed line. */
if|if
condition|(
name|linechanged
condition|)
if|if
condition|(
name|file_sline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|lb
operator|+
name|last
argument_list|,
name|lbclen
argument_list|)
condition|)
goto|goto
name|ret1
goto|;
comment|/* Get a new copy of the line. */
if|if
condition|(
operator|(
name|s
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
goto|goto
name|ret1
goto|;
block|}
name|ADD_SPACE
argument_list|(
argument|sp
argument_list|,
argument|bp
argument_list|,
argument|blen
argument_list|,
argument|len
argument_list|)
name|memmove
argument_list|(
name|bp
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|=
name|bp
expr_stmt|;
comment|/* Restart the build. */
name|lbclen
operator|=
literal|0
expr_stmt|;
comment|/* Update changed line counter. */
if|if
condition|(
name|lastline
operator|!=
name|lno
condition|)
block|{
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_CHANGED
index|]
expr_stmt|;
name|lastline
operator|=
name|lno
expr_stmt|;
block|}
comment|/* Start in the middle of the line. */
name|sp
operator|->
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|=
name|offset
expr_stmt|;
name|sp
operator|->
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|=
name|len
expr_stmt|;
goto|goto
name|skipmatch
goto|;
block|}
comment|/* 		 * If it's a global change, and there's something left in 		 * the line, check it. 		 */
if|if
condition|(
name|len
operator|&&
name|gflag
condition|)
block|{
name|eflags
operator||=
name|REG_NOTBOL
expr_stmt|;
goto|goto
name|nextmatch
goto|;
block|}
comment|/* Copy any remaining bytes into the build buffer. */
name|endmatch
label|:
if|if
condition|(
name|len
condition|)
name|BUILD
argument_list|(
argument|sp
argument_list|,
argument|s
argument_list|,
argument|len
argument_list|)
comment|/* Store inserted lines, adjusting the build buffer. */
name|last
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|newl_cnt
condition|)
block|{
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|sp
operator|->
name|newl_cnt
condition|;
operator|++
name|cnt
operator|,
operator|++
name|lno
operator|,
operator|++
name|elno
operator|,
operator|++
name|lastline
control|)
block|{
if|if
condition|(
name|file_iline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|lb
operator|+
name|last
argument_list|,
name|sp
operator|->
name|newl
index|[
name|cnt
index|]
operator|-
name|last
argument_list|)
condition|)
goto|goto
name|ret1
goto|;
name|last
operator|=
name|sp
operator|->
name|newl
index|[
name|cnt
index|]
operator|+
literal|1
expr_stmt|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_ADDED
index|]
expr_stmt|;
block|}
name|lbclen
operator|-=
name|last
expr_stmt|;
name|sp
operator|->
name|newl_cnt
operator|=
literal|0
expr_stmt|;
name|linechanged
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Store the changed line. */
if|if
condition|(
name|linechanged
condition|)
if|if
condition|(
name|file_sline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|lb
operator|+
name|last
argument_list|,
name|lbclen
argument_list|)
condition|)
goto|goto
name|ret1
goto|;
comment|/* Update changed line counter. */
if|if
condition|(
name|lastline
operator|!=
name|lno
condition|)
block|{
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_CHANGED
index|]
expr_stmt|;
name|lastline
operator|=
name|lno
expr_stmt|;
block|}
comment|/* Display as necessary. */
if|if
condition|(
name|lflag
operator|||
name|nflag
operator|||
name|pflag
condition|)
block|{
name|from
operator|.
name|lno
operator|=
name|to
operator|.
name|lno
operator|=
name|lno
expr_stmt|;
name|from
operator|.
name|cno
operator|=
name|to
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lflag
condition|)
name|ex_print
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|,
name|E_F_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
name|ex_print
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|,
name|E_F_HASH
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflag
condition|)
name|ex_print
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|,
name|E_F_PRINT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Cursor moves to last line changed, unless doing confirm, 	 * in which case don't move it. 	 */
if|if
condition|(
operator|!
name|cflag
operator|&&
name|lastline
operator|!=
name|OOBLNO
condition|)
name|sp
operator|->
name|lno
operator|=
name|lastline
expr_stmt|;
comment|/* 	 * Note if nothing found.  Else, if nothing displayed to the 	 * screen, put something up. 	 */
if|if
condition|(
name|sp
operator|->
name|rptlines
index|[
name|L_CHANGED
index|]
operator|==
literal|0
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_GLOBAL
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"No match found."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|lflag
operator|&&
operator|!
name|nflag
operator|&&
operator|!
name|pflag
condition|)
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_AUTOPRINT
argument_list|)
expr_stmt|;
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|ret1
label|:
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * regsub --  * 	Do the substitution for a regular expression.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|regsub
parameter_list|(
name|sp
parameter_list|,
name|ip
parameter_list|,
name|lbp
parameter_list|,
name|lbclenp
parameter_list|,
name|lblenp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|ip
decl_stmt|;
comment|/* Input line. */
name|char
modifier|*
modifier|*
name|lbp
decl_stmt|;
name|size_t
modifier|*
name|lbclenp
decl_stmt|,
decl|*
name|lblenp
decl_stmt|;
end_function

begin_block
block|{
name|size_t
name|lbclen
decl_stmt|,
name|lblen
decl_stmt|;
comment|/* Local copies. */
name|size_t
name|mlen
decl_stmt|;
comment|/* Match length. */
name|size_t
name|rpl
decl_stmt|;
comment|/* Remaining replacement length. */
name|char
modifier|*
name|rp
decl_stmt|;
comment|/* Replacement pointer. */
name|int
name|ch
decl_stmt|;
name|int
name|no
decl_stmt|;
comment|/* Match replacement offset. */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Build buffer pointer. */
name|char
modifier|*
name|lb
decl_stmt|;
comment|/* Local copies. */
name|lb
operator|=
operator|*
name|lbp
expr_stmt|;
comment|/* Get local copies. */
name|lbclen
operator|=
operator|*
name|lbclenp
expr_stmt|;
name|lblen
operator|=
operator|*
name|lblenp
expr_stmt|;
name|rp
operator|=
name|sp
operator|->
name|repl
expr_stmt|;
comment|/* Set up replacment info. */
name|rpl
operator|=
name|sp
operator|->
name|repl_len
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lb
operator|+
name|lbclen
init|;
name|rpl
operator|--
condition|;
control|)
block|{
name|ch
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'&'
condition|)
block|{
comment|/* Entire pattern. */
name|no
operator|=
literal|0
expr_stmt|;
goto|goto
name|sub
goto|;
comment|/* Partial pattern. */
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
operator|&&
name|isdigit
argument_list|(
operator|*
name|rp
argument_list|)
condition|)
block|{
name|no
operator|=
operator|*
name|rp
operator|++
operator|-
literal|'0'
expr_stmt|;
operator|--
name|rpl
expr_stmt|;
name|sub
label|:
if|if
condition|(
name|sp
operator|->
name|match
index|[
name|no
index|]
operator|.
name|rm_so
operator|!=
operator|-
literal|1
operator|&&
name|sp
operator|->
name|match
index|[
name|no
index|]
operator|.
name|rm_eo
operator|!=
operator|-
literal|1
condition|)
block|{
name|mlen
operator|=
name|sp
operator|->
name|match
index|[
name|no
index|]
operator|.
name|rm_eo
operator|-
name|sp
operator|->
name|match
index|[
name|no
index|]
operator|.
name|rm_so
expr_stmt|;
name|NEEDSP
argument_list|(
name|sp
argument_list|,
name|mlen
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
name|ip
operator|+
name|sp
operator|->
name|match
index|[
name|no
index|]
operator|.
name|rm_so
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|mlen
expr_stmt|;
name|lbclen
operator|+=
name|mlen
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Newline, ordinary characters. */
if|if
condition|(
name|sp
operator|->
name|special
index|[
name|ch
index|]
operator|==
name|K_CR
operator|||
name|sp
operator|->
name|special
index|[
name|ch
index|]
operator|==
name|K_NL
condition|)
block|{
name|NEEDNEWLINE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|newl
index|[
name|sp
operator|->
name|newl_cnt
operator|++
index|]
operator|=
name|lbclen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
operator|&&
operator|(
operator|*
name|rp
operator|==
literal|'\\'
operator|||
operator|*
name|rp
operator|==
literal|'&'
operator|)
condition|)
name|ch
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
name|NEEDSP
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
operator|++
name|lbclen
expr_stmt|;
block|}
block|}
operator|*
name|lbp
operator|=
name|lb
expr_stmt|;
comment|/* Update caller's information. */
operator|*
name|lbclenp
operator|=
name|lbclen
expr_stmt|;
operator|*
name|lblenp
operator|=
name|lblen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|checkmatchsize
parameter_list|(
name|sp
parameter_list|,
name|re
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|regex_t
modifier|*
name|re
decl_stmt|;
block|{
comment|/* Build nsub array as necessary. */
if|if
condition|(
name|sp
operator|->
name|matchsize
operator|<
name|re
operator|->
name|re_nsub
operator|+
literal|1
condition|)
block|{
name|sp
operator|->
name|matchsize
operator|=
name|re
operator|->
name|re_nsub
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|match
operator|=
name|realloc
argument_list|(
name|sp
operator|->
name|match
argument_list|,
name|sp
operator|->
name|matchsize
operator|*
sizeof|sizeof
argument_list|(
name|regmatch_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Error: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|matchsize
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

