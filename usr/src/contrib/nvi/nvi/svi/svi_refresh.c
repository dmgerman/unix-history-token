begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)svi_refresh.c	8.1 (Berkeley) 6/9/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"svi_screen.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|svi_modeline
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svi_msgflush
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * svi_refresh --  *	This is the guts of the vi curses screen code.  The idea is that  *	the SCR structure passed in contains the new coordinates of the  *	screen.  What makes this hard is that we don't know how big  *	characters are, doing input can put the cursor in illegal places,  *	and we're frantically trying to avoid repainting unless it's  *	absolutely necessary.  If you change this code, you'd better know  *	what you're doing.  It's subtle and quick to anger.  */
end_comment

begin_function
name|int
name|svi_refresh
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|CHNAME
modifier|*
name|cname
decl_stmt|;
name|SMAP
modifier|*
name|smp
decl_stmt|,
name|tmp
decl_stmt|;
name|recno_t
name|lastline
decl_stmt|,
name|lcnt
decl_stmt|;
name|size_t
name|cwtotal
decl_stmt|,
name|cnt
decl_stmt|,
name|len
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
define|#
directive|define
name|LNO
value|sp->lno
define|#
directive|define
name|OLNO
value|sp->olno
define|#
directive|define
name|CNO
value|sp->cno
define|#
directive|define
name|OCNO
value|sp->ocno
define|#
directive|define
name|SCNO
value|sp->sc_col
comment|/* 	 * 1: Resize the window. 	 * 	 * Notice that a resize is requested, and set up everything so that 	 * the file gets reinitialized.  Done here, instead of in the vi 	 * loop because there may be other initialization that other screens 	 * need to do.  The actual changing of the row/column values was done 	 * by calling the ex options code which put them into the environment, 	 * which is used by curses.  Stupid, but ugly. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_RESIZE
argument_list|)
condition|)
block|{
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_SSWITCH
operator||
name|S_REFORMAT
operator||
name|S_REDRAW
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * 2: Reformat the lines. 	 * 	 * If the lines themselves have changed (:set list, for example), 	 * fill in the map from scratch.  Adjust the screen that's being 	 * displayed if the leftright flag is set. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_REFORMAT
argument_list|)
condition|)
block|{
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|HMAP
operator|->
name|lno
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
operator|&&
operator|(
name|cnt
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
operator|&
name|CNO
argument_list|)
operator|)
operator|!=
literal|1
condition|)
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
name|smp
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_REFORMAT
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 3: Line movement. 	 * 	 * Line changes can cause the top line to change as well.  As 	 * before, if the movement is large, the screen is repainted. 	 * 	 * 3a: Tiny screens. 	 * 	 * Tiny screens cannot be permitted into the "scrolling" parts of 	 * the smap code for two reasons.  If the screen size is 1 line, 	 * HMAP == TMAP and the code will quickly drop core.  If the screen 	 * size is 2, none of the divisions by 2 will work, and scrolling 	 * won't work.  In fact, because no line change will be less than 	 * HALFSCREEN(sp), we always ending up "filling" the map, with a 	 * P_MIDDLE flag, which isn't what the user wanted.  Tiny screens 	 * can go into the "fill" portions of the smap code, no problem. 	 */
if|if
condition|(
name|sp
operator|->
name|t_rows
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
name|LNO
operator|<
name|HMAP
operator|->
name|lno
condition|)
block|{
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|LNO
operator|>
name|TMAP
operator|->
name|lno
condition|)
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
name|P_BOTTOM
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|t_rows
operator|==
literal|1
condition|)
block|{
name|HMAP
operator|->
name|off
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
operator|&
name|CNO
argument_list|)
expr_stmt|;
goto|goto
name|paint
goto|;
block|}
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
goto|goto
name|adjust
goto|;
block|}
comment|/* 	 * 3b: Line down. 	 */
if|if
condition|(
name|LNO
operator|>=
name|HMAP
operator|->
name|lno
condition|)
block|{
if|if
condition|(
name|LNO
operator|<=
name|TMAP
operator|->
name|lno
condition|)
goto|goto
name|adjust
goto|;
comment|/* 		 * If less than half a screen away, scroll down until the 		 * line is on the screen. 		 */
name|lcnt
operator|=
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
name|LNO
argument_list|,
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
block|{
while|while
condition|(
name|lcnt
operator|--
condition|)
if|if
condition|(
name|svi_sm_1up
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|adjust
goto|;
block|}
comment|/* 		 * If less than a full screen from the bottom of the file, put 		 * the last line of the file on the bottom of the screen.  The 		 * calculation is safe because we know there's at least one 		 * full screen of lines, otherwise couldn't have gotten here. 		 */
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lastline
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tmp
operator|.
name|lno
operator|=
name|LNO
expr_stmt|;
name|tmp
operator|.
name|off
operator|=
literal|1
expr_stmt|;
name|lcnt
operator|=
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|tmp
argument_list|,
name|lastline
argument_list|,
name|sp
operator|->
name|t_rows
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
name|sp
operator|->
name|t_rows
condition|)
block|{
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lastline
argument_list|,
name|P_BOTTOM
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
goto|goto
name|adjust
goto|;
block|}
comment|/* 		 * If more than a full screen from the last line of the file, 		 * put the new line in the middle of the screen. 		 */
goto|goto
name|middle
goto|;
block|}
comment|/* 	 * 3c: Line up. 	 * 	 * If less than half a screen away, scroll up until the line is 	 * the first line on the screen. 	 */
name|lcnt
operator|=
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|HMAP
argument_list|,
name|LNO
argument_list|,
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
block|{
while|while
condition|(
name|lcnt
operator|--
condition|)
if|if
condition|(
name|svi_sm_1down
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|adjust
goto|;
block|}
comment|/* 	 * If less than half a screen from the top of the file, put the first 	 * line of the file at the top of the screen.  Otherwise, put the line 	 * in the middle of the screen. 	 */
name|tmp
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|tmp
operator|.
name|off
operator|=
literal|1
expr_stmt|;
name|lcnt
operator|=
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|tmp
argument_list|,
name|LNO
argument_list|,
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
literal|1
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|middle
label|:
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
name|P_MIDDLE
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
comment|/* 	 * At this point we know part of the line is on the screen.  Since 	 * scrolling is done using logical lines, not physical, all of the 	 * line may not be on the screen.  While that's not necessarily bad, 	 * if the part the cursor is on isn't there, we're going to lose. 	 * This can be tricky; if the line covers the entire screen, lno 	 * may be the same as both ends of the map.  This isn't a problem 	 * for left-right scrolling, the cursor movement code handles the 	 * problem. 	 * 	 * XXX 	 * There's a real performance issue here if editing *really* long 	 * lines.  This gets to the right spot by scrolling, and, in a 	 * binary, by scrolling hundreds of lines. 	 */
name|adjust
label|:
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
if|if
condition|(
name|LNO
operator|==
name|HMAP
operator|->
name|lno
condition|)
block|{
name|cnt
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
operator|&
name|CNO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
name|HMAP
operator|->
name|off
condition|)
while|while
condition|(
name|cnt
operator|<
name|HMAP
operator|->
name|off
condition|)
if|if
condition|(
name|svi_sm_1down
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|LNO
operator|==
name|TMAP
operator|->
name|lno
condition|)
block|{
name|cnt
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
operator|&
name|CNO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|TMAP
operator|->
name|off
condition|)
while|while
condition|(
name|cnt
operator|>
name|TMAP
operator|->
name|off
condition|)
if|if
condition|(
name|svi_sm_1up
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If the screen needs to be repainted, skip cursor optimization. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
condition|)
goto|goto
name|paint
goto|;
comment|/* 	 * 4: Cursor movements. 	 * 	 * Decide cursor position.  If the line has changed, the cursor has 	 * moved over a tab, or don't know where the cursor was, reparse the 	 * line.  Note, if we think that the cursor "hasn't moved", reparse 	 * the line.  This is 'cause if it hasn't moved, we've almost always 	 * lost track of it. 	 * 	 * Otherwise, we've just moved over fixed-width characters, and can 	 * calculate the left/right scrolling and cursor movement without 	 * reparsing the line.  Note that we don't know which (if any) of 	 * the characters between the old and new cursor positions changed. 	 * 	 * XXX 	 * With some work, it should be possible to handle tabs quickly, at 	 * least in obvious situations, like moving right and encountering 	 * a tab, without reparsing the whole line. 	 */
comment|/* 	 * If the line we're working with has changed, reparse. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_CUR_INVALID
argument_list|)
operator|||
name|LNO
operator|!=
name|OLNO
condition|)
block|{
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_CUR_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|slow
goto|;
block|}
comment|/* 	 * Otherwise, if nothing's changed, go fast.  The one exception is 	 * that a single character or no characters are both column 0, and, 	 * if the single character required multiple screen columns, there 	 * may have still been movement. 	 */
if|if
condition|(
name|CNO
operator|==
name|OCNO
condition|)
block|{
if|if
condition|(
name|CNO
operator|==
literal|0
condition|)
goto|goto
name|slow
goto|;
goto|goto
name|fast
goto|;
block|}
comment|/* 	 * Get the current line.  If this fails, we either have an empty 	 * file and can just repaint, or there's a real problem.  This 	 * isn't a performance issue because there aren't any ways to get 	 * here repeatedly. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lastline
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lastline
operator|==
literal|0
condition|)
goto|goto
name|slow
goto|;
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|LNO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* This is just a test. */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|CNO
operator|>=
name|len
operator|&&
name|len
operator|!=
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Error: %s/%d: cno (%u)>= len (%u)"
argument_list|,
name|tail
argument_list|(
name|__FILE__
argument_list|)
argument_list|,
name|__LINE__
argument_list|,
name|CNO
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * The basic scheme here is to look at the characters in between 	 * the old and new positions and decide how big they are on the 	 * screen, and therefore, how many screen positions to move. 	 */
name|cname
operator|=
name|sp
operator|->
name|cname
expr_stmt|;
if|if
condition|(
name|CNO
operator|<
name|OCNO
condition|)
block|{
comment|/* 		 * 4a: Cursor moved left. 		 * 		 * Point to the old character.  The old cursor position can 		 * be past EOL if, for example, we just deleted the rest of 		 * the line.  In this case, since we don't know the width of 		 * the characters we traversed, we have to do it slowly. 		 */
name|p
operator|+=
name|OCNO
expr_stmt|;
name|cnt
operator|=
operator|(
name|OCNO
operator|-
name|CNO
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|OCNO
operator|>=
name|len
condition|)
goto|goto
name|slow
goto|;
comment|/* 		 * Count up the widths of the characters.  If it's a tab 		 * character, go do it the the slow way. 		 */
for|for
control|(
name|cwtotal
operator|=
literal|0
init|;
name|cnt
operator|--
condition|;
name|cwtotal
operator|+=
name|cname
index|[
name|ch
index|]
operator|.
name|len
control|)
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|p
operator|--
operator|)
operator|==
literal|'\t'
condition|)
goto|goto
name|slow
goto|;
comment|/* 		 * Decrement the screen cursor by the total width of the 		 * characters minus 1. 		 */
name|cwtotal
operator|-=
literal|1
expr_stmt|;
comment|/* 		 * If we're moving left, and there's a wide character in the 		 * current position, go to the end of the character. 		 */
if|if
condition|(
name|cname
index|[
name|ch
index|]
operator|.
name|len
operator|>
literal|1
condition|)
name|cwtotal
operator|-=
name|cname
index|[
name|ch
index|]
operator|.
name|len
operator|-
literal|1
expr_stmt|;
comment|/* 		 * If the new column moved us out of the current screen, 		 * calculate a new screen. 		 */
if|if
condition|(
name|SCNO
operator|<
name|cwtotal
condition|)
block|{
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
operator|--
name|smp
operator|->
name|off
expr_stmt|;
goto|goto
name|paint
goto|;
block|}
goto|goto
name|slow
goto|;
block|}
name|SCNO
operator|-=
name|cwtotal
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * 4b: Cursor moved right. 		 * 		 * Point to the first character to the right. 		 */
name|p
operator|+=
name|OCNO
operator|+
literal|1
expr_stmt|;
name|cnt
operator|=
name|CNO
operator|-
name|OCNO
expr_stmt|;
comment|/* 		 * Count up the widths of the characters.  If it's a tab 		 * character, go do it the the slow way. 		 */
for|for
control|(
name|cwtotal
operator|=
literal|0
init|;
name|cnt
operator|--
condition|;
name|cwtotal
operator|+=
name|cname
index|[
name|ch
index|]
operator|.
name|len
control|)
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|p
operator|++
operator|)
operator|==
literal|'\t'
condition|)
goto|goto
name|slow
goto|;
comment|/* 		 * Increment the screen cursor by the total width of the 		 * characters. 		 */
name|SCNO
operator|+=
name|cwtotal
expr_stmt|;
comment|/* 		 * If the new column moved us out of the current screen, 		 * calculate a new screen. 		 */
if|if
condition|(
name|SCNO
operator|>=
name|SCREEN_COLS
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|SCNO
operator|-=
name|SCREEN_COLS
argument_list|(
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
operator|++
name|smp
operator|->
name|off
expr_stmt|;
goto|goto
name|paint
goto|;
block|}
goto|goto
name|slow
goto|;
block|}
block|}
name|fast
label|:
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Just move the cursor. */
name|y
operator|-=
name|sp
operator|->
name|s_off
expr_stmt|;
comment|/* Correct for split screen. */
goto|goto
name|update
goto|;
name|slow
label|:
comment|/* Find the current line in the map. */
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|->
name|lno
operator|!=
name|LNO
condition|;
operator|++
name|smp
control|)
empty_stmt|;
comment|/* 	 * If doing left-right scrolling, and the cursor movement has 	 * changed the screen being displayed, fix it. 	 */
if|if
condition|(
operator|!
name|ISINFOLINE
argument_list|(
name|sp
argument_list|,
name|smp
argument_list|)
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|cnt
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
operator|&
name|CNO
argument_list|)
operator|%
name|SCREEN_COLS
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
name|HMAP
operator|->
name|off
condition|)
block|{
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
name|smp
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
goto|goto
name|paint
goto|;
block|}
block|}
comment|/* Update all of the screen lines for this file line. */
for|for
control|(
init|;
name|smp
operator|<=
name|TMAP
operator|&&
name|smp
operator|->
name|lno
operator|==
name|LNO
condition|;
operator|++
name|smp
control|)
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|smp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|SCNO
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Not too bad, move the cursor. */
goto|goto
name|update
goto|;
comment|/* Lost big, do what you have to do. */
name|paint
label|:
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|smp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|SCNO
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
name|update
label|:
comment|/* Ring the bell if scheduled. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_BELLSCHED
argument_list|)
condition|)
name|svi_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * If the bottom line isn't in use by vi, display any 	 * messages or paint the mode line. 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
operator|&
name|sp
operator|->
name|bhdr
argument_list|,
name|HDR_INUSE
argument_list|)
condition|)
if|if
condition|(
name|sp
operator|->
name|msgp
operator|!=
name|NULL
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
operator|->
name|msgp
argument_list|,
name|M_EMPTY
argument_list|)
condition|)
name|svi_msgflush
argument_list|(
name|sp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_UPDATE_MODE
argument_list|)
condition|)
block|{
name|svi_modeline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
comment|/* Place the cursor. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|y
argument_list|,
name|SCNO
argument_list|)
expr_stmt|;
comment|/* Update saved information. */
name|OCNO
operator|=
name|CNO
expr_stmt|;
name|OLNO
operator|=
name|LNO
expr_stmt|;
name|sp
operator|->
name|sc_row
operator|=
name|y
expr_stmt|;
comment|/* Refresh the screen. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_REFRESH
argument_list|)
condition|)
block|{
name|wrefresh
argument_list|(
name|curscr
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_REFRESH
argument_list|)
expr_stmt|;
block|}
else|else
name|refresh
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_msgflush --  *	Flush any accumulated messages.  */
end_comment

begin_function
specifier|static
name|int
name|svi_msgflush
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|CHNAME
modifier|*
name|cname
decl_stmt|;
name|MSG
modifier|*
name|mp
decl_stmt|;
name|size_t
name|chlen
decl_stmt|,
name|len
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
define|#
directive|define
name|MCONTMSG
value|" [More ...]"
comment|/* Display the messages. */
name|cname
operator|=
name|sp
operator|->
name|cname
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|sp
operator|->
name|msgp
operator|,
name|p
operator|=
name|NULL
init|;
name|mp
operator|!=
name|NULL
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|mp
argument_list|,
name|M_EMPTY
argument_list|)
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
block|{
name|p
operator|=
name|mp
operator|->
name|mbuf
expr_stmt|;
name|lcont
label|:
comment|/* Move to the message line and clear it. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
comment|/* 		 * Turn on standout mode if requested, or, if we've split 		 * the screen and need a divider. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|mp
argument_list|,
name|M_INV_VIDEO
argument_list|)
operator|||
name|sp
operator|->
name|child
operator|!=
name|NULL
condition|)
name|standout
argument_list|()
expr_stmt|;
comment|/* 		 * Print up to the "more" message.  Avoid the last character 		 * in the last line, some hardware doesn't like it. 		 */
if|if
condition|(
name|svi_ncols
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|mp
operator|->
name|len
argument_list|,
name|NULL
argument_list|)
operator|<
name|sp
operator|->
name|cols
operator|-
literal|1
condition|)
name|len
operator|=
name|sp
operator|->
name|cols
operator|-
literal|1
expr_stmt|;
else|else
name|len
operator|=
operator|(
name|sp
operator|->
name|cols
operator|-
sizeof|sizeof
argument_list|(
name|MCONTMSG
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
name|mp
operator|->
name|len
condition|)
break|break;
name|ch
operator|=
operator|*
name|p
expr_stmt|;
name|chlen
operator|=
name|cname
index|[
name|ch
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|chlen
operator|>=
name|len
condition|)
break|break;
name|len
operator|-=
name|chlen
expr_stmt|;
operator|--
name|mp
operator|->
name|len
expr_stmt|;
name|ADDNSTR
argument_list|(
name|cname
index|[
name|ch
index|]
operator|.
name|name
argument_list|,
name|chlen
argument_list|)
expr_stmt|;
block|}
comment|/* If more, print continue message. */
if|if
condition|(
name|mp
operator|->
name|len
operator|||
name|mp
operator|->
name|next
operator|!=
name|NULL
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|mp
operator|->
name|next
argument_list|,
name|M_EMPTY
argument_list|)
condition|)
block|{
name|ADDNSTR
argument_list|(
name|MCONTMSG
argument_list|,
sizeof|sizeof
argument_list|(
name|MCONTMSG
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
while|while
condition|(
name|sp
operator|->
name|special
index|[
name|ch
operator|=
name|term_key
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
index|]
operator|!=
name|K_CR
operator|&&
operator|!
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
name|svi_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* Turn off standout mode. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|mp
argument_list|,
name|M_INV_VIDEO
argument_list|)
operator|||
name|sp
operator|->
name|child
operator|!=
name|NULL
condition|)
name|standend
argument_list|()
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|len
condition|)
goto|goto
name|lcont
goto|;
name|refresh
argument_list|()
expr_stmt|;
name|F_SET
argument_list|(
name|mp
argument_list|,
name|M_EMPTY
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RULERSIZE
value|15
end_define

begin_define
define|#
directive|define
name|MODESIZE
value|(RULERSIZE + 15)
end_define

begin_comment
comment|/*  * svi_modeline --  *	Update the mode line.  */
end_comment

begin_function
specifier|static
name|int
name|svi_modeline
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
name|buf
index|[
name|RULERSIZE
index|]
decl_stmt|;
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
comment|/* Display the dividing line. */
if|if
condition|(
name|sp
operator|->
name|child
operator|!=
name|NULL
condition|)
name|svi_divider
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Display the ruler and mode. */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_RULER
argument_list|)
operator|&&
name|sp
operator|->
name|cols
operator|>
name|RULERSIZE
operator|+
literal|2
condition|)
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|sp
operator|->
name|cols
operator|/
literal|2
operator|-
name|RULERSIZE
operator|/
literal|2
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%lu,%lu"
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
name|sp
operator|->
name|cno
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ADDSTR
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Show the mode.  Leave the last character blank, just in case 	 * it's a really dumb terminal with hardware scroll. 	 */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_SHOWMODE
argument_list|)
operator|&&
name|sp
operator|->
name|cols
operator|>
name|MODESIZE
condition|)
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|sp
operator|->
name|cols
operator|-
literal|8
argument_list|)
expr_stmt|;
name|s
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_INPUT
argument_list|)
condition|?
literal|"  Input "
else|:
literal|"Command "
expr_stmt|;
name|ADDSTR
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|svi_divider
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
define|#
directive|define
name|DIVIDESIZE
value|10
name|int
name|dividesize
decl_stmt|;
name|char
name|buf
index|[
name|DIVIDESIZE
operator|+
literal|1
index|]
decl_stmt|;
name|dividesize
operator|=
name|DIVIDESIZE
operator|>
name|sp
operator|->
name|cols
condition|?
name|sp
operator|->
name|cols
else|:
name|DIVIDESIZE
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|,
name|dividesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|standout
argument_list|()
operator|==
name|ERR
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ADDNSTR
argument_list|(
name|buf
argument_list|,
name|dividesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|standend
argument_list|()
operator|==
name|ERR
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

