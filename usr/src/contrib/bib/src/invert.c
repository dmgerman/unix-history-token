begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)invert.c	2.2	%G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  input:  records of lines, separated by blank lines     output: key:file1 start/length ... start/length:file2 start/length ... */
end_comment

begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_include
include|#
directive|include
file|"streams.h"
end_include

begin_include
include|#
directive|include
file|"bib.h"
end_include

begin_define
define|#
directive|define
name|isnull
parameter_list|(
name|x
parameter_list|)
value|(*(x) == NULL)
end_define

begin_define
define|#
directive|define
name|makelow
parameter_list|(
name|c
parameter_list|)
value|('A'<=(c)&& (c)<='Z' ? (c)-'A'+'a' : c)
end_define

begin_decl_stmt
name|int
name|max_kcnt
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  max number of keys                      */
end_comment

begin_decl_stmt
name|int
name|max_klen
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  max length of keys                      */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ignore
init|=
comment|/*  string of line starts to ignore         */
literal|"CNOPVX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|common
init|=
comment|/*  name of file of common words            */
name|COMFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|INDEX
init|=
comment|/*  name of output file                     */
name|INDXFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tmpfile
init|=
comment|/*  name of temporary file                  */
name|INVTEMPFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|silent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  0 => statistics printed			*/
end_comment

begin_comment
comment|/*  1 => no statisitics printed		*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|sort_it
init|=
literal|"sort -u +0 -1 +1 -2 +2n -3 +3n %s -o %s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|sortcmd
index|[
name|maxstr
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argcount
parameter_list|,
name|arglist
parameter_list|)
name|int
name|argcount
decl_stmt|;
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|input
decl_stmt|,
modifier|*
name|output
decl_stmt|;
name|long
name|int
name|start
decl_stmt|,
name|length
decl_stmt|;
name|char
name|word
index|[
name|maxstr
index|]
decl_stmt|;
name|int
name|kcnt
decl_stmt|;
name|char
name|tag_line
index|[
name|maxstr
index|]
decl_stmt|;
name|long
name|int
name|records
init|=
literal|0
decl_stmt|;
comment|/*  number of records read           */
name|long
name|int
name|keys
init|=
literal|0
decl_stmt|;
comment|/*  number of keys read (occurences) */
name|long
name|int
name|distinct
decl_stmt|;
comment|/*  number of distinct keys          */
name|long
name|int
name|shorten
parameter_list|()
function_decl|;
name|argc
operator|=
name|argcount
operator|-
literal|1
expr_stmt|;
name|argv
operator|=
name|arglist
operator|+
literal|1
expr_stmt|;
name|mktemp
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
name|output
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
for|for
control|(
name|flags
argument_list|()
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
operator|,
name|flags
argument_list|()
control|)
block|{
comment|/* open input file              */
name|filename
operator|=
operator|*
name|argv
expr_stmt|;
name|input
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invert: error in open of %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|start
operator|=
literal|0L
expr_stmt|;
name|length
operator|=
literal|0L
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
comment|/* each record  */
block|{
comment|/* find start of next record (exit if none)     */
name|start
operator|=
name|nextrecord
argument_list|(
name|input
argument_list|,
name|start
operator|+
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|EOF
condition|)
break|break;
name|records
operator|++
expr_stmt|;
name|kcnt
operator|=
literal|0
expr_stmt|;
name|length
operator|=
name|recsize
argument_list|(
name|input
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tag_line
argument_list|,
literal|" %s %ld %ld\n"
argument_list|,
name|filename
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
while|while
condition|(
name|ftell
argument_list|(
name|input
argument_list|)
operator|<
name|start
operator|+
name|length
operator|&&
name|kcnt
operator|<
name|max_kcnt
condition|)
block|{
name|getword
argument_list|(
name|input
argument_list|,
name|word
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
name|makekey
argument_list|(
name|word
argument_list|,
name|max_klen
argument_list|,
name|common
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isnull
argument_list|(
name|word
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
name|word
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|tag_line
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|kcnt
operator|++
expr_stmt|;
name|keys
operator|++
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sortcmd
argument_list|,
name|sort_it
argument_list|,
name|tmpfile
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|sortcmd
argument_list|)
expr_stmt|;
name|distinct
operator|=
name|shorten
argument_list|(
name|tmpfile
argument_list|,
name|INDEX
argument_list|)
expr_stmt|;
if|if
condition|(
name|silent
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld documents   %ld distinct keys  %ld key occurrences\n"
argument_list|,
name|records
argument_list|,
name|distinct
argument_list|,
name|keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Flag    Meaning                             Default     -ki     Keys per record                     100     -li     max Length of keys                  6     -%str   ignore lines that begin with %x     CNOPVX             where x is in str             str is a seq of chars     -cfile  file contains Common words          /usr/src/local/bib/common             do not use common words as keys     -pfile  name of output file                 INDEX     -s	    do not print statistics		statistics printed */
end_comment

begin_define
define|#
directive|define
name|operand
value|(strlen(*argv+2)==0 ? (argv++,argc--,*argv) : *argv+2)
end_define

begin_macro
name|flags
argument_list|()
end_macro

begin_block
block|{
for|for
control|(
init|;
name|argc
operator|>
literal|0
operator|&&
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'-'
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'k'
case|:
name|max_kcnt
operator|=
name|atoi
argument_list|(
name|operand
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|max_klen
operator|=
name|atoi
argument_list|(
name|operand
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|common
operator|=
name|operand
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|ignore
operator|=
operator|*
name|argv
operator|+
literal|2
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|INDEX
operator|=
name|operand
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|silent
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown flag '%s'\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  shorten(inf,outf): file "inf" consists of lines of the form:         key file start length     sorted by key and file.  replace lines with the same key     with one line of the form:         key:file1 start/length ... start/length:file2 start/length ...     rename as file "outf"     returns number of lines in output */
end_comment

begin_function
name|long
name|shorten
parameter_list|(
name|inf
parameter_list|,
name|outf
parameter_list|)
name|char
modifier|*
name|inf
decl_stmt|,
decl|*
name|outf
decl_stmt|;
end_function

begin_block
block|{
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|char
name|line
index|[
name|maxstr
index|]
decl_stmt|;
name|char
name|key
index|[
name|maxstr
index|]
decl_stmt|,
name|newkey
index|[
name|maxstr
index|]
decl_stmt|,
name|file
index|[
name|maxstr
index|]
decl_stmt|,
name|newfile
index|[
name|maxstr
index|]
decl_stmt|;
name|long
name|int
name|start
decl_stmt|,
name|length
decl_stmt|;
name|long
name|int
name|lines
init|=
literal|0
decl_stmt|;
name|in
operator|=
name|fopen
argument_list|(
name|inf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|out
operator|=
name|fopen
argument_list|(
name|outf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
operator|||
name|out
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invert: error in opening file for compression\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|getline
argument_list|(
name|in
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%s%s%ld%ld"
argument_list|,
name|key
argument_list|,
name|file
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s :%s %ld/%ld"
argument_list|,
name|key
argument_list|,
name|file
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|getline
argument_list|(
name|in
argument_list|,
name|line
argument_list|)
init|;
operator|!
name|feof
argument_list|(
name|in
argument_list|)
condition|;
name|getline
argument_list|(
name|in
argument_list|,
name|line
argument_list|)
control|)
block|{
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%s%s%ld%ld"
argument_list|,
name|newkey
argument_list|,
name|newfile
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|newkey
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|key
argument_list|,
name|newkey
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|file
argument_list|,
name|newfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n%s :%s %ld/%ld"
argument_list|,
name|key
argument_list|,
name|file
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|lines
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
name|newfile
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|file
argument_list|,
name|newfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|":%s %ld/%ld"
argument_list|,
name|file
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %ld/%ld"
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|lines
operator|++
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
operator|(
name|lines
operator|)
return|;
block|}
end_block

end_unit

