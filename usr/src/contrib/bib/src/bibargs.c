begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)bibargs.c	2.13	5/27/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*         Authored by: Tim Budd, University of Arizona, 1983.                 version 7/4/83          Various modifications suggested by:                 David Cherveny - Duke University Medical Center                 Phil Garrison - UC Berkeley                 M. J. Hawley - Yale University   	       version 8/23/1988 	  	 Adapted to use TiB style macro calls (i.e. |macro|) 	       A. Dain Samples             read argument strings for bib and listrefs         do name formatting, printing lines, other actions common to both                                                         */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"bib.h"
end_include

begin_define
define|#
directive|define
name|LINELENGTH
value|1024
end_define

begin_define
define|#
directive|define
name|MAXDEFS
value|500
end_define

begin_comment
comment|/* maximum number of defined words */
end_comment

begin_comment
comment|/* global variables */
end_comment

begin_decl_stmt
name|char
name|bibfname
index|[
literal|120
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file name currently being read            */
end_comment

begin_decl_stmt
name|int
name|biblineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number currently being referenced    */
end_comment

begin_decl_stmt
name|int
name|abbrev
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* automatically abbreviate names            */
end_comment

begin_decl_stmt
name|int
name|capsmcap
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print names in caps small caps (CACM form)*/
end_comment

begin_decl_stmt
name|int
name|TibOption
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* expect files in TiB format                */
end_comment

begin_decl_stmt
name|int
name|TibxOption
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to create files for bib2tib               */
end_comment

begin_decl_stmt
name|int
name|numrev
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of authors names to reverse        */
end_comment

begin_decl_stmt
name|int
name|edabbrev
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* abbreviate editors names ?                */
end_comment

begin_decl_stmt
name|int
name|edcapsmcap
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print editors in cap small caps           */
end_comment

begin_decl_stmt
name|int
name|ednumrev
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of editors to reverse              */
end_comment

begin_decl_stmt
name|int
name|max_klen
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max size of key			     */
end_comment

begin_decl_stmt
name|int
name|sort
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sort references ? (default no)            */
end_comment

begin_decl_stmt
name|int
name|foot
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* footnoted references ? (default endnotes) */
end_comment

begin_decl_stmt
name|int
name|doacite
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place citations ?                         */
end_comment

begin_decl_stmt
name|int
name|redefWarning
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* warnings on attempted redefs ?	     */
end_comment

begin_decl_stmt
name|int
name|hyphen
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hypenate contiguous references            */
end_comment

begin_decl_stmt
name|int
name|ordcite
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* order multiple citations                  */
end_comment

begin_decl_stmt
name|char
name|sortstr
index|[
literal|80
index|]
init|=
literal|"1"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sorting template                          */
end_comment

begin_decl_stmt
name|char
name|trailstr
index|[
literal|80
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trailing characters to output             */
end_comment

begin_decl_stmt
name|char
name|pfile
index|[
literal|400
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* private file name                         */
end_comment

begin_decl_stmt
name|int
name|personal
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* personal file given ? (default no)        */
end_comment

begin_decl_stmt
name|char
name|citetemplate
index|[
literal|80
index|]
init|=
literal|"1"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* citation template                         */
end_comment

begin_decl_stmt
name|struct
name|wordinfo
name|words
index|[
name|MAXDEFS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defined words */
end_comment

begin_decl_stmt
name|struct
name|wordinfo
modifier|*
name|wordhash
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|wordinfo
modifier|*
name|wordsearch
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|wordtop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of defined words         */
end_comment

begin_decl_stmt
name|char
name|letterSeen
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keeps track of keyletters 		       * so we know whether to emit a .ds 		       * or a .as  		      /* */
end_comment

begin_comment
comment|/* where output goes */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|tfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference file information */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|refinfo
name|refinfo
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|reffile
index|[]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|INCORE
end_ifndef

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|rfd
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not INCORE
end_endif

begin_decl_stmt
specifier|extern
name|int
name|numrefs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|programName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|usageArr
index|[]
init|=
block|{
literal|"-aa    abbreviate authors' first names"
block|,
literal|"-arN   reverse first N authors' names; no N, do all"
block|,
literal|"-ax    print authors' last names in Caps-Small"
block|,
literal|"-cS    use template S for citations"
block|,
literal|"-d	change the default directory"
block|,
literal|"-ea    abbreviate editors' first names"
block|,
literal|"-ex    print editors' last names in Caps-Small"
block|,
literal|"-erN   reverse first N editors' names; no N, do all"
block|,
literal|"-f     dump reference after citation for footnotes"
block|,
literal|"-iFILE process FILE (e.g. a file of definitions)"
block|,
literal|"-h     hyphenate sequences of citations (turns on -o)"
block|,
literal|"-nS    turn off options; S is composed of the option letters 'afhosx'"
block|,
literal|"-pFILE search these FILEs (comma separated list) instead of INDEX"
block|,
literal|"-R	print warnings when duplicate definitions of names are ignored"
block|,
literal|"-sS    sort references according to template S"
block|,
literal|"-tTYPE use the style TYPE"
block|,
literal|"-Tib   expect files to be in TiB format (which see)"
block|,
literal|"-Tibx	write a file for converting bib to TiB-style |macros|"
block|,
literal|""
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|usageErr
parameter_list|(
name|argv0
parameter_list|,
name|opt
parameter_list|,
name|str
parameter_list|)
name|char
modifier|*
name|argv0
decl_stmt|;
name|char
modifier|*
name|opt
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Illegal invocation of %s.  Acceptable options:\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Argument: %s\n"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Problem:  %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|usageArr
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    %s\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* bibwarning - print out a warning message */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|bibwarning
argument_list|(
argument|msg
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: `%s', line %d: "
argument_list|,
name|programName
argument_list|,
name|bibfname
argument_list|,
name|biblineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* doargs - read command argument line for both bib and listrefs             set switch values             call rdtext on file arguments, after dumping             default style file if no alternative style is given */
end_comment

begin_decl_stmt
name|int
name|doargs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|defstyle
argument_list|)
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
name|defstyle
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|numfiles
decl_stmt|,
name|i
decl_stmt|,
name|style
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|walloc
argument_list|()
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|numfiles
operator|=
literal|0
expr_stmt|;
name|style
operator|=
name|true
expr_stmt|;
name|TibxOption
operator|=
name|false
expr_stmt|;
name|newbibdir
argument_list|(
name|BMACLIB
argument_list|)
expr_stmt|;
name|programName
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
for|for
control|(
name|p
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'a'
operator|||
operator|*
name|p
operator|==
literal|0
condition|)
name|abbrev
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'x'
condition|)
name|capsmcap
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
condition|)
name|numrev
operator|=
name|atoi
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|numrev
operator|=
literal|1000
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"citation string expected for 'c'"
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|p
operator|=
name|citetemplate
operator|,
name|q
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
init|;
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
condition|;
control|)
empty_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|)
name|p
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
comment|/* take next arg */
name|i
operator|++
expr_stmt|;
name|p
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
name|newbibdir
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
for|for
control|(
name|p
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'a'
condition|)
name|edabbrev
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'x'
condition|)
name|edcapsmcap
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
condition|)
name|ednumrev
operator|=
name|atoi
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|ednumrev
operator|=
literal|1000
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'f'
case|:
name|CASE_f
label|:
name|foot
operator|=
name|true
expr_stmt|;
name|hyphen
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|CASE_i
label|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|)
name|p
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
comment|/* take next arg */
name|i
operator|++
expr_stmt|;
name|p
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
name|incfile
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|)
block|{
name|max_klen
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_klen
operator|>
name|REFSIZE
condition|)
name|error
argument_list|(
literal|"too long key size"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"-l needs a numeric value"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'h'
case|:
name|hyphen
operator|=
name|ordcite
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
for|for
control|(
name|p
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'a'
condition|)
name|abbrev
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'f'
condition|)
name|foot
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'h'
condition|)
name|hyphen
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'o'
condition|)
name|ordcite
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'R'
condition|)
name|redefWarning
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'r'
condition|)
name|numrev
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'s'
condition|)
name|sort
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'x'
condition|)
name|capsmcap
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'v'
condition|)
name|doacite
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|ordcite
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|)
name|p
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
comment|/* take next arg */
name|i
operator|++
expr_stmt|;
name|p
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|pfile
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|personal
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|redefWarning
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|0
condition|)
comment|/* synonym -ar */
name|numrev
operator|=
literal|1000
expr_stmt|;
else|else
name|numrev
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sort
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|)
for|for
control|(
name|p
operator|=
name|sortstr
operator|,
name|q
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
init|;
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
condition|;
control|)
empty_stmt|;
break|break;
case|case
literal|'t'
case|:
name|style
operator|=
name|false
expr_stmt|;
goto|goto
name|CASE_i
goto|;
case|case
literal|'T'
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"Tib"
argument_list|,
operator|&
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|)
argument_list|)
operator|==
literal|0
condition|)
name|TibOption
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"Tibx"
argument_list|,
operator|&
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|)
argument_list|)
operator|==
literal|0
condition|)
name|TibxOption
operator|=
name|true
expr_stmt|;
else|else
block|{
name|usageErr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|"Did you want the Tib option?"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"'%s' invalid switch"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
name|doacite
operator|=
name|false
expr_stmt|;
goto|goto
name|CASE_f
goto|;
case|case
literal|'x'
case|:
name|capsmcap
operator|=
name|true
expr_stmt|;
comment|/* synonym for -ax */
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|style
condition|)
block|{
comment|/* no style command given, take default */
name|style
operator|=
name|false
expr_stmt|;
name|incfile
argument_list|(
name|defstyle
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|bibfname
argument_list|,
literal|"<stdin>"
argument_list|)
expr_stmt|;
name|rdtext
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|numfiles
operator|++
expr_stmt|;
break|break;
default|default:
name|usageErr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|"Invalid switch"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"'%c' invalid switch"
argument_list|,
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* file name */
name|numfiles
operator|++
expr_stmt|;
if|if
condition|(
name|style
condition|)
block|{
name|style
operator|=
name|false
expr_stmt|;
name|incfile
argument_list|(
name|defstyle
argument_list|)
expr_stmt|;
block|}
name|fd
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"can't open file %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|bibfname
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rdtext
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|style
condition|)
name|incfile
argument_list|(
name|defstyle
argument_list|)
expr_stmt|;
if|if
condition|(
name|TibxOption
condition|)
block|{
comment|/*      Emits m4 macros that allow easy transformation of old bib-style      bibliographic databases into tib-style.  The primary problem       (although not the only one) is the change of |macro| calls.       */
name|reg
name|struct
name|wordinfo
modifier|*
name|wp
decl_stmt|;
name|FILE
modifier|*
name|outf
decl_stmt|;
name|outf
operator|=
name|fopen
argument_list|(
literal|"bib.m4.in"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|wp
operator|=
name|wordhash
index|[
name|i
index|]
init|;
name|wp
operator|!=
name|NULL
condition|;
name|wp
operator|=
name|wp
operator|->
name|wi_hp
control|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"define(%s,|%s__m4_|)dnl\n"
argument_list|,
name|wp
operator|->
name|wi_word
argument_list|,
name|wp
operator|->
name|wi_word
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|outf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|numfiles
operator|)
return|;
block|}
end_block

begin_macro
name|newbibdir
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|strreplace
argument_list|(
name|COMFILE
argument_list|,
name|BMACLIB
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strreplace
argument_list|(
name|DEFSTYLE
argument_list|,
name|BMACLIB
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|BMACLIB
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|wordrestuff
argument_list|(
literal|"BMACLIB"
argument_list|,
name|BMACLIB
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tfd
argument_list|,
literal|".ds l] %s\n"
argument_list|,
name|BMACLIB
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* incfile - read in an included file  */
end_comment

begin_macro
name|incfile
argument_list|(
argument|np
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|name
index|[
literal|120
index|]
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|line
index|[
name|LINELENGTH
index|]
decl_stmt|,
name|dline
index|[
name|LINELENGTH
index|]
decl_stmt|,
name|word
index|[
literal|80
index|]
decl_stmt|,
modifier|*
name|tfgets
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|,
name|getwrd
argument_list|()
decl_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|bibfname
argument_list|)
expr_stmt|;
comment|/* temporary save in case of errors */
comment|/* first try ./<yourfile> */
name|strcpy
argument_list|(
name|bibfname
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|bibfname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* try BMACLIB/<yourfile> */
if|if
condition|(
name|fd
operator|==
name|NULL
operator|&&
operator|*
name|np
operator|!=
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|name
argument_list|,
name|BMACLIB
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bibfname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|bibfname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
comment|/* try BMACLIB/tibmacs/<yourfile> */
if|if
condition|(
name|TibOption
operator|&&
name|fd
operator|==
name|NULL
operator|&&
operator|*
name|np
operator|!=
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|name
argument_list|,
name|BMACLIB
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|"/tibmacs/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bibfname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|bibfname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
comment|/* try BMACLIB/bibmacs/<yourfile> */
if|if
condition|(
operator|!
name|TibOption
operator|&&
name|fd
operator|==
name|NULL
operator|&&
operator|*
name|np
operator|!=
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|name
argument_list|,
name|BMACLIB
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|"/bibmacs/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bibfname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|bibfname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
comment|/* try ./bib.<yourfile> */
if|if
condition|(
name|fd
operator|==
name|NULL
operator|&&
operator|*
name|np
operator|!=
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"bib."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bibfname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|bibfname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
comment|/* try BMACLIB/bib.<yourfile> */
if|if
condition|(
name|fd
operator|==
name|NULL
operator|&&
operator|*
name|np
operator|!=
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|name
argument_list|,
name|BMACLIB
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|"/bib."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bibfname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|bibfname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
comment|/* unsave old name */
name|strcpy
argument_list|(
name|bibfname
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|bibwarning
argument_list|(
literal|"%s: can't find"
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* now go off and process file */
name|biblineno
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|tfgets
argument_list|(
name|line
argument_list|,
name|LINELENGTH
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|biblineno
operator|++
expr_stmt|;
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'#'
case|:
break|break;
case|case
literal|'A'
case|:
for|for
control|(
name|p
operator|=
operator|&
name|line
index|[
literal|1
index|]
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'A'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|abbrev
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'X'
condition|)
name|capsmcap
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'R'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
condition|)
name|numrev
operator|=
name|atoi
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|numrev
operator|=
literal|1000
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'C'
case|:
for|for
control|(
name|p
operator|=
operator|&
name|line
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|==
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|strcpy
argument_list|(
name|citetemplate
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
operator|(
name|i
operator|=
name|getwrd
argument_list|(
name|line
argument_list|,
literal|1
argument_list|,
name|word
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"word expected in definition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordsearch
argument_list|(
name|word
argument_list|)
condition|)
block|{
comment|/* already there-toss rest of def.*/
if|if
condition|(
name|redefWarning
condition|)
name|bibwarning
argument_list|(
literal|"Attempted redefine of %s ignored."
argument_list|,
name|word
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|tfgets
argument_list|(
name|line
argument_list|,
name|LINELENGTH
argument_list|,
name|fd
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
break|break;
block|}
for|for
control|(
name|p
operator|=
operator|&
name|line
index|[
name|i
index|]
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
for|for
control|(
name|strcpy
argument_list|(
name|dline
argument_list|,
name|p
argument_list|)
init|;
name|dline
index|[
name|strlen
argument_list|(
name|dline
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|;
control|)
block|{
name|dline
index|[
name|strlen
argument_list|(
name|dline
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|tfgets
argument_list|(
name|line
argument_list|,
name|LINELENGTH
argument_list|,
name|fd
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|strcat
argument_list|(
name|dline
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|wordstuff
argument_list|(
name|word
argument_list|,
name|dline
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|p
operator|=
operator|&
name|line
index|[
literal|1
index|]
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'A'
condition|)
name|edabbrev
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'X'
condition|)
name|edcapsmcap
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'R'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
condition|)
name|ednumrev
operator|=
name|atoi
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|ednumrev
operator|=
literal|1000
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'F'
case|:
name|foot
operator|=
name|true
expr_stmt|;
name|hyphen
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
for|for
control|(
name|p
operator|=
operator|&
name|line
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|==
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|expand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|incfile
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|hyphen
operator|=
name|ordcite
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|ordcite
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|line
index|[
literal|1
index|]
operator|==
literal|0
condition|)
comment|/* this is now replaced by AR */
name|numrev
operator|=
literal|1000
expr_stmt|;
else|else
name|numrev
operator|=
name|atoi
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|sort
operator|=
name|true
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|line
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|==
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|strcpy
argument_list|(
name|sortstr
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
for|for
control|(
name|p
operator|=
operator|&
name|line
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|==
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|strcpy
argument_list|(
name|trailstr
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|capsmcap
operator|=
name|true
expr_stmt|;
comment|/* this is now replace by AX */
break|break;
default|default:
name|fprintf
argument_list|(
name|tfd
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|LINELENGTH
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|line
argument_list|,
name|tfd
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* close up */
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* error - report unrecoverable error message */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|error
argument_list|(
argument|str
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bibwarning
argument_list|(
name|str
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
comment|/*    *	clean up temp files and exit    */
name|cleanup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|INCORE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|READWRITE
end_ifdef

begin_comment
comment|/* ** fixrfd( mode ) -- re-opens the rfd file to be read or write, **      depending on the mode.  Uses a static int to save the current mode **      and avoid unnecessary re-openings. */
end_comment

begin_expr_stmt
name|fixrfd
argument_list|(
name|mode
argument_list|)
specifier|register
name|int
name|mode
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|int
name|cur_mode
init|=
name|WRITE
decl_stmt|;
comment|/* rfd open for writing initially */
if|if
condition|(
name|mode
operator|!=
name|cur_mode
condition|)
block|{
name|rfd
operator|=
name|freopen
argument_list|(
name|reffile
argument_list|,
operator|(
operator|(
name|mode
operator|==
name|READ
operator|)
condition|?
literal|"r"
else|:
literal|"a"
operator|)
argument_list|,
name|rfd
argument_list|)
expr_stmt|;
name|cur_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|rfd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Hell!  Couldn't re-open reference file %s"
argument_list|,
name|reffile
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
endif|not INCORE
end_endif

begin_comment
comment|/* tfgets - fgets which trims off newline */
end_comment

begin_function
name|char
modifier|*
name|tfgets
parameter_list|(
name|line
parameter_list|,
name|n
parameter_list|,
name|ptr
parameter_list|)
name|char
name|line
index|[]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|FILE
modifier|*
name|ptr
decl_stmt|;
block|{
name|reg
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|fgets
argument_list|(
name|line
argument_list|,
name|n
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
for|for
control|(
name|p
operator|=
name|line
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|line
operator|)
return|;
block|}
end_function

begin_comment
comment|/* getwrd - place next word from in[i] into out */
end_comment

begin_decl_stmt
name|int
name|getwrd
argument_list|(
name|in
argument_list|,
name|i
argument_list|,
name|out
argument_list|)
name|reg
name|char
name|in
index|[]
decl_stmt|,
name|out
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|reg
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|j
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|in
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|in
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|)
while|while
condition|(
name|in
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
name|in
index|[
name|i
index|]
argument_list|)
condition|)
name|out
index|[
name|j
operator|++
index|]
operator|=
name|in
index|[
name|i
operator|++
index|]
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
comment|/* signals end of in[i..]   */
name|out
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/* walloc - allocate enough space for a word */
end_comment

begin_function
name|char
modifier|*
name|walloc
parameter_list|(
name|word
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
block|{
name|char
modifier|*
name|i
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|;
name|i
operator|=
name|malloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"out of storage"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|i
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* isword - see if character is legit word char */
end_comment

begin_define
define|#
directive|define
name|iswordc
parameter_list|(
name|c
parameter_list|)
value|(isalnum(c) || c == '&' || c == '_')
end_define

begin_macro
name|expand
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|line2
index|[
name|REFSIZE
index|]
decl_stmt|,
name|word
index|[
name|REFSIZE
index|]
decl_stmt|;
name|reg
name|struct
name|wordinfo
modifier|*
name|wp
decl_stmt|;
name|reg
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|w
decl_stmt|;
name|q
operator|=
name|line2
expr_stmt|;
if|if
condition|(
name|TibOption
condition|)
block|{
comment|/* expand only macro names in |name| vertical bars; name must exist */
for|for
control|(
name|p
operator|=
name|line
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
comment|/* VOID */
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|w
operator|=
name|word
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'|'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|*
name|w
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|w
operator|=
literal|'\0'
expr_stmt|;
comment|/* skip second '|', if present */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'|'
condition|)
block|{
operator|--
name|p
expr_stmt|;
name|bibwarning
argument_list|(
literal|"Unbalanced |macro| bars\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|wp
operator|=
name|wordsearch
argument_list|(
name|word
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|word
argument_list|,
name|wp
operator|->
name|wi_def
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|wi_expanding
condition|)
block|{
name|bibwarning
argument_list|(
literal|"Recursive definition for |%s|\n"
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wp
operator|->
name|wi_expanding
operator|=
name|true
expr_stmt|;
name|expand
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|wp
operator|->
name|wi_expanding
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
name|errword
index|[
name|REFSIZE
index|]
decl_stmt|;
name|bibwarning
argument_list|(
literal|"word |%s| not defined\n"
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|errword
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|errword
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|errword
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
name|wordstuff
argument_list|(
name|word
argument_list|,
name|errword
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|word
argument_list|,
name|errword
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|w
operator|=
name|word
init|;
operator|*
name|w
operator|!=
literal|'\0'
condition|;
operator|*
name|q
operator|++
operator|=
operator|*
name|w
operator|++
control|)
empty_stmt|;
block|}
else|else
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|line
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
comment|/*VOID*/
control|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
for|for
control|(
name|w
operator|=
name|word
init|;
operator|*
name|p
operator|&&
name|iswordc
argument_list|(
operator|*
name|p
argument_list|)
condition|;
control|)
operator|*
name|w
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|w
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wp
operator|=
name|wordsearch
argument_list|(
name|word
argument_list|)
condition|)
block|{
if|if
condition|(
name|wp
operator|->
name|wi_expanding
condition|)
name|bibwarning
argument_list|(
literal|"Recursive definition for %s\n"
argument_list|,
name|word
argument_list|)
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|word
argument_list|,
name|wp
operator|->
name|wi_def
argument_list|)
expr_stmt|;
name|wp
operator|->
name|wi_expanding
operator|=
name|true
expr_stmt|;
name|expand
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|wp
operator|->
name|wi_expanding
operator|=
name|false
expr_stmt|;
block|}
block|}
for|for
control|(
name|w
operator|=
name|word
init|;
operator|*
name|w
operator|!=
literal|'\0'
condition|;
operator|*
name|q
operator|++
operator|=
operator|*
name|w
operator|++
control|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|line2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* wordstuff- save a word and its definition, building a hash table */
end_comment

begin_macro
name|wordstuff
argument_list|(
argument|word
argument_list|,
argument|def
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|word
decl_stmt|,
modifier|*
name|def
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wordtop
operator|>=
name|MAXDEFS
condition|)
name|error
argument_list|(
literal|"too many definitions, max of %d"
argument_list|,
name|MAXDEFS
argument_list|)
expr_stmt|;
name|words
index|[
name|wordtop
index|]
operator|.
name|wi_length
operator|=
name|strlen
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|words
index|[
name|wordtop
index|]
operator|.
name|wi_word
operator|=
name|word
condition|?
name|walloc
argument_list|(
name|word
argument_list|)
else|:
name|NULL
expr_stmt|;
name|words
index|[
name|wordtop
index|]
operator|.
name|wi_def
operator|=
name|def
condition|?
name|walloc
argument_list|(
name|def
argument_list|)
else|:
name|NULL
expr_stmt|;
name|i
operator|=
name|strhash
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|words
index|[
name|wordtop
index|]
operator|.
name|wi_expanding
operator|=
name|false
expr_stmt|;
name|words
index|[
name|wordtop
index|]
operator|.
name|wi_hp
operator|=
name|wordhash
index|[
name|i
index|]
expr_stmt|;
name|wordhash
index|[
name|i
index|]
operator|=
operator|&
name|words
index|[
name|wordtop
index|]
expr_stmt|;
name|wordtop
operator|++
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|wordinfo
modifier|*
name|wordsearch
parameter_list|(
name|word
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
block|{
name|reg
name|int
name|lg
decl_stmt|;
name|reg
name|struct
name|wordinfo
modifier|*
name|wp
decl_stmt|;
name|lg
operator|=
name|strlen
argument_list|(
name|word
argument_list|)
expr_stmt|;
for|for
control|(
name|wp
operator|=
name|wordhash
index|[
name|strhash
argument_list|(
name|word
argument_list|)
index|]
init|;
name|wp
condition|;
name|wp
operator|=
name|wp
operator|->
name|wi_hp
control|)
block|{
if|if
condition|(
name|wp
operator|->
name|wi_length
operator|==
name|lg
operator|&&
operator|(
name|strcmp
argument_list|(
name|wp
operator|->
name|wi_word
argument_list|,
name|word
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|wp
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* wordrestuff - save a word and its definition, but replace any existing  * definition; this could be more efficient, but it is only used to  * redefine BMACLIB at the present.  -ads 8/88  */
end_comment

begin_macro
name|wordrestuff
argument_list|(
argument|word
argument_list|,
argument|def
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|word
decl_stmt|,
modifier|*
name|def
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|wordinfo
modifier|*
name|wp
init|=
name|wordsearch
argument_list|(
name|word
argument_list|)
decl_stmt|;
if|if
condition|(
name|wp
operator|==
name|NULL
condition|)
name|wordstuff
argument_list|(
name|word
argument_list|,
name|def
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|wp
operator|->
name|wi_word
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|wp
operator|->
name|wi_word
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|wi_def
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|wp
operator|->
name|wi_def
argument_list|)
expr_stmt|;
name|wp
operator|->
name|wi_length
operator|=
name|strlen
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|wp
operator|->
name|wi_word
operator|=
name|word
condition|?
name|walloc
argument_list|(
name|word
argument_list|)
else|:
name|NULL
expr_stmt|;
name|wp
operator|->
name|wi_def
operator|=
name|def
condition|?
name|walloc
argument_list|(
name|def
argument_list|)
else|:
name|NULL
expr_stmt|;
name|wp
operator|->
name|wi_expanding
operator|=
name|false
expr_stmt|;
block|}
block|}
end_block

begin_function
name|int
name|strhash
parameter_list|(
name|str
parameter_list|)
name|reg
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|reg
name|int
name|value
init|=
literal|0
decl_stmt|;
for|for
control|(
name|value
operator|=
literal|0
init|;
operator|*
name|str
condition|;
name|value
operator|<<=
literal|2
operator|,
name|value
operator|+=
operator|*
name|str
operator|++
control|)
comment|/*VOID*/
empty_stmt|;
name|value
operator|%=
name|HASHSIZE
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|value
operator|+=
name|HASHSIZE
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* rdref - read text for an already cited reference */
end_comment

begin_macro
name|rdref
argument_list|(
argument|p
argument_list|,
argument|ref
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|refinfo
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ref
index|[
name|REFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ref
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|INCORE
ifdef|#
directive|ifdef
name|READWRITE
name|fixrfd
argument_list|(
name|READ
argument_list|)
expr_stmt|;
comment|/* fix access mode of rfd, if nec. */
endif|#
directive|endif
name|fseek
argument_list|(
name|rfd
argument_list|,
name|p
operator|->
name|ri_pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|ref
argument_list|,
name|p
operator|->
name|ri_length
argument_list|,
literal|1
argument_list|,
name|rfd
argument_list|)
expr_stmt|;
else|#
directive|else
else|INCORE
name|strcpy
argument_list|(
name|ref
argument_list|,
name|p
operator|->
name|ri_ref
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|INCORE
block|}
end_block

begin_comment
comment|/* wrref - write text for a new reference */
end_comment

begin_macro
name|wrref
argument_list|(
argument|p
argument_list|,
argument|ref
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|refinfo
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ref
index|[
name|REFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|INCORE
ifdef|#
directive|ifdef
name|READWRITE
name|fixrfd
argument_list|(
name|WRITE
argument_list|)
expr_stmt|;
comment|/* fix access mode of rfd, if nec. */
else|#
directive|else
name|fseek
argument_list|(
name|rfd
argument_list|,
name|p
operator|->
name|ri_pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* go to end of rfd */
endif|#
directive|endif
name|fwrite
argument_list|(
name|ref
argument_list|,
name|p
operator|->
name|ri_length
argument_list|,
literal|1
argument_list|,
name|rfd
argument_list|)
expr_stmt|;
else|#
directive|else
else|INCORE
name|p
operator|->
name|ri_ref
operator|=
name|walloc
argument_list|(
name|ref
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|INCORE
block|}
end_block

begin_comment
comment|/* breakname - break a name into first and last name */
end_comment

begin_macro
name|breakname
argument_list|(
argument|line
argument_list|,
argument|first
argument_list|,
argument|last
argument_list|)
end_macro

begin_decl_stmt
name|char
name|line
index|[]
decl_stmt|,
name|first
index|[]
decl_stmt|,
name|last
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|t
operator|=
name|line
init|;
operator|*
name|t
operator|!=
literal|'\n'
condition|;
name|t
operator|++
control|)
empty_stmt|;
for|for
control|(
name|t
operator|--
init|;
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|;
name|t
operator|--
control|)
empty_stmt|;
comment|/* now strip off last name */
for|for
control|(
name|q
operator|=
name|t
init|;
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|(
operator|*
name|q
operator|==
literal|' '
operator|)
operator|&
operator|(
operator|*
operator|(
name|q
operator|-
literal|1
operator|)
operator|==
literal|'\\'
operator|)
operator|)
condition|;
name|q
operator|--
control|)
if|if
condition|(
name|q
operator|==
name|line
condition|)
break|break;
name|f
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|line
condition|)
block|{
name|q
operator|++
expr_stmt|;
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|f
argument_list|)
condition|;
name|f
operator|--
control|)
empty_stmt|;
name|f
operator|++
expr_stmt|;
block|}
comment|/* first name is start to f, last name is q to t */
for|for
control|(
name|r
operator|=
name|first
operator|,
name|p
operator|=
name|line
init|;
name|p
operator|!=
name|f
condition|;
control|)
operator|*
name|r
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|r
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
name|last
operator|,
name|p
operator|=
name|q
operator|,
name|t
operator|++
init|;
name|q
operator|!=
name|t
condition|;
control|)
operator|*
name|r
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
operator|*
name|r
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* match - see if string1 is a substring of string2 (case independent)*/
end_comment

begin_decl_stmt
name|int
name|match
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
name|reg
name|char
name|str1
index|[]
decl_stmt|,
name|str2
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|int
name|j
decl_stmt|,
name|i
decl_stmt|;
name|char
name|a
decl_stmt|,
name|b
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|str2
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|str1
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|a
operator|=
name|str2
index|[
name|i
operator|+
name|j
index|]
argument_list|)
condition|)
name|a
operator|=
operator|(
name|a
operator|-
literal|'A'
operator|)
operator|+
literal|'a'
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|b
operator|=
name|str1
index|[
name|j
index|]
argument_list|)
condition|)
name|b
operator|=
operator|(
name|b
operator|-
literal|'A'
operator|)
operator|+
literal|'a'
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|b
condition|)
break|break;
block|}
if|if
condition|(
name|str1
index|[
name|j
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_block

begin_comment
comment|/* scopy - append a copy of one string to another */
end_comment

begin_function
name|char
modifier|*
name|scopy
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
name|reg
name|char
modifier|*
name|p
decl_stmt|,
decl|*
name|q
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
condition|)
empty_stmt|;
return|return
operator|(
operator|--
name|p
operator|)
return|;
block|}
end_block

begin_comment
comment|/* rcomp - reference comparison routine for qsort utility */
end_comment

begin_function
name|int
name|rcomp
parameter_list|(
name|ap
parameter_list|,
name|bp
parameter_list|)
name|struct
name|refinfo
modifier|*
name|ap
decl_stmt|,
decl|*
name|bp
decl_stmt|;
end_function

begin_block
block|{
name|char
name|ref1
index|[
name|REFSIZE
index|]
decl_stmt|,
name|ref2
index|[
name|REFSIZE
index|]
decl_stmt|,
name|field1
index|[
name|MAXFIELD
index|]
decl_stmt|,
name|field2
index|[
name|MAXFIELD
index|]
decl_stmt|;
name|reg
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|getfield
parameter_list|()
function_decl|;
name|int
name|neg
decl_stmt|,
name|res
decl_stmt|;
name|int
name|fields_found
decl_stmt|;
name|rdref
argument_list|(
name|ap
argument_list|,
name|ref1
argument_list|)
expr_stmt|;
name|rdref
argument_list|(
name|bp
argument_list|,
name|ref2
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sortstr
init|;
operator|*
name|p
condition|;
name|p
operator|=
name|q
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|neg
operator|=
name|true
expr_stmt|;
block|}
else|else
name|neg
operator|=
name|false
expr_stmt|;
name|q
operator|=
name|getfield
argument_list|(
name|p
argument_list|,
name|field1
argument_list|,
name|ref1
argument_list|)
expr_stmt|;
name|fields_found
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|q
operator|==
literal|0
condition|)
block|{
name|res
operator|=
literal|1
expr_stmt|;
name|fields_found
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|field1
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* field not found */
if|if
condition|(
operator|*
name|p
operator|==
literal|'A'
condition|)
block|{
name|getfield
argument_list|(
literal|"F"
argument_list|,
name|field1
argument_list|,
name|ref1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|field1
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
name|getfield
argument_list|(
literal|"I"
argument_list|,
name|field1
argument_list|,
name|ref1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|field1
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
literal|1
expr_stmt|;
name|fields_found
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|res
operator|=
literal|1
expr_stmt|;
name|fields_found
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|getfield
argument_list|(
name|p
argument_list|,
name|field2
argument_list|,
name|ref2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
operator|-
literal|1
expr_stmt|;
name|fields_found
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|field2
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* field not found */
if|if
condition|(
operator|*
name|p
operator|==
literal|'A'
condition|)
block|{
name|getfield
argument_list|(
literal|"F"
argument_list|,
name|field2
argument_list|,
name|ref2
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|field2
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
name|getfield
argument_list|(
literal|"I"
argument_list|,
name|field2
argument_list|,
name|ref2
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|field2
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
operator|-
literal|1
expr_stmt|;
name|fields_found
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|res
operator|=
operator|-
literal|1
expr_stmt|;
name|fields_found
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fields_found
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'A'
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|field1
index|[
literal|0
index|]
argument_list|)
condition|)
name|field1
index|[
literal|0
index|]
operator|-=
literal|'A'
operator|-
literal|'a'
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|field2
index|[
literal|0
index|]
argument_list|)
condition|)
name|field2
index|[
literal|0
index|]
operator|-=
literal|'A'
operator|-
literal|'a'
expr_stmt|;
block|}
name|res
operator|=
name|strcmp
argument_list|(
name|field1
argument_list|,
name|field2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|neg
condition|)
name|res
operator|=
operator|-
name|res
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|res
operator|==
literal|0
condition|)
if|if
condition|(
name|ap
operator|<
name|bp
condition|)
name|res
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|res
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_block

begin_comment
comment|/* makecites - make standard citation strings, using citetemplate currently in effect */
end_comment

begin_macro
name|makecites
argument_list|()
end_macro

begin_block
block|{
name|char
name|ref
index|[
name|REFSIZE
index|]
decl_stmt|,
name|tempcite
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|;
name|reg
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numrefs
condition|;
name|i
operator|++
control|)
block|{
name|rdref
argument_list|(
operator|&
name|refinfo
index|[
name|i
index|]
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|bldcite
argument_list|(
name|tempcite
argument_list|,
name|i
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|refinfo
index|[
name|i
index|]
operator|.
name|ri_cite
operator|=
name|malloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|tempcite
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|refinfo
index|[
name|i
index|]
operator|.
name|ri_cite
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"out of storage"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|refinfo
index|[
name|i
index|]
operator|.
name|ri_cite
argument_list|,
name|tempcite
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* bldcite - build a single citation string */
end_comment

begin_macro
name|bldcite
argument_list|(
argument|cp
argument_list|,
argument|i
argument_list|,
argument|ref
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|,
name|ref
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|field
index|[
name|REFSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|getfield
argument_list|()
decl_stmt|,
modifier|*
name|aabet
argument_list|()
decl_stmt|,
modifier|*
name|aabetlast
argument_list|()
decl_stmt|,
modifier|*
name|fullaabet
argument_list|()
decl_stmt|,
modifier|*
name|multfull
argument_list|()
decl_stmt|;
name|getfield
argument_list|(
literal|"F"
argument_list|,
name|field
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
for|for
control|(
name|p
operator|=
name|field
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|p
expr_stmt|;
else|else
block|{
name|p
operator|=
name|citetemplate
expr_stmt|;
name|field
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* field name   */
name|q
operator|=
name|getfield
argument_list|(
name|p
operator|-
literal|1
argument_list|,
name|field
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|q
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|field
init|;
operator|*
name|fp
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'1'
condition|)
block|{
comment|/* numeric  order */
name|sprintf
argument_list|(
name|field
argument_list|,
literal|"%d"
argument_list|,
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|field
init|;
operator|*
name|fp
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'2'
condition|)
comment|/* alternate alphabetic */
name|cp
operator|=
name|aabet
argument_list|(
name|cp
argument_list|,
name|ref
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'3'
condition|)
comment|/* Astrophysical Journal style*/
name|cp
operator|=
name|multfull
argument_list|(
name|cp
argument_list|,
name|ref
argument_list|,
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'4'
condition|)
comment|/* Computing Surveys style*/
name|cp
operator|=
name|multfull
argument_list|(
name|cp
argument_list|,
name|ref
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'8'
condition|)
comment|/* Full alphabetic */
name|cp
operator|=
name|fullaabet
argument_list|(
name|cp
argument_list|,
name|ref
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'9'
condition|)
comment|/* Last name of Senior Author*/
name|cp
operator|=
name|aabetlast
argument_list|(
name|cp
argument_list|,
name|ref
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
comment|/* print nothing */
for|for
control|(
name|fp
operator|=
name|field
init|;
operator|*
name|fp
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
comment|/* other information   */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'}'
condition|)
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"unexpected end of citation template"
argument_list|)
expr_stmt|;
else|else
operator|*
name|cp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'>'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"unexpected end of citation template"
argument_list|)
expr_stmt|;
else|else
operator|*
name|cp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'@'
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* alternate alphabetic citation style -         if 1 author - first three letters of last name         if 2 authors - first two letters of first, followed by first letter of                                 seond         if 3 or more authors - first letter of first three authors */
end_comment

begin_decl_stmt
name|char
modifier|*
name|aabet
argument_list|(
name|cp
argument_list|,
name|ref
argument_list|)
name|char
modifier|*
name|cp
decl_stmt|,
name|ref
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|field
index|[
name|REFSIZE
index|]
decl_stmt|,
name|temp
index|[
literal|100
index|]
decl_stmt|;
name|reg
name|char
modifier|*
name|np
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
name|int
name|j
decl_stmt|,
name|getname
argument_list|()
decl_stmt|;
if|if
condition|(
name|getname
argument_list|(
literal|1
argument_list|,
name|field
argument_list|,
name|temp
argument_list|,
name|ref
argument_list|)
condition|)
block|{
name|np
operator|=
name|cp
expr_stmt|;
name|fp
operator|=
name|field
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
literal|3
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|*
name|fp
operator|!=
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
if|if
condition|(
name|getname
argument_list|(
literal|2
argument_list|,
name|field
argument_list|,
name|temp
argument_list|,
name|ref
argument_list|)
condition|)
name|np
index|[
literal|2
index|]
operator|=
name|field
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|getname
argument_list|(
literal|3
argument_list|,
name|field
argument_list|,
name|temp
argument_list|,
name|ref
argument_list|)
condition|)
block|{
name|np
index|[
literal|1
index|]
operator|=
name|np
index|[
literal|2
index|]
expr_stmt|;
name|np
index|[
literal|2
index|]
operator|=
name|field
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_block

begin_comment
comment|/* alternate alphabetic citation style - 	first two characters of last names of all authors 	up to max_klen characters. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fullaabet
argument_list|(
name|cp
argument_list|,
name|ref
argument_list|)
name|char
modifier|*
name|cp
decl_stmt|,
name|ref
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|field
index|[
name|REFSIZE
index|]
decl_stmt|,
name|temp
index|[
literal|100
index|]
decl_stmt|;
name|reg
name|char
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|lastcp
decl_stmt|;
name|int
name|getname
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|;
name|lastcp
operator|=
name|cp
operator|+
name|max_klen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|getname
argument_list|(
name|i
argument_list|,
name|field
argument_list|,
name|temp
argument_list|,
name|ref
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|fp
operator|=
name|field
init|;
operator|*
name|fp
operator|&&
operator|(
name|fp
operator|<
operator|&
operator|(
name|field
index|[
literal|3
index|]
operator|)
operator|)
condition|;
control|)
if|if
condition|(
name|cp
operator|>
name|lastcp
condition|)
break|break;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|fp
argument_list|)
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
else|else
name|fp
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_block

begin_comment
comment|/* alternate alphabetic citation style - 	entire last name of senior author */
end_comment

begin_decl_stmt
name|char
modifier|*
name|aabetlast
argument_list|(
name|cp
argument_list|,
name|ref
argument_list|)
name|char
modifier|*
name|cp
decl_stmt|,
name|ref
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|field
index|[
name|REFSIZE
index|]
decl_stmt|,
name|temp
index|[
literal|100
index|]
decl_stmt|;
name|reg
name|char
modifier|*
name|fp
decl_stmt|;
name|int
name|getname
parameter_list|()
function_decl|;
if|if
condition|(
name|getname
argument_list|(
literal|1
argument_list|,
name|field
argument_list|,
name|temp
argument_list|,
name|ref
argument_list|)
condition|)
block|{
for|for
control|(
name|fp
operator|=
name|field
init|;
operator|*
name|fp
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*    Multiple full authors last names (1, 2 or 3 full names).    If maxauthors<3         if 1 author - last name date         if 2 authors - last name and last name date         if 3 or more authors - last name et al. date   If maxauthors>=3         if 1 author - last name date         if 2 authors - last name and last name date         if 3 authors - last name, last name and last name date         if 4 or more authors - last name et al. date */
end_comment

begin_decl_stmt
name|char
modifier|*
name|multfull
argument_list|(
name|cp
argument_list|,
name|ref
argument_list|,
name|maxauthors
argument_list|)
name|char
modifier|*
name|cp
decl_stmt|,
name|ref
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxauthors
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|name1
index|[
literal|100
index|]
decl_stmt|,
name|name2
index|[
literal|100
index|]
decl_stmt|,
name|name3
index|[
literal|100
index|]
decl_stmt|,
name|temp
index|[
literal|100
index|]
decl_stmt|;
name|reg
name|char
modifier|*
name|fp
decl_stmt|;
name|int
name|getname
parameter_list|()
function_decl|;
if|if
condition|(
name|getname
argument_list|(
literal|1
argument_list|,
name|name1
argument_list|,
name|temp
argument_list|,
name|ref
argument_list|)
condition|)
block|{
for|for
control|(
name|fp
operator|=
name|name1
init|;
operator|*
name|fp
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|maxauthors
operator|>=
literal|3
operator|)
operator|&&
operator|(
name|getname
argument_list|(
literal|4
argument_list|,
name|name3
argument_list|,
name|temp
argument_list|,
name|ref
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|maxauthors
operator|<
literal|3
operator|)
operator|&&
operator|(
name|getname
argument_list|(
literal|3
argument_list|,
name|name3
argument_list|,
name|temp
argument_list|,
name|ref
argument_list|)
operator|)
operator|)
condition|)
block|{
for|for
control|(
name|fp
operator|=
literal|" \\*(e]"
init|;
operator|*
name|fp
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getname
argument_list|(
literal|2
argument_list|,
name|name2
argument_list|,
name|temp
argument_list|,
name|ref
argument_list|)
condition|)
block|{
if|if
condition|(
name|getname
argument_list|(
literal|3
argument_list|,
name|name3
argument_list|,
name|temp
argument_list|,
name|ref
argument_list|)
condition|)
block|{
for|for
control|(
name|fp
operator|=
literal|"\\*(c]"
init|;
operator|*
name|fp
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|name2
init|;
operator|*
name|fp
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
for|for
control|(
name|fp
operator|=
literal|"\\*(m]"
init|;
operator|*
name|fp
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|name3
init|;
operator|*
name|fp
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|fp
operator|=
literal|"\\*(n]"
init|;
operator|*
name|fp
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|name2
init|;
operator|*
name|fp
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_block

begin_comment
comment|/* getfield - get a single field from reference */
end_comment

begin_decl_stmt
name|char
modifier|*
name|getfield
argument_list|(
name|ptr
argument_list|,
name|field
argument_list|,
name|ref
argument_list|)
name|char
modifier|*
name|ptr
decl_stmt|,
name|field
index|[]
decl_stmt|,
name|ref
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|temp
index|[
literal|100
index|]
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
decl_stmt|,
name|i
decl_stmt|,
name|getname
argument_list|()
decl_stmt|;
name|field
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'A'
condition|)
name|getname
argument_list|(
literal|1
argument_list|,
name|field
argument_list|,
name|temp
argument_list|,
name|ref
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|p
operator|=
name|ref
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
operator|*
name|ptr
condition|)
block|{
for|for
control|(
name|p
operator|=
name|p
operator|+
literal|2
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
for|for
control|(
name|q
operator|=
name|field
init|;
operator|(
operator|*
name|p
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|)
condition|;
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|n
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|ptr
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|ptr
operator|++
init|;
name|isdigit
argument_list|(
operator|*
name|ptr
argument_list|)
condition|;
name|ptr
operator|++
control|)
name|n
operator|=
literal|10
operator|*
name|n
operator|+
operator|(
operator|*
name|ptr
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|len
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|len
operator|-
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|field
index|[
name|i
index|]
operator|=
name|field
index|[
name|i
operator|+
name|n
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|isdigit
argument_list|(
operator|*
name|ptr
argument_list|)
condition|;
name|ptr
operator|++
control|)
name|n
operator|=
literal|10
operator|*
name|n
operator|+
operator|(
operator|*
name|ptr
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
name|field
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'u'
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|field
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|-
literal|'a'
operator|)
operator|+
literal|'A'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'l'
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|field
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|-
literal|'A'
operator|)
operator|+
literal|'a'
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_block

begin_comment
comment|/* getname - get the nth name field from reference, breaking into              first and last names */
end_comment

begin_decl_stmt
name|int
name|getname
argument_list|(
name|n
argument_list|,
name|last
argument_list|,
name|first
argument_list|,
name|ref
argument_list|)
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|last
index|[]
decl_stmt|,
name|first
index|[]
decl_stmt|,
name|ref
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|m
decl_stmt|;
name|m
operator|=
name|n
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ref
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
operator|&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'A'
condition|)
block|{
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|p
operator|+
literal|2
init|;
operator|*
name|p
operator|==
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|breakname
argument_list|(
name|p
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
if|if
condition|(
name|n
operator|==
name|m
condition|)
comment|/* no authors, try editors */
for|for
control|(
name|p
operator|=
name|ref
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
operator|&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'E'
condition|)
block|{
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|p
operator|+
literal|2
init|;
operator|*
name|p
operator|==
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|breakname
argument_list|(
name|p
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
if|if
condition|(
name|n
operator|==
name|m
condition|)
block|{
comment|/* no editors, either, try institution */
name|first
index|[
literal|0
index|]
operator|=
name|last
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|getfield
argument_list|(
literal|"I"
argument_list|,
name|last
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_block

begin_comment
comment|/* disambiguate - compare adjacent citation strings, and if equal, add                   single character disambiguators */
end_comment

begin_macro
name|disambiguate
argument_list|()
end_macro

begin_block
block|{
name|reg
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|adstr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numrefs
operator|-
literal|1
condition|;
name|i
operator|=
name|j
control|)
block|{
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|refinfo
index|[
name|i
index|]
operator|.
name|ri_cite
argument_list|,
name|refinfo
index|[
name|j
index|]
operator|.
name|ri_cite
argument_list|)
operator|==
literal|0
condition|)
block|{
name|adstr
operator|=
literal|'a'
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|numrefs
operator|&&
name|strcmp
argument_list|(
name|refinfo
index|[
name|i
index|]
operator|.
name|ri_cite
argument_list|,
name|refinfo
index|[
name|j
index|]
operator|.
name|ri_cite
argument_list|)
operator|==
literal|0
condition|;
name|j
operator|++
control|)
block|{
name|adstr
operator|=
literal|'a'
operator|+
operator|(
name|j
operator|-
name|i
operator|)
expr_stmt|;
name|refinfo
index|[
name|j
index|]
operator|.
name|ri_disambig
index|[
literal|0
index|]
operator|=
name|adstr
expr_stmt|;
block|}
name|refinfo
index|[
name|i
index|]
operator|.
name|ri_disambig
index|[
literal|0
index|]
operator|=
literal|'a'
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numrefs
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|refinfo
index|[
name|i
index|]
operator|.
name|ri_cite
argument_list|,
name|refinfo
index|[
name|i
index|]
operator|.
name|ri_disambig
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* bldname - build a name field              doing abbreviations, reversals, and caps/small caps */
end_comment

begin_macro
name|bldname
argument_list|(
argument|first
argument_list|,
argument|last
argument_list|,
argument|name
argument_list|,
argument|reverse
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|,
name|name
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reverse
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|newfirst
index|[
literal|120
index|]
decl_stmt|,
name|newlast
index|[
literal|120
index|]
decl_stmt|;
name|reg
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|f
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|char
modifier|*
name|scopy
parameter_list|()
function_decl|;
name|int
name|flag
decl_stmt|;
if|if
condition|(
name|abbrev
condition|)
block|{
name|p
operator|=
name|first
expr_stmt|;
name|q
operator|=
name|newfirst
expr_stmt|;
name|flag
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag
condition|)
comment|/* between initial gap */
name|q
operator|=
name|scopy
argument_list|(
name|q
argument_list|,
literal|"\\*(a]"
argument_list|)
expr_stmt|;
name|flag
operator|=
name|true
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
name|q
operator|=
name|scopy
argument_list|(
name|q
argument_list|,
literal|"\\*(p]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'.'
condition|)
name|p
operator|++
expr_stmt|;
else|else
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|newfirst
expr_stmt|;
block|}
else|else
name|f
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|capsmcap
condition|)
block|{
name|p
operator|=
name|last
expr_stmt|;
name|q
operator|=
name|newlast
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
comment|/* 1 - printing cap, 2 - printing small */
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag
operator|!=
literal|2
condition|)
name|q
operator|=
name|scopy
argument_list|(
name|q
argument_list|,
literal|"\\s-2"
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|2
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
operator|*
name|p
operator|++
operator|-
literal|'a'
operator|)
operator|+
literal|'A'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flag
operator|==
literal|2
condition|)
name|q
operator|=
name|scopy
argument_list|(
name|q
argument_list|,
literal|"\\s+2"
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|==
literal|2
condition|)
name|q
operator|=
name|scopy
argument_list|(
name|q
argument_list|,
literal|"\\s+2"
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|newlast
expr_stmt|;
block|}
else|else
name|l
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|f
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s\n"
argument_list|,
name|l
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reverse
condition|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s\\*(b]%s\n"
argument_list|,
name|l
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s %s\n"
argument_list|,
name|f
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* prtauth - print author or editor field */
end_comment

begin_macro
name|prtauth
argument_list|(
argument|c
argument_list|,
argument|line
argument_list|,
argument|num
argument_list|,
argument|max
argument_list|,
argument|ofd
argument_list|,
argument|abbrev
argument_list|,
argument|capsmcap
argument_list|,
argument|numrev
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|,
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num
decl_stmt|,
name|max
decl_stmt|,
name|abbrev
decl_stmt|,
name|capsmcap
decl_stmt|,
name|numrev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ofd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|first
index|[
name|LINELENGTH
index|]
decl_stmt|,
name|last
index|[
name|LINELENGTH
index|]
decl_stmt|;
if|if
condition|(
name|num
operator|<=
name|numrev
operator|||
name|abbrev
operator|||
name|capsmcap
condition|)
block|{
name|breakname
argument_list|(
name|line
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|bldname
argument_list|(
name|first
argument_list|,
name|last
argument_list|,
name|line
argument_list|,
name|num
operator|<=
name|numrev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".ds [%c %s"
argument_list|,
name|c
argument_list|,
name|line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|<
name|max
condition|)
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".as [%c \\*(c]%s"
argument_list|,
name|c
argument_list|,
name|line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|max
operator|==
literal|2
condition|)
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".as [%c \\*(n]%s"
argument_list|,
name|c
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".as [%c \\*(m]%s"
argument_list|,
name|c
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
name|max
operator|&&
name|index
argument_list|(
name|trailstr
argument_list|,
name|c
argument_list|)
condition|)
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".ds ]%c %c\n"
argument_list|,
name|c
argument_list|,
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* doline - actually print out a line of reference information */
end_comment

begin_macro
name|doline
argument_list|(
argument|c
argument_list|,
argument|line
argument_list|,
argument|numauths
argument_list|,
argument|maxauths
argument_list|,
argument|numeds
argument_list|,
argument|maxeds
argument_list|,
argument|ofd
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|,
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numauths
decl_stmt|,
name|maxauths
decl_stmt|,
name|numeds
decl_stmt|,
name|maxeds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ofd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|appending
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
name|prtauth
argument_list|(
name|c
argument_list|,
name|line
argument_list|,
name|numauths
argument_list|,
name|maxauths
argument_list|,
name|ofd
argument_list|,
name|abbrev
argument_list|,
name|capsmcap
argument_list|,
name|numrev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|prtauth
argument_list|(
name|c
argument_list|,
name|line
argument_list|,
name|numeds
argument_list|,
name|maxeds
argument_list|,
name|ofd
argument_list|,
name|edabbrev
argument_list|,
name|edcapsmcap
argument_list|,
name|ednumrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|numeds
operator|==
name|maxeds
condition|)
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".nr [E %d\n"
argument_list|,
name|maxeds
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|index
argument_list|(
name|line
argument_list|,
literal|'-'
argument_list|)
condition|)
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".nr [P 1\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".nr [P 0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".ds [P %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|trailstr
argument_list|,
literal|'P'
argument_list|)
condition|)
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".ds ]P %c\n"
argument_list|,
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
break|break;
comment|/* these now accumulate their entries */
comment|/* defined by official bib documentation */
case|case
literal|'K'
case|:
case|case
literal|'O'
case|:
case|case
literal|'W'
case|:
comment|/* not defined by official bib documentation */
case|case
literal|'H'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'U'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
name|appending
operator|=
name|letterSeen
index|[
name|c
index|]
expr_stmt|;
name|letterSeen
index|[
name|c
index|]
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|appending
condition|)
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".as [%c , %s"
argument_list|,
name|c
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".ds [%c %s"
argument_list|,
name|c
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|trailstr
argument_list|,
name|c
argument_list|)
condition|)
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".ds ]%c %c\n"
argument_list|,
name|c
argument_list|,
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
break|break;
comment|/* ignore what you don't understand */
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".ds [%c %s"
argument_list|,
name|c
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|trailstr
argument_list|,
name|c
argument_list|)
condition|)
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".ds ]%c %c\n"
argument_list|,
name|c
argument_list|,
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* dumpref - dump reference number i */
end_comment

begin_macro
name|dumpref
argument_list|(
argument|i
argument_list|,
argument|ofd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ofd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|ref
index|[
name|REFSIZE
index|]
decl_stmt|,
name|line
index|[
name|REFSIZE
index|]
decl_stmt|;
name|reg
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|int
name|numauths
decl_stmt|,
name|maxauths
decl_stmt|,
name|numeds
decl_stmt|,
name|maxeds
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|ref
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* ref not found */
else|else
block|{
name|rdref
argument_list|(
operator|&
name|refinfo
index|[
name|i
index|]
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|maxauths
operator|=
name|maxeds
operator|=
literal|0
expr_stmt|;
name|numauths
operator|=
name|numeds
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|128
condition|;
name|j
operator|++
control|)
name|letterSeen
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ref
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'A'
condition|)
name|maxauths
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'E'
condition|)
name|maxeds
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".[-\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".ds [F %s\n"
argument_list|,
name|refinfo
index|[
name|i
index|]
operator|.
name|ri_cite
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|INCORE
name|fseek
argument_list|(
name|rfd
argument_list|,
operator|(
name|long
operator|)
name|refinfo
index|[
name|i
index|]
operator|.
name|ri_pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|REFSIZE
argument_list|,
name|rfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
else|#
directive|else
else|INCORE
for|for
control|(
name|q
operator|=
name|line
operator|,
name|from
operator|=
name|refinfo
index|[
name|i
index|]
operator|.
name|ri_ref
init|;
operator|*
name|from
condition|;
comment|/*VOID*/
control|)
block|{
comment|/*} */
if|if
condition|(
operator|*
name|from
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|line
expr_stmt|;
name|from
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
endif|INCORE
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
goto|goto
name|doneref
goto|;
case|case
literal|'.'
case|:
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
switch|switch
condition|(
name|line
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'A'
case|:
name|numauths
operator|++
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|numeds
operator|++
expr_stmt|;
break|break;
block|}
for|for
control|(
name|p
operator|=
operator|&
name|line
index|[
literal|2
index|]
init|;
operator|*
name|p
operator|==
literal|' '
condition|;
name|p
operator|++
control|)
comment|/*VOID*/
empty_stmt|;
name|doline
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|,
name|p
argument_list|,
name|numauths
argument_list|,
name|maxauths
argument_list|,
name|numeds
argument_list|,
name|maxeds
argument_list|,
name|ofd
argument_list|)
expr_stmt|;
block|}
block|}
name|doneref
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|ofd
argument_list|,
literal|".][\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

