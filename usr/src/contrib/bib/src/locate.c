begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)locate.c	2.2	%G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_include
include|#
directive|include
file|"streams.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_define
define|#
directive|define
name|maxrefs
value|200
end_define

begin_struct
struct|struct
name|reftype
block|{
name|char
name|reffile
index|[
literal|64
index|]
decl_stmt|;
comment|/* rrh: still may be too short */
name|long
name|int
name|start
decl_stmt|,
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|stripkeys
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|fetchref
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|fileflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  locate(keys, name, max_klen, common):         Returns a string containing all references pointed to by name         that contain all keys in keys.  Common is name of common word file.     Pointer returned comes from malloc.  Use free to return storage.     NB A zero length string returned if nothing is found.        A NULL pointer indicates an error accessing the file "name". */
end_comment

begin_function
name|char
modifier|*
name|locate
parameter_list|(
name|keys
parameter_list|,
name|name
parameter_list|,
name|max_klen
parameter_list|,
name|common
parameter_list|)
name|char
modifier|*
name|keys
decl_stmt|,
decl|*
name|name
decl_stmt|,
modifier|*
name|common
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|max_klen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max key length */
end_comment

begin_block
block|{
specifier|static
name|char
name|oldname
index|[
name|maxstr
index|]
init|=
literal|""
decl_stmt|;
comment|/* oldname is name of stream index */
specifier|static
name|FILE
modifier|*
name|index
init|=
name|NULL
decl_stmt|;
specifier|static
name|long
name|int
name|i_size
decl_stmt|;
comment|/* size of index                   */
specifier|static
name|char
name|oldtext
index|[
name|maxstr
index|]
decl_stmt|;
comment|/* oldtext is the path to stream   */
specifier|static
name|char
name|workbuf
index|[
literal|10240
index|]
decl_stmt|;
comment|/* work buffer */
specifier|static
name|FILE
modifier|*
name|text
init|=
name|NULL
decl_stmt|;
comment|/*  text.  if it is a relative     */
specifier|static
name|int
name|pathlen
decl_stmt|;
comment|/*  path, it is relative to index  */
comment|/*  directory.                     */
comment|/* oldname[0..pathlen-1] is index  */
comment|/*  directory                      */
name|int
name|len
decl_stmt|;
name|char
name|key
index|[
name|maxstr
index|]
decl_stmt|;
comment|/* refs[i] is a line of index for  */
name|struct
name|reftype
name|refs
index|[
name|maxrefs
index|]
decl_stmt|;
comment|/* all keys up to key              */
name|int
name|refcnt
decl_stmt|,
name|copied
decl_stmt|,
name|comp
decl_stmt|;
comment|/* refcnt = # of refs               */
comment|/* copied = # of refs copied        */
comment|/* comp   = # of refs compared      */
name|struct
name|reftype
name|ref
decl_stmt|;
name|char
name|str
index|[
name|maxstr
index|]
decl_stmt|;
name|int
name|more
decl_stmt|;
name|long
name|int
name|ans
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|total
decl_stmt|;
name|char
modifier|*
name|allrefs
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* all refs (separated by null line)*/
name|char
modifier|*
name|p
decl_stmt|;
comment|/*  open index */
if|if
condition|(
name|strcmp
argument_list|(
name|oldname
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|index
condition|)
name|fclose
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
condition|)
name|fclose
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|oldname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|oldtext
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/*  determine pathlen   */
name|p
operator|=
name|rindex
argument_list|(
name|oldname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|pathlen
operator|=
name|p
operator|-
name|oldname
operator|+
literal|1
expr_stmt|;
else|else
name|pathlen
operator|=
literal|0
expr_stmt|;
name|index
operator|=
name|fopen
argument_list|(
name|oldname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"locate: cannot open %s\n"
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|oldname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|fseek
argument_list|(
name|index
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/*  seeks last newline      */
name|i_size
operator|=
name|ftell
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  load references to first key  */
name|keys
operator|=
name|stripkeys
argument_list|(
name|keys
argument_list|,
name|key
argument_list|,
name|max_klen
argument_list|,
name|common
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|key
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"locate: no keys for citation\n"
argument_list|)
expr_stmt|;
name|allrefs
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|allrefs
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"locate: insufficient space for references\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|allrefs
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|allrefs
operator|)
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|key
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|alpha_seek
argument_list|(
name|index
argument_list|,
name|key
argument_list|,
name|i_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|key
index|[
name|len
index|]
operator|=
name|NULL
expr_stmt|;
comment|/*  strip blank off */
name|refcnt
operator|=
literal|0
expr_stmt|;
name|fscanf
argument_list|(
name|index
argument_list|,
literal|"%s "
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
name|str
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|refcnt
operator|<
name|maxrefs
operator|&&
name|fetchref
argument_list|(
name|index
argument_list|,
name|str
argument_list|,
operator|&
name|ref
argument_list|)
condition|)
block|{
name|refs
index|[
name|refcnt
index|]
operator|=
name|ref
expr_stmt|;
name|refcnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|refcnt
operator|==
name|maxrefs
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"locate: first key (%s) matched too many refs\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/*  intersect the reference sets for remaining keys with first set */
while|while
condition|(
operator|*
name|keys
operator|!=
name|NULL
condition|)
block|{
name|keys
operator|=
name|stripkeys
argument_list|(
name|keys
argument_list|,
name|key
argument_list|,
name|max_klen
argument_list|,
name|common
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|key
operator|==
name|NULL
condition|)
continue|continue;
name|len
operator|=
name|strlen
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|key
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|alpha_seek
argument_list|(
name|index
argument_list|,
name|key
argument_list|,
name|i_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|key
index|[
name|len
index|]
operator|=
name|NULL
expr_stmt|;
name|fscanf
argument_list|(
name|index
argument_list|,
literal|"%s "
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|key
argument_list|)
operator|!=
literal|0
condition|)
name|refcnt
operator|=
literal|0
expr_stmt|;
comment|/*  no matching refs */
name|copied
operator|=
literal|0
expr_stmt|;
name|comp
operator|=
literal|0
expr_stmt|;
name|more
operator|=
name|fetchref
argument_list|(
name|index
argument_list|,
name|str
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
while|while
condition|(
name|comp
operator|<
name|refcnt
operator|&&
name|more
condition|)
block|{
comment|/*  ans= ref-refs[comp]    */
name|ans
operator|=
name|strcmp
argument_list|(
name|ref
operator|.
name|reffile
argument_list|,
name|refs
index|[
name|comp
index|]
operator|.
name|reffile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ans
operator|==
literal|0
condition|)
name|ans
operator|=
name|ref
operator|.
name|start
operator|-
name|refs
index|[
name|comp
index|]
operator|.
name|start
expr_stmt|;
if|if
condition|(
name|ans
operator|==
literal|0
condition|)
name|ans
operator|=
name|ref
operator|.
name|length
operator|-
name|refs
index|[
name|comp
index|]
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|ans
operator|<
literal|0
condition|)
name|more
operator|=
name|fetchref
argument_list|(
name|index
argument_list|,
name|str
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|ans
operator|==
literal|0
condition|)
block|{
name|refs
index|[
name|copied
index|]
operator|=
name|refs
index|[
name|comp
index|]
expr_stmt|;
name|comp
operator|++
expr_stmt|;
name|copied
operator|++
expr_stmt|;
name|more
operator|=
name|fetchref
argument_list|(
name|index
argument_list|,
name|str
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ans
operator|>
literal|0
condition|)
name|comp
operator|++
expr_stmt|;
block|}
name|refcnt
operator|=
name|copied
expr_stmt|;
block|}
comment|/* copy refs into the work buffer */
name|next
operator|=
name|workbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|refcnt
condition|;
name|i
operator|++
control|)
block|{
comment|/*  open text */
if|if
condition|(
name|strcmp
argument_list|(
name|oldtext
argument_list|,
name|refs
index|[
name|i
index|]
operator|.
name|reffile
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|oldtext
argument_list|,
name|refs
index|[
name|i
index|]
operator|.
name|reffile
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtext
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* absolute path */
name|strcpy
argument_list|(
name|str
argument_list|,
name|oldtext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* relative name */
name|strncpy
argument_list|(
name|str
argument_list|,
name|oldname
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|str
index|[
name|pathlen
index|]
operator|=
name|NULL
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|oldtext
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|text
condition|)
name|fclose
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|text
operator|=
name|fopen
argument_list|(
name|str
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"locate: cannot open %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|oldtext
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|fseek
argument_list|(
name|text
argument_list|,
name|refs
index|[
name|i
index|]
operator|.
name|start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
if|if
condition|(
name|fileflag
condition|)
block|{
name|from
operator|=
name|oldtext
expr_stmt|;
while|while
condition|(
operator|*
name|next
operator|++
operator|=
operator|*
name|from
operator|++
condition|)
comment|/*VOID*/
empty_stmt|;
name|next
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|refs
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|++
control|)
operator|*
name|next
operator|++
operator|=
name|getc
argument_list|(
name|text
argument_list|)
expr_stmt|;
operator|*
name|next
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
operator|*
name|next
operator|=
name|NULL
expr_stmt|;
name|allrefs
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|workbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|allrefs
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No space left for allrefs\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|allrefs
argument_list|,
name|workbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|allrefs
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  stripkeys(line,key,max_klen, common):         assigns to key the first key in line         and returns a pointer to the position following the key */
end_comment

begin_function
name|char
modifier|*
name|stripkeys
parameter_list|(
name|line
parameter_list|,
name|key
parameter_list|,
name|max_klen
parameter_list|,
name|common
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|,
decl|*
name|key
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|max_klen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|common
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
do|do
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
name|p
operator|=
name|key
expr_stmt|;
while|while
condition|(
operator|*
name|line
operator|!=
name|NULL
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|line
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
name|makekey
argument_list|(
name|key
argument_list|,
name|max_klen
argument_list|,
name|common
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|key
operator|==
name|NULL
operator|&&
operator|*
name|line
operator|!=
name|NULL
condition|)
do|;
return|return
operator|(
name|line
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  read a reference pair from stream into *ref.  if file not given,     use oldfile. return 1 if pair found, 0 ow. */
end_comment

begin_function
name|int
name|fetchref
parameter_list|(
name|stream
parameter_list|,
name|oldfile
parameter_list|,
name|ref
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|oldfile
decl_stmt|;
name|struct
name|reftype
modifier|*
name|ref
decl_stmt|;
block|{
name|char
name|cntl
decl_stmt|;
name|fscanf
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|&
name|cntl
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntl
operator|==
literal|'\n'
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cntl
operator|==
literal|':'
condition|)
name|fscanf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|oldfile
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ref
operator|->
name|reffile
argument_list|,
name|oldfile
argument_list|)
expr_stmt|;
name|fscanf
argument_list|(
name|stream
argument_list|,
literal|"%ld/%ld"
argument_list|,
operator|&
name|ref
operator|->
name|start
argument_list|,
operator|&
name|ref
operator|->
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

