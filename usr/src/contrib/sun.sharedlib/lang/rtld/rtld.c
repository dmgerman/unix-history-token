begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This source code is a product of Sun Microsystems, Inc. and is provided  * for unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify this source code without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *  * THIS PROGRAM CONTAINS SOURCE CODE COPYRIGHTED BY SUN MICROSYSTEMS, INC.  * SUN MICROSYSTEMS, INC., MAKES NO REPRESENTATIONS ABOUT THE SUITABLITY  * OF SUCH SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT  * EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  SUN MICROSYSTEMS, INC. DISCLAIMS  * ALL WARRANTIES WITH REGARD TO SUCH SOURCE CODE, INCLUDING ALL IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN  * NO EVENT SHALL SUN MICROSYSTEMS, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT,  * INCIDENTAL, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING  * FROM USE OF SUCH SOURCE CODE, REGARDLESS OF THE THEORY OF LIABILITY.  *   * This source code is provided with no support and without any obligation on  * the part of Sun Microsystems, Inc. to assist in its use, correction,   * modification or enhancement.  *  * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY THIS  * SOURCE CODE OR ANY PART THEREOF.  *  * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California 94043  */
end_comment

begin_comment
comment|/* @(#)rtld.c 1.60 91/04/02 SMI */
end_comment

begin_comment
comment|/*  * Run-time link editor.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1989, 1990, 1991 by Sun Microsystems, Inc.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<link.h>
end_include

begin_include
include|#
directive|include
file|"dynamic.h"
end_include

begin_include
include|#
directive|include
file|"reloc_info.h"
end_include

begin_include
include|#
directive|include
file|"rtld.h"
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_define
define|#
directive|define
name|VERSION2
value|2
end_define

begin_comment
comment|/*  * Code collapsing macros.  */
end_comment

begin_define
define|#
directive|define
name|JMPOFF
parameter_list|(
name|x
parameter_list|)
value|(x)->v2->ld_plt
end_define

begin_define
define|#
directive|define
name|RELOCOFF
parameter_list|(
name|x
parameter_list|)
value|(x)->v2->ld_rel
end_define

begin_define
define|#
directive|define
name|HASHOFF
parameter_list|(
name|x
parameter_list|)
value|(x)->v2->ld_hash
end_define

begin_define
define|#
directive|define
name|SYMOFF
parameter_list|(
name|x
parameter_list|)
value|(x)->v2->ld_stab
end_define

begin_define
define|#
directive|define
name|STROFF
parameter_list|(
name|x
parameter_list|)
value|(x)->v2->ld_symbols
end_define

begin_define
define|#
directive|define
name|DONTAPPEND
value|0
end_define

begin_define
define|#
directive|define
name|APPEND
value|1
end_define

begin_if
if|#
directive|if
name|TARGET
operator|==
name|SUN4
end_if

begin_define
define|#
directive|define
name|MASK
parameter_list|(
name|n
parameter_list|)
value|((1<<(n))-1)
end_define

begin_define
define|#
directive|define
name|IN_RANGE
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|((-(1<<((n)-1)))<=(v)&& (v)< (1<<((n)-1)))
end_define

begin_define
define|#
directive|define
name|isitpcrel
parameter_list|(
name|rp
parameter_list|)
value|(rp->r_type == RELOC_DISP8 || rp->r_type == RELOC_DISP16\ 	    || rp->r_type == RELOC_DISP32 || rp->r_type == RELOC_WDISP30 \ 	    || rp->r_type == RELOC_WDISP22)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * What we do:  *	- crt0 will pass in the pointer to dynamic structure of main prog.  *	- relocate ourselves.  *	- version checking: get the libraries,   *		check the version and mmap them in.  *	- relocate the _GOT_ for both user and shared libraries.  *	- relocate _PLT_ to the binder.  *	- go back to crt0.  */
end_comment

begin_comment
comment|/*  * Interface between crt0& ld.so.  */
end_comment

begin_struct
struct|struct
name|crt_i1
block|{
name|int
name|crt_baseaddr
decl_stmt|;
comment|/* Address ld.so is at */
name|int
name|crt_dzfd
decl_stmt|;
comment|/* /dev/zero file descriptor */
name|int
name|crt_rlfd
decl_stmt|;
comment|/* ld.so file descriptor */
name|struct
name|link_dynamic
modifier|*
name|crt_udp
decl_stmt|;
comment|/* "main_" dynamic */
name|char
modifier|*
modifier|*
name|crt_ep
decl_stmt|;
comment|/* environment strings */
name|caddr_t
name|crt_breakp
decl_stmt|;
comment|/* place to put initial breakpoint */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Global declarations.  */
end_comment

begin_decl_stmt
name|int
name|devzero_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cache for file descriptor */
end_comment

begin_decl_stmt
name|struct
name|rtc_symb
modifier|*
name|rtcp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* allocated commons */
end_comment

begin_decl_stmt
name|struct
name|link_map
modifier|*
name|hlmp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of link_map chain */
end_comment

begin_decl_stmt
name|struct
name|link_map
modifier|*
name|plmp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first public link_map */
end_comment

begin_decl_stmt
name|struct
name|link_map
modifier|*
name|mlmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* link map for "main" */
end_comment

begin_decl_stmt
name|struct
name|link_map
modifier|*
name|ld_lmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* link map for runtime linker */
end_comment

begin_decl_stmt
name|struct
name|link_object
name|ld_lo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dummy link object for linker */
end_comment

begin_decl_stmt
name|struct
name|link_map
modifier|*
modifier|*
name|plmpp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* insertion point for new lm's */
end_comment

begin_decl_stmt
name|struct
name|link_map
modifier|*
name|flmp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of link_map free chain */
end_comment

begin_decl_stmt
name|struct
name|dl_object
modifier|*
name|hdlp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of dl_object chain */
end_comment

begin_decl_stmt
name|struct
name|dl_object
modifier|*
modifier|*
name|pdlpp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* insertion point for new dl's */
end_comment

begin_decl_stmt
name|struct
name|dl_object
modifier|*
name|fdlp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of dl_object free chain */
end_comment

begin_decl_stmt
name|caddr_t
name|top_of_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* top of stack (+1) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dl_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last dynamic linking error */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tracing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tracing or running? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|preload
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* other shared object to preload */
end_comment

begin_decl_stmt
name|char
modifier|*
name|profile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* activate profiling */
end_comment

begin_decl_stmt
name|char
modifier|*
name|symbols_public
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show ld.so symbols to debuggers */
end_comment

begin_decl_stmt
name|char
modifier|*
name|library_path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* alternate path for library search */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* root of environment strings */
end_comment

begin_decl_stmt
name|char
modifier|*
name|main_program
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string identifying lmp of "main" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ldso_program
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string identifying lmp of "ld.so" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cached_symbol
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last string cached by lookup */
end_comment

begin_decl_stmt
name|int
name|use_cache
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tell lo_lookup ok to use cache */
end_comment

begin_decl_stmt
name|int
name|version_no
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* link dynamic version number */
end_comment

begin_function_decl
name|caddr_t
name|rtmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|nlist
modifier|*
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|nlist
modifier|*
name|findsb
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|nlist
modifier|*
name|ldsofindsb
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|link_map
modifier|*
name|have_we_got_it
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|link_map
modifier|*
name|new_lmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|link_map
modifier|*
name|map_so
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|map_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dl_object
modifier|*
name|new_dlp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|relocate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|upd_reloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|link_map
modifier|*
name|pc_to_lmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_dlp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dl_object
modifier|*
name|dlopen_worker
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|rtbinder
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* declare the binding function */
end_comment

begin_function_decl
specifier|extern
name|caddr_t
name|caller
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* function to return our caller's pc */
end_comment

begin_comment
comment|/*  * Option storage.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PROF
end_ifdef

begin_decl_stmt
name|int
name|prof_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prof_buf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WHOAMI
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HRC_TIME
end_ifdef

begin_function_decl
specifier|extern
name|void
name|hrc_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|hrc_time
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|ftime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|etime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|time1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|time2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|time3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|time4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|time5
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Dummies for LD_PRELOAD.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|link_dynamic_2
name|pld_ld2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dummy structure for preloads */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|link_dynamic
name|pld_ld
init|=
comment|/* dummy __DYNAMIC */
block|{
literal|2
block|,
operator|(
expr|struct
name|ld_debug
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Run-time link editor bootstrap entry point.  Called by program requiring  * initial link editing at startup (generally, crt0).  */
end_comment

begin_macro
name|rtld
argument_list|(
argument|version
argument_list|,
argument|iptr
argument_list|,
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interface version */
end_comment

begin_decl_stmt
name|caddr_t
name|iptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interface passed from program */
end_comment

begin_decl_stmt
specifier|register
name|struct
name|link_dynamic
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ld.so dynamic pointer */
end_comment

begin_block
block|{
specifier|register
name|struct
name|crt_i1
modifier|*
name|ip
decl_stmt|;
comment|/* crt0 version 1 interface structure */
specifier|register
name|int
name|reloc
decl_stmt|;
comment|/* count of internal relocations */
specifier|register
comment|/* scratch relocation entry pointer */
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* integer temporaries */
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/* character pointer temporaries */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* temporary storage pointers */
name|struct
name|link_object
modifier|*
name|lop
decl_stmt|;
comment|/* work pointer */
name|struct
name|link_object
modifier|*
modifier|*
name|lopp
decl_stmt|;
comment|/* preloaded object insertion point */
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
comment|/* work pointer */
name|struct
name|link_map
modifier|*
name|nlmp
decl_stmt|;
comment|/* newly allocated link_map */
comment|/* 	 * Determine interface format.  A prototype interface once existed 	 * that passed an address as the first argument.  We assume this 	 * address is greater than the size of a page, and thus use this 	 * to test for it.  Eventually, support for this will be deleted. 	 */
if|if
condition|(
name|version
operator|<
name|PAGSIZ
condition|)
block|{
comment|/* version 1 of new interface */
name|ip
operator|=
operator|(
expr|struct
name|crt_i1
operator|*
operator|)
name|iptr
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"ld.so: unsupported crt interface version of %d\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* old interface */
name|panic
argument_list|(
literal|"ld.so: obsolete crt interface\n"
argument_list|)
expr_stmt|;
comment|/* 	 * ld.so must itself be relocated, take care of this now. 	 * We can not refer to global data before this step is 	 * complete.  Perform the relocation by stepping over all 	 * entries in the relocation table and turn them into 	 * absolute addresses.   	 * 	 * N.B. We have the assumption here that there are no  	 * symbolic relocations which need to be performed. 	 */
operator|(
name|int
operator|)
name|dp
operator|->
name|v2
operator|+=
name|ip
operator|->
name|crt_baseaddr
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
comment|/* 	 * SPARC does not have a divide instruction, but we can not 	 * call support routine until we have finished relocating the 	 * loader. 	 */
define|#
directive|define
name|RELOC_SIZE
value|sizeof (struct relocation_info)
name|reloc
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|GETRELSZ
argument_list|(
name|dp
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|i
operator|-=
name|RELOC_SIZE
expr_stmt|;
name|reloc
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
name|reloc
operator|=
name|GETRELSZ
argument_list|(
name|dp
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rp
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|RELOCOFF
argument_list|(
name|dp
argument_list|)
operator|+
operator|(
name|dp
operator|->
name|ld_version
operator|<
name|VERSION2
condition|?
operator|(
name|int
operator|)
name|dp
else|:
name|ip
operator|->
name|crt_baseaddr
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reloc
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|upd_reloc
argument_list|(
name|rp
argument_list|,
operator|(
name|long
operator|*
operator|)
operator|(
name|rp
operator|->
name|r_address
operator|+
name|ip
operator|->
name|crt_baseaddr
operator|)
argument_list|,
name|ip
operator|->
name|crt_baseaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|rp
operator|->
name|r_address
operator|+
name|ip
operator|->
name|crt_baseaddr
operator|)
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|rp
operator|->
name|r_address
operator|+
name|ip
operator|->
name|crt_baseaddr
operator|)
operator|+
name|ip
operator|->
name|crt_baseaddr
expr_stmt|;
endif|#
directive|endif
name|rp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Relocation is completed.  Update any global data necessary 	 * to continue. 	 */
name|environ
operator|=
name|ip
operator|->
name|crt_ep
expr_stmt|;
name|rtgetenv
argument_list|()
expr_stmt|;
name|devzero_fd
operator|=
name|ip
operator|->
name|crt_dzfd
expr_stmt|;
name|pld_ld
operator|.
name|ld_un
operator|.
name|ld_2
operator|=
operator|&
name|pld_ld2
expr_stmt|;
comment|/* C bug with initializing unions */
comment|/* 	 * Initialize link maps.  Create a link map for ld.so -- however 	 * do not put it on the "public list" unless we are making its 	 * symbols available to the debugger. 	 */
name|pdlpp
operator|=
operator|&
name|hdlp
expr_stmt|;
name|plmpp
operator|=
operator|&
name|hlmp
expr_stmt|;
name|ldso_program
operator|=
literal|"/usr/lib/ld.so"
expr_stmt|;
name|ld_lo
operator|.
name|lo_name
operator|=
operator|(
name|long
operator|)
name|ldso_program
operator|-
name|ip
operator|->
name|crt_baseaddr
expr_stmt|;
name|ld_lmp
operator|=
name|new_lmp
argument_list|(
name|ldso_program
argument_list|,
operator|&
name|ld_lo
argument_list|,
name|ip
operator|->
name|crt_baseaddr
argument_list|,
name|ip
operator|->
name|crt_baseaddr
argument_list|,
name|dp
argument_list|,
name|findsb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbols_public
condition|)
name|hlmp
operator|=
name|NULL
expr_stmt|;
name|plmpp
operator|=
operator|&
name|hlmp
expr_stmt|;
name|db_malloc
operator|=
name|heap_malloc
operator|=
name|rtmalloc
expr_stmt|;
name|is_secure
operator|=
name|secure_objects
expr_stmt|;
name|main_program
operator|=
literal|"main_$main_"
expr_stmt|;
ifdef|#
directive|ifdef
name|PROF
comment|/* 	 * If profiling features are turned on, then see if the profiling 	 * file exists.  If so, map in the file and use it as our profile 	 * buffer. 	 */
if|if
condition|(
operator|(
name|prof_fd
operator|=
name|open
argument_list|(
literal|"/tmp/ld.so.profile_buffer"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|prof_buf
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
literal|0x2000
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|prof_fd
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"ld.so: mmap failure (%d) for profile buffer\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|profil
argument_list|(
name|prof_buf
argument_list|,
literal|0x2000
argument_list|,
name|ip
operator|->
name|crt_baseaddr
argument_list|,
literal|0x4000
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|prof_fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|PROF
ifdef|#
directive|ifdef
name|HRC_TIME
name|hrc_init
argument_list|()
expr_stmt|;
name|ftime
operator|=
name|stime
operator|=
name|hrc_time
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Free descriptor on ld.so. 	 */
name|close
argument_list|(
name|ip
operator|->
name|crt_rlfd
argument_list|)
expr_stmt|;
comment|/* 	 * If we're letting the user freelance, then see if the user has 	 * specified any files to be dynamically loaded.  If so, build 	 * link-object data structures for them and get them. 	 * N.B. THIS IS FOR DEBUGGING ONLY.  IT IS NOT SUPPORTED NOR  	 * IS IT TO BE DOCUMENTED! 	 */
if|if
condition|(
operator|(
name|cp
operator|=
name|preload
operator|)
condition|)
if|if
condition|(
operator|!
name|secure_objects
argument_list|()
condition|)
block|{
name|int
name|f
init|=
literal|0
decl_stmt|;
comment|/* flag for scanning */
name|lopp
operator|=
operator|&
operator|(
expr|struct
name|link_object
operator|*
operator|)
name|pld_ld2
operator|.
name|ld_need
expr_stmt|;
name|bp
operator|=
name|buf
operator|=
name|rtmalloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
operator|*
name|bp
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|bp
argument_list|)
operator|||
operator|(
operator|*
name|bp
operator|==
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|f
operator|=
literal|0
expr_stmt|;
name|lop
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
name|rtmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|link_object
argument_list|)
argument_list|)
expr_stmt|;
name|lop
operator|->
name|lo_name
operator|=
operator|(
name|long
operator|)
name|buf
expr_stmt|;
name|lop
operator|->
name|lo_library
operator|=
literal|0
expr_stmt|;
name|lop
operator|->
name|lo_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|lopp
operator|=
name|lop
expr_stmt|;
name|lopp
operator|=
operator|&
operator|(
expr|struct
name|link_object
operator|*
operator|)
name|lop
operator|->
name|lo_next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|f
operator|=
literal|1
expr_stmt|;
name|buf
operator|=
name|bp
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|cp
operator|++
condition|)
do|;
comment|/* 			 * Have list of objects.  Go add them. 			 */
operator|(
name|void
operator|)
name|new_lmp
argument_list|(
literal|"ld_$preload_"
argument_list|,
name|NULL
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|pld_ld
argument_list|,
name|findsb
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Insert link_map for "main". 	 */
name|mlmp
operator|=
name|new_lmp
argument_list|(
name|main_program
argument_list|,
name|NULL
argument_list|,
name|MAIN_BASE
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ip
operator|->
name|crt_udp
argument_list|,
name|findsb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HRC_TIME
name|etime
operator|=
name|hrc_time
argument_list|()
expr_stmt|;
name|time1
operator|=
name|etime
operator|-
name|stime
expr_stmt|;
name|stime
operator|=
name|etime
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Walk map of loaded objects, loading their requisite objects as 	 * necessary.  Note that the first one we load in this loop is the 	 * first one we hand back to the debugger (see use of plmp). 	 */
for|for
control|(
name|lmp
operator|=
name|hlmp
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
if|if
condition|(
name|lmp
operator|->
name|lm_ld
condition|)
block|{
for|for
control|(
name|lop
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|&
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
index|[
name|lmp
operator|->
name|lm_ld
operator|->
name|v2
operator|->
name|ld_need
index|]
init|;
name|lop
operator|!=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|&
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
index|[
literal|0
index|]
condition|;
name|lop
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|&
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
index|[
name|lop
operator|->
name|lo_next
index|]
control|)
if|if
condition|(
operator|!
name|have_we_got_it
argument_list|(
name|lop
argument_list|,
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|nlmp
operator|=
name|map_so
argument_list|(
name|lmp
argument_list|,
name|lop
argument_list|)
condition|)
if|if
condition|(
operator|!
name|plmp
condition|)
name|plmp
operator|=
name|nlmp
expr_stmt|;
block|}
comment|/* 	 * If we've just been asked to describe what we would load, 	 * describe what we did load, and terminate the process. 	 */
if|if
condition|(
name|tracing
condition|)
block|{
for|for
control|(
name|lmp
operator|=
name|plmp
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
if|if
condition|(
name|lmp
operator|->
name|lm_lop
operator|->
name|lo_library
condition|)
name|printf
argument_list|(
literal|"\t-l%s.%d => %s\n"
argument_list|,
operator|&
name|lmp
operator|->
name|lm_lob
index|[
name|lmp
operator|->
name|lm_lop
operator|->
name|lo_name
index|]
argument_list|,
name|lmp
operator|->
name|lm_lop
operator|->
name|lo_major
argument_list|,
name|lmp
operator|->
name|lm_name
condition|?
name|lmp
operator|->
name|lm_name
else|:
literal|"not found"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\t%s%s\n"
argument_list|,
operator|&
name|lmp
operator|->
name|lm_lob
index|[
name|lmp
operator|->
name|lm_lop
operator|->
name|lo_name
index|]
argument_list|,
name|lmp
operator|->
name|lm_name
condition|?
literal|""
else|:
literal|" (not found)"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HRC_TIME
name|etime
operator|=
name|hrc_time
argument_list|()
expr_stmt|;
name|time2
operator|=
name|etime
operator|-
name|stime
expr_stmt|;
name|stime
operator|=
name|etime
expr_stmt|;
comment|/* +++ time in mmap loop */
endif|#
directive|endif
comment|/*  	 * Relocate all loaded objects. 	 */
for|for
control|(
name|lmp
operator|=
name|hlmp
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
if|if
condition|(
name|lmp
operator|!=
name|ld_lmp
condition|)
name|relocate
argument_list|(
name|lmp
argument_list|,
name|mlmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HRC_TIME
name|etime
operator|=
name|hrc_time
argument_list|()
expr_stmt|;
name|time3
operator|=
name|etime
operator|-
name|stime
expr_stmt|;
name|stime
operator|=
name|etime
expr_stmt|;
comment|/* +++ time in relocate loop */
endif|#
directive|endif
comment|/* 	 * Store in the "main" link_dynamic the list of objects we 	 * loaded.  Also return any commons that were allocated. 	 */
name|ip
operator|->
name|crt_udp
operator|->
name|v2
operator|->
name|ld_loaded
operator|=
name|plmp
expr_stmt|;
if|if
condition|(
name|rtcp
condition|)
name|ip
operator|->
name|crt_udp
operator|->
name|ldd
operator|->
name|ldd_cp
operator|=
name|rtcp
expr_stmt|;
comment|/* 	 * If we're running under a debugger, let it know we've 	 * done our loader thing. 	 */
if|if
condition|(
name|ip
operator|->
name|crt_udp
operator|->
name|ldd
operator|->
name|ldd_in_debugger
condition|)
block|{
name|ip
operator|->
name|crt_udp
operator|->
name|ldd
operator|->
name|ldd_bp_addr
operator|=
name|ip
operator|->
name|crt_breakp
expr_stmt|;
if|if
condition|(
operator|!
name|mlmp
operator|->
name|lm_rwt
condition|)
if|if
condition|(
name|mprotect
argument_list|(
name|PAGEMASK
operator|&
operator|(
name|int
operator|)
name|ip
operator|->
name|crt_breakp
argument_list|,
name|PAGESIZE
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|map_error
argument_list|(
literal|"text write-enable"
argument_list|,
literal|"main"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|crt_udp
operator|->
name|ldd
operator|->
name|ldd_sym_loaded
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|crt_udp
operator|->
name|ldd
operator|->
name|ldd_bp_inst
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|ip
operator|->
name|crt_breakp
operator|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|ip
operator|->
name|crt_breakp
operator|)
operator|=
name|TRAP
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|ip
operator|->
name|crt_breakp
operator|)
operator|=
name|TRAP
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|mlmp
operator|->
name|lm_rwt
condition|)
if|if
condition|(
name|mprotect
argument_list|(
name|PAGEMASK
operator|&
operator|(
name|int
operator|)
name|ip
operator|->
name|crt_breakp
argument_list|,
name|PAGESIZE
argument_list|,
name|PROT_READ
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"ld.so: error %d on main text write-protect\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Turn write-protect back on for text segments. 	 */
for|for
control|(
name|lmp
operator|=
name|hlmp
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
if|if
condition|(
name|lmp
operator|->
name|lm_rwt
condition|)
block|{
if|if
condition|(
name|mprotect
argument_list|(
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
argument_list|,
name|PROUND
argument_list|(
name|lmp
operator|->
name|lm_ld
operator|->
name|v2
operator|->
name|ld_text
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"ld.so: write protect error %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|lmp
operator|->
name|lm_rwt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Get rid of /dev/zero 	 */
operator|(
name|void
operator|)
name|close
argument_list|(
name|devzero_fd
argument_list|)
expr_stmt|;
name|devzero_fd
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HRC_TIME
name|etime
operator|=
name|hrc_time
argument_list|()
expr_stmt|;
name|time4
operator|=
name|etime
operator|-
name|stime
expr_stmt|;
name|stime
operator|=
name|etime
expr_stmt|;
comment|/* +++ time in misc stuff after relocate loop */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"before mainloop %x main loop %x relocate %x misc %x\n"
argument_list|,
name|time1
argument_list|,
name|time2
argument_list|,
name|time3
argument_list|,
name|time4
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" total %x\n"
argument_list|,
name|etime
operator|-
name|ftime
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Indicate whether a given link_object has already been mapped into the  * address space.  */
end_comment

begin_function
specifier|static
name|struct
name|link_map
modifier|*
name|have_we_got_it
parameter_list|(
name|lop
parameter_list|,
name|ba
parameter_list|)
name|struct
name|link_object
modifier|*
name|lop
decl_stmt|;
name|caddr_t
name|ba
decl_stmt|;
block|{
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
for|for
control|(
name|lmp
operator|=
name|hlmp
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
if|if
condition|(
name|lmp
operator|->
name|lm_lop
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|ba
index|[
name|lop
operator|->
name|lo_name
index|]
argument_list|,
operator|&
name|lmp
operator|->
name|lm_lob
index|[
name|lmp
operator|->
name|lm_lop
operator|->
name|lo_name
index|]
argument_list|)
condition|)
return|return
operator|(
name|lmp
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle mapping error.  */
end_comment

begin_function
specifier|static
name|void
name|map_error
parameter_list|(
name|s
parameter_list|,
name|cp
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
comment|/* type of mapping */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* object being mapped */
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ld.so: swap space exhausted for %s of %s\n"
argument_list|,
name|s
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"ld.so: %s error (%d) for %s\n"
argument_list|,
name|s
argument_list|,
name|errno
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|link_map
modifier|*
name|mapit
argument_list|(
name|s
argument_list|,
name|lop
argument_list|,
name|lob
argument_list|,
name|intp
argument_list|)
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* object name */
end_comment

begin_decl_stmt
name|struct
name|link_object
modifier|*
name|lop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* link object that derived file */
end_comment

begin_decl_stmt
name|caddr_t
name|lob
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base address for link object */
end_comment

begin_function_decl
name|struct
name|nlist
modifier|*
function_decl|(
modifier|*
name|intp
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* interpreter for link map */
end_comment

begin_block
block|{
name|struct
name|exec
name|exec
decl_stmt|;
comment|/* working area for object headers */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor temporary */
name|caddr_t
name|addr
decl_stmt|;
comment|/* mmap result temporary */
name|struct
name|link_dynamic
modifier|*
name|dp
decl_stmt|;
comment|/* dynamic pointer of object mapped */
name|int
name|size
decl_stmt|;
comment|/* size of object */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|s
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Verify the object's header. 	 */
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|exec
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ld.so: can't read struct exec for %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
if|#
directive|if
name|TARGET
operator|==
name|SUN2
condition|(
name|exec
operator|.
name|a_machtype
operator|!=
name|M_68010
condition|)
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|(
operator|(
name|exec
operator|.
name|a_machtype
operator|!=
name|M_68010
operator|)
operator|&&
operator|(
name|exec
operator|.
name|a_machtype
operator|!=
name|M_68020
operator|)
operator|)
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN4
operator|(
name|exec
operator|.
name|a_machtype
operator|!=
name|M_SPARC
operator|)
endif|#
directive|endif
name|panic
argument_list|(
literal|"ld.so: %s is not for this machine type\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Map text and allocate enough address space to fit the whole  	 * library.  Note that we map enough to catch the first symbol 	 * in the symbol table and thereby avoid an "lseek"& "read" 	 * pair to pick it up. 	 */
comment|/* XXX need to fail in ways besides "panic". */
name|size
operator|=
name|max
argument_list|(
name|SIZE
argument_list|(
name|exec
argument_list|)
argument_list|,
name|N_SYMOFF
argument_list|(
name|exec
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_EXEC
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
name|map_error
argument_list|(
literal|"mmap"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Grab the first symbol entry while we've got it mapped aligned 	 * to file addresses.  We assume that this symbol describes the 	 * object's link_dynamic. 	 */
name|dp
operator|=
operator|(
expr|struct
name|link_dynamic
operator|*
operator|)
operator|&
name|addr
index|[
operator|(
operator|(
expr|struct
name|nlist
operator|*
block|)
end_block

begin_expr_stmt
operator|&
name|addr
index|[
name|N_SYMOFF
argument_list|(
name|exec
argument_list|)
index|]
end_expr_stmt

begin_expr_stmt
unit|)
operator|->
name|n_value
expr|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Map the initialized data portion of the file to the correct 	 * point in the range of allocated addresses.  This will leave 	 * some portion of the data segment "doubly mapped" on machines 	 * where the text/data relocation alignment is not on a page 	 * boundaries.  However, leaving the file mapped has the double 	 * advantage of both saving the munmap system call and of leaving 	 * us a contiguous chunk of address space devoted to the object -- 	 * in case we need to unmap it all later. 	 */
end_comment

begin_if
if|if
condition|(
name|mmap
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|addr
operator|+
name|SROUND
argument_list|(
name|exec
operator|.
name|a_text
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|exec
operator|.
name|a_data
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|,
name|MAP_FIXED
operator||
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|exec
operator|.
name|a_text
argument_list|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
name|map_error
argument_list|(
literal|"mmap data"
argument_list|,
name|s
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* 	 * Allocate pages for the object's bss, if necessary. 	 */
end_comment

begin_if
if|if
condition|(
name|exec
operator|.
name|a_bss
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|get_zero_object
argument_list|()
condition|)
name|map_error
argument_list|(
literal|"mmap bss"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmap
argument_list|(
name|addr
operator|+
name|SROUND
argument_list|(
name|exec
operator|.
name|a_text
argument_list|)
operator|+
name|exec
operator|.
name|a_data
argument_list|,
operator|(
name|int
operator|)
name|exec
operator|.
name|a_bss
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|,
name|MAP_FIXED
operator||
name|MAP_PRIVATE
argument_list|,
name|devzero_fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
name|map_error
argument_list|(
literal|"mmap bss"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* 	 * Finished with shared object mapping, get rid of descriptor. 	 */
end_comment

begin_expr_stmt
name|dp
operator|->
name|v2
operator|=
operator|(
expr|struct
name|link_dynamic_2
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|dp
operator|->
name|v2
operator|+
operator|(
name|int
operator|)
name|addr
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|new_lmp
argument_list|(
name|s
argument_list|,
name|lop
argument_list|,
name|lob
argument_list|,
name|addr
argument_list|,
name|dp
argument_list|,
name|intp
argument_list|)
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Map in a link object, return its link_map.  */
end_comment

begin_function
unit|static
name|struct
name|link_map
modifier|*
name|map_so
parameter_list|(
name|lmp
parameter_list|,
name|lop
parameter_list|)
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
comment|/* link_map from which lop came */
name|struct
name|link_object
modifier|*
name|lop
decl_stmt|;
comment|/* object to be mapped */
block|{
name|caddr_t
name|cp
decl_stmt|;
comment|/* work pointer */
specifier|static
name|int
name|flushed
init|=
literal|0
decl_stmt|;
comment|/* only flush cache once */
name|struct
name|link_map
modifier|*
name|nlmp
decl_stmt|;
comment|/* new link map for mapped object */
comment|/* 	 * Determine the absolute name of the object to be mapped. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|cp
operator|=
name|lop
operator|->
name|lo_library
condition|?
name|lo_lookup
argument_list|(
name|lop
argument_list|,
name|lmp
argument_list|)
else|:
operator|&
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
index|[
name|lop
operator|->
name|lo_name
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
if|if
condition|(
operator|!
name|tracing
condition|)
name|panic
argument_list|(
literal|"ld.so: lib%s.so.%d: not found\n"
argument_list|,
operator|&
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
index|[
name|lop
operator|->
name|lo_name
index|]
argument_list|,
name|lop
operator|->
name|lo_major
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_lmp
argument_list|(
name|NULL
argument_list|,
name|lop
argument_list|,
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|findsb
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * Open object. If we can not, see if flushing the cache 		 * and retrying helps.  There is special handling for the 		 * "programmer's interface", embodied in libdl -- which 		 * is really just an alias for some of our own symbols. 		 * Note that this allows for special handling ONLY for 		 * a libdl installed with /usr/lib/ld.so -- i.e., the 		 * one *in* /usr/lib. 		 */
if|if
condition|(
operator|(
name|nlmp
operator|=
name|mapit
argument_list|(
name|cp
argument_list|,
name|lop
argument_list|,
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
argument_list|,
operator|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"/usr/lib/libdl.so.1.0"
argument_list|)
condition|?
name|ldsofindsb
else|:
name|findsb
operator|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flushed
condition|)
block|{
if|if
condition|(
operator|!
name|tracing
condition|)
name|panic
argument_list|(
literal|"ld.so: open error %d for %s\n"
argument_list|,
name|errno
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_lmp
argument_list|(
name|NULL
argument_list|,
name|lop
argument_list|,
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|findsb
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|lo_flush
argument_list|()
expr_stmt|;
name|flushed
operator|++
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
comment|/* 	 * Process dynamic interface we just loaded, including 	 * list of objects on which this one depends. 	 */
return|return
operator|(
name|nlmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new link map for file "f", loaded at "addr" from link_object  * "lop", with a dynamic at "dp".  Manage a free list of "link maps" -- as  * we have no way to reclaim one into a "heap" when one is made free.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|link_map
modifier|*
name|new_lmp
argument_list|(
name|f
argument_list|,
name|lop
argument_list|,
name|lob
argument_list|,
name|addr
argument_list|,
name|dp
argument_list|,
name|intp
argument_list|)
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file name */
end_comment

begin_decl_stmt
name|struct
name|link_object
modifier|*
name|lop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* link object that derived file */
end_comment

begin_decl_stmt
name|caddr_t
name|lob
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base address for link object */
end_comment

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address where mapped */
end_comment

begin_decl_stmt
name|struct
name|link_dynamic
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* link_dynamic for file */
end_comment

begin_function_decl
name|struct
name|nlist
modifier|*
function_decl|(
modifier|*
name|intp
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* interpreter for link map */
end_comment

begin_block
block|{
name|caddr_t
name|offset
decl_stmt|;
comment|/* hack for "main" */
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
comment|/* link map we built */
comment|/* 	 * For the "main" program, addresses in the link_dynamic structure 	 * are "broken" (text relocated to "0" rather than MAIN_BASE).   	 * We "know" which these are, and deal with them especially here. 	 * XXX 	 */
name|offset
operator|=
name|f
operator|==
name|main_program
condition|?
operator|(
name|caddr_t
operator|)
name|MAIN_BASE
else|:
name|addr
expr_stmt|;
comment|/* 	 * Allocate link_map structure, and private data structure. 	 * Add the new link_map to the list of link_map's. 	 */
if|if
condition|(
name|lmp
operator|=
name|flmp
condition|)
name|flmp
operator|=
name|lmp
operator|->
name|lm_next
expr_stmt|;
else|else
block|{
name|lmp
operator|=
operator|(
expr|struct
name|link_map
operator|*
operator|)
name|rtmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|link_map
argument_list|)
argument_list|)
expr_stmt|;
name|lmp
operator|->
name|lm_lpd
operator|=
name|rtmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ld_private
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lmp
operator|->
name|lm_next
operator|=
operator|*
name|plmpp
expr_stmt|;
operator|*
name|plmpp
operator|=
name|lmp
expr_stmt|;
name|plmpp
operator|=
operator|&
name|lmp
operator|->
name|lm_next
expr_stmt|;
comment|/* 	 * Fill in the fields in the new link_map.  Load the private 	 * data cache with pre-relocated information from the object's 	 * unrelocated link_dynamic. 	 */
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_symbol_base
operator|=
name|lmp
operator|->
name|lm_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|lmp
operator|->
name|lm_name
operator|=
name|rtmalloc
argument_list|(
name|strlen
argument_list|(
name|f
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lmp
operator|->
name|lm_name
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|lmp
operator|->
name|lm_name
operator|=
name|f
expr_stmt|;
name|lmp
operator|->
name|lm_lop
operator|=
name|lop
expr_stmt|;
name|lmp
operator|->
name|lm_lob
operator|=
name|lob
expr_stmt|;
name|lmp
operator|->
name|lm_ld
operator|=
name|dp
expr_stmt|;
comment|/* 	 * Fill in fields from target's dynamic structure -- if there is 	 * one.  (There might not be because we are "tracing.") 	 */
if|if
condition|(
name|dp
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|ld_version
operator|<
name|VERSION2
condition|)
name|panic
argument_list|(
literal|"ld.so: __DYNAMIC version %d not supported\n"
argument_list|,
name|dp
operator|->
name|ld_version
argument_list|)
expr_stmt|;
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_plt
operator|=
operator|(
expr|struct
name|jbind
operator|*
operator|)
operator|(
operator|&
name|addr
index|[
name|JMPOFF
argument_list|(
name|dp
argument_list|)
index|]
operator|)
expr_stmt|;
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_rp
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
operator|&
name|offset
index|[
name|RELOCOFF
argument_list|(
name|dp
argument_list|)
index|]
operator|)
expr_stmt|;
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_hash
operator|=
operator|(
expr|struct
name|fshash
operator|*
operator|)
operator|(
operator|&
name|offset
index|[
name|HASHOFF
argument_list|(
name|dp
argument_list|)
index|]
operator|)
expr_stmt|;
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_symtab
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
operator|(
operator|&
name|offset
index|[
name|SYMOFF
argument_list|(
name|dp
argument_list|)
index|]
operator|)
expr_stmt|;
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_symstr
operator|=
operator|&
name|offset
index|[
name|STROFF
argument_list|(
name|dp
argument_list|)
index|]
expr_stmt|;
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_textbase
operator|=
name|offset
expr_stmt|;
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_interp
operator|=
name|intp
expr_stmt|;
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_refcnt
operator|++
expr_stmt|;
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_dlh
operator|=
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_dlp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|lmp
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|free_lmp
parameter_list|(
name|lmp
parameter_list|)
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
block|{
name|struct
name|link_map
modifier|*
name|tlmp
decl_stmt|;
comment|/* temporary */
name|struct
name|link_map
modifier|*
modifier|*
name|plmp
decl_stmt|;
comment|/* previous pointer */
name|tlmp
operator|=
name|hlmp
operator|,
name|plmp
operator|=
operator|&
name|hlmp
expr_stmt|;
while|while
condition|(
name|tlmp
condition|)
block|{
if|if
condition|(
name|tlmp
operator|==
name|lmp
condition|)
block|{
name|cached_symbol
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|lmp
operator|->
name|lm_addr
argument_list|,
name|max
argument_list|(
name|SIZE
argument_list|(
operator|*
operator|(
expr|struct
name|exec
operator|*
operator|)
name|lmp
operator|->
name|lm_addr
argument_list|)
argument_list|,
name|N_SYMOFF
argument_list|(
operator|(
operator|*
operator|(
expr|struct
name|exec
operator|*
operator|)
name|lmp
operator|->
name|lm_addr
operator|)
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|plmp
operator|=
name|lmp
operator|->
name|lm_next
expr_stmt|;
if|if
condition|(
name|plmpp
operator|==
operator|&
name|lmp
operator|->
name|lm_next
condition|)
name|plmpp
operator|=
name|plmp
expr_stmt|;
name|lmp
operator|->
name|lm_next
operator|=
name|flmp
expr_stmt|;
name|flmp
operator|=
name|lmp
expr_stmt|;
return|return;
block|}
name|plmp
operator|=
operator|&
name|tlmp
operator|->
name|lm_next
expr_stmt|;
name|tlmp
operator|=
name|tlmp
operator|->
name|lm_next
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"ld.so: mangled lm object list.\n"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * Relocate an object.  */
end_comment

begin_function
specifier|static
name|void
name|relocate
parameter_list|(
name|lmp
parameter_list|,
name|clmp
parameter_list|)
specifier|register
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
comment|/* object to be relocated */
specifier|register
name|struct
name|link_map
modifier|*
name|clmp
decl_stmt|;
comment|/* calling link map */
block|{
name|int
name|k
decl_stmt|;
comment|/* loop temporary */
name|int
name|nr
decl_stmt|;
comment|/* number of relocations */
name|char
modifier|*
name|symbol
decl_stmt|;
comment|/* symbol being searched for */
name|caddr_t
name|et
decl_stmt|;
comment|/* cached _etext of object */
specifier|register
name|long
name|j
decl_stmt|;
comment|/* relocation temporary */
specifier|register
name|caddr_t
name|ra
decl_stmt|;
comment|/* cached relocation address */
specifier|register
name|struct
comment|/* current relocation */
name|relocation_info
modifier|*
name|rp
decl_stmt|;
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
comment|/* symbol table of "symbol" */
name|struct
name|link_map
modifier|*
name|llmp
decl_stmt|;
comment|/* lmp of source of "symbol" */
comment|/* 	 * Cache some invariants. 	 */
name|rp
operator|=
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_rp
expr_stmt|;
name|et
operator|=
operator|&
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
index|[
name|lmp
operator|->
name|lm_ld
operator|->
name|v2
operator|->
name|ld_text
index|]
expr_stmt|;
name|nr
operator|=
name|GETRELSZ
argument_list|(
name|lmp
operator|->
name|lm_ld
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize _PLT_, if any. 	 */
if|if
condition|(
name|lmp
operator|->
name|lm_ld
operator|->
name|v2
operator|->
name|ld_plt_sz
condition|)
block|{
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|int
modifier|*
name|inst
init|=
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_plt
operator|->
name|jb_inst
decl_stmt|;
name|int
name|tmp
init|=
operator|(
name|int
operator|)
name|rtbinder
decl_stmt|;
operator|*
name|inst
operator|++
operator||=
operator|(
operator|(
name|tmp
operator|>>
operator|(
literal|32
operator|-
literal|22
operator|)
operator|)
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
expr_stmt|;
operator|*
name|inst
operator||=
operator|(
name|tmp
operator|&
name|MASK
argument_list|(
literal|10
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_plt
operator|->
name|cl_hi
operator|=
operator|(
name|int
operator|)
name|rtbinder
operator|>>
literal|16
expr_stmt|;
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_plt
operator|->
name|cl_low
operator|=
operator|(
name|int
operator|)
name|rtbinder
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Loop over all relocations. 	 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nr
condition|;
name|k
operator|++
operator|,
name|rp
operator|++
control|)
block|{
comment|/* 		 * Check to see if we're relocating in the text segment 		 * and turn off the write protect if necessary. 		 */
if|if
condition|(
operator|(
name|ra
operator|=
operator|&
name|lmp
operator|->
name|lm_addr
index|[
name|rp
operator|->
name|r_address
index|]
operator|)
operator|<
name|et
condition|)
if|if
condition|(
name|lmp
operator|->
name|lm_rwt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mprotect
argument_list|(
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
argument_list|,
name|PROUND
argument_list|(
call|(
name|long
call|)
argument_list|(
name|et
operator|-
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|map_error
argument_list|(
literal|"text write-enable"
argument_list|,
name|lmp
operator|->
name|lm_name
argument_list|)
expr_stmt|;
name|lmp
operator|->
name|lm_rwt
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Perform the relocation. 		 */
if|if
condition|(
name|rp
operator|->
name|r_extern
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|upd_reloc
argument_list|(
name|rp
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ra
argument_list|,
operator|(
name|long
operator|)
name|lmp
operator|->
name|lm_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|ra
operator|)
operator|+=
operator|(
name|int
operator|)
name|lmp
operator|->
name|lm_addr
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|TARGET
operator|==
name|SUN4
if|if
condition|(
name|rp
operator|->
name|r_type
operator|==
name|RELOC_JMP_SLOT
condition|)
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
if|if
condition|(
name|rp
operator|->
name|r_jmptable
condition|)
endif|#
directive|endif
continue|continue;
name|sp
operator|=
operator|&
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_symtab
index|[
name|rp
operator|->
name|r_symbolnum
index|]
expr_stmt|;
name|symbol
operator|=
operator|&
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_symstr
index|[
name|sp
operator|->
name|n_un
operator|.
name|n_strx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|lookup
argument_list|(
name|symbol
argument_list|,
operator|&
name|llmp
argument_list|,
name|clmp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ld.so: Undefined symbol: %s\n"
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|j
operator|=
name|sp
operator|->
name|n_value
operator|+
call|(
name|long
call|)
argument_list|(
name|sp
operator|->
name|n_type
operator|==
name|N_COMM
operator|||
name|sp
operator|->
name|n_type
operator|==
name|N_ABS
operator|+
name|N_EXT
condition|?
literal|0
else|:
name|llmp
operator|->
name|lm_addr
argument_list|)
operator|+
name|rp
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|isitpcrel
argument_list|(
name|rp
argument_list|)
condition|)
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
name|j
operator|=
name|sp
operator|->
name|n_value
operator|+
call|(
name|long
call|)
argument_list|(
name|sp
operator|->
name|n_type
operator|==
name|N_COMM
operator|||
name|sp
operator|->
name|n_type
operator|==
name|N_ABS
operator|+
name|N_EXT
condition|?
literal|0
else|:
name|llmp
operator|->
name|lm_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_pcrel
condition|)
endif|#
directive|endif
name|j
operator|-=
operator|(
name|long
operator|)
name|lmp
operator|->
name|lm_addr
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|upd_reloc
argument_list|(
name|rp
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ra
argument_list|,
name|j
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TARGET==SUN4
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
comment|/* 			 * Optimize out the call to upd_reloc.  Note 			 * that upd_reloc has unimplemented sanity checking 			 * that, when implemented, may require removing 			 * or otherwise altering this optimization. 			 */
operator|*
operator|(
name|long
operator|*
operator|)
name|ra
operator|+=
name|j
expr_stmt|;
endif|#
directive|endif
endif|TARGET==SUN3 || TARGET==SUN2
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Perform a specific relocation operation.  */
end_comment

begin_function
specifier|static
name|void
name|upd_reloc
parameter_list|(
name|rp
parameter_list|,
name|where
parameter_list|,
name|what
parameter_list|)
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|;
name|long
modifier|*
name|where
decl_stmt|;
name|long
name|what
decl_stmt|;
block|{
if|#
directive|if
name|TARGET
operator|==
name|SUN4
switch|switch
condition|(
name|rp
operator|->
name|r_type
condition|)
block|{
case|case
name|RELOC_RELATIVE
case|:
name|what
operator|+=
operator|*
name|where
operator|<<
operator|(
literal|32
operator|-
literal|22
operator|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
operator||
operator|(
operator|(
name|what
operator|>>
operator|(
literal|32
operator|-
literal|22
operator|)
operator|)
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
expr_stmt|;
name|where
operator|++
expr_stmt|;
name|what
operator|+=
operator|(
operator|*
name|where
operator|&
name|MASK
argument_list|(
literal|10
argument_list|)
operator|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|10
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|10
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|RELOC_8
case|:
case|case
name|RELOC_DISP8
case|:
name|what
operator|+=
operator|*
name|where
operator|&
name|MASK
argument_list|(
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN_RANGE
argument_list|(
name|what
argument_list|,
literal|8
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"byte displacement overflow at %#x"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
operator|*
name|where
operator|=
name|what
expr_stmt|;
break|break;
case|case
name|RELOC_LO10
case|:
case|case
name|RELOC_BASE10
case|:
name|what
operator|+=
operator|*
name|where
operator|&
name|MASK
argument_list|(
literal|10
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|10
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|10
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|RELOC_BASE13
case|:
case|case
name|RELOC_13
case|:
name|what
operator|+=
operator|*
name|where
operator|&
name|MASK
argument_list|(
literal|13
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|13
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|13
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|RELOC_16
case|:
case|case
name|RELOC_DISP16
case|:
name|what
operator|+=
operator|*
name|where
operator|&
name|MASK
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN_RANGE
argument_list|(
name|what
argument_list|,
literal|16
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"word displacement overflow at %#x"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|where
operator|=
name|what
expr_stmt|;
break|break;
case|case
name|RELOC_22
case|:
case|case
name|RELOC_BASE22
case|:
name|what
operator|+=
operator|*
name|where
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN_RANGE
argument_list|(
name|what
argument_list|,
literal|22
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sethi displacement overflow at %#x"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|RELOC_HI22
case|:
name|what
operator|+=
operator|(
operator|*
name|where
operator|<<
literal|32
operator|-
literal|22
operator|)
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
operator||
operator|(
operator|(
name|what
operator|>>
operator|(
literal|32
operator|-
literal|22
operator|)
operator|)
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|RELOC_WDISP22
case|:
name|what
operator|+=
operator|*
name|where
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|&
name|MASK
argument_list|(
literal|2
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"odd word displacement at %#x"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|what
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|IN_RANGE
argument_list|(
name|what
argument_list|,
literal|22
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"branch displacement overflow at %#x"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|RELOC_WDISP30
case|:
name|what
operator|+=
operator|*
name|where
operator|&
name|MASK
argument_list|(
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|&
name|MASK
argument_list|(
literal|2
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"odd word displacement at %#x"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|what
operator|>>=
literal|2
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|30
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|30
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|RELOC_32
case|:
case|case
name|RELOC_GLOB_DAT
case|:
case|case
name|RELOC_DISP32
case|:
name|what
operator|+=
operator|*
name|where
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
name|what
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown relocation type %d"
argument_list|,
name|rp
operator|->
name|r_type
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
comment|/* 	 * Put the value back in the segment, 	 * while checking for overflow. 	 */
name|what
operator|+=
operator|*
name|where
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
name|what
expr_stmt|;
comment|/* ++++ need to add this 	switch (rp->r_length) { 	case 0:	 		if (what< -128 || what> 127) 			fprintf(stderr, "byte displacement overflow at %#x", 				 rp->r_address); 		*where = what; 		break; 	case 1: 		if (what< -32768 || what> 32767) 			fprintf(stderr, "word displacement overflow at %#x", 				 rp->r_address); 		*(short *)where = what; 		break; 	case 2:		 		*(long *)where = what; 		break; 	} 	*/
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Calculate hash value for symbol being looked up.  */
end_comment

begin_function
specifier|static
name|int
name|gethashv
parameter_list|(
name|sn
parameter_list|)
name|char
modifier|*
name|sn
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
comment|/* accumulator for hash value */
comment|/* 	 * Calculate hash value for symbol being looked up. 	 */
for|for
control|(
name|val
operator|=
literal|0
init|;
operator|*
name|sn
condition|;
control|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|1
operator|)
operator|+
operator|*
name|sn
operator|++
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|nlist
modifier|*
name|ldsofindsb
parameter_list|(
name|lmp
parameter_list|,
name|sn
parameter_list|,
name|clmp
parameter_list|)
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
name|char
modifier|*
name|sn
decl_stmt|;
name|struct
name|link_map
modifier|*
name|clmp
decl_stmt|;
block|{
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|findsb
argument_list|(
name|lmp
argument_list|,
name|sn
argument_list|,
name|clmp
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|sp
operator|->
name|n_value
operator|==
literal|0
operator|)
operator|||
operator|(
name|sp
operator|->
name|n_type
operator|==
name|N_EXT
operator|+
name|N_UNDF
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_symbol_base
operator|=
name|ld_lmp
operator|->
name|lm_addr
expr_stmt|;
return|return
operator|(
name|findsb
argument_list|(
name|ld_lmp
argument_list|,
name|sn
argument_list|,
name|clmp
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HASHMASK
value|0x7fffffff
end_define

begin_function
specifier|static
name|struct
name|nlist
modifier|*
name|findsb
parameter_list|(
name|lmp
parameter_list|,
name|sn
parameter_list|,
name|clmp
parameter_list|)
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
name|char
modifier|*
name|sn
decl_stmt|;
name|struct
name|link_map
modifier|*
name|clmp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* temporary */
specifier|register
name|char
modifier|*
name|s1
decl_stmt|;
comment|/* string handling pointers */
name|struct
name|fshash
modifier|*
name|p
decl_stmt|;
comment|/* working pointer to .so symbols */
name|int
name|i
decl_stmt|;
comment|/* temporary */
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
comment|/* symbol entry pointer */
specifier|static
name|int
name|hashval
decl_stmt|;
comment|/* cache hash value of last symbol */
specifier|static
name|char
modifier|*
name|lp
decl_stmt|;
comment|/* cache last symbol pointer */
comment|/*  	 * this is a questionable cache since the same pointer may 	 * pointed to a different symbol. ++++ 	 */
if|if
condition|(
name|lp
operator|!=
name|sn
condition|)
name|hashval
operator|=
name|gethashv
argument_list|(
name|sn
argument_list|)
expr_stmt|;
if|if
condition|(
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_hash
operator|==
operator|(
expr|struct
name|fshash
operator|*
operator|)
operator|&
name|lmp
operator|->
name|lm_addr
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not found */
name|i
operator|=
operator|(
name|hashval
operator|&
name|HASHMASK
operator|)
operator|%
operator|(
name|lmp
operator|->
name|lm_ld
operator|->
name|v2
operator|->
name|ld_buckets
operator|==
literal|0
condition|?
name|RTHS
else|:
name|lmp
operator|->
name|lm_ld
operator|->
name|v2
operator|->
name|ld_buckets
operator|)
expr_stmt|;
name|p
operator|=
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_hash
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fssymbno
operator|!=
operator|-
literal|1
condition|)
do|do
block|{
name|sp
operator|=
operator|&
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_symtab
index|[
name|p
operator|->
name|fssymbno
index|]
expr_stmt|;
name|s1
operator|=
name|sn
expr_stmt|;
name|cp
operator|=
operator|&
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_symstr
index|[
name|sp
operator|->
name|n_un
operator|.
name|n_strx
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|cp
operator|++
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
block|{
return|return
operator|(
name|sp
operator|)
return|;
comment|/* found */
block|}
if|if
condition|(
name|p
operator|->
name|next
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not found */
else|else
continue|continue;
comment|/* next symbol */
block|}
do|while
condition|(
name|p
operator|=
operator|&
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_hash
index|[
name|p
operator|->
name|next
index|]
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup symbol with name (s).  Return pointer to symbol table entry  * representing it as well as index to dynamic object which defines it.  */
end_comment

begin_function
specifier|static
name|struct
name|nlist
modifier|*
name|lookup
parameter_list|(
name|s
parameter_list|,
name|lmpp
parameter_list|,
name|clmp
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|link_map
modifier|*
modifier|*
name|lmpp
decl_stmt|;
name|struct
name|link_map
modifier|*
name|clmp
decl_stmt|;
block|{
specifier|register
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
comment|/* working pointer */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* string handling pointers */
specifier|register
name|char
modifier|*
name|s1
decl_stmt|;
comment|/* string handling pointers */
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
comment|/* symbol table entry */
name|struct
name|nlist
modifier|*
name|savesp
decl_stmt|;
comment|/* save common data symbol entry */
name|int
name|msize
init|=
literal|0
decl_stmt|;
comment|/* common maximum size */
name|struct
name|rtc_symb
modifier|*
name|rs
decl_stmt|;
comment|/* new common */
name|struct
name|rtc_symb
modifier|*
name|trs
decl_stmt|;
comment|/* temporary for new common */
specifier|static
name|struct
name|nlist
modifier|*
name|lsp
decl_stmt|;
comment|/* cached copy of last symbol found */
specifier|static
name|struct
name|link_map
modifier|*
name|lmpc
decl_stmt|;
comment|/* cached link map pointer */
comment|/* 	 * Heuristic: if this symbol is the same as the last one, then 	 * just skip all this work. 	 * XXX should count this to see how effective it is. 	 */
if|if
condition|(
name|cached_symbol
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cached_symbol
argument_list|,
name|s
argument_list|)
condition|)
block|{
operator|*
name|lmpp
operator|=
name|lmpc
expr_stmt|;
return|return
operator|(
name|lsp
operator|)
return|;
block|}
name|cached_symbol
operator|=
name|s
expr_stmt|;
comment|/* 	 * Over all loaded objects, determine find the hash entry corresponding 	 * to this value, and search for a definition for this symbol. 	 */
for|for
control|(
name|lmp
operator|=
name|hlmp
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
block|{
name|lmpc
operator|=
name|lmp
expr_stmt|;
if|if
condition|(
name|lsp
operator|=
name|sp
operator|=
operator|(
operator|*
operator|(
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_interp
operator|)
operator|)
operator|(
name|lmp
operator|,
name|s
operator|,
name|clmp
operator|)
condition|)
block|{
comment|/* 			 * We found a match.  If it is simply a reference  			 * and not a definition we proceed to the next object. 			 * If it is a definition, and not a common then we  			 * have found what we're looking for so return it.  			 * Otherwise, determine whether the common has already  			 * been allocated, and if so, return that pointer. 			 */
if|if
condition|(
name|sp
operator|->
name|n_value
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
condition|)
block|{
if|if
condition|(
name|msize
operator|==
literal|0
condition|)
block|{
operator|*
name|lmpp
operator|=
name|lmp
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/*  				 * look up the runtime allocated commom 				 * symbol table  				 */
name|savesp
operator|=
name|sp
expr_stmt|;
name|trs
operator|=
name|rtcp
expr_stmt|;
while|while
condition|(
name|trs
condition|)
block|{
name|s1
operator|=
name|s
expr_stmt|;
name|cp
operator|=
name|trs
operator|->
name|rtc_sp
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|cp
operator|++
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|lsp
operator|=
name|trs
operator|->
name|rtc_sp
operator|)
return|;
name|trs
operator|=
name|trs
operator|->
name|rtc_next
expr_stmt|;
block|}
comment|/* 				 * It's an unallocated common,  				 * accumulate size information. 				 */
if|if
condition|(
name|msize
operator|<
name|sp
operator|->
name|n_value
condition|)
name|msize
operator|=
name|sp
operator|->
name|n_value
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/* 	 * If we got this far, we either have found nothing suitable or 	 * else have a common.  In the former, punt, otherwise we now 	 * know enough to allocate the common so do so. 	 */
if|if
condition|(
name|msize
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|rs
operator|=
operator|(
expr|struct
name|rtc_symb
operator|*
operator|)
name|rtmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtc_symb
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|rtc_sp
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|rtmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
name|trs
operator|=
name|rtcp
expr_stmt|;
name|rtcp
operator|=
name|rs
expr_stmt|;
name|rs
operator|->
name|rtc_next
operator|=
name|trs
expr_stmt|;
operator|*
operator|(
name|rs
operator|->
name|rtc_sp
operator|)
operator|=
operator|*
name|savesp
expr_stmt|;
name|rs
operator|->
name|rtc_sp
operator|->
name|n_un
operator|.
name|n_name
operator|=
name|rtmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rs
operator|->
name|rtc_sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|rs
operator|->
name|rtc_sp
operator|->
name|n_type
operator|=
name|N_COMM
expr_stmt|;
name|rs
operator|->
name|rtc_sp
operator|->
name|n_value
operator|=
operator|(
name|long
operator|)
name|rtmalloc
argument_list|(
name|msize
argument_list|)
expr_stmt|;
operator|*
name|lmpp
operator|=
name|lmpc
operator|=
name|hlmp
expr_stmt|;
return|return
operator|(
name|lsp
operator|=
name|rs
operator|->
name|rtc_sp
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Procedure call binding.  Called on initial call reference to a global  * unbound symbol.    */
end_comment

begin_function
name|int
name|binder
parameter_list|(
name|pc
parameter_list|,
name|relocindex
parameter_list|)
name|caddr_t
name|pc
decl_stmt|;
name|int
name|relocindex
decl_stmt|;
block|{
name|int
name|address
decl_stmt|;
comment|/* target address */
specifier|register
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
comment|/* link_map describing calling obj */
specifier|register
name|struct
comment|/* working relocation pointer */
name|relocation_info
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
comment|/* entry for symbol being referenced */
specifier|register
name|char
modifier|*
name|symbol
decl_stmt|;
comment|/* symbol being searched for */
name|struct
name|link_map
modifier|*
name|llmp
decl_stmt|;
comment|/* link_map in which symbol is found */
comment|/* 	 * Find the object that our caller came from. 	 */
for|for
control|(
name|lmp
operator|=
name|hlmp
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
if|if
condition|(
name|pc
operator|>
call|(
name|caddr_t
call|)
argument_list|(
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_plt
argument_list|)
operator|&&
name|pc
operator|<
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_plt
operator|+
name|lmp
operator|->
name|lm_ld
operator|->
name|v2
operator|->
name|ld_plt_sz
argument_list|)
condition|)
goto|goto
name|gotit
goto|;
comment|/* 	 * If no object can be found, we can't understand how we got 	 * here, so we panic. 	 */
if|if
condition|(
name|lmp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ld.so: unidentifiable procedure reference at 0x%x\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|gotit
label|:
comment|/* 	 * Need to know which link_dynamic version for plt handling. 	 * This interface will be revised post 4.0 ++++++ 	 */
if|#
directive|if
name|TARGET
operator|==
name|SUN4
define|#
directive|define
name|LAST22BITS
value|0x3fffff
name|version_no
operator|=
name|lmp
operator|->
name|lm_ld
operator|->
name|ld_version
expr_stmt|;
if|if
condition|(
name|version_no
operator|==
literal|3
condition|)
name|relocindex
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pc
operator|+
literal|4
operator|)
operator|&
name|LAST22BITS
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Find the symbol being referenced, and then find a definition for it. 	 * If the latter can not be found, then terminate the program. 	 */
comment|/* 	 * N.B. Different error handling possibilities are a CASE 	 * opportunity: namely, incremental program construction and 	 * calls to debuggers. 	 */
name|rp
operator|=
operator|&
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_rp
index|[
name|relocindex
index|]
expr_stmt|;
name|sp
operator|=
operator|&
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_symtab
index|[
name|rp
operator|->
name|r_symbolnum
index|]
expr_stmt|;
name|symbol
operator|=
operator|&
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_symstr
index|[
name|sp
operator|->
name|n_un
operator|.
name|n_strx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|lookup
argument_list|(
name|symbol
argument_list|,
operator|&
name|llmp
argument_list|,
name|lmp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ld.so: call to undefined procedure %s from 0x%x\n"
argument_list|,
name|symbol
argument_list|,
name|pc
argument_list|)
expr_stmt|;
comment|/* 	 * Rebuild the relocation entry to direct future calls directly 	 * to the target procedure.  Return the address to which this call 	 * should ultimately return. 	 */
comment|/* 	 * N.B. Much opportunity here for: 	 *	- call graph profiling. 	 *	- alternative procedure call implementation (RPC). 	 *	- value-added interposing. 	 */
name|address
operator|=
operator|(
name|int
operator|)
operator|&
name|LM2LP
argument_list|(
name|llmp
argument_list|)
operator|->
name|lp_symbol_base
index|[
name|sp
operator|->
name|n_value
index|]
expr_stmt|;
name|stuffit
argument_list|(
operator|(
name|long
operator|*
operator|)
operator|&
name|lmp
operator|->
name|lm_addr
index|[
name|rp
operator|->
name|r_address
index|]
argument_list|,
name|address
argument_list|)
expr_stmt|;
return|return
operator|(
name|address
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rebuild a _PLT_ entry after initial binding.    */
end_comment

begin_macro
name|stuffit
argument_list|(
argument|where
argument_list|,
argument|what
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|what
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|long
modifier|*
name|i
init|=
name|where
decl_stmt|;
switch|switch
condition|(
name|version_no
condition|)
block|{
case|case
literal|3
case|:
operator|*
name|i
operator|=
name|SETHI
expr_stmt|;
operator|*
name|i
operator|=
operator|(
operator|*
name|i
operator|&
operator|~
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
operator||
operator|(
operator|(
name|what
operator|>>
operator|(
literal|32
operator|-
literal|22
operator|)
operator|)
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
operator|*
name|i
operator|=
name|JMPI
expr_stmt|;
operator|*
name|i
operator|=
operator|(
operator|*
name|i
operator|&
operator|~
name|MASK
argument_list|(
literal|10
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|10
argument_list|)
operator|)
expr_stmt|;
break|break;
default|default:
operator|*
name|i
operator|=
name|SETHI
expr_stmt|;
operator|*
name|i
operator|=
operator|(
operator|*
name|i
operator|&
operator|~
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
operator||
operator|(
operator|(
name|what
operator|>>
operator|(
literal|32
operator|-
literal|22
operator|)
operator|)
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
operator|*
name|i
operator|=
name|ORIT
expr_stmt|;
operator|*
name|i
operator|=
operator|(
operator|*
name|i
operator|&
operator|~
name|MASK
argument_list|(
literal|10
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|10
argument_list|)
operator|)
expr_stmt|;
operator|*
name|i
operator|++
expr_stmt|;
operator|*
name|i
operator|++
operator|=
name|JMPI
expr_stmt|;
operator|*
name|i
operator|=
name|NOP
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
name|char
modifier|*
name|i
init|=
operator|(
name|char
operator|*
operator|)
name|where
decl_stmt|;
operator|*
name|where
operator|=
name|what
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|i
operator|-
literal|2
operator|)
operator|=
name|JUMP
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Utility function to round "v" to the next "r" boundary.  */
end_comment

begin_macro
name|round
argument_list|(
argument|v
argument_list|,
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|v
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|r
operator|--
expr_stmt|;
name|v
operator|+=
name|r
expr_stmt|;
name|v
operator|&=
operator|~
operator|(
name|long
operator|)
name|r
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Make sure we have a source of heap.  */
end_comment

begin_expr_stmt
specifier|static
name|get_zero_object
argument_list|()
block|{
name|int
name|zfd
block|;
if|if
condition|(
name|devzero_fd
operator|==
operator|-
literal|1
condition|)
name|devzero_fd
operator|=
name|open
argument_list|(
literal|"/dev/zero"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|devzero_fd
operator|!=
operator|-
literal|1
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Local heap allocator.  Very simple, does not support storage freeing.  * XXX Should be upgraded to support multiple heaps.  Should also handle  * /dev/zero allocation errors.  */
end_comment

begin_macro
unit|caddr_t
name|rtmalloc
argument_list|(
argument|nb
argument_list|)
end_macro

begin_decl_stmt
name|int
name|nb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|caddr_t
name|cp
init|=
literal|0
decl_stmt|;
specifier|static
name|caddr_t
name|sp
init|=
literal|0
decl_stmt|;
name|caddr_t
name|tp
decl_stmt|;
name|struct
name|rlimit
name|rlimit
decl_stmt|;
name|int
name|sl
decl_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlimit
argument_list|)
expr_stmt|;
name|sl
operator|=
name|rlimit
operator|.
name|rlim_cur
operator|-
operator|(
name|rlimit
operator|.
name|rlim_cur
operator|%
name|PAGSIZ
operator|)
expr_stmt|;
name|sp
operator|=
name|cp
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|top_of_stack
operator|-
name|sl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|+
name|round
argument_list|(
name|nb
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
operator|>=
name|sp
condition|)
block|{
if|if
condition|(
operator|!
name|get_zero_object
argument_list|()
condition|)
name|map_error
argument_list|(
literal|"map heap"
argument_list|,
literal|"/dev/zero"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|mmap
argument_list|(
name|sp
argument_list|,
name|round
argument_list|(
name|nb
argument_list|,
name|PAGSIZ
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_FIXED
operator||
name|MAP_PRIVATE
argument_list|,
name|devzero_fd
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
name|map_error
argument_list|(
literal|"map heap"
argument_list|,
literal|"/dev/zero"
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|round
argument_list|(
name|nb
argument_list|,
name|PAGSIZ
argument_list|)
expr_stmt|;
block|}
name|tp
operator|=
name|cp
expr_stmt|;
name|cp
operator|+=
name|round
argument_list|(
name|nb
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Run-time link editor private getenv system call.  Scans for our   * special strings, and also calculates top of stack.  */
end_comment

begin_decl_stmt
name|char
name|ld_library_path
index|[]
init|=
literal|"LD_LIBRARY_PATH"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ld_trace
index|[]
init|=
literal|"LD_TRACE_LOADED_OBJECTS"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ld_profile
index|[]
init|=
literal|"LD_PROFILE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ld_preload
index|[]
init|=
literal|"LD_PRELOAD"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ld_symbols_public
index|[]
init|=
literal|"LD_SYMBOLS_PUBLIC"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|rtgetenv
argument_list|()
block|{
specifier|register
name|char
operator|*
operator|*
name|p
operator|=
name|environ
block|;
specifier|register
name|char
operator|*
name|v
block|;
comment|/* 	 * Guard against no environment.  This seems practically impossible, 	 * as the variable "environ" is initialized in crt0 with an address 	 * on the stack.  However, if it actually does happen, we need to 	 * fake out the top of user_stack. 	 */
if|if
condition|(
operator|(
name|p
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
name|NULL
operator|)
condition|)
block|{
name|top_of_stack
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|&
name|p
operator|+
name|PAGSIZ
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|PAGSIZ
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_expr_stmt

begin_comment
comment|/* 	 * Scan for LD_ environment variables that affect our behavior. 	 */
end_comment

begin_while
while|while
condition|(
name|v
operator|=
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|v
argument_list|,
literal|"LD_"
argument_list|,
literal|3
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|v
argument_list|,
name|ld_library_path
argument_list|,
sizeof|sizeof
argument_list|(
name|ld_library_path
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
name|library_path
operator|=
name|v
operator|+
sizeof|sizeof
argument_list|(
name|ld_library_path
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|v
argument_list|,
name|ld_preload
argument_list|,
sizeof|sizeof
argument_list|(
name|ld_preload
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
name|preload
operator|=
name|v
operator|+
sizeof|sizeof
argument_list|(
name|ld_preload
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|v
argument_list|,
name|ld_trace
argument_list|,
sizeof|sizeof
argument_list|(
name|ld_trace
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
name|tracing
operator|=
name|v
operator|+
sizeof|sizeof
argument_list|(
name|ld_trace
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|v
argument_list|,
name|ld_profile
argument_list|,
sizeof|sizeof
argument_list|(
name|ld_profile
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
name|profile
operator|=
name|v
operator|+
sizeof|sizeof
argument_list|(
name|ld_profile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|v
argument_list|,
name|ld_symbols_public
argument_list|,
sizeof|sizeof
argument_list|(
name|ld_symbols_public
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
name|symbols_public
operator|=
name|v
operator|+
sizeof|sizeof
argument_list|(
name|ld_symbols_public
argument_list|)
expr_stmt|;
block|}
end_while

begin_comment
comment|/* 	 * Calculate the top of stack -- avoid dependence upon USRSTACK, 	 * but add dependence upon knowing that the stack ends with environment 	 * strings.  Note: program bootstraps already depend upon this 	 * knowledge, and since we're sort of kind of part of the bootstrap 	 * this isn't too much of a hack. 	 */
end_comment

begin_for
for|for
control|(
name|v
operator|=
operator|*
operator|(
name|p
operator|-
literal|2
operator|)
init|;
operator|*
name|v
condition|;
name|v
operator|++
control|)
empty_stmt|;
end_for

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|top_of_stack
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|v
operator|+
name|PAGSIZ
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|PAGSIZ
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * Simple programmatic interface to the dynamic linker.  *  * These functions constitute a simple interface that permits programs to  * add shared objects, lookup symbols in such objects, and remove those  * objects -- all under program control.  Such objects have special  * symbol lookup interpretations, implemented by interpreter functions  * such as the one immediately following.  */
end_comment

begin_function
unit|struct
name|nlist
modifier|*
name|dl_interpreter
parameter_list|(
name|lmp
parameter_list|,
name|s
parameter_list|,
name|clmp
parameter_list|)
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|link_map
modifier|*
name|clmp
decl_stmt|;
block|{
if|if
condition|(
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_dlh
operator|!=
name|LM2LP
argument_list|(
name|clmp
argument_list|)
operator|->
name|lp_dlh
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|findsb
argument_list|(
name|lmp
argument_list|,
name|s
argument_list|,
name|clmp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the shared object in "path" to the program.  Reference count the  * objects so that multiple calls actually load only one instance of  * the object -- also account for objects that might have been automatically  * loaded at program start-up.  */
end_comment

begin_function
name|struct
name|dl_object
modifier|*
name|dlopen
parameter_list|(
name|path
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
comment|/* path name of object */
name|int
name|mode
decl_stmt|;
comment|/* open mode */
block|{
name|struct
name|dl_object
modifier|*
name|dlp
decl_stmt|;
comment|/* temporary return */
comment|/* 	 * Jacket function for real worker routine.  Establishes and 	 * cleans up general environment. 	 */
name|dlp
operator|=
name|dlopen_worker
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|devzero_fd
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|devzero_fd
argument_list|)
expr_stmt|;
name|devzero_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|dlp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dl_object
modifier|*
name|dlopen_worker
parameter_list|(
name|path
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
comment|/* path name of object */
name|int
name|mode
decl_stmt|;
comment|/* open mode */
block|{
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
comment|/* link map temporary */
name|struct
name|link_map
modifier|*
name|nlmp
decl_stmt|;
comment|/* newly created link maps */
name|struct
name|dl_object
modifier|*
name|dlp
decl_stmt|;
comment|/* dl object temporary */
name|struct
name|dl_object
modifier|*
name|wdlp
decl_stmt|;
comment|/* working dl temporary */
name|struct
name|dl_object
modifier|*
modifier|*
name|dlpp
decl_stmt|;
comment|/* insertion pointer for dependents */
name|struct
name|link_object
modifier|*
name|lop
decl_stmt|;
comment|/* dependent link objects */
name|char
modifier|*
name|save_error
decl_stmt|;
comment|/* error saving */
comment|/* 	 * Initialize error state. 	 */
name|dl_error
operator|=
name|DLE_none
expr_stmt|;
comment|/* 	 * Currently, no modes supported. 	 */
if|if
condition|(
name|mode
operator|!=
literal|1
condition|)
block|{
name|dl_error
operator|=
name|DLE_mode_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If a null path, then we're operating on "main." 	 */
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
literal|"main_$main_"
expr_stmt|;
comment|/* 	 * Scan link map list looking for this object.  If found, 	 * then get a dl_object descriptor for it (creating the 	 * descriptor if necessary.)  Note that the situation in 	 * which we find an object with a descriptor, but where 	 * that object is either not on a dl "chain" (because 	 * it's part of "main") or is not the head of that chain, 	 * then we have a conflict.  The conflict is the result 	 * of having two "libraries" be depended upon by two different 	 * shared objects, leading to confusion over how the resolution 	 * of symbols should be handled.  We simply prohibit this. 	 */
for|for
control|(
name|lmp
operator|=
name|hlmp
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|path
argument_list|,
name|lmp
operator|->
name|lm_name
argument_list|)
condition|)
block|{
name|dlp
operator|=
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_dlp
expr_stmt|;
if|if
condition|(
name|dlp
condition|)
block|{
if|if
condition|(
operator|(
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_dlh
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_dlh
operator|!=
name|dlp
operator|)
condition|)
block|{
name|dl_error
operator|=
name|DLE_conflict
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dlp
operator|->
name|dl_refcnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_refcnt
operator|++
expr_stmt|;
name|dlp
operator|=
name|new_dlp
argument_list|(
name|lmp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dlp
operator|)
return|;
block|}
comment|/* 	 * No link map for it.  Make one, and then make a 	 * dl_object descriptor for it.  Add it to the 	 * address space, set it as the head of a chain. 	 */
if|if
condition|(
operator|!
operator|(
name|lmp
operator|=
name|mapit
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dl_interpreter
argument_list|)
operator|)
condition|)
block|{
name|dl_error
operator|=
name|DLE_can_not_open
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dlp
operator|=
name|new_dlp
argument_list|(
name|lmp
argument_list|)
expr_stmt|;
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_dlh
operator|=
name|dlp
expr_stmt|;
name|dlpp
operator|=
operator|&
name|dlp
operator|->
name|dl_dep
expr_stmt|;
comment|/* 	 * Now, see if there are any dependent objects.  For each, 	 * load it up, get a dlp, etc. and add it to the list of 	 * dependencies. 	 */
for|for
control|(
name|wdlp
operator|=
name|dlp
init|;
name|wdlp
condition|;
name|wdlp
operator|=
name|wdlp
operator|->
name|dl_dep
control|)
block|{
name|lmp
operator|=
name|wdlp
operator|->
name|dl_lmp
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|lm_ld
condition|)
block|{
for|for
control|(
name|lop
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|&
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
index|[
name|lmp
operator|->
name|lm_ld
operator|->
name|v2
operator|->
name|ld_need
index|]
init|;
name|lop
operator|!=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|&
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
index|[
literal|0
index|]
condition|;
name|lop
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|&
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
index|[
name|lop
operator|->
name|lo_next
index|]
control|)
if|if
condition|(
operator|(
name|nlmp
operator|=
name|have_we_got_it
argument_list|(
name|lop
argument_list|,
name|TEXTBASE
argument_list|(
name|lmp
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nlmp
operator|=
name|map_so
argument_list|(
name|lmp
argument_list|,
name|lop
argument_list|)
condition|)
block|{
operator|*
name|dlpp
operator|=
name|new_dlp
argument_list|(
name|nlmp
argument_list|)
expr_stmt|;
name|LM2LP
argument_list|(
name|nlmp
argument_list|)
operator|->
name|lp_interp
operator|=
name|dl_interpreter
expr_stmt|;
name|LM2LP
argument_list|(
name|nlmp
argument_list|)
operator|->
name|lp_dlh
operator|=
name|dlp
expr_stmt|;
name|dlpp
operator|=
operator|&
operator|(
operator|*
name|dlpp
operator|)
operator|->
name|dl_dep
expr_stmt|;
block|}
else|else
block|{
name|dl_error
operator|=
name|DLE_can_not_open
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_dlh
condition|)
block|{
name|dl_error
operator|=
name|DLE_conflict
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|dl_error
operator|!=
name|DLE_none
condition|)
break|break;
block|}
comment|/* 	 * If an error occurred, we're hosed.  Close off everything we 	 * opened including ourselves. 	 */
if|if
condition|(
name|dl_error
operator|!=
name|DLE_none
condition|)
block|{
name|save_error
operator|=
name|dl_error
expr_stmt|;
operator|(
name|void
operator|)
name|dlclose
argument_list|(
name|dlp
argument_list|)
expr_stmt|;
name|dl_error
operator|=
name|save_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Now, walk the list and relocate everything. 	 */
for|for
control|(
name|wdlp
operator|=
name|dlp
init|;
name|wdlp
condition|;
name|wdlp
operator|=
name|wdlp
operator|->
name|dl_dep
control|)
block|{
name|relocate
argument_list|(
name|wdlp
operator|->
name|dl_lmp
argument_list|,
name|wdlp
operator|->
name|dl_lmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdlp
operator|->
name|dl_lmp
operator|->
name|lm_rwt
condition|)
block|{
operator|(
name|void
operator|)
name|mprotect
argument_list|(
name|TEXTBASE
argument_list|(
name|wdlp
operator|->
name|dl_lmp
argument_list|)
argument_list|,
name|PROUND
argument_list|(
name|wdlp
operator|->
name|dl_lmp
operator|->
name|lm_ld
operator|->
name|v2
operator|->
name|ld_text
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_EXEC
argument_list|)
expr_stmt|;
name|wdlp
operator|->
name|dl_lmp
operator|->
name|lm_rwt
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|dlp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert dlsym responses to appropriate address based on type of  * symbol.  Note that in the case of dlsym references to an unallocated  * common, we have to "simulate" a reference to it in order to stimulate  * the allocation process.  */
end_comment

begin_function
specifier|static
name|caddr_t
name|dl_absolute
parameter_list|(
name|sp
parameter_list|,
name|lmp
parameter_list|)
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
comment|/* symbol table entry of symbol */
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
comment|/* link map that defined it */
block|{
if|if
condition|(
name|sp
operator|->
name|n_type
operator|==
name|N_UNDF
operator|+
name|N_EXT
operator|&&
name|sp
operator|->
name|n_value
operator|!=
literal|0
condition|)
block|{
name|sp
operator|=
name|lookup
argument_list|(
operator|&
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_symstr
index|[
name|sp
operator|->
name|n_un
operator|.
name|n_strx
index|]
argument_list|,
operator|&
name|lmp
argument_list|,
name|lmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sp
operator|->
name|n_type
operator|==
name|N_COMM
operator|||
name|sp
operator|->
name|n_type
operator|==
name|N_ABS
operator|+
name|N_EXT
condition|)
return|return
operator|(
operator|(
name|caddr_t
operator|)
name|sp
operator|->
name|n_value
operator|)
return|;
else|else
return|return
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|sp
operator|->
name|n_value
operator|+
name|lmp
operator|->
name|lm_addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_DLSYM_SYMBOL
value|1024
end_define

begin_comment
comment|/* maximum size of symbol we match */
end_comment

begin_function
name|caddr_t
name|dlsym
parameter_list|(
name|dlp
parameter_list|,
name|symbol
parameter_list|)
name|struct
name|dl_object
modifier|*
name|dlp
decl_stmt|;
name|char
modifier|*
name|symbol
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* temporary */
name|caddr_t
name|pc
decl_stmt|;
comment|/* caller's pc */
name|struct
name|dl_object
modifier|*
name|wdlp
decl_stmt|;
comment|/* working dlp */
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
comment|/* link map of symbol table */
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
comment|/* symbol table entry */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* temporary */
name|char
name|buffer
index|[
name|MAX_DLSYM_SYMBOL
operator|+
literal|2
index|]
decl_stmt|;
comment|/* "_" assembly, including null pad */
comment|/* 	 * Initialize error. 	 */
name|dl_error
operator|=
name|DLE_none
expr_stmt|;
comment|/* 	 * Check dl object handle -- if valid, then retrieve 	 * symbol from appropriate object.  Note that dlp of 	 * NULL is valid, and refers to the "caller" of dlsym. 	 */
if|if
condition|(
name|dlp
condition|)
block|{
if|if
condition|(
operator|!
name|valid_dl_object
argument_list|(
name|dlp
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|notdef
name|pc
operator|=
name|caller
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|lmp
operator|=
name|pc_to_lmp
argument_list|(
name|pc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dl_error
operator|=
name|DLE_bad_handle
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|#
directive|else
else|notdef
name|dl_error
operator|=
name|DLE_bad_handle
expr_stmt|;
comment|/* XXX */
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
endif|notdef
block|}
for|for
control|(
name|wdlp
operator|=
name|dlp
init|;
name|wdlp
condition|;
name|wdlp
operator|=
name|wdlp
operator|->
name|dl_dep
control|)
if|if
condition|(
name|sp
operator|=
name|findsb
argument_list|(
name|wdlp
operator|->
name|dl_lmp
argument_list|,
name|symbol
argument_list|,
name|wdlp
operator|->
name|dl_lmp
argument_list|)
condition|)
return|return
operator|(
name|dl_absolute
argument_list|(
name|sp
argument_list|,
name|wdlp
operator|->
name|dl_lmp
argument_list|)
operator|)
return|;
comment|/* 	 * Symbol not found as supplied.  However, most of our symbols 	 * will be in the "C" name space, where the implementation prepends 	 * a "_" to the symbol as it emits it.  Therefore, attempt to find 	 * the symbol with the "_" prepend. 	 */
name|buffer
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|cp
operator|=
operator|&
name|buffer
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|MAX_DLSYM_SYMBOL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|++
operator|=
operator|*
name|symbol
operator|++
operator|)
operator|==
literal|'\0'
condition|)
block|{
for|for
control|(
name|wdlp
operator|=
name|dlp
init|;
name|wdlp
condition|;
name|wdlp
operator|=
name|wdlp
operator|->
name|dl_dep
control|)
if|if
condition|(
name|sp
operator|=
name|findsb
argument_list|(
name|wdlp
operator|->
name|dl_lmp
argument_list|,
name|buffer
argument_list|,
name|wdlp
operator|->
name|dl_lmp
argument_list|)
condition|)
return|return
operator|(
name|dl_absolute
argument_list|(
name|sp
argument_list|,
name|wdlp
operator|->
name|dl_lmp
argument_list|)
operator|)
return|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|dl_error
operator|=
name|DLE_undefined
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Functions to retrieve a symbol from a dlopen'ed object.  */
end_comment

begin_function
specifier|static
name|struct
name|link_map
modifier|*
name|pc_to_lmp
parameter_list|(
name|pc
parameter_list|)
name|caddr_t
name|pc
decl_stmt|;
comment|/* pc needing an lmp */
block|{
name|int
name|size
decl_stmt|;
comment|/* size of program */
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
comment|/* temporary */
name|size
operator|=
name|max
argument_list|(
name|SIZE
argument_list|(
operator|*
operator|(
expr|struct
name|exec
operator|*
operator|)
name|lmp
operator|->
name|lm_addr
argument_list|)
argument_list|,
name|N_SYMOFF
argument_list|(
operator|(
operator|*
operator|(
expr|struct
name|exec
operator|*
operator|)
name|lmp
operator|->
name|lm_addr
operator|)
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|lmp
operator|=
name|hlmp
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
if|if
condition|(
name|pc
operator|>
name|lmp
operator|->
name|lm_addr
operator|&&
name|pc
operator|<
operator|(
name|lmp
operator|->
name|lm_addr
operator|+
name|size
operator|)
condition|)
break|break;
return|return
operator|(
name|lmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a dynamically loaded object from the program.  If it is  * the last reference, then *really* remove the name -- and if the  * name is the last reference to the object, then *really* remove  * the object.  */
end_comment

begin_function
name|int
name|dlclose
parameter_list|(
name|dlp
parameter_list|)
name|struct
name|dl_object
modifier|*
name|dlp
decl_stmt|;
block|{
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
comment|/* temporary */
name|struct
name|dl_object
modifier|*
name|wdlp
decl_stmt|;
comment|/* temporary */
name|struct
name|dl_object
modifier|*
name|ndlp
decl_stmt|;
comment|/* where we're going next */
comment|/* 	 * Clear error. 	 */
name|dl_error
operator|=
name|DLE_none
expr_stmt|;
comment|/* 	 * Validity check object handle. 	 */
if|if
condition|(
operator|!
name|valid_dl_object
argument_list|(
name|dlp
argument_list|)
condition|)
block|{
name|dl_error
operator|=
name|DLE_bad_handle
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Valid object: decrement reference count.  If we've still 	 * got any references then just leave. 	 */
if|if
condition|(
operator|--
name|dlp
operator|->
name|dl_refcnt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Reference count went to zero.  By definition, that means 	 * that the reference count on everything we loaded also 	 * went to zero.  So free them all as well. 	 */
for|for
control|(
name|wdlp
operator|=
name|dlp
init|;
name|wdlp
condition|;
name|wdlp
operator|=
name|ndlp
control|)
block|{
name|lmp
operator|=
name|wdlp
operator|->
name|dl_lmp
expr_stmt|;
name|ndlp
operator|=
name|wdlp
operator|->
name|dl_dep
expr_stmt|;
name|wdlp
operator|->
name|dl_refcnt
operator|=
literal|0
expr_stmt|;
name|free_dlp
argument_list|(
name|wdlp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_refcnt
condition|)
continue|continue;
name|free_lmp
argument_list|(
name|lmp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dlerror
parameter_list|()
block|{
name|char
modifier|*
name|error
init|=
name|dl_error
decl_stmt|;
if|if
condition|(
name|dl_error
operator|==
name|DLE_none
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dl_error
operator|=
name|DLE_none
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * dl_object allocation and management.  "free'ed" dl_objects are not  * returned to the "heap" (because we don't have a general heap manager  * at present.)  So, they are kept on a list in case we need to use them  * and requests for new dl_object's are allocated from this list rather  * than from the heap.  */
end_comment

begin_function
specifier|static
name|struct
name|dl_object
modifier|*
name|new_dlp
parameter_list|(
name|lmp
parameter_list|)
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
block|{
name|struct
name|dl_object
modifier|*
name|dlp
decl_stmt|;
if|if
condition|(
name|dlp
operator|=
name|fdlp
condition|)
name|fdlp
operator|=
name|dlp
operator|->
name|dl_next
expr_stmt|;
else|else
name|dlp
operator|=
operator|(
expr|struct
name|dl_object
operator|*
operator|)
name|rtmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dl_object
argument_list|)
argument_list|)
expr_stmt|;
name|dlp
operator|->
name|dl_magic
operator|=
name|DL_MAGIC
expr_stmt|;
name|dlp
operator|->
name|dl_cigam
operator|=
name|DL_CIGAM
expr_stmt|;
name|LM2LP
argument_list|(
name|lmp
argument_list|)
operator|->
name|lp_dlp
operator|=
name|dlp
expr_stmt|;
name|dlp
operator|->
name|dl_lmp
operator|=
name|lmp
expr_stmt|;
name|dlp
operator|->
name|dl_refcnt
operator|++
expr_stmt|;
name|dlp
operator|->
name|dl_next
operator|=
name|NULL
expr_stmt|;
name|dlp
operator|->
name|dl_dep
operator|=
name|NULL
expr_stmt|;
operator|*
name|pdlpp
operator|=
name|dlp
expr_stmt|;
name|pdlpp
operator|=
operator|&
name|dlp
operator|->
name|dl_next
expr_stmt|;
return|return
operator|(
name|dlp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_dlp
parameter_list|(
name|dlp
parameter_list|)
name|struct
name|dl_object
modifier|*
name|dlp
decl_stmt|;
block|{
name|struct
name|dl_object
modifier|*
name|tdlp
decl_stmt|;
comment|/* temporary */
name|struct
name|dl_object
modifier|*
modifier|*
name|pdlp
decl_stmt|;
comment|/* previous pointer */
name|tdlp
operator|=
name|hdlp
operator|,
name|pdlp
operator|=
operator|&
name|hdlp
expr_stmt|;
while|while
condition|(
name|tdlp
condition|)
block|{
if|if
condition|(
name|tdlp
operator|==
name|dlp
condition|)
block|{
name|LM2LP
argument_list|(
name|dlp
operator|->
name|dl_lmp
argument_list|)
operator|->
name|lp_dlp
operator|=
name|NULL
expr_stmt|;
name|LM2LP
argument_list|(
name|dlp
operator|->
name|dl_lmp
argument_list|)
operator|->
name|lp_dlh
operator|=
name|NULL
expr_stmt|;
name|dlp
operator|->
name|dl_magic
operator|=
literal|0
expr_stmt|;
name|dlp
operator|->
name|dl_cigam
operator|=
literal|0
expr_stmt|;
operator|*
name|pdlp
operator|=
name|dlp
operator|->
name|dl_next
expr_stmt|;
if|if
condition|(
name|pdlpp
operator|==
operator|&
name|dlp
operator|->
name|dl_next
condition|)
name|pdlpp
operator|=
name|pdlp
expr_stmt|;
name|dlp
operator|->
name|dl_next
operator|=
name|fdlp
expr_stmt|;
name|fdlp
operator|=
name|dlp
expr_stmt|;
return|return;
block|}
name|pdlp
operator|=
operator|&
name|tdlp
operator|->
name|dl_next
expr_stmt|;
name|tdlp
operator|=
name|tdlp
operator|->
name|dl_next
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"ld.so: mangled dl object list.\n"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * Sanity check a program-provided dl_object handle.  */
end_comment

begin_expr_stmt
specifier|static
name|valid_dl_object
argument_list|(
argument|dlp
argument_list|)
expr|struct
name|dl_object
operator|*
name|dlp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|dlp
condition|)
if|if
condition|(
name|dlp
operator|->
name|dl_magic
operator|==
name|DL_MAGIC
operator|&&
name|dlp
operator|->
name|dl_cigam
operator|==
name|DL_CIGAM
operator|&&
name|dlp
operator|->
name|dl_refcnt
operator|!=
literal|0
operator|&&
name|LM2LP
argument_list|(
name|dlp
operator|->
name|dl_lmp
argument_list|)
operator|->
name|lp_dlh
operator|==
name|dlp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|dl_error
operator|=
name|DLE_bad_handle
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|WHOAMI
end_ifdef

begin_comment
comment|/*  * This routine is only available in-house.  It returns the   * program name of the running process.  */
end_comment

begin_function
name|char
modifier|*
name|whoami
parameter_list|()
block|{
return|return
operator|(
name|progname
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

