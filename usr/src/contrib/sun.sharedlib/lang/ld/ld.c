begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This source code is a product of Sun Microsystems, Inc. and is provided  * for unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify this source code without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *  * THIS PROGRAM CONTAINS SOURCE CODE COPYRIGHTED BY SUN MICROSYSTEMS, INC.  * SUN MICROSYSTEMS, INC., MAKES NO REPRESENTATIONS ABOUT THE SUITABLITY  * OF SUCH SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT  * EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  SUN MICROSYSTEMS, INC. DISCLAIMS  * ALL WARRANTIES WITH REGARD TO SUCH SOURCE CODE, INCLUDING ALL IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN  * NO EVENT SHALL SUN MICROSYSTEMS, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT,  * INCIDENTAL, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING  * FROM USE OF SUCH SOURCE CODE, REGARDLESS OF THE THEORY OF LIABILITY.  *   * This source code is provided with no support and without any obligation on  * the part of Sun Microsystems, Inc. to assist in its use, correction,   * modification or enhancement.  *  * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY THIS  * SOURCE CODE OR ANY PART THEREOF.  *  * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California 94043  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  * Copyright (c) 1990, 1991 by Sun Microsystems, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n\  Copyright (c) 1990, 1991 by Sun Microsystems, Inc.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ld.c 1.135 90/12/18"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from UCB 5.4 85/11/26 */
end_comment

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * ld - string table version  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<ranlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<link.h>
end_include

begin_include
include|#
directive|include
file|"dynamic.h"
end_include

begin_include
include|#
directive|include
file|"reloc_info.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SUNPRO
end_ifdef

begin_include
include|#
directive|include
file|<vroot.h>
end_include

begin_include
include|#
directive|include
file|<report.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|nsymwrite
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|errmsg
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Basic strategy:  *  * The loader takes a number of files and libraries as arguments.  * A first pass examines each file in turn.  Normal files are  * unconditionally loaded, and the (external) symbols they define and require  * are noted in the symbol table.   Libraries are searched, and the  * library members which define needed symbols are remembered  * in a special data structure so they can be selected on the second  * pass.  Symbols defined and required by library members are also  * recorded.  *  * After the first pass, the loader knows the size of the basic text  * data, and bss segments from the sum of the sizes of the modules which  * were required.  It has computed, for each ``common'' symbol, the  * maximum size of any reference to it, and these symbols are then assigned  * storage locations after their sizes are appropriately rounded.  * The loader now knows all sizes for the eventual output file, and  * can determine the final locations of external symbols before it  * begins a second pass.  *  * On the second pass each normal file and required library member  * is processed again.  The symbol table for each such file is  * reread and relevant parts of it are placed in the output.  The offsets  * in the local symbol table for externally defined symbols are recorded  * since relocation information refers to symbols in this way.  * Armed with all necessary information, the text and data segments  * are relocated and the result is placed in the output file, which  * is pasted together, ``in place'', by writing to it in several  * different places concurrently.  */
end_comment

begin_comment
comment|/*  * Internal data structures  *  * All internal data structures are segmented and dynamically extended.  * The basic structures hold 1103 (NSYM) symbols, ~~200 (NROUT)  * referenced library members, and 100 (NSYMPR) private (local) symbols  * per object module.  For large programs and/or modules, these structures  * expand to be up to 40 (NSEG) times as large as this as necessary.  */
end_comment

begin_define
define|#
directive|define
name|NSEG
value|160
end_define

begin_comment
comment|/* Number of segments, each data structure */
end_comment

begin_define
define|#
directive|define
name|NSYM
value|1103
end_define

begin_comment
comment|/* Number of symbols per segment */
end_comment

begin_define
define|#
directive|define
name|NROUT
value|250
end_define

begin_comment
comment|/* Number of library references per segment */
end_comment

begin_define
define|#
directive|define
name|NSYMPR
value|200
end_define

begin_comment
comment|/* Number of private symbols per segment */
end_comment

begin_comment
comment|/*  * Structure describing each symbol table segment.  * Each segment has its own hash table.  We record the first  * address in and first address beyond both the symbol and hash  * tables, for use in the routine symx and the lookup routine respectively.  * The symfree routine also understands this structure well as it used  * to back out symbols from modules we decide that we don't need in pass 1.  *  * cs points to the current symbol table segment;  * cs->sy_first[cs->sy_used] is the next symbol slot to be allocated,  * (unless cs->sy_used == NSYM in which case we will allocate another  * symbol table segment first.)  */
end_comment

begin_struct
struct|struct
name|symseg
block|{
name|struct
name|nlist
modifier|*
name|sy_first
decl_stmt|;
comment|/* base of this alloc'ed segment */
name|struct
name|nlist
modifier|*
name|sy_last
decl_stmt|;
comment|/* end of this segment, for n_strx */
name|int
name|sy_used
decl_stmt|;
comment|/* symbols used in this seg */
name|struct
name|nlist
modifier|*
modifier|*
name|sy_hfirst
decl_stmt|;
comment|/* base of hash table, this seg */
name|struct
name|nlist
modifier|*
modifier|*
name|sy_hlast
decl_stmt|;
comment|/* end of hash table, this seg */
block|}
name|symseg
index|[
name|NSEG
index|]
struct|,
name|nsymseg
index|[
name|NSEG
index|]
struct|;
end_struct

begin_struct
struct|struct
name|syminfo
block|{
name|struct
name|symseg
modifier|*
name|fs
decl_stmt|;
comment|/* address of first segment */
name|struct
name|symseg
modifier|*
name|cs
decl_stmt|;
comment|/* address of current segment */
name|struct
name|nlist
modifier|*
name|ls
decl_stmt|;
comment|/* last symbol entered */
name|struct
name|nlist
modifier|*
name|ns
decl_stmt|;
comment|/* next symbol entered */
block|}
name|ldsym
init|=
block|{
name|symseg
block|,
name|symseg
block|,
literal|0
block|,
literal|0
block|}
struct|,
comment|/* symbol table for a.out */
name|shsym
init|=
block|{
name|nsymseg
block|,
name|nsymseg
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_comment
comment|/* symbols from dynamic objects */
end_comment

begin_comment
comment|/*  * The lookup routine uses quadratic rehash.  Since a quadratic rehash  * only probes 1/2 of the buckets in the table, and since the hash  * table is segmented the same way the symbol table is, we make the  * hash table have twice as many buckets as there are symbol table slots  * in the segment.  This guarantees that the quadratic rehash will never  * fail to find an empty bucket if the segment is not full and the  * symbol is not there.  */
end_comment

begin_define
define|#
directive|define
name|HSIZE
value|(NSYM*2)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|n_hash
end_ifndef

begin_define
define|#
directive|define
name|n_hash
value|n_desc
end_define

begin_endif
endif|#
directive|endif
endif|n_hash
end_endif

begin_comment
comment|/*  * Xsym converts symbol table indices (ala x) into symbol table pointers.  * Symx (harder, but never used in loops) inverts pointers into the symbol  * table into indices using the symseg[] structure.  */
end_comment

begin_define
define|#
directive|define
name|xsym
parameter_list|(
name|s
parameter_list|,
name|x
parameter_list|)
value|(s[(x)/NSYM].sy_first+((x)%NSYM))
end_define

begin_comment
comment|/* symx() is a function, defined below */
end_comment

begin_decl_stmt
name|struct
name|nlist
name|cursym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current symbol */
end_comment

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|addsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first sym defined during incr load */
end_comment

begin_decl_stmt
name|int
name|nsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pass2: number of local symbols in a.out */
end_comment

begin_comment
comment|/* nsym + symx(s, ldsym.ns) is the symbol table size during pass2 */
end_comment

begin_decl_stmt
name|struct
name|nlist
modifier|*
modifier|*
name|lookup
argument_list|()
decl_stmt|,
modifier|*
modifier|*
name|slookup
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|p_etext
decl_stmt|,
modifier|*
name|p_edata
decl_stmt|,
modifier|*
name|p_end
decl_stmt|,
modifier|*
name|entrypt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Definitions of segmentation for library member table.  * For each library we encounter on pass 1 we record pointers to all  * members which we will load on pass 2.  These are recorded as offsets  * into the archive in the library member table.  Libraries are  * separated in the table by the special offset value -1.  */
end_comment

begin_decl_stmt
name|off_t
name|li_init
index|[
name|NROUT
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|libseg
block|{
name|off_t
modifier|*
name|li_first
decl_stmt|;
name|int
name|li_used
decl_stmt|;
name|int
name|li_used2
decl_stmt|;
block|}
name|libseg
index|[
name|NSEG
index|]
init|=
block|{
name|li_init
block|,
literal|0
block|,
literal|0
block|, }
struct|,
modifier|*
name|clibseg
init|=
name|libseg
struct|;
end_struct

begin_comment
comment|/*  * In processing each module on pass 2 we must relocate references  * relative to external symbols.  These references are recorded  * in the relocation information as relative to local symbol numbers  * assigned to the external symbols when the module was created.  * Thus before relocating the module in pass 2 we create a table  * which maps these internal numbers to symbol table entries.  * A hash table is constructed, based on the local symbol table indices,  * for quick lookup of these symbols.  */
end_comment

begin_struct
struct|struct
name|local
block|{
name|int
name|l_index
decl_stmt|;
comment|/* index to symbol in file */
name|struct
name|nlist
modifier|*
name|l_symbol
decl_stmt|;
comment|/* ptr to symbol table */
name|struct
name|local
modifier|*
name|l_link
decl_stmt|;
comment|/* hash link */
block|}
modifier|*
name|lochash
index|[
name|LHSIZ
index|]
struct|,
name|lhinit
index|[
name|NSYMPR
index|]
struct|;
end_struct

begin_struct
struct|struct
name|locseg
block|{
name|struct
name|local
modifier|*
name|lo_first
decl_stmt|;
name|int
name|lo_used
decl_stmt|;
block|}
name|locseg
index|[
name|NSEG
index|]
init|=
block|{
name|lhinit
block|,
literal|0
block|}
struct|,
modifier|*
name|clocseg
struct|;
end_struct

begin_comment
comment|/*  * These data structures keep track of symbols of the following type  * stpic for static pic, dpic for data pic, tpic for text pic (or jump)  * npic for relocation in non pic modules.  */
end_comment

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|loc_symb
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|slsymb
block|{
name|int
name|sl_offset
decl_stmt|;
name|int
name|sl_lo
decl_stmt|;
comment|/* offset into the data/jump linkage */
name|struct
name|nlist
name|sl_symbol
decl_stmt|;
name|struct
name|slsymb
modifier|*
name|sl_link
decl_stmt|;
name|u_char
name|sl_new
decl_stmt|;
name|int
name|sl_rc
decl_stmt|;
comment|/* reference count */
block|}
modifier|*
name|stpichash
index|[
name|LHSIZ
index|]
struct|,
modifier|*
name|dpichash
index|[
name|LHSIZ
index|]
struct|,
modifier|*
name|tpichash
index|[
name|LHSIZ
index|]
struct|,
modifier|*
name|npichash
index|[
name|LHSIZ
index|]
struct|,
name|stpicinit
index|[
name|NSYMPR
index|]
struct|,
name|dpicinit
index|[
name|NSYMPR
index|]
struct|,
name|tpicinit
index|[
name|NSYMPR
index|]
struct|,
name|npicinit
index|[
name|NSYMPR
index|]
struct|;
end_struct

begin_struct
struct|struct
name|slsseg
block|{
name|struct
name|slsymb
modifier|*
name|sls_first
decl_stmt|;
name|int
name|sls_used
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|slsseg
name|stpicseg
index|[
name|NSEG
index|]
init|=
block|{
name|stpicinit
block|,
literal|0
block|}
decl_stmt|,
modifier|*
name|stpic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|slsseg
name|dpicseg
index|[
name|NSEG
index|]
init|=
block|{
name|dpicinit
block|,
literal|0
block|}
decl_stmt|,
modifier|*
name|dpic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|slsseg
name|tpicseg
index|[
name|NSEG
index|]
init|=
block|{
name|tpicinit
block|,
literal|0
block|}
decl_stmt|,
modifier|*
name|tpic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|slsseg
name|npicseg
index|[
name|NSEG
index|]
init|=
block|{
name|npicinit
block|,
literal|0
block|}
decl_stmt|,
modifier|*
name|npic
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NSAVETAB
value|8192
end_define

begin_decl_stmt
name|char
modifier|*
name|savetab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for symbols build by load1 */
end_comment

begin_decl_stmt
name|int
name|saveleft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dynamic
name|dynamic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|link_dynamic
name|lkd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|link_dynamic_2
name|lkd2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ld_debug
name|ldd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|doff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pad
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GT
value|"__GLOBAL_OFFSET_TABLE_"
end_define

begin_define
define|#
directive|define
name|ISGT
parameter_list|(
name|x
parameter_list|)
value|(!strcmp(GT,x))
end_define

begin_define
define|#
directive|define
name|DYNAMIC
value|1
end_define

begin_define
define|#
directive|define
name|SYMBOLIC
value|2
end_define

begin_decl_stmt
name|int
name|forceflag
init|=
name|DYNAMIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|entryflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|referonly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* load1 use this flag to decide when to bring in any 			   modules from the .sa archive */
end_comment

begin_decl_stmt
name|int
name|sa_load
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ldrand used this flag to skip lookin at the shsym 			   symbol table when checking out the .sa file */
end_comment

begin_define
define|#
directive|define
name|ST_BIND
value|0x1
end_define

begin_define
define|#
directive|define
name|DN_BIND
value|0x2
end_define

begin_define
define|#
directive|define
name|DEFINITIONS
value|0x1
end_define

begin_define
define|#
directive|define
name|NOSYMBOLIC
value|0x2
end_define

begin_define
define|#
directive|define
name|PURE_TEXT
value|0x4
end_define

begin_decl_stmt
name|int
name|bindingflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|assertflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|runtime
name|rt
decl_stmt|,
modifier|*
name|rtp
init|=
operator|&
name|rt
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ISDYNAMIC
value|((entryflag == 0&& ((bindingflag& DN_BIND) || !(bindingflag& ST_BIND))) || dynamic.lib != 0)
end_define

begin_define
define|#
directive|define
name|SHLIBSTR
value|1000
end_define

begin_decl_stmt
name|char
name|shlibstr
index|[
name|SHLIBSTR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|shlibtab
init|=
name|shlibstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|shlibleft
init|=
name|SHLIBSTR
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|slsymb
modifier|*
name|sllookup
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Libraries are typically built with a table of contents,  * which is the first member of a library with special file  * name __.SYMDEF and contains a list of symbol names  * and with each symbol the offset of the library member which defines  * it.  The loader uses this table to quickly tell which library members  * are (potentially) useful.  The alternative, examining the symbol  * table of each library member, is painfully slow for large archives.  *  * See<ranlib.h> for the definition of the ranlib structure and an  * explanation of the __.SYMDEF file format.  */
end_comment

begin_decl_stmt
name|int
name|tnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of symbols in table of contents */
end_comment

begin_decl_stmt
name|int
name|ssiz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of string table for table of contents */
end_comment

begin_decl_stmt
name|struct
name|ranlib
modifier|*
name|tab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the table of contents (dynamically allocated) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tabstr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string table for table of contents */
end_comment

begin_comment
comment|/*  * We open each input file or library only once, but in pass2 we  * (historically) read from such a file at 2 different places at the  * same time.  These structures are remnants from those days,  * and now serve only to catch ``Premature EOF''.  * In order to make I/O more efficient, we provide routines which  * use the optimal block size returned by stat().  */
end_comment

begin_define
define|#
directive|define
name|BLKSIZE
value|1024
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|short
modifier|*
name|fakeptr
decl_stmt|;
name|int
name|bno
decl_stmt|;
name|int
name|nibuf
decl_stmt|;
name|int
name|nuser
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
block|}
name|PAGE
typedef|;
end_typedef

begin_decl_stmt
name|PAGE
name|page
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|p_blksize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|p_blkshift
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|p_blkmask
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|short
modifier|*
name|fakeptr
decl_stmt|;
name|int
name|bno
decl_stmt|;
name|int
name|nibuf
decl_stmt|;
name|int
name|nuser
decl_stmt|;
block|}
name|fpage
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|bno
decl_stmt|;
name|int
name|nibuf
decl_stmt|;
name|long
name|size
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|PAGE
modifier|*
name|pno
decl_stmt|;
block|}
name|STREAM
typedef|;
end_typedef

begin_decl_stmt
name|STREAM
name|text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STREAM
name|reloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Header from the a.out and the archive it is from (if any).  */
end_comment

begin_decl_stmt
name|struct
name|exec
name|filhdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|exec
name|outfilhdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ar_hdr
name|archdr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OARMAG
value|0177545
end_define

begin_comment
comment|/*  * Options.  */
end_comment

begin_decl_stmt
name|int
name|trace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard local symbols */
end_comment

begin_decl_stmt
name|int
name|Xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard locals starting with 'L' */
end_comment

begin_decl_stmt
name|int
name|Sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard all except locals and globals*/
end_comment

begin_decl_stmt
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* preserve relocation bits, don't define common */
end_comment

begin_decl_stmt
name|int
name|arflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original copy of rflag */
end_comment

begin_decl_stmt
name|int
name|sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard all symbols */
end_comment

begin_decl_stmt
name|int
name|Mflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print rudimentary load map */
end_comment

begin_decl_stmt
name|int
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pure procedure */
end_comment

begin_decl_stmt
name|int
name|dflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* define common even with rflag */
end_comment

begin_decl_stmt
name|int
name|pflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* force definition of procedures */
end_comment

begin_decl_stmt
name|int
name|pdflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pad text to the next page boundary for 410 file */
end_comment

begin_decl_stmt
name|int
name|zflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* demand paged  */
end_comment

begin_decl_stmt
name|long
name|hsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of hole at beginning of data to be squashed */
end_comment

begin_decl_stmt
name|int
name|Aflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* doing incremental load */
end_comment

begin_decl_stmt
name|int
name|Tflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* want impure a.out */
end_comment

begin_decl_stmt
name|int
name|funding
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reading fundamental file for incremental load */
end_comment

begin_decl_stmt
name|int
name|yflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of symbols to be traced */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ytab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the symbols */
end_comment

begin_comment
comment|/*	Alastair's changes to support Sky Warrior	*/
end_comment

begin_decl_stmt
name|int
name|Pflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of commons to be aligned */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|Ptab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the commons */
end_comment

begin_if
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
end_if

begin_decl_stmt
name|int
name|use68020
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 68020-specific instructions used */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 680x0 */
end_comment

begin_comment
comment|/*  * These are the cumulative sizes, set in pass 1, which  * appear in the a.out header when the loader is finished.  */
end_comment

begin_decl_stmt
name|off_t
name|tsize
decl_stmt|,
name|dsize
decl_stmt|,
name|bsize
decl_stmt|,
name|trsize
decl_stmt|,
name|drsize
decl_stmt|,
name|ssize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Symbol relocation: c?rel is a scale factor which is  * added to an old relocation to convert it to new units;  * i.e. it is the difference between segment origins.  * (Thus if we are loading from a data segment which began at location  * 4 in a .o file into an a.out where it will be loaded starting at  * 1024, cdrel will be 1020.)  */
end_comment

begin_decl_stmt
name|long
name|ctrel
decl_stmt|,
name|cdrel
decl_stmt|,
name|cbrel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Textbase is the start address of all text, given by textreloc()  * unless specified by -T, or unless we are still relocating (-r), in  * which case it is 0.  Database is the base of all data, computed  * before and used during pass2.  */
end_comment

begin_decl_stmt
name|long
name|textbase
init|=
operator|-
literal|1
decl_stmt|,
name|database
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_define
define|#
directive|define
name|textreloc
parameter_list|()
value|0
end_define

begin_define
define|#
directive|define
name|pagesize
parameter_list|()
value|sys_pagesize
end_define

begin_define
define|#
directive|define
name|segsize
parameter_list|()
value|sys_pagesize
end_define

begin_endif
endif|#
directive|endif
endif|vax
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_define
define|#
directive|define
name|textreloc
parameter_list|()
value|(zflag ? PAGSIZ+sizeof (struct exec): PAGSIZ)
end_define

begin_define
define|#
directive|define
name|pagesize
parameter_list|()
value|PAGSIZ
end_define

begin_define
define|#
directive|define
name|segsize
parameter_list|()
value|SEGSIZ
end_define

begin_define
define|#
directive|define
name|seground
parameter_list|()
value|sizeof (double)
end_define

begin_endif
endif|#
directive|endif
endif|sun
end_endif

begin_comment
comment|/*  * Origins of the text and data segments can be regulated by command-  * line flags -Ttext& -Tdata (just -T will be interpreted as -Ttext).  */
end_comment

begin_struct
struct|struct
name|origopts
block|{
name|char
modifier|*
name|optname
decl_stmt|;
name|char
modifier|*
name|whatbase
decl_stmt|;
name|long
modifier|*
name|flagptr
decl_stmt|;
name|long
modifier|*
name|whatsize
decl_stmt|;
block|}
name|origopts
index|[]
init|=
block|{
literal|"T"
block|,
literal|"text"
block|,
operator|&
name|textbase
block|,
operator|&
name|tsize
block|,
literal|"Ttext"
block|,
literal|"text"
block|,
operator|&
name|textbase
block|,
operator|&
name|tsize
block|,
literal|"Tdata"
block|,
literal|"data"
block|,
operator|&
name|database
block|,
operator|&
name|dsize
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|, }
struct|;
end_struct

begin_comment
comment|/*  * changes for Sun-3 and subsequent architectures:  *  *   1.	(magic numbers) Magic numbers are 16 bits and are preceded by  *	a 16-bit machine type field, which is 0 for Sun-2 and earlier  *	architectures.  Sun-3 has a machine type of 1.  *  *   2.	(segment relocation bases) Changed from Sun-2:  *  *	text(old):	0x8000  *	text(new):	0x2000 + sizeof(struct exec)  *	data(old):	begins at a multiple of 0x8000  *	data(new):	begins at a multiple of 0x20000  *  *   3. (location of a.out header) In all Sun-3 object file formats,  *	the exec structure is at the beginning of the text segment.  *	In demand-paged (0413) files, this saves about a page of  *	disk space.  */
end_comment

begin_comment
comment|/*  * The base addresses for the loaded text, data and bss from the  * current module during pass2 are given by torigin, dorigin and borigin.  */
end_comment

begin_decl_stmt
name|long
name|torigin
decl_stmt|,
name|dorigin
decl_stmt|,
name|ndorigin
decl_stmt|,
name|borigin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Errlev is nonzero when errors have occured.  * Delarg is an implicit argument to the routine delexit  * which is called on error.  We do ``delarg = errlev'' before normal  * exits, and only if delarg is 0 (i.e. errlev was 0) do we make the  * result file executable.  */
end_comment

begin_decl_stmt
name|int
name|errlev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delarg
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The biobuf structure and associated routines are used to write  * into one file at several places concurrently.  Calling bopen  * with a biobuf structure sets it up to write ``biofd'' starting  * at the specified offset.  You can then use ``bwrite'' and/or ``bputc''  * to stuff characters in the stream, much like ``fwrite'' and ``fputc''.  * Calling bflush drains all the buffers and MUST be done before exit.  */
end_comment

begin_struct
struct|struct
name|biobuf
block|{
name|int
name|b_nleft
decl_stmt|;
comment|/* Number free spaces left in b_buf */
comment|/* Initialize to be less than b_bufsize initially, to boundary align in file */
name|char
modifier|*
name|b_ptr
decl_stmt|;
comment|/* Next place to stuff characters */
name|char
modifier|*
name|b_buf
decl_stmt|;
comment|/* Pointer to the buffer */
name|int
name|b_bufsize
decl_stmt|;
comment|/* Size of the buffer */
name|off_t
name|b_off
decl_stmt|;
comment|/* Current file offset */
name|struct
name|biobuf
modifier|*
name|b_link
decl_stmt|;
comment|/* Link in chain for bflush() */
block|}
modifier|*
name|biobufs
struct|;
end_struct

begin_define
define|#
directive|define
name|bputc
parameter_list|(
name|c
parameter_list|,
name|b
parameter_list|)
value|((b)->b_nleft ? (--(b)->b_nleft, *(b)->b_ptr++ = (c)) \ 		       : bflushc(b, c))
end_define

begin_decl_stmt
name|int
name|biofd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|off_t
name|boffset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|biobuf
modifier|*
name|tout
decl_stmt|,
modifier|*
name|dout
decl_stmt|,
modifier|*
name|trout
decl_stmt|,
modifier|*
name|drout
decl_stmt|,
modifier|*
name|sout
decl_stmt|,
modifier|*
name|strout
decl_stmt|,
modifier|*
name|dynout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Offset is the current offset in the string file.  * Its initial value reflects the fact that we will  * eventually stuff the size of the string table at the  * beginning of the string table (i.e. offset itself!).  */
end_comment

begin_decl_stmt
name|off_t
name|offset
init|=
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|aoutname
init|=
literal|"a.out"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of resultant file: -o argument or a.out */
end_comment

begin_decl_stmt
name|char
name|ofilename
index|[
name|MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ofilemode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* respect umask even for unsucessful ld's */
end_comment

begin_decl_stmt
name|int
name|infil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input file descriptor */
end_comment

begin_decl_stmt
name|char
modifier|*
name|filname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and its name */
end_comment

begin_decl_stmt
name|int
name|header_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ordinal # of header file (for dbx) */
end_comment

begin_define
define|#
directive|define
name|NDIRS
value|100
end_define

begin_comment
comment|/* programs are getting bigger */
end_comment

begin_define
define|#
directive|define
name|NDEFDIRS
value|3
end_define

begin_comment
comment|/* number of default directories in dirs[] */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dirs
index|[
name|NDIRS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directories for library search */
end_comment

begin_decl_stmt
name|int
name|ndir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of directories */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ldpath1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place to hold make's copy of additionals */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ldpath2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place to hold ld's copy of additionals */
end_comment

begin_decl_stmt
name|char
modifier|*
name|defaults_dir
index|[
name|NDEFDIRS
index|]
init|=
block|{
literal|"/lib"
block|,
literal|"/usr/lib"
block|,
literal|"/usr/local/lib"
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SUNPRO
end_ifdef

begin_decl_stmt
name|pathcellpt
name|sp_dirs
index|[
name|NDIRS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* search path containing one directory */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Base of the string table of the current module (pass1 and pass2).  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|curstr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * System software page size  */
end_comment

begin_decl_stmt
name|int
name|sys_pagesize
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
name|get
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|delexit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|savestr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|mymalloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * list of all libraries both dynamic and static one.  */
end_comment

begin_define
define|#
directive|define
name|PLAIN
value|0
end_define

begin_define
define|#
directive|define
name|ARCH1
value|1
end_define

begin_comment
comment|/* archive without table of contents */
end_comment

begin_define
define|#
directive|define
name|ARCH2
value|2
end_define

begin_comment
comment|/* archive with table of contents */
end_comment

begin_define
define|#
directive|define
name|ARCH3
value|3
end_define

begin_comment
comment|/* archive with out of date table of contents */
end_comment

begin_define
define|#
directive|define
name|SHLIB
value|4
end_define

begin_comment
comment|/* shared library */
end_comment

begin_comment
comment|/*  * definition of flag value  */
end_comment

begin_define
define|#
directive|define
name|DOREADME
value|1
end_define

begin_comment
comment|/* when set do read in my symbol table */
end_comment

begin_define
define|#
directive|define
name|DOLOADME
value|2
end_define

begin_comment
comment|/* in load2arg when set do load in needed .o */
end_comment

begin_struct
struct|struct
name|ldlib
block|{
name|char
modifier|*
name|ll_name
decl_stmt|;
name|int
name|ll_flag
decl_stmt|;
name|int
name|ll_type
decl_stmt|;
name|struct
name|ldlib
modifier|*
name|ll_next
decl_stmt|;
block|}
modifier|*
name|hldlp
struct|,
modifier|*
modifier|*
name|ldlpp
struct|;
end_struct

begin_comment
comment|/*  * Debugging logic  */
end_comment

begin_extern
extern|extern printf(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_macro
name|null
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|dp
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|is_null
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BROWSER
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|cb_program_name
init|=
literal|"ld"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cb_ranlib_saw_library_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_define
define|#
directive|define
name|N_BROWS
value|0x48
end_define

begin_comment
comment|/* Zap when 4.1<stab.h> is installed */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|cb_executable_tags_h_INCLUDED
end_ifndef

begin_include
include|#
directive|include
file|"cb_executable_tags.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|int
name|num
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|save
decl_stmt|;
name|char
modifier|*
name|ln
decl_stmt|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|char
modifier|*
name|ld_opts
decl_stmt|;
name|char
modifier|*
modifier|*
name|prepend_argv
parameter_list|()
function_decl|;
name|struct
name|nlist
modifier|*
modifier|*
name|spp
decl_stmt|;
name|int
name|doneflag
init|=
literal|1
decl_stmt|;
name|dp
operator|=
name|is_null
condition|?
name|printf
else|:
name|null
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|delexit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|delexit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|alloc_inclstack
argument_list|()
expr_stmt|;
name|sys_pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
comment|/*  	 * some initializations for doing dynamic linking 	 */
name|dpic
operator|=
name|dpicseg
expr_stmt|;
name|tpic
operator|=
name|tpicseg
expr_stmt|;
name|npic
operator|=
name|npicseg
expr_stmt|;
name|rtp
operator|->
name|dp
operator|=
operator|&
name|dynamic
expr_stmt|;
name|rtp
operator|->
name|libname
operator|=
name|shlibstr
expr_stmt|;
name|assertflag
operator||=
name|DEFINITIONS
expr_stmt|;
ifdef|#
directive|ifdef
name|SUNPRO
name|dovroot
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|ld_opts
operator|=
name|getenv
argument_list|(
literal|"LD_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld_opts
operator|!=
name|NULL
condition|)
name|argv
operator|=
name|prepend_argv
argument_list|(
name|ld_opts
argument_list|,
name|argv
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
comment|/* 	 * Scan arguments to determine the correct setting of 	 * zflag.  The text relocation base depends on it, and 	 * cannot change after the first file is processed. 	 * We also scan to pick up any "-L" flags, so we can set the 	 * list of directories to search for libraries in before 	 * we actually process the libraries. 	 */
name|zflag
operator|=
literal|1
expr_stmt|;
comment|/* default: on */
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
name|ap
operator|=
name|argv
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|ap
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
comment|/* not an option string */
name|doneflag
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|ap
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ap
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
name|entryflag
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|BROWSER
name|c
operator|++
expr_stmt|;
goto|goto
name|nextarg
goto|;
endif|#
directive|endif
case|case
literal|'o'
case|:
ifdef|#
directive|ifdef
name|BROWSER
if|if
condition|(
operator|!
name|cb_ranlib_saw_library_name
condition|)
block|{
name|cb_ranlib_start_library
argument_list|(
name|argv
index|[
name|c
operator|+
literal|1
index|]
argument_list|,
name|CB_CURRENT_LANGUAGE
argument_list|,
name|CB_CURRENT_MAJOR_VERSION
argument_list|,
name|CB_CURRENT_MINOR_VERSION
argument_list|,
name|CB_EX_FOCUS_UNIT_PROGRAM_FORMAT
argument_list|)
expr_stmt|;
name|cb_ranlib_saw_library_name
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Fall thru */
endif|#
directive|endif
case|case
literal|'u'
case|:
name|doneflag
operator|=
literal|0
expr_stmt|;
case|case
literal|'H'
case|:
case|case
literal|'D'
case|:
case|case
literal|'A'
case|:
case|case
literal|'T'
case|:
case|case
literal|'a'
case|:
comment|/* 				 * skip the next argument string -- 				 * but look at the rest of the flags 				 * in the current one (bletch) 				 */
name|c
operator|++
expr_stmt|;
goto|goto
name|nextarg
goto|;
case|case
literal|'l'
case|:
case|case
literal|'y'
case|:
case|case
literal|'B'
case|:
comment|/* 				 * discard the rest of the current argument 				 * string 				 */
goto|goto
name|nextarg
goto|;
case|case
literal|'r'
case|:
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
continue|continue;
case|case
literal|'L'
case|:
comment|/* 				 * add a directory to the list of directories 				 * to look for libraries in 				 */
if|if
condition|(
name|ap
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-L: pathname missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndir
operator|>=
name|NDIRS
operator|-
name|NDEFDIRS
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-L: too many directories"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUNPRO
name|add_dir_to_path
argument_list|(
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|sp_dirs
index|[
name|ndir
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dirs
index|[
name|ndir
operator|++
index|]
operator|=
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
goto|goto
name|nextarg
goto|;
default|default:
continue|continue;
block|}
block|}
name|nextarg
label|:
continue|continue;
block|}
if|if
condition|(
name|doneflag
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndir
condition|;
name|i
operator|++
control|)
name|rtp
operator|->
name|spthlen
operator|+=
name|strlen
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rtp
operator|->
name|spthlen
condition|)
block|{
name|rtp
operator|->
name|searchpath
operator|=
name|calloc
argument_list|(
name|lalign
argument_list|(
name|rtp
operator|->
name|spthlen
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rtp
operator|->
name|searchpath
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndir
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|cp
argument_list|,
name|dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cp
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUNPRO
name|ln
operator|=
name|getenv
argument_list|(
name|LDPATH
argument_list|)
expr_stmt|;
name|i
operator|=
name|ndir
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|ldpath1
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|ln
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ldpath1
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|ln
operator|=
name|ldpath1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|cp
init|=
name|ln
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|':'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|add_dir_to_path
argument_list|(
name|ln
argument_list|,
operator|&
name|sp_dirs
index|[
name|i
operator|++
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ln
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|add_dir_to_path
argument_list|(
name|ln
argument_list|,
operator|&
name|sp_dirs
index|[
name|i
operator|++
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
name|ln
operator|=
name|getenv
argument_list|(
name|LDPATH
argument_list|)
expr_stmt|;
comment|/* add default search directories */
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|ldpath2
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|ln
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ldpath2
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|ln
operator|=
name|ldpath2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|cp
init|=
name|ln
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|':'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|dirs
index|[
name|ndir
operator|++
index|]
operator|=
name|ln
expr_stmt|;
name|ln
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dirs
index|[
name|ndir
operator|++
index|]
operator|=
name|ln
expr_stmt|;
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|SUNPRO
name|i
operator|=
name|ndir
expr_stmt|;
name|add_dir_to_path
argument_list|(
literal|"/lib"
argument_list|,
operator|&
name|sp_dirs
index|[
name|i
operator|++
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_dir_to_path
argument_list|(
literal|"/usr/lib"
argument_list|,
operator|&
name|sp_dirs
index|[
name|i
operator|++
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_dir_to_path
argument_list|(
literal|"/usr/local/lib"
argument_list|,
operator|&
name|sp_dirs
index|[
name|i
operator|++
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDEFDIRS
condition|;
name|i
operator|++
control|)
name|dirs
index|[
name|ndir
operator|++
index|]
operator|=
name|defaults_dir
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
name|ap
operator|=
name|argv
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|ap
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|getlibname
argument_list|(
name|ap
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|ap
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ap
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
case|case
literal|'H'
case|:
case|case
literal|'D'
case|:
case|case
literal|'e'
case|:
case|case
literal|'T'
case|:
case|case
literal|'a'
case|:
comment|/* 				 * skip the next argument string -- 				 * but look at the rest of the flags 				 * in the current one (bletch) 				 */
name|c
operator|++
expr_stmt|;
goto|goto
name|nextt
goto|;
case|case
literal|'l'
case|:
name|getlibname
argument_list|(
operator|&
name|ap
index|[
operator|--
name|i
index|]
argument_list|)
expr_stmt|;
case|case
literal|'y'
case|:
goto|goto
name|nextt
goto|;
case|case
literal|'B'
case|:
if|if
condition|(
name|ap
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-B: force option missing"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"static"
argument_list|)
condition|)
name|forceflag
operator|&=
operator|~
name|DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"symbolic"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|char
modifier|*
name|c
init|=
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|c
operator|+
literal|8
operator|)
operator|==
literal|'='
condition|)
name|getsymb
argument_list|(
name|c
operator|+
literal|9
argument_list|)
expr_stmt|;
name|bindingflag
operator||=
name|DN_BIND
expr_stmt|;
name|forceflag
operator||=
name|SYMBOLIC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"dynamic"
argument_list|)
condition|)
block|{
name|bindingflag
operator||=
name|DN_BIND
expr_stmt|;
name|forceflag
operator||=
name|DYNAMIC
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"-B: unknown force option"
argument_list|)
expr_stmt|;
goto|goto
name|nextt
goto|;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
case|case
literal|'A'
case|:
name|bindingflag
operator||=
name|ST_BIND
expr_stmt|;
name|forceflag
operator|&=
operator|~
name|DYNAMIC
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|rflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'L'
case|:
goto|goto
name|nextt
goto|;
default|default:
continue|continue;
block|}
block|}
name|nextt
label|:
continue|continue;
block|}
if|if
condition|(
operator|!
name|rflag
condition|)
name|initss
argument_list|(
name|rtp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entryflag
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"do not mix -e and -r flags."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entryflag
operator|&&
name|bindingflag
operator|!=
name|ST_BIND
operator|&&
operator|!
name|rflag
condition|)
name|textbase
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
expr_stmt|;
name|p
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Scan files once to find where symbols are defined. 	 */
name|forceflag
operator|=
name|DYNAMIC
expr_stmt|;
comment|/* reset to default value */
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|trace
condition|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|filname
operator|=
literal|0
expr_stmt|;
name|ap
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|!=
literal|'-'
condition|)
block|{
name|load1arg
argument_list|(
name|ap
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|ap
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|ap
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* align to page size option */
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|ap
index|[
name|i
index|]
argument_list|,
literal|"align"
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|ap
index|[
name|i
index|]
argument_list|,
literal|"assert"
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-a??? option not recognized"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|tmp
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-assert argument missing"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmp
argument_list|,
literal|"definitions"
argument_list|)
condition|)
name|assertflag
operator||=
name|DEFINITIONS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmp
argument_list|,
literal|"nodefinitions"
argument_list|)
condition|)
name|assertflag
operator|&=
operator|~
name|DEFINITIONS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmp
argument_list|,
literal|"nosymbolic"
argument_list|)
condition|)
name|assertflag
operator||=
name|NOSYMBOLIC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmp
argument_list|,
literal|"pure-text"
argument_list|)
condition|)
name|assertflag
operator||=
name|PURE_TEXT
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"[no]definitions, nosymbolic, pure-text are the only valid assert options"
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-align argument missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Pflag
operator|==
literal|0
condition|)
block|{
name|Ptab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|argc
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ptab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (-align)"
argument_list|)
expr_stmt|;
block|}
name|Ptab
index|[
name|Pflag
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
goto|goto
name|next
goto|;
block|}
case|case
literal|'B'
case|:
if|if
condition|(
name|ap
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-B: force option missing"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"static"
argument_list|)
condition|)
name|forceflag
operator|&=
operator|~
name|DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"symbolic"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|forceflag
operator||=
name|SYMBOLIC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"dynamic"
argument_list|)
condition|)
block|{
name|forceflag
operator||=
name|DYNAMIC
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"-B: unknown force option"
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
case|case
literal|'o'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-o: arg missing"
argument_list|)
expr_stmt|;
name|aoutname
operator|=
operator|*
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
case|case
literal|'e'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-u or -c: arg missing"
argument_list|)
expr_stmt|;
name|spp
operator|=
name|slookup
argument_list|(
operator|*
name|p
argument_list|,
operator|&
name|ldsym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|spp
operator|==
literal|0
condition|)
name|rtp
operator|->
name|fsalloc
operator|+=
name|strlen
argument_list|(
operator|*
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
name|enter
argument_list|(
operator|&
name|ldsym
argument_list|,
name|spp
argument_list|,
operator|&
name|cursym
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|ap
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|entrypt
operator|=
name|ldsym
operator|.
name|ls
expr_stmt|;
continue|continue;
case|case
literal|'H'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-H: arg missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsize
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-H: too late, some text already loaded"
argument_list|)
expr_stmt|;
name|hsize
operator|=
name|atoi
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'A'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-A: arg missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Aflag
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-A: only one base file allowed"
argument_list|)
expr_stmt|;
name|Aflag
operator|=
literal|1
expr_stmt|;
name|nflag
operator|=
name|zflag
operator|=
literal|0
expr_stmt|;
name|funding
operator|=
literal|1
expr_stmt|;
name|load1arg
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|trsize
operator|=
name|drsize
operator|=
name|tsize
operator|=
name|dsize
operator|=
name|bsize
operator|=
literal|0
expr_stmt|;
name|ctrel
operator|=
name|cdrel
operator|=
name|cbrel
operator|=
literal|0
expr_stmt|;
name|funding
operator|=
literal|0
expr_stmt|;
name|addsym
operator|=
name|ldsym
operator|.
name|ns
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-D: arg missing"
argument_list|)
expr_stmt|;
name|num
operator|=
name|htoi
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|>
name|num
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-D: too small"
argument_list|)
expr_stmt|;
name|dsize
operator|=
name|num
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
block|{
name|struct
name|origopts
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|origopts
init|;
name|t
operator|->
name|optname
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|ap
index|[
name|i
index|]
argument_list|,
name|t
operator|->
name|optname
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|optname
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-%s option unrecognized"
argument_list|,
operator|&
name|ap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-%s: arg missing"
argument_list|,
name|t
operator|->
name|optname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|t
operator|->
name|whatsize
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-%s: too late,some %s already loaded"
argument_list|,
name|t
operator|->
name|optname
argument_list|,
name|t
operator|->
name|whatbase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|t
operator|->
name|flagptr
operator|)
operator|>=
literal|0
operator|&&
operator|!
name|Aflag
condition|)
name|error
argument_list|(
operator|-
literal|1
argument_list|,
literal|"-%s: %s base already given: old value overridden"
argument_list|,
name|t
operator|->
name|optname
argument_list|,
name|t
operator|->
name|whatbase
argument_list|)
expr_stmt|;
operator|*
operator|(
name|t
operator|->
name|flagptr
operator|)
operator|=
name|htoi
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
goto|goto
name|next
goto|;
case|case
literal|'l'
case|:
name|save
operator|=
name|ap
index|[
operator|--
name|i
index|]
expr_stmt|;
name|ap
index|[
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
name|load1arg
argument_list|(
operator|&
name|ap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ap
index|[
name|i
index|]
operator|=
name|save
expr_stmt|;
goto|goto
name|next
goto|;
case|case
literal|'M'
case|:
name|Mflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
name|xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'X'
case|:
name|Xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'S'
case|:
name|Sflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|rflag
operator|++
expr_stmt|;
name|arflag
operator|++
expr_stmt|;
comment|/* We don't want to relocate the text. */
if|if
condition|(
name|textbase
operator|!=
literal|0
operator|&&
name|textbase
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tsize
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-r: too late, some text already loaded"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|"-T& -r are mutually exclusive"
argument_list|)
expr_stmt|;
block|}
name|textbase
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|sflag
operator|++
expr_stmt|;
name|xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
if|if
condition|(
name|ap
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'c'
operator|||
name|ap
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|dflag
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'p'
condition|)
name|pflag
operator|++
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad -d flag"
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
case|case
literal|'t'
case|:
name|trace
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'y'
case|:
if|if
condition|(
name|ap
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-y: symbol name missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yflag
operator|==
literal|0
condition|)
block|{
name|ytab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|argc
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ytab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (-y)"
argument_list|)
expr_stmt|;
block|}
name|ytab
index|[
name|yflag
operator|++
index|]
operator|=
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
goto|goto
name|next
goto|;
case|case
literal|'N'
case|:
name|Nflag
operator|++
expr_stmt|;
name|nflag
operator|=
name|zflag
operator|=
literal|0
expr_stmt|;
name|forceflag
operator|&=
operator|~
name|DYNAMIC
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|nflag
operator|++
expr_stmt|;
name|Nflag
operator|=
name|zflag
operator|=
literal|0
expr_stmt|;
name|forceflag
operator|&=
operator|~
name|DYNAMIC
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
name|pdflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'z'
case|:
name|zflag
operator|++
expr_stmt|;
name|Nflag
operator|=
name|nflag
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'L'
case|:
goto|goto
name|next
goto|;
comment|/* we already did this one */
default|default:
name|filname
operator|=
name|savestr
argument_list|(
literal|"-x"
argument_list|,
operator|&
name|savetab
argument_list|,
operator|&
name|saveleft
argument_list|)
expr_stmt|;
comment|/* kludge */
name|filname
index|[
literal|1
index|]
operator|=
name|ap
index|[
name|i
index|]
expr_stmt|;
comment|/* kludge */
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* kludge */
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad flag"
argument_list|)
expr_stmt|;
block|}
name|next
label|:
empty_stmt|;
block|}
name|ap
operator|=
name|rindex
argument_list|(
name|aoutname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|!=
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|ofilename
argument_list|,
name|aoutname
argument_list|,
name|ap
operator|-
name|aoutname
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|ofilename
argument_list|,
literal|"l.outXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|ofilename
argument_list|)
expr_stmt|;
name|header_num
operator|=
literal|0
expr_stmt|;
name|merge_headers
argument_list|()
expr_stmt|;
name|endload
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BROWSER
name|cb_ranlib_exit
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine set up theses special symbols for the runtime symbol table.  * It also set up the values here so calcreloc doesn't account any   * reference to these symbols  */
end_comment

begin_expr_stmt
name|initss
argument_list|(
name|rt
argument_list|)
specifier|register
expr|struct
name|runtime
operator|*
name|rt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|struct
name|nlist
modifier|*
modifier|*
name|slookup
parameter_list|()
function_decl|;
name|enter
argument_list|(
operator|&
name|ldsym
argument_list|,
name|slookup
argument_list|(
literal|"_etext"
argument_list|,
operator|&
name|ldsym
argument_list|)
argument_list|,
operator|&
name|cursym
argument_list|)
expr_stmt|;
name|enter
argument_list|(
operator|&
name|ldsym
argument_list|,
name|slookup
argument_list|(
literal|"_edata"
argument_list|,
operator|&
name|ldsym
argument_list|)
argument_list|,
operator|&
name|cursym
argument_list|)
expr_stmt|;
name|enter
argument_list|(
operator|&
name|ldsym
argument_list|,
name|slookup
argument_list|(
literal|"_end"
argument_list|,
operator|&
name|ldsym
argument_list|)
argument_list|,
operator|&
name|cursym
argument_list|)
expr_stmt|;
name|rt
operator|->
name|fsalloc
operator|+=
literal|19
expr_stmt|;
comment|/* lenght of _etext _edata _end plus 3 null */
name|sp
operator|=
operator|*
name|slookup
argument_list|(
literal|"_etext"
argument_list|,
operator|&
name|ldsym
argument_list|)
expr_stmt|;
name|ldrsym
argument_list|(
name|sp
argument_list|,
operator|-
literal|1
argument_list|,
name|N_EXT
operator|+
name|N_UNDF
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|*
name|slookup
argument_list|(
literal|"_edata"
argument_list|,
operator|&
name|ldsym
argument_list|)
expr_stmt|;
name|ldrsym
argument_list|(
name|sp
argument_list|,
operator|-
literal|1
argument_list|,
name|N_EXT
operator|+
name|N_UNDF
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|*
name|slookup
argument_list|(
literal|"_end"
argument_list|,
operator|&
name|ldsym
argument_list|)
expr_stmt|;
name|ldrsym
argument_list|(
name|sp
argument_list|,
operator|-
literal|1
argument_list|,
name|N_EXT
operator|+
name|N_UNDF
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getlibname
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|kind
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|struct
name|ldlib
modifier|*
name|llp
decl_stmt|;
name|struct
name|ldlib
modifier|*
name|tllp
decl_stmt|;
name|kind
operator|=
name|getfile
argument_list|(
name|cp
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|infil
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|PLAIN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  	 * first time  	 */
if|if
condition|(
operator|!
name|hldlp
condition|)
name|ldlpp
operator|=
operator|&
name|hldlp
expr_stmt|;
else|else
block|{
for|for
control|(
name|tllp
operator|=
name|hldlp
init|;
name|tllp
operator|!=
name|NULL
condition|;
name|tllp
operator|=
name|tllp
operator|->
name|ll_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tllp
operator|->
name|ll_name
argument_list|,
name|cp
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|ldlpp
operator|=
name|llp
operator|=
operator|(
expr|struct
name|ldlib
operator|*
operator|)
name|mymalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ldlib
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|llp
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"getlibname: out of memory\n"
argument_list|)
expr_stmt|;
name|ldlpp
operator|=
operator|&
name|llp
operator|->
name|ll_next
expr_stmt|;
name|llp
operator|->
name|ll_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|llp
operator|->
name|ll_name
operator|=
name|mymalloc
argument_list|(
name|strlen
argument_list|(
name|filname
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"getlibname: out of memory\n"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|llp
operator|->
name|ll_name
argument_list|,
name|filname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|ARCH1
case|:
case|case
name|ARCH2
case|:
case|case
name|ARCH3
case|:
for|for
control|(
name|tllp
operator|=
name|hldlp
init|;
name|tllp
operator|!=
name|llp
condition|;
name|tllp
operator|=
name|tllp
operator|->
name|ll_next
control|)
if|if
condition|(
name|tllp
operator|->
name|ll_type
operator|==
name|SHLIB
condition|)
name|tllp
operator|->
name|ll_flag
operator||=
name|DOREADME
expr_stmt|;
break|break;
case|case
name|SHLIB
case|:
name|bindingflag
operator||=
name|DN_BIND
expr_stmt|;
name|llp
operator|->
name|ll_type
operator|=
name|kind
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|1
argument_list|,
literal|"getlibname: unexpected type of file\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Convert a ascii string which is a hex number.  * Used by -T and -D options.  */
end_comment

begin_expr_stmt
name|htoi
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
name|n
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|n
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|n
operator|+=
literal|10
operator|+
operator|(
name|c
operator|-
literal|'a'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|n
operator|+=
literal|10
operator|+
operator|(
name|c
operator|-
literal|'A'
operator|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"badly formed hex number"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|delexit
argument_list|()
end_macro

begin_block
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
name|long
name|size
decl_stmt|;
name|char
name|c
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|nwritten
decl_stmt|;
name|bflush
argument_list|()
expr_stmt|;
name|unlink
argument_list|(
name|ofilename
argument_list|)
expr_stmt|;
name|delete_section_temps
argument_list|()
expr_stmt|;
comment|/* for management of extra sections */
comment|/* 	 * We have to insure that the last block of the data segment 	 * is allocated a full pagesize block. If the underlying 	 * file system allocates frags that are smaller than pagesize, 	 * a full zero filled pagesize block needs to be allocated so  	 * that when it is demand paged, the paged in block will be  	 * appropriately filled with zeros. 	 */
name|fstat
argument_list|(
name|biofd
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|size
operator|=
name|round
argument_list|(
name|stbuf
operator|.
name|st_size
argument_list|,
name|pagesize
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rflag
operator|&&
name|zflag
operator|&&
name|size
operator|>
name|stbuf
operator|.
name|st_size
condition|)
block|{
name|lseek
argument_list|(
name|biofd
argument_list|,
name|size
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nwritten
operator|=
name|write
argument_list|(
name|biofd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwritten
operator|!=
literal|1
condition|)
block|{
name|filname
operator|=
name|ofilename
expr_stmt|;
comment|/* kludge */
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* kludge */
if|if
condition|(
name|nwritten
operator|<
literal|0
condition|)
name|error
argument_list|(
operator|-
literal|1
argument_list|,
literal|"output write error: %s"
argument_list|,
name|errmsg
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
operator|-
literal|1
argument_list|,
literal|"output write error: premature EOF"
argument_list|)
expr_stmt|;
name|delarg
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|delarg
operator|==
literal|0
operator|&&
name|Aflag
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|aoutname
argument_list|,
name|ofilemode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BROWSER
name|cb_ranlib_exit
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|delarg
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|DISCARDIT
value|0xff
end_define

begin_macro
name|endload
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|long
name|dnum
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|clibseg
operator|=
name|libseg
expr_stmt|;
name|filname
operator|=
literal|0
expr_stmt|;
name|middle
argument_list|()
expr_stmt|;
name|setupout
argument_list|()
expr_stmt|;
comment|/* 	 * In the case of static linking then symbol __DYNAMIC  	 * has a value of zero to tell crt0 that there is no need 	 * for any futher relocation. 	 * Also we dont need to increment ssize to account for 	 * this mkfsym since we are not going to write the __DYNAMIC 	 * that is already in the symbol table. 	 */
if|if
condition|(
operator|!
name|rflag
condition|)
block|{
name|int
name|savexflag
decl_stmt|;
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|D_NAME
expr_stmt|;
name|savexflag
operator|=
name|xflag
expr_stmt|;
name|xflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|lookup
argument_list|(
operator|&
name|ldsym
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|entryflag
condition|)
block|{
if|if
condition|(
name|rtp
operator|->
name|dp
operator|->
name|lib
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"_DYNAMIC bootstrapping not available: use -Bstatic."
argument_list|)
expr_stmt|;
else|else
name|mkfsym
argument_list|(
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
literal|0
argument_list|,
name|N_DATA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * when we are building a shared library here 				 * ++++ is this a reasonable assumption??? 				 */
name|mkfsym
argument_list|(
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|dorigin
argument_list|,
name|N_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|forceflag
operator|&
name|SYMBOLIC
condition|)
operator|*
operator|(
name|rtp
operator|->
name|dt
operator|+
name|abs
argument_list|(
name|rtp
operator|->
name|dp
operator|->
name|got_off
argument_list|)
operator|)
operator|=
name|dorigin
expr_stmt|;
block|}
block|}
else|else
block|{
name|mkfsym
argument_list|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
name|sp
operator|->
name|n_value
argument_list|,
name|N_DATA
argument_list|)
expr_stmt|;
comment|/* 			 * we are setting the first location of the glob  			 * table to contain the location of the dynamic 			 * structure to assist the runtime loader in  			 * locating it. 			 */
if|if
condition|(
name|sp
operator|->
name|n_value
operator|!=
literal|0
condition|)
operator|*
operator|(
name|rtp
operator|->
name|dt
operator|+
name|abs
argument_list|(
name|rtp
operator|->
name|dp
operator|->
name|got_off
argument_list|)
operator|)
operator|=
name|dorigin
expr_stmt|;
name|sp
operator|->
name|n_type
operator|=
name|DISCARDIT
expr_stmt|;
block|}
name|xflag
operator|=
name|savexflag
expr_stmt|;
name|nsym
operator|++
expr_stmt|;
name|forceflag
operator||=
name|DYNAMIC
expr_stmt|;
comment|/* reset it to default value */
block|}
name|p
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
name|ap
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|!=
literal|'-'
condition|)
block|{
name|load2arg
argument_list|(
name|ap
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|ap
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|ap
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'D'
case|:
name|dnum
operator|=
name|htoi
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dorigin
operator|<
name|dnum
condition|)
while|while
condition|(
name|dorigin
operator|<
name|dnum
condition|)
name|bputc
argument_list|(
literal|0
argument_list|,
name|dout
argument_list|)
operator|,
name|dorigin
operator|++
expr_stmt|;
comment|/* fall into ... */
case|case
literal|'u'
case|:
case|case
literal|'e'
case|:
case|case
literal|'o'
case|:
case|case
literal|'H'
case|:
operator|++
name|c
expr_stmt|;
operator|++
name|p
expr_stmt|;
comment|/* fall into ... */
default|default:
continue|continue;
case|case
literal|'A'
case|:
name|funding
operator|=
literal|1
expr_stmt|;
name|load2arg
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|funding
operator|=
literal|0
expr_stmt|;
name|c
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'a'
case|:
comment|/* Page align */
case|case
literal|'T'
case|:
operator|++
name|c
expr_stmt|;
operator|++
name|p
expr_stmt|;
comment|/* fall into ... */
case|case
literal|'y'
case|:
case|case
literal|'L'
case|:
goto|goto
name|next
goto|;
case|case
literal|'B'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"static"
argument_list|)
condition|)
name|forceflag
operator|&=
operator|~
name|DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"symbolic"
argument_list|,
literal|8
argument_list|)
condition|)
name|forceflag
operator||=
name|SYMBOLIC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"dynamic"
argument_list|)
condition|)
name|forceflag
operator||=
name|DYNAMIC
expr_stmt|;
goto|goto
name|next
goto|;
case|case
literal|'l'
case|:
name|ap
index|[
operator|--
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
name|load2arg
argument_list|(
operator|&
name|ap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
name|forceflag
operator|&=
operator|~
name|DYNAMIC
expr_stmt|;
continue|continue;
block|}
name|next
label|:
empty_stmt|;
block|}
name|finishout
argument_list|()
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|lslib
block|{
name|char
modifier|*
name|libname
decl_stmt|;
name|struct
name|lslib
modifier|*
name|lib_next
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|lslib
modifier|*
name|rd_shsb
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Scan file to find defined symbols.  */
end_comment

begin_expr_stmt
name|load1arg
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ranlib
modifier|*
name|tp
decl_stmt|;
name|off_t
name|nloc
decl_stmt|;
name|int
name|kind
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|,
modifier|*
name|tpp
decl_stmt|;
name|int
name|maj
init|=
literal|0
decl_stmt|;
name|int
name|min
init|=
literal|0
decl_stmt|;
name|struct
name|ldlib
modifier|*
name|tllp
decl_stmt|;
name|struct
name|lslib
modifier|*
name|lp
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|nosa
init|=
literal|0
decl_stmt|;
comment|/*  	 * If the user hasn't somehow specified a textbase (by -T or -r) 	 * take the default. 	 */
if|if
condition|(
name|textbase
operator|==
operator|-
literal|1
operator|&&
operator|!
name|Aflag
condition|)
name|textbase
operator|=
name|textreloc
argument_list|()
expr_stmt|;
name|kind
operator|=
name|getfile
argument_list|(
name|cp
argument_list|,
operator|&
name|maj
argument_list|,
operator|&
name|min
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mflag
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|filname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
comment|/* 	 * Plain file. 	 */
case|case
name|PLAIN
case|:
name|load1
argument_list|(
literal|0
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Archive without table of contents. 	 * (Slowly) process each member. 	 */
case|case
name|ARCH1
case|:
name|error
argument_list|(
operator|-
literal|1
argument_list|,
literal|"warning: archive has no table of contents; add one using ranlib(1)"
argument_list|)
expr_stmt|;
name|nloc
operator|=
name|SARMAG
expr_stmt|;
while|while
condition|(
name|step
argument_list|(
name|nloc
argument_list|)
condition|)
name|nloc
operator|+=
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
operator|+
name|round
argument_list|(
name|atol
argument_list|(
name|archdr
operator|.
name|ar_size
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Archive with table of contents. 	 * Read the table of contents and its associated string table. 	 * Pass through the library resolving symbols until nothing changes 	 * for an entire pass (i.e. you can get away with backward references 	 * when there is a table of contents!) 	 */
case|case
name|ARCH2
case|:
name|nloc
operator|=
name|SARMAG
operator|+
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|nloc
argument_list|,
sizeof|sizeof
argument_list|(
name|tnum
argument_list|)
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tnum
argument_list|,
sizeof|sizeof
argument_list|(
name|tnum
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|nloc
operator|+=
sizeof|sizeof
argument_list|(
name|tnum
argument_list|)
expr_stmt|;
name|tab
operator|=
operator|(
expr|struct
name|ranlib
operator|*
operator|)
name|mymalloc
argument_list|(
name|tnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (toc)"
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|nloc
argument_list|,
name|tnum
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|,
name|tnum
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|nloc
operator|+=
name|tnum
expr_stmt|;
name|tnum
operator|/=
sizeof|sizeof
argument_list|(
expr|struct
name|ranlib
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|nloc
argument_list|,
sizeof|sizeof
argument_list|(
name|ssiz
argument_list|)
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ssiz
argument_list|,
sizeof|sizeof
argument_list|(
name|ssiz
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|nloc
operator|+=
sizeof|sizeof
argument_list|(
name|ssiz
argument_list|)
expr_stmt|;
name|tabstr
operator|=
operator|(
name|char
operator|*
operator|)
name|mymalloc
argument_list|(
name|ssiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|tabstr
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (tocstr)"
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|nloc
argument_list|,
name|ssiz
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tabstr
argument_list|,
name|ssiz
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
operator|&
name|tab
index|[
name|tnum
index|]
init|;
operator|--
name|tp
operator|>=
name|tab
condition|;
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|ran_un
operator|.
name|ran_strx
operator|<
literal|0
operator|||
name|tp
operator|->
name|ran_un
operator|.
name|ran_strx
operator|>=
name|ssiz
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"mangled archive table of contents"
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ran_un
operator|.
name|ran_name
operator|=
name|tabstr
operator|+
name|tp
operator|->
name|ran_un
operator|.
name|ran_strx
expr_stmt|;
block|}
while|while
condition|(
name|ldrand
argument_list|()
condition|)
continue|continue;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tabstr
argument_list|)
expr_stmt|;
name|nextlibp
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Table of contents is out of date, so search 	 * as a normal library (but skip the __.SYMDEF file). 	 */
case|case
name|ARCH3
case|:
name|error
argument_list|(
operator|-
literal|1
argument_list|,
literal|"warning: table of contents for archive is out of date; rerun ranlib(1)"
argument_list|)
expr_stmt|;
name|nloc
operator|=
name|SARMAG
expr_stmt|;
do|do
name|nloc
operator|+=
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
operator|+
name|round
argument_list|(
name|atol
argument_list|(
name|archdr
operator|.
name|ar_size
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
do|while
condition|(
name|step
argument_list|(
name|nloc
argument_list|)
condition|)
do|;
break|break;
comment|/* 	 * shared library file.  	 */
case|case
name|SHLIB
case|:
comment|/* 		 * look up ldlib table to see if we need to read its symbol 		 * table. 		 */
for|for
control|(
name|tllp
operator|=
name|hldlp
init|;
name|tllp
condition|;
name|tllp
operator|=
name|tllp
operator|->
name|ll_next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tllp
operator|->
name|ll_name
argument_list|,
name|filname
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|tllp
operator|->
name|ll_flag
operator|&
name|DOREADME
operator|)
operator|||
name|dflag
operator|||
name|pflag
condition|)
name|lp
operator|=
name|rd_shsb
argument_list|(
name|filname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|p
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
comment|/* 			 * remove version string if one was specified; 			 * save shlib name, then put version string back 			 */
if|if
condition|(
operator|(
name|tpp
operator|=
name|rindex
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|tpp
operator|==
literal|'.'
operator|||
name|isdigit
argument_list|(
operator|*
name|tpp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|tpp
operator|==
literal|'.'
condition|)
name|pp
operator|=
name|tpp
expr_stmt|;
name|tpp
operator|--
expr_stmt|;
block|}
operator|*
name|pp
operator|=
literal|'\0'
expr_stmt|;
name|savestr
argument_list|(
name|p
operator|+
literal|2
argument_list|,
operator|&
name|shlibtab
argument_list|,
operator|&
name|shlibleft
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
name|savestr
argument_list|(
name|p
operator|+
literal|2
argument_list|,
operator|&
name|shlibtab
argument_list|,
operator|&
name|shlibleft
argument_list|)
expr_stmt|;
name|rtp
operator|->
name|lko
index|[
name|rtp
operator|->
name|lko_i
index|]
operator|.
name|lo_library
operator|=
literal|1
expr_stmt|;
name|rtp
operator|->
name|lko
index|[
name|rtp
operator|->
name|lko_i
index|]
operator|.
name|lo_major
operator|=
name|maj
expr_stmt|;
name|rtp
operator|->
name|lko
index|[
name|rtp
operator|->
name|lko_i
index|]
operator|.
name|lo_minor
operator|=
name|min
expr_stmt|;
name|rtp
operator|->
name|dp
operator|->
name|libstr
operator|+=
operator|(
name|strlen
argument_list|(
name|p
operator|+
literal|2
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 			 * if we are forced to define common then we need 			 * to bring in the sister library (of the form libx.sa) 			 * which is of an archive form and has all the  			 * definitions of both initialized and uninitialized 			 * commons for the shared library libx.so. 			 * if it is only -dp then we simply wanted to get the 			 * size information from the sister library (libx.sa) in 			 * order to assist later on the calcution of jump slots 			 * for relocation in non pic code. 			 */
if|if
condition|(
operator|(
name|dflag
operator|||
name|pflag
operator|)
operator|&&
operator|!
name|nosa
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|filname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|p
operator|=
name|filname
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
name|p
operator|++
expr_stmt|;
name|strncpy
argument_list|(
operator|++
name|p
argument_list|,
literal|"sa"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
name|filname
argument_list|,
name|O_RDONLY
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* 					 * +++ need to check here whether 					 * or not it is of the archive type 					 * of a file. 					 */
name|tllp
operator|->
name|ll_flag
operator||=
name|DOLOADME
expr_stmt|;
name|sa_load
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pflag
operator|&&
operator|!
name|dflag
condition|)
name|referonly
operator|=
literal|1
expr_stmt|;
name|load1arg
argument_list|(
name|filname
argument_list|)
expr_stmt|;
name|referonly
operator|=
literal|0
expr_stmt|;
name|sa_load
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|savestr
argument_list|(
name|p
argument_list|,
operator|&
name|shlibtab
argument_list|,
operator|&
name|shlibleft
argument_list|)
expr_stmt|;
name|rtp
operator|->
name|lko
index|[
name|rtp
operator|->
name|lko_i
index|]
operator|.
name|lo_library
operator|=
literal|0
expr_stmt|;
name|rtp
operator|->
name|lko
index|[
name|rtp
operator|->
name|lko_i
index|]
operator|.
name|lo_major
operator|=
literal|0
expr_stmt|;
name|rtp
operator|->
name|lko
index|[
name|rtp
operator|->
name|lko_i
index|]
operator|.
name|lo_minor
operator|=
literal|0
expr_stmt|;
name|rtp
operator|->
name|dp
operator|->
name|libstr
operator|+=
operator|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|shlibtab
operator|>
operator|&
name|shlibstr
index|[
name|SHLIBSTR
index|]
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of memory for shlib strings"
argument_list|)
expr_stmt|;
name|rtp
operator|->
name|dp
operator|->
name|lib
operator|++
expr_stmt|;
name|rtp
operator|->
name|lko_i
operator|++
expr_stmt|;
name|nosa
operator|=
literal|1
expr_stmt|;
comment|/* Don't process .sa files for cascaded refs */
while|while
condition|(
name|lp
operator|!=
literal|0
condition|)
block|{
name|getlibname
argument_list|(
name|lp
operator|->
name|libname
argument_list|)
expr_stmt|;
name|load1arg
argument_list|(
name|lp
operator|->
name|libname
argument_list|)
expr_stmt|;
name|lp
operator|=
name|lp
operator|->
name|lib_next
expr_stmt|;
block|}
name|nosa
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|close
argument_list|(
name|infil
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read symbols from shared object *name.  */
end_comment

begin_define
define|#
directive|define
name|VERSION2
value|2
end_define

begin_function
name|struct
name|lslib
modifier|*
name|rd_shsb
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
comment|/* Allocated symbol table */
name|struct
name|nlist
modifier|*
name|csp
decl_stmt|;
comment|/* Current symbol entry */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* Allocated string area */
name|int
name|i
decl_stmt|;
comment|/* General temporary */
name|int
name|fd
decl_stmt|;
comment|/* fd on *name */
name|struct
name|exec
name|exec
decl_stmt|;
comment|/* For examining header of *name */
name|struct
name|link_dynamic
name|dinfo
decl_stmt|;
comment|/* For examining dynamic structures */
name|struct
name|link_dynamic_2
name|d2
decl_stmt|;
comment|/* More of the same */
name|int
name|ssize
decl_stmt|;
comment|/* Calculated symbol table size */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* buffer for link objects */
name|struct
name|lslib
modifier|*
name|lp
init|=
literal|0
decl_stmt|,
modifier|*
modifier|*
name|lpp
init|=
operator|&
name|lp
decl_stmt|;
comment|/* 	 * Open and sanity check *name. 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"rd_shsb: can't open shared library %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|exec
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"rd_shsb: can't read struct exec for shared library %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Object's __DYNAMIC is assumed to be first thing right after 	 * text.  XXX 	 */
name|lseek
argument_list|(
name|fd
argument_list|,
name|exec
operator|.
name|a_text
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|dinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|link_dynamic
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|link_dynamic
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"rd_shsb: can't read struct dynamic for shared library %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Version check the interface and get the appropriate instantiation 	 * of the __DYNAMIC structure. 	 */
if|if
condition|(
name|dinfo
operator|.
name|ld_version
operator|<
name|VERSION2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"rd_shsb: ld no longer supports this version of %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
name|exec
operator|.
name|a_text
operator|+
sizeof|sizeof
argument_list|(
name|dinfo
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ld_debug
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|d2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|link_dynamic_2
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|d2
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"rd_shsb: ld can't read link_dynamic_2 of file %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Get the symbol table.  Note assumption of layout of dynamic  	 * information in object, namely that symbol strings immediately 	 * follow the symbol table. 	 */
name|dinfo
operator|.
name|v2
operator|=
operator|&
name|d2
expr_stmt|;
if|if
condition|(
name|dinfo
operator|.
name|v2
operator|->
name|ld_need
condition|)
block|{
name|struct
name|link_object
modifier|*
name|lko
decl_stmt|;
name|char
name|tmp
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
comment|/* 		 * get the object name. This is a bad hack... there should 		 * be a field denoting the space needed for this aera. 		 */
define|#
directive|define
name|LO_BUFSIZE
value|0x2000
name|buf
operator|=
name|malloc
argument_list|(
name|LO_BUFSIZE
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
name|dinfo
operator|.
name|v2
operator|->
name|ld_need
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|LO_BUFSIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"rd_shsb: can't read link_object stuff\n"
argument_list|)
expr_stmt|;
name|lko
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
name|buf
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|*
name|lpp
operator|=
operator|(
expr|struct
name|lslib
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lslib
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|lpp
operator|)
operator|->
name|lib_next
operator|=
operator|(
expr|struct
name|lslib
operator|*
operator|)
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
operator|+
operator|(
operator|(
name|int
operator|)
name|lko
operator|->
name|lo_name
operator|-
name|dinfo
operator|.
name|v2
operator|->
name|ld_need
operator|)
expr_stmt|;
if|if
condition|(
name|lko
operator|->
name|lo_library
condition|)
block|{
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"-l"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|buf
operator|+
operator|(
operator|(
name|int
operator|)
name|lko
operator|->
name|lo_name
operator|-
name|dinfo
operator|.
name|v2
operator|->
name|ld_need
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|lpp
operator|)
operator|->
name|libname
operator|=
name|cp
expr_stmt|;
name|lpp
operator|=
operator|&
operator|(
operator|(
operator|*
name|lpp
operator|)
operator|->
name|lib_next
operator|)
expr_stmt|;
block|}
else|else
block|{
name|cp1
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|lpp
operator|)
operator|->
name|libname
operator|=
name|cp1
expr_stmt|;
name|lpp
operator|=
operator|&
operator|(
operator|(
operator|*
name|lpp
operator|)
operator|->
name|lib_next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|lko
operator|->
name|lo_next
condition|)
name|lko
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|(
name|buf
operator|+
operator|(
name|int
operator|)
name|lko
operator|->
name|lo_next
operator|-
name|dinfo
operator|.
name|v2
operator|->
name|ld_need
operator|)
expr_stmt|;
else|else
break|break;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|ssize
operator|=
name|dinfo
operator|.
name|v2
operator|->
name|ld_symbols
operator|-
name|dinfo
operator|.
name|v2
operator|->
name|ld_stab
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|mymalloc
argument_list|(
name|ssize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"rd_shsb: out of memory for object %s with symbol size %d"
argument_list|,
name|name
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
name|dinfo
operator|.
name|v2
operator|->
name|ld_stab
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|sp
argument_list|,
name|ssize
argument_list|)
operator|!=
name|ssize
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"rd_shsb: can't read symbol table for object %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Get the strings. 	 */
if|if
condition|(
operator|(
name|str
operator|=
name|mymalloc
argument_list|(
name|dinfo
operator|.
name|v2
operator|->
name|ld_symb_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"rd_shsb: out of memory for strings for object %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
name|dinfo
operator|.
name|v2
operator|->
name|ld_symbols
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|str
argument_list|,
name|dinfo
operator|.
name|v2
operator|->
name|ld_symb_size
argument_list|)
operator|!=
name|dinfo
operator|.
name|v2
operator|->
name|ld_symb_size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"rd_shsb: can't read strings for shared library %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Process the symbols in this dynamic object. 	 */
name|csp
operator|=
name|sp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|ssize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|)
condition|;
name|i
operator|++
operator|,
name|csp
operator|++
control|)
block|{
comment|/* 		 * Chuck symbols that are not "extern". 		 */
if|if
condition|(
operator|!
operator|(
name|csp
operator|->
name|n_type
operator|&
name|N_EXT
operator|)
condition|)
continue|continue;
comment|/* 		 * Fixup pointer to allocated string area, and then 		 * get the "current" symbol. 		 */
name|csp
operator|->
name|n_un
operator|.
name|n_name
operator|=
name|str
operator|+
name|csp
operator|->
name|n_un
operator|.
name|n_strx
expr_stmt|;
name|cursym
operator|=
operator|*
name|csp
expr_stmt|;
comment|/* 		 * Add this symbol.  If it is new, we're done. 		 */
if|if
condition|(
name|enter
argument_list|(
operator|&
name|shsym
argument_list|,
name|lookup
argument_list|(
operator|&
name|shsym
argument_list|)
argument_list|,
operator|&
name|cursym
argument_list|)
condition|)
continue|continue;
call|(
modifier|*
name|dp
call|)
argument_list|(
literal|"shsb: collision with %s and %s\n"
argument_list|,
name|shsym
operator|.
name|ls
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
comment|/* 		 * Symbol collides.  If what it collided with is already 		 * defined, skip over it.   		 */
if|if
condition|(
name|shsym
operator|.
name|ls
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
condition|)
continue|continue;
call|(
modifier|*
name|dp
call|)
argument_list|(
literal|"shsb: collision was with N_EXT+N_UNDF %s\n"
argument_list|,
name|shsym
operator|.
name|ls
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
comment|/* 		 * Collision with an undefined symbol.  If the symbol we're 		 * examining is not a definition, and it has a value, then 		 * accumulate that value (e.g., common size) into the symbol 		 * we collided with.  Is this an error?  Shouldn't we check 		 * the type of the collided symbol first?  I bet so... 		 */
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|==
name|N_EXT
operator|+
name|N_UNDF
condition|)
block|{
if|if
condition|(
name|cursym
operator|.
name|n_value
operator|>
name|shsym
operator|.
name|ls
operator|->
name|n_value
condition|)
name|shsym
operator|.
name|ls
operator|->
name|n_value
operator|=
name|cursym
operator|.
name|n_value
expr_stmt|;
continue|continue;
block|}
call|(
modifier|*
name|dp
call|)
argument_list|(
literal|"shsb: collision because of new definition of %s, type %x, value %x\n"
argument_list|,
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|cursym
operator|.
name|n_type
argument_list|,
name|cursym
operator|.
name|n_value
argument_list|)
expr_stmt|;
comment|/* 		 * Symbol we're adding is a definition of some kind.  If 		 * the symbol we collided with already has a value, and 		 * the addition is in text, then we're done. 		 * XXX Why? 		 */
if|if
condition|(
name|shsym
operator|.
name|ls
operator|->
name|n_value
operator|!=
literal|0
operator|&&
name|cursym
operator|.
name|n_type
operator|==
name|N_EXT
operator|+
name|N_TEXT
condition|)
continue|continue;
call|(
modifier|*
name|dp
call|)
argument_list|(
literal|"shsb: collision adds a definition for a reference\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Symbol we're adding is a definition for a symbol we already 		 * have a reference for.  Replace the reference with the 		 * definition and value we're supplying now. 		 */
name|shsym
operator|.
name|ls
operator|->
name|n_type
operator|=
name|cursym
operator|.
name|n_type
expr_stmt|;
name|shsym
operator|.
name|ls
operator|->
name|n_value
operator|=
name|cursym
operator|.
name|n_value
expr_stmt|;
block|}
comment|/* 	 * Leave the symbol strings intact, but free up the symbol table 	 * scratch space we've allocated and get rid of the descriptor on 	 * the library. 	 */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Advance to the next archive member, which  * is at offset nloc in the archive.  If the member  * is useful, record its location in the liblist structure  * for use in pass2.  Mark the end of the archive in libilst with a -1.  */
end_comment

begin_macro
name|step
argument_list|(
argument|nloc
argument_list|)
end_macro

begin_decl_stmt
name|off_t
name|nloc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|nloc
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
block|{
name|nextlibp
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|getarhdr
argument_list|()
expr_stmt|;
call|(
modifier|*
name|dp
call|)
argument_list|(
literal|"step: %.16s\n"
argument_list|,
name|archdr
operator|.
name|ar_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|load1
argument_list|(
literal|1
argument_list|,
name|nloc
operator|+
operator|(
sizeof|sizeof
name|archdr
operator|)
argument_list|)
condition|)
name|nextlibp
argument_list|(
name|nloc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Record the location of a useful archive member.  * Recording -1 marks the end of files from an archive.  * The liblist data structure is dynamically extended here.  */
end_comment

begin_macro
name|nextlibp
argument_list|(
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|off_t
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|clibseg
operator|->
name|li_used
operator|==
name|NROUT
condition|)
block|{
if|if
condition|(
operator|++
name|clibseg
operator|==
operator|&
name|libseg
index|[
name|NSEG
index|]
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"too many files loaded from libraries"
argument_list|)
expr_stmt|;
name|clibseg
operator|->
name|li_first
operator|=
operator|(
name|off_t
operator|*
operator|)
name|mymalloc
argument_list|(
name|NROUT
operator|*
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clibseg
operator|->
name|li_first
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (nextlibp)"
argument_list|)
expr_stmt|;
block|}
name|clibseg
operator|->
name|li_first
index|[
name|clibseg
operator|->
name|li_used
operator|++
index|]
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|val
operator|!=
operator|-
literal|1
operator|&&
name|Mflag
condition|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|archdr
operator|.
name|ar_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * One pass over an archive with a table of contents.  * Remember the number of symbols currently defined,  * then call step on members which look promising (i.e.  * that define a symbol which is currently externally undefined).  * Indicate to our caller whether this process netted any more symbols.  */
end_comment

begin_macro
name|ldrand
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|,
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|ranlib
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tplast
decl_stmt|;
name|off_t
name|loc
decl_stmt|;
name|int
name|nsymt
init|=
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|ldsym
operator|.
name|ns
argument_list|)
decl_stmt|;
name|tplast
operator|=
operator|&
name|tab
index|[
name|tnum
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|tab
init|;
name|tp
operator|<=
name|tplast
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|slookup
argument_list|(
name|tp
operator|->
name|ran_un
operator|.
name|ran_name
argument_list|,
operator|&
name|ldsym
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|hp
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|sp
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
condition|)
continue|continue;
else|else
goto|goto
name|stepit
goto|;
name|next
label|:
if|if
condition|(
name|sa_load
condition|)
continue|continue;
if|if
condition|(
operator|(
name|hp
operator|=
name|slookup
argument_list|(
name|tp
operator|->
name|ran_un
operator|.
name|ran_name
argument_list|,
operator|&
name|shsym
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|hp
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
condition|)
continue|continue;
name|stepit
label|:
name|step
argument_list|(
name|tp
operator|->
name|ran_off
argument_list|)
expr_stmt|;
name|loc
operator|=
name|tp
operator|->
name|ran_off
expr_stmt|;
while|while
condition|(
name|tp
operator|<
name|tplast
operator|&&
operator|(
name|tp
operator|+
literal|1
operator|)
operator|->
name|ran_off
operator|==
name|loc
condition|)
name|tp
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|ldsym
operator|.
name|ns
argument_list|)
operator|!=
name|nsymt
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Examine a single file or archive member on pass 1.  */
end_comment

begin_macro
name|load1
argument_list|(
argument|libflg
argument_list|,
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|off_t
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|local
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|struct
name|nlist
modifier|*
name|savnext
decl_stmt|;
name|int
name|ndef
decl_stmt|,
name|nlocal
decl_stmt|,
name|type
decl_stmt|,
name|size
decl_stmt|,
name|nsymt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|off_t
name|maxoff
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|int
name|symno
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|csp
decl_stmt|;
name|off_t
name|saveloc
init|=
name|loc
decl_stmt|;
name|struct
name|nlist
modifier|*
modifier|*
name|hp
decl_stmt|;
name|int
name|lpicflag
decl_stmt|;
specifier|static
name|int
name|symsize
init|=
literal|0
decl_stmt|;
name|new_obj1
argument_list|()
expr_stmt|;
name|readhdr
argument_list|(
name|loc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LHSIZ
condition|;
name|i
operator|++
control|)
name|lochash
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|clocseg
operator|=
name|locseg
expr_stmt|;
name|clocseg
operator|->
name|lo_used
operator|=
literal|0
expr_stmt|;
name|symno
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|loc_symb
operator|==
literal|0
condition|)
block|{
name|symsize
operator|=
name|filhdr
operator|.
name|a_syms
expr_stmt|;
name|loc_symb
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|calloc
argument_list|(
name|filhdr
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|local
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc_symb
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of memory for relocation symbols"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * check if number of symbols of current file exceed  		 * the last one, if so free up the last one and allocate 		 * a new one. 		 */
if|if
condition|(
name|filhdr
operator|.
name|a_syms
operator|>
name|symsize
condition|)
block|{
name|symsize
operator|=
name|filhdr
operator|.
name|a_syms
expr_stmt|;
name|free
argument_list|(
name|loc_symb
argument_list|)
expr_stmt|;
name|loc_symb
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|calloc
argument_list|(
name|symsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|local
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc_symb
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of memory for relocation symbols"
argument_list|)
expr_stmt|;
block|}
block|}
name|csp
operator|=
name|loc_symb
expr_stmt|;
if|if
condition|(
name|filhdr
operator|.
name|a_syms
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|libflg
operator|==
literal|0
condition|)
block|{
name|ssize
operator|+=
sizeof|sizeof
argument_list|(
name|cursym
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
argument_list|(
literal|1
argument_list|,
literal|"no namelist"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|libflg
condition|)
name|maxoff
operator|=
name|atol
argument_list|(
name|archdr
operator|.
name|ar_size
argument_list|)
expr_stmt|;
else|else
block|{
name|fstat
argument_list|(
name|infil
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
name|maxoff
operator|=
name|stb
operator|.
name|st_size
expr_stmt|;
block|}
if|if
condition|(
name|N_STROFF
argument_list|(
name|filhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
operator|>=
name|maxoff
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"too small (old format .o?)"
argument_list|)
expr_stmt|;
name|ctrel
operator|=
name|tsize
expr_stmt|;
name|cdrel
operator|+=
name|dsize
expr_stmt|;
name|cbrel
operator|+=
name|bsize
expr_stmt|;
name|ndef
operator|=
literal|0
expr_stmt|;
name|nlocal
operator|=
sizeof|sizeof
argument_list|(
name|cursym
argument_list|)
expr_stmt|;
name|savnext
operator|=
name|ldsym
operator|.
name|ns
expr_stmt|;
name|loc
operator|+=
name|N_SYMOFF
argument_list|(
name|filhdr
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_syms
argument_list|,
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|&
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|size
argument_list|)
argument_list|,
operator|&
name|reloc
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_syms
operator|+
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
name|curstr
operator|=
operator|(
name|char
operator|*
operator|)
name|mymalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|curstr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"no space for string table"
argument_list|)
expr_stmt|;
name|mget
argument_list|(
name|curstr
operator|+
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
operator|&
name|reloc
argument_list|)
expr_stmt|;
comment|/* 	 * If we are -r'ing a -pic file, we need to "globalize" local 	 * symbols so they're around when the output gets passed through 	 * us again. 	 */
name|lpicflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
name|filhdr
operator|.
name|a_syms
argument_list|)
expr_stmt|;
while|while
condition|(
name|text
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cursym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|<
sizeof|sizeof
argument_list|(
name|size
argument_list|)
operator|||
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|>=
name|size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad string table index (pic pass 1)"
argument_list|)
expr_stmt|;
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|curstr
operator|+
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
if|if
condition|(
name|ISGT
argument_list|(
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
block|{
name|lpicflag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*  	 * Now process each symbol. 	 */
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
name|filhdr
operator|.
name|a_syms
argument_list|)
expr_stmt|;
while|while
condition|(
name|text
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|symno
operator|++
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cursym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
condition|)
block|{
if|if
condition|(
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|<
sizeof|sizeof
argument_list|(
name|size
argument_list|)
operator|||
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|>=
name|size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad string table index (pass 1)"
argument_list|)
expr_stmt|;
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|curstr
operator|+
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
ifdef|#
directive|ifdef
name|BROWSER
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|==
name|N_BROWS
condition|)
block|{
if|if
condition|(
operator|!
name|cb_ranlib_saw_library_name
condition|)
block|{
name|cb_ranlib_saw_library_name
operator|=
literal|1
expr_stmt|;
name|cb_ranlib_start_library
argument_list|(
name|aoutname
argument_list|,
name|CB_CURRENT_LANGUAGE
argument_list|,
name|CB_CURRENT_MAJOR_VERSION
argument_list|,
name|CB_CURRENT_MINOR_VERSION
argument_list|,
name|CB_EX_FOCUS_UNIT_PROGRAM_FORMAT
argument_list|)
expr_stmt|;
block|}
name|cb_ranlib_symbol
argument_list|(
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|cb_focus_program_unit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
call|(
modifier|*
name|dp
call|)
argument_list|(
literal|"load1: %s\t%x\t%x\n"
argument_list|,
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|cursym
operator|.
name|n_type
argument_list|,
name|cursym
operator|.
name|n_value
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|cursym
operator|.
name|n_type
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|N_STAB
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|N_BINCL
condition|)
block|{
name|start_incl1
argument_list|(
operator|&
name|cursym
argument_list|,
name|header_num
argument_list|)
expr_stmt|;
name|header_num
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|N_EINCL
condition|)
block|{
name|end_incl1
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|stab1
argument_list|(
operator|&
name|cursym
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * do not keep track of any dbx symbols for load1reloc 		 * +++ is it safe? 		 */
if|if
condition|(
operator|!
operator|(
name|type
operator|&
name|N_STAB
operator|)
condition|)
block|{
if|if
condition|(
name|csp
operator|>
name|loc_symb
operator|+
operator|(
name|symsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"load1: ran out of local symbol space"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clocseg
operator|->
name|lo_used
operator|==
name|NSYMPR
condition|)
block|{
if|if
condition|(
operator|++
name|clocseg
operator|==
operator|&
name|locseg
index|[
name|NSEG
index|]
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"local symbol overflow"
argument_list|)
expr_stmt|;
name|clocseg
operator|->
name|lo_used
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|clocseg
operator|->
name|lo_first
operator|==
literal|0
condition|)
block|{
name|clocseg
operator|->
name|lo_first
operator|=
operator|(
expr|struct
name|local
operator|*
operator|)
name|calloc
argument_list|(
name|NSYMPR
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|local
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clocseg
operator|->
name|lo_first
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of memory (clocseg)"
argument_list|)
expr_stmt|;
block|}
name|lp
operator|=
operator|&
name|clocseg
operator|->
name|lo_first
index|[
name|clocseg
operator|->
name|lo_used
operator|++
index|]
expr_stmt|;
name|lp
operator|->
name|l_index
operator|=
name|symno
expr_stmt|;
operator|*
name|csp
operator|=
name|cursym
expr_stmt|;
name|lp
operator|->
name|l_symbol
operator|=
name|csp
operator|++
expr_stmt|;
name|lp
operator|->
name|l_link
operator|=
name|lochash
index|[
name|symno
operator|%
name|LHSIZ
index|]
expr_stmt|;
name|lochash
index|[
name|symno
operator|%
name|LHSIZ
index|]
operator|=
name|lp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|N_EXT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * compiling with pic flag generated local symbol 			 * and we dont wanted to write these back out. 			 */
if|if
condition|(
name|type
operator|&
name|N_STAB
operator|||
name|cursym
operator|.
name|n_un
operator|.
name|n_name
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|||
operator|(
name|rflag
operator|&&
name|cursym
operator|.
name|n_un
operator|.
name|n_name
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
operator|(
name|lpicflag
operator|)
operator|)
condition|)
name|nlocal
operator|+=
sizeof|sizeof
name|cursym
expr_stmt|;
continue|continue;
block|}
name|symreloc
argument_list|()
expr_stmt|;
comment|/* 		 * Make an entry for this symbol.  If it is new, then 		 * see if a dynamic object has referenced it.  If it has, 		 * then calculate any common contributions or, if this 		 * symbol contributes a definition, increment count of 		 * definitions seen. 		 * 		 * If the symbol is not new, then see if other references 		 * have now been satisfied or calculate this symbol's 		 * common contribution (if appropriate).  If this symbol 		 * satisfies a previously undefined reference, then bump count 		 * of definitions seen. 		 */
if|if
condition|(
name|enter
argument_list|(
operator|&
name|ldsym
argument_list|,
name|lookup
argument_list|(
operator|&
name|ldsym
argument_list|)
argument_list|,
operator|&
name|cursym
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
operator|&
name|shsym
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|*
name|hp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|*
name|hp
operator|)
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
condition|)
continue|continue;
if|if
condition|(
name|ldsym
operator|.
name|ls
operator|->
name|n_type
operator|==
name|N_EXT
operator|+
name|N_UNDF
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|hp
operator|)
operator|->
name|n_value
operator|>
name|ldsym
operator|.
name|ls
operator|->
name|n_value
condition|)
name|ldsym
operator|.
name|ls
operator|->
name|n_value
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|n_value
expr_stmt|;
block|}
else|else
name|ndef
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sp
operator|=
name|ldsym
operator|.
name|ls
operator|)
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
condition|)
continue|continue;
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|==
name|N_EXT
operator|+
name|N_UNDF
condition|)
block|{
if|if
condition|(
name|cursym
operator|.
name|n_value
operator|>
name|sp
operator|->
name|n_value
condition|)
name|sp
operator|->
name|n_value
operator|=
name|cursym
operator|.
name|n_value
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|referonly
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|n_value
operator|!=
literal|0
operator|&&
name|cursym
operator|.
name|n_type
operator|==
name|N_EXT
operator|+
name|N_TEXT
condition|)
continue|continue;
name|ndef
operator|++
expr_stmt|;
name|sp
operator|->
name|n_type
operator|=
name|cursym
operator|.
name|n_type
expr_stmt|;
name|sp
operator|->
name|n_value
operator|=
name|cursym
operator|.
name|n_value
expr_stmt|;
block|}
block|}
if|if
condition|(
name|libflg
operator|==
literal|0
operator|||
name|ndef
condition|)
block|{
name|tsize
operator|+=
name|filhdr
operator|.
name|a_text
expr_stmt|;
name|dsize
operator|+=
name|round
argument_list|(
name|filhdr
operator|.
name|a_data
argument_list|,
name|seground
argument_list|()
argument_list|)
expr_stmt|;
name|bsize
operator|+=
name|round
argument_list|(
name|filhdr
operator|.
name|a_bss
argument_list|,
name|seground
argument_list|()
argument_list|)
expr_stmt|;
name|ssize
operator|+=
name|nlocal
expr_stmt|;
name|trsize
operator|+=
name|filhdr
operator|.
name|a_trsize
expr_stmt|;
name|drsize
operator|+=
name|filhdr
operator|.
name|a_drsize
expr_stmt|;
if|if
condition|(
name|funding
condition|)
block|{
if|if
condition|(
name|textbase
operator|==
operator|-
literal|1
operator|&&
name|Tflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|slookup
argument_list|(
literal|"_end"
argument_list|,
operator|&
name|ldsym
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|"base address is not provided, use option \"-T\" or link the fundamental file with option \"-u _end\""
argument_list|)
expr_stmt|;
block|}
name|textbase
operator|=
operator|(
operator|*
name|slookup
argument_list|(
literal|"_end"
argument_list|,
operator|&
name|ldsym
argument_list|)
operator|)
operator|->
name|n_value
expr_stmt|;
block|}
block|}
name|nsymt
operator|=
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|ldsym
operator|.
name|ns
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|savnext
argument_list|)
init|;
name|i
operator|<
name|nsymt
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|xsym
argument_list|(
name|ldsym
operator|.
name|fs
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
condition|)
block|{
name|rtp
operator|->
name|fsalloc
operator|+=
name|strlen
argument_list|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|sp
operator|->
name|n_un
operator|.
name|n_name
operator|=
name|savestr
argument_list|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
operator|&
name|savetab
argument_list|,
operator|&
name|saveleft
argument_list|)
expr_stmt|;
block|}
block|}
name|load1rel
argument_list|(
name|saveloc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curstr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * No symbols defined by this library member. 	 * Rip out the hash table entries and reset the symbol table. 	 */
name|incl_free
argument_list|()
expr_stmt|;
name|symfree
argument_list|(
operator|&
name|ldsym
argument_list|,
name|savnext
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curstr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|TEXTSEG
value|0
end_define

begin_define
define|#
directive|define
name|DATASEG
value|1
end_define

begin_decl_stmt
name|struct
name|dslot
name|sl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rl
name|rl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|relocused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This routine looked all the relocation datums to determine how   * much space is needed for pic data, pic static, pic and force allocation  * of a jump entry.  */
end_comment

begin_macro
name|load1rel
argument_list|(
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|off_t
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/*  	 * reintialize static pic stuff after each module 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LHSIZ
condition|;
name|i
operator|++
control|)
name|stpichash
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|stpic
operator|=
name|stpicseg
expr_stmt|;
name|stpicseg
operator|->
name|sls_used
operator|=
literal|0
expr_stmt|;
name|loc
operator|+=
name|N_TXTOFF
argument_list|(
name|filhdr
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
name|filhdr
operator|.
name|a_text
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
argument_list|,
name|filhdr
operator|.
name|a_trsize
argument_list|)
expr_stmt|;
name|load1reltd
argument_list|(
name|TEXTSEG
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
argument_list|,
name|filhdr
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
argument_list|,
name|filhdr
operator|.
name|a_drsize
argument_list|)
expr_stmt|;
name|load1reltd
argument_list|(
name|DATASEG
argument_list|)
expr_stmt|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|relocation_info
end_undef

begin_if
if|#
directive|if
name|TARGET
operator|==
name|SUN4
end_if

begin_define
define|#
directive|define
name|relocation_info
value|reloc_info_sparc
end_define

begin_define
define|#
directive|define
name|r_symbolnum
value|r_index
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
end_if

begin_define
define|#
directive|define
name|relocation_info
value|reloc_info_68k
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* mc68000 */
end_comment

begin_comment
comment|/*  * Get symbol local to the object file being relocated.  */
end_comment

begin_function
specifier|static
name|struct
name|nlist
modifier|*
name|getlocsymb
parameter_list|(
name|rp
parameter_list|)
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|;
block|{
specifier|register
name|struct
name|local
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
name|lochash
index|[
name|rp
operator|->
name|r_symbolnum
operator|%
name|LHSIZ
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"object file inconsistency: nonexistent symbol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|l_index
operator|==
name|rp
operator|->
name|r_symbolnum
condition|)
break|break;
name|lp
operator|=
name|lp
operator|->
name|l_link
expr_stmt|;
block|}
return|return
operator|(
name|lp
operator|->
name|l_symbol
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|picflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|load1reltd
argument_list|(
argument|seg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|seg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|,
modifier|*
name|rpend
decl_stmt|;
specifier|register
name|struct
name|slsymb
modifier|*
name|ps
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|relp
decl_stmt|;
name|char
modifier|*
name|codep
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|relsz
decl_stmt|,
name|codesz
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|relsz
operator|=
name|reloc
operator|.
name|size
expr_stmt|;
name|relp
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|mymalloc
argument_list|(
name|relsz
argument_list|)
expr_stmt|;
name|codesz
operator|=
name|text
operator|.
name|size
expr_stmt|;
name|codep
operator|=
operator|(
name|char
operator|*
operator|)
name|mymalloc
argument_list|(
name|codesz
argument_list|)
expr_stmt|;
if|if
condition|(
name|relp
operator|==
literal|0
operator|||
name|codep
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of memory (load2td)"
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
name|relp
argument_list|,
name|relsz
argument_list|,
operator|&
name|reloc
argument_list|)
expr_stmt|;
name|rpend
operator|=
operator|&
name|relp
index|[
name|relsz
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
index|]
expr_stmt|;
name|mget
argument_list|(
name|codep
argument_list|,
name|codesz
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|relp
init|;
name|rp
operator|<
name|rpend
condition|;
name|rp
operator|++
control|)
block|{
comment|/* 		 * keep track of the global separeted from the local references 		 */
if|#
directive|if
name|TARGET
operator|==
name|SUN4
switch|switch
condition|(
name|rp
operator|->
name|r_type
condition|)
block|{
comment|/* 		     * skip relocation for __GLOBAL_OFFSET_TABLE_  		     */
case|case
name|RELOC_PC22
case|:
case|case
name|RELOC_PC10
case|:
continue|continue;
case|case
name|RELOC_BASE13
case|:
case|case
name|RELOC_BASE10
case|:
case|case
name|RELOC_BASE22
case|:
if|if
condition|(
operator|!
name|picflag
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_type
operator|==
name|RELOC_BASE13
condition|)
name|picflag
operator|=
literal|1
expr_stmt|;
else|else
name|picflag
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|picflag
operator|==
literal|1
operator|&&
name|rp
operator|->
name|r_type
operator|!=
name|RELOC_BASE13
operator|)
operator|||
operator|(
name|picflag
operator|==
literal|2
operator|&&
operator|!
operator|(
name|rp
operator|->
name|r_type
operator|==
name|RELOC_BASE10
operator|||
name|rp
operator|->
name|r_type
operator|==
name|RELOC_BASE22
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"can't mixed pic and PIC .o"
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|getlocsymb
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_extern
condition|)
block|{
name|ps
operator|=
name|sllookup
argument_list|(
operator|&
name|dpic
argument_list|,
operator|&
name|dpicseg
index|[
name|NSEG
index|]
argument_list|,
name|dpichash
argument_list|,
name|sp
argument_list|,
name|rp
operator|->
name|r_addend
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|sl_new
condition|)
name|sl
operator|.
name|ds
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ps
operator|=
name|sllookup
argument_list|(
operator|&
name|stpic
argument_list|,
operator|&
name|stpicseg
index|[
name|NSEG
index|]
argument_list|,
name|stpichash
argument_list|,
name|sp
argument_list|,
name|rp
operator|->
name|r_addend
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|sl_new
condition|)
name|sl
operator|.
name|ss
operator|++
expr_stmt|;
block|}
continue|continue;
case|case
name|RELOC_JMP_TBL
case|:
name|sp
operator|=
name|getlocsymb
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|ps
operator|=
name|sllookup
argument_list|(
operator|&
name|tpic
argument_list|,
operator|&
name|tpicseg
index|[
name|NSEG
index|]
argument_list|,
name|tpichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|sl_new
condition|)
name|sl
operator|.
name|js
operator|++
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
name|cp
operator|=
name|codep
operator|+
name|rp
operator|->
name|r_address
expr_stmt|;
switch|switch
condition|(
name|rp
operator|->
name|r_length
condition|)
block|{
case|case
literal|0
case|:
comment|/* byte */
name|offset
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* word */
name|offset
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* long */
comment|/* "cp" points to an least a 16-bit boundary, but 			 * not necessarily a 32-bit boundary. 			 */
ifdef|#
directive|ifdef
name|mc68000
comment|/* 68k host can do long accesses on 16-bit boundaries */
name|offset
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
expr_stmt|;
else|#
directive|else
comment|/*!mc68000*/
comment|/* others can only do long accesses on 32-bit bdy's */
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
operator|&
name|offset
operator|)
operator|)
operator|=
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
name|cp
operator|)
expr_stmt|;
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|offset
operator|)
operator|)
operator|+
literal|2
operator|)
operator|)
operator|=
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|cp
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/*mc68000*/
break|break;
default|default:
name|error
argument_list|(
literal|1
argument_list|,
literal|"load1reltd botch: bad length"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|r_baserel
operator|||
name|rp
operator|->
name|r_jmptable
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_jmptable
operator|&&
operator|!
name|rp
operator|->
name|r_extern
condition|)
continue|continue;
name|sp
operator|=
name|getlocsymb
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_baserel
condition|)
block|{
if|if
condition|(
operator|!
name|picflag
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_length
operator|==
literal|1
condition|)
name|picflag
operator|=
literal|1
expr_stmt|;
else|else
name|picflag
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|picflag
operator|==
literal|1
operator|&&
name|rp
operator|->
name|r_length
operator|==
literal|2
operator|)
operator|||
operator|(
name|picflag
operator|==
literal|2
operator|&&
name|rp
operator|->
name|r_length
operator|==
literal|1
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"can't mixed pic and PIC .o"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rp
operator|->
name|r_extern
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_baserel
condition|)
block|{
name|ps
operator|=
name|sllookup
argument_list|(
operator|&
name|dpic
argument_list|,
operator|&
name|dpicseg
index|[
name|NSEG
index|]
argument_list|,
name|dpichash
argument_list|,
name|sp
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|sl_new
condition|)
name|sl
operator|.
name|ds
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|r_jmptable
condition|)
block|{
name|ps
operator|=
name|sllookup
argument_list|(
operator|&
name|tpic
argument_list|,
operator|&
name|tpicseg
index|[
name|NSEG
index|]
argument_list|,
name|tpichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|sl_new
condition|)
name|sl
operator|.
name|js
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rp
operator|->
name|r_baserel
condition|)
block|{
name|ps
operator|=
name|sllookup
argument_list|(
operator|&
name|stpic
argument_list|,
operator|&
name|stpicseg
index|[
name|NSEG
index|]
argument_list|,
name|stpichash
argument_list|,
name|sp
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|sl_new
condition|)
name|sl
operator|.
name|ss
operator|++
expr_stmt|;
block|}
block|}
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|seg
operator|==
name|DATASEG
condition|)
block|{
name|rl
operator|.
name|rl_d
operator|++
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_extern
condition|)
block|{
name|sp
operator|=
name|getlocsymb
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
if|if
condition|(
name|rp
operator|->
name|r_pcrel
operator|&&
name|ISGT
argument_list|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
name|rl
operator|.
name|rl_d
operator|--
expr_stmt|;
else|else
block|{
name|rl
operator|.
name|rl_de
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sllookup
argument_list|(
operator|&
name|npic
argument_list|,
operator|&
name|npicseg
index|[
name|NSEG
index|]
argument_list|,
name|npichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|rl
operator|.
name|rl_de
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sllookup
argument_list|(
operator|&
name|npic
argument_list|,
operator|&
name|npicseg
index|[
name|NSEG
index|]
argument_list|,
name|npichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* 			 * dont count if symbol is "__GLOBAL_OFFSET_TABLE_" 			 */
name|rl
operator|.
name|rl_t
operator|++
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_extern
condition|)
block|{
name|sp
operator|=
name|getlocsymb
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|rl
operator|.
name|rl_te
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sllookup
argument_list|(
operator|&
name|npic
argument_list|,
operator|&
name|npicseg
index|[
name|NSEG
index|]
argument_list|,
name|npichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
if|if
condition|(
name|rp
operator|->
name|r_pcrel
operator|&&
name|ISGT
argument_list|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
name|rl
operator|.
name|rl_t
operator|--
expr_stmt|;
else|else
block|{
name|rl
operator|.
name|rl_te
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sllookup
argument_list|(
operator|&
name|npic
argument_list|,
operator|&
name|npicseg
index|[
name|NSEG
index|]
argument_list|,
name|npichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
block|}
name|free
argument_list|(
name|relp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|codep
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * this is a generalized routine to do look up on 3 sort of lists:  * the static, data and jump pic list. The static list is only good per  * module basis while the data and jump list span to all modules.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|psavetab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for symbols needed by load1rel */
end_comment

begin_decl_stmt
name|int
name|psaveleft
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|slsymb
modifier|*
name|sllookup
parameter_list|(
name|slsseg
parameter_list|,
name|endseg
parameter_list|,
name|slslot
parameter_list|,
name|sp
parameter_list|,
name|offset
parameter_list|,
name|save
parameter_list|,
name|lo
parameter_list|)
name|struct
name|slsseg
modifier|*
modifier|*
name|slsseg
decl_stmt|;
name|struct
name|slsseg
modifier|*
name|endseg
decl_stmt|;
name|struct
name|slsymb
modifier|*
name|slslot
index|[]
decl_stmt|;
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|save
decl_stmt|;
name|int
name|lo
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|slsymb
modifier|*
name|ps
decl_stmt|;
name|struct
name|slsymb
modifier|*
name|slfindit
parameter_list|()
function_decl|;
name|i
operator|=
name|hashit
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ps
operator|=
name|slfindit
argument_list|(
name|slslot
argument_list|,
name|sp
argument_list|,
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
literal|0
condition|)
block|{
name|ps
operator|->
name|sl_rc
operator|++
expr_stmt|;
return|return
operator|(
name|ps
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|slsseg
operator|)
operator|->
name|sls_used
operator|==
name|NSYMPR
condition|)
block|{
if|if
condition|(
operator|++
operator|(
operator|*
name|slsseg
operator|)
operator|==
name|endseg
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"pic symbol overflow"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|slsseg
operator|)
operator|->
name|sls_used
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|slsseg
operator|)
operator|->
name|sls_first
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|slsseg
operator|)
operator|->
name|sls_first
operator|=
name|ps
operator|=
operator|(
expr|struct
name|slsymb
operator|*
operator|)
name|calloc
argument_list|(
name|NSYMPR
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|slsymb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|slsseg
operator|)
operator|->
name|sls_first
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of memory(slsseg)"
argument_list|)
expr_stmt|;
block|}
name|ps
operator|=
operator|&
operator|(
operator|*
name|slsseg
operator|)
operator|->
name|sls_first
index|[
operator|(
operator|*
name|slsseg
operator|)
operator|->
name|sls_used
operator|++
index|]
expr_stmt|;
name|ps
operator|->
name|sl_offset
operator|=
name|offset
expr_stmt|;
name|ps
operator|->
name|sl_symbol
operator|=
operator|*
name|sp
expr_stmt|;
if|if
condition|(
name|save
condition|)
block|{
name|ps
operator|->
name|sl_symbol
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|savestr
argument_list|(
name|ps
operator|->
name|sl_symbol
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
operator|&
name|psavetab
argument_list|,
operator|&
name|psaveleft
argument_list|)
expr_stmt|;
block|}
name|ps
operator|->
name|sl_link
operator|=
name|slslot
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * a value of -1 for the linkoffset  means that no slot is assigned 	 * for this symbol yet. 	 */
name|ps
operator|->
name|sl_lo
operator|=
name|lo
expr_stmt|;
name|ps
operator|->
name|sl_new
operator|=
literal|1
expr_stmt|;
name|ps
operator|->
name|sl_rc
operator|++
expr_stmt|;
name|slslot
index|[
name|i
index|]
operator|=
name|ps
expr_stmt|;
return|return
operator|(
name|ps
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hashit
parameter_list|(
name|sp
parameter_list|)
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|sp
operator|->
name|n_un
operator|.
name|n_name
init|;
operator|*
name|cp
condition|;
control|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
operator|*
name|cp
operator|++
expr_stmt|;
return|return
operator|(
operator|(
name|i
operator|&
literal|0x7fffffff
operator|)
operator|%
name|LHSIZ
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|slsymb
modifier|*
name|slfindit
parameter_list|(
name|slslot
parameter_list|,
name|sp
parameter_list|,
name|offset
parameter_list|,
name|slot
parameter_list|)
name|struct
name|slsymb
modifier|*
name|slslot
index|[]
decl_stmt|;
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|struct
name|slsymb
modifier|*
name|ps
decl_stmt|;
comment|/* now compare name,offset pair */
name|ps
operator|=
name|slslot
index|[
name|slot
index|]
expr_stmt|;
while|while
condition|(
name|ps
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ps
operator|->
name|sl_symbol
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|sl_offset
operator|==
name|offset
condition|)
block|{
name|ps
operator|->
name|sl_new
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ps
operator|)
return|;
block|}
block|}
name|ps
operator|=
name|ps
operator|->
name|sl_link
expr_stmt|;
block|}
return|return
operator|(
name|ps
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * How the fast symbol hash table is build:  * 	- There can be at most (dataslot + jumpslot) number of hash slots  *	of which the first RTHS slot are the initial buckets. Each  * 	bucket has 2 items: one denoting the ordinal symbol number  *	the other one a pointer in the form of an index to the slots  *	following the first RTHS slots.  *	- Following right after the hash table for the symbols are the  *	symbols themselves followed by the strings.  */
end_comment

begin_comment
comment|/*   * This routine look up to the hash table for dynamic symbols.  * return the ordinal symbol number if symbol is found  * else add the symbol and return a -1    */
end_comment

begin_function
name|int
name|fslookup
parameter_list|(
name|sp
parameter_list|,
name|rt
parameter_list|)
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|runtime
modifier|*
name|rt
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|fshash
modifier|*
name|p
decl_stmt|;
name|struct
name|nlist
modifier|*
name|sp1
init|=
name|rt
operator|->
name|sp
decl_stmt|;
specifier|static
name|int
name|fs
init|=
literal|0
decl_stmt|;
comment|/* ordinal number for next symbol */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|sp
operator|->
name|n_un
operator|.
name|n_name
init|;
operator|*
name|cp
condition|;
control|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
operator|*
name|cp
operator|++
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|&
literal|0x7fffffff
operator|)
operator|%
name|rt
operator|->
name|buckets
expr_stmt|;
name|p
operator|=
name|rt
operator|->
name|hp
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fssymbno
operator|==
operator|-
literal|1
condition|)
block|{
name|p
operator|->
name|fssymbno
operator|=
name|fs
operator|++
expr_stmt|;
name|addfs
argument_list|(
name|sp
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
name|rt
operator|->
name|fsstr
operator|+
operator|(
name|sp1
operator|+
name|p
operator|->
name|fssymbno
operator|)
operator|->
name|n_un
operator|.
name|n_strx
argument_list|)
condition|)
return|return
operator|(
name|p
operator|->
name|fssymbno
operator|)
return|;
elseif|else
if|if
condition|(
name|p
operator|->
name|next
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|next
operator|=
name|rt
operator|->
name|hp_ind
expr_stmt|;
name|p
operator|=
name|rt
operator|->
name|hp
operator|+
name|rt
operator|->
name|hp_ind
expr_stmt|;
name|rt
operator|->
name|hp_ind
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|rt
operator|->
name|hp_last
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of hash space"
argument_list|)
expr_stmt|;
name|p
operator|->
name|fssymbno
operator|=
name|fs
operator|++
expr_stmt|;
name|p
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|addfs
argument_list|(
name|sp
argument_list|,
name|rt
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|p
operator|=
name|rt
operator|->
name|hp
operator|+
name|p
operator|->
name|next
condition|)
do|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_expr_stmt
name|addfs
argument_list|(
name|sp
argument_list|,
name|rt
argument_list|)
specifier|register
expr|struct
name|nlist
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|runtime
modifier|*
name|rt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|sp
operator|->
name|n_un
operator|.
name|n_name
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
operator|*
operator|(
name|rt
operator|->
name|spp
operator|)
operator|=
operator|*
name|sp
expr_stmt|;
name|rt
operator|->
name|spp
operator|->
name|n_un
operator|.
name|n_strx
operator|=
name|rt
operator|->
name|fsoff
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|rt
operator|->
name|fsstr
operator|+
name|rt
operator|->
name|fsoff
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|rt
operator|->
name|fsoff
operator|+=
name|len
expr_stmt|;
name|rt
operator|->
name|spp
operator|++
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|spp
operator|>
name|rt
operator|->
name|sp_last
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of dynamic symbol space"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|fsoff
operator|>
name|rtp
operator|->
name|fsalloc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of string space"
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|nund
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|undbanner
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ck_shs
parameter_list|(
name|sp
parameter_list|,
name|ps
parameter_list|,
name|p
parameter_list|)
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|slsymb
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|slsymb
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
modifier|*
name|hp
decl_stmt|;
name|hp
operator|=
name|lookup
argument_list|(
operator|&
name|shsym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|assertflag
operator|&
name|DEFINITIONS
condition|)
block|{
if|if
condition|(
name|undbanner
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|"Undefined symbol "
argument_list|)
expr_stmt|;
name|undbanner
operator|=
literal|1
expr_stmt|;
block|}
name|error
argument_list|(
operator|-
literal|2
argument_list|,
literal|"   %s "
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|hp
operator|)
operator|->
name|n_type
operator|==
name|N_EXT
operator|+
name|N_TEXT
condition|)
block|{
name|count
operator|+=
name|p
operator|->
name|sl_rc
operator|-
literal|1
expr_stmt|;
name|ps
operator|=
name|sllookup
argument_list|(
operator|&
name|tpic
argument_list|,
operator|&
name|tpicseg
index|[
name|NSEG
index|]
argument_list|,
name|tpichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|sl_new
condition|)
name|sl
operator|.
name|js
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this routine check whether a symbol is in the procedure table or   * in the shared library symbol table.  * ++++ the handling of _end and company is ugly here. must search  * for a better way to do it.  */
end_comment

begin_function
name|int
name|calcreloc
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|tcount
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|slsymb
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|slsymb
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|entryflag
operator|==
literal|0
condition|)
comment|/* needed to do relative to absolute */
return|return
operator|(
name|sl
operator|.
name|ds
operator|+
name|sl
operator|.
name|ss
operator|+
name|sl
operator|.
name|js
operator|+
name|rl
operator|.
name|rl_d
operator|+
name|rl
operator|.
name|rl_t
operator|)
return|;
comment|/* 	 * go through the dataslot, jumpslot symbols and dont count the 	 * symbols that are defined. Also go throught the nonpic 	 * referred symbols and discount symbols that are defined. 	 */
name|count
operator|=
name|sl
operator|.
name|ds
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LHSIZ
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|dpichash
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
name|cursym
operator|=
name|p
operator|->
name|sl_symbol
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|lookup
argument_list|(
operator|&
name|ldsym
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"calrelco symb lookup botch"
argument_list|)
expr_stmt|;
comment|/* 			 * if we are not forced to define common and 			 * the symbol is a defined common (non zero 			 * size) then we still have to allocate  			 * relocation record for that symbol except 			 * the case where the symbol is one of these 			 * special ones _end, _etext, _edata. 			 */
if|if
condition|(
name|dflag
operator|==
literal|0
operator|&&
name|sp
operator|->
name|n_type
operator|==
name|N_EXT
operator|+
name|N_UNDF
operator|&&
name|sp
operator|->
name|n_value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"_end"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
operator|&&
name|strcmp
argument_list|(
literal|"_etext"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
operator|&&
name|strcmp
argument_list|(
literal|"_edata"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|sl_link
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
operator|||
name|sp
operator|->
name|n_value
operator|!=
literal|0
condition|)
name|count
operator|--
expr_stmt|;
else|else
block|{
name|ps
operator|=
name|slfindit
argument_list|(
name|dpichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
name|hashit
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ck_shs
argument_list|(
name|sp
argument_list|,
name|ps
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|p
operator|->
name|sl_link
expr_stmt|;
block|}
block|}
comment|/* 	 * should I allowed people to jump to _end, _edata, _etext 	 * here ++++++++++ 	 */
name|tcount
operator|+=
name|count
expr_stmt|;
name|count
operator|=
name|sl
operator|.
name|js
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LHSIZ
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|tpichash
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
name|cursym
operator|=
name|p
operator|->
name|sl_symbol
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|lookup
argument_list|(
operator|&
name|ldsym
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"calrelco symb lookup botch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
operator|||
name|sp
operator|->
name|n_value
operator|!=
literal|0
condition|)
name|count
operator|--
expr_stmt|;
else|else
block|{
name|ps
operator|=
name|slfindit
argument_list|(
name|tpichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
name|hashit
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ck_shs
argument_list|(
name|sp
argument_list|,
name|ps
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|p
operator|->
name|sl_link
expr_stmt|;
block|}
block|}
name|tcount
operator|+=
name|count
expr_stmt|;
name|count
operator|=
name|rl
operator|.
name|rl_de
operator|+
name|rl
operator|.
name|rl_te
expr_stmt|;
comment|/* 	 * if we are not forced to allocate common and procedure 	 * then what we need to discount are the relocations to defined 	 * symbols that are not of the type N_EXT+N_UNDF with a non zero 	 * size. 	 * 	 * if we are forced to define both then what we needed  	 * are the relocations for the extra jump slots (at this 	 * time whatever symbols that are left in this table (npichash) 	 * of the type N_EXT+N_UNDF with a size of 0 should have a 	 * definition in the shsym symbol table of type N_EXT+N_TEXT)   	 * 	 * if we are forced to define only common, then we can only  	 * discount all relocation to N_EXT+N_UNDF with non zero size. 	 * 	 * if we are forced to define only procedure then we can  	 * discount a) relocation(s) to defined routine in user program, 	 * b) for relocation(s) to routine already in the jump table 	 * we can discount the reference count to that symbol,  	 * c) the last step here is to determine if the symbol is 	 * a common in which case we can't discount the references to it. 	 * the algorithm we used to determine whether it is a common is 	 * to check whether the type is N_UNDF+N_EXT with a non zero size. 	 * (we presume that the ".sa" file's symbols are used to update 	 * the size information for any match found in the static symbol 	 * table; however none of the modules are not brought in.)  	 * if the symbol is not a common then we need then to decide  	 * whether it is a routine by checking to see if it's type 	 * is  N_EXT+N_TEXT in the shlib symbol table; we can discount 	 * reference count - 1 since we need a relocation datum for that 	 * entry in the jump table. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LHSIZ
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|npichash
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
name|cursym
operator|=
name|p
operator|->
name|sl_symbol
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|lookup
argument_list|(
operator|&
name|ldsym
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"calrelco symb lookup botch"
argument_list|)
expr_stmt|;
comment|/* 			 * case where we are not forced to define 			 * both commons and procedures 			 */
if|if
condition|(
name|dflag
operator|==
literal|0
operator|&&
name|pflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
condition|)
name|count
operator|-=
name|p
operator|->
name|sl_rc
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"_end"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"_etext"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"_edata"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
name|count
operator|-=
name|p
operator|->
name|sl_rc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dflag
operator|&&
name|pflag
condition|)
block|{
comment|/* 			 * case where we are forced to define 			 * both commons and procedures 			 */
if|if
condition|(
name|sp
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
operator|||
name|sp
operator|->
name|n_value
operator|!=
literal|0
condition|)
name|count
operator|-=
name|p
operator|->
name|sl_rc
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|ps
operator|=
name|slfindit
argument_list|(
name|tpichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
name|hashit
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|)
condition|)
name|count
operator|-=
name|p
operator|->
name|sl_rc
expr_stmt|;
else|else
name|count
operator|-=
name|ck_shs
argument_list|(
name|sp
argument_list|,
name|ps
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dflag
condition|)
block|{
comment|/* 			 * common are forced to be defined (-dc). 			 */
if|if
condition|(
name|sp
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
operator|||
name|sp
operator|->
name|n_value
operator|!=
literal|0
condition|)
name|count
operator|-=
name|p
operator|->
name|sl_rc
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * only procedure are forced to be defined (-dp) 			 */
if|if
condition|(
name|sp
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
condition|)
name|count
operator|-=
name|p
operator|->
name|sl_rc
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"_end"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"_etext"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"_edata"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
name|count
operator|-=
name|p
operator|->
name|sl_rc
expr_stmt|;
elseif|else
if|if
condition|(
name|sp
operator|->
name|n_value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ps
operator|=
name|slfindit
argument_list|(
name|tpichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
name|hashit
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|)
condition|)
name|count
operator|-=
name|p
operator|->
name|sl_rc
expr_stmt|;
else|else
name|count
operator|-=
name|ck_shs
argument_list|(
name|sp
argument_list|,
name|ps
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|=
name|p
operator|->
name|sl_link
expr_stmt|;
block|}
block|}
name|tcount
operator|+=
name|count
expr_stmt|;
return|return
operator|(
name|tcount
operator|)
return|;
block|}
end_function

begin_macro
name|middle
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp1
decl_stmt|;
name|long
name|csize
decl_stmt|,
name|t
decl_stmt|,
name|corigin
decl_stmt|,
name|ocsize
decl_stmt|;
name|int
name|rnd
decl_stmt|;
name|char
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|nsymt
decl_stmt|;
name|int
name|otsize
decl_stmt|;
name|torigin
operator|=
literal|0
expr_stmt|;
name|dorigin
operator|=
literal|0
expr_stmt|;
name|borigin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|rflag
condition|)
block|{
comment|/* 		 * needed to kludge this here so calcreloc to discount  		 * the reference to __DYNAMIC from crt0.s. 		 */
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|slookup
argument_list|(
name|D_NAME
argument_list|,
operator|&
name|ldsym
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ldrsym
argument_list|(
name|sp
argument_list|,
operator|-
literal|1
argument_list|,
name|N_EXT
operator|+
name|N_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ISDYNAMIC
operator|)
operator|||
name|forceflag
operator|&
name|SYMBOLIC
condition|)
block|{
name|rt_init
argument_list|(
name|rtp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSEG
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ldsym
operator|.
name|fs
index|[
name|i
index|]
operator|.
name|sy_first
operator|!=
literal|0
condition|)
block|{
name|sp
operator|=
name|ldsym
operator|.
name|fs
index|[
name|i
index|]
operator|.
name|sy_first
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ldsym
operator|.
name|fs
index|[
name|i
index|]
operator|.
name|sy_used
condition|;
name|j
operator|++
control|)
block|{
name|fslookup
argument_list|(
name|sp
argument_list|,
name|rtp
argument_list|)
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
block|}
else|else
break|break;
name|dj_init
argument_list|(
name|rtp
argument_list|,
operator|&
name|sl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dp_init
argument_list|(
name|rtp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * case of pic code link statically 			 */
name|dj_init
argument_list|(
name|rtp
argument_list|,
operator|&
name|sl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|p_etext
operator|=
operator|*
name|slookup
argument_list|(
literal|"_etext"
argument_list|,
operator|&
name|ldsym
argument_list|)
expr_stmt|;
name|p_edata
operator|=
operator|*
name|slookup
argument_list|(
literal|"_edata"
argument_list|,
operator|&
name|ldsym
argument_list|)
expr_stmt|;
name|p_end
operator|=
operator|*
name|slookup
argument_list|(
literal|"_end"
argument_list|,
operator|&
name|ldsym
argument_list|)
expr_stmt|;
name|nsymt
operator|=
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|ldsym
operator|.
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|sflag
operator|=
name|zflag
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Assign common locations. 	 */
name|csize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|Aflag
condition|)
name|addsym
operator|=
name|ldsym
operator|.
name|fs
index|[
literal|0
index|]
operator|.
name|sy_first
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|zflag
condition|)
block|{
comment|/* 		 * in Sun-x demand-paged programs, 		 * the exec structure is in text space 		 */
name|tsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|sun
name|otsize
operator|=
name|tsize
expr_stmt|;
comment|/* original tsize without shared lib stuff */
if|if
condition|(
operator|!
name|rflag
operator|&&
operator|(
name|ISDYNAMIC
operator|)
condition|)
name|tsize
operator|+=
name|dynamic
operator|.
name|rs
operator|+
name|dynamic
operator|.
name|hs
operator|+
name|dynamic
operator|.
name|ss
operator|+
name|dynamic
operator|.
name|sts
operator|+
name|dynamic
operator|.
name|libstr
operator|+
operator|(
name|rtp
operator|->
name|spthlen
condition|?
name|lalign
argument_list|(
name|rtp
operator|->
name|spthlen
argument_list|)
else|:
literal|0
operator|)
operator|+
operator|(
name|rtp
operator|->
name|dp
operator|->
name|lib
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|link_object
argument_list|)
operator|)
expr_stmt|;
if|#
directive|if
operator|(
name|TARGET
operator|==
name|SUN2
operator|)
operator|||
operator|(
name|TARGET
operator|==
name|SUN3
operator|)
comment|/* i.e. mc68000 */
comment|/* 	 * prevent programs from ending exactly on a page boundary; 	 * if they do, they will coredump as they prefetch the last 	 * "unlk a6; rts" instruction sequence (bug in unlk instruction) 	 */
if|if
condition|(
name|tsize
operator|>
literal|0
operator|&&
name|tsize
operator|%
name|pagesize
argument_list|()
operator|==
literal|0
condition|)
block|{
name|tsize
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* mc68000 */
if|if
condition|(
name|database
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* compute normal, default data base */
name|database
operator|=
name|textbase
operator|+
name|tsize
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|zflag
condition|)
block|{
comment|/* 			 * Don't count the header TWICE.  If we do, and 			 * the data segment gets put at the next segment 			 * boundary as a result, we'll disagree with exec, 			 * and data references will end up in no man's land. 			 */
name|database
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|sun
if|if
condition|(
operator|!
name|Aflag
condition|)
name|database
operator|=
name|round
argument_list|(
name|database
argument_list|,
operator|(
name|nflag
operator|||
name|zflag
operator|||
name|pdflag
condition|?
name|segsize
argument_list|()
else|:
name|seground
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|database
operator|+=
name|hsize
expr_stmt|;
block|}
comment|/* 	 * +++ dont allocate common if dflag is not on 	 */
if|if
condition|(
operator|!
name|rflag
operator|||
name|dflag
condition|)
block|{
name|ldrsym
argument_list|(
name|p_etext
argument_list|,
name|tsize
argument_list|,
name|N_EXT
operator|+
name|N_TEXT
argument_list|)
expr_stmt|;
name|ldrsym
argument_list|(
name|p_edata
argument_list|,
name|dsize
argument_list|,
name|N_EXT
operator|+
name|N_DATA
argument_list|)
expr_stmt|;
name|ldrsym
argument_list|(
name|p_end
argument_list|,
name|bsize
argument_list|,
name|N_EXT
operator|+
name|N_BSS
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
operator|||
name|forceflag
operator|&
name|SYMBOLIC
operator|||
name|bindingflag
operator|==
name|ST_BIND
operator|||
operator|(
name|entryflag
operator|&&
name|rtp
operator|->
name|dp
operator|->
name|lib
operator|==
literal|0
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|addsym
argument_list|)
init|;
name|i
operator|<
name|nsymt
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|xsym
argument_list|(
name|ldsym
operator|.
name|fs
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|sp
operator|->
name|n_type
operator|)
operator|==
name|N_EXT
operator|+
name|N_UNDF
operator|&&
operator|(
name|t
operator|=
name|sp
operator|->
name|n_value
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|t
operator|>=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|rnd
operator|=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|>=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|rnd
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
else|else
name|rnd
operator|=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* 					 * check if this common is to 					 * be page aligned  					 */
if|if
condition|(
name|Pflag
operator|&&
name|sp
operator|->
name|n_un
operator|.
name|n_name
condition|)
block|{
name|int
name|ii
decl_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|Pflag
condition|;
name|ii
operator|++
control|)
if|if
condition|(
name|Ptab
index|[
name|ii
index|]
index|[
literal|1
index|]
operator|==
name|sp
operator|->
name|n_un
operator|.
name|n_name
index|[
literal|1
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|Ptab
index|[
name|ii
index|]
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
block|{
name|rnd
operator|=
name|pagesize
argument_list|()
expr_stmt|;
name|t
operator|=
name|round
argument_list|(
name|t
argument_list|,
name|pagesize
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|csize
operator|=
name|round
argument_list|(
name|csize
argument_list|,
name|rnd
argument_list|)
expr_stmt|;
name|sp
operator|->
name|n_value
operator|=
name|csize
expr_stmt|;
name|sp
operator|->
name|n_type
operator|=
name|N_EXT
operator|+
name|N_COMM
expr_stmt|;
name|ocsize
operator|=
name|csize
expr_stmt|;
name|csize
operator|+=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|&
name|N_EXT
operator|&&
operator|(
name|s
operator|&
name|N_TYPE
operator|)
operator|==
name|N_UNDF
operator|&&
name|s
operator|&
name|N_STAB
condition|)
block|{
name|sp
operator|->
name|n_value
operator|=
name|ocsize
expr_stmt|;
name|sp
operator|->
name|n_type
operator|=
operator|(
name|s
operator|&
name|N_STAB
operator|)
operator||
operator|(
name|N_EXT
operator|+
name|N_COMM
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Now set symbols to their final value  	 */
if|if
condition|(
operator|!
name|rflag
operator|&&
operator|(
operator|(
name|ISDYNAMIC
operator|)
operator|||
operator|(
name|dynamic
operator|.
name|ds
operator|+
name|dynamic
operator|.
name|js
operator|)
operator|)
condition|)
block|{
name|lkd
operator|.
name|v2
operator|=
operator|&
name|lkd2
expr_stmt|;
name|lkd
operator|.
name|ldd
operator|=
operator|&
name|ldd
expr_stmt|;
name|init_lkd
argument_list|(
operator|&
name|lkd
argument_list|,
name|rtp
argument_list|,
name|otsize
argument_list|,
name|database
argument_list|)
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|link_dynamic
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|link_dynamic_2
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ld_debug
argument_list|)
operator|+
name|dynamic
operator|.
name|ds
operator|+
name|dynamic
operator|.
name|js
expr_stmt|;
if|if
condition|(
name|i
operator|%
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|pad
operator|=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|-
operator|(
name|i
operator|%
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|)
expr_stmt|;
name|doff
operator|=
name|i
operator|+
name|pad
expr_stmt|;
block|}
name|csize
operator|=
name|round
argument_list|(
name|csize
argument_list|,
name|seground
argument_list|()
argument_list|)
expr_stmt|;
name|torigin
operator|=
name|textbase
expr_stmt|;
name|dorigin
operator|=
name|database
expr_stmt|;
name|ndorigin
operator|=
name|database
operator|+
name|doff
expr_stmt|;
name|corigin
operator|=
name|ndorigin
operator|+
name|dsize
expr_stmt|;
if|if
condition|(
name|Pflag
condition|)
block|{
comment|/* make sure commons start on a page boundary */
name|corigin
operator|=
name|round
argument_list|(
name|corigin
argument_list|,
name|pagesize
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|corigin
operator|=
name|round
argument_list|(
name|corigin
argument_list|,
name|seground
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Commons must start on seg bdy. */
name|borigin
operator|=
name|corigin
operator|+
name|csize
expr_stmt|;
name|nsymt
operator|=
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|ldsym
operator|.
name|ns
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|addsym
argument_list|)
init|;
name|i
operator|<
name|nsymt
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|xsym
argument_list|(
name|ldsym
operator|.
name|fs
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|n_type
operator|&
operator|(
name|N_TYPE
operator|+
name|N_EXT
operator|)
condition|)
block|{
case|case
name|N_EXT
operator|+
name|N_UNDF
case|:
if|if
condition|(
name|arflag
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ISDYNAMIC
operator|)
operator|&&
operator|!
operator|(
name|dynamic
operator|.
name|ds
operator|+
name|dynamic
operator|.
name|js
operator|)
condition|)
name|errlev
operator||=
literal|01
expr_stmt|;
if|if
condition|(
operator|(
name|arflag
operator|==
literal|0
operator|||
name|dflag
operator|)
operator|&&
name|sp
operator|->
name|n_value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|==
name|p_end
operator|||
name|sp
operator|==
name|p_etext
operator|||
name|sp
operator|==
name|p_edata
condition|)
continue|continue;
if|if
condition|(
name|undbanner
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
operator|(
name|ISDYNAMIC
operator|)
operator|&&
operator|!
name|ISGT
argument_list|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|"Undefined symbol"
argument_list|)
expr_stmt|;
name|undbanner
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rflag
operator|&&
operator|!
name|ISGT
argument_list|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
name|nund
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ISDYNAMIC
operator|)
operator|&&
operator|!
name|ISGT
argument_list|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
name|error
argument_list|(
operator|-
literal|2
argument_list|,
literal|"   %s"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|N_EXT
operator|+
name|N_ABS
case|:
default|default:
continue|continue;
case|case
name|N_EXT
operator|+
name|N_TEXT
case|:
name|sp
operator|->
name|n_value
operator|+=
name|torigin
expr_stmt|;
continue|continue;
case|case
name|N_EXT
operator|+
name|N_DATA
case|:
name|sp
operator|->
name|n_value
operator|+=
name|ndorigin
expr_stmt|;
continue|continue;
case|case
name|N_EXT
operator|+
name|N_BSS
case|:
name|sp
operator|->
name|n_value
operator|+=
name|borigin
expr_stmt|;
continue|continue;
case|case
name|N_EXT
operator|+
name|N_COMM
case|:
comment|/* 			 * ++++ why this in sun4 ld 			 */
if|if
condition|(
name|dflag
operator|||
name|rflag
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|n_type
operator|=
operator|(
name|sp
operator|->
name|n_type
operator|&
name|N_STAB
operator|)
operator||
operator|(
name|N_EXT
operator|+
name|N_BSS
operator|)
expr_stmt|;
name|sp
operator|->
name|n_value
operator|+=
name|corigin
expr_stmt|;
block|}
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|rflag
condition|)
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|slookup
argument_list|(
name|GT
argument_list|,
operator|&
name|ldsym
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ldrsym
argument_list|(
name|sp
argument_list|,
name|lkd
operator|.
name|v2
operator|->
name|ld_got
argument_list|,
name|N_EXT
operator|+
name|N_DATA
argument_list|)
expr_stmt|;
name|rtp
operator|->
name|us
operator|=
name|nund
expr_stmt|;
if|if
condition|(
name|sflag
operator|||
name|xflag
condition|)
name|ssize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|slookup
argument_list|(
name|D_NAME
argument_list|,
operator|&
name|ldsym
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * now load in the real value of __DYNAMIC. 		 * if there is a definition for __DYNAMIC and rflag is on 		 * just leave it alone (i.e ld -x -r crt0.o) 		 */
if|if
condition|(
operator|!
name|rflag
condition|)
block|{
name|sp
operator|->
name|n_type
operator|=
name|N_EXT
operator|+
name|N_DATA
expr_stmt|;
if|if
condition|(
name|ISDYNAMIC
operator|||
name|forceflag
operator|&
name|SYMBOLIC
condition|)
name|sp
operator|->
name|n_value
operator|=
name|dorigin
expr_stmt|;
else|else
name|sp
operator|->
name|n_value
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*  		 * if there is no reference to __DYNAMIC symbol 		 * then we need to account for it here since we will 		 * be writing this symbol in endload. 		 * In the case where it is already in the ldsym table 		 * then we dont need to account for it here since we 		 * wanted to avoid writing out the same symbol twice. 		 */
if|if
condition|(
operator|!
name|rflag
condition|)
name|ssize
operator|+=
sizeof|sizeof
name|cursym
expr_stmt|;
block|}
name|bsize
operator|+=
name|csize
expr_stmt|;
name|nsym
operator|=
name|ssize
operator|/
operator|(
sizeof|sizeof
name|cursym
operator|)
expr_stmt|;
if|if
condition|(
name|Aflag
condition|)
block|{
name|fixspec
argument_list|(
name|p_etext
argument_list|,
name|torigin
argument_list|)
expr_stmt|;
name|fixspec
argument_list|(
name|p_edata
argument_list|,
name|dorigin
argument_list|)
expr_stmt|;
name|fixspec
argument_list|(
name|p_end
argument_list|,
name|borigin
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * update value field for all the symbols used for dynamic linking. 	 */
if|if
condition|(
operator|!
name|rflag
condition|)
if|if
condition|(
operator|(
name|ISDYNAMIC
operator|)
operator|||
name|forceflag
operator|&
name|SYMBOLIC
condition|)
block|{
name|sp1
operator|=
name|rtp
operator|->
name|sp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalsymb
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|rtp
operator|->
name|fsstr
operator|+
name|sp1
operator|->
name|n_un
operator|.
name|n_strx
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|lookup
argument_list|(
operator|&
name|ldsym
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"fast symbol not found"
argument_list|)
expr_stmt|;
name|sp1
operator|->
name|n_value
operator|=
name|sp
operator|->
name|n_value
expr_stmt|;
name|sp1
operator|->
name|n_type
operator|=
name|sp
operator|->
name|n_type
expr_stmt|;
name|sp1
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Finally, verify that all .so symbols would be satisfied if we 	 * were to run now. 	 */
if|if
condition|(
operator|!
operator|(
name|assertflag
operator|&
name|DEFINITIONS
operator|)
condition|)
return|return;
name|nsymt
operator|=
name|symx
argument_list|(
operator|&
name|shsym
argument_list|,
name|shsym
operator|.
name|ns
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|symx
argument_list|(
operator|&
name|shsym
argument_list|,
literal|0
argument_list|)
init|;
name|i
operator|<
name|nsymt
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|xsym
argument_list|(
name|shsym
operator|.
name|fs
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|n_type
operator|==
operator|(
name|N_EXT
operator|+
name|N_UNDF
operator|)
operator|)
operator|&&
operator|(
name|sp
operator|->
name|n_value
operator|==
literal|0
operator|)
condition|)
block|{
name|cursym
operator|=
operator|*
name|sp
expr_stmt|;
name|sp1
operator|=
operator|*
name|lookup
argument_list|(
operator|&
name|ldsym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp1
operator|==
name|NULL
operator|||
operator|(
operator|(
name|sp1
operator|->
name|n_type
operator|==
operator|(
name|N_EXT
operator|+
name|N_UNDF
operator|)
operator|)
operator|&&
operator|(
name|sp1
operator|->
name|n_value
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|undbanner
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|"Undefined symbol"
argument_list|)
expr_stmt|;
name|undbanner
operator|=
literal|1
expr_stmt|;
block|}
name|error
argument_list|(
operator|-
literal|2
argument_list|,
literal|"   %s"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_macro
name|fixspec
argument_list|(
argument|sym
argument_list|,
argument|offset
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|sym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|sym
argument_list|)
operator|<
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|addsym
argument_list|)
operator|&&
name|sym
operator|!=
literal|0
condition|)
name|sym
operator|->
name|n_value
operator|+=
name|offset
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ldrsym
argument_list|(
name|sp
argument_list|,
name|val
argument_list|,
name|type
argument_list|)
specifier|register
expr|struct
name|nlist
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|long
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|sp
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
operator|)
operator|&&
operator|!
name|Aflag
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|"%s: user attempt to redefine loader-defined symbol"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|n_type
operator|=
name|type
expr_stmt|;
name|sp
operator|->
name|n_value
operator|=
name|val
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|off_t
name|wroff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|biobuf
name|toutb
decl_stmt|;
end_decl_stmt

begin_macro
name|setupout
argument_list|()
end_macro

begin_block
block|{
name|int
name|bss
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|int
name|ds
decl_stmt|;
name|int
name|ntsize
decl_stmt|;
name|ofilemode
operator|=
literal|0777
operator|&
operator|~
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|biofd
operator|=
name|creat
argument_list|(
name|ofilename
argument_list|,
literal|0666
operator|&
name|ofilemode
argument_list|)
expr_stmt|;
if|if
condition|(
name|biofd
operator|<
literal|0
condition|)
block|{
name|filname
operator|=
name|ofilename
expr_stmt|;
comment|/* kludge */
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* kludge */
name|error
argument_list|(
literal|1
argument_list|,
name|errmsg
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* kludge */
block|}
name|fstat
argument_list|(
name|biofd
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
comment|/* suppose file exists, wrong*/
if|if
condition|(
name|stbuf
operator|.
name|st_mode
operator|&
literal|0111
condition|)
block|{
comment|/* mode, ld fails? */
name|chmod
argument_list|(
name|ofilename
argument_list|,
name|stbuf
operator|.
name|st_mode
operator|&
literal|0666
argument_list|)
expr_stmt|;
name|ofilemode
operator|=
name|stbuf
operator|.
name|st_mode
expr_stmt|;
block|}
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
name|outfilhdr
operator|.
name|a_machtype
operator|=
operator|(
name|use68020
condition|?
name|M_68020
else|:
name|M_68010
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* mc680x0 */
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|outfilhdr
operator|.
name|a_toolversion
operator|=
name|TV_SUN4
expr_stmt|;
name|outfilhdr
operator|.
name|a_machtype
operator|=
name|M_SPARC
expr_stmt|;
endif|#
directive|endif
comment|/* sun4 */
name|outfilhdr
operator|.
name|a_magic
operator|=
name|nflag
condition|?
name|NMAGIC
else|:
operator|(
name|zflag
condition|?
name|ZMAGIC
else|:
name|OMAGIC
operator|)
expr_stmt|;
name|outfilhdr
operator|.
name|a_text
operator|=
name|round
argument_list|(
name|tsize
argument_list|,
name|zflag
operator|||
name|pdflag
condition|?
name|pagesize
argument_list|()
else|:
name|seground
argument_list|()
argument_list|)
expr_stmt|;
name|ds
operator|=
name|dsize
expr_stmt|;
if|if
condition|(
operator|!
name|rflag
operator|&&
operator|(
operator|(
name|ISDYNAMIC
operator|)
operator|||
operator|(
name|dynamic
operator|.
name|ds
operator|+
name|dynamic
operator|.
name|js
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ISDYNAMIC
condition|)
name|outfilhdr
operator|.
name|a_dynamic
operator|=
literal|1
expr_stmt|;
name|ds
operator|+=
name|doff
expr_stmt|;
name|lkd
operator|.
name|v2
operator|->
name|ld_text
operator|=
name|outfilhdr
operator|.
name|a_text
expr_stmt|;
block|}
name|outfilhdr
operator|.
name|a_data
operator|=
name|round
argument_list|(
name|ds
argument_list|,
name|zflag
condition|?
name|pagesize
argument_list|()
else|:
name|seground
argument_list|()
argument_list|)
expr_stmt|;
name|bss
operator|=
name|bsize
operator|-
operator|(
name|Pflag
condition|?
literal|0
else|:
operator|(
name|outfilhdr
operator|.
name|a_data
operator|-
name|ds
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|bss
operator|<
literal|0
condition|)
name|bss
operator|=
literal|0
expr_stmt|;
name|outfilhdr
operator|.
name|a_bss
operator|=
name|bss
operator|=
name|round
argument_list|(
name|bss
argument_list|,
name|seground
argument_list|()
argument_list|)
expr_stmt|;
name|outfilhdr
operator|.
name|a_trsize
operator|=
name|trsize
expr_stmt|;
name|outfilhdr
operator|.
name|a_drsize
operator|=
name|drsize
expr_stmt|;
name|outfilhdr
operator|.
name|a_syms
operator|=
name|sflag
condition|?
literal|0
else|:
operator|(
name|ssize
operator|+
operator|(
sizeof|sizeof
name|cursym
operator|)
operator|*
operator|(
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|ldsym
operator|.
name|ns
argument_list|)
operator|-
name|rtp
operator|->
name|us
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|entrypt
condition|)
block|{
if|if
condition|(
name|entrypt
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_TEXT
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"entry point not in text"
argument_list|)
expr_stmt|;
else|else
name|outfilhdr
operator|.
name|a_entry
operator|=
name|entrypt
operator|->
name|n_value
expr_stmt|;
block|}
else|else
name|outfilhdr
operator|.
name|a_entry
operator|=
name|textbase
expr_stmt|;
name|outfilhdr
operator|.
name|a_trsize
operator|=
operator|(
name|rflag
condition|?
name|trsize
else|:
literal|0
operator|)
expr_stmt|;
name|outfilhdr
operator|.
name|a_drsize
operator|=
operator|(
name|rflag
condition|?
name|drsize
else|:
literal|0
operator|)
expr_stmt|;
name|tout
operator|=
operator|&
name|toutb
expr_stmt|;
name|bopen
argument_list|(
name|tout
argument_list|,
literal|0
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|outfilhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|outfilhdr
argument_list|)
argument_list|,
name|tout
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|sun
if|if
condition|(
name|zflag
condition|)
name|bseek
argument_list|(
name|tout
argument_list|,
name|pagesize
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|sun
name|wroff
operator|=
name|N_TXTOFF
argument_list|(
name|outfilhdr
argument_list|)
operator|+
name|outfilhdr
operator|.
name|a_text
expr_stmt|;
comment|/* 	 * in case of static linking only space for data and jump linkage 	 * is needed else the dynamic header, relocation datum and the fast 	 * symbol table will be added before the real data segment began. 	 */
if|if
condition|(
operator|!
name|rflag
operator|&&
operator|(
operator|(
name|ISDYNAMIC
operator|)
operator|||
operator|(
name|dynamic
operator|.
name|ds
operator|+
name|dynamic
operator|.
name|js
operator|)
operator|)
condition|)
block|{
name|struct
name|link_dynamic
name|lk
decl_stmt|;
name|outb
argument_list|(
operator|&
name|dynout
argument_list|,
name|doff
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
name|lk
operator|.
name|ld_version
operator|=
literal|3
expr_stmt|;
call|(
name|int
call|)
argument_list|(
name|lk
operator|.
name|ldd
argument_list|)
operator|=
operator|(
name|int
operator|)
name|database
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|link_dynamic
argument_list|)
expr_stmt|;
call|(
name|int
call|)
argument_list|(
name|lk
operator|.
name|v2
argument_list|)
operator|=
operator|(
name|int
operator|)
name|lk
operator|.
name|ldd
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ld_debug
argument_list|)
expr_stmt|;
name|lkd
operator|.
name|v2
operator|->
name|ld_buckets
operator|=
name|rtp
operator|->
name|buckets
expr_stmt|;
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|lk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|link_dynamic
argument_list|)
argument_list|,
name|dynout
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|lkd
operator|.
name|ldd
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ld_debug
argument_list|)
argument_list|,
name|dynout
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|lkd
operator|.
name|v2
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|link_dynamic_2
argument_list|)
argument_list|,
name|dynout
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
operator|&
name|dout
argument_list|,
name|outfilhdr
operator|.
name|a_data
operator|-
name|doff
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|outb
argument_list|(
operator|&
name|trout
argument_list|,
name|outfilhdr
operator|.
name|a_trsize
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|&
name|drout
argument_list|,
name|outfilhdr
operator|.
name|a_drsize
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sflag
operator|==
literal|0
operator|||
name|xflag
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
operator|&
name|sout
argument_list|,
name|outfilhdr
operator|.
name|a_syms
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
name|wroff
operator|+=
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|&
name|strout
argument_list|,
literal|0
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|outb
argument_list|(
name|bp
argument_list|,
name|inc
argument_list|,
name|bufsize
argument_list|)
specifier|register
expr|struct
name|biobuf
operator|*
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|*
name|bp
operator|=
operator|(
expr|struct
name|biobuf
operator|*
operator|)
name|mymalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|biobuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (outb)"
argument_list|)
expr_stmt|;
name|bopen
argument_list|(
operator|*
name|bp
argument_list|,
name|wroff
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|wroff
operator|+=
name|inc
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|localsymbolno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|load2arg
argument_list|(
argument|acp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|acp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|off_t
name|loc
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|struct
name|ldlib
modifier|*
name|tllp
decl_stmt|;
name|long
name|maxoff
decl_stmt|;
name|cp
operator|=
name|acp
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|getfile
argument_list|(
name|cp
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|maxoff
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|cp
operator|>=
name|acp
operator|&&
operator|*
operator|--
name|cp
operator|!=
literal|'/'
condition|)
empty_stmt|;
name|mkfsym
argument_list|(
operator|++
name|cp
argument_list|,
name|torigin
argument_list|,
name|N_TEXT
argument_list|)
expr_stmt|;
name|localsymbolno
operator|++
expr_stmt|;
name|load2
argument_list|(
literal|0L
argument_list|,
name|maxoff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* scan archive members referenced */
if|if
condition|(
name|i
operator|!=
name|SHLIB
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|clibseg
operator|->
name|li_used2
operator|==
name|clibseg
operator|->
name|li_used
condition|)
block|{
if|if
condition|(
name|clibseg
operator|->
name|li_used
operator|<
name|NROUT
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"libseg botch"
argument_list|)
expr_stmt|;
name|clibseg
operator|++
expr_stmt|;
block|}
name|loc
operator|=
name|clibseg
operator|->
name|li_first
index|[
name|clibseg
operator|->
name|li_used2
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|loc
operator|==
operator|-
literal|1
condition|)
break|break;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
argument_list|)
expr_stmt|;
name|getarhdr
argument_list|()
expr_stmt|;
name|mkfsym
argument_list|(
name|archdr
operator|.
name|ar_name
argument_list|,
name|torigin
argument_list|,
name|N_TEXT
argument_list|)
expr_stmt|;
name|load2
argument_list|(
name|loc
operator|+
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
argument_list|,
name|atol
argument_list|(
name|archdr
operator|.
name|ar_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|tllp
operator|=
name|hldlp
init|;
name|tllp
condition|;
name|tllp
operator|=
name|tllp
operator|->
name|ll_next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tllp
operator|->
name|ll_name
argument_list|,
name|filname
argument_list|)
condition|)
block|{
if|if
condition|(
name|tllp
operator|->
name|ll_flag
operator|&
name|DOLOADME
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|filname
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|p
operator|=
name|filname
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
name|p
operator|++
expr_stmt|;
name|strncpy
argument_list|(
operator|++
name|p
argument_list|,
literal|"sa"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|load2arg
argument_list|(
name|filname
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
name|close
argument_list|(
name|infil
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|load2
argument_list|(
argument|loc
argument_list|,
argument|maxoff
argument_list|)
end_macro

begin_decl_stmt
name|int
name|loc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|maxoff
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|size
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|local
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|symno
decl_stmt|,
name|i
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|exclude
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|csp
decl_stmt|;
name|int
name|lpicflag
decl_stmt|;
name|int
name|lsymbno
decl_stmt|;
name|exclude
operator|=
literal|0
expr_stmt|;
name|readhdr
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|funding
condition|)
block|{
name|ctrel
operator|=
name|torigin
expr_stmt|;
name|cdrel
operator|+=
name|ndorigin
expr_stmt|;
name|cbrel
operator|+=
name|borigin
expr_stmt|;
block|}
comment|/* 	 * Reread the symbol table, recording the numbering 	 * of symbols for fixing external references. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LHSIZ
condition|;
name|i
operator|++
control|)
name|lochash
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|clocseg
operator|=
name|locseg
expr_stmt|;
name|clocseg
operator|->
name|lo_used
operator|=
literal|0
expr_stmt|;
name|symno
operator|=
operator|-
literal|1
expr_stmt|;
name|csp
operator|=
name|loc_symb
expr_stmt|;
comment|/*  	 * reintialize static pic stuff after each module 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LHSIZ
condition|;
name|i
operator|++
control|)
name|stpichash
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|stpic
operator|=
name|stpicseg
expr_stmt|;
name|stpicseg
operator|->
name|sls_used
operator|=
literal|0
expr_stmt|;
name|loc
operator|+=
name|N_TXTOFF
argument_list|(
name|filhdr
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
operator|+
name|filhdr
operator|.
name|a_drsize
operator|+
name|filhdr
operator|.
name|a_syms
argument_list|,
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|&
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|size
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
operator|+
name|filhdr
operator|.
name|a_drsize
operator|+
name|filhdr
operator|.
name|a_syms
operator|+
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
name|curstr
operator|=
operator|(
name|char
operator|*
operator|)
name|mymalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|curstr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of space reading string table (pass 2)"
argument_list|)
expr_stmt|;
name|mget
argument_list|(
name|curstr
operator|+
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
comment|/* 	 * detect the existance of the extra sections. 	 * go blat them to temp files. 	 */
if|if
condition|(
name|maxoff
operator|>
name|N_STROFF
argument_list|(
name|filhdr
argument_list|)
operator|+
name|size
condition|)
block|{
comment|/* it should be out there. go get it */
name|collect_extra_sections
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
operator|+
name|filhdr
operator|.
name|a_drsize
operator|+
name|filhdr
operator|.
name|a_syms
operator|+
name|size
argument_list|,
name|maxoff
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we are -r'ing a -pic file, we need to "globalize" local 	 * symbols so they're around when the output gets passed through 	 * us again. 	 */
name|lpicflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
operator|+
name|filhdr
operator|.
name|a_drsize
argument_list|,
name|filhdr
operator|.
name|a_syms
argument_list|)
expr_stmt|;
while|while
condition|(
name|text
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cursym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|<
sizeof|sizeof
argument_list|(
name|size
argument_list|)
operator|||
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|>=
name|size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad string table index (pic pass 1)"
argument_list|)
expr_stmt|;
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|curstr
operator|+
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
if|if
condition|(
name|ISGT
argument_list|(
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
block|{
name|lpicflag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*  	 * Now process each symbol. 	 */
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
operator|+
name|filhdr
operator|.
name|a_drsize
argument_list|,
name|filhdr
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|lsymbno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|text
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|symno
operator|++
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cursym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
condition|)
block|{
if|if
condition|(
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|<
sizeof|sizeof
argument_list|(
name|size
argument_list|)
operator|||
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|>=
name|size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad string table index (pass 2)"
argument_list|)
expr_stmt|;
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|curstr
operator|+
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
block|}
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|&
name|N_STAB
condition|)
block|{
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|==
name|N_BINCL
condition|)
block|{
name|exclude
operator|=
name|start_incl2
argument_list|(
operator|&
name|cursym
argument_list|,
name|header_num
argument_list|)
expr_stmt|;
name|header_num
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|==
name|N_EINCL
condition|)
block|{
if|if
condition|(
name|exclude
condition|)
block|{
name|exclude
operator|=
name|end_incl2
argument_list|()
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|exclude
operator|=
name|end_incl2
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|exclude
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
comment|/* 			 * do not keep track of any dbx symbols for load2td 			 * +++ is it safe? 			 */
if|if
condition|(
name|clocseg
operator|->
name|lo_used
operator|==
name|NSYMPR
condition|)
block|{
if|if
condition|(
operator|++
name|clocseg
operator|==
operator|&
name|locseg
index|[
name|NSEG
index|]
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"local symbol overflow"
argument_list|)
expr_stmt|;
name|clocseg
operator|->
name|lo_used
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|clocseg
operator|->
name|lo_first
operator|==
literal|0
condition|)
block|{
name|clocseg
operator|->
name|lo_first
operator|=
operator|(
expr|struct
name|local
operator|*
operator|)
name|calloc
argument_list|(
name|NSYMPR
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|local
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clocseg
operator|->
name|lo_first
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of memory (clocseg)"
argument_list|)
expr_stmt|;
block|}
name|lp
operator|=
operator|&
name|clocseg
operator|->
name|lo_first
index|[
name|clocseg
operator|->
name|lo_used
operator|++
index|]
expr_stmt|;
name|lp
operator|->
name|l_index
operator|=
name|symno
expr_stmt|;
if|if
condition|(
name|rflag
operator|&&
name|lpicflag
operator|&&
name|cursym
operator|.
name|n_un
operator|.
name|n_name
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|filname
argument_list|)
operator|+
name|strlen
argument_list|(
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|filname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cp
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cp
argument_list|,
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|cp
expr_stmt|;
block|}
operator|*
name|csp
operator|=
name|cursym
expr_stmt|;
name|lp
operator|->
name|l_symbol
operator|=
name|csp
operator|++
expr_stmt|;
name|lp
operator|->
name|l_link
operator|=
name|lochash
index|[
name|symno
operator|%
name|LHSIZ
index|]
expr_stmt|;
name|lochash
index|[
name|symno
operator|%
name|LHSIZ
index|]
operator|=
name|lp
expr_stmt|;
block|}
comment|/* inline expansion of symreloc() */
if|if
condition|(
operator|!
name|funding
condition|)
block|{
comment|/* 			 * Do not relocate symbols in fundamental file. 			 * This turns out only to matter for local 			 * static and debugging symbols, which 			 * are written out here. 			 */
switch|switch
condition|(
name|cursym
operator|.
name|n_type
operator|&
operator|(
name|N_TYPE
operator|+
name|N_EXT
operator|)
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_EXT
operator|+
name|N_TEXT
case|:
name|cursym
operator|.
name|n_value
operator|+=
name|ctrel
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
case|case
name|N_EXT
operator|+
name|N_DATA
case|:
name|cursym
operator|.
name|n_value
operator|+=
name|cdrel
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
case|case
name|N_EXT
operator|+
name|N_BSS
case|:
name|cursym
operator|.
name|n_value
operator|+=
name|cbrel
expr_stmt|;
break|break;
case|case
name|N_EXT
operator|+
name|N_UNDF
case|:
break|break;
default|default:
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|&
name|N_EXT
condition|)
name|cursym
operator|.
name|n_type
operator|=
name|N_EXT
operator|+
name|N_ABS
expr_stmt|;
block|}
block|}
comment|/* end inline expansion of symreloc() */
name|type
operator|=
name|cursym
operator|.
name|n_type
expr_stmt|;
if|if
condition|(
name|yflag
operator|&&
name|cursym
operator|.
name|n_un
operator|.
name|n_name
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|yflag
condition|;
name|i
operator|++
control|)
comment|/* fast check for 2d character! */
if|if
condition|(
name|ytab
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
name|cursym
operator|.
name|n_un
operator|.
name|n_name
index|[
literal|1
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|ytab
index|[
name|i
index|]
argument_list|,
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
block|{
name|tracesym
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|N_EXT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|sflag
operator|&&
operator|!
name|xflag
operator|&&
operator|(
name|type
operator|&
name|N_STAB
operator|||
name|cursym
operator|.
name|n_un
operator|.
name|n_name
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|)
operator|)
operator|||
operator|(
name|rflag
operator|&&
operator|(
name|lpicflag
operator|)
operator|&&
name|cursym
operator|.
name|n_un
operator|.
name|n_name
index|[
literal|0
index|]
operator|==
literal|'L'
operator|)
condition|)
block|{
comment|/* 			     * if symbol is for debugging then we  			     * dont need to keep track of it. 			     */
if|if
condition|(
operator|!
operator|(
name|type
operator|&
name|N_STAB
operator|)
condition|)
block|{
name|lp
operator|->
name|l_symbol
operator|->
name|n_desc
operator|=
name|lsymbno
expr_stmt|;
name|lsymbno
operator|++
expr_stmt|;
block|}
name|symwrite
argument_list|(
operator|&
name|cursym
argument_list|,
name|sout
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|funding
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|lookup
argument_list|(
operator|&
name|ldsym
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"internal error: symbol not found"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|&
name|N_STAB
operator|||
name|cursym
operator|.
name|n_type
operator|==
name|N_EXT
operator|+
name|N_UNDF
condition|)
continue|continue;
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|!=
name|sp
operator|->
name|n_type
operator|||
name|cursym
operator|.
name|n_value
operator|!=
name|sp
operator|->
name|n_value
condition|)
block|{
if|if
condition|(
operator|!
name|ISGT
argument_list|(
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|"%s: multiply defined"
argument_list|,
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|funding
condition|)
return|return;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
name|filhdr
operator|.
name|a_text
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
argument_list|,
name|filhdr
operator|.
name|a_trsize
argument_list|)
expr_stmt|;
name|load2td
argument_list|(
name|ctrel
argument_list|,
name|torigin
operator|-
name|textbase
argument_list|,
name|tout
argument_list|,
name|trout
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
argument_list|,
name|filhdr
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
argument_list|,
name|filhdr
operator|.
name|a_drsize
argument_list|)
expr_stmt|;
name|load2td
argument_list|(
name|cdrel
argument_list|,
name|ndorigin
operator|-
name|database
argument_list|,
name|dout
argument_list|,
name|drout
argument_list|)
expr_stmt|;
while|while
condition|(
name|filhdr
operator|.
name|a_data
operator|&
operator|(
name|seground
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|bputc
argument_list|(
literal|0
argument_list|,
name|dout
argument_list|)
expr_stmt|;
name|filhdr
operator|.
name|a_data
operator|++
expr_stmt|;
block|}
name|localsymbolno
operator|+=
name|lsymbno
expr_stmt|;
name|torigin
operator|+=
name|filhdr
operator|.
name|a_text
expr_stmt|;
name|ndorigin
operator|+=
name|round
argument_list|(
name|filhdr
operator|.
name|a_data
argument_list|,
name|seground
argument_list|()
argument_list|)
expr_stmt|;
name|borigin
operator|+=
name|round
argument_list|(
name|filhdr
operator|.
name|a_bss
argument_list|,
name|seground
argument_list|()
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curstr
argument_list|)
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|tynames
block|{
name|int
name|ty_value
decl_stmt|;
name|char
modifier|*
name|ty_name
decl_stmt|;
block|}
name|tynames
index|[]
init|=
block|{
name|N_UNDF
block|,
literal|"undefined"
block|,
name|N_ABS
block|,
literal|"absolute"
block|,
name|N_TEXT
block|,
literal|"text"
block|,
name|N_DATA
block|,
literal|"data"
block|,
name|N_BSS
block|,
literal|"bss"
block|,
name|N_COMM
block|,
literal|"common"
block|,
literal|0
block|,
literal|0
block|, }
struct|;
end_struct

begin_macro
name|tracesym
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|tynames
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|&
name|N_STAB
condition|)
return|return;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|filname
argument_list|)
expr_stmt|;
if|if
condition|(
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|archdr
operator|.
name|ar_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cursym
operator|.
name|n_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_UNDF
operator|&&
name|cursym
operator|.
name|n_value
condition|)
block|{
name|printf
argument_list|(
literal|"definition of common %s size %d\n"
argument_list|,
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|cursym
operator|.
name|n_value
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|tp
operator|=
name|tynames
init|;
name|tp
operator|->
name|ty_name
condition|;
name|tp
operator|++
control|)
if|if
condition|(
name|tp
operator|->
name|ty_value
operator|==
operator|(
name|cursym
operator|.
name|n_type
operator|&
name|N_TYPE
operator|)
condition|)
break|break;
name|printf
argument_list|(
operator|(
name|cursym
operator|.
name|n_type
operator|&
name|N_TYPE
operator|)
condition|?
literal|"definition of"
else|:
literal|"reference to"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|&
name|N_EXT
condition|)
name|printf
argument_list|(
literal|" external"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ty_name
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|tp
operator|->
name|ty_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|struct
name|ssymbol
modifier|*
name|ssymbol_p
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|forcesymbolic
parameter_list|(
name|flag
parameter_list|,
name|sp
parameter_list|)
name|int
name|flag
decl_stmt|;
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|ssymbol
modifier|*
name|ssp
init|=
name|ssymbol_p
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|SYMBOLIC
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|ssp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|sp
operator|->
name|n_un
operator|.
name|n_name
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|ssp
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
name|ssp
operator|->
name|ssp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
name|ssp
operator|=
name|ssp
operator|->
name|ss_next
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * these bits denote a relocation type for bldreloc routine   */
end_comment

begin_define
define|#
directive|define
name|REL_RP
value|1
end_define

begin_comment
comment|/* relative */
end_comment

begin_define
define|#
directive|define
name|EXT_RP
value|2
end_define

begin_comment
comment|/* extern */
end_comment

begin_define
define|#
directive|define
name|BSR_RP
value|4
end_define

begin_comment
comment|/* base relative */
end_comment

begin_define
define|#
directive|define
name|JMP_RP
value|8
end_define

begin_comment
comment|/* jump */
end_comment

begin_define
define|#
directive|define
name|PCREL_RP
value|0x10
end_define

begin_comment
comment|/* pc relative */
end_comment

begin_define
define|#
directive|define
name|DONE_RP
value|0x20
end_define

begin_comment
comment|/* done */
end_comment

begin_define
define|#
directive|define
name|dloff
value|(lkd.v2->ld_got)
end_define

begin_define
define|#
directive|define
name|jloff
value|(lkd.v2->ld_plt)
end_define

begin_expr_stmt
specifier|static
name|ext_pic_got
argument_list|(
name|rp
argument_list|,
name|sp
argument_list|,
name|sp1
argument_list|,
name|ps
argument_list|,
name|where
argument_list|,
name|b1
argument_list|)
specifier|register
expr|struct
name|relocation_info
operator|*
name|rp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|nlist
modifier|*
name|sp1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|slsymb
modifier|*
name|ps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|biobuf
modifier|*
name|b1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|rf
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|errmsg
init|=
literal|"can't reduce symbolic to relative:"
decl_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|ps
operator|=
name|sllookup
argument_list|(
operator|&
name|dpic
argument_list|,
operator|&
name|dpicseg
index|[
name|NSEG
index|]
argument_list|,
name|dpichash
argument_list|,
name|sp
argument_list|,
name|rp
operator|->
name|r_addend
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
name|ps
operator|=
name|sllookup
argument_list|(
operator|&
name|dpic
argument_list|,
operator|&
name|dpicseg
index|[
name|NSEG
index|]
argument_list|,
name|dpichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ps
operator|->
name|sl_new
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"data linkage botch"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ps
operator|->
name|sl_lo
operator|==
operator|-
literal|1
condition|)
block|{
name|ps
operator|->
name|sl_lo
operator|=
name|rtp
operator|->
name|dto
expr_stmt|;
name|relocate
argument_list|(
name|rp
argument_list|,
name|where
argument_list|,
name|rtp
operator|->
name|dto
argument_list|,
name|b1
argument_list|)
expr_stmt|;
if|if
condition|(
name|forcesymbolic
argument_list|(
name|forceflag
argument_list|,
name|sp1
argument_list|)
operator|||
name|entryflag
condition|)
block|{
comment|/* 				 * case where ld is asked to do 				 * symbolic to relative. 				 */
if|if
condition|(
operator|(
name|sp1
operator|->
name|n_type
operator|&
operator|(
name|N_TYPE
operator|+
name|N_EXT
operator|)
operator|)
operator|!=
name|N_EXT
operator|+
name|N_UNDF
condition|)
block|{
comment|/* 					 * this ps->offset is bogus here since  					 * for now we are ignoring offset+++ 					 */
if|if
condition|(
name|sp1
operator|->
name|n_type
operator|==
name|N_TEXT
operator|+
name|N_EXT
condition|)
operator|*
operator|(
name|rtp
operator|->
name|dtp
operator|)
operator|++
operator|=
name|sp1
operator|->
name|n_value
expr_stmt|;
else|else
operator|*
operator|(
name|rtp
operator|->
name|dtp
operator|)
operator|++
operator|=
name|sp1
operator|->
name|n_value
operator|+
name|ps
operator|->
name|sl_offset
expr_stmt|;
if|if
condition|(
name|entryflag
condition|)
block|{
name|rtp
operator|->
name|dto
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
return|return;
block|}
name|rf
operator||=
name|REL_RP
expr_stmt|;
block|}
else|else
block|{
name|rtp
operator|->
name|dtp
operator|++
expr_stmt|;
if|if
condition|(
name|forcesymbolic
argument_list|(
name|forceflag
argument_list|,
name|sp1
argument_list|)
condition|)
if|if
condition|(
name|assertflag
operator|&
name|NOSYMBOLIC
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|"%s %s\n"
argument_list|,
name|errmsg
argument_list|,
name|sp1
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|errlev
operator||=
literal|01
expr_stmt|;
block|}
block|}
block|}
else|else
operator|*
operator|(
name|rtp
operator|->
name|dtp
operator|)
operator|++
operator|=
name|ps
operator|->
name|sl_offset
expr_stmt|;
comment|/* 			 * cooking up new relocation datum 			 */
name|rf
operator||=
name|EXT_RP
operator|+
name|BSR_RP
expr_stmt|;
name|bldreloc
argument_list|(
name|rtp
argument_list|,
name|dloff
operator|+
name|rtp
operator|->
name|dto
argument_list|,
name|rf
argument_list|,
name|sp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|rtp
operator|->
name|dto
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
else|else
name|relocate
argument_list|(
name|rp
argument_list|,
name|where
argument_list|,
name|ps
operator|->
name|sl_lo
argument_list|,
name|b1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|jmp_slot
argument_list|(
name|rp
argument_list|,
name|sp
argument_list|,
name|sp1
argument_list|,
name|ps
argument_list|,
name|where
argument_list|,
name|b1
argument_list|,
name|tw
argument_list|,
name|creloc
argument_list|)
specifier|register
expr|struct
name|relocation_info
operator|*
name|rp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|nlist
modifier|*
name|sp1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|slsymb
modifier|*
name|ps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|biobuf
modifier|*
name|b1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|tw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|creloc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|rf
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|ps
operator|=
name|sllookup
argument_list|(
operator|&
name|tpic
argument_list|,
operator|&
name|tpicseg
index|[
name|NSEG
index|]
argument_list|,
name|tpichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
name|ps
operator|=
name|sllookup
argument_list|(
operator|&
name|tpic
argument_list|,
operator|&
name|tpicseg
index|[
name|NSEG
index|]
argument_list|,
name|tpichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ps
operator|->
name|sl_new
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"jump linkage botch"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ps
operator|->
name|sl_lo
operator|==
operator|-
literal|1
condition|)
block|{
name|tw
operator|+=
operator|(
name|jloff
operator|+
name|rtp
operator|->
name|jto
operator|)
operator|-
name|creloc
expr_stmt|;
name|relocate
argument_list|(
name|rp
argument_list|,
name|where
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sp1
operator|->
name|n_type
operator|&
operator|(
name|N_TYPE
operator|+
name|N_EXT
operator|)
operator|)
operator|==
name|N_EXT
operator|+
name|N_UNDF
operator|)
operator|||
operator|!
operator|(
name|forcesymbolic
argument_list|(
name|forceflag
argument_list|,
name|sp
argument_list|)
operator|||
name|entryflag
operator|)
condition|)
block|{
if|if
condition|(
name|forcesymbolic
argument_list|(
name|forceflag
argument_list|,
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|assertflag
operator|&
name|NOSYMBOLIC
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|"can't reduce symbolic to relative: %s"
argument_list|,
name|sp1
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|errlev
operator||=
literal|01
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
name|TARGET
operator|==
name|SUN4
define|#
directive|define
name|MASK
parameter_list|(
name|n
parameter_list|)
value|((1<<(n))-1)
define|#
directive|define
name|jmpoff
value|( (unsigned long)(-4 - rtp->jto) )
name|rtp
operator|->
name|jtp
operator|->
name|jb_inst
index|[
literal|0
index|]
operator|=
name|SAVE
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|jb_inst
index|[
literal|1
index|]
operator|=
name|CALL
operator||
operator|(
operator|(
name|jmpoff
operator|>>
literal|2
operator|)
operator|&
name|MASK
argument_list|(
literal|30
argument_list|)
operator|)
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|jb_inst
index|[
literal|2
index|]
operator|=
name|SETHIG0
operator||
operator|(
name|rtp
operator|->
name|rpp
operator|-
name|rtp
operator|->
name|rp
operator|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN2
define|#
directive|define
name|jmpoff
value|( (unsigned long)(-4 - rtp->jto) )
name|rtp
operator|->
name|jtp
operator|->
name|code
operator|=
name|NOP
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|cl_hi
operator|=
name|JBSR
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|cl_low
operator|=
name|jmpoff
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
define|#
directive|define
name|jmpoff
value|( (unsigned long)(-2 - rtp->jto) )
name|rtp
operator|->
name|jtp
operator|->
name|code
operator|=
name|JBSR
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|cl_hi
operator|=
name|jmpoff
operator|>>
literal|16
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|cl_low
operator|=
name|jmpoff
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* 				 * case where ld is asked to do 				 * symbolic to relative. 				 */
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|setupjs
argument_list|(
name|rtp
operator|->
name|jtp
argument_list|,
name|sp1
operator|->
name|n_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
name|rtp
operator|->
name|jtp
operator|->
name|code
operator|=
name|JUMP
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|cl_hi
operator|=
name|sp1
operator|->
name|n_value
operator|>>
literal|16
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|cl_low
operator|=
name|sp1
operator|->
name|n_value
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entryflag
condition|)
block|{
name|ps
operator|->
name|sl_lo
operator|=
name|rtp
operator|->
name|jto
expr_stmt|;
name|rtp
operator|->
name|jto
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|jbind
argument_list|)
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|++
expr_stmt|;
return|return;
block|}
name|rf
operator||=
name|REL_RP
expr_stmt|;
block|}
comment|/* 			 * cook up new relocation info 			 */
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
name|rtp
operator|->
name|jtp
operator|->
name|reloc_index
operator|=
name|rtp
operator|->
name|rpp
operator|-
name|rtp
operator|->
name|rp
expr_stmt|;
endif|#
directive|endif
name|ps
operator|->
name|sl_lo
operator|=
name|rtp
operator|->
name|jto
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|++
expr_stmt|;
name|rf
operator||=
name|EXT_RP
operator|+
name|JMP_RP
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|bldreloc
argument_list|(
name|rtp
argument_list|,
name|jloff
operator|+
name|rtp
operator|->
name|jto
argument_list|,
name|rf
argument_list|,
name|sp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
name|bldreloc
argument_list|(
name|rtp
argument_list|,
name|jloff
operator|+
name|rtp
operator|->
name|jto
operator|+
literal|2
argument_list|,
name|rf
argument_list|,
name|sp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rtp
operator|->
name|jto
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|jbind
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tw
operator|+=
operator|(
name|jloff
operator|+
name|ps
operator|->
name|sl_lo
operator|)
operator|-
name|creloc
expr_stmt|;
name|relocate
argument_list|(
name|rp
argument_list|,
name|where
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * This routine relocates the single text or data segment argument.  * Offsets from external symbols are resolved by adding the value  * of the external symbols.  Non-external reference are updated to account  * for the relative motion of the segments (ctrel, cdrel, ...).  If  * a relocation was pc-relative, then we update it to reflect the  * change in the positioning of the segments by adding the displacement  * of the referenced segment and subtracting the displacement of the  * current segment (creloc).  *  * If we are saving the relocation information, then we increase  * each relocation datum address by our base position in the new segment.  */
end_comment

begin_macro
name|load2td
argument_list|(
argument|creloc
argument_list|,
argument|position
argument_list|,
argument|b1
argument_list|,
argument|b2
argument_list|)
end_macro

begin_decl_stmt
name|long
name|creloc
decl_stmt|,
name|position
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|biobuf
modifier|*
name|b1
decl_stmt|,
modifier|*
name|b2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp1
decl_stmt|;
specifier|register
name|int
name|rf
decl_stmt|;
name|long
name|tw
decl_stmt|;
specifier|register
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|,
modifier|*
name|rpend
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|relp
decl_stmt|;
name|char
modifier|*
name|codep
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|relsz
decl_stmt|,
name|codesz
decl_stmt|;
name|struct
name|slsymb
modifier|*
name|ps
decl_stmt|;
name|int
name|piccode
decl_stmt|;
name|relsz
operator|=
name|reloc
operator|.
name|size
expr_stmt|;
name|relp
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|mymalloc
argument_list|(
name|relsz
argument_list|)
expr_stmt|;
name|codesz
operator|=
name|text
operator|.
name|size
expr_stmt|;
name|codep
operator|=
operator|(
name|char
operator|*
operator|)
name|mymalloc
argument_list|(
name|codesz
argument_list|)
expr_stmt|;
if|if
condition|(
name|relp
operator|==
literal|0
operator|||
name|codep
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of memory (load2td)"
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
name|relp
argument_list|,
name|relsz
argument_list|,
operator|&
name|reloc
argument_list|)
expr_stmt|;
name|rpend
operator|=
operator|&
name|relp
index|[
name|relsz
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
index|]
expr_stmt|;
name|mget
argument_list|(
name|codep
argument_list|,
name|codesz
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|relp
operator|,
name|piccode
operator|=
literal|0
init|;
name|rp
operator|<
name|rpend
condition|;
name|rp
operator|++
control|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_extern
operator|==
literal|0
condition|)
continue|continue;
name|sp
operator|=
name|getlocsymb
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
define|#
directive|define
name|IN_RANGE
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|((-(1<<((n)-1)))<=(v)&& (v)< (1<<((n)-1)))
comment|/* 		 * the peephole optimizer on sun4 figured out that 		 * sometimes the __GLOBAL_OFFSET_TABLE_ relocation is not 		 * needed (i.e only jmp_table reloc are in the routine) 		 * so we have to test here for both conditions. 		 */
if|if
condition|(
name|ISGT
argument_list|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
operator|||
name|rp
operator|->
name|r_type
operator|==
name|RELOC_JMP_TBL
condition|)
block|{
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
if|if
condition|(
name|ISGT
argument_list|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
operator|||
name|rp
operator|->
name|r_jmptable
condition|)
block|{
endif|#
directive|endif
name|piccode
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|rp
operator|=
name|relp
init|;
name|rp
operator|<
name|rpend
condition|;
name|rp
operator|++
control|)
block|{
name|rf
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|codep
operator|+
name|rp
operator|->
name|r_address
expr_stmt|;
comment|/* 	     * Search the hash table which maps local 	     * symbol numbers to symbol tables entries 	     * in the new a.out file. 	     */
if|if
condition|(
name|piccode
operator|||
name|rp
operator|->
name|r_extern
condition|)
name|sp
operator|=
name|getlocsymb
argument_list|(
name|rp
argument_list|)
expr_stmt|;
comment|/* 	     * Pick up previous value at location to be relocated. 	     */
if|#
directive|if
name|TARGET
operator|==
name|SUN4
comment|/* 		 * Pick up addend. 		 */
name|tw
operator|=
name|rp
operator|->
name|r_addend
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
switch|switch
condition|(
name|rp
operator|->
name|r_length
condition|)
block|{
case|case
literal|0
case|:
comment|/* byte */
name|tw
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* word */
name|tw
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* long */
comment|/* "cp" points to an least a 16-bit boundary, but 		     * not necessarily a 32-bit boundary. 		     */
ifdef|#
directive|ifdef
name|mc68000
comment|/* 68k host can do long accesses on 16-bit boundaries */
name|tw
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
expr_stmt|;
else|#
directive|else
comment|/*!mc68000*/
comment|/* others can only do long accesses on 32-bit bdy's */
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
operator|&
name|tw
operator|)
operator|)
operator|=
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
name|cp
operator|)
expr_stmt|;
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|tw
operator|)
operator|)
operator|+
literal|2
operator|)
operator|)
operator|=
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|cp
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/*mc68000*/
break|break;
default|default:
name|error
argument_list|(
literal|1
argument_list|,
literal|"load2td botch: bad length"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rp
operator|->
name|r_extern
condition|)
block|{
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|sp
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
if|if
condition|(
operator|(
name|sp1
operator|=
operator|*
name|lookup
argument_list|(
operator|&
name|ldsym
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"can't find symbol"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The 0'th entry of the GOT (which may not be its base 		 * address) is reserved to hold the location of __DYNAMIC. 		 */
if|if
condition|(
name|rtp
operator|->
name|dto
operator|==
literal|0
condition|)
block|{
name|rtp
operator|->
name|dto
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|rtp
operator|->
name|dtp
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|TARGET
operator|==
name|SUN4
if|if
condition|(
name|rp
operator|->
name|r_type
operator|==
name|RELOC_BASE10
operator|||
name|rp
operator|->
name|r_type
operator|==
name|RELOC_BASE13
operator|||
name|rp
operator|->
name|r_type
operator|==
name|RELOC_BASE22
condition|)
block|{
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
if|if
condition|(
name|rp
operator|->
name|r_baserel
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|rflag
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_extern
condition|)
name|rp
operator|->
name|r_symbolnum
operator|=
name|nsym
operator|+
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|sp1
argument_list|)
expr_stmt|;
else|else
name|rp
operator|->
name|r_symbolnum
operator|=
name|sp
operator|->
name|n_desc
operator|+
name|localsymbolno
expr_stmt|;
goto|goto
name|dorflag
goto|;
block|}
if|if
condition|(
name|rp
operator|->
name|r_extern
condition|)
block|{
name|ext_pic_got
argument_list|(
name|rp
argument_list|,
name|sp
argument_list|,
name|sp1
argument_list|,
name|ps
argument_list|,
name|cp
argument_list|,
name|b1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|ps
operator|=
name|sllookup
argument_list|(
operator|&
name|stpic
argument_list|,
operator|&
name|stpicseg
index|[
name|NSEG
index|]
argument_list|,
name|stpichash
argument_list|,
name|sp
argument_list|,
name|rp
operator|->
name|r_addend
argument_list|,
literal|0
argument_list|,
operator|(
name|rtp
operator|->
name|dtp
operator|-
name|rtp
operator|->
name|dt
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
name|ps
operator|=
name|sllookup
argument_list|(
operator|&
name|stpic
argument_list|,
operator|&
name|stpicseg
index|[
name|NSEG
index|]
argument_list|,
name|stpichash
argument_list|,
name|sp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|rtp
operator|->
name|dtp
operator|-
name|rtp
operator|->
name|dt
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ps
operator|->
name|sl_new
condition|)
block|{
name|ps
operator|->
name|sl_lo
operator|=
name|rtp
operator|->
name|dto
expr_stmt|;
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|rtp
operator|->
name|dto
argument_list|,
name|b1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|n_type
condition|)
block|{
case|case
name|N_TEXT
case|:
comment|/* tw += ctrel; */
name|tw
operator|+=
name|ctrel
operator|+
name|sp
operator|->
name|n_value
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
comment|/* tw += cdrel; */
name|tw
operator|+=
name|cdrel
operator|+
name|sp
operator|->
name|n_value
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
comment|/* tw += cbrel; */
name|tw
operator|+=
name|cbrel
operator|+
name|sp
operator|->
name|n_value
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|1
argument_list|,
literal|"base relative static symbol(%s) botch"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entryflag
operator|||
name|forcesymbolic
argument_list|(
name|forceflag
argument_list|,
name|sp
argument_list|)
condition|)
block|{
name|rf
operator||=
name|REL_RP
operator|+
name|BSR_RP
expr_stmt|;
name|bldreloc
argument_list|(
name|rtp
argument_list|,
name|dloff
operator|+
name|rtp
operator|->
name|dto
argument_list|,
name|rf
argument_list|,
literal|0
argument_list|,
name|rp
argument_list|)
expr_stmt|;
block|}
name|rtp
operator|->
name|dto
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
name|rtp
operator|->
name|dtp
operator|)
operator|++
operator|=
name|tw
expr_stmt|;
block|}
else|else
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|ps
operator|->
name|sl_lo
argument_list|,
name|b1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|#
directive|if
name|TARGET
operator|==
name|SUN4
if|if
condition|(
name|rp
operator|->
name|r_type
operator|==
name|RELOC_JMP_TBL
condition|)
block|{
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
if|if
condition|(
name|rp
operator|->
name|r_jmptable
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|rflag
condition|)
block|{
name|rp
operator|->
name|r_symbolnum
operator|=
name|nsym
operator|+
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|sp1
argument_list|)
expr_stmt|;
goto|goto
name|dorflag
goto|;
block|}
comment|/* 		 * pc relative call to a symbol in the data segment 		 */
if|if
condition|(
name|rp
operator|->
name|r_extern
operator|==
literal|0
condition|)
block|{
name|u_int
name|dsoff
decl_stmt|;
comment|/* offset into data segment */
name|dsoff
operator|=
name|tw
operator|-
operator|(
name|filhdr
operator|.
name|a_text
operator|-
name|rp
operator|->
name|r_address
operator|)
expr_stmt|;
name|tw
operator|=
name|cdrel
operator|+
name|filhdr
operator|.
name|a_text
operator|-
operator|(
name|ctrel
operator|+
name|rp
operator|->
name|r_address
operator|)
operator|+
name|dsoff
expr_stmt|;
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|jmp_slot
argument_list|(
name|rp
argument_list|,
name|sp
argument_list|,
name|sp1
argument_list|,
name|ps
argument_list|,
name|cp
argument_list|,
name|b1
argument_list|,
name|tw
argument_list|,
name|creloc
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|TARGET
operator|==
name|SUN4
if|if
condition|(
name|rp
operator|->
name|r_type
operator|==
name|RELOC_PC10
operator|||
name|rp
operator|->
name|r_type
operator|==
name|RELOC_PC22
condition|)
block|{
if|if
condition|(
operator|!
name|ISGT
argument_list|(
name|sp1
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"load2td: expect __GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|rp
operator|->
name|r_symbolnum
operator|=
name|nsym
operator|+
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|sp1
argument_list|)
expr_stmt|;
goto|goto
name|dorflag
goto|;
block|}
comment|/* 		 * pc relative reference that used 4 instructions since 		 * sparc doesn't have one pc relative instruction to 		 * access a symbol. 		 */
name|tw
operator|=
name|sp1
operator|->
name|n_value
operator|-
name|creloc
operator|-
name|rp
operator|->
name|r_address
operator|+
name|rp
operator|->
name|r_addend
expr_stmt|;
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* 	     * If relative to an external which is defined, 	     * resolve to a simpler kind of reference in the 	     * result file.  If the external is undefined, just 	     * convert the symbol number to the number of the 	     * symbol in the result file and leave it undefined. 	     */
define|#
directive|define
name|r_addr
value|rp->r_address + position + (b1 == dout ? database : textbase)
if|#
directive|if
name|TARGET
operator|==
name|SUN4
ifdef|#
directive|ifdef
name|_SUN4_DEVELOPMENT
define|#
directive|define
name|isitpcrel
parameter_list|(
name|rp
parameter_list|)
value|(rp->r_type == RELOC_DISP8 || rp->r_type == RELOC_DISP16\ 	    || rp->r_type == RELOC_DISP32 || rp->r_type == RELOC_WDISP30 \ 	    || rp->r_type == oRELOC_WDISP23 || rp->r_type == RELOC_WDISP22)
else|#
directive|else
define|#
directive|define
name|isitpcrel
parameter_list|(
name|rp
parameter_list|)
value|(rp->r_type == RELOC_DISP8 || rp->r_type == RELOC_DISP16\ 	    || rp->r_type == RELOC_DISP32 || rp->r_type == RELOC_WDISP30 \ 	    || rp->r_type == RELOC_WDISP22)
endif|#
directive|endif
endif|_SUN4_DEVELOPMENT
endif|#
directive|endif
if|if
condition|(
name|rp
operator|->
name|r_extern
condition|)
block|{
if|if
condition|(
name|sp1
operator|->
name|n_type
operator|==
name|N_EXT
operator|+
name|N_UNDF
condition|)
block|{
name|rp
operator|->
name|r_symbolnum
operator|=
name|nsym
operator|+
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|sp1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ISDYNAMIC
operator|)
operator|&&
operator|!
name|rflag
condition|)
block|{
comment|/* 			 * if we are forced to allocate both common and 			 * procedure then all that are left here should 			 * be procedure (all the common should be turn  			 * into BSS type by now). 			 * 			 * if we are forced to declare only common then 			 * what is left here are normal relocation to  			 * undefined routines. 			 * 			 * if we are forced to allocate only procedure 			 * then what we are concerned here are the symbols 			 * with a value of 0. 			 */
if|if
condition|(
name|pflag
condition|)
block|{
if|if
condition|(
operator|(
name|ps
operator|=
name|slfindit
argument_list|(
name|tpichash
argument_list|,
name|sp1
argument_list|,
literal|0
argument_list|,
name|hashit
argument_list|(
name|sp1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|sl_lo
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|TARGET
operator|==
name|SUN4
if|if
condition|(
name|isitpcrel
argument_list|(
name|rp
argument_list|)
condition|)
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
if|if
condition|(
name|rp
operator|->
name|r_pcrel
condition|)
endif|#
directive|endif
name|tw
operator|+=
operator|(
name|jloff
operator|+
name|rtp
operator|->
name|jto
operator|)
operator|-
name|creloc
expr_stmt|;
else|else
name|tw
operator|+=
operator|(
name|jloff
operator|+
name|rtp
operator|->
name|jto
operator|)
expr_stmt|;
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
if|if
condition|(
name|forceflag
operator|&
name|SYMBOLIC
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"symbolic flag botch"
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|rtp
operator|->
name|jtp
operator|->
name|jb_inst
index|[
literal|0
index|]
operator|=
name|SAVE
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|jb_inst
index|[
literal|1
index|]
operator|=
name|CALL
operator||
operator|(
operator|(
name|jmpoff
operator|>>
literal|2
operator|)
operator|&
name|MASK
argument_list|(
literal|30
argument_list|)
operator|)
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|jb_inst
index|[
literal|2
index|]
operator|=
name|SETHIG0
operator||
operator|(
name|rtp
operator|->
name|rpp
operator|-
name|rtp
operator|->
name|rp
operator|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN2
name|rtp
operator|->
name|jtp
operator|->
name|code
operator|=
name|NOP
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|cl_hi
operator|=
name|JBSR
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|cl_low
operator|=
name|jmpoff
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
name|rtp
operator|->
name|jtp
operator|->
name|code
operator|=
name|JBSR
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|cl_hi
operator|=
name|jmpoff
operator|>>
literal|16
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|->
name|cl_low
operator|=
name|jmpoff
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
name|rtp
operator|->
name|jtp
operator|->
name|reloc_index
operator|=
name|rtp
operator|->
name|rpp
operator|-
name|rtp
operator|->
name|rp
expr_stmt|;
endif|#
directive|endif
name|ps
operator|->
name|sl_lo
operator|=
name|rtp
operator|->
name|jto
expr_stmt|;
name|rtp
operator|->
name|jtp
operator|++
expr_stmt|;
name|rf
operator||=
name|EXT_RP
operator|+
name|JMP_RP
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|bldreloc
argument_list|(
name|rtp
argument_list|,
name|jloff
operator|+
name|rtp
operator|->
name|jto
argument_list|,
name|rf
argument_list|,
name|sp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
name|bldreloc
argument_list|(
name|rtp
argument_list|,
name|jloff
operator|+
name|rtp
operator|->
name|jto
operator|+
literal|2
argument_list|,
name|rf
argument_list|,
name|sp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rtp
operator|->
name|jto
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|jbind
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|TARGET
operator|==
name|SUN4
if|if
condition|(
name|isitpcrel
argument_list|(
name|rp
argument_list|)
condition|)
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
if|if
condition|(
name|rp
operator|->
name|r_pcrel
condition|)
endif|#
directive|endif
name|tw
operator|+=
operator|(
name|jloff
operator|+
name|ps
operator|->
name|sl_lo
operator|)
operator|-
name|creloc
expr_stmt|;
else|else
name|tw
operator|+=
operator|(
name|jloff
operator|+
name|ps
operator|->
name|sl_lo
operator|)
expr_stmt|;
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
if|#
directive|if
name|TARGET
operator|==
name|SUN4
if|if
condition|(
name|isitpcrel
argument_list|(
name|rp
argument_list|)
condition|)
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
if|if
condition|(
name|rp
operator|->
name|r_pcrel
condition|)
endif|#
directive|endif
if|if
condition|(
name|b1
operator|!=
name|tout
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"no pc rel from data"
argument_list|)
expr_stmt|;
else|else
block|{
name|rf
operator||=
name|PCREL_RP
expr_stmt|;
name|tw
operator|-=
name|creloc
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|rp
operator|->
name|r_addend
operator|=
name|tw
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|rf
operator||=
name|EXT_RP
expr_stmt|;
name|bldreloc
argument_list|(
name|rtp
argument_list|,
name|r_addr
argument_list|,
name|rf
argument_list|,
name|sp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* what a kludge here */
if|#
directive|if
operator|(
name|TARGET
operator|==
name|SUN3
operator|)
operator|||
operator|(
name|TARGET
operator|==
name|SUN2
operator|)
if|if
condition|(
name|ISGT
argument_list|(
name|sp1
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|rflag
condition|)
goto|goto
name|dorflag
goto|;
name|rp
operator|->
name|r_symbolnum
operator|=
name|sp1
operator|->
name|n_type
operator|&
name|N_TYPE
expr_stmt|;
name|tw
operator|+=
name|sp1
operator|->
name|n_value
expr_stmt|;
name|rp
operator|->
name|r_extern
operator|=
literal|0
expr_stmt|;
name|tw
operator|-=
name|creloc
expr_stmt|;
comment|/* ++++ assumes that this is pcrel */
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|,
name|rp
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* 		     * This is the case of a non pic module referencing  		     * a defined symbol. 		     */
if|if
condition|(
operator|!
name|rflag
operator|&&
operator|!
name|entryflag
operator|&&
operator|(
name|bindingflag
operator|!=
name|ST_BIND
operator|)
operator|&&
operator|!
operator|(
name|forcesymbolic
argument_list|(
name|forceflag
argument_list|,
name|sp1
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|TARGET
operator|==
name|SUN4
if|if
condition|(
name|isitpcrel
argument_list|(
name|rp
argument_list|)
condition|)
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
if|if
condition|(
name|rp
operator|->
name|r_pcrel
condition|)
endif|#
directive|endif
if|if
condition|(
name|b1
operator|!=
name|tout
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"no pc rel from data"
argument_list|)
expr_stmt|;
else|else
block|{
name|rf
operator||=
name|PCREL_RP
expr_stmt|;
name|tw
operator|-=
name|creloc
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|rp
operator|->
name|r_addend
operator|=
name|tw
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|rf
operator||=
name|EXT_RP
expr_stmt|;
name|bldreloc
argument_list|(
name|rtp
argument_list|,
name|r_addr
argument_list|,
name|rf
argument_list|,
name|sp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rp
operator|->
name|r_symbolnum
operator|=
name|sp1
operator|->
name|n_type
operator|&
name|N_TYPE
expr_stmt|;
name|tw
operator|+=
name|sp1
operator|->
name|n_value
expr_stmt|;
name|rp
operator|->
name|r_extern
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ISDYNAMIC
operator|)
operator|&&
operator|!
name|rflag
condition|)
block|{
if|if
condition|(
name|forcesymbolic
argument_list|(
name|forceflag
argument_list|,
name|sp1
argument_list|)
condition|)
block|{
if|#
directive|if
name|TARGET
operator|==
name|SUN4
if|if
condition|(
name|isitpcrel
argument_list|(
name|rp
argument_list|)
condition|)
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
if|if
condition|(
name|rp
operator|->
name|r_pcrel
condition|)
endif|#
directive|endif
if|if
condition|(
name|b1
operator|!=
name|tout
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"no pc rel from data"
argument_list|)
expr_stmt|;
else|else
block|{
name|tw
operator|-=
name|creloc
expr_stmt|;
name|rf
operator||=
name|DONE_RP
expr_stmt|;
block|}
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
name|rf
operator||=
name|REL_RP
expr_stmt|;
name|bldreloc
argument_list|(
name|rtp
argument_list|,
name|r_addr
argument_list|,
name|rf
argument_list|,
literal|0
argument_list|,
name|rp
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
else|else
switch|switch
condition|(
name|rp
operator|->
name|r_symbolnum
operator|&
name|N_TYPE
condition|)
block|{
comment|/* 	     * Relocation is relative to the loaded position 	     * of another segment.  Update by the change in position 	     * of that segment. 	     */
case|case
name|N_TEXT
case|:
name|tw
operator|+=
name|ctrel
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
break|break;
if|if
condition|(
operator|!
name|entryflag
operator|&&
operator|(
operator|(
name|bindingflag
operator|&
name|DN_BIND
operator|)
operator|||
operator|!
operator|(
name|bindingflag
operator|&
name|ST_BIND
operator|)
operator|)
condition|)
block|{
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
name|rf
operator||=
name|REL_RP
expr_stmt|;
name|bldreloc
argument_list|(
name|rtp
argument_list|,
name|r_addr
argument_list|,
name|rf
argument_list|,
literal|0
argument_list|,
name|rp
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|N_DATA
case|:
name|tw
operator|+=
name|cdrel
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
break|break;
if|if
condition|(
operator|!
name|entryflag
operator|&&
operator|(
operator|(
name|bindingflag
operator|&
name|DN_BIND
operator|)
operator|||
operator|!
operator|(
name|bindingflag
operator|&
name|ST_BIND
operator|)
operator|)
condition|)
block|{
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
name|rf
operator||=
name|REL_RP
expr_stmt|;
name|bldreloc
argument_list|(
name|rtp
argument_list|,
name|r_addr
argument_list|,
name|rf
argument_list|,
literal|0
argument_list|,
name|rp
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|N_BSS
case|:
name|tw
operator|+=
name|cbrel
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
break|break;
if|if
condition|(
operator|!
name|entryflag
operator|&&
operator|(
operator|(
name|bindingflag
operator|&
name|DN_BIND
operator|)
operator|||
operator|!
operator|(
name|bindingflag
operator|&
name|ST_BIND
operator|)
operator|)
condition|)
block|{
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
name|rf
operator||=
name|REL_RP
expr_stmt|;
name|bldreloc
argument_list|(
name|rtp
argument_list|,
name|r_addr
argument_list|,
name|rf
argument_list|,
literal|0
argument_list|,
name|rp
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|N_ABS
case|:
break|break;
default|default:
name|error
argument_list|(
literal|1
argument_list|,
literal|"relocation format botch (symbol type))"
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * Relocation is pc relative, so decrease the relocation 	     * by the amount the current segment is displaced. 	     * (E.g if we are a relative reference to a text location 	     * from data space, we added the increase in the text address 	     * above, and subtract the increase in our (data) address 	     * here, leaving the net change the relative change in the 	     * positioning of our text and data segments.) 	     */
name|dorflag
label|:
if|#
directive|if
name|TARGET
operator|==
name|SUN4
switch|switch
condition|(
name|rp
operator|->
name|r_type
condition|)
block|{
case|case
name|RELOC_DISP8
case|:
case|case
name|RELOC_DISP16
case|:
case|case
name|RELOC_DISP32
case|:
case|case
name|RELOC_WDISP30
case|:
ifdef|#
directive|ifdef
name|_SUN4_DEVELOPMENT
case|case
name|oRELOC_WDISP23
case|:
endif|#
directive|endif
endif|_SUN4_DEVELOPMENT
case|case
name|RELOC_WDISP22
case|:
case|case
name|RELOC_JMP_TBL
case|:
name|tw
operator|-=
name|creloc
expr_stmt|;
block|}
comment|/* 	     * If we're saving the relocation record, just stuff the 	     * value back into it. Otherwise, 	     * Put the value back in the segment, 	     * while checking for overflow. 	     */
if|if
condition|(
name|rflag
condition|)
block|{
name|rp
operator|->
name|r_addend
operator|=
name|tw
expr_stmt|;
name|rp
operator|->
name|r_address
operator|+=
name|position
expr_stmt|;
block|}
else|else
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
if|if
condition|(
name|rp
operator|->
name|r_pcrel
condition|)
name|tw
operator|-=
name|creloc
expr_stmt|;
name|relocate
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
name|tw
argument_list|,
name|b1
argument_list|)
expr_stmt|;
comment|/* 	     * If we are saving relocation information, 	     * we must convert the address in the segment from 	     * the old .o file into an address in the segment in 	     * the new a.out, by adding the position of our 	     * segment in the new larger segment. 	     */
if|if
condition|(
name|rflag
condition|)
name|rp
operator|->
name|r_address
operator|+=
name|position
expr_stmt|;
endif|#
directive|endif
block|}
name|bwrite
argument_list|(
name|codep
argument_list|,
name|codesz
argument_list|,
name|b1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|bwrite
argument_list|(
name|relp
argument_list|,
name|relsz
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|relp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|codep
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|setupjs
argument_list|(
name|jtp
argument_list|,
name|val
argument_list|)
specifier|register
expr|struct
name|jbind
operator|*
name|jtp
expr_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|jtp
operator|->
name|jb_inst
index|[
literal|0
index|]
operator|=
name|SETHI
operator||
operator|(
operator|(
name|val
operator|>>
operator|(
literal|32
operator|-
literal|22
operator|)
operator|)
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
expr_stmt|;
name|jtp
operator|->
name|jb_inst
index|[
literal|1
index|]
operator|=
name|JMPI
operator||
operator|(
name|val
operator|&
name|MASK
argument_list|(
literal|10
argument_list|)
operator|)
expr_stmt|;
name|jtp
operator|->
name|jb_inst
index|[
literal|2
index|]
operator|=
name|NOP
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*   *  This routine build a relocation record for runtime linking  */
name|bldreloc
argument_list|(
name|rt
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|sp
argument_list|,
name|rp
argument_list|)
specifier|register
expr|struct
name|runtime
operator|*
name|rt
expr_stmt|;
specifier|register
name|int
name|addr
decl_stmt|;
specifier|register
name|int
name|flag
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|;
block|{
comment|/* 	 * If we are building a fully statically linked program, and we 	 * are doing a pic relocation against undefined symbols, it is 	 * possible for us to get asked to build a relocation entry 	 * for the undefined reference.  Of course, because we aren't 	 * doing any dynamic linking, we won't have a table to build 	 * it against.  Check for this here, and just pretend success 	 * in such a circumstance. 	 */
if|if
condition|(
name|rt
operator|->
name|rpp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|rflag
operator|&&
operator|(
operator|(
name|ISDYNAMIC
operator|)
operator|||
name|forceflag
operator|&
name|SYMBOLIC
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"bldreloc: relocation table missing"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Verify arguments and proceed to build a new relocation entry. 	 */
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Illegal flag"
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rpp
operator|->
name|r_address
operator|=
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|assertflag
operator|&
name|PURE_TEXT
operator|)
operator|&&
operator|!
operator|(
name|rflag
operator|||
name|Nflag
operator|)
condition|)
if|if
condition|(
name|addr
operator|<
name|database
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"assert pure-text failed: reference to %s at %x in %s\n"
argument_list|,
operator|(
name|sp
operator|==
literal|0
condition|?
literal|"[offset]"
else|:
name|sp
operator|->
name|n_un
operator|.
name|n_name
operator|)
argument_list|,
name|addr
argument_list|,
name|filname
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
name|rt
operator|->
name|rpp
operator|->
name|r_addend
operator|=
name|rp
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|REL_RP
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|JMP_RP
condition|)
name|rt
operator|->
name|rpp
operator|->
name|r_type
operator|=
name|RELOC_RELATIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
operator|&
name|BSR_RP
condition|)
name|rt
operator|->
name|rpp
operator|->
name|r_type
operator|=
name|RELOC_32
expr_stmt|;
else|else
name|rt
operator|->
name|rpp
operator|->
name|r_type
operator|=
name|rp
operator|->
name|r_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|&
name|BSR_RP
condition|)
name|rt
operator|->
name|rpp
operator|->
name|r_type
operator|=
name|RELOC_GLOB_DAT
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
operator|&
name|JMP_RP
condition|)
name|rt
operator|->
name|rpp
operator|->
name|r_type
operator|=
name|RELOC_JMP_SLOT
expr_stmt|;
else|else
name|rt
operator|->
name|rpp
operator|->
name|r_type
operator|=
name|rp
operator|->
name|r_type
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
if|if
condition|(
name|flag
operator|&
name|REL_RP
condition|)
name|rt
operator|->
name|rpp
operator|->
name|r_relative
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|JMP_RP
condition|)
name|rt
operator|->
name|rpp
operator|->
name|r_jmptable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|BSR_RP
condition|)
name|rt
operator|->
name|rpp
operator|->
name|r_baserel
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|PCREL_RP
condition|)
name|rt
operator|->
name|rpp
operator|->
name|r_pcrel
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag
operator|&
name|EXT_RP
condition|)
block|{
if|if
condition|(
operator|(
name|rt
operator|->
name|rpp
operator|->
name|r_symbolnum
operator|=
name|fslookup
argument_list|(
name|sp
argument_list|,
name|rt
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"fast symbol botch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|REL_RP
condition|)
name|rt
operator|->
name|rpp
operator|->
name|r_extern
operator|=
literal|0
expr_stmt|;
else|else
name|rt
operator|->
name|rpp
operator|->
name|r_extern
operator|=
literal|1
expr_stmt|;
block|}
name|rt
operator|->
name|rpp
operator|++
expr_stmt|;
name|relocused
operator|++
expr_stmt|;
block|}
name|relocate
argument_list|(
argument|rp
argument_list|,
argument|where
argument_list|,
argument|what
argument_list|,
argument|b1
argument_list|)
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|long
name|what
decl_stmt|;
name|struct
name|biobuf
modifier|*
name|b1
decl_stmt|;
block|{
if|#
directive|if
name|TARGET
operator|==
name|SUN4
switch|switch
condition|(
name|rp
operator|->
name|r_type
condition|)
block|{
case|case
name|RELOC_8
case|:
case|case
name|RELOC_DISP8
case|:
if|if
condition|(
operator|!
name|IN_RANGE
argument_list|(
name|what
argument_list|,
literal|8
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"byte displacement overflow at %s+%#x"
argument_list|,
name|b1
operator|==
name|tout
condition|?
literal|"text"
else|:
literal|"data"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
operator|*
name|where
operator|=
name|what
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|_SUN4_DEVELOPMENT
case|case
name|oRELOC_LO9
case|:
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|9
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|9
argument_list|)
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|_SUN4_DEVELOPMENT
case|case
name|RELOC_LO10
case|:
case|case
name|RELOC_PC10
case|:
case|case
name|RELOC_BASE10
case|:
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|10
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|10
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|RELOC_BASE13
case|:
case|case
name|RELOC_13
case|:
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|13
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|13
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|RELOC_16
case|:
case|case
name|RELOC_DISP16
case|:
if|if
condition|(
operator|!
name|IN_RANGE
argument_list|(
name|what
argument_list|,
literal|16
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"word displacement overflow at %s+%#x"
argument_list|,
name|b1
operator|==
name|tout
condition|?
literal|"text"
else|:
literal|"data"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|where
operator|=
name|what
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|_SUN4_DEVELOPMENT
case|case
name|oRELOC_23
case|:
if|if
condition|(
operator|!
name|IN_RANGE
argument_list|(
name|what
argument_list|,
literal|23
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"sethi displacement overflow at %s+%#x"
argument_list|,
name|b1
operator|==
name|tout
condition|?
literal|"text"
else|:
literal|"data"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|23
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|23
argument_list|)
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|_SUN4_DEVELOPMENT
case|case
name|RELOC_22
case|:
if|if
condition|(
operator|!
name|IN_RANGE
argument_list|(
name|what
argument_list|,
literal|22
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"sethi displacement overflow at %s+%#x"
argument_list|,
name|b1
operator|==
name|tout
condition|?
literal|"text"
else|:
literal|"data"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|_SUN4_DEVELOPMENT
case|case
name|oRELOC_HI23
case|:
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|23
argument_list|)
operator|)
operator||
operator|(
operator|(
name|what
operator|>>
operator|(
literal|32
operator|-
literal|23
operator|)
operator|)
operator|&
name|MASK
argument_list|(
literal|23
argument_list|)
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|_SUN4_DEVELOPMENT
case|case
name|RELOC_HI22
case|:
case|case
name|RELOC_BASE22
case|:
case|case
name|RELOC_PC22
case|:
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
operator||
operator|(
operator|(
name|what
operator|>>
operator|(
literal|32
operator|-
literal|22
operator|)
operator|)
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|_SUN4_DEVELOPMENT
case|case
name|oRELOC_WDISP23
case|:
if|if
condition|(
name|what
operator|&
name|MASK
argument_list|(
literal|2
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"odd word displacement at %s+%#x"
argument_list|,
name|b1
operator|==
name|tout
condition|?
literal|"text"
else|:
literal|"data"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|what
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|IN_RANGE
argument_list|(
name|what
argument_list|,
literal|23
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"branch displacement overflow at %s+%#x"
argument_list|,
name|b1
operator|==
name|tout
condition|?
literal|"text"
else|:
literal|"data"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|23
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|23
argument_list|)
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|_SUN4_DEVELOPMENT
case|case
name|RELOC_WDISP22
case|:
if|if
condition|(
name|what
operator|&
name|MASK
argument_list|(
literal|2
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"odd word displacement at %s+%#x"
argument_list|,
name|b1
operator|==
name|tout
condition|?
literal|"text"
else|:
literal|"data"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|what
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|IN_RANGE
argument_list|(
name|what
argument_list|,
literal|22
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"branch displacement overflow at %s+%#x"
argument_list|,
name|b1
operator|==
name|tout
condition|?
literal|"text"
else|:
literal|"data"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|22
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|RELOC_JMP_TBL
case|:
case|case
name|RELOC_WDISP30
case|:
if|if
condition|(
name|what
operator|&
name|MASK
argument_list|(
literal|2
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"odd word displacement at %s+%#x"
argument_list|,
name|b1
operator|==
name|tout
condition|?
literal|"text"
else|:
literal|"data"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|what
operator|>>=
literal|2
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|&
operator|~
name|MASK
argument_list|(
literal|30
argument_list|)
operator|)
operator||
operator|(
name|what
operator|&
name|MASK
argument_list|(
literal|30
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|RELOC_32
case|:
case|case
name|RELOC_DISP32
case|:
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
name|what
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|||
name|TARGET
operator|==
name|SUN3
comment|/* 	 * Put the value back in the segment, 	 * while checking for overflow. 	 */
switch|switch
condition|(
name|rp
operator|->
name|r_length
condition|)
block|{
case|case
literal|0
case|:
comment|/* byte */
if|if
condition|(
name|what
operator|<
operator|-
literal|128
operator|||
name|what
operator|>
literal|127
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"byte displacement overflow at %s+%#x"
argument_list|,
name|b1
operator|==
name|tout
condition|?
literal|"text"
else|:
literal|"data"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
operator|*
name|where
operator|=
name|what
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* word */
if|if
condition|(
name|what
operator|<
operator|-
literal|32768
operator|||
name|what
operator|>
literal|32767
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"word displacement overflow at %s+%#x"
argument_list|,
name|b1
operator|==
name|tout
condition|?
literal|"text"
else|:
literal|"data"
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|where
operator|=
name|what
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* long */
comment|/* "where" points to an least a 16-bit boundary, but 		 * not necessarily a 32-bit boundary. 		 */
ifdef|#
directive|ifdef
name|mc68000
comment|/* 68k host can do long accesses on 16-bit boundaries */
operator|*
operator|(
name|long
operator|*
operator|)
name|where
operator|=
name|what
expr_stmt|;
else|#
directive|else
comment|/*!mc68000*/
comment|/* others can only do long accesses on 32-bit bdy's */
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
name|where
operator|)
operator|=
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
operator|&
name|what
operator|)
operator|)
expr_stmt|;
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|where
operator|+
literal|2
operator|)
operator|)
operator|=
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|what
operator|)
operator|)
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/*mc68000*/
break|break;
block|}
endif|#
directive|endif
block|}
name|finishout
argument_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|int
name|nsymt
decl_stmt|;
comment|/* 	 * if dynamic linking then flush out the data, jump linkage table plus 	 * the relocation datum followed by the hash table for the fast symbols 	 * and the symbols themselves.  	 */
if|if
condition|(
operator|!
name|rflag
condition|)
block|{
name|int
modifier|*
name|j
init|=
name|rtp
operator|->
name|dt
decl_stmt|;
name|struct
name|jbind
modifier|*
name|k
init|=
name|rtp
operator|->
name|jt
decl_stmt|;
if|if
condition|(
name|ISDYNAMIC
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|lalign
argument_list|(
name|rtp
operator|->
name|fsoff
argument_list|)
operator|)
operator|!=
name|rtp
operator|->
name|fsalloc
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|"allocated %d used %d for fast symb"
argument_list|,
name|rtp
operator|->
name|fsalloc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|relocused
operator|!=
name|rtp
operator|->
name|rl
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|"no of reloc used %d != no alloc %d"
argument_list|,
name|relocused
argument_list|,
name|rtp
operator|->
name|rl
argument_list|)
expr_stmt|;
block|}
block|{
name|struct
name|relocation_info
modifier|*
name|l
init|=
name|rtp
operator|->
name|rp
decl_stmt|;
name|struct
name|fshash
modifier|*
name|m
init|=
name|rtp
operator|->
name|hp
decl_stmt|;
name|struct
name|nlist
modifier|*
name|n
init|=
name|rtp
operator|->
name|sp
decl_stmt|;
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sl
operator|.
name|ds
operator|+
name|sl
operator|.
name|ss
condition|;
name|i
operator|++
control|)
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|j
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|dynout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sl
operator|.
name|js
condition|;
name|i
operator|++
control|)
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|k
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|jbind
argument_list|)
argument_list|,
name|dynout
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
argument_list|,
name|pad
argument_list|,
name|dynout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rtp
operator|->
name|rl
condition|;
name|i
operator|++
control|)
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|l
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
argument_list|,
name|tout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rtp
operator|->
name|hp_ind
condition|;
name|i
operator|++
control|)
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|m
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fshash
argument_list|)
argument_list|,
name|tout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalsymb
argument_list|()
condition|;
name|i
operator|++
control|)
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|n
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|tout
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rtp
operator|->
name|fsstr
argument_list|,
name|rtp
operator|->
name|fsalloc
argument_list|,
name|tout
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtp
operator|->
name|searchpath
condition|)
name|bwrite
argument_list|(
name|rtp
operator|->
name|searchpath
argument_list|,
name|lalign
argument_list|(
name|rtp
operator|->
name|spthlen
argument_list|)
argument_list|,
name|tout
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rtp
operator|->
name|lko
argument_list|,
name|dynamic
operator|.
name|lib
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|link_object
argument_list|)
argument_list|,
name|tout
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
name|shlibstr
argument_list|,
name|dynamic
operator|.
name|libstr
argument_list|,
name|tout
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dynamic
operator|.
name|ds
operator|+
name|dynamic
operator|.
name|js
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sl
operator|.
name|ds
operator|+
name|sl
operator|.
name|ss
condition|;
name|i
operator|++
control|)
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|j
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|dynout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sl
operator|.
name|js
condition|;
name|i
operator|++
control|)
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|k
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|jbind
argument_list|)
argument_list|,
name|dynout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sflag
operator|==
literal|0
condition|)
block|{
name|nsymt
operator|=
name|symx
argument_list|(
operator|&
name|ldsym
argument_list|,
name|ldsym
operator|.
name|ns
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsymt
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|xsym
argument_list|(
name|ldsym
operator|.
name|fs
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|n_type
operator|==
name|DISCARDIT
condition|)
continue|continue;
comment|/* 			 * ++++ -g option for the symbolic debugger 			 * generated symbol types N_UNDF and N_ABS 			 * that can have value 0. Is this correct  			 * to say here that if we see such symbol the 			 * we can write it out. Checking for external 			 * text symbol here to deal with flag -N -T 0. 			 */
if|if
condition|(
operator|!
name|rflag
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|n_value
operator|!=
literal|0
operator|||
name|sp
operator|->
name|n_type
operator|==
name|N_UNDF
operator|||
name|sp
operator|->
name|n_type
operator|==
name|N_EXT
operator|+
name|N_TEXT
operator|||
name|sp
operator|->
name|n_type
operator|==
name|N_ABS
operator|||
name|sp
operator|->
name|n_type
operator|==
name|N_ABS
operator|+
name|N_EXT
condition|)
name|symwrite
argument_list|(
name|sp
argument_list|,
name|sout
argument_list|)
expr_stmt|;
block|}
else|else
name|symwrite
argument_list|(
name|sp
argument_list|,
name|sout
argument_list|)
expr_stmt|;
block|}
name|bwrite
argument_list|(
operator|&
name|offset
argument_list|,
sizeof|sizeof
name|offset
argument_list|,
name|sout
argument_list|)
expr_stmt|;
comment|/* 		 * if appropriate, write out extra sections  		 * following the string table 		 */
name|write_extra_sections
argument_list|(
name|strout
argument_list|)
expr_stmt|;
block|}
name|filname
operator|=
name|aoutname
expr_stmt|;
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|ofilename
argument_list|,
name|aoutname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|filname
operator|=
name|NULL
expr_stmt|;
comment|/* kludge */
name|error
argument_list|(
literal|1
argument_list|,
literal|"cannot move temp file %s to %s: %s"
argument_list|,
name|ofilename
argument_list|,
name|aoutname
argument_list|,
name|errmsg
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|delarg
operator|=
name|errlev
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
name|mkfsym
argument_list|(
argument|s
argument_list|,
argument|value
argument_list|,
argument|type
argument_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|value
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
specifier|static
name|struct
name|nlist
name|fsym
decl_stmt|;
if|if
condition|(
name|sflag
operator|||
name|xflag
condition|)
return|return;
name|fsym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|s
expr_stmt|;
name|fsym
operator|.
name|n_type
operator|=
name|type
expr_stmt|;
name|fsym
operator|.
name|n_value
operator|=
name|value
expr_stmt|;
name|symwrite
argument_list|(
operator|&
name|fsym
argument_list|,
name|sout
argument_list|)
expr_stmt|;
block|}
name|getarhdr
argument_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|archdr
argument_list|,
sizeof|sizeof
name|archdr
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|archdr
operator|.
name|ar_name
init|;
name|cp
operator|<
operator|&
name|archdr
operator|.
name|ar_name
index|[
sizeof|sizeof
argument_list|(
name|archdr
operator|.
name|ar_name
argument_list|)
index|]
condition|;
control|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|' '
condition|)
block|{
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|mget
argument_list|(
name|loc
argument_list|,
name|n
argument_list|,
name|sp
argument_list|)
specifier|register
name|STREAM
operator|*
name|sp
expr_stmt|;
specifier|register
name|char
modifier|*
name|loc
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|take
decl_stmt|;
specifier|register
name|int
name|nread
decl_stmt|;
name|top
label|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|sp
operator|->
name|size
operator|&&
name|sp
operator|->
name|nibuf
condition|)
block|{
name|p
operator|=
name|sp
operator|->
name|ptr
expr_stmt|;
name|take
operator|=
name|sp
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|take
operator|>
name|sp
operator|->
name|nibuf
condition|)
name|take
operator|=
name|sp
operator|->
name|nibuf
expr_stmt|;
if|if
condition|(
name|take
operator|>
name|n
condition|)
name|take
operator|=
name|n
expr_stmt|;
name|n
operator|-=
name|take
expr_stmt|;
name|sp
operator|->
name|size
operator|-=
name|take
expr_stmt|;
name|sp
operator|->
name|nibuf
operator|-=
name|take
expr_stmt|;
name|sp
operator|->
name|pos
operator|+=
name|take
expr_stmt|;
do|do
operator|*
name|loc
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|take
operator|>
literal|0
condition|)
do|;
name|sp
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|n
operator|>
name|p_blksize
condition|)
block|{
name|take
operator|=
name|n
operator|-
name|n
operator|%
name|p_blksize
expr_stmt|;
name|lseek
argument_list|(
name|infil
argument_list|,
operator|(
name|sp
operator|->
name|bno
operator|+
literal|1
operator|)
operator|<<
name|p_blkshift
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|take
operator|>
name|sp
operator|->
name|size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"premature EOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|=
name|read
argument_list|(
name|infil
argument_list|,
name|loc
argument_list|,
name|take
argument_list|)
operator|!=
name|take
condition|)
block|{
if|if
condition|(
name|nread
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errmsg
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"premature EOF"
argument_list|)
expr_stmt|;
block|}
name|loc
operator|+=
name|take
expr_stmt|;
name|n
operator|-=
name|take
expr_stmt|;
name|sp
operator|->
name|size
operator|-=
name|take
expr_stmt|;
name|sp
operator|->
name|pos
operator|+=
name|take
expr_stmt|;
name|dseek
argument_list|(
name|sp
argument_list|,
operator|(
name|sp
operator|->
name|bno
operator|+
literal|1
operator|+
operator|(
name|take
operator|>>
name|p_blkshift
operator|)
operator|)
operator|<<
name|p_blkshift
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
operator|*
name|loc
operator|++
operator|=
name|get
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|--
name|n
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|symwrite
argument_list|(
argument|sp
argument_list|,
argument|bp
argument_list|)
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|struct
name|biobuf
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|sp
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|sp
operator|->
name|n_un
operator|.
name|n_strx
operator|=
name|offset
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bwrite
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|strout
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|len
expr_stmt|;
block|}
name|bwrite
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|n_un
operator|.
name|n_name
operator|=
name|str
expr_stmt|;
name|nsymwrite
operator|++
expr_stmt|;
block|}
name|dseek
argument_list|(
name|sp
argument_list|,
name|loc
argument_list|,
name|s
argument_list|)
specifier|register
name|STREAM
operator|*
name|sp
expr_stmt|;
name|long
name|loc
decl_stmt|,
name|s
decl_stmt|;
block|{
specifier|register
name|o
expr_stmt|;
name|o
operator|=
name|loc
operator|&
name|p_blkmask
expr_stmt|;
if|if
condition|(
name|o
operator|&
literal|01
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"loader error; odd offset"
argument_list|)
expr_stmt|;
name|dseek1
argument_list|(
name|sp
argument_list|,
name|loc
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|dseek1
argument_list|(
name|sp
argument_list|,
name|loc
argument_list|,
name|s
argument_list|)
specifier|register
name|STREAM
operator|*
name|sp
expr_stmt|;
name|long
name|loc
decl_stmt|,
name|s
decl_stmt|;
block|{
specifier|register
name|PAGE
modifier|*
name|p
decl_stmt|;
specifier|register
name|b
operator|,
name|o
expr_stmt|;
name|int
name|n
decl_stmt|;
name|b
operator|=
name|loc
operator|>>
name|p_blkshift
expr_stmt|;
name|o
operator|=
name|loc
operator|&
name|p_blkmask
expr_stmt|;
operator|--
name|sp
operator|->
name|pno
operator|->
name|nuser
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
operator|)
operator|->
name|bno
operator|!=
name|b
operator|&&
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|1
index|]
operator|)
operator|->
name|bno
operator|!=
name|b
condition|)
if|if
condition|(
name|p
operator|->
name|nuser
operator|==
literal|0
operator|||
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
operator|)
operator|->
name|nuser
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|nuser
operator|==
literal|0
operator|&&
name|page
index|[
literal|1
index|]
operator|.
name|nuser
operator|==
literal|0
condition|)
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|bno
operator|<
name|page
index|[
literal|1
index|]
operator|.
name|bno
condition|)
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|->
name|bno
operator|=
name|b
expr_stmt|;
name|lseek
argument_list|(
name|infil
argument_list|,
name|loc
operator|&
operator|~
operator|(
name|long
operator|)
name|p_blkmask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|infil
argument_list|,
name|p
operator|->
name|buff
argument_list|,
name|p_blksize
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errmsg
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|nibuf
operator|=
name|n
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"botch: no pages"
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|nuser
expr_stmt|;
name|sp
operator|->
name|bno
operator|=
name|b
expr_stmt|;
name|sp
operator|->
name|pno
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|s
operator|!=
operator|-
literal|1
condition|)
block|{
name|sp
operator|->
name|size
operator|=
name|s
expr_stmt|;
name|sp
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
block|}
name|sp
operator|->
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|buff
operator|+
name|o
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|nibuf
operator|=
name|p
operator|->
name|nibuf
operator|-
name|o
operator|)
operator|<=
literal|0
condition|)
name|sp
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|char
name|get
parameter_list|(
name|asp
parameter_list|)
name|STREAM
modifier|*
name|asp
decl_stmt|;
block|{
specifier|register
name|STREAM
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|asp
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|nibuf
operator|-=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dseek
argument_list|(
name|sp
argument_list|,
operator|(
call|(
name|long
call|)
argument_list|(
name|sp
operator|->
name|bno
operator|+
literal|1
argument_list|)
operator|<<
name|p_blkshift
operator|)
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|nibuf
operator|-=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|size
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"premature EOF"
argument_list|)
expr_stmt|;
operator|++
name|fpage
operator|.
name|nuser
expr_stmt|;
operator|--
name|sp
operator|->
name|pno
operator|->
name|nuser
expr_stmt|;
name|sp
operator|->
name|pno
operator|=
operator|(
name|PAGE
operator|*
operator|)
operator|&
name|fpage
expr_stmt|;
block|}
name|sp
operator|->
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|sp
operator|->
name|ptr
operator|++
operator|)
return|;
block|}
name|getfile
argument_list|(
argument|acp
argument_list|,
argument|mj
argument_list|,
argument|mn
argument_list|,
argument|sizep
argument_list|)
name|char
modifier|*
name|acp
decl_stmt|;
name|int
modifier|*
name|mj
decl_stmt|;
name|int
modifier|*
name|mn
decl_stmt|;
name|long
modifier|*
name|sizep
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
union|union
block|{
name|char
name|arcmag
index|[
name|SARMAG
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|exec
name|ex
decl_stmt|;
block|}
name|u
union|;
name|struct
name|stat
name|stb
decl_stmt|;
ifdef|#
directive|ifdef
name|SUNPRO
name|char
modifier|*
name|path
decl_stmt|;
endif|#
directive|endif
name|cp
operator|=
name|acp
expr_stmt|;
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|filname
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
name|infil
operator|=
name|libopen
argument_list|(
name|filname
operator|+
literal|2
argument_list|,
name|O_RDONLY
argument_list|,
name|mj
argument_list|,
name|mn
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|SUNPRO
name|infil
operator|=
name|open_vroot
argument_list|(
name|filname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|VROOT_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|char
modifier|*
name|full_path
decl_stmt|;
name|get_vroot_path
argument_list|(
operator|&
name|full_path
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|full_path
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|infil
operator|=
name|open
argument_list|(
name|filname
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|infil
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errmsg
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|infil
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
name|page
index|[
literal|0
index|]
operator|.
name|bno
operator|=
name|page
index|[
literal|1
index|]
operator|.
name|bno
operator|=
operator|-
literal|1
expr_stmt|;
name|page
index|[
literal|0
index|]
operator|.
name|nuser
operator|=
name|page
index|[
literal|1
index|]
operator|.
name|nuser
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|stb
operator|.
name|st_blksize
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|||
operator|(
name|c
operator|&
operator|(
name|c
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* use default size if not a power of two */
name|c
operator|=
name|BLKSIZE
expr_stmt|;
block|}
if|if
condition|(
name|p_blksize
operator|!=
name|c
condition|)
block|{
name|p_blksize
operator|=
name|c
expr_stmt|;
name|p_blkmask
operator|=
name|c
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p_blkshift
operator|=
literal|0
init|;
name|c
operator|>
literal|1
condition|;
name|p_blkshift
operator|++
control|)
name|c
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|buff
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|page
index|[
literal|0
index|]
operator|.
name|buff
argument_list|)
expr_stmt|;
name|page
index|[
literal|0
index|]
operator|.
name|buff
operator|=
operator|(
name|char
operator|*
operator|)
name|mymalloc
argument_list|(
name|p_blksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|buff
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (getfile)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
index|[
literal|1
index|]
operator|.
name|buff
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|page
index|[
literal|1
index|]
operator|.
name|buff
argument_list|)
expr_stmt|;
name|page
index|[
literal|1
index|]
operator|.
name|buff
operator|=
operator|(
name|char
operator|*
operator|)
name|mymalloc
argument_list|(
name|p_blksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
index|[
literal|1
index|]
operator|.
name|buff
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (getfile)"
argument_list|)
expr_stmt|;
block|}
name|text
operator|.
name|pno
operator|=
name|reloc
operator|.
name|pno
operator|=
operator|(
name|PAGE
operator|*
operator|)
operator|&
name|fpage
expr_stmt|;
name|fpage
operator|.
name|nuser
operator|=
literal|2
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
literal|0L
argument_list|,
name|SARMAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"premature EOF"
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
name|u
operator|.
name|arcmag
argument_list|,
name|SARMAG
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|u
operator|.
name|arcmag
index|[
name|SARMAG
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|u
operator|.
name|arcmag
argument_list|,
name|ARMAG
argument_list|)
condition|)
block|{
if|if
condition|(
name|u
operator|.
name|ex
operator|.
name|a_dynamic
condition|)
return|return
operator|(
name|SHLIB
operator|)
return|;
else|else
block|{
if|if
condition|(
name|sizep
operator|!=
name|NULL
condition|)
if|if
condition|(
name|u
operator|.
name|ex
operator|.
name|a_magic
operator|!=
name|ZMAGIC
condition|)
operator|*
name|sizep
operator|=
name|stb
operator|.
name|st_size
expr_stmt|;
else|else
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|PLAIN
operator|)
return|;
block|}
block|}
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|SARMAG
argument_list|,
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
return|return
operator|(
name|ARCH1
operator|)
return|;
name|getarhdr
argument_list|()
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|archdr
operator|.
name|ar_name
argument_list|,
literal|"__.SYMDEF"
argument_list|,
sizeof|sizeof
argument_list|(
name|archdr
operator|.
name|ar_name
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ARCH1
operator|)
return|;
comment|/* 	 * +++++++ kludge. have to get rid of this stuff later 	 */
return|return
operator|(
name|stb
operator|.
name|st_mtime
operator|>
name|atol
argument_list|(
name|archdr
operator|.
name|ar_date
argument_list|)
operator|+
literal|60
condition|?
name|ARCH3
else|:
name|ARCH2
operator|)
return|;
block|}
comment|/*  * Search for a library with given name  * using the directory search array.  */
name|libopen
argument_list|(
argument|name
argument_list|,
argument|oflags
argument_list|,
argument|mj
argument_list|,
argument|mn
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|oflags
decl_stmt|;
name|int
modifier|*
name|mj
decl_stmt|;
name|int
modifier|*
name|mn
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|pp
decl_stmt|,
modifier|*
name|tpp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|lib
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|SUNPRO
name|char
modifier|*
name|path
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * for shared library we are not reporting make dependency 	 * since it could be changed at runtime. ++++ will need 	 * to revisit this area at some future date 	 */
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
comment|/* backwards compat */
name|name
operator|=
literal|"a"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndir
operator|&&
name|fd
operator|==
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|lib
argument_list|,
literal|"lib"
argument_list|)
expr_stmt|;
comment|/* 		 * Fix up library name if verision number was specifed 		 */
if|if
condition|(
operator|(
name|tpp
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|tpp
operator|==
literal|'.'
operator|||
name|isdigit
argument_list|(
operator|*
name|tpp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|tpp
operator|==
literal|'.'
condition|)
name|pp
operator|=
name|tpp
expr_stmt|;
name|tpp
operator|--
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|lib
argument_list|,
name|name
argument_list|,
name|pp
operator|-
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|lib
argument_list|,
literal|".so"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|lib
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|lib
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|forceflag
operator|&
name|DYNAMIC
operator|)
operator|&&
name|getshlib
argument_list|(
name|buf
argument_list|,
name|lib
argument_list|,
name|mj
argument_list|,
name|mn
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|oflags
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|SUNPRO
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"lib"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|".a"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open_vroot
argument_list|(
name|buf
argument_list|,
name|oflags
argument_list|,
literal|0
argument_list|,
name|sp_dirs
index|[
name|i
index|]
argument_list|,
name|VROOT_DEFAULT
argument_list|)
expr_stmt|;
name|get_vroot_path
argument_list|(
name|NULL
argument_list|,
operator|&
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|report_dependency
argument_list|(
name|stripvroot
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|do_report_libdep
argument_list|(
name|buf
argument_list|,
literal|"LD"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/lib"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|".a"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|oflags
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|filname
operator|=
name|buf
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
name|struct
name|nlist
modifier|*
modifier|*
name|lookup
parameter_list|(
name|st
parameter_list|)
name|struct
name|syminfo
modifier|*
name|st
decl_stmt|;
block|{
specifier|register
name|int
name|sh
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
specifier|register
name|struct
name|symseg
modifier|*
name|gp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|sh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"object file inconsistency: symbol has no string"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|sh
operator|=
operator|(
name|sh
operator|<<
literal|1
operator|)
operator|+
operator|*
name|cp
operator|++
expr_stmt|;
name|sh
operator|=
operator|(
name|sh
operator|&
literal|0x7fffffff
operator|)
operator|%
name|HSIZE
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|st
operator|->
name|fs
init|;
name|gp
operator|<
operator|&
operator|(
name|st
operator|->
name|fs
index|[
name|NSEG
index|]
operator|)
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|gp
operator|->
name|sy_first
operator|==
literal|0
condition|)
block|{
name|gp
operator|->
name|sy_first
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|calloc
argument_list|(
name|NSYM
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
name|gp
operator|->
name|sy_hfirst
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|HSIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|sy_first
operator|==
literal|0
operator|||
name|gp
operator|->
name|sy_hfirst
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of space for symbol table"
argument_list|)
expr_stmt|;
name|gp
operator|->
name|sy_last
operator|=
name|gp
operator|->
name|sy_first
operator|+
name|NSYM
expr_stmt|;
name|gp
operator|->
name|sy_hlast
operator|=
name|gp
operator|->
name|sy_hfirst
operator|+
name|HSIZE
expr_stmt|;
block|}
if|if
condition|(
name|gp
operator|>
name|st
operator|->
name|cs
condition|)
name|st
operator|->
name|cs
operator|=
name|gp
expr_stmt|;
name|hp
operator|=
name|gp
operator|->
name|sy_hfirst
operator|+
name|sh
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|hp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gp
operator|->
name|sy_used
operator|==
name|NSYM
condition|)
break|break;
return|return
operator|(
name|hp
operator|)
return|;
block|}
name|cp1
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cursym
operator|.
name|n_un
operator|.
name|n_name
init|;
operator|*
name|cp
operator|==
operator|*
name|cp1
operator|++
condition|;
control|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|0
condition|)
return|return
operator|(
name|hp
operator|)
return|;
name|hp
operator|+=
name|i
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|hp
operator|>=
name|gp
operator|->
name|sy_hlast
condition|)
name|hp
operator|-=
name|HSIZE
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|HSIZE
condition|)
do|;
if|if
condition|(
name|i
operator|>
name|HSIZE
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"hash table botch"
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|1
argument_list|,
literal|"symbol table overflow"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|symfree
argument_list|(
argument|st
argument_list|,
argument|saved
argument_list|)
name|struct
name|syminfo
modifier|*
name|st
decl_stmt|;
name|struct
name|nlist
modifier|*
name|saved
decl_stmt|;
block|{
specifier|register
name|struct
name|symseg
modifier|*
name|gp
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|gp
operator|=
name|st
operator|->
name|cs
init|;
name|gp
operator|>=
name|st
operator|->
name|fs
condition|;
name|gp
operator|--
operator|,
name|st
operator|->
name|cs
operator|--
control|)
block|{
name|sp
operator|=
name|gp
operator|->
name|sy_first
operator|+
name|gp
operator|->
name|sy_used
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|saved
condition|)
block|{
name|st
operator|->
name|ns
operator|=
name|sp
expr_stmt|;
return|return;
block|}
for|for
control|(
name|sp
operator|--
init|;
name|sp
operator|>=
name|gp
operator|->
name|sy_first
condition|;
name|sp
operator|--
control|)
block|{
name|gp
operator|->
name|sy_hfirst
index|[
name|sp
operator|->
name|n_hash
index|]
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|sy_used
operator|--
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|saved
condition|)
block|{
name|st
operator|->
name|ns
operator|=
name|sp
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|saved
operator|==
literal|0
condition|)
return|return;
name|error
argument_list|(
literal|1
argument_list|,
literal|"symfree botch"
argument_list|)
expr_stmt|;
block|}
name|struct
name|nlist
modifier|*
modifier|*
name|slookup
parameter_list|(
name|s
parameter_list|,
name|st
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|syminfo
modifier|*
name|st
decl_stmt|;
block|{
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|s
expr_stmt|;
name|cursym
operator|.
name|n_type
operator|=
name|N_EXT
operator|+
name|N_UNDF
expr_stmt|;
name|cursym
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|lookup
argument_list|(
name|st
argument_list|)
operator|)
return|;
block|}
name|enter
argument_list|(
name|st
argument_list|,
name|hp
argument_list|,
name|nsp
argument_list|)
specifier|register
expr|struct
name|syminfo
operator|*
name|st
expr_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|nsp
decl_stmt|;
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|*
name|hp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hp
operator|<
name|st
operator|->
name|cs
operator|->
name|sy_hfirst
operator|||
name|hp
operator|>=
name|st
operator|->
name|cs
operator|->
name|sy_hlast
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"enter botch"
argument_list|)
expr_stmt|;
operator|*
name|hp
operator|=
name|st
operator|->
name|ls
operator|=
name|sp
operator|=
name|st
operator|->
name|cs
operator|->
name|sy_first
operator|+
name|st
operator|->
name|cs
operator|->
name|sy_used
expr_stmt|;
name|st
operator|->
name|cs
operator|->
name|sy_used
operator|++
expr_stmt|;
name|sp
operator|->
name|n_un
operator|.
name|n_name
operator|=
name|nsp
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
name|sp
operator|->
name|n_type
operator|=
name|nsp
operator|->
name|n_type
expr_stmt|;
name|sp
operator|->
name|n_hash
operator|=
name|hp
operator|-
name|st
operator|->
name|cs
operator|->
name|sy_hfirst
expr_stmt|;
name|sp
operator|->
name|n_value
operator|=
name|nsp
operator|->
name|n_value
expr_stmt|;
name|st
operator|->
name|ns
operator|=
name|st
operator|->
name|ls
operator|+
literal|1
expr_stmt|;
call|(
modifier|*
name|dp
call|)
argument_list|(
literal|"enter: %s\t%s\t%x\t%x\n"
argument_list|,
name|st
operator|==
operator|&
name|shsym
condition|?
literal|"shsym"
else|:
literal|"ldsym"
argument_list|,
name|nsp
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
name|nsp
operator|->
name|n_type
argument_list|,
name|nsp
operator|->
name|n_value
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|st
operator|->
name|ls
operator|=
operator|*
name|hp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|symx
argument_list|(
argument|st
argument_list|,
argument|sp
argument_list|)
name|struct
name|syminfo
modifier|*
name|st
decl_stmt|;
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|struct
name|symseg
modifier|*
name|gp
decl_stmt|;
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|gp
operator|=
name|st
operator|->
name|cs
init|;
name|gp
operator|>=
name|st
operator|->
name|fs
condition|;
name|gp
operator|--
control|)
comment|/*<= is sloppy so ldsym.ns will always work */
if|if
condition|(
name|sp
operator|>=
name|gp
operator|->
name|sy_first
operator|&&
name|sp
operator|<=
name|gp
operator|->
name|sy_last
condition|)
return|return
operator|(
operator|(
name|gp
operator|-
name|st
operator|->
name|fs
operator|)
operator|*
name|NSYM
operator|+
name|sp
operator|-
name|gp
operator|->
name|sy_first
operator|)
return|;
name|error
argument_list|(
literal|1
argument_list|,
literal|"symx botch"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|symreloc
argument_list|()
block|{
if|if
condition|(
name|funding
condition|)
return|return;
switch|switch
condition|(
name|cursym
operator|.
name|n_type
operator|&
operator|(
name|N_TYPE
operator|+
name|N_EXT
operator|)
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_EXT
operator|+
name|N_TEXT
case|:
name|cursym
operator|.
name|n_value
operator|+=
name|ctrel
expr_stmt|;
return|return;
case|case
name|N_DATA
case|:
case|case
name|N_EXT
operator|+
name|N_DATA
case|:
name|cursym
operator|.
name|n_value
operator|+=
name|cdrel
expr_stmt|;
return|return;
case|case
name|N_BSS
case|:
case|case
name|N_EXT
operator|+
name|N_BSS
case|:
name|cursym
operator|.
name|n_value
operator|+=
name|cbrel
expr_stmt|;
return|return;
case|case
name|N_EXT
operator|+
name|N_UNDF
case|:
return|return;
default|default:
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|&
name|N_EXT
condition|)
name|cursym
operator|.
name|n_type
operator|=
name|N_EXT
operator|+
name|N_ABS
expr_stmt|;
return|return;
block|}
block|}
comment|/*VARARGS 2*/
name|error
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|w
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|,
argument|z
argument_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|==
operator|-
literal|2
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ld: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|filname
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|filname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|-
literal|1
operator|&&
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(%s)"
argument_list|,
name|archdr
operator|.
name|ar_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|w
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|n
condition|)
name|delexit
argument_list|()
expr_stmt|;
name|errlev
operator|=
literal|2
expr_stmt|;
block|}
name|char
modifier|*
name|errmsg
parameter_list|(
name|errnum
parameter_list|)
name|int
name|errnum
decl_stmt|;
block|{
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|6
operator|+
literal|10
operator|+
literal|1
index|]
decl_stmt|;
comment|/* "Error " + "int" + '\0' */
if|if
condition|(
name|errnum
operator|<
literal|0
operator|||
name|errnum
operator|>
name|sys_nerr
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Error %d"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
else|else
return|return
operator|(
name|sys_errlist
index|[
name|errnum
index|]
operator|)
return|;
block|}
name|readhdr
argument_list|(
argument|loc
argument_list|)
name|off_t
name|loc
decl_stmt|;
block|{
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|filhdr
argument_list|)
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|short
operator|*
operator|)
operator|&
name|filhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|filhdr
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|filhdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|filhdr
operator|.
name|a_magic
operator|==
name|OARMAG
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"old archive"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad magic number"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|||
name|TARGET
operator|==
name|SUN2
if|if
condition|(
name|filhdr
operator|.
name|a_machtype
operator|==
name|M_68020
condition|)
block|{
name|use68020
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|filhdr
operator|.
name|a_machtype
operator|==
name|M_68010
operator|||
name|filhdr
operator|.
name|a_machtype
operator|==
name|M_OLDSUN2
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"wrong machine type"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sun3 */
if|if
condition|(
name|filhdr
operator|.
name|a_text
operator|&
literal|01
operator|||
name|filhdr
operator|.
name|a_data
operator|&
literal|01
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"text/data size odd"
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|SUN4
if|if
condition|(
name|filhdr
operator|.
name|a_machtype
operator|!=
name|M_SPARC
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"wrong machine type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filhdr
operator|.
name|a_toolversion
operator|!=
name|TV_SUN4
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|"linker expected toolversion number 0x%x and got 0x%x"
argument_list|,
name|TV_SUN4
argument_list|,
name|filhdr
operator|.
name|a_toolversion
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* sun4 */
if|if
condition|(
name|filhdr
operator|.
name|a_magic
operator|==
name|NMAGIC
operator|||
name|filhdr
operator|.
name|a_magic
operator|==
name|ZMAGIC
condition|)
block|{
name|cdrel
operator|=
operator|-
name|round
argument_list|(
name|filhdr
operator|.
name|a_text
argument_list|,
name|segsize
argument_list|()
argument_list|)
expr_stmt|;
name|cbrel
operator|=
name|cdrel
operator|-
name|filhdr
operator|.
name|a_data
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filhdr
operator|.
name|a_magic
operator|==
name|OMAGIC
condition|)
block|{
name|cdrel
operator|=
operator|-
name|filhdr
operator|.
name|a_text
expr_stmt|;
name|cbrel
operator|=
name|cdrel
operator|-
name|filhdr
operator|.
name|a_data
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad format"
argument_list|)
expr_stmt|;
block|}
name|round
argument_list|(
argument|v
argument_list|,
argument|r
argument_list|)
name|int
name|v
decl_stmt|;
name|u_long
name|r
decl_stmt|;
block|{
name|r
operator|--
expr_stmt|;
name|v
operator|+=
name|r
expr_stmt|;
name|v
operator|&=
operator|~
operator|(
name|long
operator|)
name|r
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
name|char
modifier|*
name|savestr
parameter_list|(
name|cp
parameter_list|,
name|stab
parameter_list|,
name|sleft
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
modifier|*
name|stab
decl_stmt|;
name|int
modifier|*
name|sleft
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|*
name|sleft
condition|)
block|{
operator|*
name|sleft
operator|=
name|NSAVETAB
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|*
name|sleft
condition|)
name|saveleft
operator|=
operator|*
name|sleft
expr_stmt|;
operator|*
name|stab
operator|=
name|mymalloc
argument_list|(
operator|*
name|sleft
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|stab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (savestr)"
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
operator|*
name|stab
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|*
name|stab
expr_stmt|;
operator|*
name|stab
operator|+=
name|len
expr_stmt|;
operator|*
name|sleft
operator|-=
name|len
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
name|bopen
argument_list|(
name|bp
argument_list|,
name|off
argument_list|,
name|bufsize
argument_list|)
specifier|register
expr|struct
name|biobuf
operator|*
name|bp
expr_stmt|;
block|{
name|bp
operator|->
name|b_ptr
operator|=
name|bp
operator|->
name|b_buf
operator|=
name|mymalloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_ptr
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (bopen)"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|bufsize
expr_stmt|;
name|bp
operator|->
name|b_nleft
operator|=
name|bufsize
operator|-
operator|(
name|off
operator|%
name|bufsize
operator|)
expr_stmt|;
name|bp
operator|->
name|b_off
operator|=
name|off
expr_stmt|;
name|bp
operator|->
name|b_link
operator|=
name|biobufs
expr_stmt|;
name|biobufs
operator|=
name|bp
expr_stmt|;
block|}
name|int
name|bwrerror
decl_stmt|;
name|bwrite
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|bp
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|struct
name|biobuf
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|int
name|put
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|nwritten
decl_stmt|;
name|top
label|:
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|bp
operator|->
name|b_nleft
condition|)
block|{
name|put
operator|=
name|bp
operator|->
name|b_nleft
expr_stmt|;
if|if
condition|(
name|put
operator|>
name|cnt
condition|)
name|put
operator|=
name|cnt
expr_stmt|;
name|bp
operator|->
name|b_nleft
operator|-=
name|put
expr_stmt|;
name|to
operator|=
name|bp
operator|->
name|b_ptr
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|to
argument_list|,
name|put
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_ptr
operator|+=
name|put
expr_stmt|;
name|p
operator|+=
name|put
expr_stmt|;
name|cnt
operator|-=
name|put
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|cnt
operator|>=
name|bp
operator|->
name|b_bufsize
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_ptr
operator|!=
name|bp
operator|->
name|b_buf
condition|)
name|bflush1
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|put
operator|=
name|cnt
operator|-
name|cnt
operator|%
name|bp
operator|->
name|b_bufsize
expr_stmt|;
if|if
condition|(
name|boffset
operator|!=
name|bp
operator|->
name|b_off
condition|)
name|lseek
argument_list|(
name|biofd
argument_list|,
name|bp
operator|->
name|b_off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nwritten
operator|=
name|write
argument_list|(
name|biofd
argument_list|,
name|p
argument_list|,
name|put
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwritten
operator|!=
name|put
condition|)
block|{
name|bwrerror
operator|=
literal|1
expr_stmt|;
name|filname
operator|=
name|ofilename
expr_stmt|;
comment|/* kludge */
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* kludge */
if|if
condition|(
name|nwritten
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"output write error: %s"
argument_list|,
name|errmsg
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"output write error: premature EOF"
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_off
operator|+=
name|put
expr_stmt|;
name|boffset
operator|=
name|bp
operator|->
name|b_off
expr_stmt|;
name|p
operator|+=
name|put
expr_stmt|;
name|cnt
operator|-=
name|put
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|bflush1
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|bflush
argument_list|()
block|{
specifier|register
name|struct
name|biobuf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|bwrerror
condition|)
return|return;
for|for
control|(
name|bp
operator|=
name|biobufs
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_link
control|)
name|bflush1
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|bflush1
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|biobuf
operator|*
name|bp
expr_stmt|;
block|{
specifier|register
name|int
name|cnt
init|=
name|bp
operator|->
name|b_ptr
operator|-
name|bp
operator|->
name|b_buf
decl_stmt|;
specifier|register
name|int
name|nwritten
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|boffset
operator|!=
name|bp
operator|->
name|b_off
condition|)
name|lseek
argument_list|(
name|biofd
argument_list|,
name|bp
operator|->
name|b_off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nwritten
operator|=
name|write
argument_list|(
name|biofd
argument_list|,
name|bp
operator|->
name|b_buf
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwritten
operator|!=
name|cnt
condition|)
block|{
name|bwrerror
operator|=
literal|1
expr_stmt|;
name|filname
operator|=
name|ofilename
expr_stmt|;
comment|/* kludge */
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* kludge */
if|if
condition|(
name|nwritten
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"output write error: %s"
argument_list|,
name|errmsg
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"output write error: premature EOF"
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_off
operator|+=
name|cnt
expr_stmt|;
name|boffset
operator|=
name|bp
operator|->
name|b_off
expr_stmt|;
name|bp
operator|->
name|b_ptr
operator|=
name|bp
operator|->
name|b_buf
expr_stmt|;
name|bp
operator|->
name|b_nleft
operator|=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
block|}
name|bflushc
argument_list|(
name|bp
argument_list|,
name|c
argument_list|)
specifier|register
expr|struct
name|biobuf
operator|*
name|bp
expr_stmt|;
block|{
name|bflush1
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bputc
argument_list|(
name|c
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|bseek
argument_list|(
name|bp
argument_list|,
name|off
argument_list|)
specifier|register
expr|struct
name|biobuf
operator|*
name|bp
expr_stmt|;
specifier|register
name|off_t
name|off
decl_stmt|;
block|{
name|bflush1
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_nleft
operator|=
name|bp
operator|->
name|b_bufsize
operator|-
operator|(
name|off
operator|%
name|bp
operator|->
name|b_bufsize
operator|)
expr_stmt|;
name|bp
operator|->
name|b_off
operator|=
name|off
expr_stmt|;
block|}
comment|/*  * total the symbols found  */
name|int
name|totalsymb
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSEG
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ldsym
operator|.
name|fs
index|[
name|i
index|]
operator|.
name|sy_first
operator|!=
literal|0
condition|)
name|j
operator|+=
name|ldsym
operator|.
name|fs
index|[
name|i
index|]
operator|.
name|sy_used
expr_stmt|;
else|else
break|break;
return|return
operator|(
name|j
operator|)
return|;
block|}
comment|/*  * old malloc where if you wanted to allocated 0 byte it will returned  * you a address instead of null  */
name|char
modifier|*
name|mymalloc
parameter_list|(
name|cc
parameter_list|)
name|int
name|cc
decl_stmt|;
block|{
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
return|return
operator|(
name|malloc
argument_list|(
literal|1
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|malloc
argument_list|(
name|cc
argument_list|)
operator|)
return|;
block|}
name|char
modifier|*
name|WhiteSp
init|=
literal|" 	|\\\n"
decl_stmt|;
name|char
modifier|*
modifier|*
name|prepend_argv
parameter_list|(
name|ld_opts
parameter_list|,
name|argv
parameter_list|,
name|argc
parameter_list|)
name|char
modifier|*
name|ld_opts
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
modifier|*
name|argc
decl_stmt|;
block|{
name|char
modifier|*
name|new
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
modifier|*
name|tmp_argv
init|=
name|NULL
decl_stmt|;
name|int
name|tmp_argc
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nochars
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|ld_opts
argument_list|)
condition|)
name|ld_opts
operator|++
expr_stmt|;
name|s
operator|=
name|ld_opts
expr_stmt|;
name|nochars
operator|=
name|strlen
argument_list|(
name|ld_opts
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tmp_argc
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|strpbrk
argument_list|(
name|s
argument_list|,
name|WhiteSp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
else|else
block|{
operator|*
name|new
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|new
argument_list|)
condition|)
name|new
operator|++
expr_stmt|;
name|s
operator|=
name|new
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|tmp_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|tmp_argc
operator|+
operator|*
name|argc
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tmp_argv
operator|=
operator|*
name|argv
expr_stmt|;
name|s
operator|=
name|ld_opts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|i
operator|<
operator|(
name|tmp_argc
operator|+
operator|*
name|argc
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
operator|(
name|tmp_argc
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|<=
name|nochars
operator|)
operator|&&
operator|(
name|s
operator|!=
name|NULL
operator|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|nochars
operator|--
expr_stmt|;
block|}
name|tmp_argv
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|nochars
operator|-=
operator|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
operator|)
operator|)
operator|>
literal|1
condition|)
name|s
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|s
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
name|tmp_argv
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
operator|-
name|tmp_argc
index|]
expr_stmt|;
block|}
empty_stmt|;
operator|*
name|argc
operator|+=
name|tmp_argc
expr_stmt|;
return|return
operator|(
name|tmp_argv
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|BROWSER
name|cb_callback_write_stab
argument_list|()
block|{ }
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUNPRO
struct|struct
name|slc
block|{
comment|/* SUNPRO libdep cell */
name|char
modifier|*
name|slc_name
decl_stmt|;
comment|/* name of dependent library */
name|struct
name|slc
modifier|*
name|slc_next
decl_stmt|;
comment|/* next cell */
block|}
struct|;
name|do_report_libdep
argument_list|(
argument|path
argument_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|struct
name|slc
modifier|*
name|p
decl_stmt|;
specifier|static
name|struct
name|slc
modifier|*
name|sp
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|slc
modifier|*
modifier|*
name|spp
init|=
operator|&
name|sp
decl_stmt|;
for|for
control|(
name|p
operator|=
name|sp
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|slc_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|path
argument_list|,
name|p
operator|->
name|slc_name
argument_list|)
operator|==
literal|0
condition|)
return|return;
block|}
operator|*
name|spp
operator|=
operator|(
expr|struct
name|slc
operator|*
operator|)
name|mymalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|slc
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|spp
operator|)
operator|->
name|slc_name
operator|=
operator|(
name|char
operator|*
operator|)
name|strcpy
argument_list|(
name|mymalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
operator|*
name|spp
operator|)
operator|->
name|slc_next
operator|=
operator|(
expr|struct
name|slc
operator|*
operator|)
literal|0
expr_stmt|;
name|spp
operator|=
operator|&
operator|(
operator|*
name|spp
operator|)
operator|->
name|slc_next
expr_stmt|;
name|report_libdep
argument_list|(
name|path
argument_list|,
literal|"LD"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|NSE
end_endif

end_unit

