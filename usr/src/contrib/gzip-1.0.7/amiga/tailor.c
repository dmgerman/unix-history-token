begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tailor.c -- target dependent functions  * Copyright (C) 1993 Carsten Steger (carsten.steger@informatik.tu-muenchen.de)  * This is free software; you can redistribute it and/or modify it under the  * terms of the GNU General Public License, see the file COPYING.  */
end_comment

begin_comment
comment|/*  * This file contains Amiga specific functions for gzip.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<error.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_include
include|#
directive|include
file|<exec/types.h>
end_include

begin_include
include|#
directive|include
file|<dos/dos.h>
end_include

begin_include
include|#
directive|include
file|<dos/dosextens.h>
end_include

begin_include
include|#
directive|include
file|<dos/dosasl.h>
end_include

begin_include
include|#
directive|include
file|<proto/dos.h>
end_include

begin_define
define|#
directive|define
name|MAXPATH
value|1024
end_define

begin_define
define|#
directive|define
name|MAXARGS
value|512
end_define

begin_decl_stmt
specifier|extern
name|struct
name|DosLibrary
modifier|*
name|DOSBase
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
modifier|*
name|xmalloc
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|expand_next_file
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in_prev_args
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|argc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_expand_args
parameter_list|(
name|int
modifier|*
name|oargc
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|oargv
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|expand_next_file
parameter_list|(
name|pattern
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
name|long
name|err
decl_stmt|;
name|char
modifier|*
name|pathname
decl_stmt|;
specifier|static
name|struct
name|AnchorPath
modifier|*
name|an
init|=
name|NULL
decl_stmt|;
name|pathname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL
condition|)
name|err
operator|=
operator|-
literal|1
expr_stmt|;
else|else
do|do
block|{
if|if
condition|(
name|an
operator|==
name|NULL
condition|)
block|{
name|an
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|AnchorPath
argument_list|)
operator|+
name|MAXPATH
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|an
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|AnchorPath
argument_list|)
operator|+
name|MAXPATH
argument_list|)
expr_stmt|;
name|an
operator|->
name|ap_BreakBits
operator|=
name|SIGBREAKF_CTRL_C
expr_stmt|;
name|an
operator|->
name|ap_Strlen
operator|=
name|MAXPATH
expr_stmt|;
name|an
operator|->
name|ap_Flags
operator|=
name|APF_DOWILD
expr_stmt|;
name|err
operator|=
name|MatchFirst
argument_list|(
name|pattern
argument_list|,
name|an
argument_list|)
expr_stmt|;
block|}
else|else
name|err
operator|=
name|MatchNext
argument_list|(
name|an
argument_list|)
expr_stmt|;
name|pathname
operator|=
name|an
operator|->
name|ap_Buf
expr_stmt|;
block|}
do|while
condition|(
name|err
operator|==
literal|0
operator|&&
name|pathname
operator|==
name|NULL
condition|)
do|;
if|if
condition|(
name|err
condition|)
block|{
name|MatchEnd
argument_list|(
name|an
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|an
argument_list|)
expr_stmt|;
name|an
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
return|return
name|pathname
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|in_prev_args
parameter_list|(
name|arg
parameter_list|,
name|argv
parameter_list|,
name|argc
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|,
decl|*
modifier|*
name|argv
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|is_in_args
decl_stmt|;
name|is_in_args
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stricmp
argument_list|(
name|arg
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|is_in_args
operator|=
literal|1
expr_stmt|;
return|return
name|is_in_args
return|;
block|}
end_block

begin_function
name|void
name|_expand_args
parameter_list|(
name|oargc
parameter_list|,
name|oargv
parameter_list|)
name|int
modifier|*
name|oargc
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|oargv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXPATH
index|]
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|no_match_at_all
decl_stmt|,
name|num_matches
decl_stmt|,
name|contains_wildcards
decl_stmt|;
comment|/* With Kickstart 1.3 wildcards can't be expanded. */
if|if
condition|(
name|DOSBase
operator|->
name|dl_lib
operator|.
name|lib_Version
operator|<
literal|37
condition|)
return|return;
name|no_match_at_all
operator|=
literal|1
expr_stmt|;
name|contains_wildcards
operator|=
literal|0
expr_stmt|;
name|argc
operator|=
literal|0
expr_stmt|;
name|argv
operator|=
name|xmalloc
argument_list|(
name|MAXARGS
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
operator|(
operator|*
name|oargv
operator|)
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|oargc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ParsePattern
argument_list|(
operator|(
operator|*
name|oargv
operator|)
index|[
name|i
index|]
argument_list|,
name|buf
argument_list|,
name|MAXPATH
argument_list|)
condition|)
block|{
name|contains_wildcards
operator|=
literal|1
expr_stmt|;
name|num_matches
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|str
operator|=
name|expand_next_file
argument_list|(
operator|(
operator|*
name|oargv
operator|)
index|[
name|i
index|]
argument_list|)
condition|)
if|if
condition|(
name|argc
operator|>=
name|MAXARGS
condition|)
block|{
name|expand_next_file
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many files.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Avoid duplicate entries */
if|if
condition|(
operator|!
name|in_prev_args
argument_list|(
name|str
argument_list|,
name|argv
argument_list|,
name|argc
argument_list|)
condition|)
block|{
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|num_matches
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_matches
operator|!=
literal|0
condition|)
name|no_match_at_all
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|>=
name|MAXARGS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many files.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|in_prev_args
argument_list|(
operator|(
operator|*
name|oargv
operator|)
index|[
name|i
index|]
argument_list|,
name|argv
argument_list|,
name|argc
argument_list|)
condition|)
name|argv
index|[
name|argc
operator|++
index|]
operator|=
operator|(
operator|*
name|oargv
operator|)
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
operator|*
name|oargc
operator|=
name|argc
expr_stmt|;
operator|*
name|oargv
operator|=
name|argv
expr_stmt|;
if|if
condition|(
name|no_match_at_all
operator|&&
name|contains_wildcards
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No match.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|utime
parameter_list|(
name|path
parameter_list|,
name|times
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|utimbuf
modifier|*
name|times
decl_stmt|;
block|{
name|struct
name|DateStamp
name|date
decl_stmt|;
name|LONG
name|error
decl_stmt|;
name|time_t
name|modtime
decl_stmt|;
comment|/* With Kickstart 1.3 setting the filedate could be done, I guess.    * Maybe someone else will implement and test the code for this    * case (I don't have Kickstart 1.3). */
if|if
condition|(
name|DOSBase
operator|->
name|dl_lib
operator|.
name|lib_Version
operator|<
literal|37
condition|)
return|return
literal|0
return|;
comment|/* Amiga dates are counted from 1. Jan 1978 as opposed to 1. Jan 1970    * on Unix. Therefore we have to subtract 2922 days (8*365+2). We also    * have to subtract the value of __timezone since SAS/C uses "CST+06"    * as the default value. */
name|modtime
operator|=
name|times
operator|->
name|modtime
operator|-
name|__timezone
expr_stmt|;
name|date
operator|.
name|ds_Days
operator|=
operator|(
name|modtime
operator|/
literal|86400
operator|)
operator|-
literal|2922
expr_stmt|;
name|modtime
operator|%=
literal|86400
expr_stmt|;
name|date
operator|.
name|ds_Minute
operator|=
name|modtime
operator|/
literal|60
expr_stmt|;
name|modtime
operator|%=
literal|60
expr_stmt|;
name|date
operator|.
name|ds_Tick
operator|=
name|modtime
operator|*
name|TICKS_PER_SECOND
expr_stmt|;
name|error
operator|=
name|SetFileDate
argument_list|(
name|path
argument_list|,
operator|&
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|DOSFALSE
condition|)
block|{
name|errno
operator|=
name|EOSERR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

