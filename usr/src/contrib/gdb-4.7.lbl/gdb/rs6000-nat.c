begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* IBM RS/6000 native-dependent code for GDB, the GNU debugger.    Copyright 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"nm.h"
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/reg.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/core.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|exec_one_dummy_insn
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Conversion from gdb-to-system special purpose register numbers.. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|special_regs
index|[]
init|=
block|{
name|IAR
block|,
comment|/* PC_REGNUM	*/
name|MSR
block|,
comment|/* PS_REGNUM	*/
name|CR
block|,
comment|/* CR_REGNUM	*/
name|LR
block|,
comment|/* LR_REGNUM	*/
name|CTR
block|,
comment|/* CTR_REGNUM	*/
name|XER
block|,
comment|/* XER_REGNUM   */
name|MQ
comment|/* MQ_REGNUM	*/
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|int
name|ii
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
block|{
comment|/* for all registers */
comment|/* read 32 general purpose registers. */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|32
condition|;
operator|++
name|ii
control|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ii
argument_list|)
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_GPR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|ii
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* read general purpose floating point registers. */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|32
condition|;
operator|++
name|ii
control|)
name|ptrace
argument_list|(
name|PT_READ_FPR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
operator|+
name|ii
argument_list|)
index|]
argument_list|,
name|FPR0
operator|+
name|ii
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* read special registers. */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<=
name|LAST_SP_REGNUM
operator|-
name|FIRST_SP_REGNUM
condition|;
operator|++
name|ii
control|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FIRST_SP_REGNUM
operator|+
name|ii
argument_list|)
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_GPR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|special_regs
index|[
name|ii
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* else an individual register is addressed. */
elseif|else
if|if
condition|(
name|regno
operator|<
name|FP0_REGNUM
condition|)
block|{
comment|/* a GPR */
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_GPR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|<=
name|FPLAST_REGNUM
condition|)
block|{
comment|/* a FPR */
name|ptrace
argument_list|(
name|PT_READ_FPR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
operator|(
name|regno
operator|-
name|FP0_REGNUM
operator|+
name|FPR0
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|<=
name|LAST_SP_REGNUM
condition|)
block|{
comment|/* a special register */
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_GPR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|special_regs
index|[
name|regno
operator|-
name|FIRST_SP_REGNUM
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gdb error: register no %d not implemented.\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|register_valid
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* for all registers..	*/
name|int
name|ii
decl_stmt|;
comment|/* execute one dummy instruction (which is a breakpoint) in inferior           process. So give kernel a chance to do internal house keeping. 	  Otherwise the following ptrace(2) calls will mess up user stack 	  since kernel will get confused about the bottom of the stack (%sp) */
name|exec_one_dummy_insn
argument_list|()
expr_stmt|;
comment|/* write general purpose registers first! */
for|for
control|(
name|ii
operator|=
name|GPR0
init|;
name|ii
operator|<=
name|GPR31
condition|;
operator|++
name|ii
control|)
block|{
name|ptrace
argument_list|(
name|PT_WRITE_GPR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|ii
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ii
argument_list|)
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|perror
argument_list|(
literal|"ptrace write_gpr"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* write floating point registers now. */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|32
condition|;
operator|++
name|ii
control|)
block|{
name|ptrace
argument_list|(
name|PT_WRITE_FPR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
operator|+
name|ii
argument_list|)
index|]
argument_list|,
name|FPR0
operator|+
name|ii
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|perror
argument_list|(
literal|"ptrace write_fpr"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* write special registers. */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<=
name|LAST_SP_REGNUM
operator|-
name|FIRST_SP_REGNUM
condition|;
operator|++
name|ii
control|)
block|{
name|ptrace
argument_list|(
name|PT_WRITE_GPR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|special_regs
index|[
name|ii
index|]
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FIRST_SP_REGNUM
operator|+
name|ii
argument_list|)
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|perror
argument_list|(
literal|"ptrace write_gpr"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* else, a specific register number is given... */
elseif|else
if|if
condition|(
name|regno
operator|<
name|FP0_REGNUM
condition|)
block|{
comment|/* a GPR */
name|ptrace
argument_list|(
name|PT_WRITE_GPR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regno
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|<=
name|FPLAST_REGNUM
condition|)
block|{
comment|/* a FPR */
name|ptrace
argument_list|(
name|PT_WRITE_FPR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|regno
operator|-
name|FP0_REGNUM
operator|+
name|FPR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|<=
name|LAST_SP_REGNUM
condition|)
block|{
comment|/* a special register */
name|ptrace
argument_list|(
name|PT_WRITE_GPR
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|special_regs
index|[
name|regno
operator|-
name|FIRST_SP_REGNUM
index|]
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Gdb error: register no %d not implemented.\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|perror
argument_list|(
literal|"ptrace write"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Execute one dummy breakpoint instruction.  This way we give the kernel    a chance to do some housekeeping and update inferior's internal data,    including u_area. */
end_comment

begin_function
specifier|static
name|void
name|exec_one_dummy_insn
parameter_list|()
block|{
define|#
directive|define
name|DUMMY_INSN_ADDR
value|(TEXT_SEGMENT_BASE)+0x200
name|unsigned
name|long
name|shadow
decl_stmt|;
name|unsigned
name|int
name|status
decl_stmt|,
name|pid
decl_stmt|;
comment|/* We plant one dummy breakpoint into DUMMY_INSN_ADDR address. We assume that      this address will never be executed again by the real code. */
name|target_insert_breakpoint
argument_list|(
name|DUMMY_INSN_ADDR
argument_list|,
operator|&
name|shadow
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_CONTINUE
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|DUMMY_INSN_ADDR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror
argument_list|(
literal|"pt_continue"
argument_list|)
expr_stmt|;
do|do
block|{
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pid
operator|!=
name|inferior_pid
condition|)
do|;
name|target_remove_breakpoint
argument_list|(
name|DUMMY_INSN_ADDR
argument_list|,
operator|&
name|shadow
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fetch_core_registers
parameter_list|(
name|core_reg_sect
parameter_list|,
name|core_reg_size
parameter_list|,
name|which
parameter_list|,
name|reg_addr
parameter_list|)
name|char
modifier|*
name|core_reg_sect
decl_stmt|;
name|unsigned
name|core_reg_size
decl_stmt|;
name|int
name|which
decl_stmt|;
name|unsigned
name|int
name|reg_addr
decl_stmt|;
comment|/* Unused in this version */
block|{
comment|/* fetch GPRs and special registers from the first register section      in core bfd. */
if|if
condition|(
name|which
operator|==
literal|0
condition|)
block|{
comment|/* copy GPRs first. */
name|bcopy
argument_list|(
name|core_reg_sect
argument_list|,
name|registers
argument_list|,
literal|32
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* gdb's internal register template and bfd's register section layout        should share a common include file. FIXMEmgo */
comment|/* then comes special registes. They are supposed to be in the same        order in gdb template and bfd `.reg' section. */
name|core_reg_sect
operator|+=
operator|(
literal|32
operator|*
literal|4
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|core_reg_sect
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FIRST_SP_REGNUM
argument_list|)
index|]
argument_list|,
operator|(
name|LAST_SP_REGNUM
operator|-
name|FIRST_SP_REGNUM
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* fetch floating point registers from register section 2 in core bfd. */
elseif|else
if|if
condition|(
name|which
operator|==
literal|2
condition|)
name|bcopy
argument_list|(
name|core_reg_sect
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
literal|32
operator|*
literal|8
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Gdb error: unknown parameter to fetch_core_registers().\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

