begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Memory-access and commands for remote kbox (Kinetics ethernet/appletalk  * bridge), for GDB. Copyright (C) 1988 Free Software Foundation, Inc.  *  * GDB is distributed in the hope that it will be useful, but WITHOUT ANY  * WARRANTY.  No author or distributor accepts responsibility to anyone for  * the consequences of using it or for whether it serves any particular  * purpose or works at all, unless he says so in writing. Refer to the GDB  * General Public License for full details.  *  * Everyone is granted permission to copy, modify and redistribute GDB, but only  * under the conditions described in the GDB General Public License.  A copy  * of this license is supposed to have been given to you along with GDB so  * you can know your rights and responsibilities.  It should be in a file  * named COPYING.  Among other things, the copyright notice and this notice  * must be preserved on all copies.  *  * In other words, go ahead and share GDB, but don't try to stop anyone else  * from sharing it farther.  Help stamp out software hoarding!  */
end_comment

begin_comment
comment|/*  * Written by Van Jacobson (van@helios.ee.lbl.gov)  * Sat Jan  7 03:42:57 PST 1989:  *  * This is a first cut at remote debugging suport for a fastpath.  All  * this version can do is read& write memory in the box.  Support  * for writing regs or continue/resume really requires support in  * the prom ethernet driver or it's too easy to step on yourself.  *  * To use a version of gdb that contains this code (which we typically  * call kbdb for "kbox debugger") do the following:  *  *   kbdb gw.sym	(gw.sym is the a.out form of the .srec currently  *			 downloaded into the kbox)  *   (gdb) attach @foo	("foo" is the host name or ip address of the  *			 kbox you want to debug)  *  * kbdb will print out a few lines including "Program received signal 5,  * Trace/BPT trap" and an address (usually ip4me in gw2.c).  The "signal  * 5" has to do with fooling gdb into thinking that the attach worked.  * Everything else is legit (ie, the registers, stack, etc., should  * indicate that you're in the piece of code that processes incoming  * "debug" packets.  You can now do all the normal gdb things (bt,  * print, set, etc.) except set breakpoints or change the execution  * path.  If you type "return" it will appear to work (but doesn't  * really).  If you type "continue", you'll get the "Program received  * signal 5," again.  When you quit, you'll get the usual confirmer:  * "The program is running.  Quit anyway? (y or n)".  Just answer  * yes.  *  * This code will only work with the LBL modified KIP code (it  * requires some opcodes we added to the gateway debugging protocol).  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"remote.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|"kgdb_proto.h"
end_include

begin_comment
comment|/*  * KIP fastpath gateway debug protocol  */
end_comment

begin_struct
struct|struct
name|gwdb
block|{
name|u_long
name|magic
decl_stmt|;
comment|/* magic number */
name|u_char
name|op
decl_stmt|,
name|seq
decl_stmt|;
comment|/* op code, sequence number */
name|u_short
name|count
decl_stmt|;
comment|/* byte count */
name|u_long
name|address
decl_stmt|;
comment|/* address of read/write */
name|u_char
name|data
index|[
literal|512
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Maximum number of bytes that can be read or written */
end_comment

begin_define
define|#
directive|define
name|FP_MAXDATA
value|sizeof(((struct gwdb *)0)->data)
end_define

begin_comment
comment|/* errno byte + data */
end_comment

begin_define
define|#
directive|define
name|FP_RPCSIZE
value|(1 + FP_MAXDATA)
end_define

begin_define
define|#
directive|define
name|gwdbMagic
value|((u_long)0xFF068020)
end_define

begin_define
define|#
directive|define
name|gwdbPort
value|900
end_define

begin_comment
comment|/* udp port number */
end_comment

begin_comment
comment|/* op codes */
end_comment

begin_define
define|#
directive|define
name|gwdbRead
value|1
end_define

begin_define
define|#
directive|define
name|gwdbWrite
value|2
end_define

begin_define
define|#
directive|define
name|gwdbCall
value|3
end_define

begin_define
define|#
directive|define
name|gwdbStats
value|4
end_define

begin_define
define|#
directive|define
name|gwdbState
value|5
end_define

begin_define
define|#
directive|define
name|gwdbFrame
value|6
end_define

begin_decl_stmt
name|int
name|kiodebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
name|fsin
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* foreign sockaddr_in */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fsinlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for I/O to remote machine.  */
end_comment

begin_decl_stmt
name|int
name|fp_desc
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fp_send
argument_list|()
decl_stmt|,
name|fp_recv
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|fp_close
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|fp_put
argument_list|()
decl_stmt|,
name|fp_get
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Open a connection to a remote debugger. NAME is the filename used for  * communication.  */
end_comment

begin_function
name|void
name|fp_open
parameter_list|(
name|name
parameter_list|,
name|remote_fnp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|remote_fn
modifier|*
name|remote_fnp
decl_stmt|;
block|{
specifier|register
name|u_long
name|iaddr
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|>=
literal|'0'
operator|&&
operator|*
name|name
operator|<=
literal|'9'
operator|&&
operator|(
name|iaddr
operator|=
name|inet_addr
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|fsin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|fsin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|iaddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|fsin
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fsin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Bad hostname/ip-address \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|fp_desc
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_desc
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|fsin
operator|.
name|sin_port
operator|=
name|gwdbPort
expr_stmt|;
name|remote_fnp
operator|->
name|send
operator|=
name|fp_send
expr_stmt|;
name|remote_fnp
operator|->
name|recv
operator|=
name|fp_recv
expr_stmt|;
name|remote_fnp
operator|->
name|close
operator|=
name|fp_close
expr_stmt|;
name|remote_fnp
operator|->
name|maxdata
operator|=
name|FP_MAXDATA
expr_stmt|;
name|remote_fnp
operator|->
name|rpcsize
operator|=
name|FP_RPCSIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close down connection to remote debugger.  */
end_comment

begin_function
specifier|static
name|void
name|fp_close
parameter_list|()
block|{
if|if
condition|(
name|fp_desc
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"fp_close(): fp_desc not open!\n"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fp_desc
argument_list|)
expr_stmt|;
name|fp_desc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|fp_lasttype
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|fp_send
parameter_list|(
name|type
parameter_list|,
name|bp
parameter_list|,
name|len
parameter_list|)
specifier|register
name|u_char
name|type
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|ret
decl_stmt|;
specifier|static
name|struct
name|gwdb
name|dbpacket
decl_stmt|;
specifier|register
name|struct
name|gwdb
modifier|*
name|dp
init|=
operator|&
name|dbpacket
decl_stmt|;
name|fp_lasttype
operator|=
name|type
expr_stmt|;
switch|switch
condition|(
name|KGDB_CMD
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|KGDB_MEM_R
case|:
comment|/* Read memory */
if|if
condition|(
name|len
operator|!=
literal|5
condition|)
name|printf
argument_list|(
literal|"fp_send: MEM_R: bad len (%d != 5)\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dp
operator|->
name|magic
operator|=
name|gwdbMagic
expr_stmt|;
name|dp
operator|->
name|op
operator|=
name|gwdbRead
expr_stmt|;
name|dp
operator|->
name|seq
operator|=
literal|1
expr_stmt|;
name|dp
operator|->
name|count
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dp
operator|->
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|dp
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|=
name|fp_put
argument_list|(
name|dp
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
break|break;
case|case
name|KGDB_MEM_W
case|:
comment|/* Write memory */
if|if
condition|(
name|len
operator|<
literal|5
condition|)
name|printf
argument_list|(
literal|"fp_send: MEM_W: bad len (%d< 5)\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dp
operator|->
name|magic
operator|=
name|gwdbMagic
expr_stmt|;
name|dp
operator|->
name|op
operator|=
name|gwdbWrite
expr_stmt|;
name|dp
operator|->
name|seq
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dp
operator|->
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|dp
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
sizeof|sizeof
argument_list|(
name|dp
operator|->
name|address
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|dp
operator|->
name|address
argument_list|)
expr_stmt|;
name|dp
operator|->
name|count
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|=
name|fp_put
argument_list|(
name|dp
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
break|break;
case|case
name|KGDB_REG_R
case|:
comment|/* Read registers */
name|dp
operator|->
name|magic
operator|=
name|gwdbMagic
expr_stmt|;
name|dp
operator|->
name|op
operator|=
name|gwdbFrame
expr_stmt|;
name|dp
operator|->
name|seq
operator|=
literal|1
expr_stmt|;
name|dp
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|count
operator|=
name|REGISTER_BYTES
expr_stmt|;
if|if
condition|(
name|ret
operator|=
name|fp_put
argument_list|(
name|dp
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fp_recv
parameter_list|(
name|tp
parameter_list|,
name|ip
parameter_list|,
name|lenp
parameter_list|,
name|to
parameter_list|)
name|int
modifier|*
name|tp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|ip
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|;
name|int
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|type
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
specifier|static
name|struct
name|gwdb
name|dbpacket
decl_stmt|;
specifier|register
name|struct
name|gwdb
modifier|*
name|dp
init|=
operator|&
name|dbpacket
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
literal|"(fastpath %s not implemented)\n"
decl_stmt|;
if|if
condition|(
name|lenp
condition|)
operator|*
name|lenp
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|KGDB_CMD
argument_list|(
name|fp_lasttype
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|type
operator||
operator|(
name|fp_lasttype
operator|&
name|KGDB_SEQ
operator|)
operator||
name|KGDB_ACK
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|KGDB_MEM_R
case|:
if|if
condition|(
name|ret
operator|=
name|fp_get
argument_list|(
name|dp
argument_list|,
name|to
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|ip
condition|)
block|{
comment|/* 			 * Build a rpc KGDB_MEM_R reply. This is just 			 * an errno (which is always zero in the case 			 * of a fastpath) and the data. 			 */
name|ip
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ip
index|[
literal|1
index|]
argument_list|,
name|dp
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|lenp
condition|)
operator|*
name|lenp
operator|=
name|dp
operator|->
name|count
operator|+
literal|1
expr_stmt|;
comment|/* rpc reply size */
block|}
break|break;
case|case
name|KGDB_MEM_W
case|:
if|if
condition|(
name|ret
operator|=
name|fp_get
argument_list|(
name|dp
argument_list|,
name|to
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
break|break;
case|case
name|KGDB_REG_R
case|:
if|if
condition|(
name|ret
operator|=
name|fp_get
argument_list|(
name|dp
argument_list|,
name|to
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|ip
condition|)
block|{
specifier|register
name|u_char
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|dp
operator|->
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|count
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ip
operator|++
operator|=
name|i
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
operator|(
name|caddr_t
operator|)
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|bp
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lenp
condition|)
operator|*
name|lenp
operator|=
name|i
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|KGDB_REG_W
case|:
name|printf
argument_list|(
name|fmt
argument_list|,
literal|"REG_W"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KGDB_CONT
case|:
comment|/* Next time, respond with a "signal" */
name|fp_lasttype
operator|=
name|KGDB_SIGNAL
expr_stmt|;
name|printf
argument_list|(
name|fmt
argument_list|,
literal|"CONT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KGDB_STEP
case|:
name|printf
argument_list|(
name|fmt
argument_list|,
literal|"STEP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KGDB_KILL
case|:
name|printf
argument_list|(
name|fmt
argument_list|,
literal|"KILL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KGDB_SIGNAL
case|:
name|printf
argument_list|(
name|fmt
argument_list|,
literal|"SIGNAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
comment|/* Build a fake rpc KGDB_SIGNAL reply */
name|ip
index|[
literal|0
index|]
operator|=
name|SIGTRAP
expr_stmt|;
if|if
condition|(
name|lenp
condition|)
operator|*
name|lenp
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|KGDB_EXEC
case|:
name|printf
argument_list|(
name|fmt
argument_list|,
literal|"EXEC"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"fp_send(): message type 0x%x unknown\n"
argument_list|,
name|fp_lasttype
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send the command in BUF to the remote machine, and read the reply into  * BUF. Report an error if we get an error reply.  */
end_comment

begin_function
specifier|static
name|int
name|fp_put
parameter_list|(
name|dp
parameter_list|)
name|struct
name|gwdb
modifier|*
name|dp
decl_stmt|;
block|{
if|if
condition|(
name|sendto
argument_list|(
name|fp_desc
argument_list|,
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|fsin
argument_list|,
sizeof|sizeof
argument_list|(
name|fsin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fp_put(): sendto"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EKGDB_IO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|FD_SETSIZE
end_ifndef

begin_comment
comment|/* Gag. */
end_comment

begin_define
define|#
directive|define
name|FD_SET
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|((p)->fds_bits[0] |= (1<<(n)))
end_define

begin_define
define|#
directive|define
name|FD_CLR
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|((p)->fds_bits[0]&= ~(1<<(n)))
end_define

begin_define
define|#
directive|define
name|FD_ISSET
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|((p)->fds_bits[0]& (1<<(n)))
end_define

begin_define
define|#
directive|define
name|FD_ZERO
parameter_list|(
name|p
parameter_list|)
value|((p)->fds_bits[0] = 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|fp_get
parameter_list|(
name|dp
parameter_list|,
name|to
parameter_list|)
name|struct
name|gwdb
modifier|*
name|dp
decl_stmt|;
name|int
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
comment|/* Wait for data to show up */
name|timeout
operator|.
name|tv_sec
operator|=
name|to
operator|/
literal|1000
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|to
operator|%
literal|1000
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fp_desc
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|fp_desc
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
comment|/* XXX should probably check for EINTR */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fp_get(): select"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EKGDB_IO
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fp_get(): timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EKGDB_TIMEOUT
operator|)
return|;
block|}
name|fsinlen
operator|=
sizeof|sizeof
argument_list|(
name|fsin
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|recvfrom
argument_list|(
name|fp_desc
argument_list|,
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|fsin
argument_list|,
operator|&
name|fsinlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fp_get(): recvfrom"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EKGDB_IO
operator|)
return|;
block|}
comment|/* Sanity checks */
if|if
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
return|return
operator|(
name|EKGDB_RUNT
operator|)
return|;
if|if
condition|(
name|n
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
return|return
operator|(
name|EKGDB_2BIG
operator|)
return|;
if|if
condition|(
name|dp
operator|->
name|op
operator|==
literal|0
condition|)
return|return
operator|(
name|EKGDB_BADOP
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

