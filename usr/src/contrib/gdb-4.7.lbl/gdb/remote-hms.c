begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for Hitachi HMS Monitor Version 1.0    Copyright 1992 Free Software Foundation, Inc.    Contributed by Cygnus Support.  Written by Steve Chamberlain    (sac@cygnus.com).  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_comment
comment|/* External data declarations */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stop_soon_quietly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for wait_for_inferior */
end_comment

begin_comment
comment|/* Forward data declarations */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|hms_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_comment
comment|/* Forward function declarations */
end_comment

begin_function_decl
specifier|static
name|void
name|hms_fetch_registers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hms_store_registers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hms_close
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hms_clear_breakpoints
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|hms_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|quiet
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/* Caching stuff stolen from remote-nindy.c  */
end_comment

begin_comment
comment|/* The data cache records all the data read from the remote machine    since the last time it stopped.     Each cache block holds LINE_SIZE bytes of data    starting at a multiple-of-LINE_SIZE address.  */
end_comment

begin_define
define|#
directive|define
name|LINE_SIZE_POWER
value|4
end_define

begin_define
define|#
directive|define
name|LINE_SIZE
value|(1<<LINE_SIZE_POWER)
end_define

begin_comment
comment|/* eg 1<<3 == 8 */
end_comment

begin_define
define|#
directive|define
name|LINE_SIZE_MASK
value|((LINE_SIZE-1))
end_define

begin_comment
comment|/* eg 7*2+1= 111*/
end_comment

begin_define
define|#
directive|define
name|DCACHE_SIZE
value|64
end_define

begin_comment
comment|/* Number of cache blocks */
end_comment

begin_define
define|#
directive|define
name|XFORM
parameter_list|(
name|x
parameter_list|)
value|((x&LINE_SIZE_MASK)>>2)
end_define

begin_struct
struct|struct
name|dcache_block
block|{
name|struct
name|dcache_block
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
comment|/* Address for which data is recorded.  */
name|int
name|data
index|[
name|LINE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|dcache_block
name|dcache_free
decl_stmt|,
name|dcache_valid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free all the data cache blocks, thus discarding all cached data.  */
end_comment

begin_function
specifier|static
name|void
name|dcache_flush
parameter_list|()
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
while|while
condition|(
operator|(
name|db
operator|=
name|dcache_valid
operator|.
name|next
operator|)
operator|!=
operator|&
name|dcache_valid
condition|)
block|{
name|remque
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|db
argument_list|,
operator|&
name|dcache_free
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If addr is present in the dcache, return the address of the block  * containing it.  */
end_comment

begin_function
specifier|static
name|struct
name|dcache_block
modifier|*
name|dcache_hit
parameter_list|(
name|addr
parameter_list|)
name|unsigned
name|int
name|addr
decl_stmt|;
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
if|if
condition|(
name|addr
operator|&
literal|3
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Search all cache blocks for one that is at this address.  */
name|db
operator|=
name|dcache_valid
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|db
operator|!=
operator|&
name|dcache_valid
condition|)
block|{
if|if
condition|(
operator|(
name|addr
operator|&
operator|~
name|LINE_SIZE_MASK
operator|)
operator|==
name|db
operator|->
name|addr
condition|)
return|return
name|db
return|;
name|db
operator|=
name|db
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  Return the int data at address ADDR in dcache block DC.  */
end_comment

begin_function
specifier|static
name|int
name|dcache_value
parameter_list|(
name|db
parameter_list|,
name|addr
parameter_list|)
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|addr
operator|&
literal|3
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|db
operator|->
name|data
index|[
name|XFORM
argument_list|(
name|addr
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a free cache block, put or keep it on the valid list,    and return its address.  The caller should store into the block    the address and data that it describes, then remque it from the    free list and insert it into the valid list.  This procedure    prevents errors from creeping in if a ninMemGet is interrupted    (which used to put garbage blocks in the valid list...).  */
end_comment

begin_function
specifier|static
name|struct
name|dcache_block
modifier|*
name|dcache_alloc
parameter_list|()
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
if|if
condition|(
operator|(
name|db
operator|=
name|dcache_free
operator|.
name|next
operator|)
operator|==
operator|&
name|dcache_free
condition|)
block|{
comment|/* If we can't get one from the free list, take last valid and put 	 it on the free list.  */
name|db
operator|=
name|dcache_valid
operator|.
name|last
expr_stmt|;
name|remque
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|db
argument_list|,
operator|&
name|dcache_free
argument_list|)
expr_stmt|;
block|}
name|remque
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|db
argument_list|,
operator|&
name|dcache_valid
argument_list|)
expr_stmt|;
return|return
operator|(
name|db
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the contents of the word at address ADDR in the remote machine,    using the data cache.  */
end_comment

begin_function
specifier|static
name|int
name|dcache_fetch
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
name|db
operator|=
name|dcache_hit
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
literal|0
condition|)
block|{
name|db
operator|=
name|dcache_alloc
argument_list|()
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|hms_read_inferior_memory
argument_list|(
name|addr
operator|&
operator|~
name|LINE_SIZE_MASK
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|db
operator|->
name|data
argument_list|,
name|LINE_SIZE
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|db
operator|->
name|addr
operator|=
name|addr
operator|&
operator|~
name|LINE_SIZE_MASK
expr_stmt|;
name|remque
argument_list|(
name|db
argument_list|)
expr_stmt|;
comment|/* Off the free list */
name|insque
argument_list|(
name|db
argument_list|,
operator|&
name|dcache_valid
argument_list|)
expr_stmt|;
comment|/* On the valid list */
block|}
return|return
operator|(
name|dcache_value
argument_list|(
name|db
argument_list|,
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write the word at ADDR both in the data cache and in the remote machine.  */
end_comment

begin_function
specifier|static
name|void
name|dcache_poke
parameter_list|(
name|addr
parameter_list|,
name|data
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
comment|/* First make sure the word is IN the cache.  DB is its cache block.  */
name|db
operator|=
name|dcache_hit
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
literal|0
condition|)
block|{
name|db
operator|=
name|dcache_alloc
argument_list|()
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|hms_write_inferior_memory
argument_list|(
name|addr
operator|&
operator|~
name|LINE_SIZE_MASK
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|db
operator|->
name|data
argument_list|,
name|LINE_SIZE
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|db
operator|->
name|addr
operator|=
name|addr
operator|&
operator|~
name|LINE_SIZE_MASK
expr_stmt|;
name|remque
argument_list|(
name|db
argument_list|)
expr_stmt|;
comment|/* Off the free list */
name|insque
argument_list|(
name|db
argument_list|,
operator|&
name|dcache_valid
argument_list|)
expr_stmt|;
comment|/* On the valid list */
block|}
comment|/* Modify the word in the cache.  */
name|db
operator|->
name|data
index|[
name|XFORM
argument_list|(
name|addr
argument_list|)
index|]
operator|=
name|data
expr_stmt|;
comment|/* Send the changed word.  */
name|immediate_quit
operator|++
expr_stmt|;
name|hms_write_inferior_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The cache itself. */
end_comment

begin_decl_stmt
name|struct
name|dcache_block
name|the_cache
index|[
name|DCACHE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the data cache.  */
end_comment

begin_function
specifier|static
name|void
name|dcache_init
parameter_list|()
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
name|db
operator|=
name|the_cache
expr_stmt|;
name|dcache_free
operator|.
name|next
operator|=
name|dcache_free
operator|.
name|last
operator|=
operator|&
name|dcache_free
expr_stmt|;
name|dcache_valid
operator|.
name|next
operator|=
name|dcache_valid
operator|.
name|last
operator|=
operator|&
name|dcache_valid
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCACHE_SIZE
condition|;
name|i
operator|++
operator|,
name|db
operator|++
control|)
name|insque
argument_list|(
name|db
argument_list|,
operator|&
name|dcache_free
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***********************************************************************  * I/O stuff stolen from remote-eb.c  ***********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dev_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to -1 so that    hms_open knows that we don't have a file open when the program    starts.  */
end_comment

begin_decl_stmt
name|int
name|is_open
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|check_open
parameter_list|()
block|{
if|if
condition|(
operator|!
name|is_open
condition|)
block|{
name|error
argument_list|(
literal|"remote device not open"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ON
value|1
end_define

begin_define
define|#
directive|define
name|OFF
value|0
end_define

begin_comment
comment|/* Read a character from the remote system, doing all the fancy    timeout stuff.  */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|()
block|{
name|int
name|buf
decl_stmt|;
name|buf
operator|=
name|serial_readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
operator|&
literal|0x7f
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|readchar_nofail
parameter_list|()
block|{
name|int
name|buf
decl_stmt|;
name|buf
operator|=
name|serial_readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|<
literal|0
condition|)
name|buf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
operator|&
literal|0x7f
return|;
block|}
end_function

begin_comment
comment|/* Keep discarding input from the remote system, until STRING is found.     Let the user break out immediately.  */
end_comment

begin_function
specifier|static
name|void
name|expect
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|readchar
argument_list|()
operator|==
operator|*
name|p
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
else|else
name|p
operator|=
name|string
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Keep discarding input until we see the hms prompt.     The convention for dealing with the prompt is that you    o give your command    o *then* wait for the prompt.     Thus the last thing that a procedure does with the serial line    will be an expect_prompt().  Exception:  hms_resume does not    wait for the prompt, because the terminal is being handed over    to the inferior.  However, the next thing which happens after that    is a hms_wait which does wait for the prompt.    Note that this includes abnormal exit, e.g. error().  This is    necessary to prevent getting into states from which we can't    recover.  */
end_comment

begin_function
specifier|static
name|void
name|expect_prompt
parameter_list|()
block|{
name|expect
argument_list|(
literal|"HMS>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a hex digit from the remote system& return its value.    If ignore_space is nonzero, ignore spaces (not newline, tab, etc).  */
end_comment

begin_function
specifier|static
name|int
name|get_hex_digit
parameter_list|(
name|ignore_space
parameter_list|)
name|int
name|ignore_space
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|' '
operator|&&
name|ignore_space
condition|)
empty_stmt|;
else|else
block|{
name|expect_prompt
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Invalid hex digit from remote system."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get a byte from hms_desc and put it in *BYT.  Accept any number    leading spaces.  */
end_comment

begin_function
specifier|static
name|void
name|get_hex_byte
parameter_list|(
name|byt
parameter_list|)
name|char
modifier|*
name|byt
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|val
operator||=
name|get_hex_digit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|byt
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a 32-bit hex word from the hms, preceded by a space  */
end_comment

begin_function
specifier|static
name|long
name|get_hex_word
parameter_list|()
block|{
name|long
name|val
decl_stmt|;
name|int
name|j
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
name|get_hex_digit
argument_list|(
name|j
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Called when SIGALRM signal sent due to alarm() timeout.  */
end_comment

begin_comment
comment|/* Number of SIGTRAPs we need to simulate.  That is, the next    NEED_ARTIFICIAL_TRAP calls to hms_wait should just return    SIGTRAP without actually waiting for anything.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|need_artificial_trap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|hms_kill
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{  }
end_function

begin_comment
comment|/*  * Download a file specified in 'args', to the hms.   */
end_comment

begin_function
specifier|static
name|void
name|hms_load
parameter_list|(
name|args
parameter_list|,
name|fromtty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|fromtty
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|check_open
argument_list|()
expr_stmt|;
name|dcache_flush
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|args
argument_list|,
literal|"coff-h8300"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Unable to open file %s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"File is not an object file\n"
argument_list|)
expr_stmt|;
return|return ;
block|}
name|s
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
while|while
condition|(
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|int
name|i
decl_stmt|;
define|#
directive|define
name|DELTA
value|1024
name|char
modifier|*
name|buffer
init|=
name|xmalloc
argument_list|(
name|DELTA
argument_list|)
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t: 0x%4x .. 0x%4x  "
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|vma
argument_list|,
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|_raw_size
condition|;
name|i
operator|+=
name|DELTA
control|)
block|{
name|int
name|delta
init|=
name|DELTA
decl_stmt|;
if|if
condition|(
name|delta
operator|>
name|s
operator|->
name|_raw_size
operator|-
name|i
condition|)
name|delta
operator|=
name|s
operator|->
name|_raw_size
operator|-
name|i
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|hms_write_inferior_memory
argument_list|(
name|s
operator|->
name|vma
operator|+
name|i
argument_list|,
name|buffer
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"r PC=%x"
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|)
expr_stmt|;
name|hms_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called not only when we first attach, but also when the    user types "run" after having attached.  */
end_comment

begin_function
name|void
name|hms_create_inferior
parameter_list|(
name|execfile
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|execfile
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|int
name|entry_pt
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"Can't pass arguments to remote hms process."
argument_list|)
expr_stmt|;
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No exec file specified"
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|int
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|check_open
argument_list|()
expr_stmt|;
name|hms_kill
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hms_clear_breakpoints
argument_list|()
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|hms_write_cr
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* Needed to get correct instruction in cache */
name|proceed
argument_list|(
name|entry_pt
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication, then a space,    then the baud rate.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_end_of_word
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_word
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
operator|*
name|p
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|size_t
name|len
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|word
operator|=
name|s
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|copy
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|word
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|copy
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|=
name|s
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|baudrate
init|=
literal|9600
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|is_baudrate_right
parameter_list|()
block|{
name|int
name|ok
decl_stmt|;
comment|/* Put this port into NORMAL mode, send the 'normal' character */
name|hms_write
argument_list|(
literal|"\001"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Control A */
name|hms_write
argument_list|(
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Cr */
while|while
condition|(
literal|1
condition|)
block|{
name|ok
operator|=
name|serial_readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|<
literal|0
condition|)
break|break;
block|}
name|hms_write
argument_list|(
literal|"r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|readchar_nofail
argument_list|()
operator|==
literal|'r'
condition|)
return|return
literal|1
return|;
comment|/* Not the right baudrate, or the board's not on */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_rate
parameter_list|()
block|{
if|if
condition|(
operator|!
name|serial_setbaudrate
argument_list|(
name|baudrate
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't set baudrate"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_baudrate_right
parameter_list|()
block|{
if|#
directive|if
literal|0
block|while (!is_baudrate_right())    {     baudrate = serial_nextbaudrate(baudrate);     if (baudrate == 0) {       printf_filtered("Board not yet in sync\n");       break;     }     printf_filtered("Board not responding, trying %d baud\n",baudrate);     QUIT;     serial_setbaudrate(baudrate);   }
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|hms_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|unsigned
name|int
name|prl
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
block|{
name|name
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|is_open
condition|)
name|hms_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
name|dev_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|serial_open
argument_list|(
name|dev_name
argument_list|)
condition|)
name|perror_with_name
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dev_name
argument_list|)
expr_stmt|;
name|serial_raw
argument_list|()
expr_stmt|;
name|is_open
operator|=
literal|1
expr_stmt|;
name|dcache_init
argument_list|()
expr_stmt|;
name|get_baudrate_right
argument_list|()
expr_stmt|;
comment|/* Hello?  Are you there?  */
name|serial_write
argument_list|(
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
comment|/* Clear any break points */
name|hms_clear_breakpoints
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Connected to remote H8/300 HMS system.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close out all files and local state before this target loses control. */
end_comment

begin_function
specifier|static
name|void
name|hms_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
comment|/* Clear any break points */
name|hms_clear_breakpoints
argument_list|()
expr_stmt|;
comment|/* Put this port back into REMOTE mode */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Let any output make it all the way back */
name|serial_write
argument_list|(
literal|"R\r"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|serial_close
argument_list|()
expr_stmt|;
name|is_open
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Terminate the open connection to the remote debugger.    Use this when you want to detach and do something else    with your gdb.  */
end_comment

begin_function
name|void
name|hms_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|is_open
condition|)
block|{
name|hms_clear_breakpoints
argument_list|()
expr_stmt|;
block|}
name|pop_target
argument_list|()
expr_stmt|;
comment|/* calls hms_close to do the real work */
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Ending remote %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
name|void
name|hms_resume
parameter_list|(
name|step
parameter_list|,
name|sig
parameter_list|)
name|int
name|step
decl_stmt|,
name|sig
decl_stmt|;
block|{
name|dcache_flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|step
condition|)
block|{
name|hms_write_cr
argument_list|(
literal|"s"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"Step>"
argument_list|)
expr_stmt|;
comment|/* Force the next hms_wait to return a trap.  Not doing anything        about I/O from the target means that the user has to type        "continue" to see any.  FIXME, this should be fixed.  */
name|need_artificial_trap
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hms_write_cr
argument_list|(
literal|"g"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"g"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return,    storing status in STATUS just as `wait' would.  */
end_comment

begin_function
name|int
name|hms_wait
parameter_list|(
name|status
parameter_list|)
name|WAITTYPE
modifier|*
name|status
decl_stmt|;
block|{
comment|/* Strings to look for.  '?' means match any single character.        Note that with the algorithm we use, the initial character      of the string cannot recur in the string, or we will not      find some cases of the string in the input.  */
specifier|static
name|char
name|bpt
index|[]
init|=
literal|"At breakpoint:"
decl_stmt|;
comment|/* It would be tempting to look for "\n[__exit + 0x8]\n"      but that requires loading symbols with "yc i" and even if      we did do that we don't know that the file has symbols.  */
specifier|static
name|char
name|exitmsg
index|[]
init|=
literal|"HMS>"
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|bpt
decl_stmt|;
name|char
modifier|*
name|ep
init|=
name|exitmsg
decl_stmt|;
comment|/* Large enough for either sizeof (bpt) or sizeof (exitmsg) chars.  */
name|char
name|swallowed
index|[
literal|50
index|]
decl_stmt|;
comment|/* Current position in swallowed.  */
name|char
modifier|*
name|swallowed_p
init|=
name|swallowed
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|ch_handled
decl_stmt|;
name|int
name|old_timeout
init|=
name|timeout
decl_stmt|;
name|int
name|old_immediate_quit
init|=
name|immediate_quit
decl_stmt|;
name|int
name|swallowed_cr
init|=
literal|0
decl_stmt|;
name|WSETEXIT
argument_list|(
operator|(
operator|*
name|status
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_artificial_trap
operator|!=
literal|0
condition|)
block|{
name|WSETSTOP
argument_list|(
operator|(
operator|*
name|status
operator|)
argument_list|,
name|SIGTRAP
argument_list|)
expr_stmt|;
name|need_artificial_trap
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
name|timeout
operator|=
literal|99999
expr_stmt|;
comment|/* Don't time out -- user program is running. */
name|immediate_quit
operator|=
literal|1
expr_stmt|;
comment|/* Helps ability to QUIT */
while|while
condition|(
literal|1
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* Let user quit and leave process running */
name|ch_handled
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|*
name|bp
condition|)
block|{
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\0'
condition|)
break|break;
name|ch_handled
operator|=
literal|1
expr_stmt|;
operator|*
name|swallowed_p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|bpt
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
operator|*
name|ep
operator|||
operator|*
name|ep
operator|==
literal|'?'
condition|)
block|{
name|ep
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|!
name|ch_handled
condition|)
operator|*
name|swallowed_p
operator|++
operator|=
name|ch
expr_stmt|;
name|ch_handled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|=
name|exitmsg
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ch_handled
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Print out any characters which have been swallowed.  */
for|for
control|(
name|p
operator|=
name|swallowed
init|;
name|p
operator|<
name|swallowed_p
condition|;
operator|++
name|p
control|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|swallowed_p
operator|=
name|swallowed
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|!=
literal|'\r'
operator|&&
name|ch
operator|!=
literal|'\n'
operator|)
operator|||
name|swallowed_cr
operator|>
literal|10
condition|)
block|{
name|putc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|swallowed_cr
operator|=
literal|10
expr_stmt|;
block|}
name|swallowed_cr
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\0'
condition|)
block|{
name|WSETSTOP
argument_list|(
operator|(
operator|*
name|status
operator|)
argument_list|,
name|SIGTRAP
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|WSETEXIT
argument_list|(
operator|(
operator|*
name|status
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|timeout
operator|=
name|old_timeout
expr_stmt|;
name|immediate_quit
operator|=
name|old_immediate_quit
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the name of register number REGNO    in the form input and output by hms.     Returns a pointer to a static buffer containing the answer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_reg_name
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|rn
index|[
name|NUM_REGS
index|]
init|=
name|REGISTER_NAMES
decl_stmt|;
return|return
name|rn
index|[
name|regno
index|]
return|;
block|}
end_function

begin_comment
comment|/* Read the remote registers.  */
end_comment

begin_function
specifier|static
name|int
name|gethex
parameter_list|(
name|length
parameter_list|,
name|start
parameter_list|,
name|ok
parameter_list|)
name|unsigned
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|int
modifier|*
name|ok
decl_stmt|;
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|result
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
operator|*
name|start
operator|>=
literal|'a'
operator|&&
operator|*
name|start
operator|<=
literal|'f'
condition|)
block|{
name|result
operator|+=
operator|*
name|start
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|start
operator|>=
literal|'A'
operator|&&
operator|*
name|start
operator|<=
literal|'F'
condition|)
block|{
name|result
operator|+=
operator|*
name|start
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|start
operator|>=
literal|'0'
operator|&&
operator|*
name|start
operator|<=
literal|'9'
condition|)
block|{
name|result
operator|+=
operator|*
name|start
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
operator|*
name|ok
operator|=
literal|0
expr_stmt|;
name|start
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|timed_read
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|,
name|timeout
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|i
return|;
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_macro
name|hms_write
argument_list|(
argument|a
argument_list|,
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|serial_write
argument_list|(
name|a
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|hms_write_cr
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|hms_write
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|hms_write
argument_list|(
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|hms_fetch_register
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
decl_stmt|;
block|{
define|#
directive|define
name|REGREPLY_SIZE
value|79
name|char
name|linebuf
index|[
name|REGREPLY_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|gottok
decl_stmt|;
name|REGISTER_TYPE
name|reg
index|[
name|NUM_REGS
index|]
decl_stmt|;
name|int
name|foo
index|[
literal|8
index|]
decl_stmt|;
name|check_open
argument_list|()
expr_stmt|;
do|do
block|{
name|hms_write_cr
argument_list|(
literal|"r"
argument_list|)
expr_stmt|;
name|s
operator|=
name|timed_read
argument_list|(
name|linebuf
argument_list|,
name|REGREPLY_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|linebuf
index|[
name|REGREPLY_SIZE
index|]
operator|=
literal|0
expr_stmt|;
name|gottok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'r'
operator|&&
name|linebuf
index|[
literal|3
index|]
operator|==
literal|'P'
operator|&&
name|linebuf
index|[
literal|4
index|]
operator|==
literal|'C'
operator|&&
name|linebuf
index|[
literal|5
index|]
operator|==
literal|'='
operator|&&
name|linebuf
index|[
literal|75
index|]
operator|==
literal|'H'
operator|&&
name|linebuf
index|[
literal|76
index|]
operator|==
literal|'M'
operator|&&
name|linebuf
index|[
literal|77
index|]
operator|==
literal|'S'
condition|)
block|{
comment|/* 	PC=XXXX CCR=XX:XXXXXXXX R0-R7= XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 	5436789012345678901234567890123456789012345678901234567890123456789012 	0      1         2         3         4         5         6          	*/
name|gottok
operator|=
literal|1
expr_stmt|;
name|reg
index|[
name|PC_REGNUM
index|]
operator|=
name|gethex
argument_list|(
literal|4
argument_list|,
name|linebuf
operator|+
literal|6
argument_list|,
operator|&
name|gottok
argument_list|)
expr_stmt|;
name|reg
index|[
name|CCR_REGNUM
index|]
operator|=
name|gethex
argument_list|(
literal|2
argument_list|,
name|linebuf
operator|+
literal|15
argument_list|,
operator|&
name|gottok
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|reg
index|[
name|i
index|]
operator|=
name|gethex
argument_list|(
literal|4
argument_list|,
name|linebuf
operator|+
literal|34
operator|+
literal|5
operator|*
name|i
argument_list|,
operator|&
name|gottok
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|gottok
condition|)
do|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
block|{
name|char
name|swapped
index|[
literal|2
index|]
decl_stmt|;
name|swapped
index|[
literal|1
index|]
operator|=
name|reg
index|[
name|i
index|]
expr_stmt|;
name|swapped
index|[
literal|0
index|]
operator|=
operator|(
name|reg
index|[
name|i
index|]
operator|)
operator|>>
literal|8
expr_stmt|;
name|supply_register
argument_list|(
name|i
argument_list|,
name|swapped
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all if REGNO == -1.    Return errno value.  */
end_comment

begin_function
specifier|static
name|void
name|hms_store_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
comment|/* printf("hms_store_register() called.\n"); fflush(stdout); /* */
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|hms_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|name
init|=
name|get_reg_name
argument_list|(
name|regno
argument_list|)
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"r %s=%x"
argument_list|,
name|name
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|hms_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
name|void
name|hms_prepare_to_store
parameter_list|()
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|translate_addr
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a word from remote address ADDR and return it.  * This goes through the data cache.  */
end_comment

begin_function
name|int
name|hms_fetch_word
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
return|return
name|dcache_fetch
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write a word WORD into remote address ADDR.    This goes through the data cache.  */
end_comment

begin_function
name|void
name|hms_store_word
parameter_list|(
name|addr
parameter_list|,
name|word
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|word
decl_stmt|;
block|{
name|dcache_poke
argument_list|(
name|addr
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|hms_xfer_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
decl_stmt|;
name|memaddr
operator|&=
literal|0xffff
expr_stmt|;
name|addr
operator|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
if|if
condition|(
name|addr
operator|!=
name|memaddr
operator|||
name|len
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
comment|/* Need part of initial word -- fetch it.  */
name|buffer
index|[
literal|0
index|]
operator|=
name|hms_fetch_word
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
condition|)
comment|/* FIXME, avoid if even boundary */
block|{
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|hms_fetch_word
argument_list|(
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|bcopy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|hms_store_word
argument_list|(
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
name|hms_fetch_word
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
return|return
literal|0
return|;
block|}
name|QUIT
expr_stmt|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
name|int
name|hms_write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|bfd_vma
name|addr
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|todo
decl_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|done
operator|<
name|len
condition|)
block|{
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
name|int
name|thisgo
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|thisgo
operator|=
name|len
operator|-
name|done
expr_stmt|;
if|if
condition|(
name|thisgo
operator|>
literal|20
condition|)
name|thisgo
operator|=
literal|20
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"M.B %4x ="
argument_list|,
name|memaddr
operator|+
name|done
argument_list|)
expr_stmt|;
name|hms_write
argument_list|(
name|buffer
argument_list|,
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|thisgo
condition|;
name|idx
operator|++
control|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%2x "
argument_list|,
name|myaddr
index|[
name|idx
operator|+
name|done
index|]
argument_list|)
expr_stmt|;
name|hms_write
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|hms_write_cr
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
name|done
operator|+=
name|thisgo
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|hms_files_info
parameter_list|()
block|{
name|char
modifier|*
name|file
init|=
literal|"nothing"
decl_stmt|;
if|if
condition|(
name|exec_bfd
condition|)
name|file
operator|=
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_bfd
condition|)
ifdef|#
directive|ifdef
name|__GO32__
name|printf_filtered
argument_list|(
literal|"\tAttached to DOS asynctsr and running program %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"\tAttached to %s at %d baud and running program %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf_filtered
argument_list|(
literal|"\ton an H8/300 processor.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.  Returns errno value.    * sb/sh instructions don't work on unaligned addresses, when TU=1.   */
end_comment

begin_comment
comment|/* Read LEN bytes from inferior memory at MEMADDR.  Put the result    at debugger address MYADDR.  Returns errno value.  */
end_comment

begin_function
name|int
name|hms_read_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/* Align to nearest low 16 bits */
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|CORE_ADDR start = memaddr& ~0xf;   CORE_ADDR end = ((memaddr + len +16)& ~0xf) -1;
endif|#
directive|endif
name|CORE_ADDR
name|start
init|=
name|memaddr
decl_stmt|;
name|CORE_ADDR
name|end
init|=
name|memaddr
operator|+
name|len
operator|-
literal|1
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
comment|/*     AAAA: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX '................'     012345678901234567890123456789012345678901234567890123456789012345     0         1         2         3         4         5         6     */
name|char
name|buffer
index|[
literal|66
index|]
decl_stmt|;
if|if
condition|(
name|memaddr
operator|&
literal|0xf
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|16
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"m %4x %4x"
argument_list|,
name|start
operator|&
literal|0xffff
argument_list|,
name|end
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|hms_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* drop the echo and newline*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|13
condition|;
name|i
operator|++
control|)
name|readchar
argument_list|()
expr_stmt|;
comment|/* Grab the lines as they come out and fill the area */
comment|/* Skip over cr */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|char
name|byte
index|[
literal|16
index|]
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|==
literal|'M'
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|66
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
index|]
operator|=
name|readchar
argument_list|()
expr_stmt|;
comment|/* Now parse the line */
name|addr
operator|=
name|gethex
argument_list|(
literal|4
argument_list|,
name|buffer
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|6
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
literal|16
condition|;
name|p
operator|+=
literal|2
control|)
block|{
name|byte
index|[
name|p
index|]
operator|=
name|gethex
argument_list|(
literal|2
argument_list|,
name|buffer
operator|+
name|idx
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
name|byte
index|[
name|p
operator|+
literal|1
index|]
operator|=
name|gethex
argument_list|(
literal|2
argument_list|,
name|buffer
operator|+
name|idx
operator|+
literal|2
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|5
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
literal|16
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|addr
operator|+
name|p
operator|>=
name|memaddr
operator|&&
name|addr
operator|+
name|p
operator|<
name|memaddr
operator|+
name|len
condition|)
block|{
name|myaddr
index|[
operator|(
name|addr
operator|+
name|p
operator|)
operator|-
name|memaddr
index|]
operator|=
name|byte
index|[
name|p
index|]
expr_stmt|;
block|}
block|}
block|}
name|hms_write_cr
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* This routine is run as a hook, just before the main command loop is    entered.  If gdb is configured for the H8, but has not had its    target specified yet, this will loop prompting the user to do so. */
end_comment

begin_macro
name|hms_before_main_loop
argument_list|()
end_macro

begin_block
block|{
name|char
name|ttyname
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|instream
decl_stmt|;
specifier|extern
name|jmp_buf
name|to_top_level
decl_stmt|;
name|push_target
argument_list|(
operator|&
name|hms_ops
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|MAX_BREAKS
value|16
end_define

begin_decl_stmt
specifier|static
name|int
name|num_brkpts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|hms_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|save
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
comment|/* Throw away, let hms save instructions */
block|{
name|check_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_brkpts
operator|<
name|MAX_BREAKS
condition|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|num_brkpts
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"b %x"
argument_list|,
name|addr
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|hms_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stderr
argument_list|,
literal|"Too many break points, break point not installed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hms_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|save
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
comment|/* Throw away, let hms save instructions */
block|{
if|if
condition|(
name|num_brkpts
operator|>
literal|0
condition|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|num_brkpts
operator|--
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"b - %x"
argument_list|,
name|addr
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|hms_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Clear the hmss notion of what the break points are */
end_comment

begin_function
specifier|static
name|int
name|hms_clear_breakpoints
parameter_list|()
block|{
if|if
condition|(
name|is_open
condition|)
block|{
name|hms_write_cr
argument_list|(
literal|"b -"
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
name|num_brkpts
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hms_mourn
parameter_list|()
block|{
name|hms_clear_breakpoints
argument_list|()
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put a command string, in args, out to the hms.  The hms is assumed to    be in raw mode, all writing/reading done through desc.    Ouput from the hms is placed on the users terminal until the    prompt from the hms is seen.    FIXME: Can't handle commands that take input.  */
end_comment

begin_function
name|void
name|hms_com
parameter_list|(
name|args
parameter_list|,
name|fromtty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|fromtty
decl_stmt|;
block|{
name|check_open
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
return|return;
comment|/* Clear all input so only command relative output is displayed */
name|hms_write_cr
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|hms_write
argument_list|(
literal|"\030"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|hms_ops
init|=
block|{
literal|"hms"
block|,
literal|"Remote HMS monitor"
block|,
literal|"Use the H8 evaluation board running the HMS monitor connected\n\ by a serial line."
block|,
name|hms_open
block|,
name|hms_close
block|,
literal|0
block|,
name|hms_detach
block|,
name|hms_resume
block|,
name|hms_wait
block|,
comment|/* attach */
name|hms_fetch_register
block|,
name|hms_store_register
block|,
name|hms_prepare_to_store
block|,
name|hms_xfer_inferior_memory
block|,
name|hms_files_info
block|,
name|hms_insert_breakpoint
block|,
name|hms_remove_breakpoint
block|,
comment|/* Breakpoints */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* Terminal handling */
name|hms_kill
block|,
comment|/* FIXME, kill */
name|hms_load
block|,
literal|0
block|,
comment|/* lookup_symbol */
name|hms_create_inferior
block|,
comment|/* create_inferior */
name|hms_mourn
block|,
comment|/* mourn_inferior FIXME */
literal|0
block|,
comment|/* can_run */
literal|0
block|,
comment|/* notice_signals */
name|process_stratum
block|,
literal|0
block|,
comment|/* next */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* all mem, mem, stack, regs, exec */
literal|0
block|,
literal|0
block|,
comment|/* Section pointers */
name|OPS_MAGIC
block|,
comment|/* Always the last thing */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|hms_quiet
argument_list|()
end_macro

begin_block
block|{
name|quiet
operator|=
operator|!
name|quiet
expr_stmt|;
if|if
condition|(
name|quiet
condition|)
name|printf_filtered
argument_list|(
literal|"Snoop disabled\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Snoop enabled\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hms_device
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|s
condition|)
block|{
name|dev_name
operator|=
name|get_word
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|hms_speed
argument_list|(
argument|s
argument_list|)
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|check_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|int
name|newrate
init|=
name|atoi
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|which
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|serial_setbaudrate
argument_list|(
name|newrate
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't use %d baud\n"
argument_list|,
name|newrate
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Checking target is in sync\n"
argument_list|)
expr_stmt|;
name|get_baudrate_right
argument_list|()
expr_stmt|;
name|baudrate
operator|=
name|newrate
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Sending commands to set target to %d\n"
argument_list|,
name|baudrate
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"tm %d. N 8 1"
argument_list|,
name|baudrate
argument_list|)
expr_stmt|;
name|hms_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/***********************************************************************/
end_comment

begin_function
name|void
name|_initialize_remote_hms
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|hms_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"hms<command>"
argument_list|,
name|class_obscure
argument_list|,
name|hms_com
argument_list|,
literal|"Send a command to the HMS monitor."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"snoop"
argument_list|,
name|class_obscure
argument_list|,
name|hms_quiet
argument_list|,
literal|"Show what commands are going to the monitor"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"device"
argument_list|,
name|class_obscure
argument_list|,
name|hms_device
argument_list|,
literal|"Set the terminal line for HMS communications"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"speed"
argument_list|,
name|class_obscure
argument_list|,
name|hms_speed
argument_list|,
literal|"Set the terminal line speed for HMS communications"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|dev_name = serial_default_name();
endif|#
directive|endif
name|dev_name
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

