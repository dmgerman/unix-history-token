begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Do various things to symbol tables (other than lookup), for GDB.    Copyright 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DEV_TTY
end_ifndef

begin_define
define|#
directive|define
name|DEV_TTY
value|"/dev/tty"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Unfortunately for debugging, stderr is usually a macro.  Better if we    make a variable which has the same value and which is accessible when    debugging GDB with itself.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|std_in
init|=
name|stdin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|std_out
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|std_err
init|=
name|stderr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dump_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|symtab
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_psymtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|partial_symtab
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_msymbols
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_objfile
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|block_depth
name|PARAMS
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_partial_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symbol
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_symtab_block
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|block
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Free a struct block<- B and all the symbols defined in that block.  */
end_comment

begin_function
specifier|static
name|void
name|free_symtab_block
parameter_list|(
name|objfile
parameter_list|,
name|b
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all the storage associated with the struct symtab<- S.    Note that some symtabs have contents malloc'ed structure by structure,    while some have contents that all live inside one big block of memory,    and some share the contents of another symbol table and so you should    not free the contents on their behalf (except sometimes the linetable,    which maybe per symtab even when the rest is not).    It is s->free_code that says which alternative to use.  */
end_comment

begin_function
name|void
name|free_symtab
parameter_list|(
name|s
parameter_list|)
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
switch|switch
condition|(
name|s
operator|->
name|free_code
condition|)
block|{
case|case
name|free_nothing
case|:
comment|/* All the contents are part of a big block of memory (an obstack), 	 and some other symtab is in charge of freeing that block. 	 Therefore, do nothing.  */
break|break;
case|case
name|free_contents
case|:
comment|/* Here all the contents were malloc'ed structure by structure 	 and must be freed that way.  */
comment|/* First free the blocks (and their symbols.  */
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|n
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|free_symtab_block
argument_list|(
name|s
operator|->
name|objfile
argument_list|,
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free the blockvector itself.  */
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|bv
argument_list|)
expr_stmt|;
comment|/* Also free the linetable.  */
case|case
name|free_linetable
case|:
comment|/* Everything will be freed either by our `free_ptr' 	 or by some other symtab, except for our linetable. 	 Free that now.  */
if|if
condition|(
name|LINETABLE
argument_list|(
name|s
argument_list|)
condition|)
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|LINETABLE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If there is a single block of memory to free, free it.  */
if|if
condition|(
name|s
operator|->
name|free_ptr
operator|!=
name|NULL
condition|)
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|free_ptr
argument_list|)
expr_stmt|;
comment|/* Free source-related stuff */
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|!=
name|NULL
condition|)
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|s
operator|->
name|line_charpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fullname
operator|!=
name|NULL
condition|)
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_function
specifier|static
name|void
name|dump_objfile
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"\nObject file %s:  "
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Objfile at %x, bfd at %x, %d minsyms\n\n"
argument_list|,
name|objfile
argument_list|,
name|objfile
operator|->
name|obfd
argument_list|,
name|objfile
operator|->
name|minimal_symbol_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|psymtabs
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Psymtabs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|psymtab
operator|=
name|objfile
operator|->
name|psymtabs
init|;
name|psymtab
operator|!=
name|NULL
condition|;
name|psymtab
operator|=
name|psymtab
operator|->
name|next
control|)
block|{
name|printf_filtered
argument_list|(
literal|"%s at %x, "
argument_list|,
name|psymtab
operator|->
name|filename
argument_list|,
name|psymtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|psymtab
operator|->
name|objfile
operator|!=
name|objfile
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"NOT ON CHAIN!  "
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|symtabs
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Symtabs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|symtab
operator|=
name|objfile
operator|->
name|symtabs
init|;
name|symtab
operator|!=
name|NULL
condition|;
name|symtab
operator|=
name|symtab
operator|->
name|next
control|)
block|{
name|printf_filtered
argument_list|(
literal|"%s at %x, "
argument_list|,
name|symtab
operator|->
name|filename
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|->
name|objfile
operator|!=
name|objfile
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"NOT ON CHAIN!  "
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print minimal symbols from this objfile.  */
end_comment

begin_function
specifier|static
name|void
name|dump_msymbols
parameter_list|(
name|objfile
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|int
name|index
decl_stmt|;
name|char
name|ms_type
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\nObject file %s:\n\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
operator|,
name|msymbol
operator|=
name|objfile
operator|->
name|msymbols
init|;
name|msymbol
operator|->
name|name
operator|!=
name|NULL
condition|;
name|msymbol
operator|++
operator|,
name|index
operator|++
control|)
block|{
switch|switch
condition|(
name|msymbol
operator|->
name|type
condition|)
block|{
case|case
name|mst_unknown
case|:
name|ms_type
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
name|mst_text
case|:
name|ms_type
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
name|mst_data
case|:
name|ms_type
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|mst_bss
case|:
name|ms_type
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
name|mst_abs
case|:
name|ms_type
operator|=
literal|'a'
expr_stmt|;
break|break;
default|default:
name|ms_type
operator|=
literal|'?'
expr_stmt|;
break|break;
block|}
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"[%2d] %c %#10x %s\n"
argument_list|,
name|index
argument_list|,
name|ms_type
argument_list|,
name|msymbol
operator|->
name|address
argument_list|,
name|msymbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|minimal_symbol_count
operator|!=
name|index
condition|)
block|{
name|warning
argument_list|(
literal|"internal error:  minimal symbol count %d != %d"
argument_list|,
name|objfile
operator|->
name|minimal_symbol_count
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_psymtab
parameter_list|(
name|objfile
parameter_list|,
name|psymtab
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\nPartial symtab for source file %s "
argument_list|,
name|psymtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"(object 0x%x)\n\n"
argument_list|,
name|psymtab
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  Read from object file %s (0x%x)\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|psymtab
operator|->
name|readin
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"  Full symtab was read (at 0x%x by function at 0x%x)\n"
argument_list|,
name|psymtab
operator|->
name|symtab
argument_list|,
name|psymtab
operator|->
name|read_symtab
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME, we need to be able to print the relocation stuff. */
comment|/* This prints some garbage for anything but stabs right now.  FIXME.  */
if|if
condition|(
name|psymtab
operator|->
name|section_offsets
condition|)
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"  Relocate symbols by 0x%x, 0x%x, 0x%x, 0x%x.\n"
argument_list|,
name|ANOFFSET
argument_list|(
name|psymtab
operator|->
name|section_offsets
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ANOFFSET
argument_list|(
name|psymtab
operator|->
name|section_offsets
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ANOFFSET
argument_list|(
name|psymtab
operator|->
name|section_offsets
argument_list|,
literal|2
argument_list|)
argument_list|,
name|ANOFFSET
argument_list|(
name|psymtab
operator|->
name|section_offsets
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"  Symbols cover text addresses 0x%x-0x%x\n"
argument_list|,
name|psymtab
operator|->
name|textlow
argument_list|,
name|psymtab
operator|->
name|texthigh
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"  Depends on %d other partial symtabs.\n"
argument_list|,
name|psymtab
operator|->
name|number_of_dependencies
argument_list|)
expr_stmt|;
if|if
condition|(
name|psymtab
operator|->
name|n_global_syms
operator|>
literal|0
condition|)
block|{
name|print_partial_symbol
argument_list|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|globals_offset
argument_list|,
name|psymtab
operator|->
name|n_global_syms
argument_list|,
literal|"Global"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|psymtab
operator|->
name|n_static_syms
operator|>
literal|0
condition|)
block|{
name|print_partial_symbol
argument_list|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
argument_list|,
name|psymtab
operator|->
name|n_static_syms
argument_list|,
literal|"Static"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_symtab
parameter_list|(
name|objfile
parameter_list|,
name|symtab
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|len
decl_stmt|,
name|blen
decl_stmt|;
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\nSymtab for file %s\n"
argument_list|,
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Read from object file %s (%x)\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|objfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Language: %s\n"
argument_list|,
name|language_str
argument_list|(
name|symtab
operator|->
name|language
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First print the line table.  */
name|l
operator|=
name|LINETABLE
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\nLine table:\n\n"
argument_list|)
expr_stmt|;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" line %d at %x\n"
argument_list|,
name|l
operator|->
name|item
index|[
name|i
index|]
operator|.
name|line
argument_list|,
name|l
operator|->
name|item
index|[
name|i
index|]
operator|.
name|pc
argument_list|)
expr_stmt|;
block|}
comment|/* Now print the block info.  */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\nBlockvector:\n\n"
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|len
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|depth
operator|=
name|block_depth
argument_list|(
name|b
argument_list|)
operator|*
literal|2
expr_stmt|;
name|print_spaces
argument_list|(
name|depth
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"block #%03d (object 0x%x) "
argument_list|,
name|i
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|b
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"[0x%x..0x%x]"
argument_list|,
name|BLOCK_START
argument_list|(
name|b
argument_list|)
argument_list|,
name|BLOCK_END
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" (under 0x%x)"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %s"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_GCC_COMPILED
argument_list|(
name|b
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" gcc%d compiled"
argument_list|,
name|BLOCK_GCC_COMPILED
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|blen
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blen
condition|;
name|j
operator|++
control|)
block|{
name|print_symbol
argument_list|(
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|maintenance_print_symbols
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|char
modifier|*
name|symname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|DEV_TTY
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"print-symbols takes an output file name and optional symbol file name"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|filename
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* If a second arg is supplied, it is a source file name to match on */
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|symname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|fclose
argument_list|,
operator|(
name|char
operator|*
operator|)
name|outfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
if|if
condition|(
name|symname
operator|==
name|NULL
operator|||
operator|(
name|strcmp
argument_list|(
name|symname
argument_list|,
name|s
operator|->
name|filename
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|dump_symtab
argument_list|(
name|objfile
argument_list|,
name|s
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_symbol
parameter_list|(
name|symbol
parameter_list|,
name|depth
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|print_spaces
argument_list|(
name|depth
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|symbol
argument_list|)
operator|==
name|LABEL_NAMESPACE
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"label %s at 0x%x\n"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|symbol
argument_list|)
operator|==
name|STRUCT_NAMESPACE
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|)
block|{
name|type_print_1
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|""
argument_list|,
name|outfile
argument_list|,
literal|1
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s %s = "
argument_list|,
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|?
literal|"enum"
else|:
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|?
literal|"struct"
else|:
literal|"union"
operator|)
operator|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|type_print_1
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|""
argument_list|,
name|outfile
argument_list|,
literal|1
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|symbol
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"typedef "
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
comment|/* Print details of types, except for enums where it's clutter.  */
name|type_print_1
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|outfile
argument_list|,
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s "
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"const %ld (0x%lx),"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_CONST_BYTES
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"const %u hex bytes:"
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %2x"
argument_list|,
operator|(
name|unsigned
operator|)
name|SYMBOL_VALUE_BYTES
argument_list|(
name|symbol
argument_list|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_STATIC
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"static at 0x%x,"
argument_list|,
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGISTER
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"register %ld,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
if|if
condition|(
name|SYMBOL_BASEREG_VALID
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"arg at 0x%lx from register %d,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_BASEREG
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"arg at 0x%lx,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_LOCAL_ARG
case|:
if|if
condition|(
name|SYMBOL_BASEREG_VALID
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"arg at offset 0x%lx from register %d,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_BASEREG
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"arg at offset 0x%lx from fp,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|LOC_REF_ARG
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"reference arg at 0x%lx,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"parameter register %ld,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
if|if
condition|(
name|SYMBOL_BASEREG_VALID
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"local at 0x%lx from register %d"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_BASEREG
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"local at 0x%lx,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_TYPEDEF
case|:
break|break;
case|case
name|LOC_LABEL
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"label at 0x%lx"
argument_list|,
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"block (object 0x%x) starting at 0x%x,"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"botched symbol class %x"
argument_list|,
name|SYMBOL_CLASS
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|maintenance_print_psymbols
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|char
modifier|*
name|symname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|DEV_TTY
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"print-psymbols takes an output file name and optional symbol file name"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|filename
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* If a second arg is supplied, it is a source file name to match on */
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|symname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|fclose
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
if|if
condition|(
name|symname
operator|==
name|NULL
operator|||
operator|(
name|strcmp
argument_list|(
name|symname
argument_list|,
name|ps
operator|->
name|filename
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|dump_psymtab
argument_list|(
name|objfile
argument_list|,
name|ps
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_partial_symbol
parameter_list|(
name|p
parameter_list|,
name|count
parameter_list|,
name|what
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|partial_symbol
modifier|*
name|p
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"  %s partial symbols:\n"
argument_list|,
name|what
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"    `%s', "
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|UNDEF_NAMESPACE
case|:
name|fputs_filtered
argument_list|(
literal|"undefined namespace, "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_NAMESPACE
case|:
comment|/* This is the usual thing -- don't print it */
break|break;
case|case
name|STRUCT_NAMESPACE
case|:
name|fputs_filtered
argument_list|(
literal|"struct namespace, "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_NAMESPACE
case|:
name|fputs_filtered
argument_list|(
literal|"label namespace, "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fputs_filtered
argument_list|(
literal|"<invalid namespace>, "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|LOC_UNDEF
case|:
name|fputs_filtered
argument_list|(
literal|"undefined"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_CONST
case|:
name|fputs_filtered
argument_list|(
literal|"constant int"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_STATIC
case|:
name|fputs_filtered
argument_list|(
literal|"static"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGISTER
case|:
name|fputs_filtered
argument_list|(
literal|"register"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
name|fputs_filtered
argument_list|(
literal|"pass by value"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|fputs_filtered
argument_list|(
literal|"pass by reference"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM
case|:
name|fputs_filtered
argument_list|(
literal|"register parameter"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
name|fputs_filtered
argument_list|(
literal|"stack parameter"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
name|fputs_filtered
argument_list|(
literal|"type"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LABEL
case|:
name|fputs_filtered
argument_list|(
literal|"label"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
name|fputs_filtered
argument_list|(
literal|"function"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_CONST_BYTES
case|:
name|fputs_filtered
argument_list|(
literal|"constant bytes"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL_ARG
case|:
name|fputs_filtered
argument_list|(
literal|"shuffled arg"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fputs_filtered
argument_list|(
literal|"<invalid location>"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"0x%x\n"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|maintenance_print_msymbols
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|DEV_TTY
decl_stmt|;
name|char
modifier|*
name|symname
init|=
name|NULL
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"print-msymbols takes an output file name and optional symbol file name"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|freeargv
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|filename
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* If a second arg is supplied, it is a source file name to match on */
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|symname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|fclose
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
if|if
condition|(
name|symname
operator|==
name|NULL
operator|||
operator|(
name|strcmp
argument_list|(
name|symname
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|dump_msymbols
argument_list|(
name|objfile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|maintenance_print_objfiles
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
name|dump_objfile
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the nexting depth of a block within other blocks in its symtab.  */
end_comment

begin_function
specifier|static
name|int
name|block_depth
parameter_list|(
name|block
parameter_list|)
name|struct
name|block
modifier|*
name|block
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAINTENANCE_CMDS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Increase the space allocated for LISTP, which is probably    global_psymbol_list or static_psymbol_list. This space will eventually    be freed in free_objfile().  */
end_comment

begin_function
name|void
name|extend_psymbol_list
parameter_list|(
name|listp
parameter_list|,
name|objfile
parameter_list|)
specifier|register
name|struct
name|psymbol_allocation_list
modifier|*
name|listp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|new_size
decl_stmt|;
if|if
condition|(
name|listp
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|new_size
operator|=
literal|255
expr_stmt|;
name|listp
operator|->
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_size
operator|=
name|listp
operator|->
name|size
operator|*
literal|2
expr_stmt|;
name|listp
operator|->
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
name|xmrealloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|listp
operator|->
name|list
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Next assumes we only went one over.  Should be good if      program works correctly */
name|listp
operator|->
name|next
operator|=
name|listp
operator|->
name|list
operator|+
name|listp
operator|->
name|size
expr_stmt|;
name|listp
operator|->
name|size
operator|=
name|new_size
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* The work performed by this function is normally done by the macro    ADD_PSYMBOL_TO_LIST defined in symfile.h.  When debugging gdb, this    function makes things easier. */
end_comment

begin_function
name|void
name|add_psymbol_to_list
parameter_list|(
name|name
parameter_list|,
name|namelength
parameter_list|,
name|namespace
parameter_list|,
name|class
parameter_list|,
name|listp
parameter_list|,
name|psymval
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelength
decl_stmt|;
name|enum
name|namespace
name|namespace
decl_stmt|;
name|enum
name|address_class
name|class
decl_stmt|;
name|struct
name|psymbol_allocation_list
modifier|*
name|listp
decl_stmt|;
name|unsigned
name|long
name|psymval
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
if|if
condition|(
name|listp
operator|->
name|next
operator|>=
name|listp
operator|->
name|list
operator|+
name|listp
operator|->
name|size
condition|)
name|extend_psymbol_list
argument_list|(
name|listp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|psym
operator|=
name|listp
operator|->
name|next
operator|++
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|namelength
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|name
argument_list|,
name|namelength
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
index|[
name|namelength
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|psym
argument_list|)
operator|=
name|namespace
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|=
name|class
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|psym
argument_list|)
operator|=
name|psymval
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The work performed by this function is normally done by the macro    ADD_PSYMBOL_ADDR_TO_LIST defined in symfile.h.  When debugging gdb, this    function makes things easier. */
end_comment

begin_function
name|void
name|add_psymbol_addr_to_list
parameter_list|(
name|name
parameter_list|,
name|namelength
parameter_list|,
name|namespace
parameter_list|,
name|class
parameter_list|,
name|listp
parameter_list|,
name|psymval
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelength
decl_stmt|;
name|enum
name|namespace
name|namespace
decl_stmt|;
name|enum
name|address_class
name|class
decl_stmt|;
name|struct
name|psymbol_allocation_list
modifier|*
name|listp
decl_stmt|;
name|CORE_ADDR
name|psymval
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
if|if
condition|(
name|listp
operator|->
name|next
operator|>=
name|listp
operator|->
name|list
operator|+
name|listp
operator|->
name|size
condition|)
name|extend_psymbol_list
argument_list|(
name|listp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|psym
operator|=
name|listp
operator|->
name|next
operator|++
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|namelength
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|name
argument_list|,
name|namelength
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
index|[
name|namelength
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|psym
argument_list|)
operator|=
name|namespace
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|=
name|class
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|psym
argument_list|)
operator|=
name|psymval
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

