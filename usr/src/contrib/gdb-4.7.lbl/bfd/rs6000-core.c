begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* IBM RS/6000 "XCOFF" back-end for BFD.    Copyright (C) 1990, 1991 Free Software Foundation, Inc.    Written by Metin G. Ozisik, Mimi Phûông-Thåo Võ, and John Gilmore.    Archive support from Damon A. Permezel.    Contributed by IBM Corporation and Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This port currently only handles reading object files, except when    compiled on an RS/6000 host.  -- no archive support, no core files.    In all cases, it does not support writing.     FIXMEmgo comments are left from Metin Ozisik's original port.     This is in a separate file from coff-rs6000.c, because it includes    system include files that conflict with coff/rs6000.h.   */
end_comment

begin_comment
comment|/* Internalcoff.h and coffcode.h modify themselves based on this flag.  */
end_comment

begin_define
define|#
directive|define
name|RS6000COFF_C
value|1
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COREFILES_PLEASE
end_ifdef

begin_comment
comment|/* AOUTHDR is defined by the above.  We need another defn of it, from the    system include files.  Punt the old one and get us a new name for the    typedef in the system include files.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AOUTHDR
end_ifdef

begin_undef
undef|#
directive|undef
name|AOUTHDR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|AOUTHDR
value|second_AOUTHDR
end_define

begin_undef
undef|#
directive|undef
name|SCNHDR
end_undef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/*	Support for core file stuff.. 					    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ldr.h>
end_include

begin_include
include|#
directive|include
file|<sys/core.h>
end_include

begin_comment
comment|/* Number of special purpose registers supported by gdb.  This value    should match `tm.h' in gdb directory.  Clean this mess up and use    the macros in sys/reg.h.  FIXMEmgo. */
end_comment

begin_define
define|#
directive|define
name|NUM_OF_SPEC_REGS
value|7
end_define

begin_define
define|#
directive|define
name|STACK_END_ADDR
value|0x2ff80000
end_define

begin_define
define|#
directive|define
name|core_hdr
parameter_list|(
name|bfd
parameter_list|)
value|(((Rs6kCorData*)(bfd->tdata.any))->hdr)
end_define

begin_define
define|#
directive|define
name|core_datasec
parameter_list|(
name|bfd
parameter_list|)
value|(((Rs6kCorData*)(bfd->tdata.any))->data_section)
end_define

begin_define
define|#
directive|define
name|core_stacksec
parameter_list|(
name|bfd
parameter_list|)
value|(((Rs6kCorData*)(bfd->tdata.any))->stack_section)
end_define

begin_define
define|#
directive|define
name|core_regsec
parameter_list|(
name|bfd
parameter_list|)
value|(((Rs6kCorData*)(bfd->tdata.any))->reg_section)
end_define

begin_define
define|#
directive|define
name|core_reg2sec
parameter_list|(
name|bfd
parameter_list|)
value|(((Rs6kCorData*)(bfd->tdata.any))->reg2_section)
end_define

begin_comment
comment|/* These are stored in the bfd's tdata */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|core
modifier|*
name|hdr
decl_stmt|;
comment|/* core file header */
name|asection
modifier|*
name|data_section
decl_stmt|,
modifier|*
name|stack_section
decl_stmt|,
modifier|*
name|reg_section
decl_stmt|,
comment|/* section for GPRs and special registers. */
modifier|*
name|reg2_section
decl_stmt|;
comment|/* section for FPRs. */
block|}
name|Rs6kCorData
typedef|;
end_typedef

begin_comment
comment|/* Decide if a given bfd represents a `core' file or not. There really is no    magic number or anything like, in rs6000coff. */
end_comment

begin_function
name|bfd_target
modifier|*
name|rs6000coff_core_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|core_dump
name|coredata
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|tmpptr
decl_stmt|;
comment|/* Use bfd_xxx routines, rather than O/S primitives to read coredata. FIXMEmgo */
name|fd
operator|=
name|open
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|coredata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|core_dump
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_long
operator|)
name|coredata
operator|.
name|c_tab
operator|<
sizeof|sizeof
name|coredata
operator|||
operator|(
name|u_long
operator|)
name|coredata
operator|.
name|c_tab
operator|>=
name|statbuf
operator|.
name|st_size
operator|||
operator|(
name|long
operator|)
name|coredata
operator|.
name|c_tab
operator|>=
operator|(
name|long
operator|)
name|coredata
operator|.
name|c_stack
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/*   If it looks like core file, then.....   read core file header..... (maybe you've done it above..) */
comment|/* maybe you should alloc space for the whole core chunk over here!! FIXMEmgo */
name|tmpptr
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|Rs6kCorData
argument_list|)
argument_list|)
expr_stmt|;
name|set_tdata
argument_list|(
name|abfd
argument_list|,
name|tmpptr
argument_list|)
expr_stmt|;
comment|/* .stack section. */
if|if
condition|(
operator|(
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
comment|/* bfd_release (abfd, ???? ) */
return|return
name|NULL
return|;
block|}
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".stack"
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|coredata
operator|.
name|c_size
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|STACK_END_ADDR
operator|-
name|coredata
operator|.
name|c_size
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|int
operator|)
name|coredata
operator|.
name|c_stack
expr_stmt|;
comment|/*???? */
comment|/* .reg section for GPRs and special registers. */
if|if
condition|(
operator|(
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
comment|/* bfd_release (abfd, ???? ) */
return|return
name|NULL
return|;
block|}
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".reg"
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
operator|(
literal|32
operator|+
name|NUM_OF_SPEC_REGS
operator|)
operator|*
literal|4
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
comment|/* not used?? */
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|coredata
operator|.
name|c_u
operator|.
name|u_save
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|coredata
expr_stmt|;
comment|/* .reg2 section for FPRs (floating point registers). */
if|if
condition|(
operator|(
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
comment|/* bfd_release (abfd, ???? ) */
return|return
name|NULL
return|;
block|}
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".reg2"
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
literal|8
operator|*
literal|32
expr_stmt|;
comment|/* 32 FPRs. */
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
comment|/* not used?? */
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|coredata
operator|.
name|c_u
operator|.
name|u_save
operator|.
name|fpr
index|[
literal|0
index|]
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|coredata
expr_stmt|;
comment|/* set up section chain here. */
name|abfd
operator|->
name|section_count
operator|=
literal|3
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|core_regsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
comment|/* this is garbage for now. */
block|}
end_function

begin_comment
comment|/* return `true' if given core is from the given executable.. */
end_comment

begin_function
name|boolean
name|rs6000coff_core_file_matches_executable_p
parameter_list|(
name|core_bfd
parameter_list|,
name|exec_bfd
parameter_list|)
name|bfd
modifier|*
name|core_bfd
decl_stmt|;
name|bfd
modifier|*
name|exec_bfd
decl_stmt|;
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|struct
name|core_dump
name|coredata
decl_stmt|;
name|struct
name|ld_info
name|ldinfo
decl_stmt|;
name|char
name|pathname
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|str1
decl_stmt|,
modifier|*
name|str2
decl_stmt|;
comment|/* Use bfd_xxx routines, rather than O/S primitives, do error checking!!   								FIXMEmgo */
name|fd
operator|=
name|fopen
argument_list|(
name|core_bfd
operator|->
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|coredata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|core_dump
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
operator|(
name|long
operator|)
name|coredata
operator|.
name|c_tab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|ldinfo
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ldinfo
operator|.
name|ldinfo_filename
index|[
literal|0
index|]
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|ldinfo
operator|.
name|ldinfo_next
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fscanf
argument_list|(
name|fd
argument_list|,
literal|"%s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"path: %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|str1
operator|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|str2
operator|=
name|strrchr
argument_list|(
name|exec_bfd
operator|->
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* step over character '/' */
name|str1
operator|=
name|str1
condition|?
name|str1
operator|+
literal|1
else|:
operator|&
name|pathname
index|[
literal|0
index|]
expr_stmt|;
name|str2
operator|=
name|str2
condition|?
name|str2
operator|+
literal|1
else|:
name|exec_bfd
operator|->
name|filename
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
name|boolean
name|rs6000coff_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* Reading a core file's sections will be slightly different. For the        rest of them we can use bfd_generic_get_section_contents () I suppose. */
comment|/* Make sure this routine works for any bfd and any section. FIXMEmgo. */
if|if
condition|(
name|abfd
operator|->
name|format
operator|==
name|bfd_core
operator|&&
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".reg"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|mstsave
name|mstatus
decl_stmt|;
name|int
name|regoffset
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|mstatus
operator|.
name|gpr
index|[
literal|0
index|]
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|mstatus
decl_stmt|;
comment|/* Assert that the only way this code will be executed is reading the          whole section. */
if|if
condition|(
name|offset
operator|||
name|count
operator|!=
operator|(
sizeof|sizeof
argument_list|(
name|mstatus
operator|.
name|gpr
argument_list|)
operator|+
operator|(
literal|4
operator|*
name|NUM_OF_SPEC_REGS
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"ERROR! in rs6000coff_get_section_contents()\n"
argument_list|)
expr_stmt|;
comment|/* for `.reg' section, `filepos' is a pointer to the `mstsave' structure          in the core file. */
comment|/* read GPR's into the location. */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|regoffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|bfd_read
argument_list|(
name|location
argument_list|,
sizeof|sizeof
argument_list|(
name|mstatus
operator|.
name|gpr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|mstatus
operator|.
name|gpr
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* on error */
comment|/* increment location to the beginning of special registers in the section,          reset register offset value to the beginning of first special register 	 in mstsave structure, and read special registers. */
name|location
operator|=
call|(
name|PTR
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|location
operator|+
sizeof|sizeof
argument_list|(
name|mstatus
operator|.
name|gpr
argument_list|)
argument_list|)
expr_stmt|;
name|regoffset
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|mstatus
operator|.
name|iar
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|mstatus
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|regoffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|bfd_read
argument_list|(
name|location
argument_list|,
literal|4
operator|*
name|NUM_OF_SPEC_REGS
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
operator|*
name|NUM_OF_SPEC_REGS
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* on error */
comment|/* increment location address, and read the special registers.. */
comment|/* FIXMEmgo */
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* else, use default bfd section content transfer. */
else|else
return|return
name|bfd_generic_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|location
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COREFILES_PLEASE */
end_comment

end_unit

