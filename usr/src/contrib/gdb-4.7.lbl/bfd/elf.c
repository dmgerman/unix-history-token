begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF executable support for BFD.    Copyright 1991, 1992 Free Software Foundation, Inc.     Written by Fred Fish @ Cygnus Support, from information published    in "UNIX System V Release 4, Programmers Guide: ANSI C and    Programming Support Tools".  Sufficient support for gdb.     Rewritten by Mark Eichin @ Cygnus Support, from information    published in "System V Application Binary Interface", chapters 4    and 5, as well as the various "Processor Supplement" documents    derived from it. Added support for assembler and other object file    utilities.     This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/****************************************  	  		WARNING  	This is only a partial ELF implementation, 	incorporating only those parts that are 	required to get gdb up and running.  It is 	expected that it will be expanded to a full 	ELF implementation at some future date.  	Unimplemented stubs call abort() to ensure 	that they get proper attention if they are 	ever called.  The stubs are here since 	this version was hacked from the COFF 	version, and thus they will probably 	go away or get expanded appropriately in a 	future version.  	fnf@cygnus.com  	*****************************************/
end_comment

begin_comment
comment|/* Problems and other issues to resolve.     (1)	BFD expects there to be some fixed number of "sections" in         the object file.  I.E. there is a "section_count" variable in the 	bfd structure which contains the number of sections.  However, ELF 	supports multiple "views" of a file.  In particular, with current 	implementations, executable files typically have two tables, a 	program header table and a section header table, both of which 	partition the executable.  	In ELF-speak, the "linking view" of the file uses the section header 	table to access "sections" within the file, and the "execution view" 	uses the program header table to access "segments" within the file. 	"Segments" typically may contain all the data from one or more 	"sections".  	Note that the section header table is optional in ELF executables, 	but it is this information that is most useful to gdb.  If the 	section header table is missing, then gdb should probably try 	to make do with the program header table.  (FIXME)  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/internal.h"
end_include

begin_include
include|#
directive|include
file|"elf/external.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PROCFS
end_ifdef

begin_comment
comment|/* Some core file support requires host /proc files */
end_comment

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|bfd_prstatus
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|)
end_define

begin_comment
comment|/* Define away */
end_comment

begin_define
define|#
directive|define
name|bfd_fpregset
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|)
end_define

begin_comment
comment|/* Define away */
end_comment

begin_define
define|#
directive|define
name|bfd_prpsinfo
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|)
end_define

begin_comment
comment|/* Define away */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward data declarations */
end_comment

begin_decl_stmt
specifier|extern
name|bfd_target
name|elf_little_vec
decl_stmt|,
name|elf_big_vec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Currently the elf_symbol_type struct just contains the generic bfd    symbol structure. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|asymbol
name|symbol
decl_stmt|;
block|}
name|elf_symbol_type
typedef|;
end_typedef

begin_comment
comment|/* Some private data is stashed away for future use using the tdata pointer    in the bfd structure.  */
end_comment

begin_struct
struct|struct
name|elf_obj_tdata
block|{
name|Elf_Internal_Ehdr
name|elf_header
index|[
literal|1
index|]
decl_stmt|;
comment|/* Actual data, but ref like ptr */
name|Elf_Internal_Shdr
modifier|*
name|elf_sect_ptr
decl_stmt|;
name|struct
name|strtab
modifier|*
name|strtab_ptr
decl_stmt|;
name|int
name|symtab_section
decl_stmt|;
name|void
modifier|*
name|prstatus
decl_stmt|;
comment|/* The raw /proc prstatus structure */
name|void
modifier|*
name|prpsinfo
decl_stmt|;
comment|/* The raw /proc prpsinfo structure */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf_tdata
parameter_list|(
name|bfd
parameter_list|)
value|((bfd) -> tdata.elf_obj_data)
end_define

begin_define
define|#
directive|define
name|elf_elfheader
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> elf_header)
end_define

begin_define
define|#
directive|define
name|elf_elfsections
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> elf_sect_ptr)
end_define

begin_define
define|#
directive|define
name|elf_shstrtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> strtab_ptr)
end_define

begin_define
define|#
directive|define
name|elf_onesymtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> symtab_section)
end_define

begin_define
define|#
directive|define
name|core_prpsinfo
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> prpsinfo)
end_define

begin_define
define|#
directive|define
name|core_prstatus
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> prstatus)
end_define

begin_comment
comment|/* Translate an ELF symbol in external format into an ELF symbol in internal    format. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_swap_symbol_in
argument_list|,
operator|(
name|abfd
operator|,
name|src
operator|,
name|dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_External_Sym
operator|*
name|src
name|AND
name|Elf_Internal_Sym
operator|*
name|dst
argument_list|)
block|{
name|dst
operator|->
name|st_name
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_value
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_size
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_size
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_info
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_other
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_other
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_shndx
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Translate an ELF symbol in internal format into an ELF symbol in external    format. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_swap_symbol_out
argument_list|,
operator|(
name|abfd
operator|,
name|src
operator|,
name|dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_Internal_Sym
operator|*
name|src
name|AND
name|Elf_External_Sym
operator|*
name|dst
argument_list|)
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_name
argument_list|,
name|dst
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_value
argument_list|,
name|dst
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_size
argument_list|,
name|dst
operator|->
name|st_size
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_info
argument_list|,
name|dst
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_other
argument_list|,
name|dst
operator|->
name|st_other
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_shndx
argument_list|,
name|dst
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Translate an ELF file header in external format into an ELF file header in    internal format. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_swap_ehdr_in
argument_list|,
operator|(
name|abfd
operator|,
name|src
operator|,
name|dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_External_Ehdr
operator|*
name|src
name|AND
name|Elf_Internal_Ehdr
operator|*
name|dst
argument_list|)
block|{
name|memcpy
argument_list|(
name|dst
operator|->
name|e_ident
argument_list|,
name|src
operator|->
name|e_ident
argument_list|,
name|EI_NIDENT
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_type
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_machine
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_machine
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_version
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_version
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_entry
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_phoff
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_phoff
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shoff
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_flags
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_ehsize
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_ehsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_phentsize
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_phentsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_phnum
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shentsize
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shnum
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shstrndx
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Translate an ELF file header in internal format into an ELF file header in    external format. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_swap_ehdr_out
argument_list|,
operator|(
name|abfd
operator|,
name|src
operator|,
name|dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_Internal_Ehdr
operator|*
name|src
name|AND
name|Elf_External_Ehdr
operator|*
name|dst
argument_list|)
block|{
name|memcpy
argument_list|(
name|dst
operator|->
name|e_ident
argument_list|,
name|src
operator|->
name|e_ident
argument_list|,
name|EI_NIDENT
argument_list|)
expr_stmt|;
comment|/* note that all elements of dst are *arrays of unsigned char* already... */
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_type
argument_list|,
name|dst
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_machine
argument_list|,
name|dst
operator|->
name|e_machine
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_version
argument_list|,
name|dst
operator|->
name|e_version
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_entry
argument_list|,
name|dst
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phoff
argument_list|,
name|dst
operator|->
name|e_phoff
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shoff
argument_list|,
name|dst
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_flags
argument_list|,
name|dst
operator|->
name|e_flags
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_ehsize
argument_list|,
name|dst
operator|->
name|e_ehsize
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phentsize
argument_list|,
name|dst
operator|->
name|e_phentsize
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phnum
argument_list|,
name|dst
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shentsize
argument_list|,
name|dst
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shnum
argument_list|,
name|dst
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shstrndx
argument_list|,
name|dst
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Translate an ELF section header table entry in external format into an    ELF section header table entry in internal format. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_swap_shdr_in
argument_list|,
operator|(
name|abfd
operator|,
name|src
operator|,
name|dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_External_Shdr
operator|*
name|src
name|AND
name|Elf_Internal_Shdr
operator|*
name|dst
argument_list|)
block|{
name|dst
operator|->
name|sh_name
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_name
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_type
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_flags
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_addr
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_size
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_link
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_info
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_addralign
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_entsize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
comment|/* we haven't done any processing on it yet, so... */
name|dst
operator|->
name|rawdata
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Translate an ELF section header table entry in internal format into an    ELF section header table entry in external format. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_swap_shdr_out
argument_list|,
operator|(
name|abfd
operator|,
name|src
operator|,
name|dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_Internal_Shdr
operator|*
name|src
name|AND
name|Elf_External_Shdr
operator|*
name|dst
argument_list|)
block|{
comment|/* note that all elements of dst are *arrays of unsigned char* already... */
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_name
argument_list|,
name|dst
operator|->
name|sh_name
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_type
argument_list|,
name|dst
operator|->
name|sh_type
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_flags
argument_list|,
name|dst
operator|->
name|sh_flags
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_addr
argument_list|,
name|dst
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_offset
argument_list|,
name|dst
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_size
argument_list|,
name|dst
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_link
argument_list|,
name|dst
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_info
argument_list|,
name|dst
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_addralign
argument_list|,
name|dst
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_entsize
argument_list|,
name|dst
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Translate an ELF program header table entry in external format into an    ELF program header table entry in internal format. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_swap_phdr_in
argument_list|,
operator|(
name|abfd
operator|,
name|src
operator|,
name|dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_External_Phdr
operator|*
name|src
name|AND
name|Elf_Internal_Phdr
operator|*
name|dst
argument_list|)
block|{
name|dst
operator|->
name|p_type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_vaddr
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_paddr
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_filesz
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_memsz
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_flags
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_align
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Translate an ELF reloc from external format to internal format. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_swap_reloc_in
argument_list|,
operator|(
name|abfd
operator|,
name|src
operator|,
name|dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_External_Rel
operator|*
name|src
name|AND
name|Elf_Internal_Rel
operator|*
name|dst
argument_list|)
block|{
name|dst
operator|->
name|r_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_info
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_swap_reloca_in
argument_list|,
operator|(
name|abfd
operator|,
name|src
operator|,
name|dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_External_Rela
operator|*
name|src
name|AND
name|Elf_Internal_Rela
operator|*
name|dst
argument_list|)
block|{
name|dst
operator|->
name|r_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_info
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_addend
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Translate an ELF reloc from internal format to external format. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_swap_reloc_out
argument_list|,
operator|(
name|abfd
operator|,
name|src
operator|,
name|dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_Internal_Rel
operator|*
name|src
name|AND
name|Elf_External_Rel
operator|*
name|dst
argument_list|)
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|,
name|dst
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_info
argument_list|,
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_swap_reloca_out
argument_list|,
operator|(
name|abfd
operator|,
name|src
operator|,
name|dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_Internal_Rela
operator|*
name|src
name|AND
name|Elf_External_Rela
operator|*
name|dst
argument_list|)
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|,
name|dst
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_info
argument_list|,
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_addend
argument_list|,
name|dst
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|EXFUN
argument_list|(
name|elf_read
argument_list|,
operator|(
name|bfd
operator|*
operator|,
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sec
modifier|*
name|EXFUN
argument_list|(
name|section_from_elf_index
argument_list|,
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|EXFUN
argument_list|(
name|elf_section_from_bfd_section
argument_list|,
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|EXFUN
argument_list|(
name|elf_slurp_symbol_table
argument_list|,
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|elf_info_to_howto
argument_list|,
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|EXFUN
argument_list|(
name|elf_get_str_section
argument_list|,
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  INTERNAL_FUNCTION 	bfd_elf_find_section  SYNOPSIS 	struct elf_internal_shdr *bfd_elf_find_section (bfd *abfd, char *name);  DESCRIPTION 	Helper functions for GDB to locate the string tables. 	Since BFD hides string tables from callers, GDB needs to use an 	internal hook to find them.  Sun's .stabstr, in particular, 	isn't even pointed to by the .stab section, so ordinary 	mechanisms wouldn't work to find it, even if we had some. */
end_comment

begin_decl_stmt
name|struct
name|elf_internal_shdr
modifier|*
name|DEFUN
argument_list|(
name|bfd_elf_find_section
argument_list|,
operator|(
name|abfd
operator|,
name|name
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
name|name
argument_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|shstrtab
init|=
name|elf_get_str_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|max
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|shstrtab
index|[
name|i_shdrp
index|[
name|i
index|]
operator|.
name|sh_name
index|]
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|&
name|i_shdrp
index|[
name|i
index|]
return|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* End of GDB support.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|DEFUN
argument_list|(
name|elf_get_str_section
argument_list|,
operator|(
name|abfd
operator|,
name|shindex
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|unsigned
name|int
name|shindex
argument_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|shstrtabsize
init|=
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|sh_size
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|sh_offset
decl_stmt|;
name|char
modifier|*
name|shstrtab
init|=
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|rawdata
decl_stmt|;
if|if
condition|(
name|shstrtab
condition|)
return|return
name|shstrtab
return|;
if|if
condition|(
operator|(
name|shstrtab
operator|=
name|elf_read
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|shstrtabsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|rawdata
operator|=
operator|(
name|void
operator|*
operator|)
name|shstrtab
expr_stmt|;
return|return
name|shstrtab
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|DEFUN
argument_list|(
name|elf_string_from_elf_section
argument_list|,
operator|(
name|abfd
operator|,
name|shindex
operator|,
name|strindex
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|unsigned
name|int
name|shindex
name|AND
name|unsigned
name|int
name|strindex
argument_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
name|i_shdrp
operator|+
name|shindex
decl_stmt|;
if|if
condition|(
operator|!
name|hdr
operator|->
name|rawdata
condition|)
block|{
if|if
condition|(
name|elf_get_str_section
argument_list|(
name|abfd
argument_list|,
name|shindex
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|->
name|rawdata
operator|)
operator|+
name|strindex
return|;
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|elf_string_from_elf_strtab
parameter_list|(
name|abfd
parameter_list|,
name|strindex
parameter_list|)
define|\
value|elf_string_from_elf_section (abfd, elf_elfheader(abfd)->e_shstrndx, strindex)
end_define

begin_comment
comment|/* Create a new bfd section from an ELF section header. */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|bfd_section_from_shdr
argument_list|,
operator|(
name|abfd
operator|,
name|shindex
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|unsigned
name|int
name|shindex
argument_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
name|i_shdrp
operator|+
name|shindex
decl_stmt|;
name|asection
modifier|*
name|newsect
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|hdr
operator|->
name|sh_name
condition|?
name|elf_string_from_elf_strtab
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_name
argument_list|)
else|:
literal|"unnamed"
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_NULL
case|:
comment|/* inactive section. Throw it away. */
return|return
name|true
return|;
case|case
name|SHT_PROGBITS
case|:
case|case
name|SHT_NOBITS
case|:
comment|/* Bits that get saved. This one is real. */
if|if
condition|(
operator|!
name|hdr
operator|->
name|rawdata
condition|)
block|{
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|newsect
operator|->
name|vma
operator|=
name|hdr
operator|->
name|sh_addr
expr_stmt|;
name|newsect
operator|->
name|_raw_size
operator|=
name|hdr
operator|->
name|sh_size
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|hdr
operator|->
name|sh_offset
expr_stmt|;
comment|/* so we can read back the bits */
name|newsect
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
condition|)
block|{
name|newsect
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|newsect
operator|->
name|flags
operator||=
name|SEC_LOAD
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_WRITE
operator|)
condition|)
name|newsect
operator|->
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_EXECINSTR
condition|)
name|newsect
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
comment|/* FIXME: may only contain SOME code */
else|else
name|newsect
operator|->
name|flags
operator||=
name|SEC_DATA
expr_stmt|;
name|hdr
operator|->
name|rawdata
operator|=
operator|(
name|void
operator|*
operator|)
name|newsect
expr_stmt|;
block|}
return|return
name|true
return|;
break|break;
case|case
name|SHT_SYMTAB
case|:
comment|/* A symbol table */
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
expr_stmt|;
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
return|return
name|true
return|;
case|case
name|SHT_STRTAB
case|:
comment|/* A string table */
return|return
name|true
return|;
case|case
name|SHT_REL
case|:
case|case
name|SHT_RELA
case|:
comment|/* *these* do a lot of work -- but build no sections! */
comment|/* the spec says there can be multiple strtabs, but only one symtab */
comment|/* but there can be lots of REL* sections. */
comment|/* FIXME:  The above statement is wrong!  There are typically at least        two symbol tables in a dynamically linked executable, ".dynsym"        which is the dynamic linkage symbol table and ".symtab", which is        the "traditional" symbol table.  -fnf */
block|{
name|asection
modifier|*
name|target_sect
decl_stmt|;
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|)
expr_stmt|;
comment|/* symbol table */
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_info
argument_list|)
expr_stmt|;
comment|/* target */
name|target_sect
operator|=
name|section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_sect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|#
directive|if
literal|0
comment|/* FIXME:  We are only prepared to read one symbol table, so 	 do NOT read the dynamic symbol table since it is only a 	 subset of the full symbol table.  Also see comment above. -fnf */
block|if (!elf_slurp_symbol_table(abfd, i_shdrp + hdr->sh_link)) 	return false;
endif|#
directive|endif
name|target_sect
operator|->
name|reloc_count
operator|=
name|hdr
operator|->
name|sh_size
operator|/
name|hdr
operator|->
name|sh_entsize
expr_stmt|;
name|target_sect
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|target_sect
operator|->
name|relocation
operator|=
literal|0
expr_stmt|;
name|target_sect
operator|->
name|rel_filepos
operator|=
name|hdr
operator|->
name|sh_offset
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
case|case
name|SHT_HASH
case|:
case|case
name|SHT_DYNAMIC
case|:
case|case
name|SHT_DYNSYM
case|:
comment|/* could treat this like symtab... */
if|#
directive|if
literal|0
block|fprintf(stderr, "Dynamic Linking sections not yet supported.\n");     abort ();
endif|#
directive|endif
break|break;
case|case
name|SHT_NOTE
case|:
if|#
directive|if
literal|0
block|fprintf(stderr, "Note Sections not yet supported.\n");     abort ();
endif|#
directive|endif
break|break;
case|case
name|SHT_SHLIB
case|:
if|#
directive|if
literal|0
block|fprintf(stderr, "SHLIB Sections not supported (and non conforming.)\n");
endif|#
directive|endif
return|return
name|true
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_decl_stmt

begin_struct
struct|struct
name|strtab
block|{
name|char
modifier|*
name|tab
decl_stmt|;
name|int
name|nentries
decl_stmt|;
name|int
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|strtab
modifier|*
name|DEFUN
argument_list|(
name|bfd_new_strtab
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|struct
name|strtab
modifier|*
name|ss
decl_stmt|;
name|ss
operator|=
operator|(
expr|struct
name|strtab
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|strtab
argument_list|)
argument_list|)
expr_stmt|;
name|ss
operator|->
name|tab
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ss
operator|->
name|tab
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ss
operator|->
name|tab
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|nentries
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|length
operator|=
literal|1
expr_stmt|;
return|return
name|ss
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|bfd_add_to_strtab
argument_list|,
operator|(
name|abfd
operator|,
name|ss
operator|,
name|str
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|strtab
operator|*
name|ss
name|AND
name|CONST
name|char
operator|*
name|str
argument_list|)
block|{
comment|/* should search first, but for now: */
comment|/* include the trailing NUL */
name|int
name|ln
init|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* should this be using obstacks? */
name|ss
operator|->
name|tab
operator|=
name|realloc
argument_list|(
name|ss
operator|->
name|tab
argument_list|,
name|ss
operator|->
name|length
operator|+
name|ln
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ss
operator|->
name|tab
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ss
operator|->
name|tab
operator|+
name|ss
operator|->
name|length
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|ss
operator|->
name|nentries
operator|++
expr_stmt|;
name|ss
operator|->
name|length
operator|+=
name|ln
expr_stmt|;
return|return
name|ss
operator|->
name|length
operator|-
name|ln
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|bfd_add_2_to_strtab
argument_list|,
operator|(
name|abfd
operator|,
name|ss
operator|,
name|str
operator|,
name|str2
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|strtab
operator|*
name|ss
name|AND
name|char
operator|*
name|str
name|AND
name|CONST
name|char
operator|*
name|str2
argument_list|)
block|{
comment|/* should search first, but for now: */
comment|/* include the trailing NUL */
name|int
name|ln
init|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
name|strlen
argument_list|(
name|str2
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* should this be using obstacks? */
if|if
condition|(
name|ss
operator|->
name|length
condition|)
name|ss
operator|->
name|tab
operator|=
name|realloc
argument_list|(
name|ss
operator|->
name|tab
argument_list|,
name|ss
operator|->
name|length
operator|+
name|ln
argument_list|)
expr_stmt|;
else|else
name|ss
operator|->
name|tab
operator|=
name|malloc
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ss
operator|->
name|tab
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ss
operator|->
name|tab
operator|+
name|ss
operator|->
name|length
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ss
operator|->
name|tab
operator|+
name|ss
operator|->
name|length
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|str2
argument_list|)
expr_stmt|;
name|ss
operator|->
name|nentries
operator|++
expr_stmt|;
name|ss
operator|->
name|length
operator|+=
name|ln
expr_stmt|;
return|return
name|ss
operator|->
name|length
operator|-
name|ln
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Create a new ELF section from a bfd section. */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|bfd_shdr_from_section
argument_list|,
operator|(
name|abfd
operator|,
name|hdr
operator|,
name|shstrtab
operator|,
name|indx
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_Internal_Shdr
operator|*
name|hdr
name|AND
expr|struct
name|strtab
operator|*
name|shstrtab
name|AND
name|int
name|indx
argument_list|)
block|{
name|asection
modifier|*
name|sect
decl_stmt|;
name|int
name|ndx
decl_stmt|;
comment|/* figure out out to write the section name from the bfd section name. MWE */
name|sect
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
for|for
control|(
name|ndx
operator|=
name|indx
init|;
operator|--
name|ndx
condition|;
control|)
block|{
name|sect
operator|=
name|sect
operator|->
name|next
expr_stmt|;
block|}
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_name
operator|=
name|bfd_add_to_strtab
argument_list|(
name|abfd
argument_list|,
name|shstrtab
argument_list|,
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_addr
operator|=
name|sect
operator|->
name|vma
expr_stmt|;
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_size
operator|=
name|sect
operator|->
name|_raw_size
expr_stmt|;
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_flags
operator|=
literal|0
expr_stmt|;
comment|/* these need to be preserved on */
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_link
operator|=
literal|0
expr_stmt|;
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_info
operator|=
literal|0
expr_stmt|;
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_addralign
operator|=
literal|0
expr_stmt|;
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_RELOC
condition|)
block|{
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_type
operator|=
name|SHT_RELA
expr_stmt|;
comment|/* FIXME -- sparc specific */
block|}
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
condition|)
block|{
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_offset
operator|=
name|sect
operator|->
name|filepos
expr_stmt|;
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_size
operator|=
name|sect
operator|->
name|_raw_size
expr_stmt|;
block|}
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_ALLOC
condition|)
block|{
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_flags
operator||=
name|SHF_ALLOC
expr_stmt|;
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
comment|/* do something with sh_type ? */
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|sect
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
condition|)
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_flags
operator||=
name|SHF_WRITE
expr_stmt|;
if|if
condition|(
name|sect
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|hdr
index|[
name|indx
index|]
operator|.
name|sh_flags
operator||=
name|SHF_EXECINSTR
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Create a new bfd section from an ELF program header.     Since program segments have no names, we generate a synthetic name    of the form segment<NUM>, where NUM is generally the index in the    program header table.  For segments that are split (see below) we    generate the names segment<NUM>a and segment<NUM>b.     Note that some program segments may have a file size that is different than    (less than) the memory size.  All this means is that at execution the    system must allocate the amount of memory specified by the memory size,    but only initialize it with the first "file size" bytes read from the    file.  This would occur for example, with program segments consisting    of combined data+bss.     To handle the above situation, this routine generates TWO bfd sections    for the single program segment.  The first has the length specified by    the file size of the segment, and the second has the length specified    by the difference between the two sizes.  In effect, the segment is split    into it's initialized and uninitialized parts.   */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|bfd_section_from_phdr
argument_list|,
operator|(
name|abfd
operator|,
name|hdr
operator|,
name|index
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_Internal_Phdr
operator|*
name|hdr
name|AND
name|int
name|index
argument_list|)
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|namebuf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|split
decl_stmt|;
name|split
operator|=
operator|(
operator|(
name|hdr
operator|->
name|p_memsz
operator|>
literal|0
operator|)
operator|&&
operator|(
name|hdr
operator|->
name|p_filesz
operator|>
literal|0
operator|)
operator|&&
operator|(
name|hdr
operator|->
name|p_memsz
operator|>
name|hdr
operator|->
name|p_filesz
operator|)
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|namebuf
argument_list|,
name|split
condition|?
literal|"segment%da"
else|:
literal|"segment%d"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|namebuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|newsect
operator|->
name|vma
operator|=
name|hdr
operator|->
name|p_vaddr
expr_stmt|;
name|newsect
operator|->
name|_raw_size
operator|=
name|hdr
operator|->
name|p_filesz
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|hdr
operator|->
name|p_offset
expr_stmt|;
name|newsect
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|newsect
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
name|newsect
operator|->
name|flags
operator||=
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_X
condition|)
block|{
comment|/* FIXME: all we known is that it has execute PERMISSION, 	     may be data. */
name|newsect
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_W
operator|)
condition|)
block|{
name|newsect
operator|->
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
block|}
if|if
condition|(
name|split
condition|)
block|{
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"segment%db"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|namebuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|newsect
operator|->
name|vma
operator|=
name|hdr
operator|->
name|p_vaddr
operator|+
name|hdr
operator|->
name|p_filesz
expr_stmt|;
name|newsect
operator|->
name|_raw_size
operator|=
name|hdr
operator|->
name|p_memsz
operator|-
name|hdr
operator|->
name|p_filesz
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|newsect
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_X
condition|)
name|newsect
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_W
operator|)
condition|)
name|newsect
operator|->
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PROCFS
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|bfd_prstatus
argument_list|,
operator|(
name|abfd
operator|,
name|descdata
operator|,
name|descsz
operator|,
name|filepos
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
name|descdata
name|AND
name|int
name|descsz
name|AND
name|long
name|filepos
argument_list|)
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|prstatus_t
modifier|*
name|status
init|=
operator|(
name|prstatus_t
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|descsz
operator|==
sizeof|sizeof
argument_list|(
name|prstatus_t
argument_list|)
condition|)
block|{
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|)
expr_stmt|;
name|newsect
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|status
operator|->
name|pr_reg
argument_list|)
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|filepos
operator|+
operator|(
name|long
operator|)
operator|&
name|status
operator|->
name|pr_reg
expr_stmt|;
name|newsect
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
name|newsect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|core_prstatus
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|descsz
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|core_prstatus
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|descdata
argument_list|,
name|descsz
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Stash a copy of the prpsinfo structure away for future use. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|bfd_prpsinfo
argument_list|,
operator|(
name|abfd
operator|,
name|descdata
operator|,
name|descsz
operator|,
name|filepos
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
name|descdata
name|AND
name|int
name|descsz
name|AND
name|long
name|filepos
argument_list|)
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
if|if
condition|(
name|descsz
operator|==
sizeof|sizeof
argument_list|(
name|prpsinfo_t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|core_prpsinfo
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|descsz
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|core_prpsinfo
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|descdata
argument_list|,
name|descsz
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|bfd_fpregset
argument_list|,
operator|(
name|abfd
operator|,
name|descdata
operator|,
name|descsz
operator|,
name|filepos
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
name|descdata
name|AND
name|int
name|descsz
name|AND
name|long
name|filepos
argument_list|)
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".reg2"
argument_list|)
expr_stmt|;
name|newsect
operator|->
name|_raw_size
operator|=
name|descsz
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|filepos
expr_stmt|;
name|newsect
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
name|newsect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PROCFS */
end_comment

begin_comment
comment|/* Return a pointer to the args (including the command name) that were    seen by the program that generated the core dump.  Note that for    some reason, a spurious space is tacked onto the end of the args    in some (at least one anyway) implementations, so strip it off if    it exists. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DEFUN
argument_list|(
name|elf_core_file_failing_command
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PROCFS
if|if
condition|(
name|core_prpsinfo
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|prpsinfo_t
modifier|*
name|p
init|=
name|core_prpsinfo
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|scan
init|=
name|p
operator|->
name|pr_psargs
decl_stmt|;
while|while
condition|(
operator|*
name|scan
operator|++
condition|)
block|{
empty_stmt|;
block|}
name|scan
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|scan
operator|>
name|p
operator|->
name|pr_psargs
operator|)
operator|&&
operator|(
operator|*
name|scan
operator|==
literal|' '
operator|)
condition|)
block|{
operator|*
name|scan
operator|=
literal|'\000'
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|->
name|pr_psargs
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return the number of the signal that caused the core dump.  Presumably,    since we have a core file, we got a signal of some kind, so don't bother    checking the other process status fields, just return the signal number.    */
end_comment

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|elf_core_file_failing_signal
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PROCFS
if|if
condition|(
name|core_prstatus
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
operator|(
name|prstatus_t
operator|*
operator|)
operator|(
name|core_prstatus
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
operator|->
name|pr_cursig
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Check to see if the core file could reasonably be expected to have    come for the current executable file.  Note that by default we return    true unless we find something that indicates that there might be a    problem.    */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|elf_core_file_matches_executable_p
argument_list|,
operator|(
name|core_bfd
operator|,
name|exec_bfd
operator|)
argument_list|,
name|bfd
operator|*
name|core_bfd
name|AND
name|bfd
operator|*
name|exec_bfd
argument_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PROCFS
name|char
modifier|*
name|corename
decl_stmt|;
name|char
modifier|*
name|execname
decl_stmt|;
endif|#
directive|endif
comment|/* First, xvecs must match since both are ELF files for the same target. */
if|if
condition|(
name|core_bfd
operator|->
name|xvec
operator|!=
name|exec_bfd
operator|->
name|xvec
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_PROCFS
comment|/* If no prpsinfo, just return true.  Otherwise, grab the last component      of the exec'd pathname from the prpsinfo. */
if|if
condition|(
name|core_prpsinfo
argument_list|(
name|core_bfd
argument_list|)
condition|)
block|{
name|corename
operator|=
operator|(
operator|(
operator|(
expr|struct
name|prpsinfo
operator|*
operator|)
name|core_prpsinfo
argument_list|(
name|core_bfd
argument_list|)
operator|)
operator|->
name|pr_fname
operator|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* Find the last component of the executable pathname. */
if|if
condition|(
operator|(
name|execname
operator|=
name|strrchr
argument_list|(
name|exec_bfd
operator|->
name|filename
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|execname
operator|++
expr_stmt|;
block|}
else|else
block|{
name|execname
operator|=
operator|(
name|char
operator|*
operator|)
name|exec_bfd
operator|->
name|filename
expr_stmt|;
block|}
comment|/* See if they match */
return|return
operator|(
name|strcmp
argument_list|(
name|execname
argument_list|,
name|corename
argument_list|)
condition|?
name|false
else|:
name|true
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|true
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_PROCFS */
block|}
end_decl_stmt

begin_comment
comment|/* ELF core files contain a segment of type PT_NOTE, that holds much of    the information that would normally be available from the /proc interface    for the process, at the time the process dumped core.  Currently this    includes copies of the prstatus, prpsinfo, and fpregset structures.     Since these structures are potentially machine dependent in size and    ordering, bfd provides two levels of support for them.  The first level,    available on all machines since it does not require that the host    have /proc support or the relevant include files, is to create a bfd    section for each of the prstatus, prpsinfo, and fpregset structures,    without any interpretation of their contents.  With just this support,    the bfd client will have to interpret the structures itself.  Even with    /proc support, it might want these full structures for it's own reasons.     In the second level of support, where HAVE_PROCFS is defined, bfd will    pick apart the structures to gather some additional information that    clients may want, such as the general register set, the name of the    exec'ed file and its arguments, the signal (if any) that caused the    core dump, etc.     */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|elf_corefile_note
argument_list|,
operator|(
name|abfd
operator|,
name|hdr
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|Elf_Internal_Phdr
operator|*
name|hdr
argument_list|)
block|{
name|Elf_External_Note
modifier|*
name|x_note_p
decl_stmt|;
comment|/* Elf note, external form */
name|Elf_Internal_Note
name|i_note
decl_stmt|;
comment|/* Elf note, internal form */
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
comment|/* Entire note segment contents */
name|char
modifier|*
name|namedata
decl_stmt|;
comment|/* Name portion of the note */
name|char
modifier|*
name|descdata
decl_stmt|;
comment|/* Descriptor portion of the note */
name|char
modifier|*
name|sectname
decl_stmt|;
comment|/* Name to use for new section */
name|long
name|filepos
decl_stmt|;
comment|/* File offset to descriptor data */
name|asection
modifier|*
name|newsect
decl_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_filesz
operator|>
literal|0
operator|&&
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_xmalloc
argument_list|(
name|hdr
operator|->
name|p_filesz
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|p_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buf
argument_list|,
name|hdr
operator|->
name|p_filesz
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|==
name|hdr
operator|->
name|p_filesz
condition|)
block|{
name|x_note_p
operator|=
operator|(
name|Elf_External_Note
operator|*
operator|)
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|char
operator|*
operator|)
name|x_note_p
operator|<
operator|(
name|buf
operator|+
name|hdr
operator|->
name|p_filesz
operator|)
condition|)
block|{
name|i_note
operator|.
name|namesz
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_note_p
operator|->
name|namesz
argument_list|)
expr_stmt|;
name|i_note
operator|.
name|descsz
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_note_p
operator|->
name|descsz
argument_list|)
expr_stmt|;
name|i_note
operator|.
name|type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_note_p
operator|->
name|type
argument_list|)
expr_stmt|;
name|namedata
operator|=
name|x_note_p
operator|->
name|name
expr_stmt|;
name|descdata
operator|=
name|namedata
operator|+
name|BFD_ALIGN
argument_list|(
name|i_note
operator|.
name|namesz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|filepos
operator|=
name|hdr
operator|->
name|p_offset
operator|+
operator|(
name|descdata
operator|-
name|buf
operator|)
expr_stmt|;
switch|switch
condition|(
name|i_note
operator|.
name|type
condition|)
block|{
case|case
name|NT_PRSTATUS
case|:
comment|/* process descdata as prstatus info */
name|bfd_prstatus
argument_list|(
name|abfd
argument_list|,
name|descdata
argument_list|,
name|i_note
operator|.
name|descsz
argument_list|,
name|filepos
argument_list|)
expr_stmt|;
name|sectname
operator|=
literal|".prstatus"
expr_stmt|;
break|break;
case|case
name|NT_FPREGSET
case|:
comment|/* process descdata as fpregset info */
name|bfd_fpregset
argument_list|(
name|abfd
argument_list|,
name|descdata
argument_list|,
name|i_note
operator|.
name|descsz
argument_list|,
name|filepos
argument_list|)
expr_stmt|;
name|sectname
operator|=
literal|".fpregset"
expr_stmt|;
break|break;
case|case
name|NT_PRPSINFO
case|:
comment|/* process descdata as prpsinfo */
name|bfd_prpsinfo
argument_list|(
name|abfd
argument_list|,
name|descdata
argument_list|,
name|i_note
operator|.
name|descsz
argument_list|,
name|filepos
argument_list|)
expr_stmt|;
name|sectname
operator|=
literal|".prpsinfo"
expr_stmt|;
break|break;
default|default:
comment|/* Unknown descriptor, just ignore it. */
name|sectname
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sectname
operator|!=
name|NULL
condition|)
block|{
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|sectname
argument_list|)
expr_stmt|;
name|newsect
operator|->
name|_raw_size
operator|=
name|i_note
operator|.
name|descsz
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|filepos
expr_stmt|;
name|newsect
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
name|newsect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
block|}
name|x_note_p
operator|=
operator|(
name|Elf_External_Note
operator|*
operator|)
operator|(
name|descdata
operator|+
name|BFD_ALIGN
argument_list|(
name|i_note
operator|.
name|descsz
argument_list|,
literal|4
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Read a specified number of bytes at a specified offset in an ELF    file, into a newly allocated buffer, and return a pointer to the     buffer. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|DEFUN
argument_list|(
name|elf_read
argument_list|,
operator|(
name|abfd
operator|,
name|offset
operator|,
name|size
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|long
name|offset
name|AND
name|int
name|size
argument_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Begin processing a given object.     First we validate the file by reading in the ELF header and checking    the magic number.     */
end_comment

begin_decl_stmt
specifier|static
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|elf_object_p
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_External_Shdr
name|x_shdr
decl_stmt|;
comment|/* Section header table entry, external form */
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
decl_stmt|;
comment|/* Section header table, internal form */
name|int
name|shindex
decl_stmt|;
name|char
modifier|*
name|shstrtab
decl_stmt|;
comment|/* Internal copy of section header stringtab */
comment|/* Read in the ELF header in external format.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_ehdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Now check to see if we have a valid ELF file, and one that BFD can      make use of.  The magic number must match, the address size ('class')      and byte-swapping must match our XVEC entry, and it must have a      section header table (FIXME: See comments re sections at top of this      file). */
if|if
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_MAG0
index|]
operator|!=
name|ELFMAG0
operator|||
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_MAG1
index|]
operator|!=
name|ELFMAG1
operator|||
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_MAG2
index|]
operator|!=
name|ELFMAG2
operator|||
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_MAG3
index|]
operator|!=
name|ELFMAG3
condition|)
block|{
name|wrong
label|:
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* FIXME, Check EI_VERSION here !  */
switch|switch
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
condition|)
block|{
case|case
name|ELFCLASSNONE
case|:
comment|/* address size not specified */
goto|goto
name|wrong
goto|;
comment|/* No support if can't tell address size */
case|case
name|ELFCLASS32
case|:
comment|/* 32-bit addresses */
break|break;
case|case
name|ELFCLASS64
case|:
comment|/* 64-bit addresses */
goto|goto
name|wrong
goto|;
comment|/* FIXME: 64 bits not yet supported */
default|default:
goto|goto
name|wrong
goto|;
comment|/* No support if unknown address class */
block|}
comment|/* Switch xvec to match the specified byte order.  */
switch|switch
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
comment|/* Big-endian */
if|if
condition|(
operator|!
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
condition|)
goto|goto
name|wrong
goto|;
break|break;
case|case
name|ELFDATA2LSB
case|:
comment|/* Little-endian */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
condition|)
goto|goto
name|wrong
goto|;
break|break;
case|case
name|ELFDATANONE
case|:
comment|/* No data encoding specified */
default|default:
comment|/* Unknown data encoding specified */
goto|goto
name|wrong
goto|;
block|}
comment|/* Allocate an instance of the elf_obj_tdata structure and hook it up to      the tdata pointer in the bfd. */
if|if
condition|(
name|NULL
operator|==
operator|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|elf_obj_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_obj_tdata
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* FIXME:  Any `wrong' exits below here will leak memory (tdata).  */
comment|/* Now that we know the byte order, swap in the rest of the header */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elf_swap_ehdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_ehdr
argument_list|,
name|i_ehdrp
argument_list|)
expr_stmt|;
comment|/* If there is no section header table, we're hosed. */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shoff
operator|==
literal|0
condition|)
goto|goto
name|wrong
goto|;
if|if
condition|(
name|i_ehdrp
operator|->
name|e_type
operator|==
name|ET_EXEC
operator|||
name|i_ehdrp
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
switch|switch
condition|(
name|i_ehdrp
operator|->
name|e_machine
condition|)
block|{
case|case
name|EM_NONE
case|:
case|case
name|EM_M32
case|:
comment|/* or should this be bfd_arch_obscure? */
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_unknown
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_SPARC
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sparc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_386
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_i386
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_68K
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_m68k
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_88K
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_m88k
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_860
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_i860
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MIPS
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_mips
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|wrong
goto|;
block|}
comment|/* Allocate space for a copy of the section header table in       internal form, seek to the section header table in the file,      read it in, and convert it to internal form.  As a simple sanity      check, verify that the what BFD thinks is the size of each section      header table entry actually matches the size recorded in the file. */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shentsize
operator|!=
sizeof|sizeof
argument_list|(
name|x_shdr
argument_list|)
condition|)
goto|goto
name|wrong
goto|;
name|i_shdrp
operator|=
operator|(
name|Elf_Internal_Shdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i_shdrp
argument_list|)
operator|*
name|i_ehdrp
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i_shdrp
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_shoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|shindex
operator|=
literal|0
init|;
name|shindex
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|shindex
operator|++
control|)
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_shdr
argument_list|,
sizeof|sizeof
name|x_shdr
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_shdr
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|elf_swap_shdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_shdr
argument_list|,
name|i_shdrp
operator|+
name|shindex
argument_list|)
expr_stmt|;
block|}
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|=
name|i_shdrp
expr_stmt|;
comment|/* Read in the string table containing the names of the sections.  We      will need the base pointer to this table later. */
comment|/* We read this inline now, so that we don't have to go through      bfd_section_from_shdr with it (since this particular strtab is      used to find all of the ELF section names.) */
name|shstrtab
operator|=
name|elf_get_str_section
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shstrtab
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Once all of the section headers have been read and converted, we      can start processing them.  Note that the first section header is      a dummy placeholder entry, so we ignore it.       We also watch for the symbol table section and remember the file      offset and section size for both the symbol table section and the      associated string table section. */
for|for
control|(
name|shindex
operator|=
literal|1
init|;
name|shindex
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|shindex
operator|++
control|)
block|{
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|shindex
argument_list|)
expr_stmt|;
block|}
comment|/* Remember the entry point specified in the ELF file header. */
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|i_ehdrp
operator|->
name|e_entry
expr_stmt|;
return|return
operator|(
name|abfd
operator|->
name|xvec
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  Core files are simply standard ELF formatted files that partition     the file using the execution view of the file (program header table)     rather than the linking view.  In fact, there is no section header     table in a core file.      The process status information (including the contents of the general     register set) and the floating point register set are stored in a     segment of type PT_NOTE.  We handcraft a couple of extra bfd sections     that allow standard bfd access to the general registers (.reg) and the     floating point registers (.reg2).   */
end_comment

begin_decl_stmt
specifier|static
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|elf_core_file_p
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_External_Phdr
name|x_phdr
decl_stmt|;
comment|/* Program header table entry, external form */
name|Elf_Internal_Phdr
modifier|*
name|i_phdrp
decl_stmt|;
comment|/* Program header table, internal form */
name|unsigned
name|int
name|phindex
decl_stmt|;
comment|/* Read in the ELF header in external format.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_ehdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Now check to see if we have a valid ELF file, and one that BFD can      make use of.  The magic number must match, the address size ('class')      and byte-swapping must match our XVEC entry, and it must have a      program header table (FIXME: See comments re segments at top of this      file). */
if|if
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_MAG0
index|]
operator|!=
name|ELFMAG0
operator|||
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_MAG1
index|]
operator|!=
name|ELFMAG1
operator|||
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_MAG2
index|]
operator|!=
name|ELFMAG2
operator|||
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_MAG3
index|]
operator|!=
name|ELFMAG3
condition|)
block|{
name|wrong
label|:
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* FIXME, Check EI_VERSION here !  */
switch|switch
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
condition|)
block|{
case|case
name|ELFCLASSNONE
case|:
comment|/* address size not specified */
goto|goto
name|wrong
goto|;
comment|/* No support if can't tell address size */
case|case
name|ELFCLASS32
case|:
comment|/* 32-bit addresses */
break|break;
case|case
name|ELFCLASS64
case|:
comment|/* 64-bit addresses */
goto|goto
name|wrong
goto|;
comment|/* FIXME: 64 bits not yet supported */
default|default:
goto|goto
name|wrong
goto|;
comment|/* No support if unknown address class */
block|}
comment|/* Switch xvec to match the specified byte order.  */
switch|switch
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
comment|/* Big-endian */
name|abfd
operator|->
name|xvec
operator|=
operator|&
name|elf_big_vec
expr_stmt|;
break|break;
case|case
name|ELFDATA2LSB
case|:
comment|/* Little-endian */
name|abfd
operator|->
name|xvec
operator|=
operator|&
name|elf_little_vec
expr_stmt|;
break|break;
case|case
name|ELFDATANONE
case|:
comment|/* No data encoding specified */
default|default:
comment|/* Unknown data encoding specified */
goto|goto
name|wrong
goto|;
block|}
comment|/* Allocate an instance of the elf_obj_tdata structure and hook it up to      the tdata pointer in the bfd. */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|elf_obj_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_obj_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* FIXME, `wrong' returns from this point onward, leak memory.  */
comment|/* Now that we know the byte order, swap in the rest of the header */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elf_swap_ehdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_ehdr
argument_list|,
name|i_ehdrp
argument_list|)
expr_stmt|;
comment|/* If there is no program header, or the type is not a core file, then      we are hosed. */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phoff
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_type
operator|!=
name|ET_CORE
condition|)
goto|goto
name|wrong
goto|;
comment|/* Allocate space for a copy of the program header table in       internal form, seek to the program header table in the file,      read it in, and convert it to internal form.  As a simple sanity      check, verify that the what BFD thinks is the size of each program      header table entry actually matches the size recorded in the file. */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phentsize
operator|!=
sizeof|sizeof
argument_list|(
name|x_phdr
argument_list|)
condition|)
goto|goto
name|wrong
goto|;
name|i_phdrp
operator|=
operator|(
name|Elf_Internal_Phdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i_phdrp
argument_list|)
operator|*
name|i_ehdrp
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i_phdrp
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_phoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|phindex
operator|=
literal|0
init|;
name|phindex
operator|<
name|i_ehdrp
operator|->
name|e_phnum
condition|;
name|phindex
operator|++
control|)
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_phdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_phdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_phdr
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|elf_swap_phdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_phdr
argument_list|,
name|i_phdrp
operator|+
name|phindex
argument_list|)
expr_stmt|;
block|}
comment|/* Once all of the program headers have been read and converted, we      can start processing them. */
for|for
control|(
name|phindex
operator|=
literal|0
init|;
name|phindex
operator|<
name|i_ehdrp
operator|->
name|e_phnum
condition|;
name|phindex
operator|++
control|)
block|{
name|bfd_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|i_phdrp
operator|+
name|phindex
argument_list|,
name|phindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i_phdrp
operator|+
name|phindex
operator|)
operator|->
name|p_type
operator|==
name|PT_NOTE
condition|)
block|{
name|elf_corefile_note
argument_list|(
name|abfd
argument_list|,
name|i_phdrp
operator|+
name|phindex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remember the entry point specified in the ELF file header. */
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|i_ehdrp
operator|->
name|e_entry
expr_stmt|;
return|return
operator|(
name|abfd
operator|->
name|xvec
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|elf_mkobject
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
comment|/* this just does initialization */
comment|/* coff_mkobject zalloc's space for tdata.coff_obj_data ... */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|elf_obj_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_obj_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* since everything is done at close time, do we need any      initialization? */
return|return
operator|(
name|true
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*   Create ELF output from BFD sections.      Essentially, just create the section header and forget about the program   header for now.       */
end_comment

begin_comment
comment|/* lacking nested functions and nested types, set up for mapping over    BFD sections to produce ELF sections */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
decl_stmt|;
name|struct
name|strtab
modifier|*
name|shstrtab
decl_stmt|;
name|int
name|symtab_section
decl_stmt|;
block|}
name|elf_sect_thunk
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_make_sections
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|,
name|obj
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|asect
name|AND
name|PTR
name|obj
argument_list|)
block|{
name|elf_sect_thunk
modifier|*
name|thunk
init|=
operator|(
name|elf_sect_thunk
operator|*
operator|)
name|obj
decl_stmt|;
comment|/* most of what is in bfd_shdr_from_section goes in here... */
comment|/* and all of these sections generate at *least* one ELF section. */
name|int
name|this_section
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* check if we're making a PROGBITS section... */
comment|/* if ((asect->flags& SEC_ALLOC)&& (asect->flags& SEC_LOAD)) */
comment|/* this was too strict... what *do* we want to check here? */
if|if
condition|(
literal|1
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|this_hdr
decl_stmt|;
name|this_section
operator|=
name|elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
name|this_hdr
operator|=
operator|&
name|thunk
operator|->
name|i_shdrp
index|[
name|this_section
index|]
expr_stmt|;
name|this_hdr
operator|->
name|sh_addr
operator|=
name|asect
operator|->
name|vma
expr_stmt|;
name|this_hdr
operator|->
name|sh_size
operator|=
name|asect
operator|->
name|_raw_size
expr_stmt|;
comment|/* contents already set by elf_set_section_contents */
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
condition|)
block|{
comment|/* emit a reloc section, and thus strtab and symtab... */
name|Elf_Internal_Shdr
modifier|*
name|rela_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symstrtab_hdr
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|outbound_relocs
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|outbound_syms
decl_stmt|;
name|int
name|rela_section
decl_stmt|;
name|int
name|symstrtab_section
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|thunk
operator|->
name|i_shdrp
index|[
name|thunk
operator|->
name|symtab_section
index|]
expr_stmt|;
if|if
condition|(
name|thunk
operator|->
name|symtab_section
operator|==
name|this_section
operator|+
literal|1
condition|)
name|rela_section
operator|=
name|thunk
operator|->
name|symtab_section
operator|+
literal|2
expr_stmt|;
comment|/* symtab + symstrtab */
else|else
name|rela_section
operator|=
name|this_section
operator|+
literal|1
expr_stmt|;
name|rela_hdr
operator|=
operator|&
name|thunk
operator|->
name|i_shdrp
index|[
name|rela_section
index|]
expr_stmt|;
name|rela_hdr
operator|->
name|sh_type
operator|=
name|SHT_RELA
expr_stmt|;
name|rela_hdr
operator|->
name|sh_link
operator|=
name|thunk
operator|->
name|symtab_section
expr_stmt|;
name|rela_hdr
operator|->
name|sh_info
operator|=
name|this_section
expr_stmt|;
name|rela_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
expr_stmt|;
comment|/* orelocation has the data, reloc_count has the count... */
name|rela_hdr
operator|->
name|sh_size
operator|=
name|rela_hdr
operator|->
name|sh_entsize
operator|*
name|asect
operator|->
name|reloc_count
expr_stmt|;
name|outbound_relocs
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|asect
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
name|Elf_Internal_Rela
name|dst
decl_stmt|;
name|arelent
modifier|*
name|ptr
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|src
decl_stmt|;
name|ptr
operator|=
name|asect
operator|->
name|orelocation
index|[
name|idx
index|]
expr_stmt|;
name|src
operator|=
name|outbound_relocs
operator|+
name|idx
expr_stmt|;
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
condition|)
name|dst
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
operator|-
name|asect
operator|->
name|vma
expr_stmt|;
else|else
name|dst
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
expr_stmt|;
name|dst
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
literal|1
comment|/*ptr->sym_ptr_ptr*/
argument_list|,
comment|/* needs index into symtab (FIXME) */
name|ptr
operator|->
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|dst
operator|.
name|r_addend
operator|=
name|ptr
operator|->
name|addend
expr_stmt|;
name|elf_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
name|rela_hdr
operator|->
name|contents
operator|=
operator|(
name|void
operator|*
operator|)
name|outbound_relocs
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_fake_sections
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|,
name|obj
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|asect
name|AND
name|PTR
name|obj
argument_list|)
block|{
name|elf_sect_thunk
modifier|*
name|thunk
init|=
operator|(
name|elf_sect_thunk
operator|*
operator|)
name|obj
decl_stmt|;
comment|/* most of what is in bfd_shdr_from_section goes in here... */
comment|/* and all of these sections generate at *least* one ELF section. */
name|int
name|this_section
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* check if we're making a PROGBITS section... */
comment|/* if ((asect->flags& SEC_ALLOC)&& (asect->flags& SEC_LOAD)) */
comment|/* this was too strict... what *do* we want to check here? */
if|if
condition|(
literal|1
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|this_hdr
decl_stmt|;
name|this_section
operator|=
name|thunk
operator|->
name|i_ehdr
operator|->
name|e_shnum
operator|++
expr_stmt|;
name|this_hdr
operator|=
operator|&
name|thunk
operator|->
name|i_shdrp
index|[
name|this_section
index|]
expr_stmt|;
name|this_hdr
operator|->
name|sh_name
operator|=
name|bfd_add_to_strtab
argument_list|(
name|abfd
argument_list|,
name|thunk
operator|->
name|shstrtab
argument_list|,
name|asect
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* we need to log the type *now* so that elf_section_from_bfd_section 	 can find us... have to set rawdata too. */
name|this_hdr
operator|->
name|rawdata
operator|=
operator|(
name|void
operator|*
operator|)
name|asect
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|&&
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
else|else
comment|/* what *do* we put here? */
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
condition|)
block|{
comment|/* emit a reloc section, and thus strtab and symtab... */
name|Elf_Internal_Shdr
modifier|*
name|rela_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symstrtab_hdr
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|outbound_relocs
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|outbound_syms
decl_stmt|;
name|int
name|rela_section
decl_stmt|;
name|int
name|symstrtab_section
decl_stmt|;
comment|/* note that only one symtab is used, so just remember it 	     for now */
if|if
condition|(
operator|!
name|thunk
operator|->
name|symtab_section
condition|)
block|{
name|thunk
operator|->
name|symtab_section
operator|=
name|thunk
operator|->
name|i_ehdr
operator|->
name|e_shnum
operator|++
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|thunk
operator|->
name|i_shdrp
index|[
name|thunk
operator|->
name|symtab_section
index|]
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_name
operator|=
name|bfd_add_to_strtab
argument_list|(
name|abfd
argument_list|,
name|thunk
operator|->
name|shstrtab
argument_list|,
literal|".symtab"
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_SYMTAB
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|symstrtab_section
operator|=
name|thunk
operator|->
name|i_ehdr
operator|->
name|e_shnum
operator|++
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|symstrtab_section
operator|==
name|thunk
operator|->
name|symtab_section
operator|+
literal|1
argument_list|)
expr_stmt|;
name|symstrtab_hdr
operator|=
operator|&
name|thunk
operator|->
name|i_shdrp
index|[
name|symstrtab_section
index|]
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_link
operator|=
name|symstrtab_section
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_name
operator|=
name|bfd_add_to_strtab
argument_list|(
name|abfd
argument_list|,
name|thunk
operator|->
name|shstrtab
argument_list|,
literal|".strtab"
argument_list|)
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|contents
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|symtab_hdr
operator|=
operator|&
name|thunk
operator|->
name|i_shdrp
index|[
name|thunk
operator|->
name|symtab_section
index|]
expr_stmt|;
name|rela_section
operator|=
name|thunk
operator|->
name|i_ehdr
operator|->
name|e_shnum
operator|++
expr_stmt|;
name|rela_hdr
operator|=
operator|&
name|thunk
operator|->
name|i_shdrp
index|[
name|rela_section
index|]
expr_stmt|;
name|rela_hdr
operator|->
name|sh_name
operator|=
name|bfd_add_2_to_strtab
argument_list|(
name|abfd
argument_list|,
name|thunk
operator|->
name|shstrtab
argument_list|,
literal|".rela"
argument_list|,
name|asect
operator|->
name|name
argument_list|)
expr_stmt|;
name|rela_hdr
operator|->
name|sh_type
operator|=
name|SHT_RELA
expr_stmt|;
name|rela_hdr
operator|->
name|sh_link
operator|=
name|thunk
operator|->
name|symtab_section
expr_stmt|;
name|rela_hdr
operator|->
name|sh_info
operator|=
name|this_section
expr_stmt|;
name|rela_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|elf_compute_section_file_positions
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
decl_stmt|;
comment|/* Section header table, internal form */
name|struct
name|strtab
modifier|*
name|shstrtab
decl_stmt|;
name|int
name|count
decl_stmt|,
name|maxsections
decl_stmt|;
name|int
name|outbase
decl_stmt|;
name|elf_sect_thunk
name|est
decl_stmt|;
if|if
condition|(
operator|!
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* build new header in tdata memory */
name|shstrtab
operator|=
name|bfd_new_strtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|=
name|ELFMAG0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|=
name|ELFMAG1
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|=
name|ELFMAG2
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|=
name|ELFMAG3
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|ELFCLASS32
expr_stmt|;
comment|/* FIXME: find out from bfd */
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|abfd
operator|->
name|xvec
operator|->
name|byteorder_big_p
condition|?
name|ELFDATA2MSB
else|:
name|ELFDATA2LSB
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|=
name|EV_CURRENT
expr_stmt|;
for|for
control|(
name|count
operator|=
name|EI_PAD
init|;
name|count
operator|<
name|EI_NIDENT
condition|;
name|count
operator|++
control|)
name|i_ehdrp
operator|->
name|e_ident
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_type
operator|=
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
condition|?
name|ET_EXEC
else|:
name|ET_REL
expr_stmt|;
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_unknown
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_NONE
expr_stmt|;
break|break;
case|case
name|bfd_arch_sparc
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_SPARC
expr_stmt|;
break|break;
case|case
name|bfd_arch_i386
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_386
expr_stmt|;
break|break;
case|case
name|bfd_arch_m68k
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_68K
expr_stmt|;
break|break;
case|case
name|bfd_arch_m88k
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_88K
expr_stmt|;
break|break;
case|case
name|bfd_arch_i860
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_860
expr_stmt|;
break|break;
case|case
name|bfd_arch_mips
case|:
comment|/* MIPS Rxxxx */
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_MIPS
expr_stmt|;
comment|/* only MIPS R3000 */
break|break;
comment|/* also note that EM_M32, AT&T WE32100 is unknown to bfd */
default|default:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_NONE
expr_stmt|;
block|}
name|i_ehdrp
operator|->
name|e_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ehsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Ehdr
argument_list|)
expr_stmt|;
comment|/* no program header, for now. */
name|i_ehdrp
operator|->
name|e_phoff
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phentsize
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phnum
operator|=
literal|0
expr_stmt|;
comment|/* each bfd section is section header entry */
name|i_ehdrp
operator|->
name|e_entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|->
name|e_shentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Shdr
argument_list|)
expr_stmt|;
comment|/* figure at most each section can have a rel, strtab, symtab */
name|maxsections
operator|=
literal|4
operator|*
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|2
expr_stmt|;
name|i_ehdrp
operator|->
name|e_shoff
operator|=
name|i_ehdrp
operator|->
name|e_ehsize
expr_stmt|;
comment|/* and we'll just have to fix up the offsets later. */
comment|/* outbase += i_ehdr.e_shentsize * i_ehdr.e_shnum; */
name|i_shdrp
operator|=
operator|(
name|Elf_Internal_Shdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i_shdrp
argument_list|)
operator|*
name|maxsections
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i_shdrp
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|maxsections
condition|;
name|count
operator|++
control|)
block|{
name|i_shdrp
index|[
name|count
index|]
operator|.
name|rawdata
operator|=
literal|0
expr_stmt|;
name|i_shdrp
index|[
name|count
index|]
operator|.
name|contents
operator|=
literal|0
expr_stmt|;
block|}
name|i_shdrp
index|[
literal|0
index|]
operator|.
name|sh_name
operator|=
literal|0
expr_stmt|;
name|i_shdrp
index|[
literal|0
index|]
operator|.
name|sh_type
operator|=
name|SHT_NULL
expr_stmt|;
name|i_shdrp
index|[
literal|0
index|]
operator|.
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|i_shdrp
index|[
literal|0
index|]
operator|.
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|i_shdrp
index|[
literal|0
index|]
operator|.
name|sh_offset
operator|=
literal|0
expr_stmt|;
name|i_shdrp
index|[
literal|0
index|]
operator|.
name|sh_size
operator|=
literal|0
expr_stmt|;
name|i_shdrp
index|[
literal|0
index|]
operator|.
name|sh_link
operator|=
name|SHN_UNDEF
expr_stmt|;
name|i_shdrp
index|[
literal|0
index|]
operator|.
name|sh_info
operator|=
literal|0
expr_stmt|;
name|i_shdrp
index|[
literal|0
index|]
operator|.
name|sh_addralign
operator|=
literal|0
expr_stmt|;
name|i_shdrp
index|[
literal|0
index|]
operator|.
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_shnum
operator|=
literal|1
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|=
name|i_shdrp
expr_stmt|;
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|shstrtab
expr_stmt|;
block|}
name|est
operator|.
name|i_ehdr
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|est
operator|.
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|est
operator|.
name|shstrtab
operator|=
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|est
operator|.
name|symtab_section
operator|=
literal|0
expr_stmt|;
comment|/* elf_fake_sections fils it in */
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|elf_fake_sections
argument_list|,
operator|&
name|est
argument_list|)
expr_stmt|;
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|est
operator|.
name|symtab_section
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|elf_write_object_contents
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_External_Phdr
modifier|*
name|x_phdrp
decl_stmt|;
comment|/* Program header table, external form */
name|Elf_Internal_Phdr
modifier|*
name|i_phdrp
decl_stmt|;
comment|/* Program header table, internal form */
name|Elf_External_Shdr
modifier|*
name|x_shdrp
decl_stmt|;
comment|/* Section header table, external form */
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
decl_stmt|;
comment|/* Section header table, internal form */
name|asection
modifier|*
name|nsect
decl_stmt|;
name|int
name|maxsections
decl_stmt|;
name|elf_sect_thunk
name|est
decl_stmt|;
name|int
name|outbase
init|=
literal|0
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|strtab
modifier|*
name|shstrtab
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
name|elf_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|shstrtab
operator|=
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|est
operator|.
name|i_ehdr
operator|=
name|i_ehdrp
expr_stmt|;
name|est
operator|.
name|i_shdrp
operator|=
name|i_shdrp
expr_stmt|;
name|est
operator|.
name|shstrtab
operator|=
name|shstrtab
expr_stmt|;
name|est
operator|.
name|symtab_section
operator|=
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* filled in by elf_fake */
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|elf_make_sections
argument_list|,
operator|&
name|est
argument_list|)
expr_stmt|;
comment|/* dump out the one symtab */
block|{
name|int
name|symcount
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|strtab
modifier|*
name|stt
init|=
name|bfd_new_strtab
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symstrtab_hdr
decl_stmt|;
name|int
name|symstrtab_section
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|outbound_syms
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|i_shdrp
index|[
name|est
operator|.
name|symtab_section
index|]
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_SYMTAB
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_size
operator|=
name|symtab_hdr
operator|->
name|sh_entsize
operator|*
name|symcount
expr_stmt|;
comment|/* see assert in elf_fake_sections that supports this: */
name|symstrtab_section
operator|=
name|est
operator|.
name|symtab_section
operator|+
literal|1
expr_stmt|;
name|symstrtab_hdr
operator|=
operator|&
name|i_shdrp
index|[
name|symstrtab_section
index|]
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_link
operator|=
name|symstrtab_section
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|outbound_syms
operator|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
literal|1
operator|+
name|symcount
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now generate the data (for "contents") */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symcount
condition|;
name|idx
operator|++
control|)
block|{
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|sym
operator|.
name|st_name
operator|=
name|bfd_add_to_strtab
argument_list|(
name|abfd
argument_list|,
name|stt
argument_list|,
name|syms
index|[
name|idx
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
name|syms
index|[
name|idx
index|]
operator|->
name|value
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
comment|/* we should recover this (FIXME) */
if|if
condition|(
name|syms
index|[
name|idx
index|]
operator|->
name|flags
operator|&
name|BSF_WEAK
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_WEAK
argument_list|,
name|STT_OBJECT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|syms
index|[
name|idx
index|]
operator|->
name|flags
operator|&
name|BSF_LOCAL
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_OBJECT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|syms
index|[
name|idx
index|]
operator|->
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_OBJECT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|syms
index|[
name|idx
index|]
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|syms
index|[
name|idx
index|]
operator|->
name|flags
operator|&
name|BSF_FILE
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_FILE
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|syms
index|[
name|idx
index|]
operator|->
name|section
condition|)
name|sym
operator|.
name|st_shndx
operator|=
name|elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|syms
index|[
name|idx
index|]
operator|->
name|section
operator|->
name|output_section
argument_list|)
expr_stmt|;
else|else
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|elf_swap_symbol_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
name|outbound_syms
operator|+
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|{
comment|/* fill in 0th symbol */
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|elf_swap_symbol_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
name|outbound_syms
argument_list|)
expr_stmt|;
block|}
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|void
operator|*
operator|)
name|outbound_syms
expr_stmt|;
name|symstrtab_hdr
operator|->
name|contents
operator|=
operator|(
name|void
operator|*
operator|)
name|stt
operator|->
name|tab
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_size
operator|=
name|stt
operator|->
name|length
expr_stmt|;
block|}
comment|/* put the strtab out too... */
block|{
name|Elf_Internal_Shdr
modifier|*
name|this_hdr
decl_stmt|;
name|int
name|this_section
decl_stmt|;
name|this_section
operator|=
name|i_ehdrp
operator|->
name|e_shnum
operator|++
expr_stmt|;
name|i_ehdrp
operator|->
name|e_shstrndx
operator|=
name|this_section
expr_stmt|;
name|this_hdr
operator|=
operator|&
name|i_shdrp
index|[
name|this_section
index|]
expr_stmt|;
name|this_hdr
operator|->
name|sh_name
operator|=
name|bfd_add_to_strtab
argument_list|(
name|abfd
argument_list|,
name|shstrtab
argument_list|,
literal|".shstrtab"
argument_list|)
expr_stmt|;
name|this_hdr
operator|->
name|sh_size
operator|=
name|shstrtab
operator|->
name|length
expr_stmt|;
name|this_hdr
operator|->
name|contents
operator|=
operator|(
name|void
operator|*
operator|)
name|shstrtab
operator|->
name|tab
expr_stmt|;
block|}
name|outbase
operator|=
name|i_ehdrp
operator|->
name|e_ehsize
expr_stmt|;
comment|/* swap the header before spitting it out... */
name|elf_swap_ehdr_out
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
argument_list|,
operator|&
name|x_ehdr
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_ehdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|outbase
operator|+=
name|i_ehdrp
operator|->
name|e_shentsize
operator|*
name|i_ehdrp
operator|->
name|e_shnum
expr_stmt|;
comment|/* now we fix up the offsets... */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|count
operator|++
control|)
block|{
name|i_shdrp
index|[
name|count
index|]
operator|.
name|sh_offset
operator|=
name|outbase
expr_stmt|;
name|outbase
operator|+=
name|i_shdrp
index|[
name|count
index|]
operator|.
name|sh_size
expr_stmt|;
block|}
comment|/* at this point we've concocted all the ELF sections... */
name|x_shdrp
operator|=
operator|(
name|Elf_External_Shdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|x_shdrp
argument_list|)
operator|*
operator|(
name|i_ehdrp
operator|->
name|e_shnum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x_shdrp
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|count
operator|++
control|)
block|{
name|elf_swap_shdr_out
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
operator|+
name|count
argument_list|,
name|x_shdrp
operator|+
name|count
argument_list|)
expr_stmt|;
block|}
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|x_shdrp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|x_shdrp
argument_list|)
argument_list|,
name|i_ehdrp
operator|->
name|e_shnum
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
comment|/* need to dump the string table too... */
comment|/* after writing the headers, we need to write the sections too... */
name|nsect
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|i_shdrp
index|[
name|count
index|]
operator|.
name|contents
condition|)
block|{
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
index|[
name|count
index|]
operator|.
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|i_shdrp
index|[
name|count
index|]
operator|.
name|contents
argument_list|,
name|i_shdrp
index|[
name|count
index|]
operator|.
name|sh_size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* sample use of bfd:    * bfd_seek (abfd, (file_ptr) 0, SEEK_SET);    * bfd_write ((PTR)&exec_bytes, 1, EXEC_BYTES_SIZE, abfd);    * if (bfd_seek(abfd, scn_base, SEEK_SET) != 0)    * return false;    * old = bfd_tell(abfd);    */
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Given an index of a section, retrieve a pointer to it.  Note    that for our purposes, sections are indexed by {1, 2, ...} with    0 being an illegal index. */
end_comment

begin_comment
comment|/* In the original, each ELF section went into exactly one BFD    section. This doesn't really make sense, so we need a real mapping.    The mapping has to hide in the Elf_Internal_Shdr since asection    doesn't have anything like a tdata field... */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sec
modifier|*
name|DEFUN
argument_list|(
name|section_from_elf_index
argument_list|,
operator|(
name|abfd
operator|,
name|index
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|int
name|index
argument_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
name|i_shdrp
operator|+
name|index
decl_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
comment|/* ELF sections that map to BFD sections */
case|case
name|SHT_PROGBITS
case|:
case|case
name|SHT_NOBITS
case|:
if|if
condition|(
operator|!
name|hdr
operator|->
name|rawdata
condition|)
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|sec
operator|*
operator|)
name|hdr
operator|->
name|rawdata
return|;
break|break;
default|default:
return|return
operator|(
expr|struct
name|sec
operator|*
operator|)
operator|&
name|bfd_abs_section
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* given a section, search the header to find them... */
end_comment

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|elf_section_from_bfd_section
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|sec
operator|*
name|asect
argument_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|index
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|int
name|maxindex
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|maxindex
condition|;
name|index
operator|++
control|)
block|{
name|hdr
operator|=
operator|&
name|i_shdrp
index|[
name|index
index|]
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
comment|/* ELF sections that map to BFD sections */
case|case
name|SHT_PROGBITS
case|:
case|case
name|SHT_NOBITS
case|:
if|if
condition|(
name|hdr
operator|->
name|rawdata
condition|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|sec
operator|*
operator|)
operator|(
name|hdr
operator|->
name|rawdata
operator|)
operator|)
operator|==
name|asect
condition|)
return|return
name|index
return|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|elf_slurp_symbol_table
argument_list|,
operator|(
name|abfd
operator|,
name|symptrs
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
operator|*
name|symptrs
argument_list|)
comment|/* Buffer for generated bfd symbols */
block|{
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
name|i_shdrp
operator|+
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|symcount
decl_stmt|;
comment|/* Number of external ELF symbols */
name|int
name|i
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
comment|/* Pointer to current bfd symbol */
name|asymbol
modifier|*
name|symbase
decl_stmt|;
comment|/* Buffer for generated bfd symbols */
name|Elf_Internal_Sym
name|i_sym
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|x_symp
decl_stmt|;
comment|/* this is only valid because there is only one symtab... */
comment|/* FIXME:  This is incorrect, there may also be a dynamic symbol      table which is a subset of the full symbol table.  We either need      to be prepared to read both (and merge them) or ensure that we      only read the full symbol table.  Currently we only get called to      read the full symbol table.  -fnf */
if|if
condition|(
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* Read each raw ELF symbol, converting from external ELF form to      internal ELF form, and then using the information to create a      canonical bfd symbol table entry.       Note that we allocate the initial bfd canonical symbol buffer      based on a one-to-one mapping of the ELF symbols to canonical      symbols.  We actually use all the ELF symbols, so there will be no      space left over at the end.  When we have all the symbols, we      build the caller's pointer vector. */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|symbase
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbase
expr_stmt|;
comment|/* Temporarily allocate room for the raw ELF symbols.  */
name|x_symp
operator|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|malloc
argument_list|(
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|x_symp
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|,
name|symcount
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|x_symp
argument_list|)
expr_stmt|;
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* Skip first symbol, which is a null dummy.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|symcount
condition|;
name|i
operator|++
control|)
block|{
name|elf_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|x_symp
operator|+
name|i
argument_list|,
operator|&
name|i_sym
argument_list|)
expr_stmt|;
name|sym
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|i_sym
operator|.
name|st_name
operator|>
literal|0
condition|)
name|sym
operator|->
name|name
operator|=
name|elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|i_sym
operator|.
name|st_name
argument_list|)
expr_stmt|;
else|else
name|sym
operator|->
name|name
operator|=
literal|"unnamed"
expr_stmt|;
comment|/* perhaps should include the number? */
name|sym
operator|->
name|value
operator|=
name|i_sym
operator|.
name|st_value
expr_stmt|;
comment|/* FIXME -- this is almost certainly bogus.  It's from Pace Willisson's hasty Solaris support, to pass the sizes of object files or functions down into GDB via the back door, to circumvent some other kludge in how Sun hacked stabs.   -- gnu@cygnus.com  */
name|sym
operator|->
name|udata
operator|=
operator|(
name|PTR
operator|)
name|i_sym
operator|.
name|st_size
expr_stmt|;
comment|/* FIXME -- end of bogosity.  */
if|if
condition|(
name|i_sym
operator|.
name|st_shndx
operator|>
literal|0
operator|&&
name|i_sym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERV
condition|)
block|{
name|sym
operator|->
name|section
operator|=
name|section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|i_sym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i_sym
operator|.
name|st_shndx
operator|==
name|SHN_ABS
condition|)
block|{
name|sym
operator|->
name|section
operator|=
operator|&
name|bfd_abs_section
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i_sym
operator|.
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
block|{
name|sym
operator|->
name|section
operator|=
operator|&
name|bfd_com_section
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i_sym
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
block|{
name|sym
operator|->
name|section
operator|=
operator|&
name|bfd_und_section
expr_stmt|;
block|}
else|else
name|sym
operator|->
name|section
operator|=
operator|&
name|bfd_abs_section
expr_stmt|;
switch|switch
condition|(
name|ELF_ST_BIND
argument_list|(
name|i_sym
operator|.
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STB_LOCAL
case|:
name|sym
operator|->
name|flags
operator||=
name|BSF_LOCAL
expr_stmt|;
break|break;
case|case
name|STB_GLOBAL
case|:
name|sym
operator|->
name|flags
operator||=
operator|(
name|BSF_GLOBAL
operator||
name|BSF_EXPORT
operator|)
expr_stmt|;
break|break;
case|case
name|STB_WEAK
case|:
name|sym
operator|->
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ELF_ST_TYPE
argument_list|(
name|i_sym
operator|.
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STT_SECTION
case|:
name|sym
operator|->
name|flags
operator||=
name|BSF_SECTION_SYM
operator||
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|STT_FILE
case|:
name|sym
operator|->
name|flags
operator||=
name|BSF_FILE
operator||
name|BSF_DEBUGGING
expr_stmt|;
break|break;
block|}
name|sym
operator|++
expr_stmt|;
block|}
comment|/* We rely on the zalloc to clear out the final symbol entry.  */
comment|/* We're now done with the raw symbols.  */
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|x_symp
argument_list|)
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|symcount
operator|=
name|sym
operator|-
name|symbase
expr_stmt|;
comment|/* Fill in the user's symbol pointer vector if needed.  */
if|if
condition|(
name|symptrs
condition|)
block|{
name|sym
operator|=
name|symbase
expr_stmt|;
while|while
condition|(
name|symcount
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|symptrs
operator|++
operator|=
name|sym
operator|++
expr_stmt|;
block|}
operator|*
name|symptrs
operator|=
literal|0
expr_stmt|;
comment|/* Final null pointer */
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return the number of bytes required to hold the symtab vector.     Note that we base it on the count plus 1, since we will null terminate    the vector allocated based on this size.  However, the ELF symbol table    always has a dummy entry as symbol #0, so it ends up even.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|elf_get_symtab_upper_bound
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|unsigned
name|int
name|symcount
decl_stmt|;
name|unsigned
name|int
name|symtab_size
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
name|i_shdrp
operator|+
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|symtab_size
operator|=
operator|(
name|symcount
operator|-
literal|1
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|symtab_size
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* 	This function return the number of bytes required to store the 	relocation information associated with section<<sect>> 	attached to bfd<<abfd>>  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|elf_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
block|{
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
condition|)
block|{
comment|/* either rel or rela */
return|return
name|asect
operator|->
name|_raw_size
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FIXME!!! sparc howto should go into elf-32-sparc.c */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_enum
enum|enum
name|reloc_type
block|{
name|R_SPARC_NONE
init|=
literal|0
block|,
name|R_SPARC_8
block|,
name|R_SPARC_16
block|,
name|R_SPARC_32
block|,
name|R_SPARC_DISP8
block|,
name|R_SPARC_DISP16
block|,
name|R_SPARC_DISP32
block|,
name|R_SPARC_WDISP30
block|,
name|R_SPARC_WDISP22
block|,
name|R_SPARC_HI22
block|,
name|R_SPARC_22
block|,
name|R_SPARC_13
block|,
name|R_SPARC_LO10
block|,
name|R_SPARC_GOT10
block|,
name|R_SPARC_GOT13
block|,
name|R_SPARC_GOT22
block|,
name|R_SPARC_PC10
block|,
name|R_SPARC_PC22
block|,
name|R_SPARC_WPLT30
block|,
name|R_SPARC_COPY
block|,
name|R_SPARC_GLOB_DAT
block|,
name|R_SPARC_JMP_SLOT
block|,
name|R_SPARC_RELATIVE
block|,
name|R_SPARC_UA32
block|,     }
enum|;
end_enum

begin_define
define|#
directive|define
name|RELOC_TYPE_NAMES
define|\
value|"R_SPARC_NONE",		\     "R_SPARC_8",	"R_SPARC_16",		"R_SPARC_32",		\     "R_SPARC_DISP8",	"R_SPARC_DISP16",	"R_SPARC_DISP32",	\     "R_SPARC_WDISP30",	"R_SPARC_WDISP22",	\     "R_SPARC_HI22",	"R_SPARC_22",		\     "R_SPARC_13",	"R_SPARC_LO10",		\     "R_SPARC_GOT10",	"R_SPARC_GOT13",	"R_SPARC_GOT22",	\     "R_SPARC_PC10",	"R_SPARC_PC22",		\     "R_SPARC_WPLT30",		\     "R_SPARC_COPY",		\     "R_SPARC_GLOB_DAT",	"R_SPARC_JMP_SLOT",	\     "R_SPARC_RELATIVE",		\     "R_SPARC_UA32"
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_SPARC_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_NONE"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_8"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_DISP8"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_DISP16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_DISP32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00ffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WDISP30
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_WDISP30"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x3fffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WDISP22
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_WDISP22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_HI22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_HI22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_22
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_13
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|13
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_13"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_LO10
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_LO10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GOT10
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_GOT10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GOT13
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|13
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_GOT13"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GOT22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_GOT22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC10
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_PC10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC22
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_PC22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WPLT30
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_WPLT30"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_COPY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_COPY"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_GLOB_DAT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_JMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_JMP_SLOT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_RELATIVE"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_UA32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"R_SPARC_UA32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_info_to_howto
argument_list|,
operator|(
name|abfd
operator|,
name|cache_ptr
operator|,
name|dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|arelent
operator|*
name|cache_ptr
name|AND
name|Elf_Internal_Rela
operator|*
name|dst
argument_list|)
block|{
comment|/* FIXME!!! just doing sparc for now... */
ifdef|#
directive|ifdef
name|sparc
name|BFD_ASSERT
argument_list|(
name|ELF_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|<
literal|24
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|ELF_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elf_info_to_howto not implemented\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|elf_slurp_reloca_table
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|,
name|symbols
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|asect
name|AND
name|asymbol
operator|*
operator|*
name|symbols
argument_list|)
block|{
name|Elf_External_Rela
modifier|*
name|native_relocs
decl_stmt|;
name|arelent
modifier|*
name|reloc_cache
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
return|return
name|true
return|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|native_relocs
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|native_relocs
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|,
name|asect
operator|->
name|reloc_count
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|reloc_cache
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|asect
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc_cache
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|asect
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|RELOC_PROCESSING
comment|/* sparc, 68k, 88k, 860 use rela only. */
comment|/* 386 and we32000 use rel only... fix it for them later. */
name|Elf_Internal_Rela
name|dst
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|src
decl_stmt|;
name|cache_ptr
operator|=
name|reloc_cache
operator|+
name|idx
expr_stmt|;
name|src
operator|=
name|native_relocs
operator|+
name|idx
expr_stmt|;
name|elf_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
name|src
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|RELOC_PROCESSING
argument_list|(
name|cache_ptr
argument_list|,
operator|&
name|dst
argument_list|,
name|symbols
argument_list|,
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
else|#
directive|else
name|Elf_Internal_Rela
name|dst
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|src
decl_stmt|;
name|cache_ptr
operator|=
name|reloc_cache
operator|+
name|idx
expr_stmt|;
name|src
operator|=
name|native_relocs
operator|+
name|idx
expr_stmt|;
name|elf_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
name|src
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
condition|)
block|{
comment|/* relocatable, so the offset is off of the section */
name|cache_ptr
operator|->
name|address
operator|=
name|dst
operator|.
name|r_offset
operator|+
name|asect
operator|->
name|vma
expr_stmt|;
block|}
else|else
block|{
comment|/* non-relocatable, so the offset a virtual address */
name|cache_ptr
operator|->
name|address
operator|=
name|dst
operator|.
name|r_offset
expr_stmt|;
block|}
comment|/* ELF_R_SYM(dst.r_info) is the symbol table offset... */
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|symbols
operator|+
name|ELF_R_SYM
argument_list|(
name|dst
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|addend
operator|=
name|dst
operator|.
name|r_addend
expr_stmt|;
comment|/* Fill in the cache_ptr->howto field from dst.r_type */
name|elf_info_to_howto
argument_list|(
name|abfd
argument_list|,
name|cache_ptr
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|asect
operator|->
name|relocation
operator|=
name|reloc_cache
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|elf_canonicalize_reloc
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|arelent
modifier|*
name|tblptr
init|=
name|section
operator|->
name|relocation
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* snarfed from coffcode.h */
comment|/* FIXME: this could be reloc... */
name|elf_slurp_reloca_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
if|if
condition|(
operator|!
name|tblptr
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|elf_get_symtab
argument_list|,
operator|(
name|abfd
operator|,
name|alocation
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
operator|*
name|alocation
argument_list|)
block|{
if|if
condition|(
operator|!
name|elf_slurp_symbol_table
argument_list|(
name|abfd
argument_list|,
name|alocation
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|DEFUN
argument_list|(
name|elf_make_empty_symbol
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|elf_symbol_type
modifier|*
name|newsym
decl_stmt|;
name|newsym
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_symbol_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsym
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|newsym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|(
operator|&
name|newsym
operator|->
name|symbol
operator|)
return|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|elf_print_symbol
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|filep
operator|,
name|symbol
operator|,
name|how
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|PTR
name|filep
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|bfd_print_symbol_type
name|how
argument_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"elf %lx %lx"
argument_list|,
name|symbol
operator|->
name|value
argument_list|,
name|symbol
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_nm
case|:
case|case
name|bfd_print_symbol_all
case|:
block|{
name|CONST
name|char
modifier|*
name|section_name
decl_stmt|;
name|section_name
operator|=
name|symbol
operator|->
name|section
condition|?
name|symbol
operator|->
name|section
operator|->
name|name
else|:
literal|"(*none*)"
expr_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s\t%s"
argument_list|,
name|section_name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|alent
modifier|*
name|DEFUN
argument_list|(
name|elf_get_lineno
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|symbol
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|asymbol
operator|*
name|symbol
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elf_get_lineno unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|elf_set_arch_mach
argument_list|,
operator|(
name|abfd
operator|,
name|arch
operator|,
name|machine
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|enum
name|bfd_architecture
name|arch
name|AND
name|unsigned
name|long
name|machine
argument_list|)
block|{
comment|/* Allow any architecture to be supported by the elf backend */
switch|switch
condition|(
name|arch
condition|)
block|{
case|case
name|bfd_arch_unknown
case|:
comment|/* EM_NONE */
case|case
name|bfd_arch_sparc
case|:
comment|/* EM_SPARC */
case|case
name|bfd_arch_i386
case|:
comment|/* EM_386 */
case|case
name|bfd_arch_m68k
case|:
comment|/* EM_68K */
case|case
name|bfd_arch_m88k
case|:
comment|/* EM_88K */
case|case
name|bfd_arch_i860
case|:
comment|/* EM_860 */
case|case
name|bfd_arch_mips
case|:
comment|/* EM_MIPS (MIPS R3000) */
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|elf_find_nearest_line
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|symbols
operator|,
name|offset
operator|,
name|filename_ptr
operator|,
name|functionname_ptr
operator|,
name|line_ptr
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
name|AND
name|asymbol
operator|*
operator|*
name|symbols
name|AND
name|bfd_vma
name|offset
name|AND
name|CONST
name|char
operator|*
operator|*
name|filename_ptr
name|AND
name|CONST
name|char
operator|*
operator|*
name|functionname_ptr
name|AND
name|unsigned
name|int
operator|*
name|line_ptr
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elf_find_nearest_line unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|elf_sizeof_headers
argument_list|,
operator|(
name|abfd
operator|,
name|reloc
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|boolean
name|reloc
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elf_sizeof_headers unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|elf_set_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
argument_list|)
block|{
name|int
name|dest_sect
decl_stmt|;
name|void
modifier|*
name|contents
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
comment|/* set by bfd.c handler? */
block|{
comment|/* do setup calculations (FIXME) */
name|elf_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if(bfd_seek (abfd, (file_ptr)section->filepos + offset, SEEK_SET) == -1)     return false;   if(bfd_write (location, (bfd_size_type)1, count, abfd) != count)     return false;
endif|#
directive|endif
comment|/* we really just need to save the contents away... */
name|dest_sect
operator|=
name|elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dest_sect
condition|)
return|return
name|false
return|;
comment|/* FIXME: allocate in set_section_size, then copy in here... */
name|contents
operator|=
operator|(
name|void
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|contents
argument_list|,
name|location
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|dest_sect
index|]
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This structure contains everything that BFD knows about a target.    It includes things like its byte order, name, what routines to call    to do various operations, etc.  Every BFD points to a target structure    with its "xvec" member.     There are two such structures here:  one for big-endian machines and    one for little-endian machines.   */
end_comment

begin_comment
comment|/* Archives are generic or unimplemented.  */
end_comment

begin_define
define|#
directive|define
name|elf_slurp_armap
value|bfd_false
end_define

begin_define
define|#
directive|define
name|elf_slurp_extended_name_table
value|_bfd_slurp_extended_name_table
end_define

begin_define
define|#
directive|define
name|elf_truncate_arname
value|bfd_dont_truncate_arname
end_define

begin_define
define|#
directive|define
name|elf_openr_next_archived_file
value|bfd_generic_openr_next_archived_file
end_define

begin_define
define|#
directive|define
name|elf_generic_stat_arch_elt
value|bfd_generic_stat_arch_elt
end_define

begin_define
define|#
directive|define
name|elf_write_armap
value|(PROTO (boolean, (*),		\      (bfd *arch, unsigned int elength, struct orl *map, unsigned int orl_count,	\       int stridx))) bfd_false
end_define

begin_comment
comment|/* Ordinary section reading and writing */
end_comment

begin_define
define|#
directive|define
name|elf_new_section_hook
value|_bfd_dummy_new_section_hook
end_define

begin_define
define|#
directive|define
name|elf_get_section_contents
value|bfd_generic_get_section_contents
end_define

begin_comment
comment|/* #define elf_set_section_contents	bfd_generic_set_section_contents */
end_comment

begin_define
define|#
directive|define
name|elf_close_and_cleanup
value|bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|elf_bfd_debug_info_start
value|bfd_void
end_define

begin_define
define|#
directive|define
name|elf_bfd_debug_info_end
value|bfd_void
end_define

begin_define
define|#
directive|define
name|elf_bfd_debug_info_accumulate
value|(PROTO(void,(*),(bfd*, struct sec *))) bfd_void
end_define

begin_define
define|#
directive|define
name|elf_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|elf_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_decl_stmt
name|bfd_target
name|elf_big_vec
init|=
block|{
comment|/* name: identify kind of target */
literal|"elf-big"
block|,
comment|/* flavour: general indication about file */
name|bfd_target_elf_flavour
block|,
comment|/* byteorder_big_p: data is big endian */
name|true
block|,
comment|/* header_byteorder_big_p: header is also big endian */
name|true
block|,
comment|/* object_flags: mask of all file flags */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|DYNAMIC
operator||
name|WP_TEXT
operator|)
block|,
comment|/* section_flags: mask of all section flags */
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
comment|/* leading_symbol_char: is the first char of a user symbol       predictable, and if so what is it */
literal|0
block|,
comment|/* ar_pad_char: pad character for filenames within an archive header      FIXME:  this really has nothing to do with ELF, this is a characteristic      of the archiver and/or os and should be independently tunable */
literal|'/'
block|,
comment|/* ar_max_namelen: maximum number of characters in an archive header      FIXME:  this really has nothing to do with ELF, this is a characteristic      of the archiver and should be independently tunable.  This value is      a WAG (wild a** guess) */
literal|15
block|,
comment|/* align_power_min: minimum alignment restriction for any section      FIXME:  this value may be target machine dependent */
literal|3
block|,
comment|/* Routines to byte-swap various sized integers from the data sections */
name|_do_getb64
block|,
name|_do_putb64
block|,
name|_do_getb32
block|,
name|_do_putb32
block|,
name|_do_getb16
block|,
name|_do_putb16
block|,
comment|/* Routines to byte-swap various sized integers from the file headers */
name|_do_getb64
block|,
name|_do_putb64
block|,
name|_do_getb32
block|,
name|_do_putb32
block|,
name|_do_getb16
block|,
name|_do_putb16
block|,
comment|/* bfd_check_format: check the format of a file being read */
block|{
name|_bfd_dummy_target
block|,
comment|/* unknown format */
name|elf_object_p
block|,
comment|/* assembler/linker output (object file) */
name|bfd_generic_archive_p
block|,
comment|/* an archive */
name|elf_core_file_p
comment|/* a core file */
block|}
block|,
comment|/* bfd_set_format: set the format of a file being written */
block|{
name|bfd_false
block|,
name|elf_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
comment|/* bfd_write_contents: write cached information into a file being written */
block|{
name|bfd_false
block|,
name|elf_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
comment|/* Initialize a jump table with the standard macro.  All names start      with "elf" */
name|JUMP_TABLE
argument_list|(
name|elf
argument_list|)
block|,
comment|/* SWAP_TABLE */
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_target
name|elf_little_vec
init|=
block|{
comment|/* name: identify kind of target */
literal|"elf-little"
block|,
comment|/* flavour: general indication about file */
name|bfd_target_elf_flavour
block|,
comment|/* byteorder_big_p: data is big endian */
name|false
block|,
comment|/* Nope -- this one's little endian */
comment|/* header_byteorder_big_p: header is also big endian */
name|false
block|,
comment|/* Nope -- this one's little endian */
comment|/* object_flags: mask of all file flags */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|DYNAMIC
operator||
name|WP_TEXT
operator|)
block|,
comment|/* section_flags: mask of all section flags */
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
operator|)
block|,
comment|/* leading_symbol_char: is the first char of a user symbol       predictable, and if so what is it */
literal|0
block|,
comment|/* ar_pad_char: pad character for filenames within an archive header      FIXME:  this really has nothing to do with ELF, this is a characteristic      of the archiver and/or os and should be independently tunable */
literal|'/'
block|,
comment|/* ar_max_namelen: maximum number of characters in an archive header      FIXME:  this really has nothing to do with ELF, this is a characteristic      of the archiver and should be independently tunable.  This value is      a WAG (wild a** guess) */
literal|15
block|,
comment|/* align_power_min: minimum alignment restriction for any section      FIXME:  this value may be target machine dependent */
literal|3
block|,
comment|/* Routines to byte-swap various sized integers from the data sections */
name|_do_getl64
block|,
name|_do_putl64
block|,
name|_do_getl32
block|,
name|_do_putl32
block|,
name|_do_getl16
block|,
name|_do_putl16
block|,
comment|/* Routines to byte-swap various sized integers from the file headers */
name|_do_getl64
block|,
name|_do_putl64
block|,
name|_do_getl32
block|,
name|_do_putl32
block|,
name|_do_getl16
block|,
name|_do_putl16
block|,
comment|/* bfd_check_format: check the format of a file being read */
block|{
name|_bfd_dummy_target
block|,
comment|/* unknown format */
name|elf_object_p
block|,
comment|/* assembler/linker output (object file) */
name|bfd_generic_archive_p
block|,
comment|/* an archive */
name|elf_core_file_p
comment|/* a core file */
block|}
block|,
comment|/* bfd_set_format: set the format of a file being written */
block|{
name|bfd_false
block|,
name|elf_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
comment|/* bfd_write_contents: write cached information into a file being written */
block|{
name|bfd_false
block|,
name|elf_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
comment|/* Initialize a jump table with the standard macro.  All names start      with "elf" */
name|JUMP_TABLE
argument_list|(
name|elf
argument_list|)
block|,
comment|/* SWAP_TABLE */
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

