begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for ieee-695 objects.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_define
define|#
directive|define
name|KEEPMINUSPCININST
value|1
end_define

begin_comment
comment|/* IEEE 695 format is a stream of records, which we parse using a simple one-    token (which is one byte in this lexicon) lookahead recursive decent    parser.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"ieee.h"
end_include

begin_include
include|#
directive|include
file|"libieee.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|bfd_xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Functions for writing to ieee files in the strange way that the    standard requires. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_write_byte
argument_list|,
operator|(
name|abfd
operator|,
name|byte
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|bfd_byte
name|byte
argument_list|)
block|{
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|byte
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_write_twobyte
argument_list|,
operator|(
name|abfd
operator|,
name|twobyte
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|int
name|twobyte
argument_list|)
block|{
name|bfd_byte
name|b
index|[
literal|2
index|]
decl_stmt|;
name|b
index|[
literal|1
index|]
operator|=
name|twobyte
operator|&
literal|0xff
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|twobyte
operator|>>
literal|8
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|b
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_write_2bytes
argument_list|,
operator|(
name|abfd
operator|,
name|bytes
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|int
name|bytes
argument_list|)
block|{
name|bfd_byte
name|buffer
index|[
literal|2
index|]
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|bytes
operator|>>
literal|8
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
name|bytes
operator|&
literal|0xff
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_write_int
argument_list|,
operator|(
name|abfd
operator|,
name|value
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|bfd_vma
name|value
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|value
operator|)
operator|<=
literal|127
condition|)
block|{
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|length
decl_stmt|;
comment|/* How many significant bytes ? */
comment|/* FIXME FOR LONGER INTS */
if|if
condition|(
name|value
operator|&
literal|0xff000000
condition|)
block|{
name|length
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|&
literal|0x00ff0000
condition|)
block|{
name|length
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|&
literal|0x0000ff00
condition|)
block|{
name|length
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|length
operator|=
literal|1
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
operator|(
name|int
operator|)
name|ieee_number_repeat_start_enum
operator|+
name|length
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|4
case|:
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|value
operator|>>
literal|24
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|value
operator|>>
literal|16
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|value
operator|>>
literal|8
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_write_id
argument_list|,
operator|(
name|abfd
operator|,
name|id
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|CONST
name|char
operator|*
name|id
argument_list|)
block|{
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>=
literal|0
operator|&&
name|length
operator|<=
literal|127
condition|)
block|{
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|<
literal|255
condition|)
block|{
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_extension_length_1_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|<
literal|65535
condition|)
block|{
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_extension_length_2_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|length
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|length
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|id
argument_list|,
literal|1
argument_list|,
name|length
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*************************************************************************** Functions for reading from ieee files in the strange way that the standard requires: */
end_comment

begin_define
define|#
directive|define
name|this_byte
parameter_list|(
name|ieee
parameter_list|)
value|*((ieee)->input_p)
end_define

begin_define
define|#
directive|define
name|next_byte
parameter_list|(
name|ieee
parameter_list|)
value|((ieee)->input_p++)
end_define

begin_define
define|#
directive|define
name|this_byte_and_next
parameter_list|(
name|ieee
parameter_list|)
value|(*((ieee)->input_p++))
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|DEFUN
argument_list|(
name|read_2bytes
argument_list|,
operator|(
name|ieee
operator|)
argument_list|,
name|common_header_type
operator|*
name|ieee
argument_list|)
block|{
name|unsigned
name|char
name|c1
init|=
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|c2
init|=
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
decl_stmt|;
return|return
operator|(
name|c1
operator|<<
literal|8
operator|)
operator||
name|c2
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|bfd_get_string
argument_list|,
operator|(
name|ieee
operator|,
name|string
operator|,
name|length
operator|)
argument_list|,
name|common_header_type
operator|*
name|ieee
name|AND
name|char
operator|*
name|string
name|AND
name|size_t
name|length
argument_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|string
index|[
name|i
index|]
operator|=
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|DEFUN
argument_list|(
name|read_id
argument_list|,
operator|(
name|ieee
operator|)
argument_list|,
name|common_header_type
operator|*
name|ieee
argument_list|)
block|{
name|size_t
name|length
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|length
operator|=
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|0x00
operator|&&
name|length
operator|<=
literal|0x7f
condition|)
block|{
comment|/* Simple string of length 0 to 127 */
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|0xde
condition|)
block|{
comment|/* Length is next byte, allowing 0..255 */
name|length
operator|=
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|0xdf
condition|)
block|{
comment|/* Length is next two bytes, allowing 0..65535 */
name|length
operator|=
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|length
operator|*
literal|256
operator|)
operator|+
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
block|}
comment|/* Buy memory and read string */
name|string
operator|=
name|bfd_alloc
argument_list|(
name|ieee
operator|->
name|abfd
argument_list|,
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_get_string
argument_list|(
name|ieee
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|string
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|string
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_write_expression
argument_list|,
operator|(
name|abfd
operator|,
name|value
operator|,
name|symbol
operator|,
name|pcrel
operator|,
name|index
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|bfd_vma
name|value
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|boolean
name|pcrel
name|AND
name|unsigned
name|int
name|index
argument_list|)
block|{
name|unsigned
name|int
name|term_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|term_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_com_section
operator|||
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
comment|/* Def of a common symbol */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_X_enum
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
expr_stmt|;
name|term_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|section
operator|!=
operator|&
name|bfd_abs_section
condition|)
block|{
comment|/* Ref to defined symbol - */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_R_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
expr_stmt|;
name|term_count
operator|++
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_GLOBAL
condition|)
block|{
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_I_enum
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
expr_stmt|;
name|term_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
operator|(
name|BSF_LOCAL
operator||
name|BSF_SECTION_SYM
operator|)
condition|)
block|{
comment|/* This is a reference to a defined local symbol,  	 We can easily do a local as a section+offset */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_R_enum
argument_list|)
expr_stmt|;
comment|/* or L */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
expr_stmt|;
name|term_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pcrel
condition|)
block|{
comment|/* subtract the pc from here by asking for PC of this section*/
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_P_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_function_minus_enum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|term_count
operator|==
literal|1
condition|)
block|{
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|term_count
operator|>
literal|1
condition|)
block|{
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_function_plus_enum
argument_list|)
expr_stmt|;
name|term_count
operator|--
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/* writes any integer into the buffer supplied and always takes 5 bytes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_write_int5
argument_list|,
operator|(
name|buffer
operator|,
name|value
operator|)
argument_list|,
name|bfd_byte
operator|*
name|buffer
name|AND
name|bfd_vma
name|value
argument_list|)
block|{
name|buffer
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|ieee_number_repeat_4_enum
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|2
index|]
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|3
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|buffer
index|[
literal|4
index|]
operator|=
operator|(
name|value
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_write_int5_out
argument_list|,
operator|(
name|abfd
operator|,
name|value
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|bfd_vma
name|value
argument_list|)
block|{
name|bfd_byte
name|b
index|[
literal|5
index|]
decl_stmt|;
name|ieee_write_int5
argument_list|(
name|b
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|b
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|parse_int
argument_list|,
operator|(
name|ieee
operator|,
name|value_ptr
operator|)
argument_list|,
name|common_header_type
operator|*
name|ieee
name|AND
name|bfd_vma
operator|*
name|value_ptr
argument_list|)
block|{
name|int
name|value
init|=
name|this_byte
argument_list|(
name|ieee
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0
operator|&&
name|value
operator|<=
literal|127
condition|)
block|{
operator|*
name|value_ptr
operator|=
name|value
expr_stmt|;
name|next_byte
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|>=
literal|0x80
operator|&&
name|value
operator|<=
literal|0x88
condition|)
block|{
name|unsigned
name|int
name|count
init|=
name|value
operator|&
literal|0xf
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|next_byte
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|result
operator|=
operator|(
name|result
operator|<<
literal|8
operator|)
operator||
name|this_byte_and_next
argument_list|(
name|ieee
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
operator|*
name|value_ptr
operator|=
name|result
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|parse_i
argument_list|,
operator|(
name|ieee
operator|,
name|ok
operator|)
argument_list|,
name|common_header_type
operator|*
name|ieee
name|AND
name|boolean
operator|*
name|ok
argument_list|)
block|{
name|bfd_vma
name|x
decl_stmt|;
operator|*
name|ok
operator|=
name|parse_int
argument_list|(
name|ieee
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|DEFUN
argument_list|(
name|must_parse_int
argument_list|,
operator|(
name|ieee
operator|)
argument_list|,
name|common_header_type
operator|*
name|ieee
argument_list|)
block|{
name|bfd_vma
name|result
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|parse_int
argument_list|(
name|ieee
argument_list|,
operator|&
name|result
argument_list|)
operator|==
name|true
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|ieee_symbol_index_type
name|symbol
decl_stmt|;
block|}
name|ieee_value_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|abs32_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"abs32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|abs16_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"abs16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|abs8_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"abs8"
argument_list|,
name|true
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|rel32_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"rel32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|rel16_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"rel16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|rel8_howto
init|=
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"rel8"
argument_list|,
name|true
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee_symbol_index_type
name|NOSYMBOL
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|parse_expression
argument_list|,
operator|(
name|ieee
operator|,
name|value
operator|,
name|symbol
operator|,
name|pcrel
operator|,
name|extra
operator|,
name|section
operator|)
argument_list|,
name|ieee_data_type
operator|*
name|ieee
name|AND
name|bfd_vma
operator|*
name|value
name|AND
name|ieee_symbol_index_type
operator|*
name|symbol
name|AND
name|boolean
operator|*
name|pcrel
name|AND
name|unsigned
name|int
operator|*
name|extra
name|AND
name|asection
operator|*
operator|*
name|section
argument_list|)
block|{
define|#
directive|define
name|POS
value|sp[1]
define|#
directive|define
name|TOS
value|sp[0]
define|#
directive|define
name|NOS
value|sp[-1]
define|#
directive|define
name|INC
value|sp++;
define|#
directive|define
name|DEC
value|sp--;
name|boolean
name|loop
init|=
name|true
decl_stmt|;
name|ieee_value_type
name|stack
index|[
literal|10
index|]
decl_stmt|;
comment|/* The stack pointer always points to the next unused location */
define|#
directive|define
name|PUSH
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|TOS.symbol=x;TOS.section=y;TOS.value=z;INC;
define|#
directive|define
name|POP
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|DEC;x=TOS.symbol;y=TOS.section;z=TOS.value;
name|ieee_value_type
modifier|*
name|sp
init|=
name|stack
decl_stmt|;
while|while
condition|(
name|loop
condition|)
block|{
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_variable_P_enum
case|:
comment|/* P variable, current program counter for section n */
block|{
name|int
name|section_n
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pcrel
operator|=
name|true
expr_stmt|;
name|section_n
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|NOSYMBOL
argument_list|,
operator|&
name|bfd_abs_section
argument_list|,
name|TOS
operator|.
name|value
operator|=
name|ieee
operator|->
name|section_table
index|[
name|section_n
index|]
operator|->
name|vma
operator|+
name|ieee_per_section
argument_list|(
name|ieee
operator|->
name|section_table
index|[
name|section_n
index|]
argument_list|)
operator|->
name|pc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ieee_variable_L_enum
case|:
comment|/* L variable  address of section N */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|NOSYMBOL
argument_list|,
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_variable_R_enum
case|:
comment|/* R variable, logical address of section module */
comment|/* FIXME, this should be different to L */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|NOSYMBOL
argument_list|,
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_variable_S_enum
case|:
comment|/* S variable, size in MAUS of section module */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|NOSYMBOL
argument_list|,
literal|0
argument_list|,
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_variable_I_enum
case|:
case|case
name|ieee_variable_X_enum
case|:
comment|/* Push the address of external variable n */
block|{
name|ieee_symbol_index_type
name|sy
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|sy
operator|.
name|index
operator|=
call|(
name|int
call|)
argument_list|(
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|sy
operator|.
name|letter
operator|=
literal|'X'
expr_stmt|;
name|PUSH
argument_list|(
name|sy
argument_list|,
operator|&
name|bfd_und_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ieee_function_minus_enum
case|:
block|{
name|bfd_vma
name|value1
decl_stmt|,
name|value2
decl_stmt|;
name|asection
modifier|*
name|section1
decl_stmt|,
modifier|*
name|section_dummy
decl_stmt|;
name|ieee_symbol_index_type
name|sy
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|sy
argument_list|,
name|section1
argument_list|,
name|value1
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|sy
argument_list|,
name|section_dummy
argument_list|,
name|value2
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|sy
argument_list|,
name|section1
condition|?
name|section1
else|:
name|section_dummy
argument_list|,
name|value1
operator|-
name|value2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ieee_function_plus_enum
case|:
block|{
name|bfd_vma
name|value1
decl_stmt|,
name|value2
decl_stmt|;
name|asection
modifier|*
name|section1
decl_stmt|;
name|asection
modifier|*
name|section2
decl_stmt|;
name|ieee_symbol_index_type
name|sy1
decl_stmt|;
name|ieee_symbol_index_type
name|sy2
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|sy1
argument_list|,
name|section1
argument_list|,
name|value1
argument_list|)
expr_stmt|;
name|POP
argument_list|(
name|sy2
argument_list|,
name|section2
argument_list|,
name|value2
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|sy1
operator|.
name|letter
condition|?
name|sy1
else|:
name|sy2
argument_list|,
name|section1
operator|!=
operator|&
name|bfd_abs_section
condition|?
name|section1
else|:
name|section2
argument_list|,
name|value1
operator|+
name|value2
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|bfd_vma
name|va
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|<
operator|(
name|int
operator|)
name|ieee_variable_A_enum
operator|||
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|>
operator|(
name|int
operator|)
name|ieee_variable_Z_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|va
argument_list|)
condition|)
block|{
name|PUSH
argument_list|(
name|NOSYMBOL
argument_list|,
operator|&
name|bfd_abs_section
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  		  Thats all that we can understand. As far as I can see 		  there is a bug in the Microtec IEEE output which I'm 		  using to scan, whereby the comma operator is ommited 		  sometimes in an expression, giving expressions with too 		  many terms. We can tell if that's the case by ensuring 		  that sp == stack here. If not, then we've pushed 		  something too far, so we keep adding 		  */
while|while
condition|(
name|sp
operator|!=
name|stack
operator|+
literal|1
condition|)
block|{
name|asection
modifier|*
name|section1
decl_stmt|;
name|ieee_symbol_index_type
name|sy1
decl_stmt|;
name|POP
argument_list|(
name|sy1
argument_list|,
name|section1
argument_list|,
operator|*
name|extra
argument_list|)
expr_stmt|;
block|}
block|{
name|asection
modifier|*
name|dummy
decl_stmt|;
name|POP
argument_list|(
operator|*
name|symbol
argument_list|,
name|dummy
argument_list|,
operator|*
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
condition|)
operator|*
name|section
operator|=
name|dummy
expr_stmt|;
block|}
name|loop
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|ieee_seek
parameter_list|(
name|abfd
parameter_list|,
name|offset
parameter_list|)
define|\
value|IEEE_DATA(abfd)->h.input_p = IEEE_DATA(abfd)->h.first_byte + offset
end_define

begin_define
define|#
directive|define
name|ieee_pos
parameter_list|(
name|abfd
parameter_list|)
value|IEEE_DATA(abfd)->h.input_p -IEEE_DATA(abfd)->h.first_byte
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|last_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee_symbol_type
modifier|*
name|DEFUN
argument_list|(
name|get_symbol
argument_list|,
operator|(
name|abfd
operator|,
name|ieee
operator|,
name|last_symbol
operator|,
name|symbol_count
operator|,
name|pptr
operator|,
name|max_index
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|ieee_data_type
operator|*
name|ieee
name|AND
name|ieee_symbol_type
operator|*
name|last_symbol
name|AND
name|unsigned
name|int
operator|*
name|symbol_count
name|AND
name|ieee_symbol_type
operator|*
operator|*
operator|*
name|pptr
name|AND
name|unsigned
name|int
operator|*
name|max_index
argument_list|)
block|{
comment|/* Need a new symbol */
name|unsigned
name|int
name|new_index
init|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_index
operator|!=
name|last_index
condition|)
block|{
name|ieee_symbol_type
modifier|*
name|new_symbol
init|=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ieee_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
name|new_symbol
operator|->
name|index
operator|=
name|new_index
expr_stmt|;
name|last_index
operator|=
name|new_index
expr_stmt|;
operator|(
operator|*
name|symbol_count
operator|)
operator|++
expr_stmt|;
operator|*
operator|*
name|pptr
operator|=
name|new_symbol
expr_stmt|;
operator|*
name|pptr
operator|=
operator|&
name|new_symbol
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|new_index
operator|>
operator|*
name|max_index
condition|)
block|{
operator|*
name|max_index
operator|=
name|new_index
expr_stmt|;
block|}
return|return
name|new_symbol
return|;
block|}
return|return
name|last_symbol
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_slurp_external_symbols
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|file_ptr
name|offset
init|=
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|external_part
decl_stmt|;
name|ieee_symbol_type
modifier|*
modifier|*
name|prev_symbols_ptr
init|=
operator|&
name|ieee
operator|->
name|external_symbols
decl_stmt|;
name|ieee_symbol_type
modifier|*
modifier|*
name|prev_reference_ptr
init|=
operator|&
name|ieee
operator|->
name|external_reference
decl_stmt|;
name|ieee_symbol_type
modifier|*
name|symbol
init|=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|NULL
decl_stmt|;
name|unsigned
name|int
name|symbol_count
init|=
literal|0
decl_stmt|;
name|boolean
name|loop
init|=
name|true
decl_stmt|;
name|last_index
operator|=
literal|0xffffff
expr_stmt|;
name|ieee
operator|->
name|symbol_table_full
operator|=
name|true
expr_stmt|;
name|ieee_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
while|while
condition|(
name|loop
condition|)
block|{
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_nn_record
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|get_symbol
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|,
name|symbol
argument_list|,
operator|&
name|symbol_count
argument_list|,
operator|&
name|prev_symbols_ptr
argument_list|,
operator|&
name|ieee
operator|->
name|external_symbol_max_index
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|name
operator|=
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|udata
operator|=
operator|(
name|PTR
operator|)
name|NULL
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
break|break;
case|case
name|ieee_external_symbol_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|get_symbol
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|,
name|symbol
argument_list|,
operator|&
name|symbol_count
argument_list|,
operator|&
name|prev_symbols_ptr
argument_list|,
operator|&
name|ieee
operator|->
name|external_symbol_max_index
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|symbol
operator|->
name|index
operator|>=
name|ieee
operator|->
name|external_symbol_min_index
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|name
operator|=
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|udata
operator|=
operator|(
name|PTR
operator|)
name|NULL
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
break|break;
case|case
name|ieee_attribute_record_enum
operator|>>
literal|8
case|:
block|{
name|unsigned
name|int
name|symbol_name_index
decl_stmt|;
name|unsigned
name|int
name|symbol_type_index
decl_stmt|;
name|unsigned
name|int
name|symbol_attribute_def
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Skip prefix */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol_name_index
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol_type_index
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol_attribute_def
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|symbol_attribute_def
condition|)
block|{
case|case
literal|63
case|:
comment|/* Module misc; followed by two fields which describe the 	       current module block. The first fired is the type id 	       number, the second is the number of asn records 	       associated with the directive */
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|ieee_value_record_enum
operator|>>
literal|8
case|:
block|{
name|unsigned
name|int
name|symbol_name_index
decl_stmt|;
name|ieee_symbol_index_type
name|symbol_ignore
decl_stmt|;
name|boolean
name|pcrel_ignore
decl_stmt|;
name|unsigned
name|int
name|extra
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol_name_index
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|parse_expression
argument_list|(
name|ieee
argument_list|,
operator|&
name|symbol
operator|->
name|symbol
operator|.
name|value
argument_list|,
operator|&
name|symbol_ignore
argument_list|,
operator|&
name|pcrel_ignore
argument_list|,
operator|&
name|extra
argument_list|,
operator|&
name|symbol
operator|->
name|symbol
operator|.
name|section
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_GLOBAL
operator||
name|BSF_EXPORT
expr_stmt|;
block|}
break|break;
case|case
name|ieee_weak_external_reference_enum
case|:
block|{
name|bfd_vma
name|size
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Throw away the external reference index */
operator|(
name|void
operator|)
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Fetch the default size if not resolved */
name|size
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Fetch the defautlt value if available */
if|if
condition|(
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|value
argument_list|)
operator|==
name|false
condition|)
block|{
name|value
operator|=
literal|0
expr_stmt|;
block|}
comment|/* This turns into a common */
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|=
operator|&
name|bfd_com_section
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|value
operator|=
name|size
expr_stmt|;
block|}
break|break;
case|case
name|ieee_external_reference_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|get_symbol
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|,
name|symbol
argument_list|,
operator|&
name|symbol_count
argument_list|,
operator|&
name|prev_reference_ptr
argument_list|,
operator|&
name|ieee
operator|->
name|external_reference_max_index
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|name
operator|=
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|udata
operator|=
operator|(
name|PTR
operator|)
name|NULL
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|=
operator|&
name|bfd_und_section
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|bfd_vma
operator|)
literal|0
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|symbol
operator|->
name|index
operator|>=
name|ieee
operator|->
name|external_reference_min_index
argument_list|)
expr_stmt|;
break|break;
default|default:
name|loop
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ieee
operator|->
name|external_symbol_max_index
operator|!=
literal|0
condition|)
block|{
name|ieee
operator|->
name|external_symbol_count
operator|=
name|ieee
operator|->
name|external_symbol_max_index
operator|-
name|ieee
operator|->
name|external_symbol_min_index
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ieee
operator|->
name|external_symbol_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ieee
operator|->
name|external_reference_max_index
operator|!=
literal|0
condition|)
block|{
name|ieee
operator|->
name|external_reference_count
operator|=
name|ieee
operator|->
name|external_reference_max_index
operator|-
name|ieee
operator|->
name|external_reference_min_index
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ieee
operator|->
name|external_reference_count
operator|=
literal|0
expr_stmt|;
block|}
name|abfd
operator|->
name|symcount
operator|=
name|ieee
operator|->
name|external_reference_count
operator|+
name|ieee
operator|->
name|external_symbol_count
expr_stmt|;
if|if
condition|(
name|symbol_count
operator|!=
name|abfd
operator|->
name|symcount
condition|)
block|{
comment|/* There are gaps in the table -- */
name|ieee
operator|->
name|symbol_table_full
operator|=
name|false
expr_stmt|;
block|}
operator|*
name|prev_symbols_ptr
operator|=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|prev_reference_ptr
operator|=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_slurp_symbol_table
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
if|if
condition|(
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|read_symbols
operator|==
name|false
condition|)
block|{
name|ieee_slurp_external_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|read_symbols
operator|=
name|true
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|ieee_get_symtab_upper_bound
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|ieee_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|abfd
operator|->
name|symcount
operator|!=
literal|0
operator|)
condition|?
operator|(
name|abfd
operator|->
name|symcount
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|ieee_symbol_type
operator|*
argument_list|)
operator|)
else|:
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  Move from our internal lists to the canon table, and insert in symbol index order */
end_comment

begin_decl_stmt
specifier|extern
name|bfd_target
name|ieee_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|ieee_get_symtab
argument_list|,
operator|(
name|abfd
operator|,
name|location
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
operator|*
name|location
argument_list|)
block|{
name|ieee_symbol_type
modifier|*
name|symp
decl_stmt|;
specifier|static
name|bfd
name|dummy_bfd
decl_stmt|;
specifier|static
name|asymbol
name|empty_symbol
init|=
block|{
operator|&
name|dummy_bfd
block|,
literal|" ieee empty"
block|,
operator|(
name|symvalue
operator|)
literal|0
block|,
name|BSF_DEBUGGING
block|,
operator|&
name|bfd_abs_section
block|}
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|symcount
condition|)
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|dummy_bfd
operator|.
name|xvec
operator|=
operator|&
name|ieee_vec
expr_stmt|;
name|ieee_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee
operator|->
name|symbol_table_full
operator|==
name|false
condition|)
block|{
comment|/* Arrgh - there are gaps in the table, run through and fill them */
comment|/* up with pointers to a null place */
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abfd
operator|->
name|symcount
condition|;
name|i
operator|++
control|)
block|{
name|location
index|[
name|i
index|]
operator|=
operator|&
name|empty_symbol
expr_stmt|;
block|}
block|}
name|ieee
operator|->
name|external_symbol_base_offset
operator|=
operator|-
name|ieee
operator|->
name|external_symbol_min_index
expr_stmt|;
for|for
control|(
name|symp
operator|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_symbols
init|;
name|symp
operator|!=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|NULL
condition|;
name|symp
operator|=
name|symp
operator|->
name|next
control|)
block|{
comment|/* Place into table at correct index locations */
name|location
index|[
name|symp
operator|->
name|index
operator|+
name|ieee
operator|->
name|external_symbol_base_offset
index|]
operator|=
operator|&
name|symp
operator|->
name|symbol
expr_stmt|;
block|}
comment|/* The external refs are indexed in a bit */
name|ieee
operator|->
name|external_reference_base_offset
operator|=
operator|-
name|ieee
operator|->
name|external_reference_min_index
operator|+
name|ieee
operator|->
name|external_symbol_count
expr_stmt|;
for|for
control|(
name|symp
operator|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_reference
init|;
name|symp
operator|!=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|NULL
condition|;
name|symp
operator|=
name|symp
operator|->
name|next
control|)
block|{
name|location
index|[
name|symp
operator|->
name|index
operator|+
name|ieee
operator|->
name|external_reference_base_offset
index|]
operator|=
operator|&
name|symp
operator|->
name|symbol
expr_stmt|;
block|}
block|}
name|location
index|[
name|abfd
operator|->
name|symcount
index|]
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|abfd
operator|->
name|symcount
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|DEFUN
argument_list|(
name|get_section_entry
argument_list|,
operator|(
name|abfd
operator|,
name|ieee
operator|,
name|index
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|ieee_data_type
operator|*
name|ieee
name|AND
name|unsigned
name|int
name|index
argument_list|)
block|{
if|if
condition|(
name|ieee
operator|->
name|section_table
index|[
name|index
index|]
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|asection
modifier|*
name|section
init|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|" tempname"
argument_list|)
decl_stmt|;
name|ieee
operator|->
name|section_table
index|[
name|index
index|]
operator|=
name|section
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
name|section
operator|->
name|target_index
operator|=
name|index
expr_stmt|;
name|ieee
operator|->
name|section_table
index|[
name|index
index|]
operator|=
name|section
expr_stmt|;
block|}
return|return
name|ieee
operator|->
name|section_table
index|[
name|index
index|]
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_slurp_sections
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|file_ptr
name|offset
init|=
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|section_part
decl_stmt|;
name|asection
modifier|*
name|section
init|=
operator|(
name|asection
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
name|section_type
index|[
literal|3
index|]
decl_stmt|;
name|ieee_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_section_type_enum
case|:
block|{
name|unsigned
name|int
name|section_index
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section_index
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Fixme to be nice about a silly number of sections */
name|BFD_ASSERT
argument_list|(
name|section_index
operator|<
name|NSECTIONS
argument_list|)
expr_stmt|;
name|section
operator|=
name|get_section_entry
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|,
name|section_index
argument_list|)
expr_stmt|;
name|section_type
index|[
literal|0
index|]
operator|=
name|this_byte_and_next
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|section_type
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0xC1
case|:
comment|/* Normal attributes for absolute sections	*/
name|section_type
index|[
literal|1
index|]
operator|=
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
switch|switch
condition|(
name|section_type
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0xD3
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section_type
index|[
literal|2
index|]
operator|=
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|section_type
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|0xD0
case|:
comment|/* Normal code */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|flags
operator||=
name|SEC_LOAD
operator||
name|SEC_CODE
expr_stmt|;
break|break;
case|case
literal|0xC4
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|flags
operator||=
name|SEC_LOAD
operator||
name|SEC_DATA
expr_stmt|;
comment|/* Normal data */
break|break;
case|case
literal|0xD2
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Normal rom data */
name|section
operator|->
name|flags
operator||=
name|SEC_LOAD
operator||
name|SEC_ROM
operator||
name|SEC_DATA
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
case|case
literal|0xC3
case|:
name|section_type
index|[
literal|1
index|]
operator|=
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
switch|switch
condition|(
name|section_type
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0xD0
case|:
comment|/* Normal code */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|flags
operator||=
name|SEC_LOAD
operator||
name|SEC_CODE
expr_stmt|;
break|break;
case|case
literal|0xC4
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section
operator|->
name|flags
operator||=
name|SEC_LOAD
operator||
name|SEC_DATA
expr_stmt|;
comment|/* Normal data */
break|break;
case|case
literal|0xD2
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Normal rom data */
name|section
operator|->
name|flags
operator||=
name|SEC_LOAD
operator||
name|SEC_ROM
operator||
name|SEC_DATA
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|section
operator|->
name|name
operator|=
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
block|{
name|bfd_vma
name|parent
decl_stmt|,
name|brother
decl_stmt|,
name|context
decl_stmt|;
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|parent
argument_list|)
expr_stmt|;
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|brother
argument_list|)
expr_stmt|;
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ieee_section_alignment_enum
case|:
block|{
name|unsigned
name|int
name|section_index
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section_index
operator|=
name|must_parse_int
argument_list|(
operator|&
name|ieee
operator|->
name|h
argument_list|)
expr_stmt|;
name|section
operator|=
name|get_section_entry
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|,
name|section_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_index
operator|>
name|ieee
operator|->
name|section_count
condition|)
block|{
name|ieee
operator|->
name|section_count
operator|=
name|section_index
expr_stmt|;
block|}
name|section
operator|->
name|alignment_power
operator|=
name|bfd_log2
argument_list|(
name|must_parse_int
argument_list|(
operator|&
name|ieee
operator|->
name|h
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ieee_e2_first_byte_enum
case|:
block|{
name|ieee_record_enum_type
name|t
init|=
call|(
name|ieee_record_enum_type
call|)
argument_list|(
name|read_2bytes
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|ieee_section_size_enum
case|:
name|section
operator|=
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_physical_region_size_enum
case|:
name|section
operator|=
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_region_base_address_enum
case|:
name|section
operator|=
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
expr_stmt|;
name|section
operator|->
name|vma
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_mau_size_enum
case|:
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_m_value_enum
case|:
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_section_base_address_enum
case|:
name|section
operator|=
name|ieee
operator|->
name|section_table
index|[
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
index|]
expr_stmt|;
name|section
operator|->
name|vma
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_section_offset_enum
case|:
operator|(
name|void
operator|)
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
block|}
break|break;
default|default:
return|return;
block|}
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/*********************************************************************** *  archive stuff  */
end_comment

begin_decl_stmt
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|ieee_archive_p
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|char
modifier|*
name|library
decl_stmt|;
name|boolean
name|loop
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|uint8e_type
name|buffer
index|[
literal|512
index|]
decl_stmt|;
name|struct
name|obstack
name|ob
decl_stmt|;
name|file_ptr
name|buffer_offset
init|=
literal|0
decl_stmt|;
name|ieee_ar_data_type
modifier|*
name|save
init|=
name|abfd
operator|->
name|tdata
operator|.
name|ieee_ar_data
decl_stmt|;
name|ieee_ar_data_type
modifier|*
name|ieee
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|ieee_ar_data
operator|=
operator|(
name|ieee_ar_data_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ieee_ar_data_type
argument_list|)
argument_list|)
expr_stmt|;
name|ieee
operator|=
name|IEEE_AR_DATA
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|first_byte
operator|=
name|buffer
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|input_p
operator|=
name|buffer
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|!=
name|Module_Beginning
condition|)
block|{
name|abfd
operator|->
name|tdata
operator|.
name|ieee_ar_data
operator|=
name|save
expr_stmt|;
return|return
operator|(
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|library
operator|=
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|library
argument_list|,
literal|"LIBRARY"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|ieee_ar_data
operator|=
name|save
expr_stmt|;
return|return
operator|(
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
comment|/* Throw away the filename */
name|free
argument_list|(
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This must be an IEEE archive, so we'll buy some space to do      things */
name|obstack_begin
argument_list|(
operator|&
name|ob
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|ieee
operator|->
name|element_count
operator|=
literal|0
expr_stmt|;
name|ieee
operator|->
name|element_index
operator|=
literal|0
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Drop the ad part */
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* And the two dummy numbers */
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|loop
operator|=
name|true
expr_stmt|;
comment|/* Read the index of the BB table */
while|while
condition|(
name|loop
condition|)
block|{
name|ieee_ar_obstack_type
name|t
decl_stmt|;
name|int
name|rec
init|=
name|read_2bytes
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rec
operator|==
operator|(
name|int
operator|)
name|ieee_assign_value_to_variable_enum
condition|)
block|{
name|int
name|record_number
init|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
decl_stmt|;
name|t
operator|.
name|file_offset
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|abfd
operator|=
operator|(
name|bfd
operator|*
operator|)
name|NULL
expr_stmt|;
name|ieee
operator|->
name|element_count
operator|++
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|ob
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure that we don't go over the end of the buffer */
if|if
condition|(
name|ieee_pos
argument_list|(
name|abfd
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|/
literal|2
condition|)
block|{
comment|/* Past half way, reseek and reprime */
name|buffer_offset
operator|+=
name|ieee_pos
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|buffer_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|first_byte
operator|=
name|buffer
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|input_p
operator|=
name|buffer
expr_stmt|;
block|}
block|}
else|else
name|loop
operator|=
name|false
expr_stmt|;
block|}
name|ieee
operator|->
name|elements
operator|=
operator|(
name|ieee_ar_obstack_type
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
comment|/* Now scan the area again, and replace BB offsets with file */
comment|/* offsets */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ieee
operator|->
name|element_count
condition|;
name|i
operator|++
control|)
block|{
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|ieee
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|file_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|first_byte
operator|=
name|buffer
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|input_p
operator|=
name|buffer
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Drop F8 */
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Drop 14 */
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Drop size of block */
if|if
condition|(
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This object has been deleted */
name|ieee
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|file_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ieee
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|file_offset
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|ieee_mkobject
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|abfd
operator|->
name|tdata
operator|.
name|ieee_data
operator|=
operator|(
name|ieee_data_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ieee_data_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|ieee_object_p
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|char
modifier|*
name|processor
decl_stmt|;
name|unsigned
name|int
name|part
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
decl_stmt|;
name|uint8e_type
name|buffer
index|[
literal|300
index|]
decl_stmt|;
name|ieee_data_type
modifier|*
name|save
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|ieee_data
operator|=
literal|0
expr_stmt|;
name|ieee_mkobject
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|ieee
operator|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* Read the first few bytes in to see if it makes sense */
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|input_p
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|this_byte_and_next
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|!=
name|Module_Beginning
condition|)
goto|goto
name|fail
goto|;
name|ieee
operator|->
name|read_symbols
operator|=
name|false
expr_stmt|;
name|ieee
operator|->
name|read_data
operator|=
name|false
expr_stmt|;
name|ieee
operator|->
name|section_count
operator|=
literal|0
expr_stmt|;
name|ieee
operator|->
name|external_symbol_max_index
operator|=
literal|0
expr_stmt|;
name|ieee
operator|->
name|external_symbol_min_index
operator|=
name|IEEE_PUBLIC_BASE
expr_stmt|;
name|ieee
operator|->
name|external_reference_min_index
operator|=
name|IEEE_REFERENCE_BASE
expr_stmt|;
name|ieee
operator|->
name|external_reference_max_index
operator|=
literal|0
expr_stmt|;
name|ieee
operator|->
name|h
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|ieee
operator|->
name|section_table
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ieee
operator|->
name|section_table
argument_list|)
argument_list|)
expr_stmt|;
name|processor
operator|=
name|ieee
operator|->
name|mb
operator|.
name|processor
operator|=
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|processor
argument_list|,
literal|"LIBRARY"
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
name|ieee
operator|->
name|mb
operator|.
name|module_name
operator|=
name|read_id
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|filename
operator|==
operator|(
name|CONST
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|abfd
operator|->
name|filename
operator|=
name|ieee
operator|->
name|mb
operator|.
name|module_name
expr_stmt|;
block|}
comment|/* Determine the architecture and machine type of the object file.      */
block|{
name|bfd_arch_info_type
modifier|*
name|arch
init|=
name|bfd_scan_arch
argument_list|(
name|processor
argument_list|)
decl_stmt|;
if|if
condition|(
name|arch
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
name|abfd
operator|->
name|arch_info
operator|=
name|arch
expr_stmt|;
block|}
if|if
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|ieee_address_descriptor_enum
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|ieee
operator|->
name|ad
operator|.
name|number_of_bits_mau
argument_list|)
operator|==
name|false
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|ieee
operator|->
name|ad
operator|.
name|number_of_maus_in_address
argument_list|)
operator|==
name|false
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
comment|/* If there is a byte order info, take it */
if|if
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|==
operator|(
name|int
operator|)
name|ieee_variable_L_enum
operator|||
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|==
operator|(
name|int
operator|)
name|ieee_variable_M_enum
condition|)
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
name|N_W_VARIABLES
condition|;
name|part
operator|++
control|)
block|{
name|boolean
name|ok
decl_stmt|;
if|if
condition|(
name|read_2bytes
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|ieee_assign_value_to_variable_enum
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|this_byte_and_next
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|!=
name|part
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
name|ieee
operator|->
name|w
operator|.
name|offset
index|[
name|part
index|]
operator|=
name|parse_i
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
name|false
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
block|}
name|abfd
operator|->
name|flags
operator|=
name|HAS_SYMS
expr_stmt|;
comment|/* By now we know that this is a real IEEE file, we're going to read    the whole thing into memory so that we can run up and down it    quickly. We can work out how big the file is from the trailer    record */
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|h
operator|.
name|first_byte
operator|=
operator|(
name|uint8e_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|me_record
operator|+
literal|50
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|h
operator|.
name|first_byte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|me_record
operator|+
literal|50
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|ieee_slurp_sections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
name|fail
label|:
operator|(
name|void
operator|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ieee
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|ieee_data
operator|=
name|save
expr_stmt|;
return|return
operator|(
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|ieee_print_symbol
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|afile
operator|,
name|symbol
operator|,
name|how
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|PTR
name|afile
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|bfd_print_symbol_type
name|how
argument_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
if|#
directive|if
literal|0
block|fprintf(file,"%4x %2x",aout_symbol(symbol)->desc& 0xffff, 	    aout_symbol(symbol)->other& 0xff);
endif|#
directive|endif
name|BFD_FAIL
argument_list|()
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_nm
case|:
case|case
name|bfd_print_symbol_all
case|:
block|{
name|CONST
name|char
modifier|*
name|section_name
init|=
name|symbol
operator|->
name|section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|?
operator|(
name|CONST
name|char
operator|*
operator|)
literal|"*abs"
else|:
name|symbol
operator|->
name|section
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|symbol
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"* empty table entry "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %04x %02x %s"
argument_list|,
name|section_name
argument_list|,
operator|(
name|unsigned
operator|)
name|ieee_symbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|index
argument_list|,
operator|(
name|unsigned
operator|)
literal|0
argument_list|,
comment|/* 					   aout_symbol(symbol)->desc& 0xffff, 					   aout_symbol(symbol)->other& 0xff,*/
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|do_one
argument_list|,
operator|(
name|ieee
operator|,
name|current_map
operator|,
name|location_ptr
operator|,
name|s
operator|)
argument_list|,
name|ieee_data_type
operator|*
name|ieee
name|AND
name|ieee_per_section_type
operator|*
name|current_map
name|AND
name|uint8e_type
operator|*
name|location_ptr
name|AND
name|asection
operator|*
name|s
argument_list|)
block|{
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_load_constant_bytes_enum
case|:
block|{
name|unsigned
name|int
name|number_of_maus
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|number_of_maus
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_maus
condition|;
name|i
operator|++
control|)
block|{
name|location_ptr
index|[
name|current_map
operator|->
name|pc
operator|++
index|]
operator|=
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ieee_load_with_relocation_enum
case|:
block|{
name|boolean
name|loop
init|=
name|true
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|loop
condition|)
block|{
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_variable_R_enum
case|:
case|case
name|ieee_function_signed_open_b_enum
case|:
case|case
name|ieee_function_unsigned_open_b_enum
case|:
case|case
name|ieee_function_either_open_b_enum
case|:
block|{
name|unsigned
name|int
name|extra
init|=
literal|4
decl_stmt|;
name|boolean
name|pcrel
init|=
name|false
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|ieee_reloc_type
modifier|*
name|r
init|=
operator|(
name|ieee_reloc_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ieee_reloc_type
argument_list|)
argument_list|)
decl_stmt|;
operator|*
operator|(
name|current_map
operator|->
name|reloc_tail_ptr
operator|)
operator|=
name|r
expr_stmt|;
name|current_map
operator|->
name|reloc_tail_ptr
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|next
operator|=
operator|(
name|ieee_reloc_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/*			    abort();*/
name|parse_expression
argument_list|(
name|ieee
argument_list|,
operator|&
name|r
operator|->
name|relent
operator|.
name|addend
argument_list|,
operator|&
name|r
operator|->
name|symbol
argument_list|,
operator|&
name|pcrel
argument_list|,
operator|&
name|extra
argument_list|,
operator|&
name|section
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|address
operator|=
name|current_map
operator|->
name|pc
expr_stmt|;
name|s
operator|->
name|reloc_count
operator|++
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|==
literal|0
condition|)
block|{
name|r
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
name|section
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
if|if
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
operator|==
operator|(
name|int
operator|)
name|ieee_comma
condition|)
block|{
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Fetch number of bytes to pad */
name|extra
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_function_signed_close_b_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_function_unsigned_close_b_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_function_either_close_b_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Build a relocation entry for this type */
comment|/* If pc rel then stick -ve pc into instruction 			       and take out of reloc ..  			       I've changed this. It's all too 			       complicated. I keep 0 in the 			       instruction  now. 			       */
switch|switch
condition|(
name|extra
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|4
case|:
if|if
condition|(
name|pcrel
operator|==
name|true
condition|)
block|{
if|#
directive|if
name|KEEPMINUSPCININST
name|bfd_put_32
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
operator|-
name|current_map
operator|->
name|pc
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|rel32_howto
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|addend
operator|-=
name|current_map
operator|->
name|pc
expr_stmt|;
else|#
directive|else
name|bfd_put_32
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
literal|0
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|rel32_howto
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
literal|0
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|abs32_howto
expr_stmt|;
block|}
name|current_map
operator|->
name|pc
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|pcrel
operator|==
name|true
condition|)
block|{
if|#
directive|if
name|KEEPMINUSPCININST
name|bfd_put_16
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|-
name|current_map
operator|->
name|pc
argument_list|)
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|addend
operator|-=
name|current_map
operator|->
name|pc
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|rel16_howto
expr_stmt|;
else|#
directive|else
name|bfd_put_16
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
literal|0
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|rel16_howto
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|bfd_put_16
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
literal|0
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|abs16_howto
expr_stmt|;
block|}
name|current_map
operator|->
name|pc
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|pcrel
operator|==
name|true
condition|)
block|{
if|#
directive|if
name|KEEPMINUSPCININST
name|bfd_put_8
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|-
name|current_map
operator|->
name|pc
argument_list|)
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|addend
operator|-=
name|current_map
operator|->
name|pc
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|rel8_howto
expr_stmt|;
else|#
directive|else
name|bfd_put_8
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
literal|0
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|rel8_howto
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|bfd_put_8
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
literal|0
argument_list|,
name|location_ptr
operator|+
name|current_map
operator|->
name|pc
argument_list|)
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|abs8_howto
expr_stmt|;
block|}
name|current_map
operator|->
name|pc
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
block|{
name|bfd_vma
name|this_size
decl_stmt|;
if|if
condition|(
name|parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|,
operator|&
name|this_size
argument_list|)
operator|==
name|true
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|this_size
condition|;
name|i
operator|++
control|)
block|{
name|location_ptr
index|[
name|current_map
operator|->
name|pc
operator|++
index|]
operator|=
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|loop
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Read in all the section data and relocation stuff too */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|ieee_slurp_section_data
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|bfd_byte
modifier|*
name|location_ptr
init|=
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|section_number
decl_stmt|;
name|ieee_per_section_type
modifier|*
name|current_map
init|=
operator|(
name|ieee_per_section_type
operator|*
operator|)
name|NULL
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Seek to the start of the data area */
if|if
condition|(
name|ieee
operator|->
name|read_data
operator|==
name|true
condition|)
return|return
name|true
return|;
name|ieee
operator|->
name|read_data
operator|=
name|true
expr_stmt|;
name|ieee_seek
argument_list|(
name|abfd
argument_list|,
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|data_part
argument_list|)
expr_stmt|;
comment|/* Allocate enough space for all the section contents */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|ieee_per_section_type
modifier|*
name|per
init|=
operator|(
name|ieee_per_section_type
operator|*
operator|)
name|s
operator|->
name|used_by_bfd
decl_stmt|;
name|per
operator|->
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|ieee
operator|->
name|h
operator|.
name|abfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
comment|/*SUPPRESS 68*/
name|per
operator|->
name|reloc_tail_ptr
operator|=
operator|(
name|ieee_reloc_type
operator|*
operator|*
operator|)
operator|&
operator|(
name|s
operator|->
name|relocation
operator|)
expr_stmt|;
block|}
while|while
condition|(
name|true
condition|)
block|{
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
comment|/* IF we see anything strange then quit */
default|default:
return|return
name|true
return|;
case|case
name|ieee_set_current_section_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|section_number
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ieee
operator|->
name|section_table
index|[
name|section_number
index|]
expr_stmt|;
name|current_map
operator|=
operator|(
name|ieee_per_section_type
operator|*
operator|)
name|s
operator|->
name|used_by_bfd
expr_stmt|;
name|location_ptr
operator|=
name|current_map
operator|->
name|data
operator|-
name|s
operator|->
name|vma
expr_stmt|;
comment|/* The document I have says that Microtec's compilers reset */
comment|/* this after a sec section, even though the standard says not */
comment|/* to. SO .. */
name|current_map
operator|->
name|pc
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|ieee_e2_first_byte_enum
case|:
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|this_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
condition|)
block|{
case|case
name|ieee_set_current_pc_enum
operator|&
literal|0xff
case|:
block|{
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|dsection
decl_stmt|;
name|ieee_symbol_index_type
name|symbol
decl_stmt|;
name|unsigned
name|int
name|extra
decl_stmt|;
name|boolean
name|pcrel
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* Thow away section #*/
name|parse_expression
argument_list|(
name|ieee
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|symbol
argument_list|,
operator|&
name|pcrel
argument_list|,
operator|&
name|extra
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_map
operator|->
name|pc
operator|=
name|value
expr_stmt|;
name|BFD_ASSERT
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|value
operator|-
name|s
operator|->
name|vma
argument_list|)
operator|<=
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ieee_value_starting_address_enum
operator|&
literal|0xff
case|:
comment|/* We've got to the end of the data now - */
return|return
name|true
return|;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
case|case
name|ieee_repeat_data_enum
case|:
block|{
comment|/* Repeat the following LD or LR n times - we do this by 		 remembering the stream pointer before running it and 		 resetting it and running it n times. We special case 		 the repetition of a repeat_data/load_constant 		 */
name|unsigned
name|int
name|iterations
decl_stmt|;
name|uint8e_type
modifier|*
name|start
decl_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|iterations
operator|=
name|must_parse_int
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|ieee
operator|->
name|h
operator|.
name|input_p
expr_stmt|;
if|if
condition|(
name|start
index|[
literal|0
index|]
operator|==
operator|(
name|int
operator|)
name|ieee_load_constant_bytes_enum
operator|&&
name|start
index|[
literal|1
index|]
operator|==
literal|1
condition|)
block|{
while|while
condition|(
name|iterations
operator|!=
literal|0
condition|)
block|{
name|location_ptr
index|[
name|current_map
operator|->
name|pc
operator|++
index|]
operator|=
name|start
index|[
literal|2
index|]
expr_stmt|;
name|iterations
operator|--
expr_stmt|;
block|}
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
name|next_byte
argument_list|(
operator|&
operator|(
name|ieee
operator|->
name|h
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|iterations
operator|!=
literal|0
condition|)
block|{
name|ieee
operator|->
name|h
operator|.
name|input_p
operator|=
name|start
expr_stmt|;
name|do_one
argument_list|(
name|ieee
argument_list|,
name|current_map
argument_list|,
name|location_ptr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|iterations
operator|--
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|ieee_load_constant_bytes_enum
case|:
case|case
name|ieee_load_with_relocation_enum
case|:
block|{
name|do_one
argument_list|(
name|ieee
argument_list|,
name|current_map
argument_list|,
name|location_ptr
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|ieee_new_section_hook
argument_list|,
operator|(
name|abfd
operator|,
name|newsect
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|newsect
argument_list|)
block|{
name|newsect
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ieee_per_section_type
argument_list|)
argument_list|)
expr_stmt|;
name|ieee_per_section
argument_list|(
name|newsect
argument_list|)
operator|->
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
expr_stmt|;
name|ieee_per_section
argument_list|(
name|newsect
argument_list|)
operator|->
name|section
operator|=
name|newsect
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|ieee_get_reloc_upper_bound
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|asect
argument_list|)
block|{
name|ieee_slurp_section_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|ieee_get_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
argument_list|)
block|{
name|ieee_per_section_type
modifier|*
name|p
init|=
operator|(
name|ieee_per_section_type
operator|*
operator|)
name|section
operator|->
name|used_by_bfd
decl_stmt|;
name|ieee_slurp_section_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|location
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|p
operator|->
name|data
operator|+
name|offset
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|ieee_canonicalize_reloc
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|relptr
operator|,
name|symbols
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|arelent
operator|*
operator|*
name|relptr
name|AND
name|asymbol
operator|*
operator|*
name|symbols
argument_list|)
block|{
comment|/*  ieee_per_section_type *p = (ieee_per_section_type *) section->used_by_bfd;*/
name|ieee_reloc_type
modifier|*
name|src
init|=
operator|(
name|ieee_reloc_type
operator|*
operator|)
operator|(
name|section
operator|->
name|relocation
operator|)
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
while|while
condition|(
name|src
operator|!=
operator|(
name|ieee_reloc_type
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Work out which symbol to attach it this reloc to */
switch|switch
condition|(
name|src
operator|->
name|symbol
operator|.
name|letter
condition|)
block|{
case|case
literal|'X'
case|:
name|src
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
name|symbols
operator|+
name|src
operator|->
name|symbol
operator|.
name|index
operator|+
name|ieee
operator|->
name|external_reference_base_offset
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|src
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
name|bfd_abs_section
operator|.
name|symbol_ptr_ptr
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
operator|*
name|relptr
operator|++
operator|=
operator|&
name|src
operator|->
name|relent
expr_stmt|;
name|src
operator|=
name|src
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
operator|(
name|arelent
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|comp
argument_list|,
operator|(
name|ap
operator|,
name|bp
operator|)
argument_list|,
name|CONST
name|PTR
name|ap
name|AND
name|CONST
name|PTR
name|bp
argument_list|)
block|{
name|arelent
modifier|*
name|a
init|=
operator|*
operator|(
operator|(
name|arelent
operator|*
operator|*
operator|)
name|ap
operator|)
decl_stmt|;
name|arelent
modifier|*
name|b
init|=
operator|*
operator|(
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bp
operator|)
decl_stmt|;
return|return
name|a
operator|->
name|address
operator|-
name|b
operator|->
name|address
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Write the section headers */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_write_section_part
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|section_part
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|!=
operator|&
name|bfd_abs_section
condition|)
block|{
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_section_type_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
comment|/* This image is executable, so output absolute sections */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_A_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_S_enum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_C_enum
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator|)
condition|)
block|{
case|case
name|SEC_CODE
operator||
name|SEC_LOAD
case|:
case|case
name|SEC_CODE
case|:
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_P_enum
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEC_DATA
case|:
default|default:
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_D_enum
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEC_ROM
case|:
case|case
name|SEC_ROM
operator||
name|SEC_DATA
case|:
case|case
name|SEC_ROM
operator||
name|SEC_LOAD
case|:
case|case
name|SEC_ROM
operator||
name|SEC_DATA
operator||
name|SEC_LOAD
case|:
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_variable_R_enum
argument_list|)
expr_stmt|;
block|}
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|ieee_write_int(abfd, 0);
comment|/* Parent */
block|ieee_write_int(abfd, 0);
comment|/* Brother */
block|ieee_write_int(abfd, 0);
comment|/* Context */
endif|#
directive|endif
comment|/* Alignment */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_section_alignment_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
literal|1
operator|<<
name|s
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
comment|/* Size */
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
name|ieee_section_size_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
comment|/* Relocateable sections don't have asl records */
comment|/* Vma */
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
name|ieee_section_base_address_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|vma
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|do_with_relocs
argument_list|,
operator|(
name|abfd
operator|,
name|s
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|s
argument_list|)
block|{
name|unsigned
name|int
name|relocs_to_go
init|=
name|s
operator|->
name|reloc_count
decl_stmt|;
name|bfd_byte
modifier|*
name|stream
init|=
name|ieee_per_section
argument_list|(
name|s
argument_list|)
operator|->
name|data
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|p
init|=
name|s
operator|->
name|orelocation
decl_stmt|;
name|bfd_size_type
name|current_byte_index
init|=
literal|0
decl_stmt|;
name|qsort
argument_list|(
name|s
operator|->
name|orelocation
argument_list|,
name|relocs_to_go
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
operator|*
operator|*
argument_list|)
argument_list|,
name|comp
argument_list|)
expr_stmt|;
comment|/* Output the section preheader */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_set_current_section_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
expr_stmt|;
name|ieee_write_twobyte
argument_list|(
name|abfd
argument_list|,
name|ieee_set_current_pc_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
expr_stmt|;
name|ieee_write_expression
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|symbol
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocs_to_go
operator|==
literal|0
condition|)
block|{
comment|/* If there arn't any relocations then output the load constant byte 	   opcode rather than the load with relocation opcode */
while|while
condition|(
name|current_byte_index
operator|<
name|s
operator|->
name|_raw_size
condition|)
block|{
name|bfd_size_type
name|run
decl_stmt|;
name|unsigned
name|int
name|MAXRUN
init|=
literal|32
decl_stmt|;
name|run
operator|=
name|MAXRUN
expr_stmt|;
if|if
condition|(
name|run
operator|>
name|s
operator|->
name|_raw_size
operator|-
name|current_byte_index
condition|)
block|{
name|run
operator|=
name|s
operator|->
name|_raw_size
operator|-
name|current_byte_index
expr_stmt|;
block|}
if|if
condition|(
name|run
operator|!=
literal|0
condition|)
block|{
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_load_constant_bytes_enum
argument_list|)
expr_stmt|;
comment|/* Output a stream of bytes */
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|run
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|stream
operator|+
name|current_byte_index
argument_list|)
argument_list|,
literal|1
argument_list|,
name|run
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|current_byte_index
operator|+=
name|run
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_load_with_relocation_enum
argument_list|)
expr_stmt|;
comment|/* Output the data stream as the longest sequence of bytes 	   possible, allowing for the a reasonable packet size and 	   relocation stuffs */
if|if
condition|(
operator|(
name|PTR
operator|)
name|stream
operator|==
operator|(
name|PTR
operator|)
name|NULL
condition|)
block|{
comment|/* Outputting a section without data, fill it up */
name|stream
operator|=
operator|(
name|uint8e_type
operator|*
operator|)
operator|(
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|stream
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|current_byte_index
operator|<
name|s
operator|->
name|_raw_size
condition|)
block|{
name|bfd_size_type
name|run
decl_stmt|;
name|unsigned
name|int
name|MAXRUN
init|=
literal|32
decl_stmt|;
if|if
condition|(
name|relocs_to_go
condition|)
block|{
name|run
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|address
operator|-
name|current_byte_index
expr_stmt|;
block|}
else|else
block|{
name|run
operator|=
name|MAXRUN
expr_stmt|;
block|}
if|if
condition|(
name|run
operator|>
name|s
operator|->
name|_raw_size
operator|-
name|current_byte_index
condition|)
block|{
name|run
operator|=
name|s
operator|->
name|_raw_size
operator|-
name|current_byte_index
expr_stmt|;
block|}
if|if
condition|(
name|run
operator|!=
literal|0
condition|)
block|{
comment|/* Output a stream of bytes */
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|run
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|stream
operator|+
name|current_byte_index
argument_list|)
argument_list|,
literal|1
argument_list|,
name|run
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|current_byte_index
operator|+=
name|run
expr_stmt|;
block|}
comment|/* Output any relocations here */
if|if
condition|(
name|relocs_to_go
operator|&&
operator|(
operator|*
name|p
operator|)
operator|&&
operator|(
operator|*
name|p
operator|)
operator|->
name|address
operator|==
name|current_byte_index
condition|)
block|{
while|while
condition|(
name|relocs_to_go
operator|&&
operator|(
operator|*
name|p
operator|)
operator|&&
operator|(
operator|*
name|p
operator|)
operator|->
name|address
operator|==
name|current_byte_index
condition|)
block|{
name|arelent
modifier|*
name|r
init|=
operator|*
name|p
decl_stmt|;
name|bfd_vma
name|ov
decl_stmt|;
if|#
directive|if
literal|0
block|if (r->howto->pc_relative) { 		r->addend += current_byte_index ; 	      }
endif|#
directive|endif
switch|switch
condition|(
name|r
operator|->
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|2
case|:
name|ov
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|stream
operator|+
name|current_byte_index
argument_list|)
expr_stmt|;
name|current_byte_index
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ov
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|stream
operator|+
name|current_byte_index
argument_list|)
expr_stmt|;
name|current_byte_index
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|ov
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|stream
operator|+
name|current_byte_index
argument_list|)
expr_stmt|;
name|current_byte_index
operator|++
expr_stmt|;
break|break;
default|default:
name|ov
operator|=
literal|0
expr_stmt|;
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_function_either_open_b_enum
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|sym_ptr_ptr
operator|!=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|ieee_write_expression
argument_list|(
name|abfd
argument_list|,
name|r
operator|->
name|addend
operator|+
name|ov
argument_list|,
operator|*
operator|(
name|r
operator|->
name|sym_ptr_ptr
operator|)
argument_list|,
name|r
operator|->
name|howto
operator|->
name|pc_relative
argument_list|,
name|s
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ieee_write_expression
argument_list|(
name|abfd
argument_list|,
name|r
operator|->
name|addend
operator|+
name|ov
argument_list|,
operator|(
name|asymbol
operator|*
operator|)
name|NULL
argument_list|,
name|r
operator|->
name|howto
operator|->
name|pc_relative
argument_list|,
name|s
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|1
operator|||
name|r
operator|->
name|howto
operator|->
name|size
operator|!=
literal|2
condition|)
block|{
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_comma
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
literal|1
operator|<<
name|r
operator|->
name|howto
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_function_either_close_b_enum
argument_list|)
expr_stmt|;
name|relocs_to_go
operator|--
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* If there are no relocations in the output section then we can be clever about how we write. We block items up into a max of 127 bytes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|do_as_repeat
argument_list|,
operator|(
name|abfd
operator|,
name|s
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|s
argument_list|)
block|{
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_set_current_section_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_set_current_pc_enum
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_set_current_pc_enum
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|vma
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_repeat_data_enum
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_load_constant_bytes_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|do_without_relocs
argument_list|,
operator|(
name|abfd
operator|,
name|s
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|s
argument_list|)
block|{
name|bfd_byte
modifier|*
name|stream
init|=
name|ieee_per_section
argument_list|(
name|s
argument_list|)
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|stream
operator|==
literal|0
operator|||
operator|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|do_as_repeat
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|_raw_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stream
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|do_with_relocs
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|do_as_repeat
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|output_ptr_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|output_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|output_ptr_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|input_ptr_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|input_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|input_ptr_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|output_buffer
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fill
parameter_list|()
block|{
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|input_ptr_start
argument_list|,
literal|1
argument_list|,
name|input_ptr_end
operator|-
name|input_ptr_start
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
name|input_ptr
operator|=
name|input_ptr_start
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush
parameter_list|()
block|{
name|bfd_write
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|output_ptr_start
argument_list|)
argument_list|,
literal|1
argument_list|,
name|output_ptr
operator|-
name|output_ptr_start
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
name|output_ptr
operator|=
name|output_ptr_start
expr_stmt|;
name|output_buffer
operator|++
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|THIS
parameter_list|()
value|( *input_ptr )
end_define

begin_define
define|#
directive|define
name|NEXT
parameter_list|()
value|{ input_ptr++; if (input_ptr == input_ptr_end) fill(); }
end_define

begin_define
define|#
directive|define
name|OUT
parameter_list|(
name|x
parameter_list|)
value|{ *output_ptr++ = (x); if(output_ptr == output_ptr_end)  flush(); }
end_define

begin_function
specifier|static
name|void
name|write_int
parameter_list|(
name|value
parameter_list|)
name|int
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|>=
literal|0
operator|&&
name|value
operator|<=
literal|127
condition|)
block|{
name|OUT
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|length
decl_stmt|;
comment|/* How many significant bytes ? */
comment|/* FIXME FOR LONGER INTS */
if|if
condition|(
name|value
operator|&
literal|0xff000000
condition|)
block|{
name|length
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|&
literal|0x00ff0000
condition|)
block|{
name|length
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|&
literal|0x0000ff00
condition|)
block|{
name|length
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|length
operator|=
literal|1
expr_stmt|;
name|OUT
argument_list|(
operator|(
name|int
operator|)
name|ieee_number_repeat_start_enum
operator|+
name|length
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|4
case|:
name|OUT
argument_list|(
name|value
operator|>>
literal|24
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|OUT
argument_list|(
name|value
operator|>>
literal|16
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|OUT
argument_list|(
name|value
operator|>>
literal|8
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|OUT
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|copy_id
parameter_list|()
block|{
name|int
name|length
init|=
name|THIS
argument_list|()
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|OUT
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|VAR
parameter_list|(
name|x
parameter_list|)
value|((x | 0x80))
end_define

begin_function
specifier|static
name|void
name|copy_expression
parameter_list|()
block|{
name|int
name|stack
index|[
literal|10
index|]
decl_stmt|;
name|int
modifier|*
name|tos
init|=
name|stack
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|THIS
argument_list|()
condition|)
block|{
case|case
literal|0x84
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|0x83
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|0x82
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|0x81
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|NEXT
argument_list|()
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|THIS
argument_list|()
operator|>
literal|0x84
condition|)
block|{
comment|/* Not a number, just bug out with the answer */
name|write_int
argument_list|(
operator|*
operator|(
operator|--
name|tos
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|tos
operator|++
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0xa5
case|:
comment|/* PLUS anything */
block|{
name|int
name|value
init|=
operator|*
operator|(
operator|--
name|tos
operator|)
decl_stmt|;
name|value
operator|+=
operator|*
operator|(
operator|--
name|tos
operator|)
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
name|value
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|VAR
argument_list|(
literal|'R'
argument_list|)
case|:
block|{
name|int
name|section_number
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|section_number
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|ieee
operator|=
name|IEEE_DATA
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|s
operator|=
name|ieee
operator|->
name|section_table
index|[
name|section_number
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|output_section
condition|)
block|{
name|value
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|value
operator|+=
name|s
operator|->
name|output_offset
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
name|value
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|0x90
case|:
block|{
name|NEXT
argument_list|()
expr_stmt|;
name|write_int
argument_list|(
operator|*
operator|(
operator|--
name|tos
operator|)
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0x90
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Drop the int in the buffer, and copy a null into the gap, which we    will overwrite later */
end_comment

begin_struct
struct|struct
name|output_buffer_struct
block|{
name|unsigned
name|char
modifier|*
name|ptrp
decl_stmt|;
name|int
name|buffer
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|fill_int
argument_list|,
operator|(
name|buf
operator|)
argument_list|,
expr|struct
name|output_buffer_struct
operator|*
name|buf
argument_list|)
block|{
if|if
condition|(
name|buf
operator|->
name|buffer
operator|==
name|output_buffer
condition|)
block|{
comment|/* Still a chance to output the size */
name|int
name|value
init|=
name|output_ptr
operator|-
name|buf
operator|->
name|ptrp
operator|+
literal|3
decl_stmt|;
name|buf
operator|->
name|ptrp
index|[
literal|0
index|]
operator|=
name|value
operator|>>
literal|24
expr_stmt|;
name|buf
operator|->
name|ptrp
index|[
literal|1
index|]
operator|=
name|value
operator|>>
literal|16
expr_stmt|;
name|buf
operator|->
name|ptrp
index|[
literal|2
index|]
operator|=
name|value
operator|>>
literal|8
expr_stmt|;
name|buf
operator|->
name|ptrp
index|[
literal|3
index|]
operator|=
name|value
operator|>>
literal|0
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|drop_int
argument_list|,
operator|(
name|buf
operator|)
argument_list|,
expr|struct
name|output_buffer_struct
operator|*
name|buf
argument_list|)
block|{
name|int
name|type
init|=
name|THIS
argument_list|()
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|type
operator|<=
literal|0x84
condition|)
block|{
name|NEXT
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0x84
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x83
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x82
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x81
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x80
case|:
break|break;
block|}
block|}
name|OUT
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
name|buf
operator|->
name|ptrp
operator|=
name|output_ptr
expr_stmt|;
name|buf
operator|->
name|buffer
operator|=
name|output_buffer
expr_stmt|;
name|OUT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|copy_int
parameter_list|()
block|{
name|int
name|type
init|=
name|THIS
argument_list|()
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|type
operator|<=
literal|0x84
condition|)
block|{
name|OUT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0x84
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
case|case
literal|0x83
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
case|case
literal|0x82
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
case|case
literal|0x81
case|:
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
case|case
literal|0x80
case|:
break|break;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ID
value|copy_id()
end_define

begin_define
define|#
directive|define
name|INT
value|copy_int()
end_define

begin_define
define|#
directive|define
name|EXP
value|copy_expression()
end_define

begin_function_decl
specifier|static
name|void
name|copy_till_end
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|INTn
parameter_list|(
name|q
parameter_list|)
value|copy_int()
end_define

begin_define
define|#
directive|define
name|EXPn
parameter_list|(
name|q
parameter_list|)
value|copy_expression()
end_define

begin_function
specifier|static
name|void
name|f1_record
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
comment|/* ATN record */
name|NEXT
argument_list|()
expr_stmt|;
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
default|default:
name|OUT
argument_list|(
literal|0xf1
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xc9
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf1
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0xc9
argument_list|)
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0x16
case|:
name|NEXT
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
name|NEXT
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0x00
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|INT
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|INT
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
name|EXPn
argument_list|(
argument|instruction address
argument_list|)
empty_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|0xd8
case|:
comment|/* EXternal ref */
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf1
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0xd8
argument_list|)
expr_stmt|;
name|EXP
expr_stmt|;
name|EXP
expr_stmt|;
name|EXP
expr_stmt|;
name|EXP
expr_stmt|;
break|break;
case|case
literal|0xce
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf1
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0xce
argument_list|)
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
name|INT
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0x01
case|:
name|INT
expr_stmt|;
name|INT
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
name|INT
expr_stmt|;
break|break;
case|case
literal|0x04
case|:
name|EXPn
argument_list|(
argument|external function
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x05
case|:
break|break;
case|case
literal|0x07
case|:
name|INTn
argument_list|(
argument|line number
argument_list|)
empty_stmt|;
name|INT
expr_stmt|;
case|case
literal|0x08
case|:
break|break;
case|case
literal|0x0a
case|:
name|INTn
argument_list|(
name|locked
specifier|register
argument_list|)
expr_stmt|;
name|INT
expr_stmt|;
break|break;
case|case
literal|0x3f
case|:
name|copy_till_end
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0x3e
case|:
name|copy_till_end
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
name|copy_till_end
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0x41
case|:
name|ID
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|f0_record
parameter_list|()
block|{
comment|/* Attribute record */
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf0
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
argument|Symbol name
argument_list|)
empty_stmt|;
name|ID
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_till_end
parameter_list|()
block|{
name|int
name|ch
init|=
name|THIS
argument_list|()
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|ch
operator|<=
literal|0x80
condition|)
block|{
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0x84
case|:
name|OUT
argument_list|(
name|THIS
argument_list|()
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x83
case|:
name|OUT
argument_list|(
name|THIS
argument_list|()
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x82
case|:
name|OUT
argument_list|(
name|THIS
argument_list|()
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
case|case
literal|0x81
case|:
name|OUT
argument_list|(
name|THIS
argument_list|()
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
name|THIS
argument_list|()
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|f2_record
parameter_list|()
block|{
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf2
argument_list|)
expr_stmt|;
name|INT
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xce
argument_list|)
expr_stmt|;
name|INT
expr_stmt|;
name|copy_till_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|block
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|f8_record
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0x01
case|:
case|case
literal|0x02
case|:
case|case
literal|0x03
case|:
comment|/* Unique typedefs for module */
comment|/* GLobal typedefs  */
comment|/* High level module scope beginning */
block|{
name|struct
name|output_buffer_struct
name|ob
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf8
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|drop_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|ID
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|fill_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0xf9
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x04
case|:
comment|/* Global function */
block|{
name|struct
name|output_buffer_struct
name|ob
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf8
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0x04
argument_list|)
expr_stmt|;
name|drop_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|ID
expr_stmt|;
name|INTn
argument_list|(
argument|stack size
argument_list|)
empty_stmt|;
name|INTn
argument_list|(
argument|ret val
argument_list|)
empty_stmt|;
name|EXPn
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf9
argument_list|)
expr_stmt|;
name|EXPn
argument_list|(
argument|size of block
argument_list|)
empty_stmt|;
name|fill_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x05
case|:
comment|/* File name for source line numbers */
block|{
name|struct
name|output_buffer_struct
name|ob
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf8
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0x05
argument_list|)
expr_stmt|;
name|drop_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|ID
expr_stmt|;
name|INTn
argument_list|(
name|year
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
name|month
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
name|day
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
name|hour
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
name|monute
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
name|second
argument_list|)
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf9
argument_list|)
expr_stmt|;
name|fill_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x06
case|:
comment|/* Local function */
block|{
name|struct
name|output_buffer_struct
name|ob
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf8
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0x06
argument_list|)
expr_stmt|;
name|drop_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|ID
expr_stmt|;
name|INTn
argument_list|(
argument|stack size
argument_list|)
empty_stmt|;
name|INTn
argument_list|(
argument|type return
argument_list|)
empty_stmt|;
name|EXPn
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf9
argument_list|)
expr_stmt|;
name|EXPn
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|fill_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x0a
case|:
comment|/* Assembler module scope beginning -*/
block|{
name|struct
name|output_buffer_struct
name|ob
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf8
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0x0a
argument_list|)
expr_stmt|;
name|drop_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|ID
expr_stmt|;
name|ID
expr_stmt|;
name|INT
expr_stmt|;
name|ID
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|INT
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf9
argument_list|)
expr_stmt|;
name|fill_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x0b
case|:
block|{
name|struct
name|output_buffer_struct
name|ob
decl_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf8
argument_list|)
expr_stmt|;
name|OUT
argument_list|(
literal|0x0b
argument_list|)
expr_stmt|;
name|drop_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
name|ID
expr_stmt|;
name|INT
expr_stmt|;
name|INTn
argument_list|(
argument|section index
argument_list|)
empty_stmt|;
name|EXPn
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|INTn
argument_list|(
name|stuff
argument_list|)
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xf9
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|EXPn
argument_list|(
argument|Size in Maus
argument_list|)
empty_stmt|;
name|fill_int
argument_list|(
operator|&
name|ob
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|e2_record
parameter_list|()
block|{
name|OUT
argument_list|(
literal|0xe2
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|OUT
argument_list|(
literal|0xce
argument_list|)
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|INT
expr_stmt|;
name|EXP
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|DEFUN_VOID
parameter_list|(
name|block
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|THIS
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0xe1
case|:
case|case
literal|0xe5
case|:
return|return;
case|case
literal|0xf9
case|:
return|return;
case|case
literal|0xf0
case|:
name|f0_record
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0xf1
case|:
name|f1_record
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0xf2
case|:
name|f2_record
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0xf8
case|:
name|f8_record
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0xe2
case|:
name|e2_record
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* relocate_debug,     moves all the debug information from the source bfd to the output    bfd, and relocates any expressions it finds */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|relocate_debug
argument_list|,
operator|(
name|output
operator|,
name|input
operator|)
argument_list|,
name|bfd
operator|*
name|output
name|AND
name|bfd
operator|*
name|input
argument_list|)
block|{
define|#
directive|define
name|IBS
value|400
define|#
directive|define
name|OBS
value|400
name|unsigned
name|char
name|input_buffer
index|[
name|IBS
index|]
decl_stmt|;
name|input_ptr_start
operator|=
name|input_ptr
operator|=
name|input_buffer
expr_stmt|;
name|input_ptr_end
operator|=
name|input_buffer
operator|+
name|IBS
expr_stmt|;
name|input_bfd
operator|=
name|input
expr_stmt|;
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|input_ptr_start
argument_list|,
literal|1
argument_list|,
name|IBS
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|block
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*    During linking, we we told about the bfds which made up our   contents, we have a list of them. They will still be open, so go to   the debug info in each, and copy it out, relocating it as we go. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_write_debug_part
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_chain_type
modifier|*
name|chain
init|=
name|ieee
operator|->
name|chain_root
decl_stmt|;
name|unsigned
name|char
name|output_buffer
index|[
name|OBS
index|]
decl_stmt|;
name|boolean
name|some_debug
init|=
name|false
decl_stmt|;
name|file_ptr
name|here
init|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|output_ptr_start
operator|=
name|output_ptr
operator|=
name|output_buffer
expr_stmt|;
name|output_ptr_end
operator|=
name|output_buffer
operator|+
name|OBS
expr_stmt|;
name|output_ptr
operator|=
name|output_buffer
expr_stmt|;
name|output_bfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|chain
operator|==
operator|(
name|bfd_chain_type
operator|*
operator|)
name|NULL
condition|)
block|{
if|#
directive|if
literal|0
comment|/* There is no debug info, so we'll fake some up */
block|CONST static char fake[] = { 	  0xf8, 0xa, 0, 5, 't', 't', 't', 't', 't', 0, 2, 3, 	  '1','.','1',0x82, 1991>>8, 1991& 0xff, 9, 20, 11, 07,50 };       ieee->w.r.debug_information_part = 0;         here;
comment|/*    bfd_write(fake, 1, sizeof(fake), abfd);*/
comment|/* Now write a header for each section */
block|{       int i = 0;       asection *s = abfd->sections;       while (s) { 	  if (s != abfd->abs_section)  	  { 	       	    ieee_write_byte(abfd, 0xf8);	 	    ieee_write_byte(abfd, 0x0b); 	    ieee_write_byte(abfd, 0); 	    ieee_write_byte(abfd, 0); 	    ieee_write_byte(abfd, 1); 	    ieee_write_byte(abfd, i + IEEE_SECTION_NUMBER_BASE); 	    ieee_write_expression(abfd, 0, s->symbol, 0, 0, 0); 	    ieee_write_byte(abfd,0); 	    ieee_write_byte(abfd, 0xf9); 	    ieee_write_expression(abfd, s->size, 				  bfd_abs_section.symbol, 0, 0, 0);	 	    i++; 	  } 	     	  s = s->next;  	}
comment|/* Close the scope */
block|ieee_write_byte(abfd, 0xf9);     }
endif|#
directive|endif
block|}
else|else
block|{
while|while
condition|(
name|chain
operator|!=
operator|(
name|bfd_chain_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd
modifier|*
name|entry
init|=
name|chain
operator|->
name|this
decl_stmt|;
name|ieee_data_type
modifier|*
name|entry_ieee
init|=
name|IEEE_DATA
argument_list|(
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry_ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
condition|)
block|{
name|bfd_seek
argument_list|(
name|entry
argument_list|,
name|entry_ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|relocate_debug
argument_list|(
name|abfd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|some_debug
condition|)
block|{
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
operator|=
name|here
expr_stmt|;
block|}
else|else
block|{
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|flush
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* write the data in an ieee way */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_write_data_part
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|data_part
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
comment|/* Sort the reloc records so we can insert them in the correct 	   places */
if|if
condition|(
name|s
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
block|{
name|do_with_relocs
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_without_relocs
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|init_for_output
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|ieee_per_section
argument_list|(
name|s
argument_list|)
operator|->
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/** exec and core file sections */
end_comment

begin_comment
comment|/* set section contents is complicated with IEEE since the format is  * not a byte image, but a record stream. */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|ieee_set_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
argument_list|)
block|{
if|if
condition|(
name|ieee_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
block|{
name|init_for_output
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|ieee_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
operator|+
name|offset
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
name|location
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* write the external symbols of a file, IEEE considers two sorts of external symbols, public, and referenced. It uses to internal forms to index them as well. When we write them out we turn their symbol values into indexes from the right base. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_write_external_part
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|asymbol
modifier|*
modifier|*
name|q
decl_stmt|;
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|reference_index
init|=
name|IEEE_REFERENCE_BASE
decl_stmt|;
name|unsigned
name|int
name|public_index
init|=
name|IEEE_PUBLIC_BASE
operator|+
literal|2
decl_stmt|;
name|file_ptr
name|here
init|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|boolean
name|hadone
init|=
name|false
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|outsymbols
operator|!=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
for|for
control|(
name|q
operator|=
name|abfd
operator|->
name|outsymbols
init|;
operator|*
name|q
operator|!=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
condition|;
name|q
operator|++
control|)
block|{
name|asymbol
modifier|*
name|p
init|=
operator|*
name|q
decl_stmt|;
name|hadone
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
comment|/* This must be a symbol reference .. */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_external_reference_enum
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|reference_index
argument_list|)
expr_stmt|;
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|reference_index
expr_stmt|;
name|reference_index
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|section
operator|==
operator|&
name|bfd_com_section
condition|)
block|{
comment|/* This is a weak reference */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_external_reference_enum
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|reference_index
argument_list|)
expr_stmt|;
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_weak_external_reference_enum
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|reference_index
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|value
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|BFD_FORT_COMM_DEFAULT_VALUE
argument_list|)
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|reference_index
expr_stmt|;
name|reference_index
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|BSF_GLOBAL
condition|)
block|{
comment|/* This must be a symbol definition */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_external_symbol_enum
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|public_index
argument_list|)
expr_stmt|;
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|ieee_write_twobyte
argument_list|(
name|abfd
argument_list|,
name|ieee_attribute_record_enum
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|public_index
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|15
argument_list|)
expr_stmt|;
comment|/* instruction address */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|19
argument_list|)
expr_stmt|;
comment|/* static symbol */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* one of them */
comment|/* Write out the value */
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
name|ieee_value_record_enum
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|public_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|section
operator|!=
operator|&
name|bfd_abs_section
condition|)
block|{
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
comment|/* If fully linked, then output all symbols 		   relocated */
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|value
operator|+
name|p
operator|->
name|section
operator|->
name|output_offset
operator|+
name|p
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ieee_write_expression
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|value
operator|+
name|p
operator|->
name|section
operator|->
name|output_offset
argument_list|,
name|p
operator|->
name|section
operator|->
name|output_section
operator|->
name|symbol
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ieee_write_expression
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|value
argument_list|,
name|bfd_abs_section
operator|.
name|symbol
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|value
operator|=
name|public_index
expr_stmt|;
name|public_index
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* This can happen - when there are gaps in the symbols read */
comment|/* from an input ieee file */
block|}
block|}
block|}
if|if
condition|(
name|hadone
condition|)
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|external_part
operator|=
name|here
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|CONST
specifier|static
name|unsigned
name|char
name|exten
index|[]
init|=
block|{
literal|0xf0
block|,
literal|0x20
block|,
literal|0x00
block|,
literal|0xf1
block|,
literal|0xce
block|,
literal|0x20
block|,
literal|0x00
block|,
literal|37
block|,
literal|3
block|,
literal|3
block|,
comment|/* Set version 3 rev 3   	*/
literal|0xf1
block|,
literal|0xce
block|,
literal|0x20
block|,
literal|0x00
block|,
literal|39
block|,
literal|2
block|,
comment|/* keep symbol in  original case */
literal|0xf1
block|,
literal|0xce
block|,
literal|0x20
block|,
literal|0x00
block|,
literal|38
comment|/* set object type relocateable to x */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CONST
specifier|static
name|unsigned
name|char
name|envi
index|[]
init|=
block|{
literal|0xf0
block|,
literal|0x21
block|,
literal|0x00
block|,
comment|/*    0xf1, 0xce, 0x21, 00, 50, 0x82, 0x07, 0xc7, 0x09, 0x11, 0x11,     0x19, 0x2c,  */
literal|0xf1
block|,
literal|0xce
block|,
literal|0x21
block|,
literal|00
block|,
literal|52
block|,
literal|0x00
block|,
comment|/* exec ok */
literal|0xf1
block|,
literal|0xce
block|,
literal|0x21
block|,
literal|0
block|,
literal|53
block|,
literal|0x03
block|,
comment|/* host unix */
comment|/*    0xf1, 0xce, 0x21, 0, 54, 2,1,1	tool& version # */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_write_me_part
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|trailer_part
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|start_address
condition|)
block|{
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|me_record
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
name|ieee_value_starting_address_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_function_either_open_b_enum
argument_list|)
expr_stmt|;
name|ieee_write_int
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_function_either_close_b_enum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|me_record
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_module_end_enum
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|ieee_write_object_contents
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|file_ptr
name|old
decl_stmt|;
comment|/* Fast forward over the header area */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_module_beginning_enum
argument_list|)
expr_stmt|;
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
name|bfd_printable_name
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|ieee_write_id
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
comment|/* Fast forward over the variable bits */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|ieee_address_descriptor_enum
argument_list|)
expr_stmt|;
comment|/* Bits per MAU */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_bits_per_byte
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* MAU's per address */
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
operator|/
name|bfd_arch_bits_per_byte
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|old
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
literal|8
operator|*
name|N_W_VARIABLES
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|extension_record
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
name|exten
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|exten
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* Absolute */
else|else
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
comment|/* Relocateable */
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|environmental_record
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envi
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|envi
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|output_bfd
operator|=
name|abfd
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|ieee_write_section_part
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/*     First write the symbols, this changes their values into table      indeces so we cant use it after this point     */
name|ieee_write_external_part
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/*  ieee_write_byte(abfd, ieee_record_seperator_enum);*/
comment|/*  ieee_write_byte(abfd, ieee_record_seperator_enum);*/
comment|/*     Write any debugs we have been told about      */
name|ieee_write_debug_part
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/*      Can only write the data once the symbols have been written since     the data contains relocation information which points to the     symbols      */
name|ieee_write_data_part
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/*     At the end we put the end !     */
name|ieee_write_me_part
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Generate the header */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|old
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_W_VARIABLES
condition|;
name|i
operator|++
control|)
block|{
name|ieee_write_2bytes
argument_list|(
name|abfd
argument_list|,
name|ieee_assign_value_to_variable_enum
argument_list|)
expr_stmt|;
name|ieee_write_byte
argument_list|(
name|abfd
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ieee_write_int5_out
argument_list|(
name|abfd
argument_list|,
name|ieee
operator|->
name|w
operator|.
name|offset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Native-level interface to symbols. */
end_comment

begin_comment
comment|/* We read the symbols into a buffer, which is discarded when this function exits.  We read the strings into a buffer large enough to hold them all plus all the cached symbol entries. */
end_comment

begin_decl_stmt
name|asymbol
modifier|*
name|DEFUN
argument_list|(
name|ieee_make_empty_symbol
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|ieee_symbol_type
modifier|*
name|new
init|=
operator|(
name|ieee_symbol_type
operator|*
operator|)
name|zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ieee_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|DEFUN
argument_list|(
name|ieee_openr_next_archived_file
argument_list|,
operator|(
name|arch
operator|,
name|prev
operator|)
argument_list|,
name|bfd
operator|*
name|arch
name|AND
name|bfd
operator|*
name|prev
argument_list|)
block|{
name|ieee_ar_data_type
modifier|*
name|ar
init|=
name|IEEE_AR_DATA
argument_list|(
name|arch
argument_list|)
decl_stmt|;
comment|/* take the next one from the arch state, or reset */
if|if
condition|(
name|prev
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Reset the index - the first two entries are bogus*/
name|ar
operator|->
name|element_index
operator|=
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|true
condition|)
block|{
name|ieee_ar_obstack_type
modifier|*
name|p
init|=
name|ar
operator|->
name|elements
operator|+
name|ar
operator|->
name|element_index
decl_stmt|;
name|ar
operator|->
name|element_index
operator|++
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|element_index
operator|<=
name|ar
operator|->
name|element_count
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|file_offset
operator|!=
operator|(
name|file_ptr
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|abfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|p
operator|->
name|abfd
operator|=
name|_bfd_create_empty_archive_element_shell
argument_list|(
name|arch
argument_list|)
expr_stmt|;
name|p
operator|->
name|abfd
operator|->
name|origin
operator|=
name|p
operator|->
name|file_offset
expr_stmt|;
block|}
return|return
name|p
operator|->
name|abfd
return|;
block|}
block|}
else|else
block|{
name|bfd_error
operator|=
name|no_more_archived_files
expr_stmt|;
return|return
operator|(
name|bfd
operator|*
operator|)
name|NULL
return|;
block|}
block|}
block|}
end_decl_stmt

begin_function
specifier|static
name|boolean
name|ieee_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|line_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|int
modifier|*
name|line_ptr
decl_stmt|;
block|{
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ieee_generic_stat_arch_elt
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
block|{
name|ieee_ar_data_type
modifier|*
name|ar
init|=
name|abfd
operator|->
name|my_archive
operator|->
name|tdata
operator|.
name|ieee_ar_data
decl_stmt|;
if|if
condition|(
name|ar
operator|==
operator|(
name|ieee_ar_data_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|buf
operator|->
name|st_size
operator|=
literal|0x1
expr_stmt|;
name|buf
operator|->
name|st_mode
operator|=
literal|0666
expr_stmt|;
return|return
operator|!
name|ieee_object_p
argument_list|(
name|abfd
argument_list|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|ieee_sizeof_headers
argument_list|,
operator|(
name|abfd
operator|,
name|x
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|boolean
name|x
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_bfd_debug_info_start
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{    }
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_bfd_debug_info_end
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{    }
end_decl_stmt

begin_comment
comment|/* Add this section to the list of sections we have debug info for, to    be ready to output it at close time     */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|ieee_bfd_debug_info_accumulate
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
argument_list|)
block|{
name|ieee_data_type
modifier|*
name|ieee
init|=
name|IEEE_DATA
argument_list|(
name|section
operator|->
name|owner
argument_list|)
decl_stmt|;
name|ieee_data_type
modifier|*
name|output_ieee
init|=
name|IEEE_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* can only accumulate data from other ieee bfds */
if|if
condition|(
name|section
operator|->
name|owner
operator|->
name|xvec
operator|!=
name|abfd
operator|->
name|xvec
condition|)
return|return;
comment|/* Only bother once per bfd */
if|if
condition|(
name|ieee
operator|->
name|done_debug
operator|==
name|true
condition|)
return|return;
name|ieee
operator|->
name|done_debug
operator|=
name|true
expr_stmt|;
comment|/* Don't bother if there is no debug info */
if|if
condition|(
name|ieee
operator|->
name|w
operator|.
name|r
operator|.
name|debug_information_part
operator|==
literal|0
condition|)
return|return;
comment|/* Add to chain */
block|{
name|bfd_chain_type
modifier|*
name|n
init|=
operator|(
name|bfd_chain_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|bfd_chain_type
argument_list|)
argument_list|)
decl_stmt|;
name|n
operator|->
name|this
operator|=
name|section
operator|->
name|owner
expr_stmt|;
name|n
operator|->
name|next
operator|=
operator|(
name|bfd_chain_type
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|output_ieee
operator|->
name|chain_head
condition|)
block|{
name|output_ieee
operator|->
name|chain_head
operator|->
name|next
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|output_ieee
operator|->
name|chain_root
operator|=
name|n
expr_stmt|;
block|}
name|output_ieee
operator|->
name|chain_head
operator|=
name|n
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|FOO
value|PROTO
end_define

begin_define
define|#
directive|define
name|ieee_core_file_failing_command
value|(char *(*)())(bfd_nullvoidptr)
end_define

begin_define
define|#
directive|define
name|ieee_core_file_failing_signal
value|(int (*)())bfd_0
end_define

begin_define
define|#
directive|define
name|ieee_core_file_matches_executable_p
value|( FOO(boolean, (*),(bfd *, bfd *)))bfd_false
end_define

begin_define
define|#
directive|define
name|ieee_slurp_armap
value|bfd_true
end_define

begin_define
define|#
directive|define
name|ieee_slurp_extended_name_table
value|bfd_true
end_define

begin_define
define|#
directive|define
name|ieee_truncate_arname
value|(void (*)())bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|ieee_write_armap
value|(FOO( boolean, (*),(bfd *, unsigned int, struct orl *, unsigned int, int))) bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|ieee_get_lineno
value|(struct lineno_cache_entry *(*)())bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|ieee_close_and_cleanup
value|bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|ieee_set_arch_mach
value|bfd_default_set_arch_mach
end_define

begin_define
define|#
directive|define
name|ieee_bfd_get_relocated_section_contents
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|ieee_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_comment
comment|/*SUPPRESS 460 */
end_comment

begin_decl_stmt
name|bfd_target
name|ieee_vec
init|=
block|{
literal|"ieee"
block|,
comment|/* name */
name|bfd_target_ieee_flavour
block|,
name|true
block|,
comment|/* target byte order */
name|true
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|DYNAMIC
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
literal|1
block|,
comment|/* minimum alignment */
name|_do_getb64
block|,
name|_do_putb64
block|,
name|_do_getb32
block|,
name|_do_putb32
block|,
name|_do_getb16
block|,
name|_do_putb16
block|,
comment|/* data */
name|_do_getb64
block|,
name|_do_putb64
block|,
name|_do_getb32
block|,
name|_do_putb32
block|,
name|_do_getb16
block|,
name|_do_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|ieee_object_p
block|,
comment|/* bfd_check_format */
name|ieee_archive_p
block|,
name|_bfd_dummy_target
block|,      }
block|,
block|{
name|bfd_false
block|,
name|ieee_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|ieee_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|JUMP_TABLE
argument_list|(
argument|ieee
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

