begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for s-record objects.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support<sac@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* SUBSECTION 	S-record handling  DESCRIPTION 	 	S-records cannot hold anything but addresses and data, so 	that's all that we implement.     	The only interesting thing is that s-records may come out of 	order and there is no header, so an initial scan is required 	to discover the minimum and maximum addresses used to create 	the vma and size of the only section we create.  We 	arbitrarily call this section ".text".   	When bfd_get_section_contents is called the file is read 	again, and this time the data is placed into a bfd_alloc'd 	area.  	Any number of sections may be created for output, we save them 	up and output them when it's time to close the bfd.  	An s record looks like: 	 EXAMPLE 	S<type><length><address><data><checksum> 	 DESCRIPTION 	Where 	o length 	is the number of bytes following upto the checksum. Note that 	this is not the number of chars following, since it takes two 	chars to represent a byte. 	o type 	is one of: 	0) header record 	1) two byte address data record 	2) three byte address data record 	3) four byte address data record 	7) four byte address termination record 	8) three byte address termination record 	9) two byte address termination record 	 	o address 	is the start address of the data following, or in the case of 	a termination record, the start address of the image 	o data 	is the data. 	o checksum 	is the sum of all the raw byte data in the record, from the length 	upwards, modulo 256 and subtracted from 255. 	 */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* Macros for converting between hex and binary */
end_comment

begin_decl_stmt
specifier|static
name|CONST
name|char
name|digs
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|hex_value
index|[
literal|1
operator|+
operator|(
name|unsigned
name|char
operator|)
operator|~
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOT_HEX
value|20
end_define

begin_define
define|#
directive|define
name|NIBBLE
parameter_list|(
name|x
parameter_list|)
value|hex_value[(unsigned char)(x)]
end_define

begin_define
define|#
directive|define
name|HEX
parameter_list|(
name|buffer
parameter_list|)
value|((NIBBLE((buffer)[0])<<4) + NIBBLE((buffer)[1]))
end_define

begin_define
define|#
directive|define
name|TOHEX
parameter_list|(
name|d
parameter_list|,
name|x
parameter_list|,
name|ch
parameter_list|)
define|\
value|d[1] = digs[(x)& 0xf]; \ 	d[0] = digs[((x)>>4)&0xf]; \ 	ch += ((x)& 0xff);
end_define

begin_define
define|#
directive|define
name|ISHEX
parameter_list|(
name|x
parameter_list|)
value|(hex_value[(unsigned char)(x)] != NOT_HEX)
end_define

begin_function
specifier|static
name|void
name|DEFUN_VOID
parameter_list|(
name|srec_init
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
name|boolean
name|inited
init|=
name|false
decl_stmt|;
if|if
condition|(
name|inited
operator|==
name|false
condition|)
block|{
name|inited
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hex_value
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|hex_value
index|[
name|i
index|]
operator|=
name|NOT_HEX
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|hex_value
index|[
name|i
operator|+
literal|'0'
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|hex_value
index|[
name|i
operator|+
literal|'a'
index|]
operator|=
name|i
operator|+
literal|10
expr_stmt|;
name|hex_value
index|[
name|i
operator|+
literal|'A'
index|]
operator|=
name|i
operator|+
literal|10
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The maximum number of bytes on a line is FF */
end_comment

begin_define
define|#
directive|define
name|MAXCHUNK
value|0xff
end_define

begin_comment
comment|/* The number of bytes we fit onto a line on output */
end_comment

begin_define
define|#
directive|define
name|CHUNK
value|21
end_define

begin_comment
comment|/* We cannot output our srecords as we see them, we have to glue them    together, this is done in this structure : */
end_comment

begin_struct
struct|struct
name|srec_data_list_struct
block|{
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|bfd_vma
name|where
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|struct
name|srec_data_list_struct
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|srec_data_list_struct
name|srec_data_list_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|srec_data_struct
block|{
name|srec_data_list_type
modifier|*
name|head
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
block|}
name|tdata_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|enda
parameter_list|(
name|x
parameter_list|)
value|(x->vma + x->size)
end_define

begin_comment
comment|/*     called once per input s-record, used to work out vma and size of data.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|size_srec
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|address
operator|,
name|raw
operator|,
name|length
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
name|AND
name|bfd_vma
name|address
name|AND
name|bfd_byte
operator|*
name|raw
name|AND
name|unsigned
name|int
name|length
argument_list|)
block|{
if|if
condition|(
name|address
operator|<
name|low
condition|)
name|low
operator|=
name|address
expr_stmt|;
if|if
condition|(
name|address
operator|+
name|length
operator|>
name|high
condition|)
name|high
operator|=
name|address
operator|+
name|length
operator|-
literal|1
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  called once per input s-record, copies data from input into bfd_alloc'd area  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|fillup
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|address
operator|,
name|raw
operator|,
name|length
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
name|AND
name|bfd_vma
name|address
name|AND
name|bfd_byte
operator|*
name|raw
name|AND
name|unsigned
name|int
name|length
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_byte
modifier|*
name|dst
init|=
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|section
operator|->
name|used_by_bfd
operator|)
operator|+
name|address
operator|-
name|section
operator|->
name|vma
decl_stmt|;
comment|/* length -1 because we don't read in the checksum */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dst
operator|=
name|HEX
argument_list|(
name|raw
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|raw
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Pass over an s-record file, calling one of the above functions on each    record.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|pass_over
argument_list|,
operator|(
name|abfd
operator|,
name|func
operator|,
name|section
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|void
argument_list|(
argument|*func
argument_list|)
operator|(
operator|)
name|AND
name|asection
operator|*
name|section
argument_list|)
block|{
name|unsigned
name|int
name|bytes_on_line
decl_stmt|;
name|boolean
name|eof
init|=
name|false
decl_stmt|;
comment|/* To the front of the file */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
while|while
condition|(
name|eof
operator|==
name|false
condition|)
block|{
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|buffer
decl_stmt|;
name|char
name|type
decl_stmt|;
name|bfd_vma
name|address
init|=
literal|0
decl_stmt|;
comment|/* Find first 'S' */
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|!=
literal|'S'
operator|&&
operator|!
name|eof
condition|)
block|{
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eof
condition|)
break|break;
name|src
operator|++
expr_stmt|;
comment|/* Fetch the type and the length */
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|type
operator|=
operator|*
name|src
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
break|break;
name|bytes_on_line
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_on_line
operator|>
name|MAXCHUNK
operator|/
literal|2
condition|)
break|break;
name|src
operator|+=
literal|2
expr_stmt|;
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
name|bytes_on_line
operator|*
literal|2
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'5'
case|:
comment|/* Prologue - ignore */
break|break;
case|case
literal|'3'
case|:
name|address
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|bytes_on_line
operator|--
expr_stmt|;
case|case
literal|'2'
case|:
name|address
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
operator||
operator|(
name|address
operator|<<
literal|8
operator|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|bytes_on_line
operator|--
expr_stmt|;
case|case
literal|'1'
case|:
name|address
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
operator||
operator|(
name|address
operator|<<
literal|8
operator|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|address
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
operator||
operator|(
name|address
operator|<<
literal|8
operator|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|bytes_on_line
operator|-=
literal|2
expr_stmt|;
name|func
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|,
name|src
argument_list|,
name|bytes_on_line
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|srec_object_p
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|srec_init
argument_list|()
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
name|b
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|!=
literal|'S'
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|3
index|]
argument_list|)
condition|)
return|return
operator|(
name|bfd_target
operator|*
operator|)
name|NULL
return|;
comment|/* We create one section called .text for all the contents,       and allocate enough room for the entire file.  */
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|section
operator|->
name|vma
operator|=
literal|0xffffffff
expr_stmt|;
name|low
operator|=
literal|0xffffffff
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
name|pass_over
argument_list|(
name|abfd
argument_list|,
name|size_srec
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
name|high
operator|-
name|low
expr_stmt|;
name|section
operator|->
name|vma
operator|=
name|low
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|srec_get_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
argument_list|)
block|{
if|if
condition|(
name|section
operator|->
name|used_by_bfd
operator|==
operator|(
name|PTR
operator|)
name|NULL
condition|)
block|{
name|section
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|pass_over
argument_list|(
name|abfd
argument_list|,
name|fillup
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|location
argument_list|,
call|(
name|PTR
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|section
operator|->
name|used_by_bfd
operator|)
operator|+
name|offset
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|srec_set_arch_mach
argument_list|,
operator|(
name|abfd
operator|,
name|arch
operator|,
name|machine
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|enum
name|bfd_architecture
name|arch
name|AND
name|unsigned
name|long
name|machine
argument_list|)
block|{
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* we have to save up all the Srecords for a splurge before output,    also remember   */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|srec_set_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|bytes_to_do
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|bytes_to_do
argument_list|)
block|{
name|tdata_type
modifier|*
name|tdata
init|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
decl_stmt|;
name|srec_data_list_type
modifier|*
name|entry
init|=
operator|(
name|srec_data_list_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|srec_data_list_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|&&
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
block|{
name|unsigned
name|char
modifier|*
name|data
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|bytes_to_do
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|location
argument_list|,
name|bytes_to_do
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|vma
operator|+
name|offset
operator|+
name|bytes_to_do
operator|)
operator|<=
literal|0xffff
condition|)
block|{      }
elseif|else
if|if
condition|(
operator|(
name|section
operator|->
name|vma
operator|+
name|offset
operator|+
name|bytes_to_do
operator|)
operator|<=
literal|0xffffff
operator|&&
name|tdata
operator|->
name|type
operator|<
literal|2
condition|)
block|{
name|tdata
operator|->
name|type
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|tdata
operator|->
name|type
operator|=
literal|3
expr_stmt|;
block|}
name|entry
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|entry
operator|->
name|where
operator|=
name|section
operator|->
name|vma
operator|+
name|offset
expr_stmt|;
name|entry
operator|->
name|size
operator|=
name|bytes_to_do
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|tdata
operator|->
name|head
expr_stmt|;
name|tdata
operator|->
name|head
operator|=
name|entry
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Write a record of type, of the supplied number of bytes. The    supplied bytes and length don't have a checksum. That's worked out    here */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|srec_write_record
argument_list|,
operator|(
name|abfd
operator|,
name|type
operator|,
name|address
operator|,
name|data
operator|,
name|end
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
name|type
name|AND
name|bfd_vma
name|address
name|AND
name|CONST
name|unsigned
name|char
operator|*
name|data
name|AND
name|CONST
name|unsigned
name|char
operator|*
name|end
argument_list|)
block|{
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
name|unsigned
name|int
name|check_sum
init|=
literal|0
decl_stmt|;
name|unsigned
name|CONST
name|char
modifier|*
name|src
init|=
name|data
decl_stmt|;
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|length
decl_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'S'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'0'
operator|+
name|type
expr_stmt|;
name|length
operator|=
name|dst
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
comment|/* leave room for dst*/
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|3
case|:
case|case
literal|7
case|:
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|>>
literal|24
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
case|case
literal|8
case|:
case|case
literal|2
case|:
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|>>
literal|16
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
case|case
literal|9
case|:
case|case
literal|1
case|:
case|case
literal|0
case|:
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|>>
literal|8
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
for|for
control|(
name|src
operator|=
name|data
init|;
name|src
operator|<
name|end
condition|;
name|src
operator|++
control|)
block|{
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|*
name|src
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Fill in the length */
name|TOHEX
argument_list|(
name|length
argument_list|,
operator|(
name|dst
operator|-
name|length
operator|)
operator|/
literal|2
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|check_sum
operator|&=
literal|0xff
expr_stmt|;
name|check_sum
operator|=
literal|255
operator|-
name|check_sum
expr_stmt|;
name|TOHEX
argument_list|(
name|dst
argument_list|,
name|check_sum
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
name|dst
operator|-
name|buffer
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|srec_write_header
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|unsigned
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* I'll put an arbitary 40 char limit on header size */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
operator|&&
name|abfd
operator|->
name|filename
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dst
operator|++
operator|=
name|abfd
operator|->
name|filename
index|[
name|i
index|]
expr_stmt|;
block|}
name|srec_write_record
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|srec_write_section
argument_list|,
operator|(
name|abfd
operator|,
name|tdata
operator|,
name|list
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|tdata_type
operator|*
name|tdata
name|AND
name|srec_data_list_type
operator|*
name|list
argument_list|)
block|{
name|unsigned
name|int
name|bytes_written
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|location
init|=
name|list
operator|->
name|data
decl_stmt|;
while|while
condition|(
name|bytes_written
operator|<
name|list
operator|->
name|size
condition|)
block|{
name|bfd_vma
name|address
decl_stmt|;
name|unsigned
name|int
name|bytes_this_chunk
init|=
name|list
operator|->
name|size
operator|-
name|bytes_written
decl_stmt|;
if|if
condition|(
name|bytes_this_chunk
operator|>
name|CHUNK
condition|)
block|{
name|bytes_this_chunk
operator|=
name|CHUNK
expr_stmt|;
block|}
name|address
operator|=
name|list
operator|->
name|where
operator|+
name|bytes_written
expr_stmt|;
name|srec_write_record
argument_list|(
name|abfd
argument_list|,
name|tdata
operator|->
name|type
argument_list|,
name|address
argument_list|,
name|location
argument_list|,
name|location
operator|+
name|bytes_this_chunk
argument_list|)
expr_stmt|;
name|bytes_written
operator|+=
name|bytes_this_chunk
expr_stmt|;
name|location
operator|+=
name|bytes_this_chunk
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|srec_write_terminator
argument_list|,
operator|(
name|abfd
operator|,
name|tdata
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|tdata_type
operator|*
name|tdata
argument_list|)
block|{
name|unsigned
name|char
name|buffer
index|[
literal|2
index|]
decl_stmt|;
name|srec_write_record
argument_list|(
name|abfd
argument_list|,
literal|10
operator|-
name|tdata
operator|->
name|type
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|,
name|buffer
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|srec_mkobject
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|tdata_type
modifier|*
name|tdata
init|=
operator|(
name|tdata_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|tdata_type
argument_list|)
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|=
name|tdata
expr_stmt|;
name|tdata
operator|->
name|type
operator|=
literal|1
expr_stmt|;
name|tdata
operator|->
name|head
operator|=
operator|(
name|srec_data_list_type
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|srec_write_object_contents
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|int
name|bytes_written
decl_stmt|;
name|tdata_type
modifier|*
name|tdata
init|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
decl_stmt|;
name|srec_data_list_type
modifier|*
name|list
decl_stmt|;
name|bytes_written
operator|=
literal|0
expr_stmt|;
name|srec_write_header
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Now wander though all the sections provided and output them */
name|list
operator|=
name|tdata
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|list
operator|!=
operator|(
name|srec_data_list_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|srec_write_section
argument_list|(
name|abfd
argument_list|,
name|tdata
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
name|srec_write_terminator
argument_list|(
name|abfd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|srec_sizeof_headers
argument_list|,
operator|(
name|abfd
operator|,
name|exec
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|boolean
name|exec
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|DEFUN
argument_list|(
name|srec_make_empty_symbol
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|asymbol
modifier|*
name|new
init|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
name|new
return|;
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|FOO
value|PROTO
end_define

begin_define
define|#
directive|define
name|srec_new_section_hook
value|(FOO(boolean, (*), (bfd *, asection *)))bfd_true
end_define

begin_define
define|#
directive|define
name|srec_get_symtab_upper_bound
value|(PROTO(unsigned int, (*),(bfd *)))bfd_false
end_define

begin_define
define|#
directive|define
name|srec_get_symtab
value|(FOO(unsigned int, (*), (bfd *, asymbol **)))bfd_0
end_define

begin_define
define|#
directive|define
name|srec_get_reloc_upper_bound
value|(FOO(unsigned int, (*),(bfd*, asection *)))bfd_false
end_define

begin_define
define|#
directive|define
name|srec_canonicalize_reloc
value|(FOO(unsigned int, (*),(bfd*,asection *, arelent **, asymbol **))) bfd_0
end_define

begin_define
define|#
directive|define
name|srec_print_symbol
value|(FOO(void,(*),(bfd *, PTR, asymbol *, bfd_print_symbol_type))) bfd_void
end_define

begin_define
define|#
directive|define
name|srec_openr_next_archived_file
value|(FOO(bfd *, (*), (bfd*,bfd*))) bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|srec_find_nearest_line
value|(FOO(boolean, (*),(bfd*,asection*,asymbol**,bfd_vma, CONST char**, CONST char**, unsigned int *))) bfd_false
end_define

begin_define
define|#
directive|define
name|srec_generic_stat_arch_elt
value|(FOO(int, (*), (bfd *,struct stat *))) bfd_0
end_define

begin_define
define|#
directive|define
name|srec_core_file_failing_command
value|(char *(*)())(bfd_nullvoidptr)
end_define

begin_define
define|#
directive|define
name|srec_core_file_failing_signal
value|(int (*)())bfd_0
end_define

begin_define
define|#
directive|define
name|srec_core_file_matches_executable_p
value|(FOO(boolean, (*),(bfd*, bfd*)))bfd_false
end_define

begin_define
define|#
directive|define
name|srec_slurp_armap
value|bfd_true
end_define

begin_define
define|#
directive|define
name|srec_slurp_extended_name_table
value|bfd_true
end_define

begin_define
define|#
directive|define
name|srec_truncate_arname
value|(void (*)())bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|srec_write_armap
value|(FOO( boolean, (*),(bfd *, unsigned int, struct orl *, unsigned int, int))) bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|srec_get_lineno
value|(struct lineno_cache_entry *(*)())bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|srec_close_and_cleanup
value|bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|srec_bfd_debug_info_start
value|bfd_void
end_define

begin_define
define|#
directive|define
name|srec_bfd_debug_info_end
value|bfd_void
end_define

begin_define
define|#
directive|define
name|srec_bfd_debug_info_accumulate
value|(FOO(void, (*), (bfd *,	 asection *))) bfd_void
end_define

begin_define
define|#
directive|define
name|srec_bfd_get_relocated_section_contents
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|srec_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_decl_stmt
name|bfd_target
name|srec_vec
init|=
block|{
literal|"srec"
block|,
comment|/* name */
name|bfd_target_srec_flavour
block|,
name|true
block|,
comment|/* target byte order */
name|true
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|DYNAMIC
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
literal|1
block|,
comment|/* minimum alignment */
name|_do_getb64
block|,
name|_do_putb64
block|,
name|_do_getb32
block|,
name|_do_putb32
block|,
name|_do_getb16
block|,
name|_do_putb16
block|,
comment|/* data */
name|_do_getb64
block|,
name|_do_putb64
block|,
name|_do_getb32
block|,
name|_do_putb32
block|,
name|_do_getb16
block|,
name|_do_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|srec_object_p
block|,
comment|/* bfd_check_format */
operator|(
expr|struct
name|bfd_target
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|bfd_nullvoidptr
block|,
operator|(
expr|struct
name|bfd_target
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|bfd_nullvoidptr
block|,   }
block|,
block|{
name|bfd_false
block|,
name|srec_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|srec_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|JUMP_TABLE
argument_list|(
argument|srec
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

