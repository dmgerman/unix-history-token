begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD library support routines for the i960 architecture.    Copyright (C) 1990-1991 Free Software Foundation, Inc.    Hacked by Steve Chamberlain of Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* This routine is provided a string, and tries to work out if it    could possibly refer to the i960 machine pointed at in the    info_struct pointer */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|scan_960_mach
argument_list|,
operator|(
name|ap
operator|,
name|string
operator|)
argument_list|,
name|CONST
name|bfd_arch_info_type
operator|*
name|ap
name|AND
name|CONST
name|char
operator|*
name|string
argument_list|)
block|{
name|unsigned
name|long
name|machine
decl_stmt|;
comment|/* Look for the string i960, or somesuch at the front of the string  */
if|if
condition|(
name|strncmp
argument_list|(
literal|"i960"
argument_list|,
name|string
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* no match, can be us */
return|return
name|false
return|;
block|}
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* i960 on it's own means core to us*/
if|if
condition|(
name|ap
operator|->
name|mach
operator|==
name|bfd_mach_i960_core
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|!=
literal|':'
condition|)
block|{
return|return
name|false
return|;
block|}
name|string
operator|++
expr_stmt|;
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|false
return|;
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'c'
operator|&&
name|string
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|string
index|[
literal|2
index|]
operator|==
literal|'r'
operator|&&
name|string
index|[
literal|3
index|]
operator|==
literal|'e'
operator|&&
name|string
index|[
literal|4
index|]
operator|==
literal|'\0'
condition|)
name|machine
operator|=
name|bfd_mach_i960_core
expr_stmt|;
elseif|else
if|if
condition|(
name|string
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|string
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
comment|/* rest are 2-char */
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'k'
operator|&&
name|string
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
name|machine
operator|=
name|bfd_mach_i960_kb_sb
expr_stmt|;
elseif|else
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|string
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
name|machine
operator|=
name|bfd_mach_i960_kb_sb
expr_stmt|;
elseif|else
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'m'
operator|&&
name|string
index|[
literal|1
index|]
operator|==
literal|'c'
condition|)
name|machine
operator|=
name|bfd_mach_i960_mc
expr_stmt|;
elseif|else
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'x'
operator|&&
name|string
index|[
literal|1
index|]
operator|==
literal|'a'
condition|)
name|machine
operator|=
name|bfd_mach_i960_xa
expr_stmt|;
elseif|else
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'c'
operator|&&
name|string
index|[
literal|1
index|]
operator|==
literal|'a'
condition|)
name|machine
operator|=
name|bfd_mach_i960_ca
expr_stmt|;
elseif|else
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'k'
operator|&&
name|string
index|[
literal|1
index|]
operator|==
literal|'a'
condition|)
name|machine
operator|=
name|bfd_mach_i960_ka_sa
expr_stmt|;
elseif|else
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|string
index|[
literal|1
index|]
operator|==
literal|'a'
condition|)
name|machine
operator|=
name|bfd_mach_i960_ka_sa
expr_stmt|;
else|else
return|return
name|false
return|;
if|if
condition|(
name|machine
operator|==
name|ap
operator|->
name|mach
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/* This routine is provided two arch_infos and works out the i960    machine which would be compatible with both and returns a pointer    to its info structure */
end_comment

begin_decl_stmt
name|CONST
name|bfd_arch_info_type
modifier|*
name|DEFUN
argument_list|(
name|compatible
argument_list|,
operator|(
name|a
operator|,
name|b
operator|)
argument_list|,
name|CONST
name|bfd_arch_info_type
operator|*
name|a
name|AND
name|CONST
name|bfd_arch_info_type
operator|*
name|b
argument_list|)
block|{
comment|/* The i960 has two distinct subspecies which may not interbreed:      CORE CA                CORE KA KB MC XA      Any architecture on the same line is compatible, the one on      the right is the least restrictive.              We represent this information in an array, each machine to a side */
define|#
directive|define
name|ERROR
value|0
define|#
directive|define
name|CORE
value|bfd_mach_i960_core
comment|/*1*/
define|#
directive|define
name|KA
value|bfd_mach_i960_ka_sa
comment|/*2*/
define|#
directive|define
name|KB
value|bfd_mach_i960_kb_sb
comment|/*3*/
define|#
directive|define
name|MC
value|bfd_mach_i960_mc
comment|/*4*/
define|#
directive|define
name|XA
value|bfd_mach_i960_xa
comment|/*5*/
define|#
directive|define
name|CA
value|bfd_mach_i960_ca
comment|/*6*/
specifier|static
name|CONST
name|char
name|matrix
index|[
literal|7
index|]
index|[
literal|7
index|]
init|=
block|{
name|ERROR
block|,
name|CORE
block|,
name|KA
block|,
name|KB
block|,
name|MC
block|,
name|XA
block|,
name|CA
block|,
name|CORE
block|,
name|CORE
block|,
name|KA
block|,
name|KB
block|,
name|MC
block|,
name|XA
block|,
name|CA
block|,
name|KA
block|,
name|KA
block|,
name|KA
block|,
name|KB
block|,
name|MC
block|,
name|XA
block|,
name|ERROR
block|,
name|KB
block|,
name|KB
block|,
name|KB
block|,
name|KB
block|,
name|MC
block|,
name|XA
block|,
name|ERROR
block|,
name|MC
block|,
name|MC
block|,
name|MC
block|,
name|MC
block|,
name|MC
block|,
name|XA
block|,
name|ERROR
block|,
name|XA
block|,
name|XA
block|,
name|XA
block|,
name|XA
block|,
name|XA
block|,
name|XA
block|,
name|ERROR
block|,
name|CA
block|,
name|CA
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|,
name|ERROR
block|,
name|CA
block|}
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|arch
operator|!=
name|b
operator|->
name|arch
operator|||
name|matrix
index|[
name|a
operator|->
name|mach
index|]
index|[
name|b
operator|->
name|mach
index|]
operator|==
name|ERROR
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
operator|(
name|a
operator|->
name|mach
operator|==
name|matrix
index|[
name|a
operator|->
name|mach
index|]
index|[
name|b
operator|->
name|mach
index|]
operator|)
condition|?
name|a
else|:
name|b
return|;
block|}
block|}
end_decl_stmt

begin_function_decl
name|int
name|bfd_default_scan_num_mach
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|d
parameter_list|)
define|\
value|{ 32, 32, 8,bfd_arch_i960,a,"i960",b,3,d,compatible,scan_960_mach,0,}
end_define

begin_decl_stmt
specifier|static
name|bfd_arch_info_type
name|arch_info_struct
index|[]
init|=
block|{
name|N
argument_list|(
name|bfd_mach_i960_core
argument_list|,
literal|"i960:core"
argument_list|,
name|true
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_i960_ka_sa
argument_list|,
literal|"i960:ka_sa"
argument_list|,
name|false
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_i960_kb_sb
argument_list|,
literal|"i960:kb_sb"
argument_list|,
name|false
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_i960_mc
argument_list|,
literal|"i960:mc"
argument_list|,
name|false
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_i960_xa
argument_list|,
literal|"i960:xa"
argument_list|,
name|false
argument_list|)
block|,
name|N
argument_list|(
argument|bfd_mach_i960_ca
argument_list|,
literal|"i960:ca"
argument_list|,
argument|false
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|DEFUN_VOID
parameter_list|(
name|bfd_i960_arch
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|arch_info_struct
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|arch_info_struct
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|bfd_arch_linkin
argument_list|(
name|arch_info_struct
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

