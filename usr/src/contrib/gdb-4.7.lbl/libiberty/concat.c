begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Concatenate variable number of strings.    Copyright (C) 1991 Free Software Foundation, Inc.    Written by Fred Fish @ Cygnus Support  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  NAME  	concat -- concatenate a variable number of strings  SYNOPSIS  	#include<varargs.h>  	char *concat (s1, s2, s3, ..., NULL)  DESCRIPTION  	Concatenate a variable number of strings and return the result 	in freshly malloc'd memory.  	Returns NULL if insufficient memory is available.  The argument 	list is terminated by the first NULL pointer encountered.  Pointers 	to empty strings are ignored.  NOTES  	This function uses xmalloc() which is expected to be a front end 	function to malloc() that deals with low memory situations.  In 	typical use, if malloc() returns NULL then xmalloc() diverts to an 	error handler routine which never returns, and thus xmalloc will 	never return a NULL pointer.  If the client application wishes to 	deal with low memory situations itself, it should supply an xmalloc 	that just directly invokes malloc and blindly returns whatever 	malloc returns. */
end_comment

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_define
define|#
directive|define
name|NULLP
value|(char *)0
end_define

begin_function_decl
specifier|extern
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
specifier|register
name|int
name|length
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|newstr
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
name|va_list
name|args
decl_stmt|;
comment|/* First compute the size of the result and get sufficient memory. */
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|arg
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULLP
condition|)
block|{
name|length
operator|+=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|newstr
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* Now copy the individual pieces to the result string. */
if|if
condition|(
name|newstr
operator|!=
name|NULLP
condition|)
block|{
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|end
operator|=
name|newstr
expr_stmt|;
while|while
condition|(
operator|(
name|arg
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULLP
condition|)
block|{
while|while
condition|(
operator|*
name|arg
condition|)
block|{
operator|*
name|end
operator|++
operator|=
operator|*
name|arg
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|end
operator|=
literal|'\000'
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|newstr
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_comment
comment|/* Simple little test driver. */
end_comment

begin_function
name|main
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\"\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"a\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"a"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"ab\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"abc\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"abcd\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"ab"
argument_list|,
literal|"cd"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"abcde\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"ab"
argument_list|,
literal|"c"
argument_list|,
literal|"de"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"abcdef\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|""
argument_list|,
literal|"a"
argument_list|,
literal|""
argument_list|,
literal|"bcd"
argument_list|,
literal|"ef"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

