begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_define
define|#
directive|define
name|CTIME
value|1
end_define

begin_define
define|#
directive|define
name|ASCTIME
value|2
end_define

begin_define
define|#
directive|define
name|TZSET
value|3
end_define

begin_define
define|#
directive|define
name|LOCALTIME
value|4
end_define

begin_define
define|#
directive|define
name|GMTIME
value|5
end_define

begin_define
define|#
directive|define
name|OFFTIME
value|6
end_define

begin_function_decl
specifier|extern
name|struct
name|tm
modifier|*
name|offtime
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|,
name|junk
index|[
literal|52
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|l
decl_stmt|,
name|off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|timeout
argument_list|()
decl_stmt|,
name|checkppid
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tm
name|tmtmp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|itimerval
name|it
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|getdtablesize
argument_list|()
init|;
operator|--
name|i
operator|>
literal|2
condition|;
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/*  * Need a timer running while we disassociate from the control terminal  * in case of a modem line which has lost carrier. */
name|timerclear
argument_list|(
operator|&
name|it
operator|.
name|it_interval
argument_list|)
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|5
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|it
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|ioctl
argument_list|(
name|i
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Now start a timer with one minute refresh.  In the signal service  * routine, check the parent process id to see if this process has  * been orphaned and if so exit.  This is primarily aimed at removing  * the 'ctimed' process left behind by 'sendmail's multi-fork startup  * but may prove useful in preventing accumulation of 'ctimed' processes  * in other circumstances as well.  Normally this process is short  * lived. */
name|it
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|60
expr_stmt|;
name|it
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|60
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|checkppid
argument_list|)
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|it
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTIME
case|:
name|l
operator|=
literal|0L
expr_stmt|;
name|getb
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|l
argument_list|,
sizeof|sizeof
name|l
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ctime
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|cp
argument_list|,
literal|26
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASCTIME
case|:
name|getb
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|tmtmp
argument_list|,
sizeof|sizeof
name|tmtmp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|asctime
argument_list|(
operator|&
name|tmtmp
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|cp
argument_list|,
literal|26
argument_list|)
expr_stmt|;
break|break;
case|case
name|TZSET
case|:
operator|(
name|void
operator|)
name|tzset
argument_list|()
expr_stmt|;
break|break;
case|case
name|LOCALTIME
case|:
name|l
operator|=
literal|0L
expr_stmt|;
name|getb
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|l
argument_list|,
sizeof|sizeof
name|l
argument_list|)
expr_stmt|;
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|junk
argument_list|,
name|tp
operator|->
name|tm_zone
argument_list|)
expr_stmt|;
name|junk
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|junk
argument_list|,
literal|24
argument_list|)
expr_stmt|;
break|break;
case|case
name|GMTIME
case|:
name|l
operator|=
literal|0L
expr_stmt|;
name|getb
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|l
argument_list|,
sizeof|sizeof
name|l
argument_list|)
expr_stmt|;
name|tp
operator|=
name|gmtime
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|junk
argument_list|,
name|tp
operator|->
name|tm_zone
argument_list|)
expr_stmt|;
name|junk
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|junk
argument_list|,
literal|24
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFTIME
case|:
name|getb
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|l
argument_list|,
sizeof|sizeof
name|l
argument_list|)
expr_stmt|;
name|getb
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|off
argument_list|,
sizeof|sizeof
name|off
argument_list|)
expr_stmt|;
name|tp
operator|=
name|offtime
argument_list|(
operator|&
name|l
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|(
literal|"switch"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_macro
name|getb
argument_list|(
argument|f
argument_list|,
argument|p
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|i
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return;
name|p
operator|+=
name|i
expr_stmt|;
name|n
operator|-=
name|i
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|timeout
argument_list|()
end_macro

begin_block
block|{
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|checkppid
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|getppid
argument_list|()
operator|==
literal|1
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

