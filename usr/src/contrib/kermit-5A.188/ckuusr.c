begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
name|char
modifier|*
name|userv
init|=
literal|"User Interface 5A(092), 23 Nov 92"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  C K U U S R --  "User Interface" for Unix Kermit (Part 1)  */
end_comment

begin_comment
comment|/*   Author: Frank da Cruz (fdc@columbia.edu, FDCCU@CUVMA.BITNET),   Columbia University Center for Computing Activities.   First released January 1985.   Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University. */
end_comment

begin_comment
comment|/*   NOTE: Because of the massive additions in functionality, and therefore   the increase in the number of commands, much code was moved from here to   the two new modules, ckuus4.c and ckuus5.c.  This module now contains only   the top-level command keyword table, the SET command keyword table, and   the top-level interactive command parser/dispatcher.  ckuus3.c contains the   rest of the SET and REMOTE command parsers; ckuus2.c contains the help   command parser and help text strings, and ckuus4.c and ckuus5.c contain   miscellaneous pieces that logically belong in the ckuusr.c file but had to   be moved because of size problems with some C compilers / linkers.   Later...  as the other modules became too large, a ckuus6.c was created.   Still later...  ckuus7.c.   Also: ckuusy.c contains the UNIX-style command-line interface;   ckuusx.c contains routines needed by both the command-line interface and   the interactive command parser. */
end_comment

begin_comment
comment|/*  The ckuus*.c modules depend on the existence of C library features like fopen,  fgets, feof, (f)printf, argv/argc, etc.  Other functions that are likely to  vary among Unix implementations -- like setting terminal modes or interrupts  -- are invoked via calls to functions that are defined in the system-  dependent modules, ck?[ft]io.c.  The command line parser processes any  arguments found on the command line, as passed to main() via argv/argc.  The  interactive parser uses the facilities of the cmd package (developed for this  program, but usable by any program).  Any command parser may be substituted  for this one.  The only requirements for the Kermit command parser are these:  1. Set parameters via global variables like duplex, speed, ttname, etc.  See    ckmain.c for the declarations and descriptions of these variables.  2. If a command can be executed without the use of Kermit protocol, then    execute the command directly and set the variable sstate to 0. Examples    include 'set' commands, local directory listings, the 'connect' command.  3. If a command requires the Kermit protocol, set the following variables:      sstate                             string data       'x' (enter server mode)            (none)       'r' (send a 'get' command)         cmarg, cmarg2       'v' (enter receive mode)           cmarg2       'g' (send a generic command)       cmarg       's' (send files)                   nfils, cmarg& cmarg2 OR cmlist       'c' (send a remote host command)   cmarg      cmlist is an array of pointers to strings.     cmarg, cmarg2 are pointers to strings.     nfils is an integer.      cmarg can be a filename string (possibly wild), or        a pointer to a prefabricated generic command string, or        a pointer to a host command string.     cmarg2 is the name to send a single file under, or        the name under which to store an incoming file; must not be wild.        If it's the name for receiving, a null value means to store the        file under the name it arrives with.     cmlist is a list of nonwild filenames, such as passed via argv.     nfils is an integer, interpreted as follows:       -1: filespec (possibly wild) in cmarg, must be expanded internally.        0: send from stdin (standard input).>0: number of files to send, from cmlist.   The screen() function is used to update the screen during file transfer.  The tlog() function writes to a transaction log.  The debug() function writes to a debugging log.  The intmsg() and chkint() functions provide the user i/o for interrupting    file transfers. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOICP
end_ifndef

begin_comment
comment|/* Includes */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_include
include|#
directive|include
file|"ckcasc.h"
end_include

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_include
include|#
directive|include
file|"ckuusr.h"
end_include

begin_include
include|#
directive|include
file|"ckcxla.h"
end_include

begin_include
include|#
directive|include
file|"ckcnet.h"
end_include

begin_comment
comment|/* Network symbols */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|datageneral
end_ifdef

begin_include
include|#
directive|include
file|<packets:common.h>
end_include

begin_define
define|#
directive|define
name|fgets
parameter_list|(
name|stringbuf
parameter_list|,
name|max
parameter_list|,
name|fd
parameter_list|)
value|dg_fgets(stringbuf,max,fd)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* datageneral */
end_comment

begin_comment
comment|/* External Kermit Variables, see ckmain.c for description. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|size
decl_stmt|,
name|local
decl_stmt|,
name|sndsrc
decl_stmt|,
name|xitsta
decl_stmt|,
name|server
decl_stmt|,
name|displa
decl_stmt|,
name|binary
decl_stmt|,
name|msgflg
decl_stmt|,
name|escape
decl_stmt|,
name|duplex
decl_stmt|,
name|nfils
decl_stmt|,
name|quiet
decl_stmt|,
name|tlevel
decl_stmt|,
name|pflag
decl_stmt|,
name|zincnt
decl_stmt|,
name|atcapr
decl_stmt|,
name|atdiso
decl_stmt|,
name|verwho
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|vernum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|versio
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ckxsys
decl_stmt|,
modifier|*
name|cmarg
decl_stmt|,
modifier|*
name|cmarg2
decl_stmt|,
modifier|*
modifier|*
name|cmlist
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOHELP
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|introtxt
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOHELP */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|PWDCMD
decl_stmt|,
modifier|*
name|WHOCMD
decl_stmt|,
modifier|*
name|TYPCMD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|ttname
index|[]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOFRILLS
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|rmailf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MAIL command items */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|optbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOFRILLS */
end_comment

begin_decl_stmt
specifier|extern
name|CHAR
name|sstate
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NETCONN
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|network
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Have active network connection */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETCONN */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOMSEND
end_ifndef

begin_comment
comment|/* Multiple SEND */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|msfiles
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOMSEND */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|fspec
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Most recent filespec */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOCSETS
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|nfilc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|fcstab
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOCSETS */
end_comment

begin_decl_stmt
name|int
name|rcflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to home directory string */
end_comment

begin_decl_stmt
name|int
name|repars
decl_stmt|,
comment|/* Reparse needed */
name|techo
init|=
literal|0
decl_stmt|,
comment|/* Take echo */
name|terror
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Take error action, 1 = quit */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSCRIPT
end_ifndef

begin_decl_stmt
name|int
name|secho
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSCRIPT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOXMIT
end_ifndef

begin_comment
comment|/* Variables for TRANSMIT command */
end_comment

begin_decl_stmt
name|int
name|xmitx
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to echo during TRANSMIT */
end_comment

begin_decl_stmt
name|int
name|xmitf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character to fill empty lines */
end_comment

begin_decl_stmt
name|int
name|xmitl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 = Don't send linefeed too */
end_comment

begin_decl_stmt
name|int
name|xmitp
init|=
name|LF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Host line prompt */
end_comment

begin_decl_stmt
name|int
name|xmits
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use shift-in/shift-out, 0 = no */
end_comment

begin_decl_stmt
name|int
name|xmitw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Milliseconds to pause during TRANSMIT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOXMIT */
end_comment

begin_comment
comment|/* Declarations from ck?fio.c module */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|SPACMD
decl_stmt|,
modifier|*
name|SPACM2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SPACE commands */
end_comment

begin_comment
comment|/* Command-oriented items */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|cmdbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffers */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|atmbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character buffer for anything */
end_comment

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|ifcmd
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
name|cmdbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffers */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|atmbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|line
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character buffer for anything */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|ifcmd
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to line buffer */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_decl_stmt
specifier|extern
name|char
name|inpbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for INPUT and REINPUT */
end_comment

begin_decl_stmt
name|char
modifier|*
name|inpbp
init|=
name|inpbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And pointer to same */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|lblbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for labels */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_decl_stmt
name|char
name|psave
index|[
literal|80
index|]
init|=
block|{
name|NUL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For saving& restoring prompt */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|tmpbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary buffer */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|success
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command success/failure flag */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_decl_stmt
name|int
comment|/* SET INPUT parameters. */
name|indef
init|=
literal|5
decl_stmt|,
comment|/* 5 seconds default timeout */
name|intime
init|=
literal|0
decl_stmt|,
comment|/* 0 = proceed */
name|incase
init|=
literal|0
decl_stmt|,
comment|/* 0 = ignore */
name|inecho
init|=
literal|1
decl_stmt|,
comment|/* 1 = echo on */
name|insilence
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 = no silence constraint */
end_comment

begin_decl_stmt
name|int
name|maclvl
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro nesting level */
end_comment

begin_decl_stmt
name|int
name|mecho
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro echo, 0 = don't */
end_comment

begin_decl_stmt
name|int
name|merror
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro error action */
end_comment

begin_decl_stmt
name|char
name|varnam
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For variable names */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|macargc
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGC from macro invocation */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|m_arg
index|[
name|MACLEVEL
index|]
index|[
name|NARGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of macro arguments */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|a_ptr
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array pointers */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|a_dim
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array dimensions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|cmdptr
modifier|*
name|cmdstk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The command stack itself */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|struct
name|cmdptr
name|cmdstk
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The command stack itself */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|cmdlvl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current position in command stack */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_decl_stmt
specifier|static
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local workers */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|xsystem
parameter_list|(
name|s
parameter_list|)
value|zsyscmd(s)
end_define

begin_comment
comment|/* Top-Level Interactive Command Keyword Table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|cmdtab
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|NOPUSH
literal|"!"
block|,
name|XXSHE
block|,
name|CM_INV
block|,
comment|/* shell escape */
endif|#
directive|endif
comment|/* NOPUSH */
literal|"#"
block|,
name|XXCOM
block|,
name|CM_INV
block|,
comment|/* comment */
ifndef|#
directive|ifndef
name|NOSPL
literal|":"
block|,
name|XXLBL
block|,
name|CM_INV
block|,
comment|/* label */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOPUSH
literal|"@"
block|,
name|XXSHE
block|,
name|CM_INV
block|,
comment|/* DCL escape */
endif|#
directive|endif
comment|/* NOPUSH */
ifndef|#
directive|ifndef
name|NOSPL
literal|"asg"
block|,
name|XXASS
block|,
name|CM_INV
block|,
comment|/* invisible synonym for assign */
literal|"ask"
block|,
name|XXASK
block|,
literal|0
block|,
comment|/* ask */
literal|"askq"
block|,
name|XXASKQ
block|,
literal|0
block|,
comment|/* ask quietly */
literal|"assign"
block|,
name|XXASS
block|,
literal|0
block|,
comment|/* assign */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"bug"
block|,
name|XXBUG
block|,
literal|0
block|,
comment|/* bug report instructions */
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"bye"
block|,
name|XXBYE
block|,
literal|0
block|,
comment|/* bye to remote server */
literal|"c"
block|,
name|XXCON
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
comment|/* invisible synonym for connect */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"cat"
block|,
name|XXTYP
block|,
name|CM_INV
block|,
comment|/* display a local file */
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"cd"
block|,
name|XXCWD
block|,
literal|0
block|,
comment|/* change directory */
literal|"check"
block|,
name|XXCHK
block|,
literal|0
block|,
comment|/* check for a feature */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"clear"
block|,
name|XXCLE
block|,
literal|0
block|,
comment|/* clear input buffer */
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"close"
block|,
name|XXCLO
block|,
literal|0
block|,
comment|/* close a log file */
ifdef|#
directive|ifdef
name|NOFRILLS
literal|"comment"
block|,
name|XXCOM
block|,
name|CM_INV
block|,
comment|/* comment */
else|#
directive|else
literal|"comment"
block|,
name|XXCOM
block|,
literal|0
block|,
comment|/* comment */
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"connect"
block|,
name|XXCON
block|,
literal|0
block|,
comment|/* connect to remote system */
literal|"cwd"
block|,
name|XXCWD
block|,
name|CM_INV
block|,
comment|/* invisisble synonym for cd */
ifndef|#
directive|ifndef
name|NOSPL
literal|"dcl"
block|,
name|XXDCL
block|,
name|CM_INV
block|,
comment|/* declare an array */
literal|"declare"
block|,
name|XXDCL
block|,
literal|0
block|,
comment|/* declare an array */
literal|"decrement"
block|,
name|XXDEC
block|,
literal|0
block|,
comment|/* decrement a numeric variable */
literal|"define"
block|,
name|XXDEF
block|,
literal|0
block|,
comment|/* define a macro */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"delete"
block|,
name|XXDEL
block|,
literal|0
block|,
comment|/* delete a file */
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|NODIAL
literal|"dial"
block|,
name|XXDIAL
block|,
literal|0
block|,
comment|/* dial a phone number */
endif|#
directive|endif
comment|/* NODIAL */
ifndef|#
directive|ifndef
name|MAC
literal|"directory"
block|,
name|XXDIR
block|,
literal|0
block|,
comment|/* directory of files */
endif|#
directive|endif
comment|/* MAC */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"disable"
block|,
name|XXDIS
block|,
literal|0
block|,
comment|/* disable server function */
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|NOSPL
literal|"do"
block|,
name|XXDO
block|,
literal|0
block|,
comment|/* execute a macro */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"e-packet"
block|,
name|XXERR
block|,
name|CM_INV
block|,
comment|/* Send an Error packet */
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"echo"
block|,
name|XXECH
block|,
literal|0
block|,
comment|/* echo argument */
ifndef|#
directive|ifndef
name|NOSPL
literal|"else"
block|,
name|XXELS
block|,
name|CM_INV
block|,
comment|/* ELSE part of IF statement */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"enable"
block|,
name|XXENA
block|,
literal|0
block|,
comment|/* ENABLE a server function */
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|NOSPL
literal|"end"
block|,
name|XXEND
block|,
literal|0
block|,
comment|/* END command file or macro */
endif|#
directive|endif
comment|/* NOSPL */
literal|"ex"
block|,
name|XXEXI
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
comment|/* Let "ex" still be EXIT */
literal|"exit"
block|,
name|XXEXI
block|,
literal|0
block|,
comment|/* exit the program */
literal|"extproc"
block|,
name|XXCOM
block|,
name|CM_INV
block|,
comment|/* dummy command */
literal|"finish"
block|,
name|XXFIN
block|,
literal|0
block|,
comment|/* FINISH */
ifndef|#
directive|ifndef
name|NOSPL
literal|"for"
block|,
name|XXFOR
block|,
literal|0
block|,
comment|/* FOR loop */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOFRILLS
ifndef|#
directive|ifndef
name|MAC
literal|"fot"
block|,
name|XXDIR
block|,
name|CM_INV
block|,
comment|/* "fot" = "dir" (for Chris) */
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"g"
block|,
name|XXGET
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
comment|/* Invisible abbreviation for GET */
ifndef|#
directive|ifndef
name|NOSPL
literal|"ge"
block|,
name|XXGET
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
comment|/* Ditto */
endif|#
directive|endif
comment|/* NOSPL */
literal|"get"
block|,
name|XXGET
block|,
literal|0
block|,
comment|/* GET */
ifndef|#
directive|ifndef
name|NOSPL
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"getok"
block|,
name|XXGOK
block|,
literal|0
block|,
comment|/* GETOK (ask for Yes/No) */
endif|#
directive|endif
comment|/* NOFRILLS */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOSPL
literal|"goto"
block|,
name|XXGOTO
block|,
literal|0
block|,
comment|/* goto label in take file or macro */
endif|#
directive|endif
comment|/* NOSPL */
literal|"hangup"
block|,
name|XXHAN
block|,
literal|0
block|,
comment|/* hangup dialed phone connection */
literal|"help"
block|,
name|XXHLP
block|,
literal|0
block|,
comment|/* display help text */
ifndef|#
directive|ifndef
name|NOSPL
literal|"i"
block|,
name|XXINP
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
comment|/* invisible synonym for INPUT */
literal|"if"
block|,
name|XXIF
block|,
literal|0
block|,
comment|/* if (condition) command */
literal|"in"
block|,
name|XXINP
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
comment|/* invisible synonym for INPUT */
literal|"increment"
block|,
name|XXINC
block|,
literal|0
block|,
comment|/* increment a numeric variable */
literal|"input"
block|,
name|XXINP
block|,
literal|0
block|,
comment|/* input string from comm line */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOHELP
literal|"introduction"
block|,
name|XXINT
block|,
literal|0
block|,
comment|/* Print introductory text */
endif|#
directive|endif
comment|/* NOHELP */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"l"
block|,
name|XXLOG
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
comment|/* invisible synonym for log */
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"log"
block|,
name|XXLOG
block|,
literal|0
block|,
comment|/* open a log file */
ifndef|#
directive|ifndef
name|NOFRILLS
ifndef|#
directive|ifndef
name|MAC
literal|"ls"
block|,
name|XXDIR
block|,
name|CM_INV
block|,
comment|/* invisible synonym for directory */
endif|#
directive|endif
comment|/* MAC */
literal|"mail"
block|,
name|XXMAI
block|,
literal|0
block|,
comment|/* mail file to user */
literal|"man"
block|,
name|XXHLP
block|,
name|CM_INV
block|,
comment|/* Synonym for help */
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|NOMSEND
literal|"mget"
block|,
name|XXGET
block|,
name|CM_INV
block|,
comment|/* MGET = GET */
endif|#
directive|endif
comment|/* NOMSEND */
ifndef|#
directive|ifndef
name|NOSPL
literal|"mpause"
block|,
name|XXMSL
block|,
name|CM_INV
block|,
comment|/* Millisecond sleep */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOMSEND
literal|"ms"
block|,
name|XXMSE
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
literal|"msend"
block|,
name|XXMSE
block|,
literal|0
block|,
comment|/* Multiple SEND */
endif|#
directive|endif
comment|/* NOMSEND */
ifndef|#
directive|ifndef
name|NOSPL
literal|"msleep"
block|,
name|XXMSL
block|,
literal|0
block|,
comment|/* Millisecond sleep */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOMSEND
literal|"mput"
block|,
name|XXMSE
block|,
name|CM_INV
block|,
comment|/* MPUT = MSEND */
endif|#
directive|endif
comment|/* NOMSEND */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"mv"
block|,
name|XXREN
block|,
name|CM_INV
block|,
comment|/* rename a local file */
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|NOSPL
literal|"o"
block|,
name|XXOUT
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
comment|/* invisible synonym for OUTPUT */
literal|"open"
block|,
name|XXOPE
block|,
literal|0
block|,
comment|/* open file for reading or writing */
literal|"output"
block|,
name|XXOUT
block|,
literal|0
block|,
comment|/* output string to comm line */
endif|#
directive|endif
comment|/* NOSPL */
ifdef|#
directive|ifdef
name|SUNX25
literal|"pad"
block|,
name|XXPAD
block|,
literal|0
block|,
comment|/* PAD commands */
endif|#
directive|endif
comment|/* SUNX25 */
ifndef|#
directive|ifndef
name|NOSPL
literal|"pause"
block|,
name|XXPAU
block|,
literal|0
block|,
comment|/* sleep for specified interval */
ifdef|#
directive|ifdef
name|TCPSOCKET
literal|"ping"
block|,
name|XXPNG
block|,
literal|0
block|,
comment|/* PING (for TCP/IP) */
endif|#
directive|endif
comment|/* TCPSOCKET */
literal|"pop"
block|,
name|XXEND
block|,
name|CM_INV
block|,
comment|/* allow POP as synonym for END */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"print"
block|,
name|XXPRI
block|,
literal|0
block|,
comment|/* PRINT */
ifndef|#
directive|ifndef
name|NOPUSH
literal|"pu"
block|,
name|XXSHE
block|,
name|CM_INV
block|,
comment|/* PU = PUSH */
literal|"push"
block|,
name|XXSHE
block|,
literal|0
block|,
comment|/* PUSH command (like RUN, !) */
endif|#
directive|endif
comment|/* NOPUSH */
literal|"put"
block|,
name|XXSEN
block|,
name|CM_INV
block|,
comment|/* PUT = SEND */
ifndef|#
directive|ifndef
name|MAC
literal|"pwd"
block|,
name|XXPWD
block|,
literal|0
block|,
comment|/* print working directory */
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"quit"
block|,
name|XXQUI
block|,
literal|0
block|,
comment|/* quit from program = exit */
literal|"r"
block|,
name|XXREC
block|,
name|CM_INV
block|,
comment|/* invisible synonym for receive */
ifndef|#
directive|ifndef
name|NOSPL
literal|"read"
block|,
name|XXREA
block|,
literal|0
block|,
comment|/* read */
endif|#
directive|endif
comment|/* NOSPL */
literal|"receive"
block|,
name|XXREC
block|,
literal|0
block|,
comment|/* receive files */
ifndef|#
directive|ifndef
name|NODIAL
literal|"redial"
block|,
name|XXRED
block|,
literal|0
block|,
comment|/* redial */
endif|#
directive|endif
comment|/* NODIAL */
ifndef|#
directive|ifndef
name|NOSPL
literal|"reinput"
block|,
name|XXREI
block|,
literal|0
block|,
comment|/* reinput */
endif|#
directive|endif
comment|/* NOSPL */
literal|"remote"
block|,
name|XXREM
block|,
literal|0
block|,
comment|/* send generic command to server */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"rename"
block|,
name|XXREN
block|,
literal|0
block|,
comment|/* rename a local file */
literal|"replay"
block|,
name|XXTYP
block|,
name|CM_INV
block|,
comment|/* replay (for now, just type) */
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|NOSPL
literal|"return"
block|,
name|XXRET
block|,
literal|0
block|,
comment|/* return from function */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"rm"
block|,
name|XXDEL
block|,
name|CM_INV
block|,
comment|/* invisible synonym for delete */
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|NOPUSH
literal|"run"
block|,
name|XXSHE
block|,
literal|0
block|,
comment|/* run a program or command */
endif|#
directive|endif
comment|/* NOPUSH */
literal|"s"
block|,
name|XXSEN
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
comment|/* invisible synonym for send */
ifndef|#
directive|ifndef
name|NOSCRIPT
literal|"script"
block|,
name|XXLOGI
block|,
literal|0
block|,
comment|/* execute a uucp-style script */
endif|#
directive|endif
comment|/* NOSCRIPT */
literal|"send"
block|,
name|XXSEN
block|,
literal|0
block|,
comment|/* send files */
ifndef|#
directive|ifndef
name|NOSERVER
literal|"server"
block|,
name|XXSER
block|,
literal|0
block|,
comment|/* be a server */
endif|#
directive|endif
comment|/* NOSERVER */
literal|"set"
block|,
name|XXSET
block|,
literal|0
block|,
comment|/* set parameters */
ifndef|#
directive|ifndef
name|NOSHOW
literal|"show"
block|,
name|XXSHO
block|,
literal|0
block|,
comment|/* show parameters */
endif|#
directive|endif
comment|/* NOSHOW */
ifndef|#
directive|ifndef
name|NOSPL
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"sleep"
block|,
name|XXPAU
block|,
name|CM_INV
block|,
comment|/* sleep for specified interval */
endif|#
directive|endif
comment|/* NOFRILLS */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|MAC
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"sp"
block|,
name|XXSPA
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
literal|"spa"
block|,
name|XXSPA
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"space"
block|,
name|XXSPA
block|,
literal|0
block|,
comment|/* show available disk space */
endif|#
directive|endif
comment|/* MAC */
ifndef|#
directive|ifndef
name|NOFRILLS
ifndef|#
directive|ifndef
name|NOPUSH
literal|"spawn"
block|,
name|XXSHE
block|,
name|CM_INV
block|,
comment|/* synonym for PUSH, RUN */
endif|#
directive|endif
comment|/* NOPUSH */
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"statistics"
block|,
name|XXSTA
block|,
literal|0
block|,
comment|/* display file transfer stats */
ifndef|#
directive|ifndef
name|NOSPL
literal|"stop"
block|,
name|XXSTO
block|,
literal|0
block|,
comment|/* stop all take files */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOJC
literal|"suspend"
block|,
name|XXSUS
block|,
literal|0
block|,
comment|/* Suspend */
endif|#
directive|endif
comment|/* NOJC */
literal|"take"
block|,
name|XXTAK
block|,
literal|0
block|,
comment|/* take commands from file */
ifndef|#
directive|ifndef
name|NOFRILLS
ifdef|#
directive|ifdef
name|NETCONN
literal|"telnet"
block|,
name|XXTEL
block|,
literal|0
block|,
comment|/* telnet */
endif|#
directive|endif
comment|/* NETCONN */
literal|"test"
block|,
name|XXTES
block|,
name|CM_INV
block|,
comment|/* (for testing) */
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|NOCSETS
literal|"translate"
block|,
name|XXXLA
block|,
literal|0
block|,
comment|/* translate local file char sets */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NOXMIT
literal|"transmit"
block|,
name|XXTRA
block|,
literal|0
block|,
comment|/* raw upload file */
endif|#
directive|endif
comment|/* NOXMIT */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"type"
block|,
name|XXTYP
block|,
literal|0
block|,
comment|/* display a local file */
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"version"
block|,
name|XXVER
block|,
literal|0
comment|/* version number display */
ifndef|#
directive|ifndef
name|NOSPL
block|,
literal|"wait"
block|,
name|XXWAI
block|,
literal|0
comment|/* wait (like pause) */
block|,
literal|"while"
block|,
name|XXWHI
block|,
literal|0
comment|/* while */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|MAC
ifndef|#
directive|ifndef
name|NOFRILLS
block|,
literal|"who"
block|,
name|XXWHO
block|,
literal|0
comment|/* who */
endif|#
directive|endif
comment|/* NOFRILLS */
endif|#
directive|endif
comment|/* MAC */
ifndef|#
directive|ifndef
name|NOSPL
block|,
literal|"write"
block|,
name|XXWRI
block|,
literal|0
comment|/* write */
block|,
literal|"xif"
block|,
name|XXIFX
block|,
literal|0
comment|/* Extended IF */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOCSETS
block|,
literal|"xlate"
block|,
name|XXXLA
block|,
name|CM_INV
comment|/* translate local file char sets */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NOXMIT
block|,
literal|"xmit"
block|,
name|XXTRA
block|,
name|CM_INV
comment|/* raw upload file */
endif|#
directive|endif
comment|/* NOXMIT */
block|,
literal|"z"
block|,
name|XXSUS
block|,
name|CM_INV
comment|/* Suspend */
ifndef|#
directive|ifndef
name|NOSPL
block|,
literal|"_assign"
block|,
name|XXASX
block|,
name|CM_INV
comment|/* used internally by FOR, etc */
block|,
literal|"_define"
block|,
name|XXDFX
block|,
name|CM_INV
comment|/* used internally by FOR, etc */
block|,
literal|"_getargs"
block|,
name|XXGTA
block|,
name|CM_INV
comment|/* used internally by FOR, etc */
block|,
literal|"_putargs"
block|,
name|XXPTA
block|,
name|CM_INV
comment|/* used internally by FOR, etc */
endif|#
directive|endif
comment|/* NOSPL */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ncmd
init|=
operator|(
sizeof|sizeof
argument_list|(
name|cmdtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|toktab
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|NOPUSH
literal|'!'
block|,
comment|/* Shell escape */
endif|#
directive|endif
comment|/* NOPUSH */
literal|'#'
block|,
comment|/* Comment */
literal|';'
block|,
comment|/* Comment */
ifndef|#
directive|ifndef
name|NOSPL
literal|':'
block|,
comment|/* Label */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOPUSH
literal|'@'
block|,
comment|/* DCL escape */
endif|#
directive|endif
comment|/* NOPUSH */
literal|'\0'
comment|/* End of this string */
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NOFRILLS
end_ifndef

begin_decl_stmt
name|struct
name|keytab
name|yesno
index|[]
init|=
block|{
literal|"no"
block|,
literal|0
block|,
literal|0
block|,
literal|"ok"
block|,
literal|1
block|,
literal|0
block|,
literal|"yes"
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nyesno
init|=
operator|(
sizeof|sizeof
argument_list|(
name|yesno
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOFRILLS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_comment
comment|/* Parameter keyword table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|prmtab
index|[]
init|=
block|{
literal|"attributes"
block|,
name|XYATTR
block|,
literal|0
block|,
literal|"b"
block|,
name|XYBACK
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
literal|"ba"
block|,
name|XYBACK
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
literal|"background"
block|,
name|XYBACK
block|,
literal|0
block|,
literal|"baud"
block|,
name|XYSPEE
block|,
name|CM_INV
block|,
literal|"block-check"
block|,
name|XYCHKT
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|DYNAMIC
literal|"buffers"
block|,
name|XYBUF
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* DYNAMIC */
ifndef|#
directive|ifndef
name|MAC
literal|"carrier"
block|,
name|XYCARR
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* MAC */
ifndef|#
directive|ifndef
name|NOSPL
literal|"case"
block|,
name|XYCASE
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSPL */
literal|"command"
block|,
name|XYCMD
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOSPL
literal|"count"
block|,
name|XYCOUN
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSPL */
literal|"d"
block|,
name|XYDELA
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
literal|"de"
block|,
name|XYDELA
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
literal|"debug"
block|,
name|XYDEBU
block|,
name|CM_INV
block|,
ifdef|#
directive|ifdef
name|VMS
literal|"default"
block|,
name|XYDFLT
block|,
literal|0
block|,
else|#
directive|else
ifndef|#
directive|ifndef
name|MAC
literal|"default"
block|,
name|XYDFLT
block|,
name|CM_INV
block|,
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* VMS */
literal|"delay"
block|,
name|XYDELA
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NODIAL
literal|"dial"
block|,
name|XYDIAL
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NODIAL */
literal|"duplex"
block|,
name|XYDUPL
block|,
literal|0
block|,
literal|"escape-character"
block|,
name|XYESC
block|,
literal|0
block|,
literal|"file"
block|,
name|XYFILE
block|,
literal|0
block|,
literal|"flow-control"
block|,
name|XYFLOW
block|,
literal|0
block|,
literal|"handshake"
block|,
name|XYHAND
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|NETCONN
literal|"host"
block|,
name|XYHOST
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NETCONN */
literal|"incomplete"
block|,
name|XYIFD
block|,
name|CM_INV
block|,
ifndef|#
directive|ifndef
name|NOSPL
literal|"i"
block|,
name|XYINPU
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
literal|"in"
block|,
name|XYINPU
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
literal|"input"
block|,
name|XYINPU
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|MAC
ifndef|#
directive|ifndef
name|NOSETKEY
literal|"key"
block|,
name|XYKEY
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSETKEY */
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* NOSPL */
literal|"l"
block|,
name|XYLINE
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
ifndef|#
directive|ifndef
name|NOCSETS
literal|"language"
block|,
name|XYLANG
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOCSETS */
literal|"line"
block|,
name|XYLINE
block|,
literal|0
block|,
literal|"local-echo"
block|,
name|XYLCLE
block|,
name|CM_INV
block|,
ifndef|#
directive|ifndef
name|NOSPL
literal|"macro"
block|,
name|XYMACR
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSPL */
ifdef|#
directive|ifdef
name|COMMENT
ifdef|#
directive|ifdef
name|VMS
literal|"messages"
block|,
name|XYMSGS
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* VMS */
endif|#
directive|endif
comment|/* COMMENT */
ifndef|#
directive|ifndef
name|NODIAL
literal|"modem-dialer"
block|,
name|XYMODM
block|,
literal|0
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NETCONN
literal|"network"
block|,
name|XYNET
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NETCONN */
ifdef|#
directive|ifdef
name|SUNX25
literal|"pad"
block|,
name|XYPAD
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* SUNX25 */
literal|"parity"
block|,
name|XYPARI
block|,
literal|0
block|,
literal|"port"
block|,
name|XYLINE
block|,
name|CM_INV
block|,
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"prompt"
block|,
name|XYPROM
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"quiet"
block|,
name|XYQUIE
block|,
literal|0
block|,
literal|"receive"
block|,
name|XYRECV
block|,
literal|0
block|,
literal|"retry-limit"
block|,
name|XYRETR
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOSCRIPT
literal|"script"
block|,
name|XYSCRI
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSCRIPT */
literal|"send"
block|,
name|XYSEND
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOSERVER
literal|"server"
block|,
name|XYSERV
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSERVER */
ifdef|#
directive|ifdef
name|UNIX
literal|"session-log"
block|,
name|XYSESS
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* UNIX */
literal|"speed"
block|,
name|XYSPEE
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOJC
literal|"suspend"
block|,
name|XYSUSP
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOJC */
literal|"take"
block|,
name|XYTAKE
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|TNCODE
literal|"telnet"
block|,
name|XYTEL
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* TNCODE */
literal|"terminal"
block|,
name|XYTERM
block|,
literal|0
block|,
literal|"transfer"
block|,
name|XYXFER
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOXMIT
literal|"transmit"
block|,
name|XYXMIT
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOXMIT */
ifndef|#
directive|ifndef
name|NOCSETS
literal|"unknown-char-set"
block|,
name|XYUNCS
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOCSETS */
literal|"window-size"
block|,
name|XYWIND
block|,
literal|0
ifdef|#
directive|ifdef
name|UNIX
block|,
literal|"wildcard-expansion"
block|,
name|XYWILD
block|,
literal|0
endif|#
directive|endif
comment|/* UNIX */
ifdef|#
directive|ifdef
name|SUNX25
block|,
literal|"x.25"
block|,
name|XYX25
block|,
literal|0
block|,
literal|"x25"
block|,
name|XYX25
block|,
name|CM_INV
endif|#
directive|endif
comment|/* SUNX25 */
ifndef|#
directive|ifndef
name|NOCSETS
block|,
literal|"xfer"
block|,
name|XYXFER
block|,
name|CM_INV
endif|#
directive|endif
comment|/* NOCSETS */
ifndef|#
directive|ifndef
name|NOXMIT
block|,
literal|"xmit"
block|,
name|XYXMIT
block|,
name|CM_INV
endif|#
directive|endif
comment|/* NOXMIT */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nprm
init|=
operator|(
sizeof|sizeof
argument_list|(
name|prmtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many parameters */
end_comment

begin_comment
comment|/* Table of networks */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NETCONN
end_ifdef

begin_decl_stmt
name|struct
name|keytab
name|netcmd
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|DECNET
literal|"decnet"
block|,
name|NET_DEC
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* DECNET */
ifdef|#
directive|ifdef
name|NPIPE
literal|"named-pipe"
block|,
name|NET_PIPE
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NPIPE */
ifdef|#
directive|ifdef
name|TCPSOCKET
literal|"tcp/ip"
block|,
name|NET_TCPB
block|,
literal|0
endif|#
directive|endif
comment|/* TCPSOCKET */
ifdef|#
directive|ifdef
name|SUNX25
block|,
literal|"x"
block|,
name|NET_SX25
block|,
name|CM_INV
operator||
name|CM_ABR
block|,
literal|"x.25"
block|,
name|NET_SX25
block|,
literal|0
block|,
literal|"x25"
block|,
name|NET_SX25
block|,
name|CM_INV
endif|#
directive|endif
comment|/* SUNX25 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nnets
init|=
operator|(
sizeof|sizeof
argument_list|(
name|netcmd
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many networks */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETCONN */
end_comment

begin_comment
comment|/* Remote Command Table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|remcmd
index|[]
init|=
block|{
literal|"cd"
block|,
name|XZCWD
block|,
literal|0
block|,
literal|"cwd"
block|,
name|XZCWD
block|,
name|CM_INV
block|,
literal|"delete"
block|,
name|XZDEL
block|,
literal|0
block|,
literal|"directory"
block|,
name|XZDIR
block|,
literal|0
block|,
literal|"help"
block|,
name|XZHLP
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOPUSH
literal|"host"
block|,
name|XZHOS
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOPUSH */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"kermit"
block|,
name|XZKER
block|,
literal|0
block|,
literal|"login"
block|,
name|XZLGI
block|,
literal|0
block|,
literal|"logout"
block|,
name|XZLGO
block|,
literal|0
block|,
literal|"print"
block|,
name|XZPRI
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"set"
block|,
name|XZSET
block|,
literal|0
block|,
literal|"space"
block|,
name|XZSPA
block|,
literal|0
ifndef|#
directive|ifndef
name|NOFRILLS
block|,
literal|"type"
block|,
name|XZTYP
block|,
literal|0
block|,
literal|"who"
block|,
name|XZWHO
block|,
literal|0
endif|#
directive|endif
comment|/* NOFRILLS */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nrmt
init|=
operator|(
sizeof|sizeof
argument_list|(
name|remcmd
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|logtab
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|DEBUG
literal|"debugging"
block|,
name|LOGD
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* DEBUG */
literal|"packets"
block|,
name|LOGP
block|,
literal|0
block|,
literal|"session"
block|,
name|LOGS
block|,
literal|0
ifdef|#
directive|ifdef
name|TLOG
block|,
literal|"transactions"
block|,
name|LOGT
block|,
literal|0
endif|#
directive|endif
comment|/* TLOG */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nlog
init|=
operator|(
sizeof|sizeof
argument_list|(
name|logtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|writab
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|NOSPL
literal|"append-file"
block|,
name|LOGW
block|,
name|CM_INV
block|,
endif|#
directive|endif
comment|/* NOSPL */
literal|"debug-log"
block|,
name|LOGD
block|,
literal|0
block|,
literal|"error"
block|,
name|LOGE
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOSPL
literal|"file"
block|,
name|LOGW
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSPL */
literal|"packet-log"
block|,
name|LOGP
block|,
literal|0
block|,
literal|"screen"
block|,
name|LOGX
block|,
literal|0
block|,
literal|"session-log"
block|,
name|LOGS
block|,
literal|0
block|,
literal|"sys$output"
block|,
name|LOGX
block|,
name|CM_INV
block|,
literal|"transaction-log"
block|,
name|LOGT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nwri
init|=
operator|(
sizeof|sizeof
argument_list|(
name|writab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CLR_DEV
value|1
end_define

begin_define
define|#
directive|define
name|CLR_INP
value|2
end_define

begin_decl_stmt
specifier|static
name|struct
name|keytab
name|clrtab
index|[]
init|=
block|{
comment|/* Keywords for CLEAR command */
ifndef|#
directive|ifndef
name|NOSPL
literal|"both"
block|,
name|CLR_DEV
operator||
name|CLR_INP
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSPL */
literal|"device-buffer"
block|,
name|CLR_DEV
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOSPL
literal|"input-buffer"
block|,
name|CLR_INP
block|,
literal|0
endif|#
directive|endif
comment|/* NOSPL */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nclear
init|=
operator|(
sizeof|sizeof
argument_list|(
name|clrtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|clstab
index|[]
init|=
block|{
comment|/* Keywords for CLOSE command */
ifndef|#
directive|ifndef
name|NOSPL
literal|"append-file"
block|,
name|LOGW
block|,
name|CM_INV
block|,
endif|#
directive|endif
comment|/* NOSPL */
ifdef|#
directive|ifdef
name|DEBUG
literal|"debug-log"
block|,
name|LOGD
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* DEBUG */
literal|"packet-log"
block|,
name|LOGP
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOSPL
literal|"read-file"
block|,
name|LOGR
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSPL */
literal|"session-log"
block|,
name|LOGS
block|,
literal|0
ifdef|#
directive|ifdef
name|TLOG
block|,
literal|"transaction-log"
block|,
name|LOGT
block|,
literal|0
endif|#
directive|endif
comment|/* TLOG */
ifndef|#
directive|ifndef
name|NOSPL
block|,
literal|"write-file"
block|,
name|LOGW
block|,
literal|0
endif|#
directive|endif
comment|/* NOSPL */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ncls
init|=
operator|(
sizeof|sizeof
argument_list|(
name|clstab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SHOW command arguments */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|shotab
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|NOSPL
literal|"arguments"
block|,
name|SHARG
block|,
literal|0
block|,
literal|"arrays"
block|,
name|SHARR
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSPL */
literal|"attributes"
block|,
name|SHATT
block|,
literal|0
block|,
literal|"character-sets"
block|,
name|SHCSE
block|,
literal|0
block|,
literal|"communications"
block|,
name|SHCOM
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOSPL
literal|"count"
block|,
name|SHCOU
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSPL */
ifdef|#
directive|ifdef
name|VMS
literal|"default"
block|,
name|SHDFLT
block|,
literal|0
block|,
else|#
directive|else
literal|"default"
block|,
name|SHDFLT
block|,
name|CM_INV
block|,
endif|#
directive|endif
comment|/* VMS */
ifndef|#
directive|ifndef
name|NODIAL
literal|"dial"
block|,
name|SHDIA
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NODIAL */
literal|"escape"
block|,
name|SHESC
block|,
literal|0
block|,
literal|"features"
block|,
name|SHFEA
block|,
literal|0
block|,
literal|"file"
block|,
name|SHFIL
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOSPL
literal|"functions"
block|,
name|SHFUN
block|,
literal|0
block|,
literal|"globals"
block|,
name|SHVAR
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOSETKEY
literal|"key"
block|,
name|SHKEY
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSETKEY */
ifdef|#
directive|ifdef
name|VMS
literal|"labeled-file-info"
block|,
name|SHLBL
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* VMS */
ifndef|#
directive|ifndef
name|NOCSETS
literal|"languages"
block|,
name|SHLNG
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOCSETS */
ifndef|#
directive|ifndef
name|NOSPL
literal|"macros"
block|,
name|SHMAC
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSPL */
literal|"modem-signals"
block|,
name|SHMOD
block|,
literal|0
block|,
literal|"network"
block|,
name|SHNET
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|SUNX25
literal|"pad"
block|,
name|SHPAD
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* SUNX25 */
literal|"parameters"
block|,
name|SHPAR
block|,
name|CM_INV
block|,
literal|"protocol"
block|,
name|SHPRO
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOSPL
literal|"scripts"
block|,
name|SHSCR
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOSERVER
literal|"server"
block|,
name|SHSER
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOSERVER */
literal|"status"
block|,
name|SHSTA
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|MAC
literal|"stack"
block|,
name|SHSTK
block|,
literal|0
block|,
comment|/* debugging */
endif|#
directive|endif
comment|/* MAC */
literal|"terminal"
block|,
name|SHTER
block|,
literal|0
ifndef|#
directive|ifndef
name|NOXMIT
block|,
literal|"transmit"
block|,
name|SHXMI
block|,
literal|0
endif|#
directive|endif
comment|/* NOXMIT */
ifndef|#
directive|ifndef
name|NOSPL
block|,
literal|"variables"
block|,
name|SHBUI
block|,
literal|0
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOFRILLS
block|,
literal|"versions"
block|,
name|SHVER
block|,
literal|0
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|NOXMIT
block|,
literal|"xmit"
block|,
name|SHXMI
block|,
name|CM_INV
endif|#
directive|endif
comment|/* NOXMIT */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsho
init|=
operator|(
sizeof|sizeof
argument_list|(
name|shotab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SUNX25
end_ifdef

begin_decl_stmt
name|struct
name|keytab
name|padtab
index|[]
init|=
block|{
comment|/* PAD commands */
literal|"clear"
block|,
name|XYPADL
block|,
literal|0
block|,
literal|"interrupt"
block|,
name|XYPADI
block|,
literal|0
block|,
literal|"reset"
block|,
name|XYPADR
block|,
literal|0
block|,
literal|"status"
block|,
name|XYPADS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|npadc
init|=
operator|(
sizeof|sizeof
argument_list|(
name|padtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUNX25 */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|enatab
index|[]
init|=
block|{
comment|/* ENABLE commands */
literal|"all"
block|,
name|EN_ALL
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|datageneral
literal|"bye"
block|,
name|EN_BYE
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* datageneral */
literal|"cd"
block|,
name|EN_CWD
block|,
literal|0
block|,
literal|"cwd"
block|,
name|EN_CWD
block|,
name|CM_INV
block|,
literal|"delete"
block|,
name|EN_DEL
block|,
literal|0
block|,
literal|"directory"
block|,
name|EN_DIR
block|,
literal|0
block|,
literal|"finish"
block|,
name|EN_FIN
block|,
literal|0
block|,
literal|"get"
block|,
name|EN_GET
block|,
literal|0
block|,
literal|"host"
block|,
name|EN_HOS
block|,
literal|0
block|,
literal|"send"
block|,
name|EN_SEN
block|,
literal|0
block|,
literal|"set"
block|,
name|EN_SET
block|,
literal|0
block|,
literal|"space"
block|,
name|EN_SPA
block|,
literal|0
block|,
literal|"type"
block|,
name|EN_TYP
block|,
literal|0
block|,
literal|"who"
block|,
name|EN_WHO
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nena
init|=
operator|(
sizeof|sizeof
argument_list|(
name|enatab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|COMMENT
end_ifdef

begin_decl_stmt
name|struct
name|mtab
name|mactab
index|[
name|MAC_MAX
index|]
init|=
block|{
comment|/* Preinitialized macro table */
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|mtab
modifier|*
name|mactab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dynamically allocated macro table */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMMENT */
end_comment

begin_decl_stmt
name|int
name|nmac
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|mackey
index|[
name|MAC_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro names as command keywords */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_comment
comment|/* Forward declarations of functions */
end_comment

begin_macro
name|_PROTOTYP
argument_list|(
argument|int doask
argument_list|,
argument|( int  )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int dodef
argument_list|,
argument|( int  )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int dodel
argument_list|,
argument|( void )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int dodial
argument_list|,
argument|( int  )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int dodir
argument_list|,
argument|( void )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int doelse
argument_list|,
argument|( void )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int dofor
argument_list|,
argument|( void )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int dogta
argument_list|,
argument|( int  )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int doincr
argument_list|,
argument|( int  )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int dopaus
argument_list|,
argument|( int  )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int doping
argument_list|,
argument|( void )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYP
argument_list|(
argument|int dorenam
argument_list|,
argument|( void )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCPSOCKET
end_ifdef

begin_function
name|int
name|doping
parameter_list|()
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
name|network
condition|)
comment|/* If we have a current connection */
name|strcpy
argument_list|(
name|line
argument_list|,
name|ttname
argument_list|)
expr_stmt|;
comment|/* get the host name */
else|else
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
comment|/* as default host to be pinged. */
for|for
control|(
name|p
operator|=
name|line
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
comment|/* Remove ":service" from end. */
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"IP host name or number"
argument_list|,
name|line
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* Construct PING command */
ifdef|#
directive|ifdef
name|VMS
ifdef|#
directive|ifdef
name|MULTINET
comment|/* TGV MultiNet */
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"multinet ping %s /num=1"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"ping %s 56 1"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Other VMS TCP/IP's */
endif|#
directive|endif
comment|/* MULTINET */
else|#
directive|else
comment|/* Not VMS */
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"ping %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|conres
argument_list|()
expr_stmt|;
comment|/* Make console normal  */
ifdef|#
directive|ifdef
name|DEC_TCPIP
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Prevent prompt-stomping */
endif|#
directive|endif
comment|/* DEC_TCPIP */
name|x
operator|=
name|zshcmd
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|concb
argument_list|(
operator|(
name|char
operator|)
name|escape
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
comment|/* We don't know the status */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCPSOCKET */
end_comment

begin_comment
comment|/*  D O C M D  --  Do a command  */
end_comment

begin_comment
comment|/*  Returns:    -2: user typed an illegal command    -1: reparse needed     0: parse was successful (even tho command may have failed). */
end_comment

begin_function
name|int
name|docmd
parameter_list|(
name|cx
parameter_list|)
name|int
name|cx
decl_stmt|;
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"docmd entry, cx"
argument_list|,
literal|""
argument_list|,
name|cx
argument_list|)
expr_stmt|;
comment|/*   Massive switch() broken up into many smaller ones, for the benefit of   compilers that run out of space when trying to handle large switch   statements. */
switch|switch
condition|(
name|cx
condition|)
block|{
case|case
operator|-
literal|4
case|:
comment|/* EOF */
ifdef|#
directive|ifdef
name|OSK
if|if
condition|(
name|msgflg
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|msgflg
condition|)
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OSK */
name|doexit
argument_list|(
name|GOOD_EXIT
argument_list|,
name|xitsta
argument_list|)
expr_stmt|;
case|case
operator|-
literal|3
case|:
comment|/* Null command */
return|return
operator|(
literal|0
operator|)
return|;
case|case
operator|-
literal|9
case|:
comment|/* Like -2, but errmsg already done */
case|case
operator|-
literal|1
case|:
comment|/* Reparse needed */
return|return
operator|(
name|cx
operator|)
return|;
case|case
operator|-
literal|6
case|:
comment|/* Special */
case|case
operator|-
literal|2
case|:
comment|/* Error, maybe */
ifndef|#
directive|ifndef
name|NOSPL
comment|/*   Maybe they typed a macro name.  Let's look it up and see. */
if|if
condition|(
name|cx
operator|==
operator|-
literal|6
condition|)
comment|/* If they typed CR */
name|strcat
argument_list|(
name|cmdbuf
argument_list|,
literal|"\015"
argument_list|)
expr_stmt|;
comment|/*  add it back to command buffer. */
if|if
condition|(
name|ifcmd
index|[
name|cmdlvl
index|]
operator|==
literal|2
condition|)
comment|/* Watch out for IF commands. */
name|ifcmd
index|[
name|cmdlvl
index|]
operator|--
expr_stmt|;
name|repars
operator|=
literal|1
expr_stmt|;
comment|/* Force reparse */
name|cmres
argument_list|()
expr_stmt|;
name|cx
operator|=
name|XXDO
expr_stmt|;
comment|/* Try DO command */
else|#
directive|else
return|return
operator|(
name|cx
operator|)
return|;
endif|#
directive|endif
comment|/* NOSPL */
default|default:
break|break;
block|}
ifndef|#
directive|ifndef
name|NOSPL
comment|/* Copy macro args from/to two levels up, used internally by _floop et al. */
if|if
condition|(
name|cx
operator|==
name|XXGTA
operator|||
name|cx
operator|==
name|XXPTA
condition|)
block|{
comment|/* _GETARGS, _PUTARGS */
name|int
name|x
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"docmd XXGTA"
argument_list|,
literal|""
argument_list|,
name|XXGTA
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"docmd cx"
argument_list|,
literal|""
argument_list|,
name|cx
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"docmd XXGTA maclvl"
argument_list|,
literal|""
argument_list|,
name|maclvl
argument_list|)
expr_stmt|;
name|x
operator|=
name|dogta
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"docmd dogta returns"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"docmd dogta maclvl"
argument_list|,
literal|""
argument_list|,
name|maclvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOSPL
comment|/* ASK, ASKQ, READ */
if|if
condition|(
name|cx
operator|==
name|XXASK
operator|||
name|cx
operator|==
name|XXASKQ
operator|||
name|cx
operator|==
name|XXREA
condition|)
block|{
return|return
operator|(
name|doask
argument_list|(
name|cx
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
name|cx
operator|==
name|XXBUG
condition|)
block|{
comment|/* BUG */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|dobug
argument_list|()
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOFRILLS */
if|if
condition|(
name|cx
operator|==
name|XXBYE
condition|)
block|{
comment|/* BYE */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'L'
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|ttflui
argument_list|()
expr_stmt|;
comment|/* If local, flush tty input buffer */
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
name|cx
operator|==
name|XXCLE
condition|)
block|{
comment|/* CLEAR */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|clrtab
argument_list|,
name|nclear
argument_list|,
literal|"buffer(s) to clear"
argument_list|,
ifdef|#
directive|ifdef
name|NOSPL
literal|"device-buffer"
else|#
directive|else
literal|"both"
endif|#
directive|endif
comment|/* NOSPL */
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* Clear device input buffer if requested */
name|y
operator|=
operator|(
name|x
operator|&
name|CLR_DEV
operator|)
condition|?
name|ttflui
argument_list|()
else|:
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|NOSPL
comment|/* Clear INPUT command buffer if requested */
if|if
condition|(
name|x
operator|&
name|CLR_INP
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|INPBUFSIZ
condition|;
name|x
operator|++
control|)
name|inpbuf
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
name|inpbp
operator|=
name|inpbuf
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOSPL */
return|return
operator|(
name|success
operator|=
operator|(
name|y
operator|==
literal|0
operator|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOFRILLS */
if|if
condition|(
name|cx
operator|==
name|XXCOM
condition|)
block|{
comment|/* COMMENT */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Text of comment line"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* Don't change SUCCESS flag for this one */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cx
operator|==
name|XXCON
condition|)
block|{
comment|/* CONNECT */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|success
operator|=
name|doconect
argument_list|()
operator|)
return|;
block|}
if|if
condition|(
name|cx
operator|==
name|XXCWD
condition|)
comment|/* CWD */
return|return
operator|(
name|success
operator|=
name|docd
argument_list|()
operator|)
return|;
if|if
condition|(
name|cx
operator|==
name|XXCHK
condition|)
comment|/* CHECK */
return|return
operator|(
name|success
operator|=
name|dochk
argument_list|()
operator|)
return|;
if|if
condition|(
name|cx
operator|==
name|XXCLO
condition|)
block|{
comment|/* CLOSE */
name|x
operator|=
name|cmkey
argument_list|(
name|clstab
argument_list|,
name|ncls
argument_list|,
literal|"Which log or file to close"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?You must say which file or log\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|y
operator|=
name|doclslog
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|y
operator|==
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|cx
operator|==
name|XXDEC
operator|||
name|cx
operator|==
name|XXINC
condition|)
comment|/* DECREMENT, INCREMENT */
return|return
operator|(
name|doincr
argument_list|(
name|cx
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|cx
operator|==
name|XXDEF
operator|||
name|cx
operator|==
name|XXASS
operator|||
name|cx
operator|==
name|XXASX
operator|||
name|cx
operator|==
name|XXDFX
condition|)
return|return
operator|(
name|dodef
argument_list|(
name|cx
argument_list|)
operator|)
return|;
comment|/* DEFINE, ASSIGN */
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|cx
operator|==
name|XXDCL
condition|)
block|{
comment|/* DECLARE an array */
if|if
condition|(
operator|(
name|y
operator|=
name|cmfld
argument_list|(
literal|"Array name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Array name required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|arraynam
argument_list|(
name|s
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|z
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|dclarray
argument_list|(
operator|(
name|char
operator|)
name|x
argument_list|,
name|z
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Declare failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NODIAL
if|if
condition|(
name|cx
operator|==
name|XXRED
operator|||
name|cx
operator|==
name|XXDIAL
condition|)
comment|/* DIAL or REDIAL */
return|return
operator|(
name|dodial
argument_list|(
name|cx
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* NODIAL */
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
name|cx
operator|==
name|XXDEL
condition|)
comment|/* DELETE */
return|return
operator|(
name|dodel
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|MAC
if|if
condition|(
name|cx
operator|==
name|XXDIR
condition|)
comment|/* DIRECTORY */
return|return
operator|(
name|dodir
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* MAC */
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|cx
operator|==
name|XXELS
condition|)
comment|/* ELSE */
return|return
operator|(
name|doelse
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
name|cx
operator|==
name|XXENA
operator|||
name|cx
operator|==
name|XXDIS
condition|)
block|{
comment|/* ENABLE, DISABLE */
name|s
operator|=
operator|(
name|cx
operator|==
name|XXENA
operator|)
condition|?
literal|"Server function to enable"
else|:
literal|"Server function to disable"
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|enatab
argument_list|,
name|nena
argument_list|,
name|s
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Name of server function required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
return|return
operator|(
name|doenable
argument_list|(
name|cx
argument_list|,
name|x
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|cx
operator|==
name|XXRET
condition|)
block|{
comment|/* RETURN */
if|if
condition|(
name|cmdlvl
operator|==
literal|0
condition|)
block|{
comment|/* At top level, nothing happens... */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cmdstk
index|[
name|cmdlvl
index|]
operator|.
name|src
operator|==
name|CMD_TF
condition|)
block|{
comment|/* In TAKE file, like POP */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"optional return value"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* Allow trailing text, but ignore. */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|popclvl
argument_list|()
expr_stmt|;
comment|/* pop command level */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
comment|/* always succeeds */
block|}
elseif|else
if|if
condition|(
name|cmdstk
index|[
name|cmdlvl
index|]
operator|.
name|src
operator|==
name|CMD_MD
condition|)
block|{
comment|/* Within macro */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"optional return value"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|doreturn
argument_list|(
name|s
argument_list|)
operator|)
return|;
comment|/* Trailing text is return value. */
block|}
else|else
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|cx
operator|==
name|XXDO
condition|)
block|{
comment|/* DO (a macro) */
if|if
condition|(
name|nmac
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n?No macros defined\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|nmac
condition|;
name|y
operator|++
control|)
block|{
comment|/* copy the macro table */
name|mackey
index|[
name|y
index|]
operator|.
name|kwd
operator|=
name|mactab
index|[
name|y
index|]
operator|.
name|kwd
expr_stmt|;
comment|/* into a regular keyword table */
name|mackey
index|[
name|y
index|]
operator|.
name|kwval
operator|=
name|y
expr_stmt|;
comment|/* with value = pointer to macro tbl */
name|mackey
index|[
name|y
index|]
operator|.
name|flgs
operator|=
name|mactab
index|[
name|y
index|]
operator|.
name|flgs
expr_stmt|;
block|}
comment|/* parse name as keyword */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|mackey
argument_list|,
name|nmac
argument_list|,
literal|"macro"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Macro name required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"optional arguments"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* get args */
return|return
operator|(
name|dodo
argument_list|(
name|x
argument_list|,
name|s
argument_list|)
operator|<
literal|1
condition|?
operator|(
name|success
operator|=
literal|0
operator|)
else|:
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSPL */
if|if
condition|(
name|cx
operator|==
name|XXECH
condition|)
block|{
comment|/* ECHO */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Material to be echoed"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
comment|/* Strip enclosing braces */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Always succeeds */
block|}
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|cx
operator|==
name|XXOPE
condition|)
comment|/* OPEN */
return|return
operator|(
name|doopen
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|cx
operator|==
name|XXOUT
condition|)
block|{
comment|/* OUTPUT */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Text to be output"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"OUTPUT 1"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
comment|/* Strip enclosing braces, */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* if any. */
if|if
condition|(
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
name|debug
argument_list|(
name|F110
argument_list|,
literal|"OUTPUT 2"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
operator|,
name|y
operator|=
literal|0
init|;
name|s
index|[
name|x
index|]
condition|;
name|x
operator|++
operator|,
name|y
operator|++
control|)
block|{
comment|/* Convert \B, \L to \\B, \\L */
if|if
condition|(
name|x
operator|>
literal|0
operator|&&
operator|(
name|s
index|[
name|x
index|]
operator|==
literal|'B'
operator|||
name|s
index|[
name|x
index|]
operator|==
literal|'b'
operator|||
name|s
index|[
name|x
index|]
operator|==
literal|'L'
operator|||
name|s
index|[
name|x
index|]
operator|==
literal|'l'
operator|)
condition|)
if|if
condition|(
operator|(
name|x
operator|==
literal|1
operator|&&
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|==
name|CMDQ
operator|)
operator|||
operator|(
name|x
operator|>
literal|1
operator|&&
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|==
name|CMDQ
operator|&&
name|s
index|[
name|x
operator|-
literal|2
index|]
operator|!=
name|CMDQ
operator|)
condition|)
name|line
index|[
name|y
operator|++
index|]
operator|=
name|CMDQ
expr_stmt|;
name|line
index|[
name|y
index|]
operator|=
name|s
index|[
name|x
index|]
expr_stmt|;
block|}
name|line
index|[
name|y
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now expand variables, etc. */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"OUTPUT 3"
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|line
operator|+
name|y
operator|+
literal|1
expr_stmt|;
name|x
operator|=
name|LINBUFSIZ
operator|-
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"OUTPUT size"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|xxstring
argument_list|(
name|line
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|x
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
name|s
operator|=
name|line
operator|+
name|y
operator|+
literal|1
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"OUTPUT 4"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|dooutput
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSPL */
ifdef|#
directive|ifdef
name|SUNX25
if|if
condition|(
name|cx
operator|==
name|XXPAD
condition|)
block|{
comment|/* PAD commands */
name|x
operator|=
name|cmkey
argument_list|(
name|padtab
argument_list|,
name|npadc
argument_list|,
literal|"PAD command"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?You must specify a PAD command to execute\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|XYPADL
case|:
if|if
condition|(
name|x25stat
argument_list|()
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"Sorry, you must 'set network'& 'set host' first\r\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|x25clear
argument_list|()
expr_stmt|;
name|initpad
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|XYPADS
case|:
if|if
condition|(
name|x25stat
argument_list|()
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"Not connected\r\n"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|extern
name|int
name|linkid
decl_stmt|,
name|lcn
decl_stmt|;
name|conol
argument_list|(
literal|"Connected thru "
argument_list|)
expr_stmt|;
name|conol
argument_list|(
name|ttname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", Link id %d, Logical channel number %d\r\n"
argument_list|,
name|linkid
argument_list|,
name|lcn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XYPADR
case|:
if|if
condition|(
name|x25stat
argument_list|()
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"Sorry, you must 'set network'& 'set host' first\r\n"
argument_list|)
expr_stmt|;
else|else
name|x25reset
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYPADI
case|:
if|if
condition|(
name|x25stat
argument_list|()
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"Sorry, you must 'set network'& 'set host' first\r\n"
argument_list|)
expr_stmt|;
else|else
name|x25intr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* SUNX25 */
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|cx
operator|==
name|XXPAU
operator|||
name|cx
operator|==
name|XXWAI
operator|||
name|cx
operator|==
name|XXMSL
condition|)
comment|/* PAUSE, WAIT, etc */
return|return
operator|(
name|dopaus
argument_list|(
name|cx
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
name|cx
operator|==
name|XXPRI
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|cmifi
argument_list|(
literal|"File to print"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|y
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?A file specification is required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Wildcards not allowed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Local print command options, or carriage return"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|success
operator|=
operator|(
name|zprint
argument_list|(
name|s
argument_list|,
name|line
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TCPSOCKET
if|if
condition|(
name|cx
operator|==
name|XXPNG
condition|)
comment|/* PING an IP host */
return|return
operator|(
name|doping
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* TCPSOCKET */
ifndef|#
directive|ifndef
name|MAC
if|if
condition|(
name|cx
operator|==
name|XXPWD
condition|)
block|{
comment|/* PWD */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|xsystem
argument_list|(
name|PWDCMD
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
comment|/* blind faith */
block|}
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* NOFRILLS */
if|if
condition|(
name|cx
operator|==
name|XXQUI
operator|||
name|cx
operator|==
name|XXEXI
condition|)
block|{
comment|/* EXIT, QUIT */
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"exit status code"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
name|x
operator|=
name|xitsta
expr_stmt|;
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
ifdef|#
directive|ifdef
name|VMS
name|doexit
argument_list|(
name|GOOD_EXIT
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|OSK
comment|/* Returning any codes here makes the OS-9 shell print an error message. */
name|doexit
argument_list|(
name|GOOD_EXIT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|datageneral
name|doexit
argument_list|(
name|GOOD_EXIT
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|doexit
argument_list|(
name|x
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* datageneral */
endif|#
directive|endif
comment|/* OSK */
endif|#
directive|endif
comment|/* VMS */
block|}
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
name|cx
operator|==
name|XXERR
condition|)
block|{
comment|/* ERROR */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|ttflui
argument_list|()
expr_stmt|;
name|sstate
operator|=
literal|'a'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOFRILLS */
if|if
condition|(
name|cx
operator|==
name|XXFIN
condition|)
block|{
comment|/* FINISH */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'F'
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|ttflui
argument_list|()
expr_stmt|;
comment|/* If local, flush tty input buffer */
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|cx
operator|==
name|XXFOR
condition|)
comment|/* FOR loop */
return|return
operator|(
name|dofor
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* NOSPL */
if|if
condition|(
name|cx
operator|==
name|XXGET
condition|)
block|{
comment|/* GET */
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Name of remote file(s), or carriage return"
argument_list|,
literal|""
argument_list|,
operator|&
name|cmarg
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
operator|(
name|x
operator|==
operator|-
literal|2
operator|)
operator|||
operator|(
name|x
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
endif|#
directive|endif
comment|/* NOFRILLS */
if|if
condition|(
operator|*
name|cmarg
operator|==
literal|'{'
condition|)
block|{
comment|/* Strip any enclosing braces */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|cmarg
argument_list|)
expr_stmt|;
comment|/* This allows preservation of */
if|if
condition|(
name|cmarg
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
comment|/* leading and/or trailing */
name|cmarg
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
comment|/* spaces. */
name|cmarg
operator|++
expr_stmt|;
block|}
block|}
name|x
operator|=
name|doget
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|sstate
operator|==
literal|'r'
condition|)
name|scrcreate
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
return|return
operator|(
name|x
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOSPL
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
name|cx
operator|==
name|XXGOK
condition|)
block|{
comment|/* GETOK */
return|return
operator|(
name|success
operator|=
name|doask
argument_list|(
name|cx
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOFRILLS */
endif|#
directive|endif
comment|/* NOSPL */
if|if
condition|(
name|cx
operator|==
name|XXHLP
condition|)
block|{
comment|/* HELP */
ifdef|#
directive|ifdef
name|NOHELP
return|return
operator|(
name|dohlp
argument_list|(
name|XXHLP
argument_list|)
operator|)
return|;
else|#
directive|else
name|x
operator|=
name|cmkey2
argument_list|(
name|cmdtab
argument_list|,
name|ncmd
argument_list|,
literal|"C-Kermit command"
argument_list|,
literal|"help"
argument_list|,
name|toktab
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"HELP command x"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|5
condition|)
block|{
name|y
operator|=
name|chktok
argument_list|(
name|toktab
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"top-level cmkey token"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|ungword
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|y
condition|)
block|{
ifndef|#
directive|ifndef
name|NOPUSH
case|case
literal|'!'
case|:
name|x
operator|=
name|XXSHE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NOPUSH */
case|case
literal|'#'
case|:
name|x
operator|=
name|XXCOM
expr_stmt|;
break|break;
case|case
literal|';'
case|:
name|x
operator|=
name|XXCOM
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NOSPL
case|case
literal|':'
case|:
name|x
operator|=
name|XXLBL
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NOSPL */
case|case
literal|'&'
case|:
name|x
operator|=
name|XXECH
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\n?Invalid - %s\n"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
name|x
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
return|return
operator|(
name|dohlp
argument_list|(
name|x
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* NOHELP */
block|}
ifndef|#
directive|ifndef
name|NOHELP
if|if
condition|(
name|cx
operator|==
name|XXINT
condition|)
comment|/* INTRO */
return|return
operator|(
name|hmsga
argument_list|(
name|introtxt
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* NOHELP */
if|if
condition|(
name|cx
operator|==
name|XXHAN
condition|)
block|{
comment|/* HANGUP */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
ifndef|#
directive|ifndef
name|NODIAL
if|if
condition|(
operator|(
name|x
operator|=
name|mdmhup
argument_list|()
operator|)
operator|<
literal|1
condition|)
endif|#
directive|endif
comment|/* NODIAL */
name|x
operator|=
operator|(
name|tthang
argument_list|()
operator|>
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|x
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|cx
operator|==
name|XXGOTO
condition|)
block|{
comment|/* GOTO */
comment|/* Note, here we don't set SUCCESS/FAILURE flag */
if|if
condition|(
operator|(
name|y
operator|=
name|cmfld
argument_list|(
literal|"label"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Label name required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|lblbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|s
operator|=
name|lblbuf
expr_stmt|;
return|return
operator|(
name|dogoto
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOSPL
comment|/* IF, Extended IF, WHILE */
if|if
condition|(
name|cx
operator|==
name|XXIF
operator|||
name|cx
operator|==
name|XXIFX
operator|||
name|cx
operator|==
name|XXWHI
condition|)
block|{
return|return
operator|(
name|doif
argument_list|(
name|cx
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|cx
operator|==
name|XXINP
operator|||
name|cx
operator|==
name|XXREI
condition|)
block|{
comment|/* INPUT and REINPUT */
name|y
operator|=
name|cmnum
argument_list|(
literal|"seconds to wait for input"
argument_list|,
literal|"1"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|y
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
name|x
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"Material to be input"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
ifdef|#
directive|ifdef
name|COMMENT
comment|/*   Now it's ok -- null argument means wait for any character. */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"?Text required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* COMMENT */
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
name|y
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|y
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|s
index|[
name|y
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cx
operator|==
name|XXINP
condition|)
block|{
comment|/* INPUT */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"calling doinput"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|success
operator|=
name|doinput
argument_list|(
name|x
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Go try to input the search string */
block|}
else|else
block|{
comment|/* REINPUT */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxrei line"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|success
operator|=
name|doreinp
argument_list|(
name|x
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intime
operator|&&
operator|!
name|success
condition|)
block|{
comment|/* TIMEOUT-ACTION = QUIT? */
name|popclvl
argument_list|()
expr_stmt|;
comment|/* If so, pop command level. */
if|if
condition|(
name|pflag
operator|&&
name|cmdlvl
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cx
operator|==
name|XXINP
condition|)
name|printf
argument_list|(
literal|"?Input timed out\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx
operator|==
name|XXREI
condition|)
name|printf
argument_list|(
literal|"?Reinput failed\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|success
operator|)
return|;
comment|/* Return do(re)input's return code */
block|}
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOSPL
if|if
condition|(
name|cx
operator|==
name|XXLBL
condition|)
block|{
comment|/* LABEL */
if|if
condition|(
operator|(
name|x
operator|=
name|cmfld
argument_list|(
literal|"label"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Label name required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSPL */
if|if
condition|(
name|cx
operator|==
name|XXLOG
condition|)
block|{
comment|/* LOG */
name|x
operator|=
name|cmkey
argument_list|(
name|logtab
argument_list|,
name|nlog
argument_list|,
literal|"What to log"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Type of log required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|x
operator|=
name|dolog
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
else|else
return|return
operator|(
name|success
operator|=
name|x
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOSCRIPT
if|if
condition|(
name|cx
operator|==
name|XXLOGI
condition|)
block|{
comment|/* UUCP-style script */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"expect-send expect-send ..."
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
ifdef|#
directive|ifdef
name|VMS
name|conres
argument_list|()
expr_stmt|;
comment|/* For Ctrl-C to work... */
endif|#
directive|endif
comment|/* VMS */
return|return
operator|(
name|success
operator|=
name|dologin
argument_list|(
name|s
argument_list|)
operator|)
return|;
comment|/* Return 1=completed, 0=failed */
block|}
endif|#
directive|endif
comment|/* NOSCRIPT */
if|if
condition|(
name|cx
operator|==
name|XXREC
condition|)
block|{
comment|/* RECEIVE */
name|cmarg2
operator|=
literal|""
expr_stmt|;
name|x
operator|=
name|cmofi
argument_list|(
literal|"Name under which to store the file, or CR"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|x
operator|==
operator|-
literal|2
operator|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|cmarg2
operator|=
name|line
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmofi cmarg2"
argument_list|,
name|cmarg2
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sstate
operator|=
literal|'v'
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|scrcreate
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
if|if
condition|(
name|local
condition|)
name|displa
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cx
operator|==
name|XXREM
condition|)
block|{
comment|/* REMOTE */
name|x
operator|=
name|cmkey
argument_list|(
name|remcmd
argument_list|,
name|nrmt
argument_list|,
literal|"Remote Kermit server command"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?You must specify a command for the remote server\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
return|return
operator|(
name|dormt
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
name|cx
operator|==
name|XXREN
condition|)
comment|/* RENAME */
return|return
operator|(
name|dorenam
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* NOFRILLS */
if|if
condition|(
name|cx
operator|==
name|XXSEN
operator|||
name|cx
operator|==
name|XXMAI
condition|)
block|{
comment|/* SEND, MAIL */
name|cmarg
operator|=
name|cmarg2
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmifi
argument_list|(
literal|"File(s) to send"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|y
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?A file specification is required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
name|nfils
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Files come from internal list. */
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Save copy of string just parsed. */
name|strncpy
argument_list|(
name|fspec
argument_list|,
name|s
argument_list|,
name|FSPECL
argument_list|)
expr_stmt|;
comment|/* and here for \v(filespec) */
if|if
condition|(
name|cx
operator|==
name|XXSEN
condition|)
block|{
comment|/* SEND command */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"Send: wild"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Name to send it with"
argument_list|,
literal|""
argument_list|,
operator|&
name|cmarg2
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
block|}
name|cmarg
operator|=
name|line
expr_stmt|;
comment|/* File to send */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"Sending:"
argument_list|,
name|cmarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cmarg2
operator|!=
literal|'\0'
condition|)
name|debug
argument_list|(
name|F110
argument_list|,
literal|" as:"
argument_list|,
name|cmarg2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* MAIL */
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
operator|!
name|atdiso
operator|||
operator|!
name|atcapr
condition|)
block|{
comment|/* Disposition attribute off? */
name|printf
argument_list|(
literal|"?Disposition Attribute is Off\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"Mail: wild"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|optbuf
operator|=
name|NUL
expr_stmt|;
comment|/* Wipe out any old options */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Address to mail to"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Address required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|optbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|optbuf
argument_list|)
operator|>
literal|94
condition|)
block|{
comment|/* Ensure legal size */
name|printf
argument_list|(
literal|"?Option string too long\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|cmarg
operator|=
name|line
expr_stmt|;
comment|/* File to send */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"Mailing:"
argument_list|,
name|cmarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"To:"
argument_list|,
name|optbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rmailf
operator|=
literal|1
expr_stmt|;
comment|/* MAIL modifier flag for SEND */
else|#
directive|else
name|printf
argument_list|(
literal|"?Sorry, MAIL feature not configured.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
endif|#
directive|endif
comment|/* NOFRILLS */
block|}
name|sstate
operator|=
literal|'s'
expr_stmt|;
comment|/* Set start state to SEND */
ifdef|#
directive|ifdef
name|MAC
name|scrcreate
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
if|if
condition|(
name|local
condition|)
block|{
comment|/* If in local mode, */
name|displa
operator|=
literal|1
expr_stmt|;
comment|/* turn on file transfer display */
ifdef|#
directive|ifdef
name|COMMENT
comment|/* Redundant -- this is done later in sipkt() */
name|ttflui
argument_list|()
expr_stmt|;
comment|/* and flush tty input buffer. */
endif|#
directive|endif
comment|/* COMMENT */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOMSEND
if|if
condition|(
name|cx
operator|==
name|XXMSE
condition|)
block|{
comment|/* MSEND command */
name|nfils
operator|=
literal|0
expr_stmt|;
comment|/* Like getting a list of */
name|lp
operator|=
name|line
expr_stmt|;
comment|/* files on the command line */
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmifi
argument_list|(
literal|"Names of files to send, separated by spaces"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|y
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
if|if
condition|(
name|nfils
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?A file specification is required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
break|break;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
name|msfiles
index|[
name|nfils
operator|++
index|]
operator|=
name|lp
expr_stmt|;
comment|/* Got one, count it, point to it, */
name|p
operator|=
name|lp
expr_stmt|;
comment|/* remember pointer, */
while|while
condition|(
operator|*
name|lp
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
comment|/* and copy it into buffer */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"msfiles"
argument_list|,
name|msfiles
index|[
name|nfils
operator|-
literal|1
index|]
argument_list|,
name|nfils
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfils
operator|==
literal|1
condition|)
operator|*
name|fspec
operator|=
name|NUL
expr_stmt|;
comment|/* Take care of \v(filespec) */
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|fspec
argument_list|)
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
operator|)
operator|<
name|FSPECL
condition|)
block|{
name|strcat
argument_list|(
name|fspec
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fspec
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
name|cmlist
operator|=
name|msfiles
expr_stmt|;
comment|/* Point cmlist to pointer array */
name|cmarg2
operator|=
literal|""
expr_stmt|;
comment|/* No internal expansion list (yet) */
name|sndsrc
operator|=
name|nfils
expr_stmt|;
comment|/* Filenames come from cmlist */
name|sstate
operator|=
literal|'s'
expr_stmt|;
comment|/* Set start state to SEND */
ifdef|#
directive|ifdef
name|MAC
name|scrcreate
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
if|if
condition|(
name|local
condition|)
block|{
comment|/* If in local mode, */
name|displa
operator|=
literal|1
expr_stmt|;
comment|/* turn on file transfer display */
name|ttflui
argument_list|()
expr_stmt|;
comment|/* and flush tty input buffer. */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOMSEND */
ifndef|#
directive|ifndef
name|NOSERVER
if|if
condition|(
name|cx
operator|==
name|XXSER
condition|)
block|{
comment|/* SERVER */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|sstate
operator|=
literal|'x'
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|scrcreate
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
if|if
condition|(
name|local
condition|)
name|displa
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|AMIGA
name|reqoff
argument_list|()
expr_stmt|;
comment|/* No DOS requestors while server */
endif|#
directive|endif
comment|/* AMIGA */
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSERVER */
if|if
condition|(
name|cx
operator|==
name|XXSET
condition|)
block|{
comment|/* SET command */
name|x
operator|=
name|cmkey
argument_list|(
name|prmtab
argument_list|,
name|nprm
argument_list|,
literal|"Parameter"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?You must specify a parameter to set\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* have to set success separately for each item in doprm()... */
comment|/* actually not really, could have just had doprm return 0 or 1 */
comment|/* and set success here... */
name|y
operator|=
name|doprm
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?More fields required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOPUSH
if|if
condition|(
name|cx
operator|==
name|XXSHE
condition|)
block|{
comment|/* SHELL (system) command */
if|if
condition|(
name|cmtxt
argument_list|(
literal|"System command to execute"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|conres
argument_list|()
expr_stmt|;
comment|/* Make console normal  */
name|x
operator|=
name|zshcmd
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|concb
argument_list|(
operator|(
name|char
operator|)
name|escape
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|x
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOPUSH */
ifndef|#
directive|ifndef
name|NOSHOW
if|if
condition|(
name|cx
operator|==
name|XXSHO
condition|)
block|{
comment|/* SHOW */
name|x
operator|=
name|cmkey
argument_list|(
name|shotab
argument_list|,
name|nsho
argument_list|,
literal|""
argument_list|,
literal|"parameters"
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|doshow
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSHOW */
ifndef|#
directive|ifndef
name|MAC
if|if
condition|(
name|cx
operator|==
name|XXSPA
condition|)
block|{
comment|/* SPACE */
ifdef|#
directive|ifdef
name|datageneral
comment|/* AOS/VS can take an argument after its "space" command. */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Confirm, or local directory name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
name|NUL
condition|)
name|xsystem
argument_list|(
name|SPACMD
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"space %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|OS2
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Press Enter for current disk,\n\  or specify a disk letter like A:"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
name|NUL
condition|)
block|{
comment|/* Current disk */
name|printf
argument_list|(
literal|" Free space: %ldK\n"
argument_list|,
name|zdskspace
argument_list|(
literal|0
argument_list|)
operator|/
literal|1024L
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|drive
init|=
name|toupper
argument_list|(
operator|*
name|s
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|" Drive %c: %ldK free\n"
argument_list|,
name|drive
argument_list|,
name|zdskspace
argument_list|(
name|drive
operator|-
literal|'A'
operator|+
literal|1
argument_list|)
operator|/
literal|1024L
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|UNIX
ifdef|#
directive|ifdef
name|COMMENT
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Confirm for current disk,\n\  or specify a disk device or directory"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
else|#
directive|else
name|x
operator|=
name|cmdir
argument_list|(
literal|"Confirm for current disk,\n\  or specify a disk device or directory"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
name|s
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
endif|#
directive|endif
comment|/* COMMENT */
if|if
condition|(
operator|*
name|s
operator|==
name|NUL
condition|)
block|{
comment|/* Current disk */
name|xsystem
argument_list|(
name|SPACMD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Specified disk */
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s %s"
argument_list|,
name|SPACM2
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|xsystem
argument_list|(
name|SPACMD
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
endif|#
directive|endif
comment|/* OS2 */
endif|#
directive|endif
comment|/* datageneral */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
comment|/* Pretend it worked */
block|}
endif|#
directive|endif
comment|/* MAC */
if|if
condition|(
name|cx
operator|==
name|XXSTA
condition|)
block|{
comment|/* STATISTICS */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|success
operator|=
name|dostat
argument_list|()
operator|)
return|;
block|}
if|if
condition|(
name|cx
operator|==
name|XXSTO
operator|||
name|cx
operator|==
name|XXEND
condition|)
block|{
comment|/* STOP, END, or POP */
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"exit status code"
argument_list|,
literal|"0"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"Message to print"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
comment|/* Strip any enclosing braces */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|s
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx
operator|==
name|XXSTO
condition|)
name|dostop
argument_list|()
expr_stmt|;
else|else
name|popclvl
argument_list|()
expr_stmt|;
return|return
operator|(
name|success
operator|=
operator|(
name|x
operator|==
literal|0
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|cx
operator|==
name|XXSUS
condition|)
block|{
comment|/* SUSPEND */
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
ifdef|#
directive|ifdef
name|NOJC
name|printf
argument_list|(
literal|"Sorry, this version of Kermit cannot be suspended\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|stptrap
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOJC */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cx
operator|==
name|XXTAK
condition|)
block|{
comment|/* TAKE */
if|if
condition|(
name|tlevel
operator|>
name|MAXTAKE
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"?Take files nested too deeply\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmifi
argument_list|(
literal|"C-Kermit command file"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?A file name is required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Wildcards not allowed in command file name\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
return|return
operator|(
name|success
operator|=
name|dotake
argument_list|(
name|line
argument_list|)
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|NETCONN
if|if
condition|(
name|cx
operator|==
name|XXTEL
condition|)
block|{
comment|/* TELNET */
if|if
condition|(
operator|(
name|y
operator|=
name|setlin
argument_list|(
name|XYHOST
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
return|return
operator|(
name|success
operator|=
operator|(
name|y
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|doconect
argument_list|()
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NETCONN */
ifndef|#
directive|ifndef
name|NOXMIT
if|if
condition|(
name|cx
operator|==
name|XXTRA
condition|)
block|{
comment|/* TRANSMIT */
if|if
condition|(
operator|(
name|x
operator|=
name|cmifi
argument_list|(
literal|"File to transmit"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|y
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Name of an existing file\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Only a single file may be transmitted\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Save copy of string just parsed. */
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* Confirm the command */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"calling transmit"
argument_list|,
name|line
argument_list|,
name|xmitp
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|transmit
argument_list|(
name|line
argument_list|,
operator|(
name|char
operator|)
name|xmitp
argument_list|)
operator|)
return|;
comment|/* Do the command */
block|}
endif|#
directive|endif
comment|/* NOXMIT */
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
name|cx
operator|==
name|XXTYP
condition|)
block|{
comment|/* TYPE */
ifndef|#
directive|ifndef
name|MAC
name|char
modifier|*
name|tc
decl_stmt|;
endif|#
directive|endif
comment|/* MAC */
if|if
condition|(
operator|(
name|x
operator|=
name|cmifi
argument_list|(
literal|"File to type"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|y
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Name of an existing file\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?A single file please\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|MAC
if|if
condition|(
operator|!
operator|(
name|tc
operator|=
name|getenv
argument_list|(
literal|"CK_TYPE"
argument_list|)
operator|)
condition|)
name|tc
operator|=
name|TYPCMD
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s %s"
argument_list|,
name|tc
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* Confirm the command */
name|xsystem
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
else|#
directive|else
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* Confirm the command */
return|return
operator|(
name|success
operator|=
name|dotype
argument_list|(
name|line
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* MAC */
block|}
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
name|cx
operator|==
name|XXTES
condition|)
block|{
comment|/* TEST */
comment|/* Fill this in with whatever is being tested... */
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* Confirm the command */
ifndef|#
directive|ifndef
name|NOSPL
ifdef|#
directive|ifdef
name|COMMENT
block|{
name|int
name|d
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Dump all arrays */
name|char
name|c
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|27
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|a_ptr
index|[
name|i
index|]
expr_stmt|;
name|d
operator|=
name|a_dim
index|[
name|i
index|]
expr_stmt|;
name|c
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|64
else|:
name|i
operator|+
literal|96
expr_stmt|;
if|if
condition|(
name|d
operator|&&
name|p
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"&%c[%d]\n"
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|d
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|j
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"&%c[%2d] = [%s]\n"
argument_list|,
name|c
argument_list|,
name|j
argument_list|,
name|p
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|#
directive|else
comment|/* Not COMMENT */
name|printf
argument_list|(
literal|"cmdlvl = %d, tlevel = %d, maclvl = %d\n"
argument_list|,
name|cmdlvl
argument_list|,
name|tlevel
argument_list|,
name|maclvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|maclvl
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
literal|"Call me from inside a macro and I'll dump the argument stack"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"Macro level: %d, ARGC = %d\n     "
argument_list|,
name|maclvl
argument_list|,
name|macargc
index|[
name|maclvl
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|10
condition|;
name|y
operator|++
control|)
name|printf
argument_list|(
literal|"%7d"
argument_list|,
name|y
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|maclvl
condition|;
name|x
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\n%2d:  "
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|10
condition|;
name|y
operator|++
control|)
block|{
name|s
operator|=
name|m_arg
index|[
name|x
index|]
index|[
name|y
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%7s"
argument_list|,
name|s
condition|?
name|s
else|:
literal|"(none)"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMMENT */
endif|#
directive|endif
comment|/* NOSPL */
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|NOCSETS
if|if
condition|(
name|cx
operator|==
name|XXXLA
condition|)
block|{
comment|/* TRANSLATE<ifn> from-cs to-cs<ofn> */
name|int
name|incs
decl_stmt|,
name|outcs
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmifi
argument_list|(
literal|"File to translate"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|y
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Name of an existing file\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?A single file please\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Save copy of string just parsed. */
if|if
condition|(
operator|(
name|incs
operator|=
name|cmkey
argument_list|(
name|fcstab
argument_list|,
name|nfilc
argument_list|,
literal|"from character-set"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|incs
operator|)
return|;
if|if
condition|(
operator|(
name|outcs
operator|=
name|cmkey
argument_list|(
name|fcstab
argument_list|,
name|nfilc
argument_list|,
literal|"to character-set"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|outcs
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmofi
argument_list|(
literal|"output file"
argument_list|,
name|CTTNAM
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|strncpy
argument_list|(
name|tmpbuf
argument_list|,
name|s
argument_list|,
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* Confirm the command */
return|return
operator|(
name|success
operator|=
name|xlate
argument_list|(
name|line
argument_list|,
name|tmpbuf
argument_list|,
name|incs
argument_list|,
name|outcs
argument_list|)
operator|)
return|;
comment|/* Execute it */
block|}
endif|#
directive|endif
comment|/* NOCSETS */
if|if
condition|(
name|cx
operator|==
name|XXVER
condition|)
block|{
comment|/* VERSION */
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|printf
argument_list|(
literal|"%s,%s\n Numeric: %ld"
argument_list|,
name|versio
argument_list|,
name|ckxsys
argument_list|,
name|vernum
argument_list|)
expr_stmt|;
if|if
condition|(
name|verwho
condition|)
name|printf
argument_list|(
literal|"-%d\n"
argument_list|,
name|verwho
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|MAC
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
name|cx
operator|==
name|XXWHO
condition|)
block|{
comment|/* WHO */
name|char
modifier|*
name|wc
decl_stmt|;
ifdef|#
directive|ifdef
name|datageneral
name|xsystem
argument_list|(
name|WHOCMD
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"user name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|wc
operator|=
name|getenv
argument_list|(
literal|"CK_WHO"
argument_list|)
operator|)
condition|)
name|wc
operator|=
name|WHOCMD
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s %s"
argument_list|,
name|wc
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* datageneral */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOFRILLS */
endif|#
directive|endif
comment|/* MAC */
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
name|cx
operator|==
name|XXWRI
condition|)
block|{
comment|/* WRITE */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|writab
argument_list|,
name|nwri
argument_list|,
literal|"to file or log"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
name|printf
argument_list|(
literal|"?Write to what?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"text"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
comment|/* Strip enclosing braces */
name|y
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|y
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|s
index|[
name|y
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|LOGD
case|:
name|y
operator|=
name|ZDFILE
expr_stmt|;
break|break;
case|case
name|LOGP
case|:
name|y
operator|=
name|ZPFILE
expr_stmt|;
break|break;
case|case
name|LOGS
case|:
name|y
operator|=
name|ZSFILE
expr_stmt|;
break|break;
case|case
name|LOGT
case|:
name|y
operator|=
name|ZTFILE
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NOSPL
case|case
name|LOGW
case|:
name|y
operator|=
name|ZWFILE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NOSPL */
case|case
name|LOGX
case|:
case|case
name|LOGE
case|:
ifndef|#
directive|ifndef
name|MAC
if|if
condition|(
name|x
operator|==
name|LOGE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* MAC */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
ifndef|#
directive|ifndef
name|NOSPL
name|cmdlvl
operator|==
literal|0
else|#
directive|else
name|tlevel
operator|==
operator|-
literal|1
endif|#
directive|endif
comment|/* NOSPL */
condition|)
ifndef|#
directive|ifndef
name|MAC
if|if
condition|(
name|x
operator|==
name|LOGE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* MAC */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|x
operator|=
name|zsout
argument_list|(
name|y
argument_list|,
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"?File or log not open\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
operator|(
name|x
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOFRILLS */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"docmd unk arg"
argument_list|,
literal|""
argument_list|,
name|cx
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
comment|/* None of the above. */
block|}
end_function

begin_comment
comment|/* end of docmnd() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOICP */
end_comment

end_unit

