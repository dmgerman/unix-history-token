begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|NOICP
end_ifndef

begin_comment
comment|/*  C K U U S 7 --  "User Interface" for Unix Kermit, part 7  */
end_comment

begin_comment
comment|/*   Author: Frank da Cruz (fdc@columbia.edu, FDCCU@CUVMA.BITNET),   Columbia University Center for Computing Activities.   First released January 1985.   Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University. */
end_comment

begin_comment
comment|/*   This file created from parts of ckuus3.c, which became to big for   Mark Williams Coherent compiler to handle. */
end_comment

begin_comment
comment|/*   Definitions here supersede those from system include files. */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_comment
comment|/* Debugging& compiler things */
end_comment

begin_include
include|#
directive|include
file|"ckcasc.h"
end_include

begin_comment
comment|/* ASCII character symbols */
end_comment

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_comment
comment|/* Kermit application definitions */
end_comment

begin_include
include|#
directive|include
file|"ckcxla.h"
end_include

begin_comment
comment|/* Character set translation */
end_comment

begin_include
include|#
directive|include
file|"ckcnet.h"
end_include

begin_comment
comment|/* Network symbols */
end_comment

begin_include
include|#
directive|include
file|"ckuusr.h"
end_include

begin_comment
comment|/* User interface symbols */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|x
decl_stmt|,
name|y
init|=
literal|0
decl_stmt|,
name|z
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mdmsav
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save modem type around network */
end_comment

begin_decl_stmt
specifier|static
name|int
name|oldplex
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Duplex holder around network */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|success
decl_stmt|,
name|nfilp
decl_stmt|,
name|fmask
decl_stmt|,
name|fncnv
decl_stmt|,
name|frecl
decl_stmt|,
name|nfttyp
decl_stmt|,
name|binary
decl_stmt|,
name|warn
decl_stmt|,
name|msgflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cmask
decl_stmt|,
name|maxrps
decl_stmt|,
name|wslotr
decl_stmt|,
name|bigsbsiz
decl_stmt|,
name|bigrbsiz
decl_stmt|,
name|urpsiz
decl_stmt|,
name|rpsiz
decl_stmt|,
name|spsiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|spsizr
decl_stmt|,
name|spsizf
decl_stmt|,
name|maxsps
decl_stmt|,
name|spmax
decl_stmt|,
name|pflag
decl_stmt|,
name|bctr
decl_stmt|,
name|npad
decl_stmt|,
name|timef
decl_stmt|,
name|timint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pkttim
decl_stmt|,
name|rtimo
decl_stmt|,
name|local
decl_stmt|,
name|nfils
decl_stmt|,
name|displa
decl_stmt|,
name|atcapr
decl_stmt|,
name|nettype
decl_stmt|,
name|escape
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|mdmtyp
decl_stmt|,
name|duplex
decl_stmt|,
name|dfloc
decl_stmt|,
name|network
decl_stmt|,
name|cdtimo
decl_stmt|,
name|fncact
decl_stmt|,
name|mypadn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tnlm
decl_stmt|,
name|sosi
decl_stmt|,
name|tlevel
decl_stmt|,
name|lf_opts
decl_stmt|,
name|backgrd
decl_stmt|,
name|flow
decl_stmt|,
name|fdispla
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|atenci
decl_stmt|,
name|atenco
decl_stmt|,
name|atdati
decl_stmt|,
name|atdato
decl_stmt|,
name|atleni
decl_stmt|,
name|atleno
decl_stmt|,
name|atblki
decl_stmt|,
name|atblko
decl_stmt|,
name|attypi
decl_stmt|,
name|attypo
decl_stmt|,
name|atsidi
decl_stmt|,
name|atsido
decl_stmt|,
name|atsysi
decl_stmt|,
name|atsyso
decl_stmt|,
name|atdisi
decl_stmt|,
name|atdiso
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|speed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|sstate
decl_stmt|,
name|eol
decl_stmt|,
name|seol
decl_stmt|,
name|stchr
decl_stmt|,
name|mystch
decl_stmt|,
name|mypadc
decl_stmt|,
name|padch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|cmarg
decl_stmt|,
modifier|*
name|cmarg2
decl_stmt|,
modifier|*
name|dftty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|tmpbuf
index|[]
decl_stmt|,
modifier|*
name|tp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary buffer& pointers */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOFRILLS
end_ifndef

begin_decl_stmt
specifier|extern
name|char
name|optbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for MAIL or PRINT options */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rprintf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* REMOTE PRINT flag */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOFRILLS */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|ttname
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|onoff
index|[]
decl_stmt|,
name|filtab
index|[]
decl_stmt|,
name|fttab
index|[]
decl_stmt|,
name|rltab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nrlt
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|atxbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Atom buffer */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|cmdbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffer */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character buffer for anything */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CK_CURSES
end_ifdef

begin_comment
comment|/* This needs cleaning up... */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|trmbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Termcap buffer */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|trmbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Termcap buffer */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OSK
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|trmbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Termcap buffer */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OSK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AMIGA
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|trmbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Termcap buffer */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AMIGA */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CK_CURSES */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
name|atxbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Atom buffer */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|cmdbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffer */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|line
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character buffer for anything */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CK_CURSES
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_decl_stmt
specifier|extern
name|char
name|trmbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Termcap buffer */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CK_CURSES */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOCSETS
end_ifndef

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|fcstab
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For 'set file character-set' */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|ttcstab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfilc
decl_stmt|,
name|fcharset
decl_stmt|,
name|ntermc
decl_stmt|,
name|tcsr
decl_stmt|,
name|tcsl
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOCSETS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|cmdlvl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Overall command level */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TNCODE
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|tn_init
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TNCODE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SUNX25
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|revcall
decl_stmt|,
name|closgr
decl_stmt|,
name|cudata
decl_stmt|,
name|nx25
decl_stmt|,
name|npadx3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|udata
index|[
name|MAXCUDATA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|padparms
index|[
name|MAXPADPARMS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|x25tab
index|[]
decl_stmt|,
name|padx3tab
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUNX25 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CK_CURSES
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_macro
name|_PROTOTYP
argument_list|(
argument|int tgetent
argument_list|,
argument|(char *, char *)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CK_CURSES */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NODIAL
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|dialhng
decl_stmt|,
name|dialtmo
decl_stmt|,
name|dialksp
decl_stmt|,
name|dialdpy
decl_stmt|,
name|dialmnp
decl_stmt|,
name|dialmhu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|mdmspd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|dialini
decl_stmt|,
modifier|*
name|dialdir
decl_stmt|,
modifier|*
name|dialcmd
decl_stmt|,
modifier|*
name|dialnpr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|dialfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|dialtab
index|[]
init|=
block|{
literal|"dial-command"
block|,
name|XYDDIA
block|,
literal|0
block|,
literal|"directory"
block|,
name|XYDDIR
block|,
literal|0
block|,
literal|"display"
block|,
name|XYDDPY
block|,
literal|0
block|,
literal|"hangup"
block|,
name|XYDHUP
block|,
literal|0
block|,
literal|"init-string"
block|,
name|XYDINI
block|,
literal|0
block|,
literal|"kermit-spoof"
block|,
name|XYDKSP
block|,
literal|0
block|,
literal|"mnp-enable"
block|,
name|XYDMNP
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|MDMHUP
literal|"modem-hangup"
block|,
name|XYDMHU
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* MDMHUP */
literal|"prefix"
block|,
name|XYDNPR
block|,
literal|0
block|,
literal|"speed-matching"
block|,
name|XYDSPD
block|,
literal|0
block|,
literal|"timeout"
block|,
name|XYDTMO
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ndial
init|=
operator|(
sizeof|sizeof
argument_list|(
name|dialtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NODIAL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOXMIT
end_ifndef

begin_comment
comment|/* set transmit */
end_comment

begin_define
define|#
directive|define
name|XMITF
value|0
end_define

begin_define
define|#
directive|define
name|XMITL
value|1
end_define

begin_define
define|#
directive|define
name|XMITP
value|2
end_define

begin_define
define|#
directive|define
name|XMITE
value|3
end_define

begin_define
define|#
directive|define
name|XMITX
value|4
end_define

begin_define
define|#
directive|define
name|XMITS
value|5
end_define

begin_define
define|#
directive|define
name|XMITW
value|6
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NOXMIT
end_ifndef

begin_define
define|#
directive|define
name|XMBUFL
value|50
end_define

begin_decl_stmt
specifier|extern
name|int
name|xmitf
decl_stmt|,
name|xmitl
decl_stmt|,
name|xmitp
decl_stmt|,
name|xmitx
decl_stmt|,
name|xmits
decl_stmt|,
name|xmitw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|xmitbuf
index|[
name|XMBUFL
operator|+
literal|1
index|]
init|=
block|{
name|NUL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRANSMIT eof string */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOXMIT */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|xmitab
index|[]
init|=
block|{
literal|"echo"
block|,
name|XMITX
block|,
literal|0
block|,
literal|"eof"
block|,
name|XMITE
block|,
literal|0
block|,
literal|"fill"
block|,
name|XMITF
block|,
literal|0
block|,
literal|"linefeed"
block|,
name|XMITL
block|,
literal|0
block|,
literal|"locking-shift"
block|,
name|XMITS
block|,
literal|0
block|,
literal|"pause"
block|,
name|XMITW
block|,
literal|0
block|,
literal|"prompt"
block|,
name|XMITP
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nxmit
init|=
operator|(
sizeof|sizeof
argument_list|(
name|xmitab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOXMIT */
end_comment

begin_comment
comment|/* For SET FILE COLLISION */
end_comment

begin_comment
comment|/* Some of the following may be possible for some C-Kermit implementations */
end_comment

begin_comment
comment|/* but not others.  Those that are not possible for your implementation */
end_comment

begin_comment
comment|/* should be ifdef'd out. */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|colxtab
index|[]
init|=
block|{
comment|/* SET FILE COLLISION options */
literal|"append"
block|,
name|XYFX_A
block|,
literal|0
block|,
comment|/* append to old file */
ifdef|#
directive|ifdef
name|COMMENT
literal|"ask"
block|,
name|XYFX_Q
block|,
literal|0
block|,
comment|/* ask what to do (not implemented) */
endif|#
directive|endif
literal|"backup"
block|,
name|XYFX_B
block|,
literal|0
block|,
comment|/* rename old file */
literal|"discard"
block|,
name|XYFX_D
block|,
literal|0
block|,
comment|/* don't accept new file */
literal|"no-supersede"
block|,
name|XYFX_D
block|,
name|CM_INV
block|,
comment|/* ditto (MSK compatibility) */
literal|"overwrite"
block|,
name|XYFX_X
block|,
literal|0
block|,
comment|/* overwrite the old file == file warning off */
literal|"rename"
block|,
name|XYFX_R
block|,
literal|0
block|,
comment|/* rename the incoming file == file warning on */
literal|"update"
block|,
name|XYFX_U
block|,
literal|0
block|,
comment|/* replace if newer */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ncolx
init|=
operator|(
sizeof|sizeof
argument_list|(
name|colxtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|keytab
name|rfiltab
index|[]
init|=
block|{
comment|/* for REMOTE SET FILE */
literal|"collision"
block|,
name|XYFILX
block|,
literal|0
block|,
literal|"record-length"
block|,
name|XYFILR
block|,
literal|0
block|,
literal|"type"
block|,
name|XYFILT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nrfilp
init|=
operator|(
sizeof|sizeof
argument_list|(
name|rfiltab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|fntab
index|[]
init|=
block|{
comment|/* File naming */
literal|"converted"
block|,
literal|1
block|,
literal|0
block|,
literal|"literal"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal parameters table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|trmtab
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|OS2
literal|"arrow-keys"
block|,
name|XYTARR
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* OS2 */
literal|"bytesize"
block|,
name|XYTBYT
block|,
literal|0
block|,
ifndef|#
directive|ifndef
name|NOCSETS
literal|"character-set"
block|,
name|XYTCS
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOCSETS */
ifdef|#
directive|ifdef
name|OS2
literal|"color"
block|,
name|XYTCOL
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* OS2 */
literal|"cr-display"
block|,
name|XYTCRD
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|OS2
literal|"cursor"
block|,
name|XYTCUR
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* OS2 */
literal|"echo"
block|,
name|XYTEC
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|OS2
literal|"keypad-mode"
block|,
name|XYTKPD
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* OS2 */
literal|"locking-shift"
block|,
name|XYTSO
block|,
literal|0
block|,
literal|"newline-mode"
block|,
name|XYTNL
block|,
literal|0
ifdef|#
directive|ifdef
name|OS2
block|,
literal|"type"
block|,
name|XYTTYP
block|,
literal|0
block|,
literal|"wrap"
block|,
name|XYTWRP
block|,
literal|0
endif|#
directive|endif
comment|/* OS2 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ntrm
init|=
operator|(
sizeof|sizeof
argument_list|(
name|trmtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|crdtab
index|[]
init|=
block|{
comment|/* Carriage-return display */
literal|"crlf"
block|,
literal|1
block|,
literal|0
block|,
literal|"normal"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tt_crd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Carriage-return display variable */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_comment
comment|/*   OS/2 serial communication devices. */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|os2devtab
index|[]
init|=
block|{
literal|"1"
block|,
literal|1
block|,
name|CM_INV
block|,
comment|/* Invisible synonyms, like */
literal|"2"
block|,
literal|2
block|,
name|CM_INV
block|,
comment|/* "set port 1" */
literal|"3"
block|,
literal|3
block|,
name|CM_INV
block|,
literal|"4"
block|,
literal|4
block|,
name|CM_INV
block|,
literal|"5"
block|,
literal|5
block|,
name|CM_INV
block|,
literal|"6"
block|,
literal|6
block|,
name|CM_INV
block|,
literal|"7"
block|,
literal|7
block|,
name|CM_INV
block|,
literal|"8"
block|,
literal|8
block|,
name|CM_INV
block|,
literal|"com1"
block|,
literal|1
block|,
literal|0
block|,
comment|/* Real device names */
literal|"com2"
block|,
literal|2
block|,
literal|0
block|,
literal|"com3"
block|,
literal|3
block|,
literal|0
block|,
literal|"com4"
block|,
literal|4
block|,
literal|0
block|,
literal|"com5"
block|,
literal|5
block|,
literal|0
block|,
literal|"com6"
block|,
literal|6
block|,
literal|0
block|,
literal|"com7"
block|,
literal|7
block|,
literal|0
block|,
literal|"com8"
block|,
literal|7
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nos2dev
init|=
operator|(
sizeof|sizeof
argument_list|(
name|os2devtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   Terminal parameters that can be set by SET commands.   Used by the ck?con.c terminal emulator code.     For now, only use for OS/2.  Should add these for Macintosh. */
end_comment

begin_decl_stmt
name|int
name|tt_arrow
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Arrow key mode */
end_comment

begin_decl_stmt
name|int
name|tt_keypad
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keypad mode */
end_comment

begin_decl_stmt
name|int
name|tt_wrap
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Autowrap */
end_comment

begin_decl_stmt
name|int
name|tt_type
init|=
name|TT_VT102
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal type */
end_comment

begin_decl_stmt
name|int
name|tt_cursor
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cursor type */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_decl_stmt
name|struct
name|keytab
name|akmtab
index|[]
init|=
block|{
comment|/* Arrow key mode */
literal|"application"
block|,
literal|1
block|,
literal|0
block|,
literal|"cursor"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|kpmtab
index|[]
init|=
block|{
comment|/* Keypad mode */
literal|"application"
block|,
literal|0
block|,
literal|0
block|,
literal|"numeric"
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|ttycoltab
index|[]
init|=
block|{
comment|/* Items to be colored */
literal|"help"
block|,
literal|4
block|,
literal|0
block|,
comment|/* Help screen */
literal|"normal"
block|,
literal|0
block|,
literal|0
block|,
comment|/* Normal screen text */
literal|"reverse"
block|,
literal|1
block|,
literal|0
block|,
comment|/* Reverse video */
literal|"status"
block|,
literal|3
block|,
literal|0
block|,
comment|/* Status line */
literal|"underlined"
block|,
literal|2
block|,
literal|0
comment|/* Underlined text */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ncolors
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|ttyclrtab
index|[]
init|=
block|{
comment|/* Colors */
literal|"black"
block|,
literal|0
block|,
literal|0
block|,
literal|"blue"
block|,
literal|1
block|,
literal|0
block|,
literal|"brown"
block|,
literal|6
block|,
literal|0
block|,
literal|"cyan"
block|,
literal|3
block|,
literal|0
block|,
literal|"dgray"
block|,
literal|8
block|,
literal|0
block|,
literal|"green"
block|,
literal|2
block|,
literal|0
block|,
literal|"lblue"
block|,
literal|9
block|,
literal|0
block|,
literal|"lcyan"
block|,
literal|11
block|,
literal|0
block|,
literal|"lgray"
block|,
literal|7
block|,
literal|0
block|,
literal|"lgreen"
block|,
literal|10
block|,
literal|0
block|,
literal|"lmagenta"
block|,
literal|13
block|,
literal|0
block|,
literal|"lred"
block|,
literal|12
block|,
literal|0
block|,
literal|"magenta"
block|,
literal|5
block|,
literal|0
block|,
literal|"red"
block|,
literal|4
block|,
literal|0
block|,
literal|"white"
block|,
literal|15
block|,
literal|0
block|,
literal|"yellow"
block|,
literal|14
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nclrs
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|ttycurtab
index|[]
init|=
block|{
literal|"full"
block|,
literal|2
block|,
literal|0
block|,
literal|"half"
block|,
literal|1
block|,
literal|0
block|,
literal|"underline"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ncursors
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_decl_stmt
name|struct
name|keytab
name|ttyptab
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|COMMENT
comment|/*   Not supported yet...   The idea is to let the console driver handle the escape sequences. */
literal|"none"
block|,
name|TT_NONE
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* COMMENT */
ifdef|#
directive|ifdef
name|OS2PM
literal|"tek4014"
block|,
name|TT_TEK40
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* OS2PM */
literal|"vt102"
block|,
name|TT_VT102
block|,
literal|0
block|,
literal|"vt52"
block|,
name|TT_VT52
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nttyp
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS2 */
end_comment

begin_comment
comment|/* #ifdef VMS */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|fbtab
index|[]
init|=
block|{
comment|/* Binary record types for VMS */
literal|"fixed"
block|,
name|XYFT_B
block|,
literal|0
block|,
comment|/* Fixed is normal for binary */
literal|"undefined"
block|,
name|XYFT_U
block|,
literal|0
comment|/* Undefined if they ask for it */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfbtyp
init|=
operator|(
sizeof|sizeof
argument_list|(
name|fbtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #endif */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_decl_stmt
name|struct
name|keytab
name|lbltab
index|[]
init|=
block|{
comment|/* Labeled File info */
literal|"acl"
block|,
name|LBL_ACL
block|,
literal|0
block|,
literal|"backup-date"
block|,
name|LBL_BCK
block|,
literal|0
block|,
literal|"name"
block|,
name|LBL_NAM
block|,
literal|0
block|,
literal|"owner"
block|,
name|LBL_OWN
block|,
literal|0
block|,
literal|"path"
block|,
name|LBL_PTH
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nlblp
init|=
operator|(
sizeof|sizeof
argument_list|(
name|lbltab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|fdtab
index|[]
init|=
block|{
comment|/* SET FILE DISPLAY options */
ifdef|#
directive|ifdef
name|MAC
comment|/* Macintosh */
literal|"fullscreen"
block|,
name|XYFD_R
block|,
literal|0
block|,
comment|/* Full-screen but not curses */
literal|"none"
block|,
name|XYFD_N
block|,
literal|0
block|,
literal|"off"
block|,
name|XYFD_N
block|,
name|CM_INV
block|,
literal|"on"
block|,
name|XYFD_R
block|,
name|CM_INV
block|,
literal|"quiet"
block|,
name|XYFD_N
block|,
name|CM_INV
else|#
directive|else
comment|/* Not Mac */
literal|"crt"
block|,
name|XYFD_S
block|,
literal|0
block|,
comment|/* CRT display */
ifdef|#
directive|ifdef
name|CK_CURSES
ifdef|#
directive|ifdef
name|COMMENT
literal|"curses"
block|,
name|XYFD_C
block|,
name|CM_INV
block|,
comment|/* Full-screen, curses */
endif|#
directive|endif
comment|/* COMMENT */
literal|"fullscreen"
block|,
name|XYFD_C
block|,
literal|0
block|,
comment|/* Full-screen, whatever the method */
endif|#
directive|endif
comment|/* CK_CURSES */
literal|"none"
block|,
name|XYFD_N
block|,
literal|0
block|,
comment|/* No display */
literal|"off"
block|,
name|XYFD_N
block|,
name|CM_INV
block|,
comment|/* Ditto */
literal|"on"
block|,
name|XYFD_R
block|,
name|CM_INV
block|,
comment|/* On = Serial */
literal|"quiet"
block|,
name|XYFD_N
block|,
name|CM_INV
block|,
comment|/* No display */
literal|"serial"
block|,
name|XYFD_R
block|,
literal|0
comment|/* Serial */
endif|#
directive|endif
comment|/* MAC */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfdtab
init|=
operator|(
sizeof|sizeof
argument_list|(
name|fdtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|rsrtab
index|[]
init|=
block|{
comment|/* For REMOTE SET RECEIVE */
literal|"packet-length"
block|,
name|XYLEN
block|,
literal|0
block|,
literal|"timeout"
block|,
name|XYTIMO
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nrsrtab
init|=
operator|(
sizeof|sizeof
argument_list|(
name|rsrtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send/Receive Parameters */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|srtab
index|[]
init|=
block|{
literal|"end-of-packet"
block|,
name|XYEOL
block|,
literal|0
block|,
literal|"packet-length"
block|,
name|XYLEN
block|,
literal|0
block|,
literal|"pad-character"
block|,
name|XYPADC
block|,
literal|0
block|,
literal|"padding"
block|,
name|XYNPAD
block|,
literal|0
block|,
literal|"start-of-packet"
block|,
name|XYMARK
block|,
literal|0
block|,
literal|"timeout"
block|,
name|XYTIMO
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsrtab
init|=
operator|(
sizeof|sizeof
argument_list|(
name|srtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* REMOTE SET */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|rmstab
index|[]
init|=
block|{
literal|"attributes"
block|,
name|XYATTR
block|,
literal|0
block|,
literal|"block-check"
block|,
name|XYCHKT
block|,
literal|0
block|,
literal|"file"
block|,
name|XYFILE
block|,
literal|0
block|,
literal|"incomplete"
block|,
name|XYIFD
block|,
literal|0
block|,
literal|"receive"
block|,
name|XYRECV
block|,
literal|0
block|,
literal|"retry"
block|,
name|XYRETR
block|,
literal|0
block|,
literal|"server"
block|,
name|XYSERV
block|,
literal|0
block|,
literal|"transfer"
block|,
name|XYXFER
block|,
literal|0
block|,
literal|"window"
block|,
name|XYWIND
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nrms
init|=
operator|(
sizeof|sizeof
argument_list|(
name|rmstab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|attrtab
index|[]
init|=
block|{
literal|"all"
block|,
name|AT_XALL
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|COMMENT
literal|"blocksize"
block|,
name|AT_BLKS
block|,
literal|0
block|,
comment|/* not used */
endif|#
directive|endif
comment|/* COMMENT */
literal|"character-set"
block|,
name|AT_ENCO
block|,
literal|0
block|,
literal|"date"
block|,
name|AT_DATE
block|,
literal|0
block|,
literal|"disposition"
block|,
name|AT_DISP
block|,
literal|0
block|,
literal|"encoding"
block|,
name|AT_ENCO
block|,
name|CM_INV
block|,
literal|"length"
block|,
name|AT_LENK
block|,
literal|0
block|,
literal|"off"
block|,
name|AT_ALLN
block|,
literal|0
block|,
literal|"on"
block|,
name|AT_ALLY
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|COMMENT
literal|"os-specific"
block|,
name|AT_SYSP
block|,
literal|0
block|,
comment|/* not used by UNIX or VMS */
endif|#
directive|endif
comment|/* COMMENT */
literal|"system-id"
block|,
name|AT_SYSI
block|,
literal|0
block|,
literal|"type"
block|,
name|AT_FTYP
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|natr
init|=
operator|(
sizeof|sizeof
argument_list|(
name|attrtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many attributes */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|indef
decl_stmt|,
name|intime
decl_stmt|,
name|incase
decl_stmt|,
name|inecho
decl_stmt|,
name|insilence
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|inptab
index|[]
init|=
block|{
comment|/* SET INPUT parameters */
literal|"case"
block|,
name|IN_CAS
block|,
literal|0
block|,
literal|"default-timeout"
block|,
name|IN_DEF
block|,
name|CM_INV
block|,
literal|"echo"
block|,
name|IN_ECH
block|,
literal|0
block|,
literal|"silence"
block|,
name|IN_SIL
block|,
literal|0
block|,
literal|"timeout-action"
block|,
name|IN_TIM
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ninp
init|=
operator|(
sizeof|sizeof
argument_list|(
name|inptab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|intimt
index|[]
init|=
block|{
comment|/* SET INPUT TIMEOUT parameters */
literal|"proceed"
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0 = proceed */
literal|"quit"
block|,
literal|1
block|,
literal|0
comment|/* 1 = quit */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|incast
index|[]
init|=
block|{
comment|/* SET INPUT CASE parameters */
literal|"ignore"
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0 = ignore */
literal|"observe"
block|,
literal|1
block|,
literal|0
comment|/* 1 = observe */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The following routines broken out of doprm() to give compilers a break. */
end_comment

begin_comment
comment|/*  S E T O N  --  Parse on/off (default on), set parameter to result  */
end_comment

begin_function
name|int
name|seton
parameter_list|(
name|prm
parameter_list|)
name|int
modifier|*
name|prm
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|onoff
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|"on"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
operator|*
name|prm
operator|=
name|y
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  S E T N U M  --  Set parameter to result of cmnum() parse.  */
end_comment

begin_comment
comment|/*  Call with pointer to integer variable to be set,    x = number from cnum parse, y = return code from cmnum,    max = maximum value to accept, -1 if no maximum.  Returns -9 on failure, after printing a message, or 1 on success. */
end_comment

begin_function
name|int
name|setnum
parameter_list|(
name|prm
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|max
parameter_list|)
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
decl|*
name|prm
decl_stmt|,
name|max
decl_stmt|;
end_function

begin_block
block|{
specifier|extern
name|int
name|cmflgs
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"setnum"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"\n?Value required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|y
operator|==
operator|-
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"%s?Not a number: %s\n"
argument_list|,
name|cmflgs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"\n"
argument_list|,
name|atxbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|max
operator|>
operator|-
literal|1
operator|&&
name|x
operator|>
name|max
condition|)
block|{
name|printf
argument_list|(
literal|"?Sorry, %d is the maximum\n"
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
operator|*
name|prm
operator|=
name|x
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  S E T C C  --  Set parameter to an ASCII control character value.  */
end_comment

begin_function
name|int
name|setcc
parameter_list|(
name|prm
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
decl|*
name|prm
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"\n?Value required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
if|if
condition|(
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|>
literal|037
operator|)
operator|&&
operator|(
name|x
operator|!=
literal|0177
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n?Not in ASCII control range - %d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
operator|*
name|prm
operator|=
name|x
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|NODIAL
end_ifndef

begin_macro
name|_PROTOTYP
argument_list|(
argument|static int dialstr
argument_list|,
argument|(char **, char *)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*   Parse a DIAL-related string, stripping enclosing braces, if any. */
end_comment

begin_function
specifier|static
name|int
name|dialstr
parameter_list|(
name|p
parameter_list|,
name|msg
parameter_list|)
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
name|msg
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
comment|/* Strip enclosing braces, if any */
name|x
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|p
condition|)
block|{
comment|/* Free any previous string. */
name|free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|x
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
operator|*
name|p
operator|=
name|malloc
argument_list|(
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Allocate space for it */
name|strcpy
argument_list|(
operator|*
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* and make a safe copy. */
block|}
else|else
operator|*
name|p
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
comment|/* Set DIAL command options */
name|setdial
parameter_list|()
block|{
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|dialtab
argument_list|,
name|ndial
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|y
condition|)
block|{
case|case
name|XYDHUP
case|:
comment|/* DIAL HANGUP */
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|dialhng
argument_list|)
operator|)
return|;
case|case
name|XYDINI
case|:
comment|/* DIAL INIT-STRING */
return|return
operator|(
name|dialstr
argument_list|(
operator|&
name|dialini
argument_list|,
literal|"Modem dialer initialization string"
argument_list|)
operator|)
return|;
case|case
name|XYDNPR
case|:
comment|/* DIAL NUMBER-PREFIX */
return|return
operator|(
name|dialstr
argument_list|(
operator|&
name|dialnpr
argument_list|,
literal|"Modem dialer telephone number prefix"
argument_list|)
operator|)
return|;
case|case
name|XYDDIA
case|:
comment|/* DIAL DIAL-COMMAND */
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Dialing command for modem,\n\  include \"%s\" to stand for phone number,\n\  for example, \"set dial dial-command ATDT%s\\13\""
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
operator|&&
name|x
operator|!=
operator|-
literal|3
condition|)
comment|/* Handle parse errors */
return|return
operator|(
name|x
operator|)
return|;
name|y
operator|=
name|x
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Get length of text */
if|if
condition|(
name|x
operator|>
literal|0
operator|&&
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
comment|/* Strip enclosing braces, */
if|if
condition|(
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
comment|/* if any. */
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|y
operator|-=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|y
operator|>
literal|0
condition|)
block|{
comment|/* If there is any text (left), */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|y
condition|;
name|x
operator|++
control|)
block|{
comment|/* make sure they included "%s" */
if|if
condition|(
name|s
index|[
name|x
index|]
operator|!=
literal|'%'
condition|)
continue|continue;
if|if
condition|(
name|s
index|[
name|x
operator|+
literal|1
index|]
operator|==
literal|'s'
condition|)
break|break;
block|}
if|if
condition|(
name|x
operator|==
name|y
condition|)
block|{
name|printf
argument_list|(
literal|"?Dial-command must contain \"%cs\" for phone number.\n"
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
block|}
if|if
condition|(
name|dialcmd
condition|)
block|{
comment|/* Free any previous string. */
name|free
argument_list|(
name|dialcmd
argument_list|)
expr_stmt|;
name|dialcmd
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|>
literal|0
condition|)
block|{
name|dialcmd
operator|=
name|malloc
argument_list|(
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Allocate space for it */
name|strcpy
argument_list|(
name|dialcmd
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* and make a safe copy. */
block|}
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYDKSP
case|:
comment|/* DIAL KERMIT-SPOOF */
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|dialksp
argument_list|)
operator|)
return|;
case|case
name|XYDTMO
case|:
comment|/* DIAL TIMEOUT */
name|y
operator|=
name|cmnum
argument_list|(
literal|"Seconds to wait for call completion"
argument_list|,
literal|"0"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|setnum
argument_list|(
operator|&
name|dialtmo
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|10000
argument_list|)
operator|)
return|;
case|case
name|XYDDPY
case|:
comment|/* DIAL DISPLAY */
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|dialdpy
argument_list|)
operator|)
return|;
case|case
name|XYDSPD
case|:
comment|/* DIAL SPEED-MATCHING */
comment|/* used to be speed-changing */
if|if
condition|(
operator|(
name|y
operator|=
name|seton
argument_list|(
operator|&
name|mdmspd
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
ifdef|#
directive|ifdef
name|COMMENT
name|mdmspd
operator|=
literal|1
operator|-
name|mdmspd
expr_stmt|;
comment|/* so here we reverse the meaning */
endif|#
directive|endif
comment|/* COMMENT */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYDMNP
case|:
comment|/* DIAL MNP-ENABLE */
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|dialmnp
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|MDMHUP
case|case
name|XYDMHU
case|:
comment|/* DIAL MODEM-HANGUP */
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|dialmhu
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* MDMHUP */
case|case
name|XYDDIR
case|:
comment|/* DIAL DIRECTORY */
if|if
condition|(
operator|(
name|y
operator|=
name|cmifi
argument_list|(
literal|"Name of dialing directory file"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|y
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
if|if
condition|(
name|dialdir
condition|)
name|free
argument_list|(
name|dialdir
argument_list|)
expr_stmt|;
comment|/* Free any previous storage */
name|dialdir
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
if|if
condition|(
name|y
condition|)
block|{
name|printf
argument_list|(
literal|"?Wildcards not allowed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Make safe copy of dial string */
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* Confirm the command */
if|if
condition|(
name|dialdir
condition|)
name|free
argument_list|(
name|dialdir
argument_list|)
expr_stmt|;
comment|/* Free previous filename storage */
if|if
condition|(
name|dialfd
condition|)
block|{
comment|/* Close previous file, if any */
name|fclose
argument_list|(
name|dialfd
argument_list|)
expr_stmt|;
name|dialfd
operator|=
name|NULL
expr_stmt|;
block|}
name|s
operator|=
name|line
expr_stmt|;
comment|/* Point back to dial string */
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
name|NUL
condition|)
block|{
comment|/* If no name given */
name|dialdir
operator|=
name|NULL
expr_stmt|;
comment|/* remove the name string */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dialdir
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
comment|/* Can't malloc storage for name */
block|}
else|else
block|{
comment|/* Have storage for name */
name|strcpy
argument_list|(
name|dialdir
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Copy string into new storage */
if|if
condition|(
operator|(
name|dialfd
operator|=
name|fopen
argument_list|(
name|dialdir
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Open the file */
name|perror
argument_list|(
name|dialdir
argument_list|)
expr_stmt|;
comment|/* Can't, print message saying why */
name|success
operator|=
literal|0
expr_stmt|;
comment|/* We didn't succeed */
return|return
operator|(
operator|-
literal|9
operator|)
return|;
comment|/* Fail, message already printed */
block|}
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
comment|/* Everything is OK */
block|}
default|default:
name|printf
argument_list|(
literal|"?Unexpected SET DIAL parameter\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NODIAL */
end_comment

begin_function
name|int
name|setfil
parameter_list|(
name|rmsflg
parameter_list|)
name|int
name|rmsflg
decl_stmt|;
block|{
if|if
condition|(
name|rmsflg
condition|)
block|{
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|rfiltab
argument_list|,
name|nrfilp
argument_list|,
literal|"Remote file parameter"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Remote file parameter required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|filtab
argument_list|,
name|nfilp
argument_list|,
literal|"File parameter"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
block|}
switch|switch
condition|(
name|y
condition|)
block|{
ifdef|#
directive|ifdef
name|COMMENT
comment|/* Not needed */
case|case
name|XYFILB
case|:
comment|/* Blocksize */
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%d"
argument_list|,
name|DBLKSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"file block size"
argument_list|,
name|tmpbuf
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%d"
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"311"
argument_list|,
name|tmpbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
block|{
name|fblksiz
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* COMMENT */
case|case
name|XYFILS
case|:
comment|/* Byte size */
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"file byte size (7 or 8)"
argument_list|,
literal|"8"
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|!=
literal|7
operator|&&
name|z
operator|!=
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"\n?The choices are 7 and 8\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|==
literal|7
condition|)
name|fmask
operator|=
literal|0177
expr_stmt|;
elseif|else
if|if
condition|(
name|z
operator|==
literal|8
condition|)
name|fmask
operator|=
literal|0377
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
ifndef|#
directive|ifndef
name|NOCSETS
case|case
name|XYFILC
case|:
comment|/* Character set */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|fcstab
argument_list|,
name|nfilc
argument_list|,
literal|"local file code"
argument_list|,
literal|"ascii"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|z
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
name|fcharset
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* NOCSETS */
case|case
name|XYFILD
case|:
comment|/* Display */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|fdtab
argument_list|,
name|nfdtab
argument_list|,
literal|"file transfer display style"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|z
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
ifdef|#
directive|ifdef
name|CK_CURSES
if|if
condition|(
name|x
operator|==
name|XYFD_C
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
name|lp
operator|=
name|line
expr_stmt|;
else|#
directive|else
name|lp
operator|=
name|trmbuf
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
ifndef|#
directive|ifndef
name|MYCURSES
name|s
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgetent
argument_list|(
name|lp
argument_list|,
name|s
argument_list|)
operator|<
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
name|printf
argument_list|(
literal|"Sorry, terminal type not supported: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Sorry, terminal type unknown: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* MYCURSES */
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CK_CURSES */
name|fdispla
operator|=
name|x
expr_stmt|;
comment|/* It's OK. */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYFILN
case|:
comment|/* Names */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|fntab
argument_list|,
literal|2
argument_list|,
literal|"how to handle filenames"
argument_list|,
literal|"converted"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|z
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
name|fncnv
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYFILR
case|:
comment|/* Record length */
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%d"
argument_list|,
name|DLRECL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"file record length"
argument_list|,
name|tmpbuf
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%d"
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"312"
argument_list|,
name|tmpbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
block|{
name|frecl
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|COMMENT
case|case
name|XYFILO
case|:
comment|/* Organization */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|forgtab
argument_list|,
name|nforg
argument_list|,
literal|"file organization"
argument_list|,
literal|"sequential"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%d"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"314"
argument_list|,
name|tmpbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
block|{
name|forg
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* COMMENT */
ifdef|#
directive|ifdef
name|COMMENT
comment|/* Not needed */
case|case
name|XYFILF
case|:
comment|/* Format */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|frectab
argument_list|,
name|nfrec
argument_list|,
literal|"file record format"
argument_list|,
literal|"stream"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%d"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"313"
argument_list|,
name|tmpbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
block|{
name|frecfm
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* COMMENT */
ifdef|#
directive|ifdef
name|COMMENT
case|case
name|XYFILP
case|:
comment|/* Printer carriage control */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|fcctab
argument_list|,
name|nfcc
argument_list|,
literal|"file carriage control"
argument_list|,
literal|"newline"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%d"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"315"
argument_list|,
name|tmpbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
block|{
name|fcctrl
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* COMMENT */
case|case
name|XYFILT
case|:
comment|/* Type */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|fttab
argument_list|,
name|nfttyp
argument_list|,
literal|"type of file"
argument_list|,
literal|"text"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
ifdef|#
directive|ifdef
name|COMMENT
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"file byte size (7 or 8)"
argument_list|,
literal|"8"
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|!=
literal|7
operator|&&
name|z
operator|!=
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"\n?The choices are 7 and 8\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* COMMENT */
ifdef|#
directive|ifdef
name|VMS
comment|/* Allow VMS users to choose record format for binary files */
if|if
condition|(
operator|(
name|x
operator|==
name|XYFT_B
operator|)
operator|&&
operator|(
name|rmsflg
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|fbtab
argument_list|,
name|nfbtyp
argument_list|,
literal|"VMS record format"
argument_list|,
literal|"fixed"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"300"
argument_list|,
name|x
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
block|{
name|binary
operator|=
name|x
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
if|if
condition|(
name|z
operator|==
literal|7
condition|)
name|fmask
operator|=
literal|0177
expr_stmt|;
elseif|else
if|if
condition|(
name|z
operator|==
literal|8
condition|)
name|fmask
operator|=
literal|0377
expr_stmt|;
endif|#
directive|endif
comment|/* COMMENT */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
case|case
name|XYFILX
case|:
comment|/* Collision Action */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|colxtab
argument_list|,
name|ncolx
argument_list|,
literal|"Filename collision action"
argument_list|,
literal|"backup"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|fncact
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%d"
argument_list|,
name|fncact
argument_list|)
expr_stmt|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"302"
argument_list|,
name|tmpbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|fncact
operator|==
name|XYFX_R
condition|)
name|warn
operator|=
literal|1
expr_stmt|;
comment|/* SET FILE WARNING implications */
if|if
condition|(
name|fncact
operator|==
name|XYFX_X
condition|)
name|warn
operator|=
literal|0
expr_stmt|;
comment|/* ... */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
case|case
name|XYFILW
case|:
comment|/* Warning/Write-Protect */
name|seton
argument_list|(
operator|&
name|warn
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn
condition|)
name|fncact
operator|=
name|XYFX_R
expr_stmt|;
else|else
name|fncact
operator|=
name|XYFX_X
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|VMS
case|case
name|XYFILL
case|:
comment|/* LABELED FILE parameters */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|lbltab
argument_list|,
name|nlblp
argument_list|,
literal|"VMS labeled file feature"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|y
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|success
operator|)
return|;
if|if
condition|(
name|y
condition|)
comment|/* Set or reset the selected bit */
name|lf_opts
operator||=
name|x
expr_stmt|;
comment|/* in the options bitmask. */
else|else
name|lf_opts
operator|&=
operator|~
name|x
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
endif|#
directive|endif
comment|/* VMS */
case|case
name|XYFILI
case|:
comment|/* INCOMPLETE */
return|return
operator|(
name|doprm
argument_list|(
name|XYIFD
argument_list|,
name|rmsflg
argument_list|)
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"?unexpected file parameter\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|settrm
parameter_list|()
block|{
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|trmtab
argument_list|,
name|ntrm
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
ifdef|#
directive|ifdef
name|MAC
name|printf
argument_list|(
literal|"\n?Sorry, not implemented yet.  Please use the Settings menu.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
else|#
directive|else
switch|switch
condition|(
name|y
condition|)
block|{
case|case
name|XYTBYT
case|:
comment|/* SET TERMINAL BYTESIZE */
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"bytesize for terminal connection"
argument_list|,
literal|"8"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|x
operator|!=
literal|7
operator|&&
name|x
operator|!=
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"\n?The choices are 7 and 8\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|x
operator|==
literal|7
condition|)
name|cmask
operator|=
literal|0177
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|8
condition|)
name|cmask
operator|=
literal|0377
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYTSO
case|:
comment|/* SET TERMINAL LOCKING-SHIFT */
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|sosi
argument_list|)
operator|)
return|;
case|case
name|XYTNL
case|:
comment|/* SET TERMINAL NEWLINE-MODE */
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|tnlm
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|OS2
case|case
name|XYTCOL
case|:
comment|/* SET TERMINAL COLOR */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|ttycoltab
argument_list|,
name|ncolors
argument_list|,
literal|""
argument_list|,
literal|"normal"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|x
operator|)
return|;
block|}
else|else
block|{
specifier|extern
name|int
name|colornormal
decl_stmt|,
name|colorreverse
decl_stmt|,
name|colorunderline
decl_stmt|,
name|colorstatus
decl_stmt|,
name|colorhelp
decl_stmt|,
name|scrninitialised
decl_stmt|;
name|int
name|fg
decl_stmt|,
name|bg
decl_stmt|;
if|if
condition|(
operator|(
name|fg
operator|=
name|cmkey
argument_list|(
name|ttyclrtab
argument_list|,
name|nclrs
argument_list|,
literal|"foreground color"
argument_list|,
literal|"black"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|fg
operator|)
return|;
if|if
condition|(
operator|(
name|bg
operator|=
name|cmkey
argument_list|(
name|ttyclrtab
argument_list|,
name|nclrs
argument_list|,
literal|"background color"
argument_list|,
literal|"cyan"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|bg
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
literal|0
case|:
name|colornormal
operator|=
name|fg
operator||
name|bg
operator|<<
literal|4
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|colorreverse
operator|=
name|fg
operator||
name|bg
operator|<<
literal|4
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|colorunderline
operator|=
name|fg
operator||
name|bg
operator|<<
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|colorstatus
operator|=
name|fg
operator||
name|bg
operator|<<
literal|4
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|colorhelp
operator|=
name|fg
operator||
name|bg
operator|<<
literal|4
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s - invalid\n"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
break|break;
block|}
name|scrninitialised
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYTCUR
case|:
comment|/* SET TERMINAL CURSOR */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|ttycurtab
argument_list|,
name|ncursors
argument_list|,
literal|""
argument_list|,
literal|"underline"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|tt_cursor
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYTTYP
case|:
comment|/* SET TERMINAL TYPE */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|ttyptab
argument_list|,
name|nttyp
argument_list|,
literal|""
argument_list|,
literal|"vt102"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|tt_type
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYTARR
case|:
comment|/* SET TERMINAL ARROW-KEYS */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|akmtab
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|tt_arrow
operator|=
name|x
expr_stmt|;
comment|/* 0 = application, 1 = cursor */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYTKPD
case|:
comment|/* SET TERMINAL KEYPAD-MODE */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|kpmtab
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|tt_keypad
operator|=
name|x
expr_stmt|;
comment|/* 0 = application, 1 = numeric */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYTWRP
case|:
comment|/* SET TERMINAL WRAP */
name|seton
argument_list|(
operator|&
name|tt_wrap
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* OS2 */
ifndef|#
directive|ifndef
name|NOCSETS
case|case
name|XYTCS
case|:
comment|/* SET TERMINAL CHARACTER-SET */
comment|/* set terminal character-set<remote><local> */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|ttcstab
argument_list|,
name|ntermc
argument_list|,
literal|"remote terminal character-set"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|x
operator|==
name|FC_TRANSP
condition|)
block|{
comment|/* TRANSPARENT? */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* Confirm the command */
name|tcsr
operator|=
name|tcsl
operator|=
name|FC_USASCII
expr_stmt|;
comment|/* Make them both the same */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
comment|/* Not transparent, so get local set to translate it into */
name|s
operator|=
literal|""
expr_stmt|;
comment|/* Make current file char set */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<=
name|nfilc
condition|;
name|y
operator|++
control|)
comment|/* be the default... */
if|if
condition|(
name|fcstab
index|[
name|y
index|]
operator|.
name|kwval
operator|==
name|fcharset
condition|)
block|{
name|s
operator|=
name|fcstab
index|[
name|y
index|]
operator|.
name|kwd
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|fcstab
argument_list|,
name|nfilc
argument_list|,
literal|"local character-set"
argument_list|,
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|z
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
comment|/* Confirm the command */
name|tcsr
operator|=
name|x
expr_stmt|;
comment|/* Remote character set */
name|tcsl
operator|=
name|y
expr_stmt|;
comment|/* Local character set */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* NOCSETS */
case|case
name|XYTEC
case|:
comment|/* SET TERMINAL ECHO */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|rltab
argument_list|,
name|nrlt
argument_list|,
literal|"which side echos during CONNECT"
argument_list|,
literal|"remote"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|duplex
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYTCRD
case|:
comment|/* SET TERMINAL CR-DISPLAY */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|crdtab
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|"normal"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|tt_crd
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
default|default:
comment|/* Shouldn't get here. */
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* MAC */
block|}
end_function

begin_function
name|int
comment|/* SET SEND/RECEIVE */
name|setsr
parameter_list|(
name|xx
parameter_list|,
name|rmsflg
parameter_list|)
name|int
name|xx
decl_stmt|;
name|int
name|rmsflg
decl_stmt|;
block|{
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"Parameter for inbound packets"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"Parameter for outbound packets"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmsflg
condition|)
block|{
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|rsrtab
argument_list|,
name|nrsrtab
argument_list|,
name|line
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Remote receive parameter required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|srtab
argument_list|,
name|nsrtab
argument_list|,
name|line
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
block|}
switch|switch
condition|(
name|y
condition|)
block|{
case|case
name|XYEOL
case|:
name|y
operator|=
name|cmnum
argument_list|(
literal|"Decimal ASCII code for packet terminator"
argument_list|,
literal|"13"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|setcc
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
name|eol
operator|=
name|z
expr_stmt|;
else|else
name|seol
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|y
operator|)
return|;
case|case
name|XYLEN
case|:
name|y
operator|=
name|cmnum
argument_list|(
literal|"Maximum number of characters in a packet"
argument_list|,
literal|"90"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
block|{
comment|/* Receive... */
if|if
condition|(
operator|(
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|maxrps
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|<
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, 10 is the minimum\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|rmsflg
condition|)
block|{
name|tp
operator|=
name|tmpbuf
expr_stmt|;
name|sprintf
argument_list|(
name|tp
argument_list|,
literal|"%d"
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"401"
argument_list|,
name|tp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|z
operator|>
name|MAXRP
condition|)
name|z
operator|=
name|MAXRP
expr_stmt|;
name|y
operator|=
name|adjpkl
argument_list|(
name|z
argument_list|,
name|wslotr
argument_list|,
name|bigrbsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|!=
name|z
condition|)
block|{
name|urpsiz
operator|=
name|y
expr_stmt|;
if|if
condition|(
ifndef|#
directive|ifndef
name|NOSPL
name|cmdlvl
operator|==
literal|0
else|#
directive|else
name|tlevel
operator|<
literal|0
endif|#
directive|endif
comment|/* NOSPL */
condition|)
if|if
condition|(
name|msgflg
condition|)
name|printf
argument_list|(
literal|" Adjusting receive packet-length to %d for %d window slots\n"
argument_list|,
name|y
argument_list|,
name|wslotr
argument_list|)
expr_stmt|;
block|}
name|urpsiz
operator|=
name|y
expr_stmt|;
name|rpsiz
operator|=
operator|(
name|y
operator|>
literal|94
operator|)
condition|?
literal|94
else|:
name|y
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Send... */
if|if
condition|(
operator|(
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|maxsps
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|<
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, 10 is the minimum\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|z
operator|>
name|MAXSP
condition|)
name|z
operator|=
name|MAXSP
expr_stmt|;
name|spsiz
operator|=
name|z
expr_stmt|;
comment|/* Set it */
name|y
operator|=
name|adjpkl
argument_list|(
name|spsiz
argument_list|,
name|wslotr
argument_list|,
name|bigsbsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|!=
name|spsiz
operator|&&
ifndef|#
directive|ifndef
name|NOSPL
name|cmdlvl
operator|==
literal|0
else|#
directive|else
name|tlevel
operator|<
literal|0
endif|#
directive|endif
comment|/* NOSPL */
condition|)
if|if
condition|(
name|msgflg
condition|)
name|printf
argument_list|(
literal|"Adjusting packet size to %d for %d window slots\n"
argument_list|,
name|y
argument_list|,
name|wslotr
argument_list|)
expr_stmt|;
name|spsiz
operator|=
name|spmax
operator|=
name|spsizr
operator|=
name|y
expr_stmt|;
comment|/* Set it and flag that it was set */
name|spsizf
operator|=
literal|1
expr_stmt|;
comment|/* to allow overriding Send-Init. */
block|}
if|if
condition|(
name|pflag
operator|&&
ifndef|#
directive|ifndef
name|NOSPL
name|cmdlvl
operator|==
literal|0
else|#
directive|else
name|tlevel
operator|<
literal|0
endif|#
directive|endif
comment|/* NOSPL */
condition|)
block|{
if|if
condition|(
name|z
operator|>
literal|94
operator|&&
name|msgflg
condition|)
block|{
name|printf
argument_list|(
literal|"Extended-length packets requested.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bctr
operator|<
literal|2
operator|&&
name|z
operator|>
literal|200
condition|)
name|printf
argument_list|(
literal|"\ Remember to SET BLOCK 2 or 3 for long packets.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|speed
operator|<=
literal|0L
condition|)
name|speed
operator|=
name|ttgspd
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
comment|/*   Kermit does this now itself. */
if|if
condition|(
name|speed
operator|<=
literal|0L
operator|&&
name|z
operator|>
literal|200
operator|&&
name|msgflg
condition|)
block|{
name|printf
argument_list|(
literal|"\ Make sure your timeout interval is long enough for %d-byte packets.\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* COMMENT */
block|}
return|return
operator|(
name|success
operator|=
name|y
operator|)
return|;
case|case
name|XYMARK
case|:
name|y
operator|=
name|cmnum
argument_list|(
literal|"Code for packet-start character"
argument_list|,
literal|"1"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
comment|/*   Printable start-of-packet works for UNIX and VMS only! */
if|if
condition|(
operator|(
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|126
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|(
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|126
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
else|#
directive|else
if|if
condition|(
operator|(
name|y
operator|=
name|setcc
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
endif|#
directive|endif
comment|/* VMS */
endif|#
directive|endif
comment|/* UNIX */
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
name|stchr
operator|=
name|z
expr_stmt|;
else|else
name|mystch
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|y
operator|)
return|;
case|case
name|XYNPAD
case|:
comment|/* PADDING */
name|y
operator|=
name|cmnum
argument_list|(
literal|"How many padding characters for inbound packets"
argument_list|,
literal|"0"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|94
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
name|mypadn
operator|=
name|z
expr_stmt|;
else|else
name|npad
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|y
operator|)
return|;
case|case
name|XYPADC
case|:
comment|/* PAD-CHARACTER */
name|y
operator|=
name|cmnum
argument_list|(
literal|"Decimal ASCII code for packet padding character"
argument_list|,
literal|"0"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|setcc
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
name|mypadc
operator|=
name|z
expr_stmt|;
else|else
name|padch
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|y
operator|)
return|;
case|case
name|XYTIMO
case|:
comment|/* TIMEOUT */
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* Construct default */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|URTIME
argument_list|)
expr_stmt|;
name|y
operator|=
name|cmnum
argument_list|(
literal|"Packet timeout interval"
argument_list|,
name|buf
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|94
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|rmsflg
condition|)
block|{
comment|/* REMOTE SET RECEIVE TIMEOUT */
name|tp
operator|=
name|tmpbuf
expr_stmt|;
comment|/*   Tell Kermit server what */
name|sprintf
argument_list|(
name|tp
argument_list|,
literal|"%d"
argument_list|,
name|z
argument_list|)
expr_stmt|;
comment|/*   timeout to ask me to use. */
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"402"
argument_list|,
name|tp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
block|{
comment|/* SET RECEIVE TIMEOUT */
name|pkttim
operator|=
name|z
expr_stmt|;
comment|/*   Value to put in my negotiation */
block|}
comment|/*   packet for other Kermit to use */
block|}
else|else
block|{
comment|/* SET SEND TIMEOUT */
name|y
operator|=
name|cmnum
argument_list|(
literal|"Packet timeout interval"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
comment|/* They cancelled a previous */
name|x
operator|=
name|DMYTIM
expr_stmt|;
comment|/* SET SEND command, so restore */
name|y
operator|=
literal|0
expr_stmt|;
comment|/* the default */
name|timef
operator|=
literal|0
expr_stmt|;
comment|/* and turn off the override flag */
block|}
else|else
block|{
comment|/* They gave a number */
name|timef
operator|=
literal|1
expr_stmt|;
comment|/* so turn on the override flag */
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|94
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|timint
operator|=
name|rtimo
operator|=
name|z
expr_stmt|;
comment|/* Override value for me to use */
block|}
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
comment|/* End of SET SEND/RECEIVE... */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NOXMIT
end_ifndef

begin_function
name|int
name|setxmit
parameter_list|()
block|{
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|xmitab
argument_list|,
name|nxmit
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|y
condition|)
block|{
case|case
name|XMITE
case|:
comment|/* EOF */
name|y
operator|=
name|cmtxt
argument_list|(
literal|"Characters to send at end of file,\n\  Use backslash codes for control characters"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|>
name|XMBUFL
condition|)
block|{
name|printf
argument_list|(
literal|"?Too many characters, %d maximum\n"
argument_list|,
name|XMBUFL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|xmitbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XMITF
case|:
comment|/* Fill */
name|y
operator|=
name|cmnum
argument_list|(
literal|"Numeric code for blank-line fill character"
argument_list|,
literal|"0"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|127
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|xmitf
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XMITL
case|:
comment|/* Linefeed */
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|xmitl
argument_list|)
operator|)
return|;
case|case
name|XMITS
case|:
comment|/* Locking-Shift */
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|xmits
argument_list|)
operator|)
return|;
case|case
name|XMITP
case|:
comment|/* Prompt */
name|y
operator|=
name|cmnum
argument_list|(
literal|"Numeric code for host's prompt character, 0 for none"
argument_list|,
literal|"10"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|127
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|xmitp
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XMITX
case|:
comment|/* Echo */
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|xmitx
argument_list|)
operator|)
return|;
case|case
name|XMITW
case|:
comment|/* Pause */
name|y
operator|=
name|cmnum
argument_list|(
literal|"Number of milliseconds to pause between binary characters\n\ or text lines during transmission"
argument_list|,
literal|"0"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1000
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|xmitw
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOXMIT */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  D O R M T  --  Do a remote command  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ATTSV
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|aegis
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|datageneral
end_ifndef

begin_define
define|#
directive|define
name|CK_NEED_SIG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* datageneral */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* aegis */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATTSV */
end_comment

begin_function
name|VOID
name|rmsg
parameter_list|()
block|{
if|if
condition|(
name|pflag
condition|)
name|printf
argument_list|(
ifdef|#
directive|ifdef
name|CK_NEEDSIG
literal|" Type your escape character, %s, followed by X or E to cancel.\n"
argument_list|,
name|dbchr
argument_list|(
name|escape
argument_list|)
else|#
directive|else
literal|" Press the X or E key to cancel.\n"
endif|#
directive|endif
comment|/* CK_NEEDSIG */
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dormt
parameter_list|(
name|xx
parameter_list|)
name|int
name|xx
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|retcode
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
name|sbuf
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
if|if
condition|(
name|xx
operator|<
literal|0
condition|)
return|return
operator|(
name|xx
operator|)
return|;
if|if
condition|(
name|xx
operator|==
name|XZSET
condition|)
block|{
comment|/* REMOTE SET */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|rmstab
argument_list|,
name|nrms
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Parameter name required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
return|return
operator|(
name|doprm
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
switch|switch
condition|(
name|xx
condition|)
block|{
comment|/* Others... */
case|case
name|XZCWD
case|:
comment|/* CWD */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Remote directory name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"XZCWD: "
argument_list|,
name|s
argument_list|,
name|x
argument_list|)
expr_stmt|;
operator|*
name|sbuf
operator|=
name|NUL
expr_stmt|;
name|s2
operator|=
name|sbuf
expr_stmt|;
comment|/* The following is commented out, because there is practically no */
comment|/* computer in the world that requires a password for directory changing. */
comment|/* (The DEC-20 was the only one, and they're mostly all gone.) */
ifdef|#
directive|ifdef
name|DIRPWDPR
if|if
condition|(
operator|*
name|s
operator|!=
name|NUL
condition|)
block|{
comment|/* If directory name given, */
comment|/* get password on separate line. */
if|if
condition|(
name|tlevel
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* From take file... */
if|if
condition|(
name|fgets
argument_list|(
name|sbuf
argument_list|,
literal|50
argument_list|,
name|tfile
index|[
name|tlevel
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"take file ends prematurely in 'remote cwd'"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|" pswd from take file"
argument_list|,
name|s2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|sbuf
argument_list|)
init|;
name|x
operator|>
literal|0
operator|&&
operator|(
name|sbuf
index|[
name|x
operator|-
literal|1
index|]
operator|==
name|NL
operator|||
name|sbuf
index|[
name|x
operator|-
literal|1
index|]
operator|==
name|CR
operator|)
condition|;
name|x
operator|--
control|)
name|sbuf
index|[
name|x
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* From terminal... */
name|printf
argument_list|(
literal|" Password: "
argument_list|)
expr_stmt|;
comment|/* get a password */
ifdef|#
directive|ifdef
name|OS2
while|while
condition|(
operator|(
operator|(
name|x
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
condition|?
name|coninc
argument_list|(
literal|0
argument_list|)
else|:
name|getchar
argument_list|()
operator|)
operator|!=
name|NL
operator|)
operator|&&
operator|(
name|x
operator|!=
name|CR
operator|)
condition|)
block|{
comment|/* with no echo */
else|#
directive|else
while|while
condition|(
operator|(
operator|(
name|x
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|NL
operator|)
operator|&&
operator|(
name|x
operator|!=
name|CR
operator|)
condition|)
block|{
comment|/* with no echo */
endif|#
directive|endif
comment|/* OS2 */
if|if
condition|(
operator|(
name|x
operator|&=
literal|0177
operator|)
operator|==
literal|'?'
condition|)
block|{
name|printf
argument_list|(
literal|"? Password of remote directory\n Password: "
argument_list|)
expr_stmt|;
name|s2
operator|=
name|sbuf
expr_stmt|;
operator|*
name|sbuf
operator|=
name|NUL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
name|ESC
condition|)
comment|/* Mini command line editor... */
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|BS
operator|||
name|x
operator|==
literal|0177
condition|)
name|s2
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|025
condition|)
block|{
comment|/* Ctrl-U */
name|s2
operator|=
name|sbuf
expr_stmt|;
operator|*
name|sbuf
operator|=
name|NUL
expr_stmt|;
block|}
else|else
operator|*
name|s2
operator|++
operator|=
name|x
expr_stmt|;
block|}
operator|*
name|s2
operator|=
name|NUL
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|s2
operator|=
name|sbuf
expr_stmt|;
block|}
else|else
name|s2
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
comment|/* DIRPWDPR */
name|debug
argument_list|(
name|F110
argument_list|,
literal|" password"
argument_list|,
name|s2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'C'
argument_list|,
name|s
argument_list|,
name|s2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XZDEL
case|:
comment|/* Delete */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Name of remote file(s) to delete"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Name of remote file(s) required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
name|local
condition|)
name|ttflui
argument_list|()
expr_stmt|;
comment|/* If local, flush tty input buffer */
name|retcode
operator|=
name|sstate
operator|=
name|rfilop
argument_list|(
name|s
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
break|break;
case|case
name|XZDIR
case|:
comment|/* Directory */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Remote directory or file specification"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|local
condition|)
name|ttflui
argument_list|()
expr_stmt|;
comment|/* If local, flush tty input buffer */
name|rmsg
argument_list|()
expr_stmt|;
name|retcode
operator|=
name|sstate
operator|=
name|setgen
argument_list|(
literal|'D'
argument_list|,
name|s
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|XZHLP
case|:
comment|/* Help */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'H'
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NOPUSH
case|case
name|XZHOS
case|:
comment|/* Host */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Command for remote system"
argument_list|,
literal|""
argument_list|,
operator|&
name|cmarg
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|cmarg
argument_list|)
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Remote host command required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
name|rmsg
argument_list|()
expr_stmt|;
name|retcode
operator|=
name|sstate
operator|=
literal|'c'
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NOPUSH */
ifndef|#
directive|ifndef
name|NOFRILLS
case|case
name|XZKER
case|:
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Command for remote Kermit"
argument_list|,
literal|""
argument_list|,
operator|&
name|cmarg
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|cmarg
argument_list|)
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Remote Kermit command required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
name|retcode
operator|=
name|sstate
operator|=
literal|'k'
expr_stmt|;
name|rmsg
argument_list|()
expr_stmt|;
break|break;
case|case
name|XZLGI
case|:
block|{
comment|/* Login */
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmfld
argument_list|(
literal|"User ID"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|p1
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Internal error: malloc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
else|else
name|strcpy
argument_list|(
name|p1
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmfld
argument_list|(
literal|"Password"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|p2
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Internal error: malloc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
else|else
name|strcpy
argument_list|(
name|p2
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Account or carriage return"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
operator|&&
name|x
operator|!=
operator|-
literal|3
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|p3
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Internal error: malloc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
else|else
name|strcpy
argument_list|(
name|p3
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'I'
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|)
expr_stmt|;
if|if
condition|(
name|p3
condition|)
name|free
argument_list|(
name|p3
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
condition|)
name|free
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|XZLGO
case|:
comment|/* Logout */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'I'
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XZPRI
case|:
comment|/* Print */
if|if
condition|(
operator|!
name|atdiso
operator|||
operator|!
name|atcapr
condition|)
block|{
comment|/* Disposition attribute off? */
name|printf
argument_list|(
literal|"?Disposition Attribute is Off\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|cmarg
operator|=
literal|""
expr_stmt|;
name|cmarg2
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmifi
argument_list|(
literal|"Local file(s) to print on remote printer"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|y
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Name of local file(s) required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Make a safe copy of filename */
operator|*
name|optbuf
operator|=
name|NUL
expr_stmt|;
comment|/* Wipe out any old options */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Options for remote print command"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|strcpy
argument_list|(
name|optbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Make a safe copy of options */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|optbuf
argument_list|)
operator|>
literal|94
condition|)
block|{
comment|/* Make sure this is legal */
name|printf
argument_list|(
literal|"?Option string too long\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|nfils
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Expand file list internally */
name|cmarg
operator|=
name|line
expr_stmt|;
comment|/* Point to file list. */
name|rprintf
operator|=
literal|1
expr_stmt|;
comment|/* REMOTE PRINT modifier for SEND */
name|sstate
operator|=
literal|'s'
expr_stmt|;
comment|/* Set start state to SEND */
if|if
condition|(
name|local
condition|)
name|displa
operator|=
literal|1
expr_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NOFRILLS */
case|case
name|XZSPA
case|:
comment|/* Space */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Confirm, or remote directory name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|retcode
operator|=
name|sstate
operator|=
name|setgen
argument_list|(
literal|'U'
argument_list|,
name|s
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NOFRILLS
case|case
name|XZTYP
case|:
comment|/* Type */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Remote file specification"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"?Remote filename required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|rmsg
argument_list|()
expr_stmt|;
name|retcode
operator|=
name|sstate
operator|=
name|rfilop
argument_list|(
name|s
argument_list|,
literal|'T'
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NOFRILLS */
ifndef|#
directive|ifndef
name|NOFRILLS
case|case
name|XZWHO
case|:
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Remote user name, or carriage return"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|retcode
operator|=
name|sstate
operator|=
name|setgen
argument_list|(
literal|'W'
argument_list|,
name|s
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NOFRILLS */
default|default:
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|printf
argument_list|(
literal|"?Not implemented - %s\n"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|local
condition|)
name|ttflui
argument_list|()
expr_stmt|;
comment|/* If local, flush tty input buffer */
return|return
operator|(
name|retcode
operator|)
return|;
block|}
comment|/*  R F I L O P  --  Remote File Operation  */
name|CHAR
ifdef|#
directive|ifdef
name|CK_ANSIC
name|rfilop
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
name|t
parameter_list|)
else|#
directive|else
function|rfilop
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
name|t
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* rfilop */
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|NUL
condition|)
block|{
name|printf
argument_list|(
literal|"?File specification required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|CHAR
operator|)
literal|0
operator|)
return|;
block|}
name|debug
argument_list|(
name|F111
argument_list|,
literal|"rfilop"
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|setgen
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SUNX25
name|int
name|setx25
parameter_list|()
block|{
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|x25tab
argument_list|,
name|nx25
argument_list|,
literal|"X.25 call options"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|y
condition|)
block|{
case|case
name|XYUDAT
case|:
if|if
condition|(
operator|(
name|z
operator|=
name|cmkey
argument_list|(
name|onoff
argument_list|,
literal|2
argument_list|,
literal|"X.25 call user data"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|z
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
name|cudata
operator|=
literal|0
expr_stmt|;
comment|/* disable call user data */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"X.25 call user data string"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|>
name|MAXCUDATA
condition|)
block|{
name|printf
argument_list|(
literal|"?The length must be> 0 and<= %d\n"
argument_list|,
name|MAXCUDATA
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|strcpy
argument_list|(
name|udata
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|cudata
operator|=
literal|1
expr_stmt|;
comment|/* X.25 call user data specified */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYCLOS
case|:
if|if
condition|(
operator|(
name|z
operator|=
name|cmkey
argument_list|(
name|onoff
argument_list|,
literal|2
argument_list|,
literal|"X.25 closed user group call"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|z
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
name|closgr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* disable closed user group */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"0<= cug index>= 99"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>
literal|99
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0<= cug index>= 99\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|closgr
operator|=
name|x
expr_stmt|;
comment|/* closed user group selected */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|XYREVC
case|:
if|if
condition|(
operator|(
name|z
operator|=
name|cmkey
argument_list|(
name|onoff
argument_list|,
literal|2
argument_list|,
literal|"X.25 reverse charge call"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|revcall
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
block|}
name|int
name|setpadp
parameter_list|()
block|{
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|padx3tab
argument_list|,
name|npadx3
argument_list|,
literal|"PAD X.3 parameter name"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|x
operator|=
name|y
expr_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|PAD_BREAK_CHARACTER
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD break character value"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_ESCAPE
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD escape"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|!=
literal|0
operator|&&
name|z
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_ECHO
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD echo"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|!=
literal|0
operator|&&
name|z
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_DATA_FORWARD_CHAR
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD data forward char"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|!=
literal|0
operator|&&
name|z
operator|!=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 2\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_DATA_FORWARD_TIMEOUT
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD data forward timeout"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|<
literal|0
operator|||
name|z
operator|>
literal|255
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1<= timeout<= 255\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_FLOW_CONTROL_BY_PAD
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD pad flow control"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|!=
literal|0
operator|&&
name|z
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_SUPPRESSION_OF_SIGNALS
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD service"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|!=
literal|0
operator|&&
name|z
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_BREAK_ACTION
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD break action"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|!=
literal|0
operator|&&
name|z
operator|!=
literal|1
operator|&&
name|z
operator|!=
literal|2
operator|&&
name|z
operator|!=
literal|5
operator|&&
name|z
operator|!=
literal|8
operator|&&
name|z
operator|!=
literal|21
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0, 1, 2, 5, 8 or 21\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_SUPPRESSION_OF_DATA
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD data delivery"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|!=
literal|0
operator|&&
name|z
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_PADDING_AFTER_CR
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD crpad"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|<
literal|0
operator|||
name|z
operator|>
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1<= crpad<= 7\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_LINE_FOLDING
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD linefold"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|<
literal|0
operator|||
name|z
operator|>
literal|255
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1<= linefold<= 255\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_LINE_SPEED
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD baudrate"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|<
literal|0
operator|||
name|z
operator|>
literal|18
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0<= baudrate<= 18\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_FLOW_CONTROL_BY_USER
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD terminal flow control"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|!=
literal|0
operator|&&
name|z
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_LF_AFTER_CR
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD crpad"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|<
literal|0
operator|||
name|z
operator|==
literal|3
operator|||
name|z
operator|>
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0, 1, 2, 4, 5, 6 or 7\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_PADDING_AFTER_LF
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD lfpad"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|<
literal|0
operator|||
name|z
operator|>
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1<= lfpad<= 7\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_EDITING
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD edit control"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|!=
literal|0
operator|&&
name|z
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_CHAR_DELETE_CHAR
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD char delete char"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|<
literal|0
operator|||
name|z
operator|>
literal|127
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1<= chardelete<= 127\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_BUFFER_DELETE_CHAR
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD buffer delete char"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|<
literal|0
operator|||
name|z
operator|>
literal|127
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1<= bufferdelte<= 127\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|PAD_BUFFER_DISPLAY_CHAR
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"PAD display line char"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|z
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|z
operator|<
literal|0
operator|||
name|z
operator|>
literal|127
condition|)
block|{
name|printf
argument_list|(
literal|"?The choices are 0 or 1<= displayline<= 127\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
block|}
name|padparms
index|[
name|x
index|]
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* SUNX25 */
name|int
name|setat
parameter_list|(
name|rmsflg
parameter_list|)
name|int
name|rmsflg
decl_stmt|;
block|{
name|int
name|xx
decl_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|attrtab
argument_list|,
name|natr
argument_list|,
literal|"File Attribute packets"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|y
operator|==
name|AT_XALL
condition|)
block|{
comment|/* ATTRIBUTES ALL ON or ALL OFF */
if|if
condition|(
operator|(
name|z
operator|=
name|seton
argument_list|(
operator|&
name|xx
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
if|if
condition|(
name|rmsflg
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, command not available\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
block|{
name|atenci
operator|=
name|xx
expr_stmt|;
comment|/* Encoding in */
name|atenco
operator|=
name|xx
expr_stmt|;
comment|/* Encoding out */
name|atdati
operator|=
name|xx
expr_stmt|;
comment|/* Date in */
name|atdato
operator|=
name|xx
expr_stmt|;
comment|/* Date out */
name|atdisi
operator|=
name|xx
expr_stmt|;
comment|/* Disposition in/out */
name|atdiso
operator|=
name|xx
expr_stmt|;
name|atleni
operator|=
name|xx
expr_stmt|;
comment|/* Length in/out (both kinds) */
name|atleno
operator|=
name|xx
expr_stmt|;
name|atblki
operator|=
name|xx
expr_stmt|;
comment|/* Blocksize in/out */
name|atblko
operator|=
name|xx
expr_stmt|;
name|attypi
operator|=
name|xx
expr_stmt|;
comment|/* File type in/out */
name|attypo
operator|=
name|xx
expr_stmt|;
name|atsidi
operator|=
name|xx
expr_stmt|;
comment|/* System ID in/out */
name|atsido
operator|=
name|xx
expr_stmt|;
name|atsysi
operator|=
name|xx
expr_stmt|;
comment|/* System-dependent params in/out */
name|atsyso
operator|=
name|xx
expr_stmt|;
block|}
return|return
operator|(
name|z
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|y
operator|==
name|AT_ALLY
operator|||
name|y
operator|==
name|AT_ALLN
condition|)
block|{
comment|/* ATTRIBUTES ON or OFF */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|atcapr
operator|=
operator|(
name|y
operator|==
name|AT_ALLY
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"132"
argument_list|,
name|atcapr
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
else|else
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
comment|/* Otherwise, it's an individual attribute that wants turning off/on */
if|if
condition|(
operator|(
name|z
operator|=
name|cmkey
argument_list|(
name|onoff
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* There are better ways to do this... */
comment|/* The real problem is that we're not separating the in and out cases */
comment|/* and so we have to arbitrarily pick the "in" case, i.e tell the remote */
comment|/* server to ignore incoming attributes of the specified type, rather */
comment|/* than telling it not to send them.  The protocol does not (yet) define */
comment|/* codes for "in-and-out-at-the-same-time". */
switch|switch
condition|(
name|y
condition|)
block|{
case|case
name|AT_DISP
case|:
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"142"
argument_list|,
name|z
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
name|atdisi
operator|=
name|atdiso
operator|=
name|z
expr_stmt|;
break|break;
case|case
name|AT_ENCO
case|:
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"141"
argument_list|,
name|z
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
name|atenci
operator|=
name|atenco
operator|=
name|z
expr_stmt|;
break|break;
case|case
name|AT_DATE
case|:
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"135"
argument_list|,
name|z
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
name|atdati
operator|=
name|atdato
operator|=
name|z
expr_stmt|;
break|break;
case|case
name|AT_LENB
case|:
case|case
name|AT_LENK
case|:
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"133"
argument_list|,
name|z
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
name|atleni
operator|=
name|atleno
operator|=
name|z
expr_stmt|;
break|break;
case|case
name|AT_BLKS
case|:
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"139"
argument_list|,
name|z
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
name|atblki
operator|=
name|atblko
operator|=
name|z
expr_stmt|;
break|break;
case|case
name|AT_FTYP
case|:
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"134"
argument_list|,
name|z
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
name|attypi
operator|=
name|attypo
operator|=
name|z
expr_stmt|;
break|break;
case|case
name|AT_SYSI
case|:
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"145"
argument_list|,
name|z
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
name|atsidi
operator|=
name|atsido
operator|=
name|z
expr_stmt|;
break|break;
case|case
name|AT_SYSP
case|:
if|if
condition|(
name|rmsflg
condition|)
block|{
name|sstate
operator|=
name|setgen
argument_list|(
literal|'S'
argument_list|,
literal|"147"
argument_list|,
name|z
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sstate
operator|)
return|;
block|}
name|atsysi
operator|=
name|atsyso
operator|=
name|z
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"?Not available\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOSPL
name|int
name|setinp
parameter_list|()
block|{
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|inptab
argument_list|,
name|ninp
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|y
condition|)
block|{
case|case
name|IN_DEF
case|:
comment|/* SET INPUT DEFAULT-TIMEOUT */
name|z
operator|=
name|cmnum
argument_list|(
literal|"Positive number"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|setnum
argument_list|(
operator|&
name|indef
argument_list|,
name|x
argument_list|,
name|z
argument_list|,
literal|94
argument_list|)
operator|)
return|;
case|case
name|IN_TIM
case|:
comment|/* SET INPUT TIMEOUT-ACTION */
if|if
condition|(
operator|(
name|z
operator|=
name|cmkey
argument_list|(
name|intimt
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|intime
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|IN_CAS
case|:
comment|/* SET INPUT CASE */
if|if
condition|(
operator|(
name|z
operator|=
name|cmkey
argument_list|(
name|incast
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|incase
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
case|case
name|IN_ECH
case|:
comment|/* SET INPUT ECHO */
return|return
operator|(
name|success
operator|=
name|seton
argument_list|(
operator|&
name|inecho
argument_list|)
operator|)
return|;
case|case
name|IN_SIL
case|:
comment|/* SET INPUT SILENCE */
name|z
operator|=
name|cmnum
argument_list|(
literal|"Positive number"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|setnum
argument_list|(
operator|&
name|insilence
argument_list|,
name|x
argument_list|,
name|z
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NOSPL */
comment|/*   setlin -- parse name of and then open a communication device.   Call with:     xx == XXLINE for a serial (tty) line, XXHOST for a network host,     zz == 0 means if user doesn't give a device name, continue current             active connection (if any);     zz != 0 means if user doesn't give a device name, then close the             current connection and restore the default communication device. */
name|int
name|setlin
parameter_list|(
name|xx
parameter_list|,
name|zz
parameter_list|)
name|int
name|xx
decl_stmt|,
name|zz
decl_stmt|;
block|{
if|if
condition|(
name|xx
operator|==
name|XYHOST
condition|)
block|{
comment|/* SET HOST<hostname> */
ifndef|#
directive|ifndef
name|NETCONN
name|printf
argument_list|(
literal|"?Network connections not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
else|#
directive|else
if|if
condition|(
operator|(
name|nettype
operator|!=
name|NET_DEC
operator|)
operator|&&
operator|(
name|nettype
operator|!=
name|NET_SX25
operator|)
operator|&&
operator|(
name|nettype
operator|!=
name|NET_TCPB
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"?Network type not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|nettype
operator|!=
name|NET_TCPB
condition|)
block|{
comment|/* Not a TCP/IP connection */
comment|/* Just get a text string */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
name|zz
condition|?
literal|"Network host name,\n or carriage return to close an open connection"
else|:
literal|"Network host name,\n or carriage return to resume an open connection"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
block|}
else|else
block|{
comment|/* TCP/IP connection... */
comment|/* Parse for host and service separately. */
if|if
condition|(
operator|(
name|x
operator|=
name|cmfld
argument_list|(
name|zz
condition|?
literal|"IP host name or number,\n or carriage return to close an open connection"
else|:
literal|"IP host name or number,\n or carriage return to resume an open connection"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|!=
operator|-
literal|3
condition|)
comment|/* Parse error */
return|return
operator|(
name|x
operator|)
return|;
comment|/* return it */
elseif|else
if|if
condition|(
operator|!
name|zz
condition|)
comment|/* No hostname given */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* and none required, */
block|}
comment|/* continue current connection. */
if|if
condition|(
operator|*
name|s
condition|)
block|{
comment|/* If they gave a host name... */
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* make a copy */
comment|/* Check for "host:service" */
for|for
control|(
init|;
operator|(
operator|*
name|s
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|':'
operator|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
comment|/* If no service given, let them type one now. */
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|cmfld
argument_list|(
literal|"TCP service name or number,\n or carriage return for telnet (23)"
argument_list|,
literal|"23"
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
operator|&&
name|x
operator|!=
operator|-
literal|3
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
comment|/* If they gave a service, */
name|strcat
argument_list|(
name|line
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|/* concatenate it to the hostname */
name|strcat
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* separated by a colon, because */
block|}
comment|/* this is how ttopen() wants it. */
block|}
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* Confirm the command */
name|s
operator|=
name|line
expr_stmt|;
block|}
block|}
comment|/* New connection wanted. */
name|ttflui
argument_list|()
expr_stmt|;
comment|/* Clear away buffered up junk */
name|ttclos
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Close old connection, if any */
if|if
condition|(
name|oldplex
operator|>
operator|-
literal|1
condition|)
comment|/* Restore duplex setting. */
name|duplex
operator|=
name|oldplex
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
comment|/* They gave a hostname */
name|x
operator|=
literal|1
expr_stmt|;
comment|/* Network connection always local */
name|mdmsav
operator|=
name|mdmtyp
expr_stmt|;
comment|/* Remember old modem type */
name|mdmtyp
operator|=
operator|-
name|nettype
expr_stmt|;
comment|/* Special code for network */
if|if
condition|(
name|nettype
operator|==
name|NET_TCPB
condition|)
block|{
comment|/* For TCP/IP telnet connections */
name|oldplex
operator|=
name|duplex
expr_stmt|;
comment|/* Remember previous duplex */
name|duplex
operator|=
literal|0
expr_stmt|;
comment|/* Set full duplex and let */
block|}
comment|/* negotiations change if necessary. */
block|}
else|else
block|{
comment|/* They just said "set host" */
if|if
condition|(
name|network
operator|&&
name|msgflg
condition|)
name|printf
argument_list|(
literal|" Closing connection\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|dftty
expr_stmt|;
comment|/* So go back to normal */
name|x
operator|=
name|dfloc
expr_stmt|;
comment|/* default tty, location, */
name|network
operator|=
literal|0
expr_stmt|;
comment|/* No more network connection. */
name|duplex
operator|=
name|oldplex
expr_stmt|;
comment|/* Restore old duplex setting. */
if|if
condition|(
name|mdmtyp
operator|<
literal|0
condition|)
block|{
comment|/* Switching from net to async? */
if|if
condition|(
name|mdmsav
operator|>
operator|-
literal|1
condition|)
comment|/* Restore modem type from last */
name|mdmtyp
operator|=
name|mdmsav
expr_stmt|;
comment|/* SET MODEM command, if any. */
else|else
name|mdmtyp
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NETCONN */
block|}
comment|/* Serial tty device, possibly modem, connection... */
if|if
condition|(
name|xx
operator|==
name|XYLINE
condition|)
block|{
comment|/* SET LINE */
ifdef|#
directive|ifdef
name|OS2
comment|/* or SET PORT */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|os2devtab
argument_list|,
name|nos2dev
argument_list|,
literal|"serial communication device name"
argument_list|,
literal|"com1"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"OS2 SET PORT x"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
operator|-
literal|9
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|s
operator|=
name|atxbuf
expr_stmt|;
comment|/* Doesn't match keyword */
if|if
condition|(
operator|*
name|s
operator|==
literal|'_'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Secret notation for file handle */
else|else
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
literal|1
operator|&&
name|x
operator|<=
literal|8
condition|)
block|{
comment|/* Regular COM port */
name|s
operator|=
name|os2devtab
index|[
name|x
operator|+
literal|7
index|]
operator|.
name|kwd
expr_stmt|;
comment|/* Use its real name */
block|}
else|else
name|s
operator|=
name|atxbuf
expr_stmt|;
comment|/* Something else, believe it */
else|#
directive|else
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Communication device name"
argument_list|,
name|dftty
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
endif|#
directive|endif
comment|/* OS2 */
if|if
condition|(
name|local
condition|)
name|ttflui
argument_list|()
expr_stmt|;
comment|/* Clear away buffered up junk */
name|ttclos
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Close old line, if any was open */
if|if
condition|(
operator|*
name|s
condition|)
block|{
comment|/* They gave a device name */
name|x
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Let ttopen decide about it */
block|}
else|else
block|{
comment|/* They just said "set line" */
name|s
operator|=
name|dftty
expr_stmt|;
comment|/* so go back to normal tty */
name|x
operator|=
name|dfloc
expr_stmt|;
comment|/* and mode. */
block|}
if|if
condition|(
name|mdmtyp
operator|<
literal|0
condition|)
block|{
comment|/* Switching from net to async? */
if|if
condition|(
name|mdmsav
operator|>
operator|-
literal|1
condition|)
comment|/* Restore modem type from last */
name|mdmtyp
operator|=
name|mdmsav
expr_stmt|;
comment|/* SET MODEM command, if any. */
else|else
name|mdmtyp
operator|=
literal|0
expr_stmt|;
name|mdmsav
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|oldplex
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* Restore previous duplex setting. */
name|duplex
operator|=
name|oldplex
expr_stmt|;
name|oldplex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|network
operator|=
literal|0
expr_stmt|;
comment|/* No more network. */
block|}
ifdef|#
directive|ifdef
name|COMMENT
comment|/*   The following is removed, not so much because it's a horrible hack, but   because it only works if the SET FLOW command was given *before* the SET   LINE command, whereas normally these commands can be given in any order. */
ifdef|#
directive|ifdef
name|NEXT
comment|/*   This is a horrible hack, but it's nice for users.  On the NeXT, you select   RTS/CTS hardware flow control not by system calls, but by referring to the   device with a different name.  If the user has asked for RTS/CTS flow   control on a NeXT, but used the non-RTS/CTS device name in the SET LINE   command, we make the appropriate substitute here.  I wonder how much bigger   this section of code will grow as the years go by...  */
if|if
condition|(
operator|(
name|flow
operator|==
name|FLO_RTSC
operator|)
operator|&&
comment|/* RTS/CTS flow control selected */
name|strcmp
argument_list|(
name|s
argument_list|,
name|dftty
argument_list|)
condition|)
block|{
comment|/*  ...on external port? */
name|y
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Yes, insert "f" as next-to-last */
if|if
condition|(
name|s
index|[
name|y
operator|-
literal|2
index|]
operator|!=
literal|'f'
condition|)
block|{
comment|/* character in device name if not */
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* already there... */
name|line
index|[
name|y
index|]
operator|=
name|line
index|[
name|y
operator|-
literal|1
index|]
expr_stmt|;
comment|/* So /dev/cua => /dev/cufa, etc. */
name|line
index|[
name|y
operator|-
literal|1
index|]
operator|=
literal|'f'
expr_stmt|;
name|line
index|[
name|y
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|line
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NEXT */
endif|#
directive|endif
comment|/* COMMENT */
if|if
condition|(
operator|(
name|y
operator|=
name|ttopen
argument_list|(
name|s
argument_list|,
operator|&
name|x
argument_list|,
name|mdmtyp
argument_list|,
name|cdtimo
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* Open the new line */
if|if
condition|(
name|y
operator|==
operator|-
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"?Timed out, no carrier.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Try SET CARRIER OFF and SET LINE again, or else\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SET MODEM, SET LINE, and then DIAL.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, access to lock denied: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|==
operator|-
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, access to device denied: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|==
operator|-
literal|5
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
name|printf
argument_list|(
literal|"Sorry, device is in use or otherwise unavailable: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Sorry, device is in use: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
block|}
else|else
block|{
comment|/* Other error. */
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|errno
condition|)
block|{
name|tp
operator|=
name|tmpbuf
expr_stmt|;
name|sprintf
argument_list|(
name|tp
argument_list|,
literal|"Sorry, can't open connection: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* VMS */
name|printf
argument_list|(
literal|"Sorry, can't open connection: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|local
operator|=
name|dfloc
expr_stmt|;
comment|/* Go back to normal */
ifndef|#
directive|ifndef
name|MAC
name|strcpy
argument_list|(
name|ttname
argument_list|,
name|dftty
argument_list|)
expr_stmt|;
comment|/* Restore default tty name */
endif|#
directive|endif
comment|/* MAC */
name|speed
operator|=
name|ttgspd
argument_list|()
expr_stmt|;
name|network
operator|=
literal|0
expr_stmt|;
comment|/* No network connection active */
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
comment|/* Return failure */
block|}
if|if
condition|(
name|x
operator|>
operator|-
literal|1
condition|)
name|local
operator|=
name|x
expr_stmt|;
comment|/* Opened ok, set local/remote. */
name|network
operator|=
operator|(
name|mdmtyp
operator|<
literal|0
operator|)
expr_stmt|;
comment|/* Remember connection type. */
ifdef|#
directive|ifdef
name|TNCODE
if|if
condition|(
name|network
condition|)
name|tn_init
operator|=
literal|0
expr_stmt|;
comment|/* Say telnet not init'd yet. */
endif|#
directive|endif
comment|/* TNCODE */
name|strcpy
argument_list|(
name|ttname
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Copy name into real place. */
name|speed
operator|=
name|ttgspd
argument_list|()
expr_stmt|;
comment|/* Get the current speed. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"set line "
argument_list|,
name|ttname
argument_list|,
name|local
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETCONN
ifdef|#
directive|ifdef
name|SUNX25
if|if
condition|(
name|nettype
operator|==
name|NET_SX25
condition|)
name|duplex
operator|=
literal|1
expr_stmt|;
comment|/* Duplex half */
endif|#
directive|endif
comment|/* SUNX25 */
endif|#
directive|endif
comment|/* NETCONN */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOICP */
end_comment

end_unit

