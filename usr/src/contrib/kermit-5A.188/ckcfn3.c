begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  C K C F N 3  --  Packet buffer management for C-Kermit  */
end_comment

begin_comment
comment|/* (plus assorted functions tacked on at the end) */
end_comment

begin_comment
comment|/*   Author: Frank da Cruz (fdc@columbia.edu, FDCCU@CUVMA.BITNET),   Columbia University Center for Computing Activities.   First released January 1985.   Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University. */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_include
include|#
directive|include
file|"ckcasc.h"
end_include

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_include
include|#
directive|include
file|"ckcxla.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|unkcs
decl_stmt|,
name|wmax
decl_stmt|,
name|wcur
decl_stmt|,
name|discard
decl_stmt|,
name|bctu
decl_stmt|,
name|bctl
decl_stmt|,
name|local
decl_stmt|,
name|fdispla
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|filnam
index|[]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOFRILLS
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|rprintf
decl_stmt|,
name|rmailf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* REMOTE MAIL, PRINT */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|optbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options buffer for mail, print */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOFRILLS */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|wslots
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fblksiz
decl_stmt|,
name|frecl
decl_stmt|,
name|forg
decl_stmt|,
name|frecfm
decl_stmt|,
name|fncact
decl_stmt|,
name|fcctrl
decl_stmt|,
name|lf_opts
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DYNAMIC
end_ifdef

begin_decl_stmt
specifier|extern
name|CHAR
modifier|*
name|srvcmd
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|CHAR
name|srvcmd
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|binary
decl_stmt|,
name|spsiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pktnum
decl_stmt|,
name|cxseen
decl_stmt|,
name|czseen
decl_stmt|,
name|bsave
decl_stmt|,
name|bsavef
decl_stmt|,
name|nfils
decl_stmt|,
name|stdinf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|memstr
decl_stmt|,
name|stdouf
decl_stmt|,
name|keep
decl_stmt|,
name|sndsrc
decl_stmt|,
name|hcflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|server
decl_stmt|,
name|en_cwd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|atenci
decl_stmt|,
name|atenco
decl_stmt|,
name|atdati
decl_stmt|,
name|atdato
decl_stmt|,
name|atleni
decl_stmt|,
name|atleno
decl_stmt|,
name|atblki
decl_stmt|,
name|atblko
decl_stmt|,
name|attypi
decl_stmt|,
name|attypo
decl_stmt|,
name|atsidi
decl_stmt|,
name|atsido
decl_stmt|,
name|atsysi
decl_stmt|,
name|atsyso
decl_stmt|,
name|atdisi
decl_stmt|,
name|atdiso
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|datageneral
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|quiet
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* datageneral */
end_comment

begin_decl_stmt
specifier|extern
name|long
name|fsize
decl_stmt|,
name|filcnt
decl_stmt|,
name|ffc
decl_stmt|,
name|tfc
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOCSETS
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|tcharset
decl_stmt|,
name|fcharset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ntcsets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|csinfo
name|tcsinfo
index|[]
decl_stmt|,
name|fcsinfo
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointers to translation functions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CK_ANSIC
end_ifdef

begin_function_decl
specifier|extern
name|CHAR
function_decl|(
modifier|*
name|xls
index|[
name|MAXTCSETS
operator|+
literal|1
index|]
index|[
name|MAXFCSETS
operator|+
literal|1
index|]
function_decl|)
parameter_list|(
name|CHAR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Character set */
end_comment

begin_function_decl
specifier|extern
name|CHAR
function_decl|(
modifier|*
name|xlr
index|[
name|MAXTCSETS
operator|+
literal|1
index|]
index|[
name|MAXFCSETS
operator|+
literal|1
index|]
function_decl|)
parameter_list|(
name|CHAR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* translation functions */
end_comment

begin_function_decl
specifier|extern
name|CHAR
function_decl|(
modifier|*
name|rx
function_decl|)
parameter_list|(
name|CHAR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pointer to input character translation function */
end_comment

begin_function_decl
specifier|extern
name|CHAR
function_decl|(
modifier|*
name|sx
function_decl|)
parameter_list|(
name|CHAR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pointer to output character translation function */
end_comment

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|CHAR
function_decl|(
modifier|*
name|xls
index|[
name|MAXTCSETS
operator|+
literal|1
index|]
index|[
name|MAXFCSETS
operator|+
literal|1
index|]
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Character set */
end_comment

begin_function_decl
specifier|extern
name|CHAR
function_decl|(
modifier|*
name|xlr
index|[
name|MAXTCSETS
operator|+
literal|1
index|]
index|[
name|MAXFCSETS
operator|+
literal|1
index|]
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* translation functions. */
end_comment

begin_function_decl
specifier|extern
name|CHAR
function_decl|(
modifier|*
name|rx
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Pointer to input character translation function */
end_comment

begin_function_decl
specifier|extern
name|CHAR
function_decl|(
modifier|*
name|sx
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Pointer to output character translation function */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CK_ANSIC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOCSETS */
end_comment

begin_comment
comment|/* Variables global to Kermit that are defined in this module */
end_comment

begin_decl_stmt
name|int
name|winlo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packet number at low window edge  */
end_comment

begin_decl_stmt
name|int
name|sbufnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of free buffers */
end_comment

begin_decl_stmt
name|int
name|dum001
init|=
literal|1234
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* protection... */
end_comment

begin_decl_stmt
name|int
name|sbufuse
index|[
name|MAXWS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer in-use flag */
end_comment

begin_decl_stmt
name|int
name|dum003
init|=
literal|1111
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rbufnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of free buffers */
end_comment

begin_decl_stmt
name|int
name|dum002
init|=
literal|4321
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* more protection */
end_comment

begin_decl_stmt
name|int
name|rbufuse
index|[
name|MAXWS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer in-use flag */
end_comment

begin_decl_stmt
name|int
name|sseqtbl
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sequence # to buffer # table */
end_comment

begin_decl_stmt
name|int
name|rseqtbl
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sequence # to buffer # table */
end_comment

begin_decl_stmt
name|int
name|sacktbl
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sequence # ack table */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DYNAMIC
end_ifdef

begin_decl_stmt
name|struct
name|pktinfo
modifier|*
name|s_pkt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pktinfo structures */
end_comment

begin_decl_stmt
name|struct
name|pktinfo
modifier|*
name|r_pkt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pktinfo structures */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|pktinfo
name|s_pkt
index|[
name|MAXWS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pktinfo structures */
end_comment

begin_decl_stmt
name|struct
name|pktinfo
name|r_pkt
index|[
name|MAXWS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pktinfo structures */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DYNAMIC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|char
name|xbuf
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For debug logging */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DYNAMIC
end_ifdef

begin_decl_stmt
name|CHAR
modifier|*
name|bigsbuf
init|=
name|NULL
decl_stmt|,
modifier|*
name|bigrbuf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|bigsbt
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protection (shouldn't need this). */
end_comment

begin_comment
comment|/* BUT DON'T REMOVE IT! */
end_comment

begin_decl_stmt
name|CHAR
name|bigsbuf
index|[
name|SBSIZ
operator|+
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send-packet buffer area */
end_comment

begin_decl_stmt
name|char
name|bigrbt
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Safety padding */
end_comment

begin_decl_stmt
name|CHAR
name|bigrbuf
index|[
name|RBSIZ
operator|+
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Receive-packet area */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|bigsbsiz
init|=
name|SBSIZ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sizes of big send& rcv buffers. */
end_comment

begin_decl_stmt
name|int
name|bigrbsiz
init|=
name|RBSIZ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FUNCTIONS */
end_comment

begin_comment
comment|/* For sanity, use "i" for buffer slots, "n" for packet numbers. */
end_comment

begin_comment
comment|/* I N I B U F S */
end_comment

begin_comment
comment|/*   Allocates the big send and receive buffers.   Call with size for big send buffer (s) and receive buffer (r).   These sizes can be different.   Attempts to allocate buffers of the requested size, but if it can't,   it will allocate smaller ones.   Sets global variables bigsbsiz and bigrbsiz to the actual sizes,   and bigsbuf and bigrbuf pointing to the actual buffers.   Designed to be called more than once.   Returns 0 on success, -1 on failure. */
end_comment

begin_decl_stmt
name|CHAR
modifier|*
name|bigbufp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|inibufs
parameter_list|(
name|s
parameter_list|,
name|r
parameter_list|)
name|int
name|s
decl_stmt|,
name|r
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DYNAMIC
name|int
name|size
decl_stmt|,
name|x
decl_stmt|;
name|long
name|z
decl_stmt|;
if|if
condition|(
name|s
operator|<
literal|80
operator|||
name|r
operator|<
literal|80
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Validate arguments. */
if|if
condition|(
operator|!
name|s_pkt
condition|)
block|{
comment|/* Allocate packet info structures */
if|if
condition|(
operator|!
operator|(
name|s_pkt
operator|=
operator|(
expr|struct
name|pktinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pktinfo
argument_list|)
operator|*
name|MAXWS
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"ini_pkts: no memory for s_pkt"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|MAXWS
condition|;
name|x
operator|++
control|)
name|s_pkt
index|[
name|x
index|]
operator|.
name|pk_adr
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize addresses */
if|if
condition|(
operator|!
name|r_pkt
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|r_pkt
operator|=
operator|(
expr|struct
name|pktinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pktinfo
argument_list|)
operator|*
name|MAXWS
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"ini_pkts: no memory for s_pkt"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|MAXWS
condition|;
name|x
operator|++
control|)
name|r_pkt
index|[
name|x
index|]
operator|.
name|pk_adr
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize addresses */
if|if
condition|(
operator|!
name|srvcmd
condition|)
block|{
comment|/* Allocate srvcmd buffer */
name|srvcmd
operator|=
operator|(
name|CHAR
operator|*
operator|)
name|malloc
argument_list|(
name|r
operator|+
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|srvcmd
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bigbufp
condition|)
block|{
comment|/* Free previous buffers, if any. */
name|free
argument_list|(
name|bigbufp
argument_list|)
expr_stmt|;
name|bigbufp
operator|=
name|NULL
expr_stmt|;
block|}
name|size
operator|=
name|s
operator|+
name|r
operator|+
literal|40
expr_stmt|;
comment|/* Combined requested size + padding */
comment|/* Try to get the space.  If malloc fails, try to get a little less. */
comment|/* (Obviously, this algorithm can be refined.) */
while|while
condition|(
operator|!
operator|(
name|bigbufp
operator|=
operator|(
name|CHAR
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
condition|)
block|{
name|size
operator|=
operator|(
name|size
operator|*
literal|3
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* Failed, cut size by 1/3. */
if|if
condition|(
name|size
operator|<
literal|200
condition|)
comment|/* Try again until too small. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"inibufs size"
argument_list|,
literal|""
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* OK, we got some space. */
comment|/*   Now divide the allocated space between the send and receive buffers in the   requested proportion.  The natural formula would be (s / (s + r)) * size   (for the send buffer), but that doesn't work with integer arithmetic and we   can't use floating point because some machines don't have it.  This can be   rearranged as (s * size) / (s + r).  But (s * size) can be VERY large, too   large for 32 bits.  So let's do it this way.  This arithmetic works for   buffer sizes up to about 5,000,000. */
define|#
directive|define
name|FACTOR
value|20L
name|z
operator|=
operator|(
operator|(
name|long
operator|)
name|s
operator|*
name|FACTOR
operator|)
operator|/
operator|(
operator|(
name|long
operator|)
name|s
operator|+
operator|(
name|long
operator|)
name|r
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|z
operator|*
operator|(
operator|(
name|long
operator|)
name|size
operator|/
name|FACTOR
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Catch overflow */
name|bigsbsiz
operator|=
name|x
operator|-
literal|5
expr_stmt|;
comment|/* Size of send buffer */
name|bigsbuf
operator|=
name|bigbufp
expr_stmt|;
comment|/* Address of send buffer */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"inibufs bigsbsiz"
argument_list|,
literal|""
argument_list|,
name|bigsbsiz
argument_list|)
expr_stmt|;
name|bigrbsiz
operator|=
name|size
operator|-
name|x
operator|-
literal|5
expr_stmt|;
comment|/* Size of receive buffer */
name|bigrbuf
operator|=
name|bigbufp
operator|+
name|x
expr_stmt|;
comment|/* Addresss of receive buffer */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"inibufs bigrbsiz"
argument_list|,
literal|""
argument_list|,
name|bigrbsiz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Success */
else|#
directive|else
comment|/* No dynamic allocation */
name|bigsbsiz
operator|=
name|SBSIZ
expr_stmt|;
comment|/* Just use the symbols */
name|bigrbsiz
operator|=
name|RBSIZ
expr_stmt|;
comment|/* ... */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Success. */
endif|#
directive|endif
comment|/* DYNAMIC */
block|}
end_function

begin_comment
comment|/* M A K E B U F  --  Makes and clears a new buffers.  */
end_comment

begin_comment
comment|/* Call with: */
end_comment

begin_comment
comment|/*  slots:  number of buffer slots to make, 1 to 31 */
end_comment

begin_comment
comment|/*  bufsiz: size of the big buffer */
end_comment

begin_comment
comment|/*  buf:    address of the big buffer */
end_comment

begin_comment
comment|/*  xx:     pointer to array of pktinfo structures for these buffers */
end_comment

begin_comment
comment|/* Subdivides the big buffer into "slots" buffers. */
end_comment

begin_comment
comment|/* Returns: */
end_comment

begin_comment
comment|/*  -1 if too many or too few slots requested,     */
end_comment

begin_comment
comment|/*  -2 if slots would be too small.      */
end_comment

begin_comment
comment|/*   n (positive) on success = size of one buffer. */
end_comment

begin_comment
comment|/*   with pktinfo structure initialized for this set of buffers. */
end_comment

begin_function
name|int
name|makebuf
parameter_list|(
name|slots
parameter_list|,
name|bufsiz
parameter_list|,
name|buf
parameter_list|,
name|xx
parameter_list|)
comment|/* makebuf */
name|int
name|slots
decl_stmt|,
name|bufsiz
decl_stmt|;
name|CHAR
name|buf
index|[]
decl_stmt|;
name|struct
name|pktinfo
modifier|*
name|xx
decl_stmt|;
block|{
name|CHAR
modifier|*
name|a
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"makebuf"
argument_list|,
literal|""
argument_list|,
name|slots
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"makebuf bufsiz"
argument_list|,
literal|""
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"makebuf MAXWS"
argument_list|,
literal|""
argument_list|,
name|MAXWS
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots
operator|>
name|MAXWS
operator|||
name|slots
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|bufsiz
operator|<
name|slots
operator|*
literal|10
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|size
operator|=
name|bufsiz
operator|/
name|slots
expr_stmt|;
comment|/* Divide up the big buffer. */
name|a
operator|=
name|buf
expr_stmt|;
comment|/* Address of first piece. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slots
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|pktinfo
modifier|*
name|x
init|=
operator|&
name|xx
index|[
name|i
index|]
decl_stmt|;
name|x
operator|->
name|bf_adr
operator|=
name|a
expr_stmt|;
comment|/* Address of this buffer */
name|x
operator|->
name|bf_len
operator|=
name|size
expr_stmt|;
comment|/* Length of this buffer */
name|x
operator|->
name|pk_len
operator|=
literal|0
expr_stmt|;
comment|/* Length of data field */
name|x
operator|->
name|pk_typ
operator|=
literal|' '
expr_stmt|;
comment|/* packet type */
name|x
operator|->
name|pk_seq
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* packet sequence number */
name|x
operator|->
name|pk_flg
operator|=
literal|0
expr_stmt|;
comment|/* ack'd bit */
name|x
operator|->
name|pk_rtr
operator|=
literal|0
expr_stmt|;
comment|/* retransmissions */
operator|*
name|a
operator|=
literal|'\0'
expr_stmt|;
comment|/* Clear the buffer */
name|a
operator|+=
name|size
expr_stmt|;
comment|/* Position to next buffer slot */
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  M A K S B U F  --  Makes the send-packet buffer  */
end_comment

begin_function
name|int
name|mksbuf
parameter_list|(
name|slots
parameter_list|)
name|int
name|slots
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
name|sbufnum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|makebuf
argument_list|(
name|slots
argument_list|,
name|bigsbsiz
argument_list|,
name|bigsbuf
argument_list|,
name|s_pkt
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"mksbuf makebuf return"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"mksbuf makebuf return"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
comment|/* Initialize sequence-number- */
name|sseqtbl
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* to-buffer-number table. */
name|sacktbl
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXWS
condition|;
name|i
operator|++
control|)
name|sbufuse
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Mark each buffer as free */
name|sbufnum
operator|=
name|slots
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  M A K R B U F  --  Makes the receive-packet buffer  */
end_comment

begin_function
name|int
name|mkrbuf
parameter_list|(
name|slots
parameter_list|)
name|int
name|slots
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
name|rbufnum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|makebuf
argument_list|(
name|slots
argument_list|,
name|bigrbsiz
argument_list|,
name|bigrbuf
argument_list|,
name|r_pkt
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"mkrbuf makebuf return"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"mkrbuf makebuf return"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
comment|/* Initialize sequence-number- */
name|rseqtbl
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* to-buffer-number table. */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXWS
condition|;
name|i
operator|++
control|)
name|rbufuse
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Mark each buffer as free */
name|rbufnum
operator|=
name|slots
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  W I N D O W  --  Resize the window to n  */
end_comment

begin_function
name|int
name|window
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"window"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
operator|||
name|n
operator|>
literal|31
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|mksbuf
argument_list|(
name|n
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|mkrbuf
argument_list|(
name|n
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|wslots
operator|=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|deblog
condition|)
name|dumpsbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|deblog
condition|)
name|dumprbuf
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  G E T S B U F  --  Allocate a send-buffer.  */
end_comment

begin_comment
comment|/*  Call with packet sequence number to allocate buffer for. */
end_comment

begin_comment
comment|/*  Returns: */
end_comment

begin_comment
comment|/*   -4 if argument is invalid (negative, or greater than 63) */
end_comment

begin_comment
comment|/*   -3 if buffers were thought to be available but really weren't (bug!) */
end_comment

begin_comment
comment|/*   -2 if the number of free buffers is negative (bug!) */
end_comment

begin_comment
comment|/*   -1 if no free buffers. */
end_comment

begin_comment
comment|/*   0 or positive, packet sequence number, with buffer allocated for it. */
end_comment

begin_function
name|int
name|getsbuf
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
comment|/* Allocate a send-buffer */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|63
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"getsbuf bad arg"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|4
operator|)
return|;
comment|/* Bad argument */
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"getsbuf, packet"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"getsbuf, sbufnum"
argument_list|,
literal|""
argument_list|,
name|sbufnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbufnum
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* No free buffers. */
if|if
condition|(
name|sbufnum
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
comment|/* Shouldn't happen. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wslots
condition|;
name|i
operator|++
control|)
comment|/* Find the first one not in use. */
if|if
condition|(
name|sbufuse
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Got one? */
name|sbufuse
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Mark it as in use. */
name|sbufnum
operator|--
expr_stmt|;
comment|/* One less free buffer. */
operator|*
name|s_pkt
index|[
name|i
index|]
operator|.
name|bf_adr
operator|=
literal|'\0'
expr_stmt|;
comment|/* Zero the buffer data field */
name|s_pkt
index|[
name|i
index|]
operator|.
name|pk_seq
operator|=
name|n
expr_stmt|;
comment|/* Put in the sequence number */
name|sseqtbl
index|[
name|n
index|]
operator|=
name|i
expr_stmt|;
comment|/* Back pointer from sequence number */
name|sacktbl
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
comment|/* ACK flag */
name|s_pkt
index|[
name|i
index|]
operator|.
name|pk_len
operator|=
literal|0
expr_stmt|;
comment|/* Data field length now zero. */
name|s_pkt
index|[
name|i
index|]
operator|.
name|pk_typ
operator|=
literal|' '
expr_stmt|;
comment|/* Blank the packet type too. */
name|s_pkt
index|[
name|i
index|]
operator|.
name|pk_flg
operator|=
literal|0
expr_stmt|;
comment|/* Zero the flags */
name|s_pkt
index|[
name|i
index|]
operator|.
name|pk_rtr
operator|=
literal|0
expr_stmt|;
comment|/* Zero the retransmission count */
name|data
operator|=
name|s_pkt
index|[
name|i
index|]
operator|.
name|bf_adr
operator|+
literal|7
expr_stmt|;
comment|/* Set global "data" address. */
name|wcur
operator|=
name|wslots
operator|-
name|sbufnum
expr_stmt|;
comment|/* Current number of window slots */
if|if
condition|(
name|i
operator|+
literal|1
operator|>
name|wmax
condition|)
name|wmax
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* For statistics. */
return|return
operator|(
name|n
operator|)
return|;
comment|/* Return its index. */
block|}
name|sbufnum
operator|=
literal|0
expr_stmt|;
comment|/* Didn't find one. */
return|return
operator|(
operator|-
literal|3
operator|)
return|;
comment|/* Shouldn't happen! */
block|}
end_function

begin_function
name|int
name|getrbuf
parameter_list|()
block|{
comment|/* Allocate a receive buffer */
name|int
name|i
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"getrbuf rbufnum"
argument_list|,
literal|""
argument_list|,
name|rbufnum
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"getrbuf wslots"
argument_list|,
literal|""
argument_list|,
name|wslots
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"getrbuf dum002"
argument_list|,
literal|""
argument_list|,
name|dum002
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"getrbuf dum003"
argument_list|,
literal|""
argument_list|,
name|dum003
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbufnum
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* No free buffers. */
if|if
condition|(
name|rbufnum
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
comment|/* Shouldn't happen. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wslots
condition|;
name|i
operator|++
control|)
comment|/* Find the first one not in use. */
if|if
condition|(
name|rbufuse
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Got one? */
name|rbufuse
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Mark it as in use. */
operator|*
name|r_pkt
index|[
name|i
index|]
operator|.
name|bf_adr
operator|=
literal|'\0'
expr_stmt|;
comment|/* Zero the buffer data field */
name|rbufnum
operator|--
expr_stmt|;
comment|/* One less free buffer. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"getrbuf new rbufnum"
argument_list|,
literal|""
argument_list|,
name|rbufnum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
name|wcur
operator|=
name|wslots
operator|-
name|rbufnum
expr_stmt|;
comment|/* Current number of window slots */
endif|#
directive|endif
comment|/* COMMENT */
if|if
condition|(
name|i
operator|+
literal|1
operator|>
name|wmax
condition|)
name|wmax
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* For statistics. */
return|return
operator|(
name|i
operator|)
return|;
comment|/* Return its index. */
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"getrbuf foulup"
argument_list|,
literal|""
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rbufnum
operator|=
literal|0
expr_stmt|;
comment|/* Didn't find one. */
return|return
operator|(
operator|-
literal|3
operator|)
return|;
comment|/* Shouldn't happen! */
block|}
end_function

begin_comment
comment|/*  F R E E S B U F  --  Free send-buffer for given packet sequence number */
end_comment

begin_comment
comment|/*  Returns:  */
end_comment

begin_comment
comment|/*   1 upon success  */
end_comment

begin_comment
comment|/*  -1 if specified buffer does not exist */
end_comment

begin_function
name|int
name|freesbuf
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
comment|/* Release send-buffer for packet n. */
name|int
name|i
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"freesbuf"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|63
condition|)
comment|/* No such packet. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|i
operator|=
name|sseqtbl
index|[
name|n
index|]
expr_stmt|;
comment|/* Get the window slot number. */
if|if
condition|(
name|i
operator|>
operator|-
literal|1
operator|&&
name|i
operator|<=
name|wslots
condition|)
block|{
name|sseqtbl
index|[
name|n
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If valid, remove from seqtbl */
name|sbufnum
operator|++
expr_stmt|;
comment|/* and count one more free buffer */
name|sbufuse
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* and mark it as free, */
block|}
else|else
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|" sseqtbl[n]"
argument_list|,
literal|""
argument_list|,
name|sseqtbl
index|[
name|n
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* The following is done only so dumped buffers will look right. */
if|if
condition|(
literal|1
condition|)
block|{
operator|*
name|s_pkt
index|[
name|i
index|]
operator|.
name|bf_adr
operator|=
literal|'\0'
expr_stmt|;
comment|/* Zero the buffer data field */
name|s_pkt
index|[
name|i
index|]
operator|.
name|pk_seq
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Invalidate the sequence number */
name|s_pkt
index|[
name|i
index|]
operator|.
name|pk_len
operator|=
literal|0
expr_stmt|;
comment|/* Data field length now zero. */
name|s_pkt
index|[
name|i
index|]
operator|.
name|pk_typ
operator|=
literal|' '
expr_stmt|;
comment|/* Blank the packet type too. */
name|s_pkt
index|[
name|i
index|]
operator|.
name|pk_flg
operator|=
literal|0
expr_stmt|;
comment|/* And zero the flag */
name|s_pkt
index|[
name|i
index|]
operator|.
name|pk_rtr
operator|=
literal|0
expr_stmt|;
comment|/* And the retries field. */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|freerbuf
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
comment|/* Release receive-buffer slot "i". */
name|int
name|n
decl_stmt|;
comment|/* NOTE !! Currently, this function frees the indicated buffer, but */
comment|/* does NOT erase the data.  The program counts on this.  Will find a */
comment|/* better way later.... */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"freerbuf, slot"
argument_list|,
literal|""
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|wslots
condition|)
block|{
comment|/* No such slot. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"freerbuf no such slot"
argument_list|,
literal|""
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|n
operator|=
name|r_pkt
index|[
name|i
index|]
operator|.
name|pk_seq
expr_stmt|;
comment|/* Get the packet sequence number */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"freerbuf, packet"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
operator|-
literal|1
operator|&&
name|n
operator|<
literal|64
condition|)
comment|/* If valid, remove from seqtbl */
name|rseqtbl
index|[
name|n
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rbufuse
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* If really allocated, */
name|rbufuse
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* mark it as free, */
name|rbufnum
operator|++
expr_stmt|;
comment|/* and count one more free buffer. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"freerbuf, new rbufnum"
argument_list|,
literal|""
argument_list|,
name|rbufnum
argument_list|)
expr_stmt|;
block|}
comment|/* The following is done only so dumped buffers will look right. */
if|if
condition|(
literal|1
condition|)
block|{
comment|/* *r_pkt[i].bf_adr = '\0'; */
comment|/* Zero the buffer data field */
name|r_pkt
index|[
name|i
index|]
operator|.
name|pk_seq
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* And from packet list */
name|r_pkt
index|[
name|i
index|]
operator|.
name|pk_len
operator|=
literal|0
expr_stmt|;
comment|/* Data field length now zero. */
name|r_pkt
index|[
name|i
index|]
operator|.
name|pk_typ
operator|=
literal|' '
expr_stmt|;
comment|/* Blank the packet type too. */
name|r_pkt
index|[
name|i
index|]
operator|.
name|pk_flg
operator|=
literal|0
expr_stmt|;
comment|/* And zero the flag */
name|r_pkt
index|[
name|i
index|]
operator|.
name|pk_rtr
operator|=
literal|0
expr_stmt|;
comment|/* And the retries field. */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is like freerbuf, except it's called with a packet sequence number */
end_comment

begin_comment
comment|/* rather than a packet buffer index. */
end_comment

begin_function
name|VOID
name|freerpkt
parameter_list|(
name|seq
parameter_list|)
name|int
name|seq
decl_stmt|;
block|{
name|int
name|k
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"freerpkt seq"
argument_list|,
literal|""
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|k
operator|=
name|rseqtbl
index|[
name|seq
index|]
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"freerpkt k"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>
operator|-
literal|1
condition|)
block|{
name|k
operator|=
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"freerpkt freerbuf"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  C H K W I N  --  Check if packet n is in window. */
end_comment

begin_comment
comment|/*  Returns: */
end_comment

begin_comment
comment|/*    0 if it is in the current window,  */
end_comment

begin_comment
comment|/*   +1 if it would have been in previous window (e.g. if ack was lost), */
end_comment

begin_comment
comment|/*   -1 if it is outside any window (protocol error),   */
end_comment

begin_comment
comment|/*   -2 if either of the argument packet numbers is out of range.  */
end_comment

begin_comment
comment|/* Call with packet number to check (n), lowest packet number in window */
end_comment

begin_comment
comment|/* (bottom), and number of slots in window (slots).  */
end_comment

begin_function
name|int
name|chkwin
parameter_list|(
name|n
parameter_list|,
name|bottom
parameter_list|,
name|slots
parameter_list|)
name|int
name|n
decl_stmt|,
name|bottom
decl_stmt|,
name|slots
decl_stmt|;
block|{
name|int
name|top
decl_stmt|,
name|prev
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"chkwin packet"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"chkwin winlo"
argument_list|,
literal|""
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"chkwin slots"
argument_list|,
literal|""
argument_list|,
name|slots
argument_list|)
expr_stmt|;
comment|/* First do the easy and common cases, where the windows are not split. */
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|63
operator|||
name|bottom
operator|<
literal|0
operator|||
name|bottom
operator|>
literal|63
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
if|if
condition|(
name|n
operator|==
name|bottom
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* In a perfect world... */
name|top
operator|=
name|bottom
operator|+
name|slots
expr_stmt|;
comment|/* Calculate window top. */
if|if
condition|(
name|top
operator|<
literal|64
operator|&&
name|n
operator|<
name|top
operator|&&
name|n
operator|>=
name|bottom
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* In current window. */
name|prev
operator|=
name|bottom
operator|-
name|slots
expr_stmt|;
comment|/* Bottom of previous window. */
if|if
condition|(
name|prev
operator|>
operator|-
literal|1
operator|&&
name|n
operator|<
name|bottom
operator|&&
name|n
operator|>
name|prev
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* In previous. */
comment|/* Now consider the case where the current window is split. */
if|if
condition|(
name|top
operator|>
literal|63
condition|)
block|{
comment|/* Wraparound... */
name|top
operator|-=
literal|64
expr_stmt|;
comment|/* Get modulo-64 sequence number */
if|if
condition|(
name|n
operator|<
name|top
operator|||
name|n
operator|>=
name|bottom
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* In current window. */
block|}
else|else
block|{
comment|/* Not in current window. */
if|if
condition|(
name|n
operator|<
name|bottom
operator|&&
name|n
operator|>=
name|prev
condition|)
comment|/* Previous window can't be split. */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* In previous window. */
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Not in previous window. */
block|}
block|}
comment|/* Now the case where current window not split, but previous window is. */
if|if
condition|(
name|prev
operator|<
literal|0
condition|)
block|{
comment|/* Is previous window split? */
name|prev
operator|+=
literal|64
expr_stmt|;
comment|/* Yes. */
if|if
condition|(
name|n
operator|<
name|bottom
operator|||
name|n
operator|>=
name|prev
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* In previous window. */
block|}
else|else
block|{
comment|/* Previous window not split. */
if|if
condition|(
name|n
operator|<
name|bottom
operator|&&
name|n
operator|>=
name|prev
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* In previous window. */
block|}
comment|/* It's not in the current window, and not in the previous window... */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* So it's not in any window. */
block|}
end_function

begin_function
name|int
name|dumpsbuf
parameter_list|()
block|{
comment|/* Dump send-buffers */
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|j
decl_stmt|,
name|x
decl_stmt|;
comment|/* to debug log. */
if|if
condition|(
operator|!
name|deblog
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|x
operator|=
name|zsoutl
argument_list|(
name|ZDFILE
argument_list|,
literal|"SEND BUFFERS:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|deblog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|x
operator|=
name|zsoutl
argument_list|(
name|ZDFILE
argument_list|,
literal|"buffer inuse address length data type seq flag retries"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|deblog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wslots
condition|;
name|j
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|xbuf
argument_list|,
literal|"%4d%6d%10d%5d%6d%4c%5d%5d%6d\n"
argument_list|,
name|j
argument_list|,
name|sbufuse
index|[
name|j
index|]
argument_list|,
name|s_pkt
index|[
name|j
index|]
operator|.
name|bf_adr
argument_list|,
name|s_pkt
index|[
name|j
index|]
operator|.
name|bf_len
argument_list|,
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_len
argument_list|,
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_typ
argument_list|,
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_seq
argument_list|,
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_flg
argument_list|,
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_rtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|xbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|deblog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_adr
condition|)
block|{
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_adr
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
name|sprintf
argument_list|(
name|xbuf
argument_list|,
literal|"[%.72s%s]\n"
argument_list|,
name|s_pkt
index|[
name|j
index|]
operator|.
name|pk_adr
argument_list|,
name|x
operator|>
literal|72
condition|?
literal|"..."
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|xbuf
argument_list|,
literal|"[(empty string)]\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|xbuf
argument_list|,
literal|"[(null pointer)]\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|xbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|deblog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|sprintf
argument_list|(
name|xbuf
argument_list|,
literal|"free: %d, winlo: %d\n"
argument_list|,
name|sbufnum
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|xbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|deblog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_function

begin_function
name|int
name|dumprbuf
parameter_list|()
block|{
comment|/* Dump receive-buffers */
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|j
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|deblog
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zsoutl
argument_list|(
name|ZDFILE
argument_list|,
literal|"RECEIVE BUFFERS:"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|deblog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|x
operator|=
name|zsoutl
argument_list|(
name|ZDFILE
argument_list|,
literal|"buffer inuse address length data type seq flag retries"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|deblog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wslots
condition|;
name|j
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|xbuf
argument_list|,
literal|"%4d%6d%10d%5d%6d%4c%5d%5d%6d\n"
argument_list|,
name|j
argument_list|,
name|rbufuse
index|[
name|j
index|]
argument_list|,
name|r_pkt
index|[
name|j
index|]
operator|.
name|bf_adr
argument_list|,
name|r_pkt
index|[
name|j
index|]
operator|.
name|bf_len
argument_list|,
name|r_pkt
index|[
name|j
index|]
operator|.
name|pk_len
argument_list|,
name|r_pkt
index|[
name|j
index|]
operator|.
name|pk_typ
argument_list|,
name|r_pkt
index|[
name|j
index|]
operator|.
name|pk_seq
argument_list|,
name|r_pkt
index|[
name|j
index|]
operator|.
name|pk_flg
argument_list|,
name|r_pkt
index|[
name|j
index|]
operator|.
name|pk_rtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|xbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|deblog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r_pkt
index|[
name|j
index|]
operator|.
name|bf_adr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|xbuf
argument_list|,
literal|"[%.72s%s]\n"
argument_list|,
name|r_pkt
index|[
name|j
index|]
operator|.
name|bf_adr
argument_list|,
name|x
operator|>
literal|72
condition|?
literal|"..."
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|xbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|deblog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|sprintf
argument_list|(
name|xbuf
argument_list|,
literal|"free: %d, winlo: %d\n"
argument_list|,
name|rbufnum
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|xbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|deblog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Some misc functions also moved here from the other ckcfn*.c modules ***/
end_comment

begin_comment
comment|/*** to even out the module sizes. ***/
end_comment

begin_comment
comment|/* Attribute Packets. */
end_comment

begin_comment
comment|/*   Call with xp == 0 if we're sending a real file (F packet),   or xp != 0 for screen data (X packet).   Returns 0 on success, -1 on failure. */
end_comment

begin_function
name|int
name|sattr
parameter_list|(
name|xp
parameter_list|)
name|int
name|xp
decl_stmt|;
block|{
comment|/* Send Attributes */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|aln
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
name|struct
name|zattr
name|x
decl_stmt|;
if|if
condition|(
name|zsattr
argument_list|(
operator|&
name|x
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Get attributes or die trying */
if|if
condition|(
name|nxtpkt
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Next packet number */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* i = Data field character number */
if|if
condition|(
name|atsido
condition|)
block|{
comment|/* System type */
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
name|data
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
name|x
operator|.
name|systemid
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/*  Copy from attr structure */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|x
operator|.
name|systemid
operator|.
name|len
condition|;
name|j
operator|++
control|)
name|data
index|[
name|i
operator|++
index|]
operator|=
name|x
operator|.
name|systemid
operator|.
name|val
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|attypo
condition|)
block|{
comment|/* File type */
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'"'
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|VMS
name|binary
operator|==
name|XYFT_I
operator|||
name|binary
operator|==
name|XYFT_L
operator|||
comment|/* IMAGE or LABELED */
operator|!
name|strncmp
argument_list|(
argument|x.recfm.val
argument_list|,
literal|"F"
argument_list|,
literal|1
argument_list|)
comment|/* or RECFM=Fxxxxxx */
else|#
directive|else
name|binary
comment|/* User said SET FILE TYPE BINARY  */
endif|#
directive|endif
comment|/* VMS */
condition|)
block|{
comment|/* Binary */
name|data
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/*  Two characters */
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'B'
expr_stmt|;
comment|/*  B for Binary */
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'8'
expr_stmt|;
comment|/*  8-bit bytes (note assumption...) */
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|binary
operator|!=
name|XYFT_I
operator|&&
name|binary
operator|!=
name|XYFT_L
condition|)
name|binary
operator|=
name|XYFT_B
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
block|}
else|else
block|{
comment|/* Text */
name|data
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/*  Three characters */
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'A'
expr_stmt|;
comment|/*  A = (extended) ASCII with CRLFs */
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'M'
expr_stmt|;
comment|/*  M for carriage return */
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'J'
expr_stmt|;
comment|/*  J for linefeed */
ifdef|#
directive|ifdef
name|VMS
name|binary
operator|=
name|XYFT_T
expr_stmt|;
comment|/* We automatically detected text */
endif|#
directive|endif
comment|/* VMS */
ifdef|#
directive|ifdef
name|NOCSETS
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'*'
expr_stmt|;
comment|/* Encoding */
name|data
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Length of value is 1 */
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'A'
expr_stmt|;
comment|/* A for ASCII */
else|#
directive|else
if|if
condition|(
name|tcharset
operator|==
name|TC_TRANSP
condition|)
comment|/* Transfer character set */
name|tp
operator|=
name|NULL
expr_stmt|;
else|else
name|tp
operator|=
name|tcsinfo
index|[
name|tcharset
index|]
operator|.
name|designator
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|aln
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|tp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'*'
expr_stmt|;
comment|/* Encoding */
name|data
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
name|aln
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*  Length of charset designator. */
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'C'
expr_stmt|;
comment|/*  Text in specified character set. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|aln
condition|;
name|j
operator|++
control|)
comment|/*  Designator from tcsinfo struct */
name|data
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|tp
operator|++
expr_stmt|;
comment|/*  Example: *&I6/100 */
block|}
endif|#
directive|endif
comment|/* NOCSETS */
block|}
block|}
if|if
condition|(
operator|(
name|xp
operator|==
literal|0
operator|)
operator|&&
operator|(
name|x
operator|.
name|length
operator|>
operator|-
literal|1L
operator|)
condition|)
block|{
comment|/* If it's a real file */
if|if
condition|(
name|atdato
operator|&&
operator|(
name|aln
operator|=
name|x
operator|.
name|date
operator|.
name|len
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* Creation date, if any */
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'#'
expr_stmt|;
name|data
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
name|aln
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|aln
condition|;
name|j
operator|++
control|)
name|data
index|[
name|i
operator|++
index|]
operator|=
name|x
operator|.
name|date
operator|.
name|val
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|atleno
condition|)
block|{
name|data
index|[
name|i
index|]
operator|=
literal|'!'
expr_stmt|;
comment|/* File length in K */
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|data
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
literal|"%ld"
argument_list|,
name|x
operator|.
name|lengthk
argument_list|)
expr_stmt|;
name|aln
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|data
operator|+
name|i
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|data
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|tochar
argument_list|(
name|aln
argument_list|)
expr_stmt|;
name|i
operator|+=
name|aln
operator|+
literal|2
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
literal|'1'
expr_stmt|;
comment|/* File length in bytes */
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|data
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
literal|"%ld"
argument_list|,
name|x
operator|.
name|length
argument_list|)
expr_stmt|;
name|aln
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|data
operator|+
name|i
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|data
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|tochar
argument_list|(
name|aln
argument_list|)
expr_stmt|;
name|i
operator|+=
name|aln
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|atblko
operator|&&
name|fblksiz
condition|)
block|{
comment|/* Blocksize, if set */
name|data
index|[
name|i
index|]
operator|=
literal|'('
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|data
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
literal|"%d"
argument_list|,
name|fblksiz
argument_list|)
expr_stmt|;
name|aln
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|data
operator|+
name|i
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|data
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|tochar
argument_list|(
name|aln
argument_list|)
expr_stmt|;
name|i
operator|+=
name|aln
operator|+
literal|2
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|NOFRILLS
if|if
condition|(
operator|(
name|rprintf
operator|||
name|rmailf
operator|)
operator|&&
name|atdiso
condition|)
block|{
comment|/* MAIL, or REMOTE PRINT?  */
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'+'
expr_stmt|;
comment|/* Disposition */
name|data
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|optbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Options, if any */
if|if
condition|(
name|rprintf
condition|)
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'P'
expr_stmt|;
comment|/* P for Print */
else|else
name|data
index|[
name|i
operator|++
index|]
operator|=
literal|'M'
expr_stmt|;
comment|/* M for Mail */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|optbuf
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
comment|/* Copy any options */
name|data
index|[
name|i
operator|++
index|]
operator|=
name|optbuf
index|[
name|j
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOFRILLS */
name|data
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Make sure it's null-terminated */
name|aln
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
comment|/* Get overall length of attributes */
comment|/* Change this code to break attribute data up into multiple packets! */
name|j
operator|=
operator|(
name|spsiz
operator|<
literal|95
operator|)
condition|?
operator|(
literal|92
operator|-
name|bctl
operator|)
else|:
operator|(
name|spsiz
operator|-
literal|2
operator|-
name|bctl
operator|)
expr_stmt|;
if|if
condition|(
name|aln
operator|>
name|j
condition|)
block|{
comment|/* Check length of result */
name|spack
argument_list|(
literal|'A'
argument_list|,
name|pktnum
argument_list|,
literal|0
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|""
argument_list|)
expr_stmt|;
comment|/* send an empty attribute packet */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"sattr pkt too long"
argument_list|,
literal|""
argument_list|,
name|aln
argument_list|)
expr_stmt|;
comment|/* if too long */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"sattr spsiz"
argument_list|,
literal|""
argument_list|,
name|spsiz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise */
name|spack
argument_list|(
literal|'A'
argument_list|,
name|pktnum
argument_list|,
name|aln
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* send the real thing. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"sattr"
argument_list|,
name|data
argument_list|,
name|aln
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|refused
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reason
index|[]
init|=
block|{
literal|"size"
block|,
literal|"type"
block|,
literal|"date"
block|,
literal|"creator"
block|,
literal|"account"
block|,
literal|"area"
block|,
literal|"password"
block|,
literal|"blocksize"
block|,
literal|"access"
block|,
literal|"encoding"
block|,
literal|"disposition"
block|,
literal|"protection"
block|,
literal|"protection"
block|,
literal|"origin"
block|,
literal|"format"
block|,
literal|"sys-dependent"
block|,
literal|"size"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nreason
init|=
sizeof|sizeof
argument_list|(
name|reason
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|getreason
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Decode attribute refusal reason */
name|char
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'N'
condition|)
return|return
operator|(
literal|""
operator|)
return|;
comment|/* Should start with N */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|>
name|SP
condition|)
block|{
comment|/* get reason, */
name|c
operator|-=
literal|'!'
expr_stmt|;
comment|/* get offset */
name|p
operator|=
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|CHAR
operator|)
name|c
argument_list|)
operator|<=
name|nreason
operator|)
condition|?
name|reason
index|[
name|c
index|]
else|:
literal|"unknown"
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rsattr
parameter_list|(
name|s
parameter_list|)
name|CHAR
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Read response to attribute packet */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"rsattr: "
argument_list|,
name|s
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'N'
condition|)
block|{
comment|/* If it's 'N' followed by anything, */
name|refused
operator|=
name|getreason
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
comment|/* they are refusing, get reason. */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"refused"
argument_list|,
name|refused
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"refused"
argument_list|,
name|refused
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
name|refused
operator|=
literal|""
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gattr
parameter_list|(
name|s
parameter_list|,
name|yy
parameter_list|)
name|CHAR
modifier|*
name|s
decl_stmt|;
name|struct
name|zattr
modifier|*
name|yy
decl_stmt|;
block|{
comment|/* Read incoming attribute packet */
name|char
name|c
decl_stmt|;
name|int
name|aln
decl_stmt|,
name|i
decl_stmt|;
define|#
directive|define
name|ABUFL
value|40
comment|/* Temporary buffer for conversions */
name|char
name|abuf
index|[
name|ABUFL
index|]
decl_stmt|;
define|#
directive|define
name|FTBUFL
value|10
comment|/* File type buffer */
specifier|static
name|char
name|ftbuf
index|[
name|FTBUFL
index|]
decl_stmt|;
define|#
directive|define
name|DTBUFL
value|40
comment|/* File creation date */
specifier|static
name|char
name|dtbuf
index|[
name|DTBUFL
index|]
decl_stmt|;
define|#
directive|define
name|TSBUFL
value|10
comment|/* Transfer syntax */
specifier|static
name|char
name|tsbuf
index|[
name|TSBUFL
index|]
decl_stmt|;
define|#
directive|define
name|IDBUFL
value|10
comment|/* System ID */
specifier|static
name|char
name|idbuf
index|[
name|IDBUFL
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|DYNAMIC
define|#
directive|define
name|DSBUFL
value|100
comment|/* Disposition */
specifier|static
name|char
name|dsbuf
index|[
name|DSBUFL
index|]
decl_stmt|;
define|#
directive|define
name|SPBUFL
value|512
comment|/* System-dependent parameters */
specifier|static
name|char
name|spbuf
index|[
name|SPBUFL
index|]
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|DSBUFL
value|100
comment|/* Disposition */
specifier|static
name|char
modifier|*
name|dsbuf
init|=
name|NULL
decl_stmt|;
define|#
directive|define
name|SPBUFL
value|512
comment|/* System-dependent parameters */
specifier|static
name|char
modifier|*
name|spbuf
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* DYNAMIC */
define|#
directive|define
name|RPBUFL
value|20
comment|/* Attribute reply */
specifier|static
name|char
name|rpbuf
index|[
name|RPBUFL
index|]
decl_stmt|;
name|char
modifier|*
name|rp
decl_stmt|;
comment|/* Pointer to reply buffer */
name|int
name|retcode
decl_stmt|;
comment|/* Return code */
comment|/* fill in the attributes we have received */
name|rp
operator|=
name|rpbuf
expr_stmt|;
comment|/* Initialize reply buffer */
operator|*
name|rp
operator|++
operator|=
literal|'N'
expr_stmt|;
comment|/* for negative reply. */
name|retcode
operator|=
literal|0
expr_stmt|;
comment|/* Initialize return code. */
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
comment|/* Get attribute tag */
name|aln
operator|=
name|xunchar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
comment|/* Length of attribute string */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'!'
case|:
comment|/* File length in K */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|aln
operator|)
operator|&&
operator|(
name|i
operator|<
name|ABUFL
operator|)
condition|;
name|i
operator|++
control|)
comment|/* Copy it */
name|abuf
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|abuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate with null */
if|if
condition|(
name|i
operator|<
name|aln
condition|)
name|s
operator|+=
operator|(
name|aln
operator|-
name|i
operator|)
expr_stmt|;
comment|/* If field was too long for buffer */
name|yy
operator|->
name|lengthk
operator|=
name|atol
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
comment|/* Convert to number */
break|break;
case|case
literal|'"'
case|:
comment|/* file type */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|aln
operator|)
operator|&&
operator|(
name|i
operator|<
name|FTBUFL
operator|)
condition|;
name|i
operator|++
control|)
name|ftbuf
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* Copy it into a static string */
name|ftbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|aln
condition|)
name|s
operator|+=
operator|(
name|aln
operator|-
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|attypi
condition|)
block|{
comment|/* TYPE attribute is enabled? */
name|yy
operator|->
name|type
operator|.
name|val
operator|=
name|ftbuf
expr_stmt|;
comment|/* Pointer to string */
name|yy
operator|->
name|type
operator|.
name|len
operator|=
name|i
expr_stmt|;
comment|/* Length of string */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"gattr file type"
argument_list|,
name|tsbuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ftbuf
operator|!=
literal|'A'
operator|&&
operator|*
name|ftbuf
operator|!=
literal|'B'
comment|/* Unknown type? */
ifdef|#
directive|ifdef
name|VMS
comment|/* or (VMS) our FILE TYPE is LABELED and the incoming file is text... */
operator|||
name|binary
operator|==
name|XYFT_L
operator|&&
operator|*
name|ftbuf
operator|==
literal|'A'
endif|#
directive|endif
comment|/* VMS */
condition|)
block|{
name|discard
operator|=
literal|1
expr_stmt|;
comment|/* Reject the file */
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|rp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
comment|/*   The following code moved here from opena() so we set binary mode   as soon as requested by the attribute packet.  That way when the first   data packet comes, the mode of transfer can be displayed correctly   before opena() is called. */
if|if
condition|(
name|bsavef
condition|)
block|{
comment|/* If somehow file mode */
name|binary
operator|=
name|bsave
expr_stmt|;
comment|/* was saved but not restored, */
name|bsavef
operator|=
literal|0
expr_stmt|;
comment|/* restore it. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"gattr restoring binary"
argument_list|,
literal|""
argument_list|,
name|binary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yy
operator|->
name|type
operator|.
name|val
index|[
literal|0
index|]
operator|==
literal|'A'
condition|)
block|{
comment|/* Check received attributes. */
name|bsave
operator|=
name|binary
expr_stmt|;
comment|/* ASCII.  Save global file type */
name|bsavef
operator|=
literal|1
expr_stmt|;
comment|/* ( restore it in clsof() ) */
name|binary
operator|=
name|XYFT_T
expr_stmt|;
comment|/* Set current type to Text. */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"gattr attribute A = text"
argument_list|,
literal|""
argument_list|,
name|binary
argument_list|)
expr_stmt|;
comment|/*  */
block|}
elseif|else
if|if
condition|(
name|yy
operator|->
name|type
operator|.
name|val
index|[
literal|0
index|]
operator|==
literal|'B'
condition|)
block|{
name|bsave
operator|=
name|binary
expr_stmt|;
comment|/* Binary.  Save global file type */
name|bsavef
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|binary
operator|!=
name|XYFT_L
operator|&&
name|binary
operator|!=
name|XYFT_U
condition|)
comment|/* VMS cases */
endif|#
directive|endif
comment|/* VMS */
name|binary
operator|=
name|XYFT_B
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"gattr attribute B = binary"
argument_list|,
literal|""
argument_list|,
name|binary
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'#'
case|:
comment|/* File creation date */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|aln
operator|)
operator|&&
operator|(
name|i
operator|<
name|DTBUFL
operator|)
condition|;
name|i
operator|++
control|)
name|dtbuf
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* Copy it into a static string */
if|if
condition|(
name|i
operator|<
name|aln
condition|)
name|s
operator|+=
operator|(
name|aln
operator|-
name|i
operator|)
expr_stmt|;
name|dtbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|atdati
condition|)
block|{
name|yy
operator|->
name|date
operator|.
name|val
operator|=
name|dtbuf
expr_stmt|;
comment|/* Pointer to string */
name|yy
operator|->
name|date
operator|.
name|len
operator|=
name|i
expr_stmt|;
comment|/* Length of string */
if|if
condition|(
name|fncact
operator|==
name|XYFX_U
condition|)
block|{
comment|/* Receiving in update mode? */
if|if
condition|(
name|zstime
argument_list|(
name|filnam
argument_list|,
name|yy
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Compare dates */
name|discard
operator|=
literal|1
expr_stmt|;
comment|/* If incoming file is older, */
operator|*
name|rp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* discard it, reason = date. */
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Rejection notice. */
block|}
block|}
block|}
break|break;
case|case
literal|'('
case|:
comment|/* File Block Size */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|aln
operator|)
operator|&&
operator|(
name|i
operator|<
name|ABUFL
operator|)
condition|;
name|i
operator|++
control|)
comment|/* Copy it */
name|abuf
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|abuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate with null */
if|if
condition|(
name|i
operator|<
name|aln
condition|)
name|s
operator|+=
operator|(
name|aln
operator|-
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|atblki
condition|)
name|yy
operator|->
name|blksize
operator|=
name|atol
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
comment|/* Convert to number */
break|break;
case|case
literal|'*'
case|:
comment|/* Encoding (transfer syntax) */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|aln
operator|)
operator|&&
operator|(
name|i
operator|<
name|TSBUFL
operator|)
condition|;
name|i
operator|++
control|)
name|tsbuf
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* Copy it into a static string */
if|if
condition|(
name|i
operator|<
name|aln
condition|)
name|s
operator|+=
operator|(
name|aln
operator|-
name|i
operator|)
expr_stmt|;
name|tsbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|atenci
condition|)
block|{
name|yy
operator|->
name|encoding
operator|.
name|val
operator|=
name|tsbuf
expr_stmt|;
comment|/* Pointer to string */
name|yy
operator|->
name|encoding
operator|.
name|len
operator|=
name|i
expr_stmt|;
comment|/* Length of string */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"gattr encoding"
argument_list|,
name|tsbuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|tsbuf
condition|)
block|{
ifndef|#
directive|ifndef
name|NOCSETS
case|case
literal|'A'
case|:
comment|/* Normal (maybe extended) ASCII */
name|tcharset
operator|=
name|TC_USASCII
expr_stmt|;
comment|/* Transparent chars untranslated */
break|break;
case|case
literal|'C'
case|:
comment|/* Specified character set */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntcsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tcsinfo
index|[
name|i
index|]
operator|.
name|designator
argument_list|,
name|tsbuf
operator|+
literal|1
argument_list|)
condition|)
break|break;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"gattr xfer charset lookup"
argument_list|,
literal|""
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ntcsets
condition|)
block|{
comment|/* If unknown character set, */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"gattr: xfer charset unknown"
argument_list|,
name|tsbuf
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unkcs
condition|)
block|{
comment|/* and SET UNKNOWN DISCARD, */
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* reject the file. */
operator|*
name|rp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
name|tcharset
operator|=
name|tcsinfo
index|[
name|i
index|]
operator|.
name|code
expr_stmt|;
comment|/* if known, use it */
name|rx
operator|=
name|xlr
index|[
name|tcharset
index|]
index|[
name|fcharset
index|]
expr_stmt|;
comment|/* xlation function */
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"gattr tcharset"
argument_list|,
literal|""
argument_list|,
name|tcharset
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NOCSETS */
default|default:
comment|/* Something else. */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"gattr unk encoding attribute"
argument_list|,
name|tsbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unkcs
condition|)
block|{
comment|/* If SET UNK DISC */
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* reject the file */
operator|*
name|rp
operator|++
operator|=
name|c
expr_stmt|;
block|}
break|break;
block|}
block|}
break|break;
case|case
literal|'+'
case|:
comment|/* disposition */
ifdef|#
directive|ifdef
name|DYNAMIC
if|if
condition|(
operator|!
name|dsbuf
condition|)
if|if
condition|(
operator|(
name|dsbuf
operator|=
name|malloc
argument_list|(
name|DSBUFL
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"gtattr: no memory for dsbuf"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DYNAMIC */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|aln
operator|)
operator|&&
operator|(
name|i
operator|<
name|DSBUFL
operator|)
condition|;
name|i
operator|++
control|)
name|dsbuf
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* Copy it into a static string */
name|dsbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|aln
condition|)
name|s
operator|+=
operator|(
name|aln
operator|-
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|atdisi
condition|)
block|{
name|yy
operator|->
name|disp
operator|.
name|val
operator|=
name|dsbuf
expr_stmt|;
comment|/* Pointer to string */
name|yy
operator|->
name|disp
operator|.
name|len
operator|=
name|i
expr_stmt|;
comment|/* Length of string */
if|if
condition|(
ifndef|#
directive|ifndef
name|datageneral
comment|/* MAIL supported only for */
ifndef|#
directive|ifndef
name|OS2
comment|/* UNIX, VMS, and OS-9 */
ifndef|#
directive|ifndef
name|MAC
ifndef|#
directive|ifndef
name|GEMDOS
ifndef|#
directive|ifndef
name|AMIGA
operator|*
name|dsbuf
operator|!=
literal|'M'
operator|&&
endif|#
directive|endif
comment|/* AMIGA */
endif|#
directive|endif
comment|/* GEMDOS */
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* OS/2 */
endif|#
directive|endif
comment|/* datageneral */
operator|*
name|dsbuf
operator|!=
literal|'P'
condition|)
block|{
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|rp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'.'
case|:
comment|/* Sender's system ID */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|aln
operator|)
operator|&&
operator|(
name|i
operator|<
name|IDBUFL
operator|)
condition|;
name|i
operator|++
control|)
name|idbuf
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* Copy it into a static string */
name|idbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|aln
condition|)
name|s
operator|+=
operator|(
name|aln
operator|-
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|atsidi
condition|)
block|{
name|yy
operator|->
name|systemid
operator|.
name|val
operator|=
name|idbuf
expr_stmt|;
comment|/* Pointer to string */
name|yy
operator|->
name|systemid
operator|.
name|len
operator|=
name|i
expr_stmt|;
comment|/* Length of string */
block|}
break|break;
case|case
literal|'0'
case|:
comment|/* System-dependent parameters */
ifdef|#
directive|ifdef
name|DYNAMIC
if|if
condition|(
operator|!
name|spbuf
operator|&&
operator|!
operator|(
name|spbuf
operator|=
name|malloc
argument_list|(
name|SPBUFL
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"gattr: no memory for spbuf"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DYNAMIC */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|aln
operator|)
operator|&&
operator|(
name|i
operator|<
name|SPBUFL
operator|)
condition|;
name|i
operator|++
control|)
name|spbuf
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* Copy it into a static string */
name|spbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|aln
condition|)
name|s
operator|+=
operator|(
name|aln
operator|-
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|atsysi
condition|)
block|{
name|yy
operator|->
name|sysparam
operator|.
name|val
operator|=
name|spbuf
expr_stmt|;
comment|/* Pointer to string */
name|yy
operator|->
name|sysparam
operator|.
name|len
operator|=
name|i
expr_stmt|;
comment|/* Length of string */
block|}
break|break;
case|case
literal|'1'
case|:
comment|/* File length in bytes */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|aln
operator|)
operator|&&
operator|(
name|i
operator|<
name|ABUFL
operator|)
condition|;
name|i
operator|++
control|)
comment|/* Copy it */
name|abuf
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|abuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate with null */
if|if
condition|(
name|i
operator|<
name|aln
condition|)
name|s
operator|+=
operator|(
name|aln
operator|-
name|i
operator|)
expr_stmt|;
name|yy
operator|->
name|length
operator|=
name|atol
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
comment|/* Convert to number */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"gattr length"
argument_list|,
name|abuf
argument_list|,
operator|(
name|int
operator|)
name|yy
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Unknown attribute */
name|s
operator|+=
name|aln
expr_stmt|;
comment|/* Just skip past it */
break|break;
block|}
block|}
comment|/* Check file length now, because we also need to know the file type */
comment|/* in case zchkspa() differentiates text and binary (VMS version does) */
if|if
condition|(
name|atleni
condition|)
block|{
comment|/* Length attribute enabled? */
if|if
condition|(
name|yy
operator|->
name|length
operator|>
operator|-
literal|1L
condition|)
block|{
comment|/* Length-in-bytes attribute rec'd? */
if|if
condition|(
operator|!
name|zchkspa
argument_list|(
name|filnam
argument_list|,
operator|(
name|yy
operator|->
name|length
operator|)
argument_list|)
condition|)
block|{
comment|/* Check space */
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|rp
operator|++
operator|=
literal|'1'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|yy
operator|->
name|lengthk
operator|>
operator|-
literal|1L
condition|)
block|{
comment|/* Length in K attribute rec'd? */
if|if
condition|(
operator|!
name|zchkspa
argument_list|(
name|filnam
argument_list|,
operator|(
name|yy
operator|->
name|lengthk
operator|*
literal|1024
operator|)
argument_list|)
condition|)
block|{
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Check space */
operator|*
name|rp
operator|++
operator|=
literal|'!'
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|yy
operator|->
name|length
operator|>
operator|-
literal|1L
condition|)
block|{
comment|/* Get the file size */
name|fsize
operator|=
name|yy
operator|->
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yy
operator|->
name|lengthk
operator|>
operator|-
literal|1L
condition|)
block|{
name|fsize
operator|=
name|yy
operator|->
name|lengthk
operator|*
literal|1024L
expr_stmt|;
block|}
else|else
name|fsize
operator|=
operator|-
literal|1L
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|deblog
condition|)
block|{
name|sprintf
argument_list|(
name|abuf
argument_list|,
literal|"%ld"
argument_list|,
name|fsize
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"gattr fsize"
argument_list|,
name|abuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|retcode
operator|==
literal|0
condition|)
name|rp
operator|=
name|rpbuf
expr_stmt|;
comment|/* Null reply string if accepted */
operator|*
name|rp
operator|=
literal|'\0'
expr_stmt|;
comment|/* End of reply string */
name|yy
operator|->
name|reply
operator|.
name|val
operator|=
name|rpbuf
expr_stmt|;
comment|/* Add it to attribute structure */
name|yy
operator|->
name|reply
operator|.
name|len
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|rpbuf
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"gattr return"
argument_list|,
name|rpbuf
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  I N I T A T T R  --  Initialize file attribute structure  */
end_comment

begin_function
name|int
name|initattr
parameter_list|(
name|yy
parameter_list|)
name|struct
name|zattr
modifier|*
name|yy
decl_stmt|;
block|{
name|yy
operator|->
name|lengthk
operator|=
name|yy
operator|->
name|length
operator|=
operator|-
literal|1L
expr_stmt|;
name|yy
operator|->
name|type
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|type
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|date
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|date
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|encoding
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|encoding
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|disp
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|disp
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|systemid
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|systemid
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|sysparam
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|sysparam
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|creator
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|creator
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|account
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|account
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|area
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|area
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|passwd
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|passwd
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|blksize
operator|=
operator|-
literal|1L
expr_stmt|;
name|yy
operator|->
name|access
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|access
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|lprotect
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|lprotect
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|gprotect
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|gprotect
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|recfm
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|recfm
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|yy
operator|->
name|reply
operator|.
name|val
operator|=
literal|""
expr_stmt|;
name|yy
operator|->
name|reply
operator|.
name|len
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  A D E B U -- Write attribute packet info to debug log  */
end_comment

begin_function
name|int
name|adebu
parameter_list|(
name|f
parameter_list|,
name|zz
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|struct
name|zattr
modifier|*
name|zz
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|deblog
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"Attributes for incoming file "
argument_list|,
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" length in K"
argument_list|,
literal|""
argument_list|,
operator|(
name|int
operator|)
name|zz
operator|->
name|lengthk
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" file type"
argument_list|,
name|zz
operator|->
name|type
operator|.
name|val
argument_list|,
name|zz
operator|->
name|type
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" creation date"
argument_list|,
name|zz
operator|->
name|date
operator|.
name|val
argument_list|,
name|zz
operator|->
name|date
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" creator"
argument_list|,
name|zz
operator|->
name|creator
operator|.
name|val
argument_list|,
name|zz
operator|->
name|creator
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" account"
argument_list|,
name|zz
operator|->
name|account
operator|.
name|val
argument_list|,
name|zz
operator|->
name|account
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" area"
argument_list|,
name|zz
operator|->
name|area
operator|.
name|val
argument_list|,
name|zz
operator|->
name|area
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" password"
argument_list|,
name|zz
operator|->
name|passwd
operator|.
name|val
argument_list|,
name|zz
operator|->
name|passwd
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" blksize"
argument_list|,
literal|""
argument_list|,
operator|(
name|int
operator|)
name|zz
operator|->
name|blksize
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" access"
argument_list|,
name|zz
operator|->
name|access
operator|.
name|val
argument_list|,
name|zz
operator|->
name|access
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" encoding"
argument_list|,
name|zz
operator|->
name|encoding
operator|.
name|val
argument_list|,
name|zz
operator|->
name|encoding
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" disposition"
argument_list|,
name|zz
operator|->
name|disp
operator|.
name|val
argument_list|,
name|zz
operator|->
name|disp
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" lprotection"
argument_list|,
name|zz
operator|->
name|lprotect
operator|.
name|val
argument_list|,
name|zz
operator|->
name|lprotect
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" gprotection"
argument_list|,
name|zz
operator|->
name|gprotect
operator|.
name|val
argument_list|,
name|zz
operator|->
name|gprotect
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" systemid"
argument_list|,
name|zz
operator|->
name|systemid
operator|.
name|val
argument_list|,
name|zz
operator|->
name|systemid
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" recfm"
argument_list|,
name|zz
operator|->
name|recfm
operator|.
name|val
argument_list|,
name|zz
operator|->
name|recfm
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" sysparam"
argument_list|,
name|zz
operator|->
name|sysparam
operator|.
name|val
argument_list|,
name|zz
operator|->
name|sysparam
operator|.
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" length"
argument_list|,
literal|""
argument_list|,
operator|(
name|int
operator|)
name|zz
operator|->
name|length
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|" reply"
argument_list|,
name|zz
operator|->
name|reply
operator|.
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  O P E N A -- Open a file, with attributes.  */
end_comment

begin_comment
comment|/*   This function tries to open a new file to put the arriving data in.  The   filename is the one in the srvcmd buffer.  File collision actions are:   OVERWRITE (the existing file is overwritten), RENAME (the new file is   renamed), BACKUP (the existing file is renamed), DISCARD (the new file is   refused), UPDATE (the incoming file replaces the existing file only if the   incoming file has a newer creation date).    Returns 0 on failure, nonzero on success. */
end_comment

begin_function
name|int
name|opena
parameter_list|(
name|f
parameter_list|,
name|zz
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|struct
name|zattr
modifier|*
name|zz
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
specifier|static
name|struct
name|filinfo
name|fcb
decl_stmt|;
comment|/* Must be static! */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"opena discard"
argument_list|,
name|f
argument_list|,
name|discard
argument_list|)
expr_stmt|;
name|adebu
argument_list|(
name|f
argument_list|,
name|zz
argument_list|)
expr_stmt|;
comment|/* Write attributes to debug log */
name|ffc
operator|=
literal|0L
expr_stmt|;
comment|/* Init file character counter */
ifdef|#
directive|ifdef
name|COMMENT
comment|/*   This code moved to sattr(). */
if|if
condition|(
name|bsavef
condition|)
block|{
comment|/* If somehow file mode */
name|binary
operator|=
name|bsave
expr_stmt|;
comment|/* was saved but not restored, */
name|bsavef
operator|=
literal|0
expr_stmt|;
comment|/* restore it. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"opena restoring binary"
argument_list|,
literal|""
argument_list|,
name|binary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zz
operator|->
name|type
operator|.
name|val
index|[
literal|0
index|]
operator|==
literal|'A'
condition|)
block|{
comment|/* Check received attributes */
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|binary
operator|==
name|XYFT_L
condition|)
comment|/* Refuse to receive a file in */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* labeled mode if sent as text. */
endif|#
directive|endif
comment|/* VMS */
name|bsave
operator|=
name|binary
expr_stmt|;
comment|/* ASCII.  Save global file type */
name|bsavef
operator|=
literal|1
expr_stmt|;
comment|/* ( restore it in clsof() ) */
name|binary
operator|=
name|XYFT_T
expr_stmt|;
comment|/* Set current type to Text. */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"opena attribute A = text"
argument_list|,
literal|""
argument_list|,
name|binary
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zz
operator|->
name|type
operator|.
name|val
index|[
literal|0
index|]
operator|==
literal|'B'
condition|)
block|{
name|bsave
operator|=
name|binary
expr_stmt|;
comment|/* Binary.  Save global file type */
name|bsavef
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|binary
operator|!=
name|XYFT_L
operator|&&
name|binary
operator|!=
name|XYFT_U
condition|)
comment|/* Special VMS cases */
endif|#
directive|endif
comment|/* VMS */
name|binary
operator|=
name|XYFT_B
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"opena attribute B = binary"
argument_list|,
literal|""
argument_list|,
name|binary
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* COMMENT */
comment|/* Set up file control structure */
name|fcb
operator|.
name|bs
operator|=
name|fblksiz
expr_stmt|;
comment|/* Blocksize */
ifndef|#
directive|ifndef
name|NOCSETS
name|fcb
operator|.
name|cs
operator|=
name|fcharset
expr_stmt|;
comment|/* Character set */
else|#
directive|else
name|fcb
operator|.
name|cs
operator|=
literal|0
expr_stmt|;
comment|/* Character set */
endif|#
directive|endif
comment|/* NOCSETS */
name|fcb
operator|.
name|rl
operator|=
name|frecl
expr_stmt|;
comment|/* Record Length */
name|fcb
operator|.
name|fmt
operator|=
name|frecfm
expr_stmt|;
comment|/* Record Format */
name|fcb
operator|.
name|org
operator|=
name|forg
expr_stmt|;
comment|/* Organization */
name|fcb
operator|.
name|cc
operator|=
name|fcctrl
expr_stmt|;
comment|/* Carriage control */
name|fcb
operator|.
name|typ
operator|=
name|binary
expr_stmt|;
comment|/* Type */
name|fcb
operator|.
name|dsp
operator|=
operator|(
name|fncact
operator|==
name|XYFX_A
operator|)
condition|?
name|XYFZ_A
else|:
name|XYFZ_N
expr_stmt|;
comment|/* Disposition */
name|fcb
operator|.
name|os_specific
operator|=
literal|'\0'
expr_stmt|;
comment|/* OS specific info */
ifdef|#
directive|ifdef
name|VMS
name|fcb
operator|.
name|lblopts
operator|=
name|lf_opts
expr_stmt|;
comment|/* VMS Labeled file options */
else|#
directive|else
name|fcb
operator|.
name|lblopts
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
name|x
operator|=
name|openo
argument_list|(
name|f
argument_list|,
name|zz
argument_list|,
operator|&
name|fcb
argument_list|)
condition|)
block|{
comment|/* Try to open the file. */
name|tlog
argument_list|(
name|F110
argument_list|,
literal|" as"
argument_list|,
name|f
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
comment|/* OK, open, record name. */
if|if
condition|(
name|binary
condition|)
block|{
comment|/* Log file mode in transaction log */
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" mode: binary"
argument_list|,
literal|""
argument_list|,
operator|(
name|long
operator|)
name|binary
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If text mode, check character set */
name|tlog
argument_list|(
name|F100
argument_list|,
literal|" mode: text"
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOCSETS
name|tlog
argument_list|(
name|F110
argument_list|,
literal|" file character set"
argument_list|,
name|fcsinfo
index|[
name|fcharset
index|]
operator|.
name|name
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcharset
operator|==
name|TC_TRANSP
condition|)
name|tlog
argument_list|(
name|F110
argument_list|,
literal|" xfer character set"
argument_list|,
literal|"transparent"
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
else|else
name|tlog
argument_list|(
name|F110
argument_list|,
literal|" xfer character set"
argument_list|,
name|tcsinfo
index|[
name|tcharset
index|]
operator|.
name|name
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOCSETS */
name|debug
argument_list|(
name|F111
argument_list|,
literal|" opena charset"
argument_list|,
name|zz
operator|->
name|encoding
operator|.
name|val
argument_list|,
name|zz
operator|->
name|encoding
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fsize
operator|>
operator|-
literal|1L
condition|)
name|screen
argument_list|(
name|SCR_FS
argument_list|,
literal|0
argument_list|,
name|fsize
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|datageneral
comment|/* Need to turn on multi-tasking console interrupt task here, since multiple */
comment|/* files may be received. */
if|if
condition|(
operator|(
name|local
operator|)
operator|&&
operator|(
operator|!
name|quiet
operator|)
condition|)
comment|/* Only do this if local& not quiet */
name|consta_mt
argument_list|()
expr_stmt|;
comment|/* Start the asynch read task */
endif|#
directive|endif
comment|/* datageneral */
block|}
else|else
block|{
comment|/* Did not open file OK. */
ifdef|#
directive|ifdef
name|ATTSV
specifier|extern
name|int
name|errno
decl_stmt|;
name|screen
argument_list|(
name|SCR_EM
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD4
specifier|extern
name|int
name|errno
decl_stmt|;
name|screen
argument_list|(
name|SCR_EM
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|screen
argument_list|(
name|SCR_EM
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"Can't open output file"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD4 */
endif|#
directive|endif
comment|/* ATTSV */
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"Failure to open"
argument_list|,
name|f
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
comment|/* Pass on return code from openo */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  C A N N E D  --  Check if current file transfer cancelled */
end_comment

begin_function
name|int
name|canned
parameter_list|(
name|buf
parameter_list|)
name|CHAR
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'X'
condition|)
name|cxseen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'Z'
condition|)
name|czseen
operator|=
literal|1
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"canned: cxseen"
argument_list|,
literal|""
argument_list|,
name|cxseen
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" czseen"
argument_list|,
literal|""
argument_list|,
name|czseen
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|czseen
operator|||
name|cxseen
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  O P E N I  --  Open an existing file for input  */
end_comment

begin_function
name|int
name|openi
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|filno
decl_stmt|;
name|char
modifier|*
name|name2
decl_stmt|;
if|if
condition|(
name|memstr
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Just return if file is memory. */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"openi"
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" sndsrc"
argument_list|,
literal|""
argument_list|,
name|sndsrc
argument_list|)
expr_stmt|;
name|filno
operator|=
operator|(
name|sndsrc
operator|==
literal|0
operator|)
condition|?
name|ZSTDIO
else|:
name|ZIFILE
expr_stmt|;
comment|/* ... */
name|debug
argument_list|(
name|F101
argument_list|,
literal|" file number"
argument_list|,
literal|""
argument_list|,
name|filno
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|&&
operator|!
name|en_cwd
condition|)
block|{
comment|/* If running as server */
name|zstrip
argument_list|(
name|name
argument_list|,
operator|&
name|name2
argument_list|)
expr_stmt|;
comment|/* and CWD is disabled... */
if|if
condition|(
comment|/* check if pathname was included. */
ifdef|#
directive|ifdef
name|VMS
name|zchkpath
argument_list|(
argument|name
argument_list|)
else|#
directive|else
name|strcmp
argument_list|(
name|name
argument_list|,
name|name2
argument_list|)
endif|#
directive|endif
comment|/* VMS */
condition|)
block|{
name|tlog
argument_list|(
name|F110
argument_list|,
name|name
argument_list|,
literal|"authorization failure"
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|" openi authorization failure"
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|name
operator|=
name|name2
expr_stmt|;
block|}
if|if
condition|(
name|zopeni
argument_list|(
name|filno
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|/* Otherwise, try to open it. */
name|debug
argument_list|(
name|F110
argument_list|,
literal|" ok"
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* If not found, */
name|char
name|xname
index|[
literal|100
index|]
decl_stmt|;
comment|/* convert the name */
name|zrtol
argument_list|(
name|name
argument_list|,
name|xname
argument_list|)
expr_stmt|;
comment|/* to local form and then */
name|x
operator|=
name|zopeni
argument_list|(
name|filno
argument_list|,
name|xname
argument_list|)
expr_stmt|;
comment|/* try opening it again. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|" zopeni"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|debug
argument_list|(
name|F110
argument_list|,
literal|" ok"
argument_list|,
name|xname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* It worked. */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|COMMENT
name|screen
argument_list|(
name|SCR_EM
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"Can't open file"
argument_list|)
expr_stmt|;
comment|/* It didn't work. */
endif|#
directive|endif
comment|/* COMMENT */
name|tlog
argument_list|(
name|F110
argument_list|,
name|xname
argument_list|,
literal|"could not be opened"
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|" openi failed"
argument_list|,
name|xname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  O P E N O  --  Open a new file for output.  */
end_comment

begin_function
name|int
name|openo
parameter_list|(
name|name
parameter_list|,
name|zz
parameter_list|,
name|fcb
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|zattr
modifier|*
name|zz
decl_stmt|;
name|struct
name|filinfo
modifier|*
name|fcb
decl_stmt|;
block|{
name|char
modifier|*
name|name2
decl_stmt|;
if|if
condition|(
name|stdouf
condition|)
comment|/* Receiving to stdout? */
return|return
operator|(
name|zopeno
argument_list|(
name|ZSTDIO
argument_list|,
literal|""
argument_list|,
name|zz
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"openo: name"
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxseen
operator|||
name|czseen
operator|||
name|discard
condition|)
block|{
comment|/* If interrupted, get out before */
name|debug
argument_list|(
name|F100
argument_list|,
literal|" open cancelled"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* destroying existing file. */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Pretend to succeed. */
block|}
if|if
condition|(
name|server
operator|&&
operator|!
name|en_cwd
condition|)
block|{
comment|/* If running as server */
name|zstrip
argument_list|(
name|name
argument_list|,
operator|&
name|name2
argument_list|)
expr_stmt|;
comment|/* and CWD is disabled, */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|name2
argument_list|)
condition|)
block|{
comment|/* check if pathname was included. */
name|tlog
argument_list|(
name|F110
argument_list|,
name|name
argument_list|,
literal|"authorization failure"
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|" openo authorization failure"
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|name
operator|=
name|name2
expr_stmt|;
block|}
if|if
condition|(
name|zopeno
argument_list|(
name|ZOFILE
argument_list|,
name|name
argument_list|,
name|zz
argument_list|,
name|fcb
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Try to open the file */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"openo failed"
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"Failure to open"
argument_list|,
name|name
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|debug
argument_list|(
name|F110
argument_list|,
literal|"openo ok, name"
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  O P E N T  --  Open the terminal for output, in place of a file  */
end_comment

begin_function
name|int
name|opent
parameter_list|(
name|zz
parameter_list|)
name|struct
name|zattr
modifier|*
name|zz
decl_stmt|;
block|{
name|ffc
operator|=
name|tfc
operator|=
literal|0L
expr_stmt|;
if|if
condition|(
name|bsavef
condition|)
block|{
comment|/* If somehow file mode */
name|binary
operator|=
name|bsave
expr_stmt|;
comment|/* was saved but not restored, */
name|bsavef
operator|=
literal|0
expr_stmt|;
comment|/* restore it. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"opena restoring binary"
argument_list|,
literal|""
argument_list|,
name|binary
argument_list|)
expr_stmt|;
block|}
name|bsave
operator|=
name|binary
expr_stmt|;
name|bsavef
operator|=
literal|1
expr_stmt|;
name|binary
operator|=
name|XYFT_T
expr_stmt|;
return|return
operator|(
name|zopeno
argument_list|(
name|ZCTERM
argument_list|,
literal|""
argument_list|,
name|zz
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  C L S I F  --  Close the current input file. */
end_comment

begin_function
name|int
name|clsif
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|datageneral
if|if
condition|(
operator|(
name|local
operator|)
operator|&&
operator|(
operator|!
name|quiet
operator|)
condition|)
comment|/* Only do this if local& not quiet */
if|if
condition|(
name|nfils
operator|<
literal|1
condition|)
comment|/* More files to send ... leave it on! */
name|connoi_mt
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* datageneral */
if|if
condition|(
name|memstr
condition|)
block|{
comment|/* If input was memory string, */
name|memstr
operator|=
literal|0
expr_stmt|;
comment|/* indicate no more. */
block|}
else|else
name|x
operator|=
name|zclose
argument_list|(
name|ZIFILE
argument_list|)
expr_stmt|;
comment|/* else close input file. */
if|if
condition|(
name|cxseen
operator|||
name|czseen
condition|)
comment|/* If interrupted */
name|screen
argument_list|(
name|SCR_ST
argument_list|,
name|ST_INT
argument_list|,
literal|0l
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* say so */
elseif|else
if|if
condition|(
name|discard
condition|)
comment|/* If I'm refusing */
name|screen
argument_list|(
name|SCR_ST
argument_list|,
name|ST_REFU
argument_list|,
literal|0l
argument_list|,
name|refused
argument_list|)
expr_stmt|;
comment|/* say why */
else|else
block|{
comment|/* Otherwise */
name|fstats
argument_list|()
expr_stmt|;
comment|/* update statistics */
name|screen
argument_list|(
name|SCR_ST
argument_list|,
name|ST_OK
argument_list|,
literal|0l
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* and say transfer was OK */
block|}
name|hcflg
operator|=
literal|0
expr_stmt|;
comment|/* Reset flags */
operator|*
name|filnam
operator|=
literal|'\0'
expr_stmt|;
comment|/* and current file name */
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  C L S O F  --  Close an output file.  */
end_comment

begin_comment
comment|/*  Call with disp != 0 if file is to be discarded.  */
end_comment

begin_comment
comment|/*  Returns -1 upon failure to close, 0 or greater on success. */
end_comment

begin_function
name|int
name|clsof
parameter_list|(
name|disp
parameter_list|)
name|int
name|disp
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"clsof disp"
argument_list|,
literal|""
argument_list|,
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsavef
condition|)
block|{
comment|/* If we saved global file type */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"clsof restoring binary"
argument_list|,
literal|""
argument_list|,
name|binary
argument_list|)
expr_stmt|;
name|binary
operator|=
name|bsave
expr_stmt|;
comment|/* restore it */
name|bsavef
operator|=
literal|0
expr_stmt|;
comment|/* only this once. */
block|}
ifdef|#
directive|ifdef
name|datageneral
if|if
condition|(
operator|(
name|local
operator|)
operator|&&
operator|(
operator|!
name|quiet
operator|)
condition|)
comment|/* Only do this if local& not quiet */
name|connoi_mt
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* datageneral */
name|cxseen
operator|=
literal|0
expr_stmt|;
comment|/* Reset per-file interruption flag */
if|if
condition|(
operator|(
name|x
operator|=
name|zclose
argument_list|(
name|ZOFILE
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* Try to close the file */
name|tlog
argument_list|(
name|F100
argument_list|,
literal|"Failure to close"
argument_list|,
name|filnam
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_ST
argument_list|,
name|ST_ERR
argument_list|,
literal|0l
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|disp
condition|)
block|{
comment|/* Interrupted or refused */
if|if
condition|(
name|keep
operator|==
literal|0
condition|)
block|{
comment|/* If not keep incomplete files */
if|if
condition|(
operator|*
name|filnam
condition|)
name|zdelet
argument_list|(
name|filnam
argument_list|)
expr_stmt|;
comment|/* Delete it */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"Discarded"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F100
argument_list|,
literal|"Discarded"
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_ST
argument_list|,
name|ST_DISC
argument_list|,
literal|0l
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep incomplete copy */
if|if
condition|(
name|ffc
condition|)
name|ffc
operator|++
expr_stmt|;
comment|/* This is off by one (why?) */
name|fstats
argument_list|()
expr_stmt|;
name|debug
argument_list|(
name|F100
argument_list|,
literal|"Incomplete"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F100
argument_list|,
literal|"Incomplete"
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_ST
argument_list|,
name|ST_INC
argument_list|,
literal|0l
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Nothing wrong, just keep it */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"Closed"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* and give comforting messages. */
if|if
condition|(
name|ffc
condition|)
name|ffc
operator|++
expr_stmt|;
comment|/* Correct off-by-1 error */
name|fstats
argument_list|()
expr_stmt|;
name|screen
argument_list|(
name|SCR_ST
argument_list|,
name|ST_OK
argument_list|,
literal|0l
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
comment|/* Send back zclose() return code. */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS4S5
end_ifdef

begin_macro
name|tolower
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
name|c
operator|)
operator|-
literal|'A'
operator|+
literal|'a'
operator|)
return|;
block|}
end_block

begin_macro
name|toupper
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
name|c
operator|)
operator|-
literal|'a'
operator|+
literal|'A'
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUNOS4S5 */
end_comment

end_unit

