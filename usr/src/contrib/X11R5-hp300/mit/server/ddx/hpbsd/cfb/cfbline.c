begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* $XConsortium: cfbline.c,v 1.19 91/08/13 18:48:42 keith Exp $ */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"mistruct.h"
end_include

begin_include
include|#
directive|include
file|"cfb.h"
end_include

begin_include
include|#
directive|include
file|"cfbmskbits.h"
end_include

begin_comment
comment|/* single-pixel lines on a color frame buffer     NON-SLOPED LINES    horizontal lines are always drawn left to right; we have to move the endpoints right by one after they're swapped.    horizontal lines will be confined to a single band of a region.  the code finds that band (giving up if the lower bound of the band is above the line we're drawing); then it finds the first box in that band that contains part of the line.  we clip the line to subsequent boxes in that band.    vertical lines are always drawn top to bottom (y-increasing.) this requires adding one to the y-coordinate of each endpoint after swapping.     SLOPED LINES    when clipping a sloped line, we bring the second point inside the clipping box, rather than one beyond it, and then add 1 to the length of the line before drawing it.  this lets us use the same box for finding the outcodes for both endpoints.  since the equation for clipping the second endpoint to an edge gives us 1 beyond the edge, we then have to move the point towards the first point by one step on the major axis.    eventually, there will be a diagram here to explain what's going on.  the method uses Cohen-Sutherland outcodes to determine outsideness, and a method similar to Pike's layers for doing the actual clipping.  */
end_comment

begin_define
define|#
directive|define
name|OUTCODES
parameter_list|(
name|result
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|pbox
parameter_list|)
define|\
value|if (x< pbox->x1) \ 	result |= OUT_LEFT; \     else if (x>= pbox->x2) \ 	result |= OUT_RIGHT; \     if (y< pbox->y1) \ 	result |= OUT_ABOVE; \     else if (y>= pbox->y2) \ 	result |= OUT_BELOW;
end_define

begin_comment
comment|/* #define SignTimes(sign, n) ((sign) * ((int)(n))) */
end_comment

begin_define
define|#
directive|define
name|SignTimes
parameter_list|(
name|sign
parameter_list|,
name|n
parameter_list|)
define|\
value|( ((sign)<0) ? -(n) : (n) )
end_define

begin_define
define|#
directive|define
name|SWAPINT
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
define|\
value|{  register int _t = i; \    i = j; \    j = _t; \ }
end_define

begin_define
define|#
directive|define
name|SWAPPT
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
define|\
value|{  register DDXPointRec _t; \    _t = i; \    i = j; \    j = _t; \ }
end_define

begin_function
name|void
ifdef|#
directive|ifdef
name|POLYSEGMENT
name|cfbSegmentSS
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nseg
parameter_list|,
name|pSeg
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nseg
decl_stmt|;
specifier|register
name|xSegment
modifier|*
name|pSeg
decl_stmt|;
else|#
directive|else
function|cfbLineSS
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|mode
parameter_list|,
name|npt
parameter_list|,
name|pptInit
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* Origin or Previous */
name|int
name|npt
decl_stmt|;
comment|/* number of points */
name|DDXPointPtr
name|pptInit
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|nboxInit
decl_stmt|;
specifier|register
name|int
name|nbox
decl_stmt|;
name|BoxPtr
name|pboxInit
decl_stmt|;
specifier|register
name|BoxPtr
name|pbox
decl_stmt|;
ifndef|#
directive|ifndef
name|POLYSEGMENT
specifier|register
name|DDXPointPtr
name|ppt
decl_stmt|;
comment|/* pointer to list of translated points */
endif|#
directive|endif
name|unsigned
name|int
name|oc1
decl_stmt|;
comment|/* outcode of point 1 */
name|unsigned
name|int
name|oc2
decl_stmt|;
comment|/* outcode of point 2 */
name|unsigned
name|long
modifier|*
name|addrl
decl_stmt|;
comment|/* address of destination pixmap */
name|int
name|nlwidth
decl_stmt|;
comment|/* width in longwords of destination pixmap */
name|int
name|xorg
decl_stmt|,
name|yorg
decl_stmt|;
comment|/* origin of window */
name|int
name|adx
decl_stmt|;
comment|/* abs values of dx and dy */
name|int
name|ady
decl_stmt|;
name|int
name|signdx
decl_stmt|;
comment|/* sign of dx and dy */
name|int
name|signdy
decl_stmt|;
name|int
name|e
decl_stmt|,
name|e1
decl_stmt|,
name|e2
decl_stmt|;
comment|/* bresenham error and increments */
name|int
name|len
decl_stmt|;
comment|/* length of segment */
name|int
name|axis
decl_stmt|;
comment|/* major axis */
comment|/* a bunch of temporaries */
name|int
name|tmp
decl_stmt|;
specifier|register
name|int
name|y1
decl_stmt|,
name|y2
decl_stmt|;
specifier|register
name|int
name|x1
decl_stmt|,
name|x2
decl_stmt|;
name|RegionPtr
name|cclip
decl_stmt|;
name|cfbPrivGCPtr
name|devPriv
decl_stmt|;
name|unsigned
name|long
name|xor
decl_stmt|,
name|and
decl_stmt|;
name|int
name|alu
decl_stmt|;
name|devPriv
operator|=
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
expr_stmt|;
name|cclip
operator|=
name|devPriv
operator|->
name|pCompositeClip
expr_stmt|;
name|pboxInit
operator|=
name|REGION_RECTS
argument_list|(
name|cclip
argument_list|)
expr_stmt|;
name|nboxInit
operator|=
name|REGION_NUM_RECTS
argument_list|(
name|cclip
argument_list|)
expr_stmt|;
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|nlwidth
argument_list|,
argument|addrl
argument_list|)
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|alu
operator|=
name|devPriv
operator|->
name|rop
expr_stmt|;
name|xor
operator|=
name|devPriv
operator|->
name|xor
expr_stmt|;
name|and
operator|=
name|devPriv
operator|->
name|and
expr_stmt|;
name|xorg
operator|=
name|pDrawable
operator|->
name|x
expr_stmt|;
name|yorg
operator|=
name|pDrawable
operator|->
name|y
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
while|while
condition|(
name|nseg
operator|--
condition|)
else|#
directive|else
name|ppt
operator|=
name|pptInit
expr_stmt|;
name|x2
operator|=
name|ppt
operator|->
name|x
operator|+
name|xorg
expr_stmt|;
name|y2
operator|=
name|ppt
operator|->
name|y
operator|+
name|yorg
expr_stmt|;
while|while
condition|(
operator|--
name|npt
condition|)
endif|#
directive|endif
block|{
name|nbox
operator|=
name|nboxInit
expr_stmt|;
name|pbox
operator|=
name|pboxInit
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
name|x1
operator|=
name|pSeg
operator|->
name|x1
operator|+
name|xorg
expr_stmt|;
name|y1
operator|=
name|pSeg
operator|->
name|y1
operator|+
name|yorg
expr_stmt|;
name|x2
operator|=
name|pSeg
operator|->
name|x2
operator|+
name|xorg
expr_stmt|;
name|y2
operator|=
name|pSeg
operator|->
name|y2
operator|+
name|yorg
expr_stmt|;
name|pSeg
operator|++
expr_stmt|;
else|#
directive|else
name|x1
operator|=
name|x2
expr_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
operator|++
name|ppt
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CoordModePrevious
condition|)
block|{
name|xorg
operator|=
name|x1
expr_stmt|;
name|yorg
operator|=
name|y1
expr_stmt|;
block|}
name|x2
operator|=
name|ppt
operator|->
name|x
operator|+
name|xorg
expr_stmt|;
name|y2
operator|=
name|ppt
operator|->
name|y
operator|+
name|yorg
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|x1
operator|==
name|x2
condition|)
block|{
comment|/* make the line go top to bottom of screen, keeping 	       endpoint semantics 	    */
if|if
condition|(
name|y1
operator|>
name|y2
condition|)
block|{
specifier|register
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|y2
expr_stmt|;
name|y2
operator|=
name|y1
operator|+
literal|1
expr_stmt|;
name|y1
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|y1
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|POLYSEGMENT
elseif|else
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|y2
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* get to first band that might contain part of line */
while|while
condition|(
operator|(
name|nbox
operator|)
operator|&&
operator|(
name|pbox
operator|->
name|y2
operator|<=
name|y1
operator|)
condition|)
block|{
name|pbox
operator|++
expr_stmt|;
name|nbox
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nbox
condition|)
block|{
comment|/* stop when lower edge of box is beyond end of line */
while|while
condition|(
operator|(
name|nbox
operator|)
operator|&&
operator|(
name|y2
operator|>=
name|pbox
operator|->
name|y1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|x1
operator|>=
name|pbox
operator|->
name|x1
operator|)
operator|&&
operator|(
name|x1
operator|<
name|pbox
operator|->
name|x2
operator|)
condition|)
block|{
name|int
name|y1t
decl_stmt|,
name|y2t
decl_stmt|;
comment|/* this box has part of the line in it */
name|y1t
operator|=
name|max
argument_list|(
name|y1
argument_list|,
name|pbox
operator|->
name|y1
argument_list|)
expr_stmt|;
name|y2t
operator|=
name|min
argument_list|(
name|y2
argument_list|,
name|pbox
operator|->
name|y2
argument_list|)
expr_stmt|;
if|if
condition|(
name|y1t
operator|!=
name|y2t
condition|)
block|{
name|cfbVertS
argument_list|(
name|alu
argument_list|,
name|and
argument_list|,
name|xor
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|x1
argument_list|,
name|y1t
argument_list|,
name|y2t
operator|-
name|y1t
argument_list|)
expr_stmt|;
block|}
block|}
name|nbox
operator|--
expr_stmt|;
name|pbox
operator|++
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|POLYSEGMENT
name|y2
operator|=
name|ppt
operator|->
name|y
operator|+
name|yorg
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
block|{
comment|/* force line from left to right, keeping 	       endpoint semantics 	    */
if|if
condition|(
name|x1
operator|>
name|x2
condition|)
block|{
specifier|register
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|x1
operator|+
literal|1
expr_stmt|;
name|x1
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|x1
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|POLYSEGMENT
elseif|else
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|x2
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* find the correct band */
while|while
condition|(
operator|(
name|nbox
operator|)
operator|&&
operator|(
name|pbox
operator|->
name|y2
operator|<=
name|y1
operator|)
condition|)
block|{
name|pbox
operator|++
expr_stmt|;
name|nbox
operator|--
expr_stmt|;
block|}
comment|/* try to draw the line, if we haven't gone beyond it */
if|if
condition|(
operator|(
name|nbox
operator|)
operator|&&
operator|(
name|pbox
operator|->
name|y1
operator|<=
name|y1
operator|)
condition|)
block|{
comment|/* when we leave this band, we're done */
name|tmp
operator|=
name|pbox
operator|->
name|y1
expr_stmt|;
while|while
condition|(
operator|(
name|nbox
operator|)
operator|&&
operator|(
name|pbox
operator|->
name|y1
operator|==
name|tmp
operator|)
condition|)
block|{
name|int
name|x1t
decl_stmt|,
name|x2t
decl_stmt|;
if|if
condition|(
name|pbox
operator|->
name|x2
operator|<=
name|x1
condition|)
block|{
comment|/* skip boxes until one might contain start point */
name|nbox
operator|--
expr_stmt|;
name|pbox
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* stop if left of box is beyond right of line */
if|if
condition|(
name|pbox
operator|->
name|x1
operator|>=
name|x2
condition|)
block|{
name|nbox
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|x1t
operator|=
name|max
argument_list|(
name|x1
argument_list|,
name|pbox
operator|->
name|x1
argument_list|)
expr_stmt|;
name|x2t
operator|=
name|min
argument_list|(
name|x2
argument_list|,
name|pbox
operator|->
name|x2
argument_list|)
expr_stmt|;
if|if
condition|(
name|x1t
operator|!=
name|x2t
condition|)
block|{
name|cfbHorzS
argument_list|(
name|alu
argument_list|,
name|and
argument_list|,
name|xor
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|x1t
argument_list|,
name|y1
argument_list|,
name|x2t
operator|-
name|x1t
argument_list|)
expr_stmt|;
block|}
name|nbox
operator|--
expr_stmt|;
name|pbox
operator|++
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|POLYSEGMENT
name|x2
operator|=
name|ppt
operator|->
name|x
operator|+
name|xorg
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* sloped line */
block|{
name|signdx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|adx
operator|=
name|x2
operator|-
name|x1
operator|)
operator|<
literal|0
condition|)
block|{
name|adx
operator|=
operator|-
name|adx
expr_stmt|;
name|signdx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|signdy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ady
operator|=
name|y2
operator|-
name|y1
operator|)
operator|<
literal|0
condition|)
block|{
name|ady
operator|=
operator|-
name|ady
expr_stmt|;
name|signdy
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|adx
operator|>
name|ady
condition|)
block|{
name|axis
operator|=
name|X_AXIS
expr_stmt|;
name|e1
operator|=
name|ady
operator|<<
literal|1
expr_stmt|;
name|e2
operator|=
name|e1
operator|-
operator|(
name|adx
operator|<<
literal|1
operator|)
expr_stmt|;
name|e
operator|=
name|e1
operator|-
name|adx
expr_stmt|;
block|}
else|else
block|{
name|axis
operator|=
name|Y_AXIS
expr_stmt|;
name|e1
operator|=
name|adx
operator|<<
literal|1
expr_stmt|;
name|e2
operator|=
name|e1
operator|-
operator|(
name|ady
operator|<<
literal|1
operator|)
expr_stmt|;
name|e
operator|=
name|e1
operator|-
name|ady
expr_stmt|;
block|}
comment|/* we have bresenham parameters and two points. 	       all we have to do now is clip and draw. 	    */
while|while
condition|(
name|nbox
operator|--
condition|)
block|{
name|oc1
operator|=
literal|0
expr_stmt|;
name|oc2
operator|=
literal|0
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc1
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|pbox
argument_list|)
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc2
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|pbox
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oc1
operator||
name|oc2
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
name|len
operator|=
name|adx
expr_stmt|;
else|else
name|len
operator|=
name|ady
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|len
operator|++
expr_stmt|;
endif|#
directive|endif
name|cfbBresS
argument_list|(
name|alu
argument_list|,
name|and
argument_list|,
name|xor
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|e
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|oc1
operator|&
name|oc2
condition|)
block|{
name|pbox
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     	     * let the mfb helper routine do our work; 	     	     * better than duplicating code... 	     	     */
name|BoxRec
name|box
decl_stmt|;
name|DDXPointRec
name|pt1Copy
decl_stmt|;
comment|/* clipped start point */
name|DDXPointRec
name|pt2Copy
decl_stmt|;
comment|/* clipped end point */
name|int
name|err
decl_stmt|;
comment|/* modified bresenham error term */
name|int
name|clip1
decl_stmt|,
name|clip2
decl_stmt|;
comment|/* clippedness of the endpoints */
name|int
name|clipdx
decl_stmt|,
name|clipdy
decl_stmt|;
comment|/* difference between clipped and 				       	       	   unclipped start point */
name|DDXPointRec
name|pt1
decl_stmt|;
name|pt1
operator|.
name|x
operator|=
name|pt1Copy
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|pt1
operator|.
name|y
operator|=
name|pt1Copy
operator|.
name|y
operator|=
name|y1
expr_stmt|;
name|pt2Copy
operator|.
name|x
operator|=
name|x2
expr_stmt|;
name|pt2Copy
operator|.
name|y
operator|=
name|y2
expr_stmt|;
name|box
operator|.
name|x1
operator|=
name|pbox
operator|->
name|x1
expr_stmt|;
name|box
operator|.
name|y1
operator|=
name|pbox
operator|->
name|y1
expr_stmt|;
name|box
operator|.
name|x2
operator|=
name|pbox
operator|->
name|x2
operator|-
literal|1
expr_stmt|;
name|box
operator|.
name|y2
operator|=
name|pbox
operator|->
name|y2
operator|-
literal|1
expr_stmt|;
name|clip1
operator|=
literal|0
expr_stmt|;
name|clip2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mfbClipLine
argument_list|(
name|pbox
argument_list|,
name|box
argument_list|,
operator|&
name|pt1
argument_list|,
operator|&
name|pt1Copy
argument_list|,
operator|&
name|pt2Copy
argument_list|,
name|adx
argument_list|,
name|ady
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
operator|&
name|clip1
argument_list|,
operator|&
name|clip2
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
name|len
operator|=
name|abs
argument_list|(
name|pt2Copy
operator|.
name|x
operator|-
name|pt1Copy
operator|.
name|x
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|abs
argument_list|(
name|pt2Copy
operator|.
name|y
operator|-
name|pt1Copy
operator|.
name|y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
name|clip2
operator|!=
literal|0
operator|||
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|len
operator|++
expr_stmt|;
else|#
directive|else
name|len
operator|+=
operator|(
name|clip2
operator|!=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
condition|)
block|{
comment|/* unwind bresenham error term to first point */
if|if
condition|(
name|clip1
condition|)
block|{
name|clipdx
operator|=
name|abs
argument_list|(
name|pt1Copy
operator|.
name|x
operator|-
name|x1
argument_list|)
expr_stmt|;
name|clipdy
operator|=
name|abs
argument_list|(
name|pt1Copy
operator|.
name|y
operator|-
name|y1
argument_list|)
expr_stmt|;
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
name|err
operator|=
name|e
operator|+
operator|(
operator|(
name|clipdy
operator|*
name|e2
operator|)
operator|+
operator|(
operator|(
name|clipdx
operator|-
name|clipdy
operator|)
operator|*
name|e1
operator|)
operator|)
expr_stmt|;
else|else
name|err
operator|=
name|e
operator|+
operator|(
operator|(
name|clipdx
operator|*
name|e2
operator|)
operator|+
operator|(
operator|(
name|clipdy
operator|-
name|clipdx
operator|)
operator|*
name|e1
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|err
operator|=
name|e
expr_stmt|;
name|cfbBresS
argument_list|(
name|alu
argument_list|,
name|and
argument_list|,
name|xor
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
name|pt1Copy
operator|.
name|x
argument_list|,
name|pt1Copy
operator|.
name|y
argument_list|,
name|err
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|pbox
operator|++
expr_stmt|;
block|}
block|}
comment|/* while (nbox--) */
block|}
comment|/* sloped line */
block|}
comment|/* while (nline--) */
ifndef|#
directive|ifndef
name|POLYSEGMENT
comment|/* paint the last point if the end style isn't CapNotLast.        (Assume that a projecting, butt, or round cap that is one         pixel wide is the same as the single pixel of the endpoint.)     */
if|if
condition|(
operator|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
operator|)
operator|&&
operator|(
operator|(
name|ppt
operator|->
name|x
operator|+
name|xorg
operator|!=
name|pptInit
operator|->
name|x
operator|+
name|pDrawable
operator|->
name|x
operator|)
operator|||
operator|(
name|ppt
operator|->
name|y
operator|+
name|yorg
operator|!=
name|pptInit
operator|->
name|y
operator|+
name|pDrawable
operator|->
name|y
operator|)
operator|||
operator|(
name|ppt
operator|==
name|pptInit
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|nbox
operator|=
name|nboxInit
expr_stmt|;
name|pbox
operator|=
name|pboxInit
expr_stmt|;
while|while
condition|(
name|nbox
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|x2
operator|>=
name|pbox
operator|->
name|x1
operator|)
operator|&&
operator|(
name|y2
operator|>=
name|pbox
operator|->
name|y1
operator|)
operator|&&
operator|(
name|x2
operator|<
name|pbox
operator|->
name|x2
operator|)
operator|&&
operator|(
name|y2
operator|<
name|pbox
operator|->
name|y2
operator|)
condition|)
block|{
name|unsigned
name|long
name|mask
decl_stmt|;
name|unsigned
name|long
name|scrbits
decl_stmt|;
name|mask
operator|=
name|cfbmask
index|[
name|x2
operator|&
name|PIM
index|]
expr_stmt|;
name|addrl
operator|+=
operator|(
name|y2
operator|*
name|nlwidth
operator|)
operator|+
operator|(
name|x2
operator|>>
name|PWSH
operator|)
expr_stmt|;
name|scrbits
operator|=
operator|*
name|addrl
expr_stmt|;
operator|*
name|addrl
operator|=
operator|(
name|scrbits
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
name|DoRRop
argument_list|(
name|scrbits
argument_list|,
name|and
argument_list|,
name|xor
argument_list|)
operator|&
name|mask
operator|)
expr_stmt|;
break|break;
block|}
else|else
name|pbox
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Draw dashed 1-pixel lines.  */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|POLYSEGMENT
name|cfbSegmentSD
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nseg
parameter_list|,
name|pSeg
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
specifier|register
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nseg
decl_stmt|;
specifier|register
name|xSegment
modifier|*
name|pSeg
decl_stmt|;
else|#
directive|else
function|cfbLineSD
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|mode
parameter_list|,
name|npt
parameter_list|,
name|pptInit
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
specifier|register
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* Origin or Previous */
name|int
name|npt
decl_stmt|;
comment|/* number of points */
name|DDXPointPtr
name|pptInit
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|nboxInit
decl_stmt|;
specifier|register
name|int
name|nbox
decl_stmt|;
name|BoxPtr
name|pboxInit
decl_stmt|;
specifier|register
name|BoxPtr
name|pbox
decl_stmt|;
ifndef|#
directive|ifndef
name|POLYSEGMENT
specifier|register
name|DDXPointPtr
name|ppt
decl_stmt|;
comment|/* pointer to list of translated points */
endif|#
directive|endif
specifier|register
name|unsigned
name|int
name|oc1
decl_stmt|;
comment|/* outcode of point 1 */
specifier|register
name|unsigned
name|int
name|oc2
decl_stmt|;
comment|/* outcode of point 2 */
name|unsigned
name|long
modifier|*
name|addrl
decl_stmt|;
comment|/* address of destination pixmap */
name|int
name|nlwidth
decl_stmt|;
comment|/* width in longwords of destination pixmap */
name|int
name|xorg
decl_stmt|,
name|yorg
decl_stmt|;
comment|/* origin of window */
name|int
name|adx
decl_stmt|;
comment|/* abs values of dx and dy */
name|int
name|ady
decl_stmt|;
name|int
name|signdx
decl_stmt|;
comment|/* sign of dx and dy */
name|int
name|signdy
decl_stmt|;
name|int
name|e
decl_stmt|,
name|e1
decl_stmt|,
name|e2
decl_stmt|;
comment|/* bresenham error and increments */
name|int
name|len
decl_stmt|;
comment|/* length of segment */
name|int
name|axis
decl_stmt|;
comment|/* major axis */
name|int
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|;
name|RegionPtr
name|cclip
decl_stmt|;
name|cfbRRopRec
name|rrops
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|pDash
decl_stmt|;
name|int
name|dashOffset
decl_stmt|;
name|int
name|numInDashList
decl_stmt|;
name|int
name|dashIndex
decl_stmt|;
name|int
name|isDoubleDash
decl_stmt|;
name|int
name|dashIndexTmp
decl_stmt|,
name|dashOffsetTmp
decl_stmt|;
name|int
name|unclippedlen
decl_stmt|;
name|cfbPrivGCPtr
name|devPriv
decl_stmt|;
name|devPriv
operator|=
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
expr_stmt|;
name|cclip
operator|=
name|devPriv
operator|->
name|pCompositeClip
expr_stmt|;
name|rrops
index|[
literal|0
index|]
operator|.
name|rop
operator|=
name|devPriv
operator|->
name|rop
expr_stmt|;
name|rrops
index|[
literal|0
index|]
operator|.
name|and
operator|=
name|devPriv
operator|->
name|and
expr_stmt|;
name|rrops
index|[
literal|0
index|]
operator|.
name|xor
operator|=
name|devPriv
operator|->
name|xor
expr_stmt|;
if|if
condition|(
name|pGC
operator|->
name|alu
operator|==
name|GXcopy
condition|)
block|{
name|rrops
index|[
literal|1
index|]
operator|.
name|rop
operator|=
name|GXcopy
expr_stmt|;
name|rrops
index|[
literal|1
index|]
operator|.
name|and
operator|=
literal|0
expr_stmt|;
name|rrops
index|[
literal|1
index|]
operator|.
name|xor
operator|=
name|PFILL
argument_list|(
name|pGC
operator|->
name|bgPixel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rrops
index|[
literal|1
index|]
operator|.
name|rop
operator|=
name|cfbReduceRasterOp
argument_list|(
name|pGC
operator|->
name|alu
argument_list|,
name|pGC
operator|->
name|bgPixel
argument_list|,
name|pGC
operator|->
name|planemask
argument_list|,
operator|&
name|rrops
index|[
literal|1
index|]
operator|.
name|and
argument_list|,
operator|&
name|rrops
index|[
literal|1
index|]
operator|.
name|xor
argument_list|)
expr_stmt|;
block|}
name|pboxInit
operator|=
name|REGION_RECTS
argument_list|(
name|cclip
argument_list|)
expr_stmt|;
name|nboxInit
operator|=
name|REGION_NUM_RECTS
argument_list|(
name|cclip
argument_list|)
expr_stmt|;
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|nlwidth
argument_list|,
argument|addrl
argument_list|)
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
comment|/* compute initial dash values */
name|pDash
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pGC
operator|->
name|dash
expr_stmt|;
name|numInDashList
operator|=
name|pGC
operator|->
name|numInDashList
expr_stmt|;
name|isDoubleDash
operator|=
operator|(
name|pGC
operator|->
name|lineStyle
operator|==
name|LineDoubleDash
operator|)
expr_stmt|;
name|dashIndex
operator|=
literal|0
expr_stmt|;
name|dashOffset
operator|=
literal|0
expr_stmt|;
name|miStepDash
argument_list|(
operator|(
name|int
operator|)
name|pGC
operator|->
name|dashOffset
argument_list|,
operator|&
name|dashIndex
argument_list|,
name|pDash
argument_list|,
name|numInDashList
argument_list|,
operator|&
name|dashOffset
argument_list|)
expr_stmt|;
name|xorg
operator|=
name|pDrawable
operator|->
name|x
expr_stmt|;
name|yorg
operator|=
name|pDrawable
operator|->
name|y
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
while|while
condition|(
name|nseg
operator|--
condition|)
else|#
directive|else
name|ppt
operator|=
name|pptInit
expr_stmt|;
name|x2
operator|=
name|ppt
operator|->
name|x
operator|+
name|xorg
expr_stmt|;
name|y2
operator|=
name|ppt
operator|->
name|y
operator|+
name|yorg
expr_stmt|;
while|while
condition|(
operator|--
name|npt
condition|)
endif|#
directive|endif
block|{
name|nbox
operator|=
name|nboxInit
expr_stmt|;
name|pbox
operator|=
name|pboxInit
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
name|x1
operator|=
name|pSeg
operator|->
name|x1
operator|+
name|xorg
expr_stmt|;
name|y1
operator|=
name|pSeg
operator|->
name|y1
operator|+
name|yorg
expr_stmt|;
name|x2
operator|=
name|pSeg
operator|->
name|x2
operator|+
name|xorg
expr_stmt|;
name|y2
operator|=
name|pSeg
operator|->
name|y2
operator|+
name|yorg
expr_stmt|;
name|pSeg
operator|++
expr_stmt|;
else|#
directive|else
name|x1
operator|=
name|x2
expr_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
operator|++
name|ppt
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CoordModePrevious
condition|)
block|{
name|xorg
operator|=
name|x1
expr_stmt|;
name|yorg
operator|=
name|y1
expr_stmt|;
block|}
name|x2
operator|=
name|ppt
operator|->
name|x
operator|+
name|xorg
expr_stmt|;
name|y2
operator|=
name|ppt
operator|->
name|y
operator|+
name|yorg
expr_stmt|;
endif|#
directive|endif
name|adx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|ady
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|signdx
operator|=
name|sign
argument_list|(
name|adx
argument_list|)
expr_stmt|;
name|signdy
operator|=
name|sign
argument_list|(
name|ady
argument_list|)
expr_stmt|;
name|adx
operator|=
name|abs
argument_list|(
name|adx
argument_list|)
expr_stmt|;
name|ady
operator|=
name|abs
argument_list|(
name|ady
argument_list|)
expr_stmt|;
if|if
condition|(
name|adx
operator|>
name|ady
condition|)
block|{
name|axis
operator|=
name|X_AXIS
expr_stmt|;
name|e1
operator|=
name|ady
operator|<<
literal|1
expr_stmt|;
name|e2
operator|=
name|e1
operator|-
operator|(
name|adx
operator|<<
literal|1
operator|)
expr_stmt|;
name|e
operator|=
name|e1
operator|-
name|adx
expr_stmt|;
name|unclippedlen
operator|=
name|adx
expr_stmt|;
block|}
else|else
block|{
name|axis
operator|=
name|Y_AXIS
expr_stmt|;
name|e1
operator|=
name|adx
operator|<<
literal|1
expr_stmt|;
name|e2
operator|=
name|e1
operator|-
operator|(
name|ady
operator|<<
literal|1
operator|)
expr_stmt|;
name|e
operator|=
name|e1
operator|-
name|ady
expr_stmt|;
name|unclippedlen
operator|=
name|ady
expr_stmt|;
block|}
comment|/* we have bresenham parameters and two points. 	   all we have to do now is clip and draw. 	*/
while|while
condition|(
name|nbox
operator|--
condition|)
block|{
name|oc1
operator|=
literal|0
expr_stmt|;
name|oc2
operator|=
literal|0
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc1
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|pbox
argument_list|)
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc2
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|pbox
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oc1
operator||
name|oc2
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|unclippedlen
operator|++
expr_stmt|;
name|dashIndexTmp
operator|=
name|dashIndex
expr_stmt|;
name|dashOffsetTmp
operator|=
name|dashOffset
expr_stmt|;
name|cfbBresD
argument_list|(
name|rrops
argument_list|,
operator|&
name|dashIndexTmp
argument_list|,
name|pDash
argument_list|,
name|numInDashList
argument_list|,
operator|&
name|dashOffsetTmp
argument_list|,
name|isDoubleDash
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|e
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|unclippedlen
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|cfbBresD
argument_list|(
name|rrops
argument_list|,
operator|&
name|dashIndex
argument_list|,
name|pDash
argument_list|,
name|numInDashList
argument_list|,
operator|&
name|dashOffset
argument_list|,
name|isDoubleDash
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|e
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|unclippedlen
argument_list|)
expr_stmt|;
goto|goto
name|dontStep
goto|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|oc1
operator|&
name|oc2
condition|)
block|{
name|pbox
operator|++
expr_stmt|;
block|}
else|else
comment|/* have to clip */
block|{
comment|/* 		 * let the mfb helper routine do our work; 		 * better than duplicating code... 		 */
name|BoxRec
name|box
decl_stmt|;
name|DDXPointRec
name|pt1Copy
decl_stmt|;
comment|/* clipped start point */
name|DDXPointRec
name|pt2Copy
decl_stmt|;
comment|/* clipped end point */
name|int
name|err
decl_stmt|;
comment|/* modified bresenham error term */
name|int
name|clip1
decl_stmt|,
name|clip2
decl_stmt|;
comment|/* clippedness of the endpoints */
name|int
name|clipdx
decl_stmt|,
name|clipdy
decl_stmt|;
comment|/* difference between clipped and 					       unclipped start point */
name|DDXPointRec
name|pt1
decl_stmt|;
name|pt1
operator|.
name|x
operator|=
name|pt1Copy
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|pt1
operator|.
name|y
operator|=
name|pt1Copy
operator|.
name|y
operator|=
name|y1
expr_stmt|;
name|pt2Copy
operator|.
name|x
operator|=
name|x2
expr_stmt|;
name|pt2Copy
operator|.
name|y
operator|=
name|y2
expr_stmt|;
name|box
operator|.
name|x1
operator|=
name|pbox
operator|->
name|x1
expr_stmt|;
name|box
operator|.
name|y1
operator|=
name|pbox
operator|->
name|y1
expr_stmt|;
name|box
operator|.
name|x2
operator|=
name|pbox
operator|->
name|x2
operator|-
literal|1
expr_stmt|;
name|box
operator|.
name|y2
operator|=
name|pbox
operator|->
name|y2
operator|-
literal|1
expr_stmt|;
name|clip1
operator|=
literal|0
expr_stmt|;
name|clip2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mfbClipLine
argument_list|(
name|pbox
argument_list|,
name|box
argument_list|,
operator|&
name|pt1
argument_list|,
operator|&
name|pt1Copy
argument_list|,
operator|&
name|pt2Copy
argument_list|,
name|adx
argument_list|,
name|ady
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
operator|&
name|clip1
argument_list|,
operator|&
name|clip2
argument_list|)
operator|==
literal|1
condition|)
block|{
name|dashIndexTmp
operator|=
name|dashIndex
expr_stmt|;
name|dashOffsetTmp
operator|=
name|dashOffset
expr_stmt|;
if|if
condition|(
name|clip1
condition|)
block|{
name|int
name|dlen
decl_stmt|;
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
name|dlen
operator|=
name|abs
argument_list|(
name|pt1Copy
operator|.
name|x
operator|-
name|x1
argument_list|)
expr_stmt|;
else|else
name|dlen
operator|=
name|abs
argument_list|(
name|pt1Copy
operator|.
name|y
operator|-
name|y1
argument_list|)
expr_stmt|;
name|miStepDash
argument_list|(
name|dlen
argument_list|,
operator|&
name|dashIndexTmp
argument_list|,
name|pDash
argument_list|,
name|numInDashList
argument_list|,
operator|&
name|dashOffsetTmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
name|len
operator|=
name|abs
argument_list|(
name|pt2Copy
operator|.
name|x
operator|-
name|pt1Copy
operator|.
name|x
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|abs
argument_list|(
name|pt2Copy
operator|.
name|y
operator|-
name|pt1Copy
operator|.
name|y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
name|clip2
operator|!=
literal|0
operator|||
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|len
operator|++
expr_stmt|;
else|#
directive|else
name|len
operator|+=
operator|(
name|clip2
operator|!=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
condition|)
block|{
comment|/* unwind bresenham error term to first point */
if|if
condition|(
name|clip1
condition|)
block|{
name|clipdx
operator|=
name|abs
argument_list|(
name|pt1Copy
operator|.
name|x
operator|-
name|x1
argument_list|)
expr_stmt|;
name|clipdy
operator|=
name|abs
argument_list|(
name|pt1Copy
operator|.
name|y
operator|-
name|y1
argument_list|)
expr_stmt|;
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
name|err
operator|=
name|e
operator|+
operator|(
operator|(
name|clipdy
operator|*
name|e2
operator|)
operator|+
operator|(
operator|(
name|clipdx
operator|-
name|clipdy
operator|)
operator|*
name|e1
operator|)
operator|)
expr_stmt|;
else|else
name|err
operator|=
name|e
operator|+
operator|(
operator|(
name|clipdx
operator|*
name|e2
operator|)
operator|+
operator|(
operator|(
name|clipdy
operator|-
name|clipdx
operator|)
operator|*
name|e1
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|err
operator|=
name|e
expr_stmt|;
name|cfbBresD
argument_list|(
name|rrops
argument_list|,
operator|&
name|dashIndexTmp
argument_list|,
name|pDash
argument_list|,
name|numInDashList
argument_list|,
operator|&
name|dashOffsetTmp
argument_list|,
name|isDoubleDash
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
name|pt1Copy
operator|.
name|x
argument_list|,
name|pt1Copy
operator|.
name|y
argument_list|,
name|err
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|pbox
operator|++
expr_stmt|;
block|}
block|}
comment|/* while (nbox--) */
ifndef|#
directive|ifndef
name|POLYSEGMENT
comment|/* 	 * walk the dash list around to the next line 	 */
name|miStepDash
argument_list|(
name|unclippedlen
argument_list|,
operator|&
name|dashIndex
argument_list|,
name|pDash
argument_list|,
name|numInDashList
argument_list|,
operator|&
name|dashOffset
argument_list|)
expr_stmt|;
name|dontStep
label|:
empty_stmt|;
endif|#
directive|endif
block|}
comment|/* while (nline--) */
ifndef|#
directive|ifndef
name|POLYSEGMENT
comment|/* paint the last point if the end style isn't CapNotLast.        (Assume that a projecting, butt, or round cap that is one         pixel wide is the same as the single pixel of the endpoint.)     */
if|if
condition|(
operator|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
operator|)
operator|&&
operator|(
operator|(
name|dashIndex
operator|&
literal|1
operator|)
operator|==
literal|0
operator|||
name|isDoubleDash
operator|)
operator|&&
operator|(
operator|(
name|ppt
operator|->
name|x
operator|+
name|xorg
operator|!=
name|pptInit
operator|->
name|x
operator|+
name|pDrawable
operator|->
name|x
operator|)
operator|||
operator|(
name|ppt
operator|->
name|y
operator|+
name|yorg
operator|!=
name|pptInit
operator|->
name|y
operator|+
name|pDrawable
operator|->
name|y
operator|)
operator|||
operator|(
name|ppt
operator|==
name|pptInit
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|nbox
operator|=
name|nboxInit
expr_stmt|;
name|pbox
operator|=
name|pboxInit
expr_stmt|;
while|while
condition|(
name|nbox
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|x2
operator|>=
name|pbox
operator|->
name|x1
operator|)
operator|&&
operator|(
name|y2
operator|>=
name|pbox
operator|->
name|y1
operator|)
operator|&&
operator|(
name|x2
operator|<
name|pbox
operator|->
name|x2
operator|)
operator|&&
operator|(
name|y2
operator|<
name|pbox
operator|->
name|y2
operator|)
condition|)
block|{
name|unsigned
name|long
name|mask
decl_stmt|;
name|int
name|pix
decl_stmt|;
name|pix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dashIndex
operator|&
literal|1
condition|)
name|pix
operator|=
literal|1
expr_stmt|;
name|mask
operator|=
name|cfbmask
index|[
name|x2
operator|&
name|PIM
index|]
expr_stmt|;
name|addrl
operator|+=
operator|(
name|y2
operator|*
name|nlwidth
operator|)
operator|+
operator|(
name|x2
operator|>>
name|PWSH
operator|)
expr_stmt|;
operator|*
name|addrl
operator|=
name|DoMaskRRop
argument_list|(
operator|*
name|addrl
argument_list|,
name|rrops
index|[
name|pix
index|]
operator|.
name|and
argument_list|,
name|rrops
index|[
name|pix
index|]
operator|.
name|xor
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|pbox
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

end_unit

