begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: cfbsolid.c,v 1.5 91/07/11 21:48:24 keith Exp $  *  * Copyright 1990 Massachusetts Institute of Technology  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the name of M.I.T. not be used in advertising or  * publicity pertaining to distribution of the software without specific,  * written prior permission.  M.I.T. makes no representations about the  * suitability of this software for any purpose.  It is provided "as is"  * without express or implied warranty.  *  * M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL M.I.T.  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * Author:  Keith Packard, MIT X Consortium  */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"servermd.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"cfb.h"
end_include

begin_include
include|#
directive|include
file|"cfbmskbits.h"
end_include

begin_include
include|#
directive|include
file|"cfbrrop.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FAST_CONSTANT_OFFSET_MODE
argument_list|)
operator|&&
operator|(
name|RROP
operator|!=
name|GXcopy
operator|)
end_if

begin_define
define|#
directive|define
name|Expand
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|,
name|leftAdjust
parameter_list|)
value|{\     int part = nmiddle& 3; \     int widthStep; \     widthStep = widthDst - nmiddle - leftAdjust; \     nmiddle>>= 2; \     pdst = pdstRect; \     while (h--) { \ 	left \ 	pdst += part; \ 	switch (part) { \ 	    RROP_UNROLL_CASE3(pdst) \ 	} \ 	m = nmiddle; \ 	while (m) { \ 	    pdst += 4; \ 	    RROP_UNROLL_LOOP4(pdst,-4) \ 	    m--; \ 	} \ 	right \ 	pdst += widthStep; \     } \ }
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|RROP_UNROLL
end_ifdef

begin_define
define|#
directive|define
name|Expand
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|,
name|leftAdjust
parameter_list|)
value|{\     int part = nmiddle& RROP_UNROLL_MASK; \     int widthStep; \     widthStep = widthDst - nmiddle - leftAdjust; \     nmiddle>>= RROP_UNROLL_SHIFT; \     pdst = pdstRect; \     while (h--) { \ 	left \ 	pdst += part; \ 	switch (part) { \ 	    RROP_UNROLL_CASE(pdst) \ 	} \ 	m = nmiddle; \ 	while (m) { \ 	    pdst += RROP_UNROLL; \ 	    RROP_UNROLL_LOOP(pdst) \ 	    m--; \ 	} \ 	right \ 	pdst += widthStep; \     } \ }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Expand
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|,
name|leftAdjust
parameter_list|)
value|{ \     while (h--) { \ 	pdst = pdstRect; \ 	left \ 	m = nmiddle; \ 	while (m--) {\ 	    RROP_SOLID(pdst); \ 	    pdst++; \ 	} \ 	right \ 	pdstRect += widthDst; \     } \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|RROP_NAME
function|(
name|cfbFillRectSolid
function|)
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nBox
parameter_list|,
name|pBox
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nBox
decl_stmt|;
name|BoxPtr
name|pBox
decl_stmt|;
block|{
specifier|register
name|int
name|m
decl_stmt|;
specifier|register
name|unsigned
name|long
modifier|*
name|pdst
decl_stmt|;
name|RROP_DECLARE
specifier|register
name|unsigned
name|long
name|leftMask
decl_stmt|,
name|rightMask
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pdstBase
decl_stmt|,
modifier|*
name|pdstRect
decl_stmt|;
name|int
name|nmiddle
decl_stmt|;
name|int
name|h
decl_stmt|;
name|int
name|w
decl_stmt|;
name|int
name|widthDst
decl_stmt|;
name|cfbPrivGCPtr
name|devPriv
decl_stmt|;
name|devPriv
operator|=
operator|(
call|(
name|cfbPrivGCPtr
call|)
argument_list|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
argument_list|)
operator|)
expr_stmt|;
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|widthDst
argument_list|,
argument|pdstBase
argument_list|)
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|RROP_FETCH_GC
argument_list|(
argument|pGC
argument_list|)
for|for
control|(
init|;
name|nBox
condition|;
name|nBox
operator|--
operator|,
name|pBox
operator|++
control|)
block|{
name|pdstRect
operator|=
name|pdstBase
operator|+
name|pBox
operator|->
name|y1
operator|*
name|widthDst
expr_stmt|;
name|h
operator|=
name|pBox
operator|->
name|y2
operator|-
name|pBox
operator|->
name|y1
expr_stmt|;
name|w
operator|=
name|pBox
operator|->
name|x2
operator|-
name|pBox
operator|->
name|x1
expr_stmt|;
if|#
directive|if
name|PPW
operator|==
literal|4
if|if
condition|(
name|w
operator|==
literal|1
condition|)
block|{
specifier|register
name|char
modifier|*
name|pdstb
init|=
operator|(
operator|(
name|char
operator|*
operator|)
name|pdstRect
operator|)
operator|+
name|pBox
operator|->
name|x1
decl_stmt|;
name|int
name|incr
init|=
name|widthDst
operator|<<
literal|2
decl_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|RROP_SOLID
argument_list|(
name|pdstb
argument_list|)
expr_stmt|;
name|pdstb
operator|+=
name|incr
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
name|pdstRect
operator|+=
operator|(
name|pBox
operator|->
name|x1
operator|>>
name|PWSH
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pBox
operator|->
name|x1
operator|&
name|PIM
operator|)
operator|+
name|w
operator|<=
name|PPW
condition|)
block|{
name|maskpartialbits
argument_list|(
name|pBox
operator|->
name|x1
argument_list|,
name|w
argument_list|,
name|leftMask
argument_list|)
expr_stmt|;
name|pdst
operator|=
name|pdstRect
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|RROP_SOLID_MASK
argument_list|(
name|pdst
argument_list|,
name|leftMask
argument_list|)
expr_stmt|;
name|pdst
operator|+=
name|widthDst
expr_stmt|;
block|}
block|}
else|else
block|{
name|maskbits
argument_list|(
name|pBox
operator|->
name|x1
argument_list|,
name|w
argument_list|,
name|leftMask
argument_list|,
name|rightMask
argument_list|,
name|nmiddle
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftMask
condition|)
block|{
if|if
condition|(
name|rightMask
condition|)
comment|/* left mask and right mask */
block|{
name|Expand
argument_list|(
argument|RROP_SOLID_MASK (pdst, leftMask); pdst++;
argument_list|,
argument|RROP_SOLID_MASK (pdst, rightMask);
argument_list|,
literal|1
argument_list|)
block|}
else|else
comment|/* left mask and no right mask */
block|{
name|Expand
argument_list|(
argument|RROP_SOLID_MASK (pdst, leftMask); pdst++;
argument_list|,
argument|;
argument_list|,
literal|1
argument_list|)
block|}
block|}
else|else
block|{
if|if
condition|(
name|rightMask
condition|)
comment|/* no left mask and right mask */
block|{
name|Expand
argument_list|(
argument|;
argument_list|,
argument|RROP_SOLID_MASK (pdst, rightMask);
argument_list|,
literal|0
argument_list|)
block|}
else|else
comment|/* no left mask and no right mask */
block|{
name|Expand
argument_list|(
argument|;
argument_list|,
argument|;
argument_list|,
literal|0
argument_list|)
block|}
block|}
block|}
if|#
directive|if
name|PPW
operator|==
literal|4
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|RROP_NAME
function|(
name|cfbSolidSpans
function|)
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nInit
parameter_list|,
name|pptInit
parameter_list|,
name|pwidthInit
parameter_list|,
name|fSorted
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nInit
decl_stmt|;
comment|/* number of spans to fill */
name|DDXPointPtr
name|pptInit
decl_stmt|;
comment|/* pointer to list of start points */
name|int
modifier|*
name|pwidthInit
decl_stmt|;
comment|/* pointer to list of n widths */
name|int
name|fSorted
decl_stmt|;
block|{
name|unsigned
name|long
modifier|*
name|pdstBase
decl_stmt|;
name|int
name|widthDst
decl_stmt|;
name|RROP_DECLARE
specifier|register
name|unsigned
name|long
modifier|*
name|pdst
decl_stmt|;
specifier|register
name|int
name|nlmiddle
decl_stmt|;
specifier|register
name|unsigned
name|long
name|startmask
decl_stmt|,
name|endmask
decl_stmt|;
specifier|register
name|int
name|w
decl_stmt|;
name|int
name|x
decl_stmt|;
comment|/* next three parameters are post-clip */
name|int
name|n
decl_stmt|;
comment|/* number of spans to fill */
name|DDXPointPtr
name|ppt
decl_stmt|;
comment|/* pointer to list of start points */
name|int
modifier|*
name|pwidthFree
decl_stmt|;
comment|/* copies of the pointers to free */
name|DDXPointPtr
name|pptFree
decl_stmt|;
name|int
modifier|*
name|pwidth
decl_stmt|;
name|cfbPrivGCPtr
name|devPriv
decl_stmt|;
name|devPriv
operator|=
operator|(
name|cfbPrivGCPtr
operator|)
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
expr_stmt|;
name|RROP_FETCH_GCPRIV
argument_list|(
argument|devPriv
argument_list|)
name|n
operator|=
name|nInit
operator|*
name|miFindMaxBand
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|pwidthFree
operator|=
operator|(
name|int
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|pptFree
operator|=
operator|(
name|DDXPointRec
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|DDXPointRec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pptFree
operator|||
operator|!
name|pwidthFree
condition|)
block|{
if|if
condition|(
name|pptFree
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pptFree
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwidthFree
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidthFree
argument_list|)
expr_stmt|;
return|return;
block|}
name|pwidth
operator|=
name|pwidthFree
expr_stmt|;
name|ppt
operator|=
name|pptFree
expr_stmt|;
name|n
operator|=
name|miClipSpans
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
name|pptInit
argument_list|,
name|pwidthInit
argument_list|,
name|nInit
argument_list|,
name|ppt
argument_list|,
name|pwidth
argument_list|,
name|fSorted
argument_list|)
expr_stmt|;
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|widthDst
argument_list|,
argument|pdstBase
argument_list|)
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|x
operator|=
name|ppt
operator|->
name|x
expr_stmt|;
name|pdst
operator|=
name|pdstBase
operator|+
operator|(
name|ppt
operator|->
name|y
operator|*
name|widthDst
operator|)
expr_stmt|;
operator|++
name|ppt
expr_stmt|;
name|w
operator|=
operator|*
name|pwidth
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
continue|continue;
if|#
directive|if
name|PPW
operator|==
literal|4
if|if
condition|(
name|w
operator|<=
literal|4
condition|)
block|{
specifier|register
name|char
modifier|*
name|addrb
decl_stmt|;
name|addrb
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|pdst
operator|)
operator|+
name|x
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|RROP_SOLID
argument_list|(
name|addrb
argument_list|)
expr_stmt|;
name|addrb
operator|++
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|x
operator|&
name|PIM
operator|)
operator|+
name|w
operator|<=
name|PPW
condition|)
block|{
name|pdst
operator|+=
name|x
operator|>>
name|PWSH
expr_stmt|;
name|maskpartialbits
argument_list|(
name|x
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|RROP_SOLID_MASK
argument_list|(
name|pdst
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|pdst
operator|+=
name|x
operator|>>
name|PWSH
expr_stmt|;
name|maskbits
argument_list|(
name|x
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|,
name|endmask
argument_list|,
name|nlmiddle
argument_list|)
expr_stmt|;
if|if
condition|(
name|startmask
condition|)
block|{
name|RROP_SOLID_MASK
argument_list|(
name|pdst
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
operator|++
name|pdst
expr_stmt|;
block|}
name|RROP_SPAN
argument_list|(
argument|pdst
argument_list|,
argument|nlmiddle
argument_list|)
if|if
condition|(
name|endmask
condition|)
block|{
name|RROP_SOLID_MASK
argument_list|(
name|pdst
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|DEALLOCATE_LOCAL
argument_list|(
name|pptFree
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidthFree
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

