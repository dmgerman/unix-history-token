begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (c) 1986, 1987 by Hewlett-Packard Company Copyright (c) 1986, 1987 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD TO THIS SOFWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE.  Hewlett-Packard shall not be liable for errors  contained herein or direct, indirect, special, incidental or  consequential damages in connection with the furnishing,  performance, or use of this material.  This software is not subject to any license of the American Telephone and Telegraph Company or of the Regents of the University of California.  */
end_comment

begin_comment
comment|/***********************************************************************  *  file: tcCopyPlane.c  *  *      CopyPlane routine for Topcat (should work for Catseye) displays    *   *  *  *		Hewlett Packard -- Corvallis Workstation Operation  *		Project -- port of X11 to HP9000  *		Harry Phinney -- MTS  *  *  */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xprotostr.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"mi.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"servermd.h"
end_include

begin_include
include|#
directive|include
file|"../cfb/cfb.h"
end_include

begin_include
include|#
directive|include
file|"topcat.h"
end_include

begin_decl_stmt
specifier|extern
name|u_char
name|XHP_NewRule
index|[
literal|16
index|]
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XHP_pmap
index|[
literal|256
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XHP_QUADALIGN
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PIXER
parameter_list|(
name|Drawable
parameter_list|)
value|((hpPrivPixmapPtr)((PixmapPtr)Drawable)->devPrivate.ptr)
end_define

begin_define
define|#
directive|define
name|SCRMER
parameter_list|(
name|Drawable
parameter_list|)
value|getPrivScreenPtr(Drawable->pScreen)
end_define

begin_define
define|#
directive|define
name|DEVKIND
parameter_list|(
name|Drawable
parameter_list|)
value|((PixmapPtr)Drawable)->devKind
end_define

begin_function_decl
specifier|extern
name|unsigned
name|long
modifier|*
name|hpGetPlane
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* tcCopyPlane -- entry for the CopyPlane Request  *  The idea is to special case CopyPlane from depth 1 pixmaps to the  *  screen.  This operation looks much like a PutImage, so we've stolen  *  much of the tcPutImage code.  */
end_comment

begin_function
name|RegionPtr
name|tcCopyPlane
parameter_list|(
name|pSrcDrawable
parameter_list|,
name|pDstDrawable
parameter_list|,
name|pGC
parameter_list|,
name|xIn
parameter_list|,
name|yIn
parameter_list|,
name|widthSrc
parameter_list|,
name|heightSrc
parameter_list|,
name|xOut
parameter_list|,
name|yOut
parameter_list|,
name|bitPlane
parameter_list|)
name|DrawablePtr
name|pSrcDrawable
decl_stmt|,
name|pDstDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|xIn
decl_stmt|,
name|yIn
decl_stmt|,
name|widthSrc
decl_stmt|,
name|heightSrc
decl_stmt|,
name|xOut
decl_stmt|,
name|yOut
decl_stmt|;
name|unsigned
name|long
name|bitPlane
decl_stmt|;
block|{
name|TOPCAT
modifier|*
name|hardware
init|=
name|getTcHardware
argument_list|(
name|pDstDrawable
operator|->
name|pScreen
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|screenPlanes
init|=
name|getPlanesMask
argument_list|(
name|pDstDrawable
operator|->
name|pScreen
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|planeMask
init|=
name|pGC
operator|->
name|planemask
operator|&
name|screenPlanes
decl_stmt|;
name|unsigned
name|int
name|fore
init|=
name|pGC
operator|->
name|fgPixel
decl_stmt|;
name|unsigned
name|int
name|back
init|=
name|pGC
operator|->
name|bgPixel
decl_stmt|;
name|BoxRec
modifier|*
name|scl
decl_stmt|,
modifier|*
name|dcl
decl_stmt|,
name|sbox
decl_stmt|;
name|RegionPtr
name|prgnExposed
init|=
name|NULL
decl_stmt|;
name|int
name|srcx
decl_stmt|,
name|srcy
decl_stmt|,
name|dstx
decl_stmt|,
name|dsty
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|,
name|dboxes
decl_stmt|,
name|sboxes
decl_stmt|,
name|stx
decl_stmt|,
name|sty
decl_stmt|,
name|dtx
decl_stmt|,
name|dty
decl_stmt|,
name|lowlife
init|=
literal|0
decl_stmt|,
name|dst_stride
decl_stmt|,
name|src_stride
decl_stmt|,
name|the_real_src_stride
decl_stmt|,
name|j
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|free_plane
decl_stmt|,
name|w1
decl_stmt|,
name|h1
decl_stmt|,
name|w2
decl_stmt|,
name|h2
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|tx
decl_stmt|,
name|ty
decl_stmt|;
name|RegionPtr
name|sHitList
init|=
name|NULL
decl_stmt|;
comment|/* source hit list */
name|unsigned
name|char
modifier|*
name|presrc
decl_stmt|,
modifier|*
name|predst
decl_stmt|,
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|garbageBits
decl_stmt|,
name|bits
decl_stmt|;
name|unsigned
name|int
name|leadingBits
decl_stmt|,
name|trailingBits
decl_stmt|,
name|wholeBytes
decl_stmt|;
name|CARD8
modifier|*
name|psrc
decl_stmt|,
modifier|*
name|psrcLine
decl_stmt|,
modifier|*
name|pdstLine
decl_stmt|,
modifier|*
name|pdst
decl_stmt|;
name|unsigned
name|int
name|alu
decl_stmt|;
specifier|register
name|BoxPtr
name|btr
decl_stmt|;
name|CARD8
name|srcByte
decl_stmt|;
name|unsigned
name|int
name|rows
decl_stmt|;
name|unsigned
name|int
name|pixels
decl_stmt|;
specifier|static
name|unsigned
name|char
name|masks
index|[
literal|8
index|]
init|=
block|{
literal|0x1
block|,
literal|0x2
block|,
literal|0x4
block|,
literal|0x8
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|trailMasks
index|[
literal|8
index|]
init|=
block|{
literal|0x80
block|,
literal|0x40
block|,
literal|0x20
block|,
literal|0x10
block|,
literal|0x8
block|,
literal|0x4
block|,
literal|0x2
block|,
literal|0x1
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|pDstDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|WindowPtr
operator|)
name|pDstDrawable
operator|)
operator|->
name|realized
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|pDstDrawable
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
operator|)
operator|&&
operator|(
operator|(
call|(
name|PixmapPtr
call|)
argument_list|(
name|pDstDrawable
argument_list|)
operator|)
operator|->
name|devKind
operator|==
name|PIXMAP_HOST_MEMORY
operator|)
condition|)
block|{
comment|/* 	 * I don't want to handle 	 * all the replacement rules/planemasks for in-memory writes 	 */
return|return
name|cfbCopyPlane
argument_list|(
name|pSrcDrawable
argument_list|,
name|pDstDrawable
argument_list|,
name|pGC
argument_list|,
name|xIn
argument_list|,
name|yIn
argument_list|,
name|widthSrc
argument_list|,
name|heightSrc
argument_list|,
name|xOut
argument_list|,
name|yOut
argument_list|,
name|bitPlane
argument_list|)
return|;
block|}
name|dstx
operator|=
name|xOut
expr_stmt|;
name|dsty
operator|=
name|yOut
expr_stmt|;
name|width
operator|=
name|widthSrc
expr_stmt|;
name|height
operator|=
name|heightSrc
expr_stmt|;
comment|/* clip the left and top edges of the source */
if|if
condition|(
name|xIn
operator|<
literal|0
condition|)
block|{
name|width
operator|+=
name|xIn
expr_stmt|;
name|srcx
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|srcx
operator|=
name|xIn
expr_stmt|;
if|if
condition|(
name|yIn
operator|<
literal|0
condition|)
block|{
name|height
operator|+=
name|yIn
expr_stmt|;
name|srcy
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|srcy
operator|=
name|yIn
expr_stmt|;
comment|/*       * lookup or create the source clip lists       */
name|stx
operator|=
name|sty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pSrcDrawable
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
condition|)
block|{
comment|/* clip right and bottom edges of source */
if|if
condition|(
name|width
operator|>
name|pSrcDrawable
operator|->
name|width
condition|)
name|width
operator|=
name|pSrcDrawable
operator|->
name|width
expr_stmt|;
if|if
condition|(
name|height
operator|>
name|pSrcDrawable
operator|->
name|height
condition|)
name|height
operator|=
name|pSrcDrawable
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|DEVKIND
argument_list|(
name|pSrcDrawable
argument_list|)
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
block|{
name|stx
operator|=
name|PIXER
argument_list|(
name|pSrcDrawable
argument_list|)
operator|->
name|pChunk
operator|->
name|x
expr_stmt|;
name|sty
operator|=
name|PIXER
argument_list|(
name|pSrcDrawable
argument_list|)
operator|->
name|pChunk
operator|->
name|y
expr_stmt|;
block|}
name|sbox
operator|.
name|x2
operator|=
operator|(
name|sbox
operator|.
name|x1
operator|=
name|srcx
operator|)
operator|+
name|width
expr_stmt|;
name|sbox
operator|.
name|y2
operator|=
operator|(
name|sbox
operator|.
name|y1
operator|=
name|srcy
operator|)
operator|+
name|height
expr_stmt|;
name|scl
operator|=
operator|&
name|sbox
expr_stmt|;
name|sboxes
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* source is a window */
block|{
comment|/* translate window to screen coordinates */
name|srcx
operator|+=
name|pSrcDrawable
operator|->
name|x
expr_stmt|;
name|srcy
operator|+=
name|pSrcDrawable
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|pGC
operator|->
name|subWindowMode
operator|==
name|IncludeInferiors
condition|)
block|{
comment|/* included window can write over parent => overlap problem 	     *  (if included window is source and parent is dest) 	     */
if|if
condition|(
name|pDstDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
name|lowlife
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pSrcDrawable
operator|==
name|pDstDrawable
operator|&&
name|pGC
operator|->
name|clientClipType
operator|==
name|CT_NONE
condition|)
block|{
name|scl
operator|=
name|REGION_RECTS
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|sboxes
operator|=
name|REGION_NUM_RECTS
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* gotta create a new clip list */
block|{
name|sHitList
operator|=
name|NotClippedByChildren
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pSrcDrawable
argument_list|)
expr_stmt|;
name|scl
operator|=
name|REGION_RECTS
argument_list|(
name|sHitList
argument_list|)
expr_stmt|;
name|sboxes
operator|=
name|REGION_NUM_RECTS
argument_list|(
name|sHitList
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|scl
operator|=
name|REGION_RECTS
argument_list|(
operator|&
operator|(
operator|(
name|WindowPtr
operator|)
name|pSrcDrawable
operator|)
operator|->
name|clipList
argument_list|)
expr_stmt|;
name|sboxes
operator|=
name|REGION_NUM_RECTS
argument_list|(
operator|&
operator|(
operator|(
name|WindowPtr
operator|)
name|pSrcDrawable
operator|)
operator|->
name|clipList
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*       * lookup the dest clip list and any translation       */
name|dcl
operator|=
name|REGION_RECTS
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|dboxes
operator|=
name|REGION_NUM_RECTS
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|dtx
operator|=
name|dty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pDstDrawable
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
condition|)
block|{
if|if
condition|(
name|DEVKIND
argument_list|(
name|pDstDrawable
argument_list|)
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
block|{
name|dtx
operator|=
name|PIXER
argument_list|(
name|pDstDrawable
argument_list|)
operator|->
name|pChunk
operator|->
name|x
expr_stmt|;
name|dty
operator|=
name|PIXER
argument_list|(
name|pDstDrawable
argument_list|)
operator|->
name|pChunk
operator|->
name|y
expr_stmt|;
block|}
name|dst_stride
operator|=
name|PIXER
argument_list|(
name|pDstDrawable
argument_list|)
operator|->
name|stride
expr_stmt|;
name|predst
operator|=
name|PIXER
argument_list|(
name|pDstDrawable
argument_list|)
operator|->
name|bits
expr_stmt|;
block|}
else|else
comment|/* dest is a window */
block|{
if|if
condition|(
name|pGC
operator|->
name|miTranslate
condition|)
comment|/* translate window to screen coordinates */
block|{
name|dstx
operator|+=
name|pDstDrawable
operator|->
name|x
expr_stmt|;
name|dsty
operator|+=
name|pDstDrawable
operator|->
name|y
expr_stmt|;
block|}
name|dst_stride
operator|=
name|SCRMER
argument_list|(
name|pDstDrawable
argument_list|)
operator|->
name|stride
expr_stmt|;
name|predst
operator|=
name|SCRMER
argument_list|(
name|pDstDrawable
argument_list|)
operator|->
name|bits
expr_stmt|;
block|}
if|if
condition|(
name|pSrcDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
block|{
name|src_stride
operator|=
name|SCRMER
argument_list|(
name|pSrcDrawable
argument_list|)
operator|->
name|stride
expr_stmt|;
name|presrc
operator|=
name|SCRMER
argument_list|(
name|pSrcDrawable
argument_list|)
operator|->
name|bits
expr_stmt|;
block|}
else|else
block|{
name|src_stride
operator|=
name|PIXER
argument_list|(
name|pSrcDrawable
argument_list|)
operator|->
name|stride
expr_stmt|;
name|presrc
operator|=
name|PIXER
argument_list|(
name|pSrcDrawable
argument_list|)
operator|->
name|bits
expr_stmt|;
block|}
name|the_real_src_stride
operator|=
name|src_stride
expr_stmt|;
name|tx
operator|=
name|srcx
operator|-
name|dstx
expr_stmt|;
name|ty
operator|=
name|srcy
operator|-
name|dsty
expr_stmt|;
name|alu
operator|=
name|pGC
operator|->
name|alu
expr_stmt|;
comment|/*      * Set up the registers so that writing 0xff will get us the      * foreground and writing 0x00 will get the background with      * the proper replacement rule and plane enable      */
name|hardware
operator|->
name|write_enable
operator|=
name|planeMask
operator|&
operator|~
name|fore
operator|&
operator|~
name|back
expr_stmt|;
name|hardware
operator|->
name|pixel_write_replacement_rule
operator|=
name|XHP_NewRule
index|[
name|alu
index|]
index|[
literal|0
index|]
expr_stmt|;
name|hardware
operator|->
name|write_enable
operator|=
name|planeMask
operator|&
operator|~
name|fore
operator|&
name|back
expr_stmt|;
name|hardware
operator|->
name|pixel_write_replacement_rule
operator|=
name|XHP_NewRule
index|[
name|alu
index|]
index|[
literal|1
index|]
expr_stmt|;
name|hardware
operator|->
name|write_enable
operator|=
name|planeMask
operator|&
name|fore
operator|&
operator|~
name|back
expr_stmt|;
name|hardware
operator|->
name|pixel_write_replacement_rule
operator|=
name|XHP_NewRule
index|[
name|alu
index|]
index|[
literal|2
index|]
expr_stmt|;
name|hardware
operator|->
name|write_enable
operator|=
name|planeMask
operator|&
name|fore
operator|&
name|back
expr_stmt|;
name|hardware
operator|->
name|pixel_write_replacement_rule
operator|=
name|XHP_NewRule
index|[
name|alu
index|]
index|[
literal|3
index|]
expr_stmt|;
name|hardware
operator|->
name|frame_buf_write_enable
operator|=
name|planeMask
expr_stmt|;
for|for
control|(
init|;
name|sboxes
operator|--
condition|;
name|scl
operator|++
control|)
block|{
comment|/* for each source box */
comment|/* intersect src and src clip rectangle */
name|clipper
argument_list|(
name|srcx
argument_list|,
name|srcy
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|scl
operator|->
name|x1
argument_list|,
name|scl
operator|->
name|y1
argument_list|,
name|scl
operator|->
name|x2
argument_list|,
name|scl
operator|->
name|y2
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|w1
argument_list|,
operator|&
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|w1
operator|<=
literal|0
operator|||
name|h1
operator|<=
literal|0
condition|)
continue|continue;
name|a
operator|=
name|x1
operator|-
name|tx
expr_stmt|;
name|b
operator|=
name|y1
operator|-
name|ty
expr_stmt|;
name|c
operator|=
name|a
operator|+
name|w1
expr_stmt|;
name|d
operator|=
name|b
operator|+
name|h1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|dboxes
operator|,
name|btr
operator|=
name|dcl
init|;
name|j
operator|--
condition|;
name|btr
operator|++
control|)
block|{
name|free_plane
operator|=
name|FALSE
expr_stmt|;
comment|/* intersect dst and dst clip rectangles */
name|clipper
argument_list|(
name|dstx
argument_list|,
name|dsty
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|btr
operator|->
name|x1
argument_list|,
name|btr
operator|->
name|y1
argument_list|,
name|btr
operator|->
name|x2
argument_list|,
name|btr
operator|->
name|y2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|,
operator|&
name|w2
argument_list|,
operator|&
name|h2
argument_list|)
expr_stmt|;
if|if
condition|(
name|w2
operator|<=
literal|0
operator|||
name|h2
operator|<=
literal|0
condition|)
continue|continue;
comment|/* intersect clipped src and clipped dst rectangles */
name|clipper
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|,
name|w2
argument_list|,
name|h2
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|w1
argument_list|,
operator|&
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|w1
operator|<=
literal|0
operator|||
name|h1
operator|<=
literal|0
condition|)
continue|continue;
name|dst
operator|=
name|predst
operator|+
name|x1
operator|+
name|y1
operator|*
name|dst_stride
expr_stmt|;
if|if
condition|(
name|pSrcDrawable
operator|->
name|depth
operator|!=
literal|1
condition|)
block|{
comment|/* 		 * need to create a bitmap replica for the rest 		 * of this code to use 		 */
name|src
operator|=
name|presrc
operator|+
name|x1
operator|+
name|tx
operator|+
operator|(
name|y1
operator|+
name|ty
operator|)
operator|*
name|the_real_src_stride
expr_stmt|;
name|src
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hpGetPlane
argument_list|(
name|pSrcDrawable
argument_list|,
name|ffs
argument_list|(
name|bitPlane
argument_list|)
operator|-
literal|1
argument_list|,
name|src
argument_list|,
name|w1
argument_list|,
name|h1
argument_list|,
name|the_real_src_stride
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|src_stride
operator|=
name|PixmapBytePad
argument_list|(
name|w1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|leadingBits
operator|=
name|garbageBits
operator|=
literal|0
expr_stmt|;
name|free_plane
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
name|presrc
operator|+
name|src_stride
operator|*
operator|(
name|y1
operator|+
name|ty
operator|)
operator|+
operator|(
name|x1
operator|+
name|tx
operator|)
operator|/
literal|8
expr_stmt|;
name|garbageBits
operator|=
operator|(
name|x1
operator|+
name|tx
operator|)
operator|%
literal|8
expr_stmt|;
name|leadingBits
operator|=
literal|8
operator|-
name|garbageBits
expr_stmt|;
if|if
condition|(
name|leadingBits
operator|==
literal|8
condition|)
name|leadingBits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|leadingBits
operator|>
name|w1
condition|)
name|leadingBits
operator|=
name|w1
expr_stmt|;
block|}
name|wholeBytes
operator|=
operator|(
name|w1
operator|-
name|leadingBits
operator|)
operator|/
literal|8
expr_stmt|;
name|trailingBits
operator|=
name|w1
operator|-
operator|(
name|wholeBytes
operator|*
literal|8
operator|+
name|leadingBits
operator|)
expr_stmt|;
for|for
control|(
name|psrcLine
operator|=
name|src
operator|,
name|rows
operator|=
name|h1
operator|,
name|pixels
operator|=
name|w1
operator|,
name|pdstLine
operator|=
name|dst
init|;
name|rows
operator|--
condition|;
name|psrcLine
operator|+=
name|src_stride
operator|,
name|pdstLine
operator|+=
name|dst_stride
control|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
comment|/* 		 * write any leading bits one at a time until we're at a whole byte 		 */
if|if
condition|(
name|leadingBits
condition|)
block|{
name|srcByte
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|leadingBits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|srcByte
operator|&
name|masks
index|[
name|i
index|]
condition|)
operator|*
name|pdst
operator|++
operator|=
literal|0xff
expr_stmt|;
else|else
operator|*
name|pdst
operator|++
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
comment|/* 		 * write out all the whole bytes of bitmap 		 */
if|if
condition|(
operator|!
name|XHP_QUADALIGN
operator|||
operator|!
operator|(
operator|(
name|unsigned
name|int
operator|)
name|pdst
operator|&
literal|0x01
operator|)
condition|)
block|{
comment|/*  		     * either we're on a 68020, or we meet the alignment  		     * requirements of a 68010, so we write 4 pixels at a time  		     */
specifier|register
name|unsigned
name|int
modifier|*
name|pdstInt
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|pdst
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wholeBytes
condition|;
name|i
operator|++
control|)
block|{
name|srcByte
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
operator|*
name|pdstInt
operator|++
operator|=
name|XHP_pmap
index|[
name|srcByte
index|]
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|pdstInt
operator|++
operator|=
name|XHP_pmap
index|[
name|srcByte
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
name|pdst
operator|=
operator|(
name|CARD8
operator|*
operator|)
name|pdstInt
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * we're unaligned on a 310 (bummer...) 		     * so we have to write one byte at a time 		     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wholeBytes
condition|;
name|i
operator|++
control|)
block|{
name|srcByte
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
name|bits
operator|=
literal|8
expr_stmt|;
while|while
condition|(
name|bits
operator|--
condition|)
block|{
if|if
condition|(
name|srcByte
operator|&
name|masks
index|[
name|bits
index|]
condition|)
operator|*
name|pdst
operator|++
operator|=
literal|0xff
expr_stmt|;
else|else
operator|*
name|pdst
operator|++
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * write any trailing raggedy bits at the end of the row 		 */
if|if
condition|(
name|trailingBits
condition|)
block|{
name|srcByte
operator|=
operator|*
name|psrc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|trailingBits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|srcByte
operator|&
name|trailMasks
index|[
name|i
index|]
condition|)
operator|*
name|pdst
operator|++
operator|=
literal|0xff
expr_stmt|;
else|else
operator|*
name|pdst
operator|++
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
block|}
comment|/* free plane allocated by hpGetPlane */
if|if
condition|(
name|free_plane
condition|)
name|xfree
argument_list|(
operator|(
name|int
operator|*
operator|)
name|src
argument_list|)
expr_stmt|;
block|}
block|}
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDstDrawable
operator|->
name|pScreen
argument_list|,
literal|0xff
argument_list|,
name|alu
argument_list|)
expr_stmt|;
if|if
condition|(
name|pGC
operator|->
name|graphicsExposures
condition|)
name|prgnExposed
operator|=
name|miHandleExposures
argument_list|(
name|pSrcDrawable
argument_list|,
name|pDstDrawable
argument_list|,
name|pGC
argument_list|,
name|xIn
argument_list|,
name|yIn
argument_list|,
name|widthSrc
argument_list|,
name|heightSrc
argument_list|,
name|xOut
argument_list|,
name|yOut
argument_list|,
name|bitPlane
argument_list|)
expr_stmt|;
if|if
condition|(
name|sHitList
condition|)
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|RegionDestroy
call|)
argument_list|(
name|sHitList
argument_list|)
expr_stmt|;
return|return
name|prgnExposed
return|;
block|}
end_function

end_unit

