begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: /host/kaukau/disk2/X11R5/R5-hp300/mit/server/ddx/hpbsd/input/RCS/x_threebut.c,v 1.1 1992/09/30 03:14:10 root Exp $ */
end_comment

begin_comment
comment|/*******************************************************************  **  **    *********************************************************  **    *  **    *  File:          ddx/hp/hp/x_threebut.c  **    *  **    *  Contents:      Routines for processing button presses and  **    *                 emulating extra buttons when using HIL and serial  **    *                 pointing devices.  **    *  **    *  Created:       4/28/88  **    *  **    *  Last Change:   06/07/91  **    *  **    *  Last Release:  8.0  **    *  **    *  Revision:      A.01.00  **    *  **    *  Author:        --gms  **    *  **    *  Copyright:     (c) 1988 Hewlett-Packard Company  **    *  **    *********************************************************  **   ********************************************************************/
end_comment

begin_comment
comment|/********************************************************  Copyright (c) 1988 by Hewlett-Packard Company Copyright (c) 1988 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software  and its documentation for any purpose and without fee is hereby  granted, provided that the above copyright notice appear in all  copies and that both that copyright notice and this permission  notice appear in supporting documentation, and that the names of  Hewlett-Packard or  M.I.T.  not be used in advertising or publicity  pertaining to distribution of the software without specific, written  prior permission.  ********************************************************/
end_comment

begin_define
define|#
directive|define
name|NEED_EVENTS
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|__apollo
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__hp_osf
end_ifdef

begin_include
include|#
directive|include
file|<hp/hilioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"inputstr.h"
end_include

begin_include
include|#
directive|include
file|"hildef.h"
end_include

begin_include
include|#
directive|include
file|"XHPproto.h"
end_include

begin_include
include|#
directive|include
file|"x_serialdrv.h"
end_include

begin_define
define|#
directive|define
name|B1
value|0x01
end_define

begin_define
define|#
directive|define
name|B2
value|0x02
end_define

begin_define
define|#
directive|define
name|B3
value|0x04
end_define

begin_define
define|#
directive|define
name|B4
value|0x08
end_define

begin_define
define|#
directive|define
name|one_button_down
parameter_list|(
name|s
parameter_list|)
value|((s==B1 || s==B2 || s==B3 || s==B4) ? 1 : 0)
end_define

begin_decl_stmt
specifier|extern
name|u_char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
modifier|*
name|pkt_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pending_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pending_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|HPInputDevice
modifier|*
name|hpPointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|DeviceButtonPress
decl_stmt|,
name|DeviceButtonRelease
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|InputInfo
name|inputInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bool
name|button_latch_enabled
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|button_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|identity_map
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|swapped_map1
index|[]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HPInputDevice
modifier|*
name|bd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dev_info
modifier|*
name|devinfo
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
end_if

begin_decl_stmt
name|struct
name|timeval
name|wait_time
init|=
block|{
literal|0
block|,
literal|100000
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wait 1/10 second */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hpux */
end_comment

begin_function_decl
specifier|static
name|int
name|next_device_state
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|generate_buttons
argument_list|()
decl_stmt|,
name|put_button_event
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|look_for_next
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*************************************************************************  *   * This routine processes buttons from all input devices.  * Devices with 2 buttons emulate a third by pressing both.  * Devices with 3 buttons emulate 5 buttons by pressing two buttons at once.  * Button chording is enabled by default for two button mice, disabled by  * default for devices with three or more buttons.  * This can be overridden via the X*pointerkeys file.  *   */
end_comment

begin_function
name|void
name|process_button
parameter_list|(
name|ev
parameter_list|,
name|dev
parameter_list|,
name|hil_info
parameter_list|,
name|code
parameter_list|,
name|num_buttons
parameter_list|)
name|xEvent
modifier|*
name|ev
decl_stmt|;
name|DeviceIntPtr
name|dev
decl_stmt|;
name|struct
name|dev_info
modifier|*
name|hil_info
decl_stmt|;
name|u_char
name|code
decl_stmt|;
name|u_char
name|num_buttons
decl_stmt|;
block|{
name|int
name|old_state
decl_stmt|;
name|int
name|curstate
decl_stmt|;
specifier|extern
name|u_char
name|button_chording
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|inputInfo
operator|.
name|pointer
condition|)
name|bd
operator|=
name|hpPointer
expr_stmt|;
comment|/* logical device is X pointer */
else|else
name|bd
operator|=
name|hil_info
operator|->
name|hil_dev
expr_stmt|;
name|old_state
operator|=
name|bd
operator|->
name|button_state
expr_stmt|;
if|if
condition|(
name|num_buttons
operator|==
literal|2
operator|||
name|num_buttons
operator|==
literal|4
condition|)
name|button_map
operator|=
name|swapped_map1
expr_stmt|;
else|else
name|button_map
operator|=
name|identity_map
expr_stmt|;
name|devinfo
operator|=
name|hil_info
expr_stmt|;
name|curstate
operator|=
name|next_device_state
argument_list|(
name|dev
argument_list|,
name|ev
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|curstate
operator|==
name|ILLEGAL
condition|)
block|{
name|deallocate_event
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return;
block|}
name|bd
operator|->
name|button_state
operator|=
name|curstate
expr_stmt|;
if|if
condition|(
name|old_state
operator|==
literal|0
operator|&&
name|one_button_down
argument_list|(
name|curstate
argument_list|)
operator|&&
operator|(
operator|(
name|num_buttons
operator|==
literal|2
operator|&&
name|button_chording
operator|!=
name|CHORDING_OFF
operator|)
operator|||
name|button_chording
operator|==
name|CHORDING_ON
operator|)
condition|)
name|look_for_next
argument_list|(
operator|&
name|ev
argument_list|,
name|dev
argument_list|,
name|hil_info
argument_list|,
name|num_buttons
argument_list|,
operator|&
name|code
argument_list|)
expr_stmt|;
name|put_button_event
argument_list|(
name|dev
argument_list|,
name|ev
argument_list|,
name|hil_info
argument_list|,
name|bd
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***********************************************************************  *  * look_for_next ()  *  * If button chording is enabled, we look for a second button press within  * 100ms of the first.  *  */
end_comment

begin_define
define|#
directive|define
name|CORE_EVENT
value|0
end_define

begin_define
define|#
directive|define
name|EXTENSION_EVENT
value|1
end_define

begin_define
define|#
directive|define
name|FIRST_EXTENSION_EVENT
value|64
end_define

begin_define
define|#
directive|define
name|MAXNAMLEN
value|255
end_define

begin_define
define|#
directive|define
name|MOTION_BITS
value|3
end_define

begin_define
define|#
directive|define
name|NONDATA_BYTES
value|7
end_define

begin_function
specifier|static
name|void
name|look_for_next
parameter_list|(
name|ev
parameter_list|,
name|dev
parameter_list|,
name|hil_info
parameter_list|,
name|num_buttons
parameter_list|,
name|code
parameter_list|)
name|xEvent
modifier|*
modifier|*
name|ev
decl_stmt|;
name|DeviceIntPtr
name|dev
decl_stmt|;
name|struct
name|dev_info
modifier|*
name|hil_info
decl_stmt|;
name|int
name|num_buttons
decl_stmt|;
name|u_char
modifier|*
name|code
decl_stmt|;
block|{
specifier|extern
name|u_char
name|button_latching
decl_stmt|;
specifier|extern
name|int
name|data_cnt
decl_stmt|;
name|u_char
name|nxt_button
decl_stmt|;
name|int
name|i
decl_stmt|,
name|curstate
decl_stmt|;
name|int
name|button_ds
decl_stmt|;
comment|/* file descriptor of device. */
name|xEvent
modifier|*
name|format_ev
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|__hp_osf
specifier|extern
name|HPInputDevice
name|l_devs
index|[
name|MAX_LOGICAL_DEVS
index|]
decl_stmt|;
name|unsigned
name|int
name|curtime
decl_stmt|,
name|start
decl_stmt|;
name|char
name|dev_name
index|[
name|MAXNAMLEN
index|]
decl_stmt|;
name|Bool
name|evflag
init|=
name|FALSE
decl_stmt|;
name|u_char
modifier|*
name|lbuf
decl_stmt|;
specifier|extern
name|HILQ
modifier|*
name|hil_qp
decl_stmt|;
name|int
name|j
decl_stmt|,
name|head
decl_stmt|,
name|tmp
decl_stmt|,
name|index
decl_stmt|;
endif|#
directive|endif
name|button_ds
operator|=
name|hil_info
operator|->
name|hil_dev
operator|->
name|file_ds
expr_stmt|;
if|if
condition|(
name|pending_index
operator|<
name|pending_bytes
condition|)
comment|/* already have next button */
name|nxt_button
operator|=
name|hil_info
operator|->
name|dev_data
index|[
name|pending_index
operator|++
index|]
expr_stmt|;
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|__hp_osf
argument_list|)
comment|/* 	 * OSF has a shared memory input events queue.  We use select() to 	 * wait 100ms, then check to see if a second button press is in the 	 * queue.  If we find another button event from the same device, we 	 * remove it from the queue, otherwise we return. 	 * 	 */
name|head
operator|=
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|head
expr_stmt|;
name|lbuf
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|hil_qp
operator|->
name|hil_event
index|[
name|head
index|]
operator|.
name|tstamp
expr_stmt|;
name|start
operator|=
operator|(
operator|(
operator|*
name|lbuf
operator|&
literal|0x0ff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|lbuf
operator|+
literal|1
operator|)
operator|&
literal|0x0ff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|lbuf
operator|+
literal|2
operator|)
operator|&
literal|0x0ff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
operator|(
name|lbuf
operator|+
literal|3
operator|)
operator|&
literal|0x0ff
operator|)
expr_stmt|;
name|select
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|wait_time
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
operator|(
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|head
operator|+
literal|1
operator|)
operator|%
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|size
operator|,
name|curtime
operator|=
name|start
init|;
name|tmp
operator|!=
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|tail
operator|&&
name|curtime
operator|<
name|start
operator|+
literal|10000
condition|;
name|tmp
operator|=
operator|(
name|tmp
operator|+
literal|1
operator|)
operator|%
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|size
control|)
block|{
name|sprintf
argument_list|(
name|dev_name
argument_list|,
literal|"/dev/hil%d"
argument_list|,
name|hil_qp
operator|->
name|hil_event
index|[
name|tmp
index|]
operator|.
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_LOGICAL_DEVS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|l_devs
index|[
name|i
index|]
operator|.
name|dev_name
argument_list|,
name|dev_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|MAX_LOGICAL_DEVS
condition|)
name|FatalError
argument_list|(
literal|"Can't find input device %s\n"
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
name|lbuf
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|hil_qp
operator|->
name|hil_event
index|[
name|tmp
index|]
operator|.
name|tstamp
expr_stmt|;
name|curtime
operator|=
operator|(
operator|(
operator|*
name|lbuf
operator|&
literal|0x0ff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|lbuf
operator|+
literal|1
operator|)
operator|&
literal|0x0ff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|lbuf
operator|+
literal|2
operator|)
operator|&
literal|0x0ff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
operator|(
name|lbuf
operator|+
literal|3
operator|)
operator|&
literal|0x0ff
operator|)
expr_stmt|;
if|if
condition|(
operator|&
name|l_devs
index|[
name|i
index|]
operator|!=
name|hil_info
operator|->
name|hil_dev
condition|)
comment|/* wrong device */
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|hil_qp
operator|->
name|hil_event
index|[
name|tmp
index|]
operator|.
name|poll_hdr
operator|&
name|SET1_KEY_MASK
operator|)
condition|)
block|{
continue|continue;
comment|/* not a button event */
block|}
if|if
condition|(
operator|!
operator|(
name|hil_qp
operator|->
name|hil_event
index|[
name|tmp
index|]
operator|.
name|poll_hdr
operator|&
name|MOTION_BITS
operator|)
condition|)
name|index
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|l_devs
index|[
name|i
index|]
operator|.
name|hil_header
operator|.
name|flags
operator|&
name|HIL_16_BITS
condition|)
name|index
operator|=
operator|(
name|hil_qp
operator|->
name|hil_event
index|[
name|tmp
index|]
operator|.
name|poll_hdr
operator|&
name|MOTION_BITS
operator|)
operator|*
literal|2
expr_stmt|;
else|else
name|index
operator|=
name|hil_qp
operator|->
name|hil_event
index|[
name|tmp
index|]
operator|.
name|poll_hdr
operator|&
name|MOTION_BITS
expr_stmt|;
if|if
condition|(
name|hil_qp
operator|->
name|hil_event
index|[
name|tmp
index|]
operator|.
name|dev_data
index|[
name|index
index|]
operator|>=
name|BUTTON_BASE
operator|&&
name|hil_qp
operator|->
name|hil_event
index|[
name|tmp
index|]
operator|.
name|dev_data
index|[
name|index
index|]
operator|<
name|PROXIMITY_IN
condition|)
block|{
name|hil_info
operator|->
name|poll_hdr
operator|=
name|hil_qp
operator|->
name|hil_event
index|[
name|tmp
index|]
operator|.
name|poll_hdr
operator|&
name|HIL_POLL_HDR_BITS
expr_stmt|;
name|pending_index
operator|=
literal|0
expr_stmt|;
name|pending_bytes
operator|=
name|hil_qp
operator|->
name|hil_event
index|[
name|tmp
index|]
operator|.
name|size
operator|-
name|NONDATA_BYTES
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pending_bytes
condition|;
name|j
operator|++
control|)
name|hil_info
operator|->
name|dev_data
index|[
name|j
index|]
operator|=
name|hil_qp
operator|->
name|hil_event
index|[
name|tmp
index|]
operator|.
name|dev_data
index|[
name|j
index|]
expr_stmt|;
name|j
operator|=
name|tmp
expr_stmt|;
while|while
condition|(
name|j
operator|>
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|head
condition|)
block|{
name|hil_qp
operator|->
name|hil_event
index|[
name|j
index|]
operator|=
name|hil_qp
operator|->
name|hil_event
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|head
operator|=
operator|(
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|head
operator|+
literal|1
operator|)
operator|%
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|size
expr_stmt|;
name|evflag
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|evflag
condition|)
return|return;
endif|#
directive|endif
comment|/* __hp_osf */
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
comment|/* 	 * If data_cnt is> 0, the button has been read into a global buffer. 	 * If not, select on the proper device and wait 100ms. 	 * 	 */
if|if
condition|(
name|data_cnt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hil_info
operator|->
name|hil_dev
operator|->
name|hpflags
operator|&
name|IS_SERIAL_DEVICE
condition|)
block|{
name|get_serial_event
argument_list|(
name|hil_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hil_info
operator|->
name|poll_hdr
operator|&
name|BUTTON_DATA
operator|)
condition|)
return|return;
name|hil_info
operator|->
name|dev_data
index|[
name|pending_index
index|]
operator|+=
name|BUTTON_BASE
expr_stmt|;
block|}
else|else
block|{
name|get_hil_event
argument_list|(
name|button_ds
argument_list|,
name|hil_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hil_info
operator|->
name|poll_hdr
operator|&
name|SET1_KEY_MASK
operator|)
condition|)
return|return;
if|if
condition|(
name|hil_info
operator|->
name|poll_hdr
operator|&
name|MOTION_MASK
condition|)
block|{
name|handle_motion_event
argument_list|(
name|dev
argument_list|,
name|hil_info
operator|->
name|hil_dev
argument_list|,
name|hil_info
argument_list|)
expr_stmt|;
name|hil_info
operator|->
name|poll_hdr
operator|&=
operator|~
name|MOTION_MASK
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|mask
init|=
literal|1
operator|<<
name|button_ds
decl_stmt|;
if|if
condition|(
name|select
argument_list|(
name|button_ds
operator|+
literal|1
argument_list|,
operator|&
name|mask
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|wait_time
argument_list|)
operator|<=
literal|0
condition|)
return|return;
else|else
block|{
name|pkt_ptr
operator|=
name|buf
expr_stmt|;
name|data_cnt
operator|=
name|read
argument_list|(
name|button_ds
argument_list|,
name|buf
argument_list|,
name|READ_SIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_cnt
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|hil_info
operator|->
name|hil_dev
operator|->
name|hpflags
operator|&
name|IS_SERIAL_DEVICE
condition|)
block|{
name|get_serial_event
argument_list|(
name|hil_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hil_info
operator|->
name|poll_hdr
operator|&
name|BUTTON_DATA
operator|)
condition|)
return|return;
name|hil_info
operator|->
name|dev_data
index|[
name|pending_index
index|]
operator|+=
name|BUTTON_BASE
expr_stmt|;
block|}
else|else
block|{
name|get_hil_event
argument_list|(
name|button_ds
argument_list|,
name|hil_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hil_info
operator|->
name|poll_hdr
operator|&
name|SET1_KEY_MASK
operator|)
condition|)
return|return;
if|if
condition|(
name|hil_info
operator|->
name|poll_hdr
operator|&
name|MOTION_MASK
condition|)
block|{
name|handle_motion_event
argument_list|(
name|dev
argument_list|,
name|hil_info
operator|->
name|hil_dev
argument_list|,
name|hil_info
argument_list|)
expr_stmt|;
name|hil_info
operator|->
name|poll_hdr
operator|&=
operator|~
name|MOTION_MASK
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* __hpux */
if|#
directive|if
name|defined
argument_list|(
name|__apollo
argument_list|)
comment|/* 	 * If data_cnt is> 0, the button has been read into a global buffer. 	 * If not, select on the proper device and wait 100ms. 	 * 	 */
block|{
name|int
name|mask
init|=
literal|1
operator|<<
name|button_ds
decl_stmt|;
name|struct
name|timeval
name|wait_time
decl_stmt|;
comment|/* wait 1/10 second */
name|wait_time
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|wait_time
operator|.
name|tv_usec
operator|=
literal|100000
expr_stmt|;
if|if
condition|(
name|hil_info
operator|->
name|hil_dev
operator|->
name|hpflags
operator|&
name|IS_SERIAL_DEVICE
condition|)
if|if
condition|(
name|data_cnt
operator|!=
literal|0
condition|)
block|{
name|get_serial_event
argument_list|(
name|hil_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hil_info
operator|->
name|poll_hdr
operator|&
name|BUTTON_DATA
operator|)
condition|)
return|return;
name|hil_info
operator|->
name|dev_data
index|[
name|pending_index
index|]
operator|+=
name|BUTTON_BASE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|select
argument_list|(
name|button_ds
operator|+
literal|1
argument_list|,
operator|&
name|mask
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|wait_time
argument_list|)
operator|<=
literal|0
condition|)
return|return;
else|else
block|{
name|pkt_ptr
operator|=
name|buf
expr_stmt|;
name|data_cnt
operator|=
name|read
argument_list|(
name|button_ds
argument_list|,
name|buf
argument_list|,
name|READ_SIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_cnt
operator|<=
literal|0
condition|)
return|return;
name|get_serial_event
argument_list|(
name|hil_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hil_info
operator|->
name|poll_hdr
operator|&
name|BUTTON_DATA
operator|)
condition|)
return|return;
name|hil_info
operator|->
name|dev_data
index|[
name|pending_index
index|]
operator|+=
name|BUTTON_BASE
expr_stmt|;
block|}
else|else
block|{
name|select
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|wait_time
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_next_button
argument_list|(
name|hil_info
argument_list|)
condition|)
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* __apollo */
if|if
condition|(
name|hil_info
operator|->
name|hil_dev
operator|->
name|hpflags
operator|&
name|DATA_IS_8_BITS
condition|)
name|nxt_button
operator|=
operator|(
name|hil_info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
operator|++
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|hil_info
operator|->
name|hil_dev
operator|->
name|hpflags
operator|&
name|DATA_IS_16_BITS
condition|)
block|{
name|nxt_button
operator|=
operator|(
operator|(
name|hil_info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|hil_info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
index|]
expr_stmt|;
name|pending_index
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hil_info
operator|->
name|hil_dev
operator|->
name|hpflags
operator|&
name|DATA_IS_32_BITS
condition|)
block|{
name|nxt_button
operator|=
operator|(
operator|(
name|hil_info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
operator|+
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|hil_info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
operator|+
literal|2
index|]
operator|<<
literal|16
operator||
operator|(
name|hil_info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
operator|+
literal|1
index|]
operator|<<
literal|8
operator||
operator|(
name|hil_info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
index|]
expr_stmt|;
name|pending_index
operator|+=
literal|4
expr_stmt|;
block|}
block|}
comment|/*      * We've read another button, now see if it's valid and check that it is      * a combination that causes button chording.      *      */
name|curstate
operator|=
name|next_device_state
argument_list|(
name|dev
argument_list|,
operator|*
name|ev
argument_list|,
name|nxt_button
argument_list|)
expr_stmt|;
if|if
condition|(
name|curstate
operator|==
name|ILLEGAL
condition|)
block|{
name|deallocate_event
argument_list|(
operator|*
name|ev
argument_list|)
expr_stmt|;
return|return;
block|}
name|bd
operator|->
name|button_state
operator|=
name|curstate
expr_stmt|;
if|if
condition|(
name|curstate
operator|==
literal|3
operator|&&
name|num_buttons
operator|==
literal|2
condition|)
block|{
operator|*
name|code
operator|=
literal|0x84
expr_stmt|;
name|bd
operator|->
name|ignoremask
operator|=
literal|0x03
expr_stmt|;
name|bd
operator|->
name|savebutton
operator|=
literal|0x85
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|curstate
operator|==
literal|3
operator|&&
name|num_buttons
operator|==
literal|3
condition|)
block|{
operator|*
name|code
operator|=
literal|0x86
expr_stmt|;
name|bd
operator|->
name|ignoremask
operator|=
literal|0x03
expr_stmt|;
name|bd
operator|->
name|savebutton
operator|=
literal|0x87
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|curstate
operator|==
literal|6
operator|&&
name|num_buttons
operator|==
literal|3
condition|)
block|{
operator|*
name|code
operator|=
literal|0x88
expr_stmt|;
name|bd
operator|->
name|ignoremask
operator|=
literal|0x06
expr_stmt|;
name|bd
operator|->
name|savebutton
operator|=
literal|0x89
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|curstate
operator|==
literal|5
condition|)
block|{
if|if
condition|(
name|num_buttons
operator|==
literal|4
condition|)
block|{
operator|*
name|code
operator|=
literal|0x88
expr_stmt|;
name|bd
operator|->
name|ignoremask
operator|=
literal|0x05
expr_stmt|;
name|bd
operator|->
name|savebutton
operator|=
literal|0x89
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|button_latching
operator|==
name|LATCHING_ON
condition|)
block|{
name|button_latch_enabled
operator|=
operator|~
name|button_latch_enabled
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|bd
operator|->
name|hil_header
operator|.
name|v_button_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|button_latch_enabled
condition|)
name|LatchButton
argument_list|(
name|bd
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|UnlatchButton
argument_list|(
name|bd
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|ignoremask
operator|=
literal|0x05
expr_stmt|;
name|bd
operator|->
name|savebutton
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|put_button_event
argument_list|(
name|dev
argument_list|,
operator|*
name|ev
argument_list|,
name|hil_info
argument_list|,
name|bd
argument_list|,
operator|*
name|code
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|nxt_button
expr_stmt|;
operator|*
name|ev
operator|=
name|format_ev
argument_list|(
operator|(
operator|*
name|ev
operator|)
operator|->
name|u
operator|.
name|u
operator|.
name|type
argument_list|,
operator|*
name|code
argument_list|,
name|hil_info
operator|->
name|timestamp
argument_list|,
name|bd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************  *  * next_device_state (button)  *	  *  */
end_comment

begin_function
specifier|static
name|int
name|next_device_state
parameter_list|(
name|dev
parameter_list|,
name|ev
parameter_list|,
name|code
parameter_list|)
name|DeviceIntPtr
name|dev
decl_stmt|;
name|xEvent
modifier|*
name|ev
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|int
name|illegal
decl_stmt|;
name|int
name|button
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|new_state
init|=
name|bd
operator|->
name|button_state
decl_stmt|;
name|button
operator|=
operator|(
name|code
operator|-
name|BUTTON_1_OFFSET
operator|)
operator|/
literal|2
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
name|button
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|code
operator|&
literal|1
condition|)
name|illegal
operator|=
operator|!
operator|(
name|new_state
operator|&
name|mask
operator|)
expr_stmt|;
else|else
name|illegal
operator|=
name|new_state
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|illegal
condition|)
block|{
name|generate_buttons
argument_list|(
name|dev
argument_list|,
name|ev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ILLEGAL
operator|)
return|;
block|}
if|if
condition|(
name|code
operator|&
literal|1
condition|)
name|new_state
operator|&=
operator|~
name|mask
expr_stmt|;
else|else
name|new_state
operator||=
name|mask
expr_stmt|;
return|return
operator|(
name|new_state
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************  *   * generate_buttons ()	  *	If we get here, it is because the HIL driver has lost some data.  *	This can happen if the server is busy and the driver's buffer  *	overflows.    *	If we have lost a single button release, ignore the next press and the  *	corresponding release will fix it.  *      If both buttons are down, or the middle button is down, we can't tell  *      if we lost one or both of the button releases.  We assume we lost both.  *        */
end_comment

begin_function
specifier|static
name|void
name|generate_buttons
parameter_list|(
name|dev
parameter_list|,
name|ev
parameter_list|)
name|DeviceIntPtr
name|dev
decl_stmt|;
name|xEvent
modifier|*
name|ev
decl_stmt|;
block|{
name|bd
operator|->
name|button_state
operator|&=
operator|~
name|bd
operator|->
name|ignoremask
expr_stmt|;
if|if
condition|(
name|bd
operator|->
name|ignoremask
operator|!=
literal|0
condition|)
name|put_button_event
argument_list|(
name|dev
argument_list|,
name|ev
argument_list|,
name|devinfo
argument_list|,
name|bd
argument_list|,
name|bd
operator|->
name|savebutton
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd
operator|->
name|button_state
operator|&
literal|1
condition|)
name|put_button_event
argument_list|(
name|dev
argument_list|,
name|ev
argument_list|,
name|devinfo
argument_list|,
name|bd
argument_list|,
literal|0x81
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd
operator|->
name|button_state
operator|&
literal|2
condition|)
name|put_button_event
argument_list|(
name|dev
argument_list|,
name|ev
argument_list|,
name|devinfo
argument_list|,
name|bd
argument_list|,
literal|0x83
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd
operator|->
name|button_state
operator|&
literal|4
condition|)
name|put_button_event
argument_list|(
name|dev
argument_list|,
name|ev
argument_list|,
name|devinfo
argument_list|,
name|bd
argument_list|,
literal|0x85
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd
operator|->
name|button_state
operator|&
literal|8
condition|)
name|put_button_event
argument_list|(
name|dev
argument_list|,
name|ev
argument_list|,
name|devinfo
argument_list|,
name|bd
argument_list|,
literal|0x87
argument_list|)
expr_stmt|;
name|bd
operator|->
name|button_state
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/***********************************************************************  *  * put_button_event (hil_info)  *  * The event is on the server's internal queue and will be sent to DIX,  * unless we "deallocate" it (remove it from that queue) here.    * We deallocate it if:  *  * 1). It's an up transition, the first of a chorded pair.  For example, if  *     the left and middle mouse buttons have been chorded to generate button 4,  *     and the left button goes up, we want to ignore it until the middle button  *     also goes up, then send the up transition for button 4.  *  * 2). It has a code of 0.  This means that it was the left-right button  *     combination used to turn on button latching.  *  * 3). It's an up transition and button latching is enabled.  We'll send the  *     up transition the second time the button is pressed.  *  * 4). Some test process is stealing these buttons and doesn't want real clients  *     to see them.  *  */
end_comment

begin_function
specifier|static
name|void
name|put_button_event
parameter_list|(
name|dev
parameter_list|,
name|ev
parameter_list|,
name|hil_info
parameter_list|,
name|p
parameter_list|,
name|code
parameter_list|)
name|DeviceIntPtr
name|dev
decl_stmt|;
name|xEvent
modifier|*
name|ev
decl_stmt|;
name|struct
name|dev_info
modifier|*
name|hil_info
decl_stmt|;
name|HPInputDevice
modifier|*
name|p
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|XTESTEXT1
specifier|extern
name|int
name|on_steal_input
decl_stmt|;
comment|/* steal input mode is on.	*/
specifier|extern
name|int
name|exclusive_steal
decl_stmt|;
endif|#
directive|endif
comment|/* XTESTEXT1 */
if|if
condition|(
name|bd
operator|->
name|sent_button
condition|)
comment|/* sent a chorded button */
if|if
condition|(
name|bd
operator|->
name|button_state
operator|&
name|bd
operator|->
name|ignoremask
condition|)
comment|/* first of pair is going up */
block|{
name|deallocate_event
argument_list|(
name|ev
argument_list|)
expr_stmt|;
comment|/* remove it from the queue */
return|return;
block|}
elseif|else
if|if
condition|(
name|bd
operator|->
name|ignoremask
operator|!=
literal|0
condition|)
comment|/* second of pair is going up */
block|{
name|bd
operator|->
name|ignoremask
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|sent_button
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|bd
operator|->
name|savebutton
expr_stmt|;
comment|/* use saved chorded code */
block|}
if|if
condition|(
name|bd
operator|->
name|ignoremask
operator|!=
literal|0
condition|)
comment|/* This is a chorded button */
name|bd
operator|->
name|sent_button
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
comment|/* "enable latching" case   */
block|{
name|deallocate_event
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return;
block|}
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
operator|=
name|button_map
index|[
operator|(
name|code
operator|-
name|BUTTON_BASE
operator|)
operator|/
literal|2
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ButtonIsLatched
argument_list|(
name|hil_info
operator|->
name|hil_dev
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|)
condition|)
if|if
condition|(
name|ButtonIsIgnored
argument_list|(
name|hil_info
operator|->
name|hil_dev
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|)
condition|)
block|{
if|if
condition|(
name|ButtonDownEvent
argument_list|(
name|ev
argument_list|)
condition|)
name|UnignoreButton
argument_list|(
name|hil_info
operator|->
name|hil_dev
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|)
expr_stmt|;
name|deallocate_event
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ButtonDownEvent
argument_list|(
name|ev
argument_list|)
condition|)
name|IgnoreButton
argument_list|(
name|hil_info
operator|->
name|hil_dev
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|&
name|UP_MASK
condition|)
comment|/* up event was generated */
if|if
condition|(
name|dev
operator|==
name|inputInfo
operator|.
name|pointer
condition|)
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|type
operator|=
name|ButtonRelease
expr_stmt|;
else|else
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|type
operator|=
name|DeviceButtonRelease
expr_stmt|;
elseif|else
if|if
condition|(
name|dev
operator|==
name|inputInfo
operator|.
name|pointer
condition|)
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|type
operator|=
name|ButtonPress
expr_stmt|;
else|else
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|type
operator|=
name|DeviceButtonPress
expr_stmt|;
ifdef|#
directive|ifdef
name|XTESTEXT1
if|if
condition|(
name|on_steal_input
condition|)
name|XTestStealKeyData
argument_list|(
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|type
argument_list|,
name|MOUSE
argument_list|,
name|p
operator|->
name|coords
index|[
literal|0
index|]
argument_list|,
name|p
operator|->
name|coords
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|exclusive_steal
condition|)
name|deallocate_event
argument_list|(
name|ev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XTESTEXT1 */
block|}
end_function

end_unit

