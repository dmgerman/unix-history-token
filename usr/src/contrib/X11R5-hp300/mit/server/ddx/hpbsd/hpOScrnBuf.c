begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (c) 1986, 1987 by Hewlett-Packard Company Copyright (c) 1986, 1987 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD TO THIS SOFWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE.  Hewlett-Packard shall not be liable for errors  contained herein or direct, indirect, special, incidental or  consequential damages in connection with the furnishing,  performance, or use of this material.  This software is not subject to any license of the American Telephone and Telegraph Company or of the Regents of the University of California.  */
end_comment

begin_comment
comment|/***********************************************************************  *  file: hpbuf.c  *  *  *  ******************************************************************  *  *  (c) Copyright Hewlett-Packard Company, 1986.  All rights are  *  *  *  reserved.  Copying or other reproduction of this program      *  *  *  except for archival purposes is prohibited without prior      *  *  *  written consent of Hewlett-Packard Company.		     *  *  ******************************************************************  *  *  Off-screen display buffer allocator   *  *		Hewlett Packard -- Corvallis Workstation Operation  *		Project -- port of X to HP9000S300  *		Dan Garfinkel -- MTS  *              Bob Leichner -- MTS - port of allocator to X11  *  *  */
end_comment

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"hppriv.h"
end_include

begin_include
include|#
directive|include
file|"topcat/topcat.h"
end_include

begin_define
define|#
directive|define
name|USED
value|0
end_define

begin_define
define|#
directive|define
name|UNUSED
value|1
end_define

begin_define
define|#
directive|define
name|CNODE
value|2
end_define

begin_decl_stmt
specifier|static
name|hpBufAllocInfoPtr
name|screenBufs
index|[
name|MAXSCREENS
index|]
init|=
block|{
operator|(
name|hpBufAllocInfoPtr
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|combine
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hpChunk
modifier|*
name|getchunk
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * hpBufAlloc and hpBufFree are the off-screen memory buffer allocate   *	and free routines. hpBufAllocInit initializes the buffer allocator.  */
end_comment

begin_function
name|void
name|hpBufAllocInit
parameter_list|(
name|pScreen
parameter_list|,
name|XHP_stride
parameter_list|,
name|XHP_memheight
parameter_list|,
name|XHP_width
parameter_list|,
name|XHP_height
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
name|int
name|XHP_stride
decl_stmt|,
name|XHP_memheight
decl_stmt|,
name|XHP_width
decl_stmt|,
name|XHP_height
decl_stmt|;
block|{
specifier|register
name|hpBufAllocInfoPtr
name|allocInfo
decl_stmt|;
specifier|register
name|hpChunk
modifier|*
name|ch1
decl_stmt|,
modifier|*
name|ch2
decl_stmt|;
name|hpPrivScreenPtr
name|pPrivScreen
init|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
name|allocInfo
operator|=
name|screenBufs
index|[
name|pScreen
operator|->
name|myNum
index|]
expr_stmt|;
if|if
condition|(
name|allocInfo
operator|==
operator|(
name|hpBufAllocInfoPtr
operator|)
name|NULL
condition|)
block|{
name|allocInfo
operator|=
operator|(
name|hpBufAllocInfoPtr
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hpBufAllocInfo
argument_list|)
argument_list|)
expr_stmt|;
name|allocInfo
operator|->
name|initialized
operator|=
literal|0
expr_stmt|;
name|screenBufs
index|[
name|pScreen
operator|->
name|myNum
index|]
operator|=
name|allocInfo
expr_stmt|;
block|}
name|pPrivScreen
operator|->
name|pBufAllocInfo
operator|=
operator|(
name|pointer
operator|)
name|screenBufs
index|[
name|pScreen
operator|->
name|myNum
index|]
expr_stmt|;
comment|/*      * if initialized, free any storage currently in use.      */
if|if
condition|(
name|allocInfo
operator|->
name|initialized
condition|)
block|{
name|ch1
operator|=
name|allocInfo
operator|->
name|used
expr_stmt|;
while|while
condition|(
name|ch1
condition|)
block|{
name|ch2
operator|=
name|ch1
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|ch1
argument_list|)
expr_stmt|;
name|ch1
operator|=
name|ch2
expr_stmt|;
block|}
name|ch1
operator|=
name|allocInfo
operator|->
name|unused
expr_stmt|;
while|while
condition|(
name|ch1
condition|)
block|{
name|ch2
operator|=
name|ch1
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|ch1
argument_list|)
expr_stmt|;
name|ch1
operator|=
name|ch2
expr_stmt|;
block|}
block|}
name|allocInfo
operator|->
name|used
operator|=
operator|(
name|hpChunk
operator|*
operator|)
name|NULL
expr_stmt|;
name|allocInfo
operator|->
name|unused
operator|=
operator|(
name|hpChunk
operator|*
operator|)
name|NULL
expr_stmt|;
switch|switch
condition|(
name|pPrivScreen
operator|->
name|gcid
condition|)
block|{
case|case
name|GCID_TOPCAT
case|:
comment|/* got to check if it's a Catseye too! */
block|{
name|TOPCAT
modifier|*
name|gp_hardware
init|=
name|getTcHardware
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|getchunk
argument_list|(
name|allocInfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|XHP_stride
argument_list|,
name|XHP_memheight
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp_hardware
operator|->
name|id_second
operator|<=
name|ID2_LCC
operator|||
name|gp_hardware
operator|->
name|id_second
operator|==
name|ID2_CC
condition|)
name|allocInfo
operator|->
name|firstcol
operator|=
literal|0
expr_stmt|;
else|else
name|allocInfo
operator|->
name|firstcol
operator|=
name|XHP_width
expr_stmt|;
block|}
break|break;
case|case
name|GCID_GATORBOX
case|:
operator|(
name|void
operator|)
name|getchunk
argument_list|(
name|allocInfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|XHP_width
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|allocInfo
operator|->
name|firstcol
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GCID_RENAISSANCE
case|:
operator|(
name|void
operator|)
name|getchunk
argument_list|(
name|allocInfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|XHP_stride
argument_list|,
name|XHP_height
argument_list|)
expr_stmt|;
name|allocInfo
operator|->
name|firstcol
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GCID_DAVINCI
case|:
case|case
name|GCID_HYPERION
case|:
operator|(
name|void
operator|)
name|getchunk
argument_list|(
name|allocInfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|XHP_stride
argument_list|,
name|XHP_height
argument_list|)
expr_stmt|;
name|allocInfo
operator|->
name|firstcol
operator|=
name|XHP_width
expr_stmt|;
break|break;
block|}
name|allocInfo
operator|->
name|unused
operator|->
name|parent
operator|=
operator|(
name|hpCnode
operator|*
operator|)
literal|0
expr_stmt|;
name|allocInfo
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|hpChunk
modifier|*
name|hpBufAlloc
parameter_list|(
name|pScreen
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
function|register h
operator|,
function|w;
end_function

begin_block
block|{
specifier|register
name|hpChunk
modifier|*
name|me
decl_stmt|,
modifier|*
name|ch1
decl_stmt|,
modifier|*
name|ch2
decl_stmt|;
specifier|register
name|hpCnode
modifier|*
name|p
decl_stmt|;
specifier|register
name|hpBufAllocInfoPtr
name|allocInfo
init|=
name|screenBufs
index|[
name|pScreen
operator|->
name|myNum
index|]
decl_stmt|;
if|if
condition|(
name|allocInfo
operator|==
operator|(
name|hpBufAllocInfoPtr
operator|)
name|NULL
condition|)
comment|/* called without initialization. */
return|return
operator|(
name|hpChunk
operator|*
operator|)
literal|0
return|;
comment|/*      * check for h and w in range      */
if|if
condition|(
name|h
operator|<=
literal|0
operator|||
name|w
operator|<=
literal|0
condition|)
return|return
operator|(
name|hpChunk
operator|*
operator|)
literal|0
return|;
comment|/*      * set if there are any unused chunks      */
if|if
condition|(
name|allocInfo
operator|->
name|unused
operator|==
operator|(
name|hpChunk
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
name|hpChunk
operator|*
operator|)
literal|0
return|;
comment|/* pad buffer request to a word boundary, needed for s800 and hp310      * machines */
while|while
condition|(
name|w
operator|%
literal|4
operator|!=
literal|0
condition|)
name|w
operator|++
expr_stmt|;
comment|/*      * find an unused chunk of the closest size      */
name|me
operator|=
operator|(
name|hpChunk
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|ch1
operator|=
name|allocInfo
operator|->
name|unused
init|;
name|ch1
operator|!=
operator|(
name|hpChunk
operator|*
operator|)
literal|0
condition|;
name|ch1
operator|=
name|ch1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ch1
operator|->
name|h
operator|>=
name|h
operator|&&
name|ch1
operator|->
name|w
operator|>=
name|w
condition|)
block|{
if|if
condition|(
name|me
operator|==
operator|(
name|hpChunk
operator|*
operator|)
literal|0
condition|)
name|me
operator|=
name|ch1
expr_stmt|;
elseif|else
if|if
condition|(
name|ch1
operator|->
name|h
operator|<
name|me
operator|->
name|h
condition|)
name|me
operator|=
name|ch1
expr_stmt|;
block|}
block|}
comment|/*      * if I fit in no chunk, return with failure      */
if|if
condition|(
name|me
operator|==
operator|(
name|hpChunk
operator|*
operator|)
literal|0
condition|)
return|return
name|me
return|;
comment|/*      * take me out of the unused list       */
if|if
condition|(
name|me
operator|->
name|next
condition|)
name|me
operator|->
name|next
operator|->
name|prev
operator|=
name|me
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|prev
condition|)
name|me
operator|->
name|prev
operator|->
name|next
operator|=
name|me
operator|->
name|next
expr_stmt|;
else|else
name|allocInfo
operator|->
name|unused
operator|=
name|me
operator|->
name|next
expr_stmt|;
comment|/*      * put me into the used list       */
if|if
condition|(
name|allocInfo
operator|->
name|used
condition|)
name|allocInfo
operator|->
name|used
operator|->
name|prev
operator|=
name|me
expr_stmt|;
name|me
operator|->
name|next
operator|=
name|allocInfo
operator|->
name|used
expr_stmt|;
name|me
operator|->
name|prev
operator|=
operator|(
name|hpChunk
operator|*
operator|)
literal|0
expr_stmt|;
name|allocInfo
operator|->
name|used
operator|=
name|me
expr_stmt|;
comment|/*      * check on which way to divide and allocate storage as needed      */
name|ch1
operator|=
operator|(
name|hpChunk
operator|*
operator|)
literal|0
expr_stmt|;
name|ch2
operator|=
operator|(
name|hpChunk
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|x
operator|==
name|allocInfo
operator|->
name|firstcol
condition|)
block|{
comment|/*					+------+--------+ 	 * first we are dividing lengthwise	|  me  |  ch1   | 	 * then by height as the picture on	+------+--------+ 	 * the right shows.			|      ch2      | 	 *					+---------------+ 	 */
if|if
condition|(
name|me
operator|->
name|w
operator|!=
name|w
condition|)
name|ch1
operator|=
name|getchunk
argument_list|(
name|allocInfo
argument_list|,
name|me
operator|->
name|x
operator|+
name|w
argument_list|,
name|me
operator|->
name|y
argument_list|,
name|me
operator|->
name|w
operator|-
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|h
operator|!=
name|h
condition|)
name|ch2
operator|=
name|getchunk
argument_list|(
name|allocInfo
argument_list|,
name|me
operator|->
name|x
argument_list|,
name|me
operator|->
name|y
operator|+
name|h
argument_list|,
name|me
operator|->
name|w
argument_list|,
name|me
operator|->
name|h
operator|-
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*					+------+--------+ 	 * first we are dividing heightwise	|  me  |        | 	 * then by width as the picture on	+------+  ch2   + 	 * the right shows.			|  ch1 |        | 	 *					+---------------+ 	 */
if|if
condition|(
name|me
operator|->
name|h
operator|!=
name|h
condition|)
name|ch1
operator|=
name|getchunk
argument_list|(
name|allocInfo
argument_list|,
name|me
operator|->
name|x
argument_list|,
name|me
operator|->
name|y
operator|+
name|h
argument_list|,
name|w
argument_list|,
name|me
operator|->
name|h
operator|-
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|w
operator|!=
name|w
condition|)
name|ch2
operator|=
name|getchunk
argument_list|(
name|allocInfo
argument_list|,
name|me
operator|->
name|x
operator|+
name|w
argument_list|,
name|me
operator|->
name|y
argument_list|,
name|me
operator|->
name|w
operator|-
name|w
argument_list|,
name|me
operator|->
name|h
argument_list|)
expr_stmt|;
block|}
comment|/*      * update my new height      */
name|me
operator|->
name|h
operator|=
name|h
expr_stmt|;
name|me
operator|->
name|w
operator|=
name|w
expr_stmt|;
comment|/*      * get a parent node and link all the chunks properly      */
name|p
operator|=
operator|(
name|hpCnode
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hpCnode
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|c0
operator|=
operator|(
name|hpCnode
operator|*
operator|)
name|me
expr_stmt|;
name|p
operator|->
name|c1
operator|=
operator|(
name|hpCnode
operator|*
operator|)
name|ch1
expr_stmt|;
name|p
operator|->
name|c2
operator|=
operator|(
name|hpCnode
operator|*
operator|)
name|ch2
expr_stmt|;
name|p
operator|->
name|t0
operator|=
name|USED
expr_stmt|;
name|p
operator|->
name|t1
operator|=
name|UNUSED
expr_stmt|;
name|p
operator|->
name|t2
operator|=
name|UNUSED
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|parent
operator|=
name|me
operator|->
name|parent
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|me
operator|->
name|parent
operator|->
name|c0
operator|==
operator|(
name|hpCnode
operator|*
operator|)
name|me
condition|)
block|{
name|me
operator|->
name|parent
operator|->
name|c0
operator|=
name|p
expr_stmt|;
name|me
operator|->
name|parent
operator|->
name|t0
operator|=
name|CNODE
expr_stmt|;
block|}
if|if
condition|(
name|me
operator|->
name|parent
operator|->
name|c1
operator|==
operator|(
name|hpCnode
operator|*
operator|)
name|me
condition|)
block|{
name|me
operator|->
name|parent
operator|->
name|c1
operator|=
name|p
expr_stmt|;
name|me
operator|->
name|parent
operator|->
name|t1
operator|=
name|CNODE
expr_stmt|;
block|}
if|if
condition|(
name|me
operator|->
name|parent
operator|->
name|c2
operator|==
operator|(
name|hpCnode
operator|*
operator|)
name|me
condition|)
block|{
name|me
operator|->
name|parent
operator|->
name|c2
operator|=
name|p
expr_stmt|;
name|me
operator|->
name|parent
operator|->
name|t2
operator|=
name|CNODE
expr_stmt|;
block|}
block|}
name|me
operator|->
name|parent
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|ch1
condition|)
name|ch1
operator|->
name|parent
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|ch2
condition|)
name|ch2
operator|->
name|parent
operator|=
name|p
expr_stmt|;
block|{
name|void
function_decl|(
modifier|*
name|bitMover
function_decl|)
parameter_list|()
function_decl|;
name|bitMover
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
operator|->
name|MoveBits
expr_stmt|;
if|if
condition|(
name|bitMover
condition|)
block|{
comment|/* clear the area of memory that is being given to the user */
call|(
modifier|*
name|bitMover
call|)
argument_list|(
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXclear
argument_list|,
name|me
operator|->
name|x
argument_list|,
name|me
operator|->
name|y
argument_list|,
name|me
operator|->
name|x
argument_list|,
name|me
operator|->
name|y
argument_list|,
name|me
operator|->
name|w
argument_list|,
name|me
operator|->
name|h
argument_list|)
expr_stmt|;
comment|/* wait for bitMover operation to complete */
name|WAIT_READY_TO_RENDER
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
modifier|*
name|pClrInt
decl_stmt|;
specifier|register
name|int
modifier|*
name|pClrMax
decl_stmt|;
specifier|register
name|short
name|i
decl_stmt|;
name|int
name|ClrWords
decl_stmt|,
modifier|*
name|pClrStart
decl_stmt|;
name|ClrWords
operator|=
operator|(
name|me
operator|->
name|w
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
name|pClrStart
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
operator|->
name|bits
operator|+
operator|(
name|me
operator|->
name|y
operator|*
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
operator|->
name|stride
operator|)
operator|+
name|me
operator|->
name|x
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|me
operator|->
name|h
condition|;
name|i
operator|++
control|)
block|{
name|pClrInt
operator|=
name|pClrStart
expr_stmt|;
name|pClrMax
operator|=
name|pClrStart
operator|+
name|ClrWords
expr_stmt|;
while|while
condition|(
name|pClrInt
operator|<
name|pClrMax
condition|)
operator|*
name|pClrInt
operator|++
operator|=
literal|0
expr_stmt|;
name|pClrStart
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pClrStart
operator|+
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
operator|->
name|stride
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * return the chunk id      */
return|return
name|me
return|;
block|}
end_block

begin_function
name|void
name|hpBufFree
parameter_list|(
name|pScreen
parameter_list|,
name|ch
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
specifier|register
name|hpChunk
modifier|*
name|ch
decl_stmt|;
block|{
specifier|register
name|hpBufAllocInfoPtr
name|allocInfo
init|=
name|screenBufs
index|[
name|pScreen
operator|->
name|myNum
index|]
decl_stmt|;
comment|/*      * remove me from the used list and put me un the unused list      */
if|if
condition|(
name|ch
operator|->
name|next
condition|)
name|ch
operator|->
name|next
operator|->
name|prev
operator|=
name|ch
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|prev
condition|)
name|ch
operator|->
name|prev
operator|->
name|next
operator|=
name|ch
operator|->
name|next
expr_stmt|;
else|else
name|allocInfo
operator|->
name|used
operator|=
name|ch
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|allocInfo
operator|->
name|unused
condition|)
name|allocInfo
operator|->
name|unused
operator|->
name|prev
operator|=
name|ch
expr_stmt|;
name|ch
operator|->
name|next
operator|=
name|allocInfo
operator|->
name|unused
expr_stmt|;
name|ch
operator|->
name|prev
operator|=
operator|(
name|hpChunk
operator|*
operator|)
literal|0
expr_stmt|;
name|allocInfo
operator|->
name|unused
operator|=
name|ch
expr_stmt|;
comment|/*      * modify me parent to say I'm unused      */
if|if
condition|(
name|ch
operator|->
name|parent
operator|->
name|c0
operator|==
operator|(
name|hpCnode
operator|*
operator|)
name|ch
condition|)
name|ch
operator|->
name|parent
operator|->
name|t0
operator|=
name|UNUSED
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|parent
operator|->
name|c1
operator|==
operator|(
name|hpCnode
operator|*
operator|)
name|ch
condition|)
name|ch
operator|->
name|parent
operator|->
name|t1
operator|=
name|UNUSED
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|parent
operator|->
name|c2
operator|==
operator|(
name|hpCnode
operator|*
operator|)
name|ch
condition|)
name|ch
operator|->
name|parent
operator|->
name|t2
operator|=
name|UNUSED
expr_stmt|;
comment|/*      * combine freed chunks      */
name|combine
argument_list|(
name|allocInfo
argument_list|,
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * internal routine to coalate chunks back together  */
end_comment

begin_function
specifier|static
name|void
name|combine
parameter_list|(
name|allocInfo
parameter_list|,
name|par
parameter_list|)
specifier|register
name|hpBufAllocInfoPtr
name|allocInfo
decl_stmt|;
specifier|register
name|hpCnode
modifier|*
name|par
decl_stmt|;
block|{
specifier|register
name|hpChunk
modifier|*
name|ch0
decl_stmt|,
modifier|*
name|ch1
decl_stmt|,
modifier|*
name|ch2
decl_stmt|;
specifier|register
name|hpCnode
modifier|*
name|pp
decl_stmt|;
name|ch0
operator|=
operator|(
name|hpChunk
operator|*
operator|)
name|par
operator|->
name|c0
expr_stmt|;
name|ch1
operator|=
operator|(
name|hpChunk
operator|*
operator|)
name|par
operator|->
name|c1
expr_stmt|;
name|ch2
operator|=
operator|(
name|hpChunk
operator|*
operator|)
name|par
operator|->
name|c2
expr_stmt|;
comment|/*      * combine ch0 and ch1      */
if|if
condition|(
name|ch1
condition|)
comment|/* if ch1 does not exist, go on */
block|{
if|if
condition|(
name|par
operator|->
name|t0
operator|!=
name|UNUSED
operator|||
name|par
operator|->
name|t1
operator|!=
name|UNUSED
condition|)
return|return;
comment|/* return if either are not UNUSED */
comment|/* 	 * combine ch1 with ch0          */
if|if
condition|(
name|ch0
operator|->
name|y
operator|==
name|ch1
operator|->
name|y
condition|)
name|ch0
operator|->
name|w
operator|+=
name|ch1
operator|->
name|w
expr_stmt|;
else|else
name|ch0
operator|->
name|h
operator|+=
name|ch1
operator|->
name|h
expr_stmt|;
if|if
condition|(
name|ch1
operator|->
name|next
condition|)
name|ch1
operator|->
name|next
operator|->
name|prev
operator|=
name|ch1
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|ch1
operator|->
name|prev
condition|)
name|ch1
operator|->
name|prev
operator|->
name|next
operator|=
name|ch1
operator|->
name|next
expr_stmt|;
else|else
name|allocInfo
operator|->
name|unused
operator|=
name|ch1
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|ch1
argument_list|)
expr_stmt|;
name|par
operator|->
name|c1
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * combine ch0 and ch2      */
if|if
condition|(
name|ch2
condition|)
comment|/* if ch2 does not exist, go on */
block|{
if|if
condition|(
name|par
operator|->
name|t0
operator|!=
name|UNUSED
operator|||
name|par
operator|->
name|t2
operator|!=
name|UNUSED
condition|)
return|return;
comment|/* return if either are not UNUSED */
comment|/* 	 * combine ch2 with ch0          */
if|if
condition|(
name|ch0
operator|->
name|y
operator|==
name|ch2
operator|->
name|y
condition|)
name|ch0
operator|->
name|w
operator|+=
name|ch2
operator|->
name|w
expr_stmt|;
else|else
name|ch0
operator|->
name|h
operator|+=
name|ch2
operator|->
name|h
expr_stmt|;
if|if
condition|(
name|ch2
operator|->
name|next
condition|)
name|ch2
operator|->
name|next
operator|->
name|prev
operator|=
name|ch2
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|ch2
operator|->
name|prev
condition|)
name|ch2
operator|->
name|prev
operator|->
name|next
operator|=
name|ch2
operator|->
name|next
expr_stmt|;
else|else
name|allocInfo
operator|->
name|unused
operator|=
name|ch2
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
block|}
comment|/*       * only one chunk left, relink with parent of par and free par      */
if|if
condition|(
name|pp
operator|=
name|par
operator|->
name|parent
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|c0
operator|==
name|par
condition|)
block|{
name|pp
operator|->
name|c0
operator|=
operator|(
name|hpCnode
operator|*
operator|)
name|ch0
expr_stmt|;
name|pp
operator|->
name|t0
operator|=
name|UNUSED
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|c1
operator|==
name|par
condition|)
block|{
name|pp
operator|->
name|c1
operator|=
operator|(
name|hpCnode
operator|*
operator|)
name|ch0
expr_stmt|;
name|pp
operator|->
name|t1
operator|=
name|UNUSED
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|c2
operator|==
name|par
condition|)
block|{
name|pp
operator|->
name|c2
operator|=
operator|(
name|hpCnode
operator|*
operator|)
name|ch0
expr_stmt|;
name|pp
operator|->
name|t2
operator|=
name|UNUSED
expr_stmt|;
block|}
block|}
name|ch0
operator|->
name|parent
operator|=
name|pp
expr_stmt|;
name|xfree
argument_list|(
name|par
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
condition|)
name|combine
argument_list|(
name|allocInfo
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * getchunk returns a pointer to an unused chunk at x,y and size w,h  */
end_comment

begin_function
specifier|static
name|hpChunk
modifier|*
name|getchunk
parameter_list|(
name|allocInfo
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|)
specifier|register
name|hpBufAllocInfoPtr
name|allocInfo
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
block|{
name|hpChunk
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
operator|(
name|hpChunk
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hpChunk
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|ch
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|ch
operator|->
name|w
operator|=
name|w
expr_stmt|;
name|ch
operator|->
name|h
operator|=
name|h
expr_stmt|;
comment|/*      * relink the new chunk to the front of the unused list      */
if|if
condition|(
name|allocInfo
operator|->
name|unused
condition|)
name|allocInfo
operator|->
name|unused
operator|->
name|prev
operator|=
name|ch
expr_stmt|;
name|ch
operator|->
name|next
operator|=
name|allocInfo
operator|->
name|unused
expr_stmt|;
name|ch
operator|->
name|prev
operator|=
operator|(
name|hpChunk
operator|*
operator|)
literal|0
expr_stmt|;
name|ch
operator|->
name|parent
operator|=
operator|(
name|hpCnode
operator|*
operator|)
literal|0
expr_stmt|;
name|allocInfo
operator|->
name|unused
operator|=
name|ch
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/*  * an interactive testing program  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_macro
name|hpAllocTest
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|w
operator|,
name|h
expr_stmt|;
specifier|register
name|hpChunk
modifier|*
name|ch
decl_stmt|;
specifier|register
name|hpCnode
modifier|*
name|par
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|ScreenPtr
name|pScreen
decl_stmt|;
specifier|register
name|hpBufAllocInfoPtr
name|allocInfo
decl_stmt|;
name|pScreen
operator|=
operator|&
operator|(
name|screenInfo
operator|.
name|screen
index|[
literal|0
index|]
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|hpBufAllocInit
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|allocInfo
operator|=
name|screenBufs
index|[
name|pScreen
operator|->
name|myNum
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"total size of buffer is width=%d, height=%d\n"
argument_list|,
name|allocInfo
operator|->
name|unused
operator|->
name|w
argument_list|,
name|allocInfo
operator|->
name|unused
operator|->
name|h
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\nSelect function -- examin, get, free, list, or quit>>"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
literal|80
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'e'
case|:
name|printf
argument_list|(
literal|"chunk or parent???>>"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'p'
condition|)
block|{
name|printf
argument_list|(
literal|"examin which parent>>"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|par
operator|=
operator|(
name|hpCnode
operator|*
operator|)
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"c0 = %d is %d, c1 = %d is %d, c2 = %d is %d par = %d\n\n"
argument_list|,
name|par
operator|->
name|c0
argument_list|,
name|par
operator|->
name|t0
argument_list|,
name|par
operator|->
name|c1
argument_list|,
name|par
operator|->
name|t1
argument_list|,
name|par
operator|->
name|c2
argument_list|,
name|par
operator|->
name|t2
argument_list|,
name|par
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"examin which chunk>>"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
name|hpChunk
operator|*
operator|)
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"next = %d, prev = %d\n\n"
argument_list|,
name|ch
operator|->
name|next
argument_list|,
name|ch
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'g'
case|:
name|printf
argument_list|(
literal|"width>>"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|w
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"height>>"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|h
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ch
operator|=
name|hpBufAlloc
argument_list|(
name|pScreen
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|(
name|hpChunk
operator|*
operator|)
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cannot get block: %d by %d \n"
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"block returned is block #%d\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlocation of chunk is x=%d, y=%d\n"
argument_list|,
name|ch
operator|->
name|x
argument_list|,
name|ch
operator|->
name|y
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tparent block is %d\n"
argument_list|,
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
name|printf
argument_list|(
literal|"which block to free>>"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
name|hpChunk
operator|*
operator|)
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|hpBufFree
argument_list|(
name|pScreen
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|printf
argument_list|(
literal|"used = %d  unused = %d\n\n"
argument_list|,
name|allocInfo
operator|->
name|used
argument_list|,
name|allocInfo
operator|->
name|unused
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"The list of FREE blocks are:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tblock\theight\twidth\txloc\tyloc\tparent\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocInfo
operator|->
name|unused
operator|!=
name|allocInfo
operator|->
name|used
condition|)
block|{
for|for
control|(
name|ch
operator|=
name|allocInfo
operator|->
name|unused
init|;
name|ch
condition|;
name|ch
operator|=
name|ch
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"\t%d\t%d\t%d\t%d\t%d\t%d\n"
argument_list|,
name|ch
argument_list|,
name|ch
operator|->
name|h
argument_list|,
name|ch
operator|->
name|w
argument_list|,
name|ch
operator|->
name|x
argument_list|,
name|ch
operator|->
name|y
argument_list|,
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\nThe list of USED blocks are:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tblock\theight\twidth\txloc\tyloc\tparent\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
name|allocInfo
operator|->
name|used
init|;
name|ch
condition|;
name|ch
operator|=
name|ch
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"\t%d\t%d\t%d\t%d\t%d\t%d\n"
argument_list|,
name|ch
argument_list|,
name|ch
operator|->
name|h
argument_list|,
name|ch
operator|->
name|w
argument_list|,
name|ch
operator|->
name|x
argument_list|,
name|ch
operator|->
name|y
argument_list|,
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
default|default:
name|printf
argument_list|(
literal|"unknown command %c\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

