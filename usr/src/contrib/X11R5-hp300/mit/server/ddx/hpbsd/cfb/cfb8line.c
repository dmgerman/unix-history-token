begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: cfb8line.c,v 1.19 91/07/09 16:07:32 rws Exp $  *  * Copyright 1990 Massachusetts Institute of Technology  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the name of M.I.T. not be used in advertising or  * publicity pertaining to distribution of the software without specific,  * written prior permission.  M.I.T. makes no representations about the  * suitability of this software for any purpose.  It is provided "as is"  * without express or implied warranty.  *  * M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL M.I.T.  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * Author:  Keith Packard, MIT X Consortium  */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"mistruct.h"
end_include

begin_include
include|#
directive|include
file|"cfb.h"
end_include

begin_include
include|#
directive|include
file|"cfbmskbits.h"
end_include

begin_include
include|#
directive|include
file|"cfbrrop.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|mc68020
argument_list|)
end_if

begin_define
define|#
directive|define
name|STUPID
value|volatile
end_define

begin_define
define|#
directive|define
name|REARRANGE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STUPID
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_comment
comment|/* lame compiler doesn't even look at 'register' attributes */
end_comment

begin_define
define|#
directive|define
name|I_H
value|do{
end_define

begin_define
define|#
directive|define
name|I_T
value|}while(0);
end_define

begin_define
define|#
directive|define
name|IMPORTANT_START
value|I_H I_H I_H I_H I_H I_H I_H I_H I_H I_H
end_define

begin_define
define|#
directive|define
name|IMPORTANT_END
value|I_T I_T I_T I_T I_T I_T I_T I_T I_T I_T
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IMPORTANT_START
end_define

begin_define
define|#
directive|define
name|IMPORTANT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OUTCODES
parameter_list|(
name|result
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|box
parameter_list|)
define|\
value|if (x< box->x1) \ 	result |= OUT_LEFT; \     if (x>= box->x2) \ 	result |= OUT_RIGHT; \     if (y< box->y1) \ 	result |= OUT_ABOVE; \     if (y>= box->y2) \ 	result |= OUT_BELOW;
end_define

begin_define
define|#
directive|define
name|isClipped
parameter_list|(
name|c
parameter_list|,
name|ul
parameter_list|,
name|lr
parameter_list|)
value|((((c) - (ul)) | ((lr) - (c)))& ClipMask)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|POLYSEGMENT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_define
define|#
directive|define
name|WIDTH_FAST
value|1152
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ultrix
end_ifdef

begin_define
define|#
directive|define
name|WIDTH_FAST
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Mips
end_ifdef

begin_define
define|#
directive|define
name|WIDTH_FAST
value|4096
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIDTH_FAST
end_ifdef

begin_if
if|#
directive|if
name|WIDTH_FAST
operator|==
literal|1024
end_if

begin_define
define|#
directive|define
name|FAST_MUL
parameter_list|(
name|y
parameter_list|)
value|((y)<< 10)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|WIDTH_FAST
operator|==
literal|1152
end_if

begin_define
define|#
directive|define
name|FAST_MUL
parameter_list|(
name|y
parameter_list|)
value|(((y)<< 10) + ((y)<< 7))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|WIDTH_FAST
operator|==
literal|1280
end_if

begin_define
define|#
directive|define
name|FAST_MUL
parameter_list|(
name|y
parameter_list|)
value|(((y)<< 10) + ((y)<< 8))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|WIDTH_FAST
operator|==
literal|2048
end_if

begin_define
define|#
directive|define
name|FAST_MUL
parameter_list|(
name|y
parameter_list|)
value|((y)<< 11)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|WIDTH_FAST
operator|==
literal|4096
end_if

begin_define
define|#
directive|define
name|FAST_MUL
parameter_list|(
name|y
parameter_list|)
value|((y)<< 12)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WIDTH_SHIFT
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|FAST_MUL
end_ifdef

begin_define
define|#
directive|define
name|FUNC_NAME
parameter_list|(
name|e
parameter_list|)
value|RROP_NAME(RROP_NAME_CAT(e,Shift))
end_define

begin_if
if|#
directive|if
name|RROP
operator|==
name|GXcopy
end_if

begin_define
define|#
directive|define
name|INCLUDE_OTHERS
end_define

begin_define
define|#
directive|define
name|SERIOUS_UNROLLING
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INCLUDE_DRAW
end_define

begin_define
define|#
directive|define
name|NWIDTH
parameter_list|(
name|nwidth
parameter_list|)
value|WIDTH_FAST
end_define

begin_define
define|#
directive|define
name|WIDTH_MUL
parameter_list|(
name|y
parameter_list|,
name|w
parameter_list|)
value|FAST_MUL(y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FUNC_NAME
parameter_list|(
name|e
parameter_list|)
value|RROP_NAME(e)
end_define

begin_define
define|#
directive|define
name|WIDTH_MUL
parameter_list|(
name|y
parameter_list|,
name|w
parameter_list|)
value|((y) * (w))
end_define

begin_define
define|#
directive|define
name|NWIDTH
parameter_list|(
name|nwidth
parameter_list|)
value|(nwidth)
end_define

begin_define
define|#
directive|define
name|INCLUDE_DRAW
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FAST_MUL
argument_list|)
operator|&&
name|RROP
operator|==
name|GXcopy
end_if

begin_define
define|#
directive|define
name|INCLUDE_OTHERS
end_define

begin_define
define|#
directive|define
name|SERIOUS_UNROLLING
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INCLUDE_DRAW
end_define

begin_define
define|#
directive|define
name|WIDTH_MUL
parameter_list|(
name|y
parameter_list|,
name|w
parameter_list|)
value|((y) * (w))
end_define

begin_define
define|#
directive|define
name|NWIDTH
parameter_list|(
name|nwidth
parameter_list|)
value|nwidth
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PREVIOUS
end_ifdef

begin_define
define|#
directive|define
name|FUNC_NAME
parameter_list|(
name|e
parameter_list|)
value|RROP_NAME(RROP_NAME_CAT(e,Previous))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FUNC_NAME
parameter_list|(
name|e
parameter_list|)
value|RROP_NAME(e)
end_define

begin_if
if|#
directive|if
name|RROP
operator|==
name|GXcopy
end_if

begin_define
define|#
directive|define
name|INCLUDE_OTHERS
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PLENTIFUL_REGISTERS
end_ifdef

begin_define
define|#
directive|define
name|SAVE_X2Y2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ORIGIN
end_define

begin_define
define|#
directive|define
name|SERIOUS_UNROLLING
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EITHER_MODE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDE_DRAW
end_ifdef

begin_decl_stmt
name|int
ifdef|#
directive|ifdef
name|POLYSEGMENT
name|FUNC_NAME
argument_list|(
name|cfb8SegmentSS1Rect
argument_list|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|nseg
argument_list|,
name|pSegInit
argument_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|GCPtr
name|pGC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nseg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|xSegment
modifier|*
name|pSegInit
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function
name|FUNC_NAME
function|(
name|cfb8LineSS1Rect
function|)
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|mode
parameter_list|,
name|npt
parameter_list|,
name|pptInit
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* Origin or Previous */
name|int
name|npt
decl_stmt|;
comment|/* number of points */
name|DDXPointPtr
name|pptInit
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|int
name|e
decl_stmt|;
specifier|register
name|int
name|y1_or_e1
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|addrb
decl_stmt|;
specifier|register
name|int
name|stepmajor
decl_stmt|;
specifier|register
name|int
name|stepminor
decl_stmt|;
ifndef|#
directive|ifndef
name|REARRANGE
specifier|register
name|int
name|e3
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|mc68000
specifier|register
name|short
name|x1_or_len
decl_stmt|;
else|#
directive|else
specifier|register
name|int
name|x1_or_len
decl_stmt|;
endif|#
directive|endif
name|RROP_DECLARE
ifdef|#
directive|ifdef
name|SAVE_X2Y2
define|#
directive|define
name|c2
value|y2
else|#
directive|else
specifier|register
name|int
name|c2
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|upperleft
decl_stmt|,
name|lowerright
decl_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
specifier|register
name|int
name|capStyle
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SAVE_X2Y2
specifier|register
name|int
name|x2
decl_stmt|,
name|y2
decl_stmt|;
define|#
directive|define
name|X1
value|x1_or_len
define|#
directive|define
name|Y1
value|y1_or_e1
define|#
directive|define
name|X2
value|x2
define|#
directive|define
name|Y2
value|y2
else|#
directive|else
ifdef|#
directive|ifdef
name|POLYSEGMENT
define|#
directive|define
name|X1
value|x1_or_len
define|#
directive|define
name|Y1
value|y1_or_e1
else|#
directive|else
define|#
directive|define
name|X1
value|intToX(y1_or_e1)
define|#
directive|define
name|Y1
value|intToY(y1_or_e1)
endif|#
directive|endif
define|#
directive|define
name|X2
value|intToX(c2)
define|#
directive|define
name|Y2
value|intToY(c2)
endif|#
directive|endif
name|unsigned
name|long
name|ClipMask
init|=
literal|0x80008000
decl_stmt|;
name|unsigned
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|nwidth
decl_stmt|;
name|cfbPrivGCPtr
name|devPriv
decl_stmt|;
name|BoxPtr
name|extents
decl_stmt|;
name|int
modifier|*
name|ppt
decl_stmt|;
name|devPriv
operator|=
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
expr_stmt|;
name|cfbGetByteWidthAndPointer
argument_list|(
name|pDrawable
argument_list|,
name|nwidth
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|REARRANGE
name|RROP_FETCH_GCPRIV
argument_list|(
name|devPriv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|extents
operator|=
operator|&
name|devPriv
operator|->
name|pCompositeClip
operator|->
name|extents
expr_stmt|;
name|c2
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|pDrawable
operator|->
name|x
operator|)
expr_stmt|;
name|c2
operator|-=
operator|(
name|c2
operator|&
literal|0x8000
operator|)
operator|<<
literal|1
expr_stmt|;
name|upperleft
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|extents
operator|->
name|x1
operator|)
operator|-
name|c2
expr_stmt|;
name|lowerright
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|extents
operator|->
name|x2
operator|)
operator|-
name|c2
operator|-
literal|0x00010001
expr_stmt|;
name|addr
operator|=
name|addr
operator|+
name|WIDTH_MUL
argument_list|(
name|pDrawable
operator|->
name|y
argument_list|,
name|nwidth
argument_list|)
operator|+
name|pDrawable
operator|->
name|x
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
name|capStyle
operator|=
name|pGC
operator|->
name|capStyle
operator|-
name|CapNotLast
expr_stmt|;
name|ppt
operator|=
operator|(
name|int
operator|*
operator|)
name|pSegInit
expr_stmt|;
while|while
condition|(
name|nseg
operator|--
condition|)
else|#
directive|else
ifdef|#
directive|ifdef
name|EITHER_MODE
name|mode
operator|-=
name|CoordModePrevious
expr_stmt|;
endif|#
directive|endif
name|ppt
operator|=
operator|(
name|int
operator|*
operator|)
name|pptInit
expr_stmt|;
name|c2
operator|=
operator|*
name|ppt
operator|++
expr_stmt|;
if|if
condition|(
name|isClipped
argument_list|(
name|c2
argument_list|,
name|upperleft
argument_list|,
name|lowerright
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ORIGIN
ifdef|#
directive|ifdef
name|EITHER_MODE
if|if
condition|(
operator|!
name|mode
condition|)
endif|#
directive|endif
block|{
name|e
operator|=
operator|*
name|ppt
expr_stmt|;
operator|*
name|ppt
operator|=
name|e
operator|+
name|c2
operator|-
operator|(
operator|(
name|e
operator|&
literal|0x8000
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|SAVE_X2Y2
name|intToCoord
argument_list|(
name|c2
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addrb
operator|=
name|addr
operator|+
name|WIDTH_MUL
argument_list|(
name|Y2
argument_list|,
name|nwidth
argument_list|)
operator|+
name|X2
expr_stmt|;
while|while
condition|(
operator|--
name|npt
condition|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|POLYSEGMENT
name|y1_or_e1
operator|=
name|ppt
index|[
literal|0
index|]
expr_stmt|;
name|c2
operator|=
name|ppt
index|[
literal|1
index|]
expr_stmt|;
name|ppt
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|isClipped
argument_list|(
name|y1_or_e1
argument_list|,
name|upperleft
argument_list|,
name|lowerright
argument_list|)
operator||
name|isClipped
argument_list|(
name|c2
argument_list|,
name|upperleft
argument_list|,
name|lowerright
argument_list|)
condition|)
break|break;
name|intToCoord
argument_list|(
name|y1_or_e1
argument_list|,
name|x1_or_len
argument_list|,
name|y1_or_e1
argument_list|)
expr_stmt|;
comment|/* compute now to avoid needing x1, y1 later */
name|addrb
operator|=
name|addr
operator|+
name|WIDTH_MUL
argument_list|(
name|y1_or_e1
argument_list|,
name|nwidth
argument_list|)
operator|+
name|x1_or_len
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|SAVE_X2Y2
name|y1_or_e1
operator|=
name|c2
expr_stmt|;
else|#
directive|else
name|y1_or_e1
operator|=
name|y2
expr_stmt|;
name|x1_or_len
operator|=
name|x2
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ORIGIN
name|e
operator|=
name|c2
expr_stmt|;
name|c2
operator|=
operator|*
name|ppt
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|EITHER_MODE
if|if
condition|(
operator|!
name|mode
condition|)
endif|#
directive|endif
name|c2
operator|=
name|c2
operator|+
name|e
operator|-
operator|(
operator|(
name|c2
operator|&
literal|0x8000
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
else|#
directive|else
name|c2
operator|=
operator|*
name|ppt
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isClipped
argument_list|(
name|c2
argument_list|,
name|upperleft
argument_list|,
name|lowerright
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|ORIGIN
ifdef|#
directive|ifdef
name|EITHER_MODE
if|if
condition|(
operator|!
name|mode
condition|)
endif|#
directive|endif
block|{
name|ppt
index|[
operator|-
literal|2
index|]
operator|=
name|e
expr_stmt|;
name|ppt
index|[
operator|-
literal|1
index|]
operator|=
name|c2
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
ifdef|#
directive|ifdef
name|SAVE_X2Y2
name|intToCoord
argument_list|(
name|c2
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|stepmajor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|x1_or_len
operator|=
name|X2
operator|-
name|X1
operator|)
operator|<
literal|0
condition|)
block|{
name|x1_or_len
operator|=
operator|-
name|x1_or_len
expr_stmt|;
name|stepmajor
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|stepminor
operator|=
name|NWIDTH
argument_list|(
name|nwidth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y1_or_e1
operator|=
name|Y2
operator|-
name|Y1
operator|)
operator|<
literal|0
condition|)
block|{
name|y1_or_e1
operator|=
operator|-
name|y1_or_e1
expr_stmt|;
name|stepminor
operator|=
operator|-
name|stepminor
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|POLYSEGMENT
comment|/* 	 * although the horizontal code works for polyline, it 	 * slows down 10 pixel lines by 15%.  Thus, this 	 * code is optimized for horizontal segments and 	 * random orientation lines, which seems like a reasonable 	 * assumption 	 */
if|if
condition|(
name|y1_or_e1
operator|!=
literal|0
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|x1_or_len
operator|<
name|y1_or_e1
condition|)
block|{
ifdef|#
directive|ifdef
name|REARRANGE
specifier|register
name|int
name|e3
decl_stmt|;
endif|#
directive|endif
name|e3
operator|=
name|x1_or_len
expr_stmt|;
name|x1_or_len
operator|=
name|y1_or_e1
expr_stmt|;
name|y1_or_e1
operator|=
name|e3
expr_stmt|;
name|e3
operator|=
name|stepminor
expr_stmt|;
name|stepminor
operator|=
name|stepmajor
expr_stmt|;
name|stepmajor
operator|=
name|e3
expr_stmt|;
block|}
name|e
operator|=
operator|-
name|x1_or_len
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
operator|!
name|capStyle
condition|)
name|x1_or_len
operator|--
expr_stmt|;
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|REARRANGE
specifier|register
name|int
name|e3
decl_stmt|;
name|RROP_DECLARE
name|RROP_FETCH_GCPRIV
argument_list|(
name|devPriv
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|y1_or_e1
operator|=
name|y1_or_e1
operator|<<
literal|1
expr_stmt|;
name|e3
operator|=
name|e
operator|<<
literal|1
expr_stmt|;
define|#
directive|define
name|body
value|{\ 	    RROP_SOLID(addrb); \ 	    addrb += stepmajor; \ 	    e += y1_or_e1; \ 	    if (e>= 0) \ 	    { \ 		addrb += stepminor; \ 		e += e3; \ 	     } \ 	}
ifdef|#
directive|ifdef
name|LARGE_INSTRUCTION_CACHE
ifdef|#
directive|ifdef
name|SERIOUS_UNROLLING
define|#
directive|define
name|UNROLL
value|16
else|#
directive|else
define|#
directive|define
name|UNROLL
value|4
endif|#
directive|endif
define|#
directive|define
name|CASE
parameter_list|(
name|n
parameter_list|)
value|case -n: body
while|while
condition|(
operator|(
name|x1_or_len
operator|-=
name|UNROLL
operator|)
operator|>=
literal|0
condition|)
block|{
name|body
name|body
name|body
name|body
if|#
directive|if
name|UNROLL
operator|>=
literal|8
name|body
name|body
name|body
name|body
endif|#
directive|endif
if|#
directive|if
name|UNROLL
operator|>=
literal|12
name|body
name|body
name|body
name|body
endif|#
directive|endif
if|#
directive|if
name|UNROLL
operator|>=
literal|16
name|body
name|body
name|body
name|body
endif|#
directive|endif
block|}
switch|switch
condition|(
name|x1_or_len
condition|)
block|{
name|CASE
argument_list|(
literal|1
argument_list|)
name|CASE
argument_list|(
literal|2
argument_list|)
name|CASE
argument_list|(
literal|3
argument_list|)
if|#
directive|if
name|UNROLL
operator|>=
literal|8
name|CASE
argument_list|(
literal|4
argument_list|)
name|CASE
argument_list|(
literal|5
argument_list|)
name|CASE
argument_list|(
literal|6
argument_list|)
name|CASE
argument_list|(
literal|7
argument_list|)
endif|#
directive|endif
if|#
directive|if
name|UNROLL
operator|>=
literal|12
name|CASE
argument_list|(
literal|8
argument_list|)
name|CASE
argument_list|(
literal|9
argument_list|)
name|CASE
argument_list|(
literal|10
argument_list|)
name|CASE
argument_list|(
literal|11
argument_list|)
endif|#
directive|endif
if|#
directive|if
name|UNROLL
operator|>=
literal|16
name|CASE
argument_list|(
literal|12
argument_list|)
name|CASE
argument_list|(
literal|13
argument_list|)
name|CASE
argument_list|(
literal|14
argument_list|)
name|CASE
argument_list|(
literal|15
argument_list|)
endif|#
directive|endif
block|}
else|#
directive|else
name|IMPORTANT_START
name|IMPORTANT_START
if|if
condition|(
name|x1_or_len
operator|&
literal|1
condition|)
name|body
name|x1_or_len
operator|>>=
literal|1
expr_stmt|;
while|while
condition|(
name|x1_or_len
operator|--
condition|)
block|{
name|body
name|body
block|}
name|IMPORTANT_END
name|IMPORTANT_END
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POLYSEGMENT
name|RROP_SOLID
argument_list|(
name|addrb
argument_list|)
decl_stmt|;
endif|#
directive|endif
block|}
undef|#
directive|undef
name|body
ifdef|#
directive|ifdef
name|POLYSEGMENT
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|POLYSEGMENT
name|unsigned
name|char
modifier|*
name|t
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REARRANGE
specifier|register
name|int
name|e3
decl_stmt|;
name|RROP_DECLARE
name|RROP_FETCH_GCPRIV
argument_list|(
name|devPriv
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stepmajor
operator|<
literal|0
condition|)
block|{
name|addrb
operator|-=
name|x1_or_len
expr_stmt|;
ifndef|#
directive|ifndef
name|POLYSEGMENT
name|t
operator|=
name|addrb
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|capStyle
condition|)
name|x1_or_len
operator|++
expr_stmt|;
else|else
endif|#
directive|endif
name|addrb
operator|++
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|POLYSEGMENT
name|t
operator|=
name|addrb
operator|+
name|x1_or_len
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|capStyle
condition|)
name|x1_or_len
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|y1_or_e1
operator|=
operator|(
operator|(
name|int
operator|)
name|addrb
operator|)
operator|&
literal|3
expr_stmt|;
name|addrb
operator|=
name|addrb
operator|-
name|y1_or_e1
expr_stmt|;
if|if
condition|(
name|y1_or_e1
operator|+
name|x1_or_len
operator|<=
name|PPW
condition|)
block|{
if|if
condition|(
name|x1_or_len
condition|)
block|{
name|maskpartialbits
argument_list|(
argument|y1_or_e1
argument_list|,
argument|x1_or_len
argument_list|,
argument|e
argument_list|)
name|RROP_SOLID_MASK
argument_list|(
operator|(
name|int
operator|*
operator|)
name|addrb
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|maskbits
argument_list|(
argument|y1_or_e1
argument_list|,
argument|x1_or_len
argument_list|,
argument|e
argument_list|,
argument|e3
argument_list|,
argument|x1_or_len
argument_list|)
if|if
condition|(
name|e
condition|)
block|{
name|RROP_SOLID_MASK
argument_list|(
operator|(
name|int
operator|*
operator|)
name|addrb
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|addrb
operator|+=
literal|4
expr_stmt|;
block|}
name|RROP_SPAN
argument_list|(
argument|addrb
argument_list|,
argument|x1_or_len
argument_list|)
if|if
condition|(
name|e3
condition|)
name|RROP_SOLID_MASK
argument_list|(
operator|(
name|int
operator|*
operator|)
name|addrb
argument_list|,
name|e3
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|POLYSEGMENT
name|addrb
operator|=
name|t
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
name|nseg
operator|>=
literal|0
condition|)
return|return
operator|(
name|xSegment
operator|*
operator|)
name|ppt
operator|-
name|pSegInit
return|;
else|#
directive|else
if|if
condition|(
name|npt
condition|)
return|return
operator|(
operator|(
name|DDXPointPtr
operator|)
name|ppt
operator|-
name|pptInit
operator|)
operator|-
literal|1
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|POLYSEGMENT
ifndef|#
directive|ifndef
name|ORIGIN
define|#
directive|define
name|C2
value|c2
else|#
directive|else
define|#
directive|define
name|C2
value|ppt[-1]
endif|#
directive|endif
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
operator|&&
name|C2
operator|!=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|pptInit
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|REARRANGE
name|RROP_DECLARE
name|RROP_FETCH_GCPRIV
argument_list|(
name|devPriv
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|RROP_SOLID
argument_list|(
name|addrb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INCLUDE_DRAW */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDE_OTHERS
end_ifdef

begin_decl_stmt
specifier|extern
name|void
name|cfb8ClippedLineCopy
argument_list|()
decl_stmt|,
name|cfb8ClippedLineXor
argument_list|()
decl_stmt|,
name|cfb8ClippedLineGeneral
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|POLYSEGMENT
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|cfb8SegmentSS1RectCopy
argument_list|()
decl_stmt|,
name|cfb8SegmentSS1RectXor
argument_list|()
decl_stmt|,
name|cfb8SegmentSS1RectGeneral
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FAST_MUL
end_ifdef

begin_function_decl
specifier|extern
name|int
name|cfb8SegmentSS1RectShiftCopy
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|cfb8SegmentSS1Rect
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nseg
parameter_list|,
name|pSegInit
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nseg
decl_stmt|;
name|xSegment
modifier|*
name|pSegInit
decl_stmt|;
block|{
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|clip
function_decl|)
parameter_list|()
function_decl|;
name|int
name|drawn
decl_stmt|;
name|cfbPrivGCPtr
name|devPriv
decl_stmt|;
name|devPriv
operator|=
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
expr_stmt|;
switch|switch
condition|(
name|devPriv
operator|->
name|rop
condition|)
block|{
case|case
name|GXcopy
case|:
name|func
operator|=
name|cfb8SegmentSS1RectCopy
expr_stmt|;
name|clip
operator|=
name|cfb8ClippedLineCopy
expr_stmt|;
ifdef|#
directive|ifdef
name|FAST_MUL
if|if
condition|(
name|cfbGetByteWidth
argument_list|(
name|pDrawable
argument_list|)
operator|==
name|WIDTH_FAST
condition|)
name|func
operator|=
name|cfb8SegmentSS1RectShiftCopy
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GXxor
case|:
name|func
operator|=
name|cfb8SegmentSS1RectXor
expr_stmt|;
name|clip
operator|=
name|cfb8ClippedLineXor
expr_stmt|;
break|break;
default|default:
name|func
operator|=
name|cfb8SegmentSS1RectGeneral
expr_stmt|;
name|clip
operator|=
name|cfb8ClippedLineGeneral
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|nseg
condition|)
block|{
name|drawn
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|nseg
argument_list|,
name|pSegInit
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawn
operator|==
operator|-
literal|1
condition|)
break|break;
call|(
modifier|*
name|clip
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|pSegInit
index|[
name|drawn
operator|-
literal|1
index|]
operator|.
name|x1
argument_list|,
name|pSegInit
index|[
name|drawn
operator|-
literal|1
index|]
operator|.
name|y1
argument_list|,
name|pSegInit
index|[
name|drawn
operator|-
literal|1
index|]
operator|.
name|x2
argument_list|,
name|pSegInit
index|[
name|drawn
operator|-
literal|1
index|]
operator|.
name|y2
argument_list|,
operator|&
name|devPriv
operator|->
name|pCompositeClip
operator|->
name|extents
argument_list|,
name|pGC
operator|->
name|capStyle
operator|==
name|CapNotLast
argument_list|)
expr_stmt|;
name|pSegInit
operator|+=
name|drawn
expr_stmt|;
name|nseg
operator|-=
name|drawn
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* POLYSEGMENT */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|cfb8LineSS1RectCopy
argument_list|()
decl_stmt|,
name|cfb8LineSS1RectXor
argument_list|()
decl_stmt|,
name|cfb8LineSS1RectGeneral
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|cfb8LineSS1RectPreviousCopy
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|cfb8LineSS1Rect
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|mode
parameter_list|,
name|npt
parameter_list|,
name|pptInit
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|npt
decl_stmt|;
name|DDXPointPtr
name|pptInit
decl_stmt|;
block|{
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|clip
function_decl|)
parameter_list|()
function_decl|;
name|int
name|drawn
decl_stmt|;
name|cfbPrivGCPtr
name|devPriv
decl_stmt|;
name|devPriv
operator|=
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
expr_stmt|;
switch|switch
condition|(
name|devPriv
operator|->
name|rop
condition|)
block|{
case|case
name|GXcopy
case|:
name|func
operator|=
name|cfb8LineSS1RectCopy
expr_stmt|;
name|clip
operator|=
name|cfb8ClippedLineCopy
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CoordModePrevious
condition|)
name|func
operator|=
name|cfb8LineSS1RectPreviousCopy
expr_stmt|;
break|break;
case|case
name|GXxor
case|:
name|func
operator|=
name|cfb8LineSS1RectXor
expr_stmt|;
name|clip
operator|=
name|cfb8ClippedLineXor
expr_stmt|;
break|break;
default|default:
name|func
operator|=
name|cfb8LineSS1RectGeneral
expr_stmt|;
name|clip
operator|=
name|cfb8ClippedLineGeneral
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|npt
operator|>
literal|1
condition|)
block|{
name|drawn
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|mode
argument_list|,
name|npt
argument_list|,
name|pptInit
argument_list|)
expr_stmt|;
if|if
condition|(
name|drawn
operator|==
operator|-
literal|1
condition|)
break|break;
call|(
modifier|*
name|clip
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|pptInit
index|[
name|drawn
operator|-
literal|1
index|]
operator|.
name|x
argument_list|,
name|pptInit
index|[
name|drawn
operator|-
literal|1
index|]
operator|.
name|y
argument_list|,
name|pptInit
index|[
name|drawn
index|]
operator|.
name|x
argument_list|,
name|pptInit
index|[
name|drawn
index|]
operator|.
name|y
argument_list|,
operator|&
name|devPriv
operator|->
name|pCompositeClip
operator|->
name|extents
argument_list|,
name|drawn
operator|!=
name|npt
operator|-
literal|1
operator|||
name|pGC
operator|->
name|capStyle
operator|==
name|CapNotLast
argument_list|)
expr_stmt|;
name|pptInit
operator|+=
name|drawn
expr_stmt|;
name|npt
operator|-=
name|drawn
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|round
parameter_list|(
name|dividend
parameter_list|,
name|divisor
parameter_list|)
define|\
value|( (((dividend)<<1) + (divisor)) / ((divisor)<<1) )
end_define

begin_define
define|#
directive|define
name|ceiling
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
value|(((m)-1)/(n) + 1)
end_define

begin_define
define|#
directive|define
name|SignTimes
parameter_list|(
name|sign
parameter_list|,
name|n
parameter_list|)
value|(((sign)< 0) ? -(n) : (n))
end_define

begin_macro
name|cfbClipPoint
argument_list|(
argument|oc
argument_list|,
argument|xp
argument_list|,
argument|yp
argument_list|,
argument|dx
argument_list|,
argument|dy
argument_list|,
argument|boxp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|oc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|xp
decl_stmt|,
modifier|*
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BoxPtr
name|boxp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|adx
decl_stmt|,
name|ady
decl_stmt|,
name|signdx
decl_stmt|,
name|signdy
decl_stmt|;
name|int
name|utmp
decl_stmt|;
name|signdx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|signdx
operator|=
operator|-
literal|1
expr_stmt|;
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
block|}
name|signdy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
block|{
name|signdy
operator|=
operator|-
literal|1
expr_stmt|;
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
block|}
if|if
condition|(
name|oc
operator|&
operator|(
name|OUT_LEFT
operator||
name|OUT_RIGHT
operator|)
condition|)
block|{
if|if
condition|(
name|oc
operator|&
name|OUT_LEFT
condition|)
block|{
name|x
operator|=
name|boxp
operator|->
name|x1
expr_stmt|;
name|utmp
operator|=
name|x
operator|-
operator|*
name|xp
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|boxp
operator|->
name|x2
operator|-
literal|1
expr_stmt|;
name|utmp
operator|=
operator|*
name|xp
operator|-
name|x
expr_stmt|;
block|}
name|utmp
operator|*=
name|dy
expr_stmt|;
if|if
condition|(
name|dy
operator|>
name|dx
condition|)
block|{
name|utmp
operator|=
operator|(
name|utmp
operator|<<
literal|1
operator|)
operator|-
name|dy
operator|+
literal|1
expr_stmt|;
name|y
operator|=
operator|*
name|yp
operator|+
name|SignTimes
argument_list|(
name|signdy
argument_list|,
name|ceiling
argument_list|(
name|utmp
argument_list|,
operator|(
name|dx
operator|<<
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
operator|*
name|yp
operator|+
name|SignTimes
argument_list|(
name|signdy
argument_list|,
name|round
argument_list|(
name|utmp
argument_list|,
name|dx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oc
operator|=
literal|0
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|boxp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oc
operator|&
operator|(
name|OUT_ABOVE
operator||
name|OUT_BELOW
operator|)
condition|)
block|{
if|if
condition|(
name|oc
operator|&
name|OUT_ABOVE
condition|)
block|{
name|y
operator|=
name|boxp
operator|->
name|y1
expr_stmt|;
name|utmp
operator|=
name|y
operator|-
operator|*
name|yp
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
name|boxp
operator|->
name|y2
operator|-
literal|1
expr_stmt|;
name|utmp
operator|=
operator|*
name|yp
operator|-
name|y
expr_stmt|;
block|}
name|utmp
operator|*=
name|dx
expr_stmt|;
if|if
condition|(
name|dx
operator|>
name|dy
condition|)
block|{
name|utmp
operator|=
operator|(
name|utmp
operator|<<
literal|1
operator|)
operator|-
name|dx
operator|+
literal|1
expr_stmt|;
name|x
operator|=
operator|*
name|xp
operator|+
name|SignTimes
argument_list|(
name|signdx
argument_list|,
name|ceiling
argument_list|(
name|utmp
argument_list|,
operator|(
name|dy
operator|<<
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
operator|*
name|xp
operator|+
name|SignTimes
argument_list|(
name|signdx
argument_list|,
name|round
argument_list|(
name|utmp
argument_list|,
name|dy
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oc
operator|=
literal|0
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|boxp
argument_list|)
expr_stmt|;
block|}
operator|*
name|xp
operator|=
name|x
expr_stmt|;
operator|*
name|yp
operator|=
name|y
expr_stmt|;
return|return
name|oc
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* else POLYSEGMENT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INCLUDE_OTHERS */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|POLYSEGMENT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PREVIOUS
argument_list|)
end_if

begin_function
name|void
name|RROP_NAME
function|(
name|cfb8ClippedLine
function|)
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|x1
parameter_list|,
name|y1
parameter_list|,
name|x2
parameter_list|,
name|y2
parameter_list|,
name|boxp
parameter_list|,
name|shorten
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|BoxPtr
name|boxp
decl_stmt|;
name|Bool
name|shorten
decl_stmt|;
block|{
name|int
name|oc1
decl_stmt|,
name|oc2
decl_stmt|;
name|int
name|signdx
decl_stmt|,
name|signdy
decl_stmt|,
name|axis
decl_stmt|,
name|e
decl_stmt|,
name|e1
decl_stmt|,
name|e3
decl_stmt|,
name|len
decl_stmt|;
name|int
name|adx
decl_stmt|,
name|ady
decl_stmt|;
name|unsigned
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|nwidth
decl_stmt|;
name|int
name|stepx
decl_stmt|,
name|stepy
decl_stmt|;
name|int
name|xorg
decl_stmt|,
name|yorg
decl_stmt|;
name|cfbGetByteWidthAndPointer
argument_list|(
name|pDrawable
argument_list|,
name|nwidth
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|xorg
operator|=
name|pDrawable
operator|->
name|x
expr_stmt|;
name|yorg
operator|=
name|pDrawable
operator|->
name|y
expr_stmt|;
name|x1
operator|+=
name|xorg
expr_stmt|;
name|y1
operator|+=
name|yorg
expr_stmt|;
name|x2
operator|+=
name|xorg
expr_stmt|;
name|y2
operator|+=
name|yorg
expr_stmt|;
name|oc1
operator|=
literal|0
expr_stmt|;
name|oc2
operator|=
literal|0
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc1
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|boxp
argument_list|)
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc2
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|boxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc1
operator|&
name|oc2
condition|)
return|return;
name|signdx
operator|=
literal|1
expr_stmt|;
name|stepx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|adx
operator|=
name|x2
operator|-
name|x1
operator|)
operator|<
literal|0
condition|)
block|{
name|adx
operator|=
operator|-
name|adx
expr_stmt|;
name|signdx
operator|=
operator|-
literal|1
expr_stmt|;
name|stepx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|signdy
operator|=
literal|1
expr_stmt|;
name|stepy
operator|=
name|nwidth
expr_stmt|;
if|if
condition|(
operator|(
name|ady
operator|=
name|y2
operator|-
name|y1
operator|)
operator|<
literal|0
condition|)
block|{
name|ady
operator|=
operator|-
name|ady
expr_stmt|;
name|signdy
operator|=
operator|-
literal|1
expr_stmt|;
name|stepy
operator|=
operator|-
name|nwidth
expr_stmt|;
block|}
name|axis
operator|=
name|X_AXIS
expr_stmt|;
if|if
condition|(
name|adx
operator|<=
name|ady
condition|)
block|{
name|int
name|t
decl_stmt|;
name|t
operator|=
name|adx
expr_stmt|;
name|adx
operator|=
name|ady
expr_stmt|;
name|ady
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|stepx
expr_stmt|;
name|stepx
operator|=
name|stepy
expr_stmt|;
name|stepy
operator|=
name|t
expr_stmt|;
name|axis
operator|=
name|Y_AXIS
expr_stmt|;
block|}
name|e1
operator|=
name|ady
operator|<<
literal|1
expr_stmt|;
name|e3
operator|=
operator|-
operator|(
name|adx
operator|<<
literal|1
operator|)
expr_stmt|;
name|e
operator|=
operator|-
name|adx
expr_stmt|;
name|len
operator|=
name|adx
expr_stmt|;
if|if
condition|(
name|oc2
condition|)
block|{
name|int
name|xt
init|=
name|x2
decl_stmt|,
name|yt
init|=
name|y2
decl_stmt|;
name|int
name|dx
init|=
name|x2
operator|-
name|x1
decl_stmt|,
name|dy
init|=
name|y2
operator|-
name|y1
decl_stmt|;
name|int
name|change
decl_stmt|;
name|oc2
operator|=
name|cfbClipPoint
argument_list|(
name|oc2
argument_list|,
operator|&
name|xt
argument_list|,
operator|&
name|yt
argument_list|,
operator|-
name|dx
argument_list|,
operator|-
name|dy
argument_list|,
name|boxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|axis
operator|==
name|Y_AXIS
condition|)
name|change
operator|=
name|y2
operator|-
name|yt
expr_stmt|;
else|else
name|change
operator|=
name|x2
operator|-
name|xt
expr_stmt|;
if|if
condition|(
name|change
operator|<
literal|0
condition|)
name|change
operator|=
operator|-
name|change
expr_stmt|;
name|len
operator|-=
name|change
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shorten
condition|)
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|oc1
condition|)
block|{
name|int
name|xt
init|=
name|x1
decl_stmt|,
name|yt
init|=
name|y1
decl_stmt|;
name|int
name|dx
init|=
name|x2
operator|-
name|x1
decl_stmt|,
name|dy
init|=
name|y2
operator|-
name|y1
decl_stmt|;
name|int
name|changex
decl_stmt|,
name|changey
decl_stmt|;
name|oc1
operator|=
name|cfbClipPoint
argument_list|(
name|oc1
argument_list|,
operator|&
name|xt
argument_list|,
operator|&
name|yt
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|boxp
argument_list|)
expr_stmt|;
name|changex
operator|=
name|x1
operator|-
name|xt
expr_stmt|;
if|if
condition|(
name|changex
operator|<
literal|0
condition|)
name|changex
operator|=
operator|-
name|changex
expr_stmt|;
name|changey
operator|=
name|y1
operator|-
name|yt
expr_stmt|;
if|if
condition|(
name|changey
operator|<
literal|0
condition|)
name|changey
operator|=
operator|-
name|changey
expr_stmt|;
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
block|{
name|len
operator|-=
name|changex
expr_stmt|;
name|e
operator|=
name|e
operator|+
name|changey
operator|*
name|e3
operator|+
name|changex
operator|*
name|e1
expr_stmt|;
block|}
else|else
block|{
name|len
operator|-=
name|changey
expr_stmt|;
name|e
operator|=
name|e
operator|+
name|changex
operator|*
name|e3
operator|+
name|changey
operator|*
name|e1
expr_stmt|;
block|}
name|x1
operator|=
name|xt
expr_stmt|;
name|y1
operator|=
name|yt
expr_stmt|;
block|}
if|if
condition|(
name|oc1
operator||
name|oc2
operator|||
name|len
operator|<
literal|0
condition|)
return|return;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|addrb
decl_stmt|;
name|RROP_DECLARE
name|RROP_FETCH_GC
argument_list|(
name|pGC
argument_list|)
decl_stmt|;
name|addrb
operator|=
name|addr
operator|+
operator|(
name|y1
operator|*
name|nwidth
operator|)
operator|+
name|x1
expr_stmt|;
ifndef|#
directive|ifndef
name|REARRANGE
if|if
condition|(
operator|!
name|ady
condition|)
block|{
define|#
directive|define
name|body
value|{ RROP_SOLID(addrb); addrb += stepx; }
while|while
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
name|body
name|body
name|body
name|body
name|len
operator|-=
literal|4
expr_stmt|;
block|}
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|3
case|:
name|body
case|case
literal|2
case|:
name|body
case|case
literal|1
case|:
name|body
block|}
undef|#
directive|undef
name|body
block|}
else|else
endif|#
directive|endif
block|{
define|#
directive|define
name|body
value|{\ 	    RROP_SOLID(addrb); \ 	    addrb += stepx; \ 	    e += e1; \ 	    if (e>= 0) \ 	    { \ 		addrb += stepy; \ 		e += e3; \ 	     } \ 	}
ifdef|#
directive|ifdef
name|LARGE_INSTRUCTION_CACHE
while|while
condition|(
operator|(
name|len
operator|-=
literal|4
operator|)
operator|>=
literal|0
condition|)
block|{
name|body
name|body
name|body
name|body
block|}
switch|switch
condition|(
name|len
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|body
case|case
operator|-
literal|2
case|:
name|body
case|case
operator|-
literal|3
case|:
name|body
block|}
else|#
directive|else
name|IMPORTANT_START
while|while
condition|(
operator|(
name|len
operator|-=
literal|2
operator|)
operator|>=
literal|0
condition|)
block|{
name|body
name|body
block|}
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|body
expr_stmt|;
name|IMPORTANT_END
endif|#
directive|endif
block|}
name|RROP_SOLID
argument_list|(
name|addrb
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|body
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !POLYSEGMENT&& !PREVIOUS */
end_comment

end_unit

