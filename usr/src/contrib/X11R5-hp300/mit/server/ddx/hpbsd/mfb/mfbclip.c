begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* $XConsortium: mfbclip.c,v 5.2 89/11/30 14:21:50 keith Exp $ */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"miscstruct.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"gc.h"
end_include

begin_include
include|#
directive|include
file|"maskbits.h"
end_include

begin_include
include|#
directive|include
file|"mi.h"
end_include

begin_include
include|#
directive|include
file|"../include/hppriv.h"
end_include

begin_define
define|#
directive|define
name|ADDRECT
parameter_list|(
name|reg
parameter_list|,
name|r
parameter_list|,
name|fr
parameter_list|,
name|rx1
parameter_list|,
name|ry1
parameter_list|,
name|rx2
parameter_list|,
name|ry2
parameter_list|)
define|\
value|if (((rx1)< (rx2))&& ((ry1)< (ry2))&&			\     (!((reg)->data->numRects&&					\        ((r-1)->y1 == (ry1))&&					\        ((r-1)->y2 == (ry2))&&					\        ((r-1)->x1<= (rx1))&&					\        ((r-1)->x2>= (rx2)))))					\ {								\     if ((reg)->data->numRects == (reg)->data->size)		\     {								\ 	miRectAlloc(reg, 1);					\ 	fr = REGION_BOXPTR(reg);				\ 	r = fr + (reg)->data->numRects;				\     }								\     r->x1 = (rx1);						\     r->y1 = (ry1);						\     r->x2 = (rx2);						\     r->y2 = (ry2);						\     (reg)->data->numRects++;					\     if(r->x1< (reg)->extents.x1)				\ 	(reg)->extents.x1 = r->x1;				\     if(r->x2> (reg)->extents.x2)				\ 	(reg)->extents.x2 = r->x2;				\     r++;							\ }
end_define

begin_comment
comment|/* Convert bitmap clip mask into clipping region.   * First, goes through each line and makes boxes by noting the transitions  * from 0 to 1 and 1 to 0.  * Then it coalesces the current line with the previous if they have boxes  * at the same X coordinates.  */
end_comment

begin_function
name|RegionPtr
name|mfbPixmapToRegion
parameter_list|(
name|pPix
parameter_list|)
name|PixmapPtr
name|pPix
decl_stmt|;
block|{
specifier|register
name|RegionPtr
name|pReg
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|pw
decl_stmt|,
name|w
decl_stmt|;
specifier|register
name|int
name|ib
decl_stmt|;
name|int
name|width
decl_stmt|,
name|h
decl_stmt|,
name|base
decl_stmt|,
name|rx1
decl_stmt|,
name|crects
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pwLineEnd
decl_stmt|;
name|int
name|irectPrevStart
decl_stmt|,
name|irectLineStart
decl_stmt|;
specifier|register
name|BoxPtr
name|prectO
decl_stmt|,
name|prectN
decl_stmt|;
name|BoxPtr
name|FirstRect
decl_stmt|,
name|rects
decl_stmt|,
name|prectLineStart
decl_stmt|;
name|Bool
name|fInBox
decl_stmt|,
name|fSame
decl_stmt|;
specifier|register
name|unsigned
name|mask0
init|=
name|mask
index|[
literal|0
index|]
decl_stmt|;
name|pReg
operator|=
call|(
modifier|*
name|pPix
operator|->
name|drawable
operator|.
name|pScreen
operator|->
name|RegionCreate
call|)
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pReg
condition|)
return|return
name|NullRegion
return|;
name|FirstRect
operator|=
name|REGION_BOXPTR
argument_list|(
name|pReg
argument_list|)
expr_stmt|;
name|rects
operator|=
name|FirstRect
expr_stmt|;
name|width
operator|=
name|pPix
operator|->
name|drawable
operator|.
name|width
expr_stmt|;
name|pReg
operator|->
name|extents
operator|.
name|x1
operator|=
name|width
operator|-
literal|1
expr_stmt|;
name|pReg
operator|->
name|extents
operator|.
name|x2
operator|=
literal|0
expr_stmt|;
name|pw
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
name|pPix
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
operator|)
operator|->
name|bits
expr_stmt|;
name|irectPrevStart
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pPix
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
name|WAIT_READY_TO_RENDER
argument_list|(
name|pPix
operator|->
name|drawable
operator|.
name|pScreen
argument_list|)
expr_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
name|pPix
operator|->
name|drawable
operator|.
name|height
condition|;
name|h
operator|++
control|)
block|{
name|irectLineStart
operator|=
name|rects
operator|-
name|FirstRect
expr_stmt|;
comment|/* If the Screen left most bit of the word is set, we're starting in 	 * a box */
if|if
condition|(
operator|*
name|pw
operator|&
name|mask0
condition|)
block|{
name|fInBox
operator|=
name|TRUE
expr_stmt|;
name|rx1
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fInBox
operator|=
name|FALSE
expr_stmt|;
comment|/* Process all words which are fully in the pixmap */
name|pwLineEnd
operator|=
name|pw
operator|+
operator|(
name|width
operator|>>
literal|5
operator|)
expr_stmt|;
for|for
control|(
name|base
operator|=
literal|0
init|;
name|pw
operator|<
name|pwLineEnd
condition|;
name|base
operator|+=
literal|32
control|)
block|{
name|w
operator|=
operator|*
name|pw
operator|++
expr_stmt|;
if|if
condition|(
name|fInBox
condition|)
block|{
if|if
condition|(
operator|!
operator|~
name|w
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|w
condition|)
continue|continue;
block|}
for|for
control|(
name|ib
operator|=
literal|0
init|;
name|ib
operator|<
literal|32
condition|;
name|ib
operator|++
control|)
block|{
comment|/* If the Screen left most bit of the word is set, we're 		 * starting a box */
if|if
condition|(
name|w
operator|&
name|mask0
condition|)
block|{
if|if
condition|(
operator|!
name|fInBox
condition|)
block|{
name|rx1
operator|=
name|base
operator|+
name|ib
expr_stmt|;
comment|/* start new box */
name|fInBox
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fInBox
condition|)
block|{
comment|/* end box */
name|ADDRECT
argument_list|(
name|pReg
argument_list|,
name|rects
argument_list|,
name|FirstRect
argument_list|,
name|rx1
argument_list|,
name|h
argument_list|,
name|base
operator|+
name|ib
argument_list|,
name|h
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fInBox
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/* Shift the word VISUALLY left one. */
name|w
operator|=
name|SCRLEFT
argument_list|(
name|w
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|width
operator|&
literal|0x1F
condition|)
block|{
comment|/* Process final partial word on line */
name|w
operator|=
operator|*
name|pw
operator|++
expr_stmt|;
for|for
control|(
name|ib
operator|=
literal|0
init|;
name|ib
operator|<
operator|(
name|width
operator|&
literal|0x1F
operator|)
condition|;
name|ib
operator|++
control|)
block|{
comment|/* If the Screen left most bit of the word is set, we're 		 * starting a box */
if|if
condition|(
name|w
operator|&
name|mask0
condition|)
block|{
if|if
condition|(
operator|!
name|fInBox
condition|)
block|{
name|rx1
operator|=
name|base
operator|+
name|ib
expr_stmt|;
comment|/* start new box */
name|fInBox
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fInBox
condition|)
block|{
comment|/* end box */
name|ADDRECT
argument_list|(
name|pReg
argument_list|,
name|rects
argument_list|,
name|FirstRect
argument_list|,
name|rx1
argument_list|,
name|h
argument_list|,
name|base
operator|+
name|ib
argument_list|,
name|h
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fInBox
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/* Shift the word VISUALLY left one. */
name|w
operator|=
name|SCRLEFT
argument_list|(
name|w
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If scanline ended with last bit set, end the box */
if|if
condition|(
name|fInBox
condition|)
block|{
name|ADDRECT
argument_list|(
name|pReg
argument_list|,
name|rects
argument_list|,
name|FirstRect
argument_list|,
name|rx1
argument_list|,
name|h
argument_list|,
name|base
operator|+
operator|(
name|width
operator|&
literal|0x1f
operator|)
argument_list|,
name|h
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* if all rectangles on this line have the same x-coords as 	 * those on the previous line, then add 1 to all the previous  y2s and  	 * throw away all the rectangles from this line  	 */
name|fSame
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|irectPrevStart
operator|!=
operator|-
literal|1
condition|)
block|{
name|crects
operator|=
name|irectLineStart
operator|-
name|irectPrevStart
expr_stmt|;
if|if
condition|(
name|crects
operator|==
operator|(
operator|(
name|rects
operator|-
name|FirstRect
operator|)
operator|-
name|irectLineStart
operator|)
condition|)
block|{
name|prectO
operator|=
name|FirstRect
operator|+
name|irectPrevStart
expr_stmt|;
name|prectN
operator|=
name|prectLineStart
operator|=
name|FirstRect
operator|+
name|irectLineStart
expr_stmt|;
name|fSame
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|prectO
operator|<
name|prectLineStart
condition|)
block|{
if|if
condition|(
operator|(
name|prectO
operator|->
name|x1
operator|!=
name|prectN
operator|->
name|x1
operator|)
operator|||
operator|(
name|prectO
operator|->
name|x2
operator|!=
name|prectN
operator|->
name|x2
operator|)
condition|)
block|{
name|fSame
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|prectO
operator|++
expr_stmt|;
name|prectN
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fSame
condition|)
block|{
name|prectO
operator|=
name|FirstRect
operator|+
name|irectPrevStart
expr_stmt|;
while|while
condition|(
name|prectO
operator|<
name|prectLineStart
condition|)
block|{
name|prectO
operator|->
name|y2
operator|+=
literal|1
expr_stmt|;
name|prectO
operator|++
expr_stmt|;
block|}
name|rects
operator|-=
name|crects
expr_stmt|;
name|pReg
operator|->
name|data
operator|->
name|numRects
operator|-=
name|crects
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|fSame
condition|)
name|irectPrevStart
operator|=
name|irectLineStart
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pReg
operator|->
name|data
operator|->
name|numRects
condition|)
name|pReg
operator|->
name|extents
operator|.
name|x1
operator|=
name|pReg
operator|->
name|extents
operator|.
name|x2
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|pReg
operator|->
name|extents
operator|.
name|y1
operator|=
name|REGION_BOXPTR
argument_list|(
name|pReg
argument_list|)
operator|->
name|y1
expr_stmt|;
name|pReg
operator|->
name|extents
operator|.
name|y2
operator|=
name|REGION_END
argument_list|(
name|pReg
argument_list|)
operator|->
name|y2
expr_stmt|;
if|if
condition|(
name|pReg
operator|->
name|data
operator|->
name|numRects
operator|==
literal|1
condition|)
block|{
name|xfree
argument_list|(
name|pReg
operator|->
name|data
argument_list|)
expr_stmt|;
name|pReg
operator|->
name|data
operator|=
operator|(
name|RegDataPtr
operator|)
name|NULL
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|miValidRegion
argument_list|(
name|pReg
argument_list|)
condition|)
name|FatalError
argument_list|(
literal|"Assertion failed file %s, line %d: expr\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pReg
operator|)
return|;
block|}
end_function

end_unit

