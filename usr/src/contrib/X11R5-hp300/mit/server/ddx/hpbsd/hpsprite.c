begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * hpsprite.c  *  * hp screen independent software sprite routines  */
end_comment

begin_comment
comment|/* $XConsortium: misprite.c,v 5.28 90/01/13 17:33:32 rws Exp $ */
end_comment

begin_comment
comment|/* Copyright 1989 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"mi.h"
end_include

begin_include
include|#
directive|include
file|"cursorstr.h"
end_include

begin_include
include|#
directive|include
file|"font.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"colormapst.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"hpspritest.h"
end_include

begin_include
include|#
directive|include
file|"dixfontstr.h"
end_include

begin_include
include|#
directive|include
file|"fontstruct.h"
end_include

begin_include
include|#
directive|include
file|"hppriv.h"
end_include

begin_comment
comment|/*  * screen wrappers  */
end_comment

begin_function_decl
specifier|static
name|Bool
name|hpSpriteCloseScreen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpSpriteGetImage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpSpriteGetSpans
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpSpriteSourceValidate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Bool
name|hpSpriteCreateGC
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpSpriteInstallColormap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpSpriteStoreColors
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpSpritePaintWindowBackground
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpSpritePaintWindowBorder
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpSpriteCopyWindow
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpSpriteClearToBackground
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpSpriteSaveDoomedAreas
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|RegionPtr
name|hpSpriteRestoreAreas
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Bool
name|hpCursorLoc
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SCREEN_PROLOGUE
parameter_list|(
name|pScreen
parameter_list|,
name|field
parameter_list|)
define|\
value|((pScreen)->field = getPrivScreenPtr(pScreen)->field)
end_define

begin_define
define|#
directive|define
name|SCREEN_EPILOGUE
parameter_list|(
name|pScreen
parameter_list|,
name|field
parameter_list|,
name|wrapper
parameter_list|)
define|\
value|((pScreen)->field = wrapper)
end_define

begin_comment
comment|/*  * GC func wrappers  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|hpSpriteGeneration
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpSpriteGCIndex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpSpriteValidateGC
argument_list|()
decl_stmt|,
name|hpSpriteCopyGC
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpSpriteDestroyGC
argument_list|()
decl_stmt|,
name|hpSpriteChangeGC
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpSpriteChangeClip
argument_list|()
decl_stmt|,
name|hpSpriteDestroyClip
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|hpSpriteCopyClip
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|GCFuncs
name|hpSpriteGCFuncs
init|=
block|{
name|hpSpriteValidateGC
block|,
name|hpSpriteChangeGC
block|,
name|hpSpriteCopyGC
block|,
name|hpSpriteDestroyGC
block|,
name|hpSpriteChangeClip
block|,
name|hpSpriteDestroyClip
block|,
name|hpSpriteCopyClip
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GC_FUNC_PROLOGUE
parameter_list|(
name|pGC
parameter_list|)
define|\
value|hpSpriteGCPtr   pGCPriv =					\ 	(hpSpriteGCPtr) (pGC)->devPrivates[hpSpriteGCIndex].ptr;\     (pGC)->funcs = pGCPriv->wrapFuncs;				\     if (pGCPriv->wrapOps)					\ 	(pGC)->ops = pGCPriv->wrapOps;
end_define

begin_define
define|#
directive|define
name|GC_FUNC_EPILOGUE
parameter_list|(
name|pGC
parameter_list|)
define|\
value|pGCPriv->wrapFuncs = (pGC)->funcs;				\     (pGC)->funcs =&hpSpriteGCFuncs;				\     if (pGCPriv->wrapOps)					\     {								\ 	pGCPriv->wrapOps = (pGC)->ops;				\ 	(pGC)->ops =&hpSpriteGCOps;				\     }
end_define

begin_comment
comment|/*  * GC op wrappers  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|hpSpriteFillSpans
argument_list|()
decl_stmt|,
name|hpSpriteSetSpans
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|hpSpritePutImage
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|RegionPtr
name|hpSpriteCopyArea
argument_list|()
decl_stmt|,
name|hpSpriteCopyPlane
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpSpritePolyPoint
argument_list|()
decl_stmt|,
name|hpSpritePolylines
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpSpritePolySegment
argument_list|()
decl_stmt|,
name|hpSpritePolyRectangle
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpSpritePolyArc
argument_list|()
decl_stmt|,
name|hpSpriteFillPolygon
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpSpritePolyFillRect
argument_list|()
decl_stmt|,
name|hpSpritePolyFillArc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpSpritePolyText8
argument_list|()
decl_stmt|,
name|hpSpritePolyText16
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpSpriteImageText8
argument_list|()
decl_stmt|,
name|hpSpriteImageText16
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpSpriteImageGlyphBlt
argument_list|()
decl_stmt|,
name|hpSpritePolyGlyphBlt
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpSpritePushPixels
argument_list|()
decl_stmt|,
name|hpSpriteLineHelper
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpSpriteChangeClip
argument_list|()
decl_stmt|,
name|hpSpriteDestroyClip
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|hpSpriteCopyClip
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|GCOps
name|hpSpriteGCOps
init|=
block|{
name|hpSpriteFillSpans
block|,
name|hpSpriteSetSpans
block|,
name|hpSpritePutImage
block|,
name|hpSpriteCopyArea
block|,
name|hpSpriteCopyPlane
block|,
name|hpSpritePolyPoint
block|,
name|hpSpritePolylines
block|,
name|hpSpritePolySegment
block|,
name|hpSpritePolyRectangle
block|,
name|hpSpritePolyArc
block|,
name|hpSpriteFillPolygon
block|,
name|hpSpritePolyFillRect
block|,
name|hpSpritePolyFillArc
block|,
name|hpSpritePolyText8
block|,
name|hpSpritePolyText16
block|,
name|hpSpriteImageText8
block|,
name|hpSpriteImageText16
block|,
name|hpSpriteImageGlyphBlt
block|,
name|hpSpritePolyGlyphBlt
block|,
name|hpSpritePushPixels
block|,
name|hpSpriteLineHelper
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * testing only -- remove cursor for every draw.  Eventually,  * each draw operation will perform a bounding box check against  * the saved cursor area  */
end_comment

begin_define
define|#
directive|define
name|GC_SETUP_CHEAP
parameter_list|(
name|pDrawable
parameter_list|)
define|\
value|hpPrivScreenPtr	pScreenPriv = getPrivScreenPtr((pDrawable)->pScreen);
end_define

begin_define
define|#
directive|define
name|GC_SETUP
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|)
define|\
value|GC_SETUP_CHEAP(pDrawable)					    \     hpSpriteGCPtr	pGCPrivate = (hpSpriteGCPtr)		    \ 	(pGC)->devPrivates[hpSpriteGCIndex].ptr;		    \     GCFuncs *oldFuncs = pGC->funcs;
end_define

begin_define
define|#
directive|define
name|GC_SETUP_AND_CHECK
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|)
define|\
value|GC_SETUP(pDrawable, pGC);					    \     if (GC_CHECK((WindowPtr)pDrawable))				    \ 	(*pScreenPriv->CursorOff) (pDrawable->pScreen);
end_define

begin_define
define|#
directive|define
name|GC_CHECK
parameter_list|(
name|pWin
parameter_list|)
define|\
value|(pScreenPriv->cstate == CURSOR_ON&&			    \ 	(pWin)->drawable.x< pScreenPriv->saved.x2&&		    \ 	pScreenPriv->saved.x1< (pWin)->drawable.x + (int) (pWin)->drawable.width&& \ 	(pWin)->drawable.y< pScreenPriv->saved.y2&&		    \ 	pScreenPriv->saved.y1< (pWin)->drawable.y + (int) (pWin)->drawable.height)
end_define

begin_define
define|#
directive|define
name|GC_OP_PROLOGUE
parameter_list|(
name|pGC
parameter_list|)
value|{ \     (pGC)->funcs = pGCPrivate->wrapFuncs; \     (pGC)->ops = pGCPrivate->wrapOps; \     }
end_define

begin_define
define|#
directive|define
name|GC_OP_EPILOGUE
parameter_list|(
name|pGC
parameter_list|)
value|{ \     pGCPrivate->wrapOps = (pGC)->ops; \     (pGC)->funcs = oldFuncs; \     (pGC)->ops =&hpSpriteGCOps; \     }
end_define

begin_comment
comment|/*  * hpSpriteInitialize -- called from device-dependent screen  * initialization proc after all of the function pointers have  * been stored in the screen structure.  */
end_comment

begin_function
name|Bool
name|hpSpriteInitialize
parameter_list|(
name|pScreen
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
block|{
name|hpPrivScreenPtr
name|pPriv
decl_stmt|;
if|if
condition|(
name|hpSpriteGeneration
operator|!=
name|serverGeneration
condition|)
block|{
name|hpSpriteGeneration
operator|=
name|serverGeneration
expr_stmt|;
name|hpSpriteGCIndex
operator|=
name|AllocateGCPrivateIndex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|AllocateGCPrivate
argument_list|(
name|pScreen
argument_list|,
name|hpSpriteGCIndex
argument_list|,
sizeof|sizeof
argument_list|(
name|hpSpriteGCRec
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|pPriv
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
name|pPriv
operator|->
name|pInstalledMap
operator|=
name|NULL
expr_stmt|;
name|pPriv
operator|->
name|CloseScreen
operator|=
name|pScreen
operator|->
name|CloseScreen
expr_stmt|;
name|pPriv
operator|->
name|GetImage
operator|=
name|pScreen
operator|->
name|GetImage
expr_stmt|;
name|pPriv
operator|->
name|GetSpans
operator|=
name|pScreen
operator|->
name|GetSpans
expr_stmt|;
name|pPriv
operator|->
name|SourceValidate
operator|=
name|pScreen
operator|->
name|SourceValidate
expr_stmt|;
name|pPriv
operator|->
name|CreateGC
operator|=
name|pScreen
operator|->
name|CreateGC
expr_stmt|;
name|pPriv
operator|->
name|InstallColormap
operator|=
name|pScreen
operator|->
name|InstallColormap
expr_stmt|;
name|pPriv
operator|->
name|StoreColors
operator|=
name|pScreen
operator|->
name|StoreColors
expr_stmt|;
name|pPriv
operator|->
name|PaintWindowBackground
operator|=
name|pScreen
operator|->
name|PaintWindowBackground
expr_stmt|;
name|pPriv
operator|->
name|PaintWindowBorder
operator|=
name|pScreen
operator|->
name|PaintWindowBorder
expr_stmt|;
name|pPriv
operator|->
name|CopyWindow
operator|=
name|pScreen
operator|->
name|CopyWindow
expr_stmt|;
name|pPriv
operator|->
name|ClearToBackground
operator|=
name|pScreen
operator|->
name|ClearToBackground
expr_stmt|;
name|pPriv
operator|->
name|SaveDoomedAreas
operator|=
name|pScreen
operator|->
name|SaveDoomedAreas
expr_stmt|;
name|pPriv
operator|->
name|RestoreAreas
operator|=
name|pScreen
operator|->
name|RestoreAreas
expr_stmt|;
name|pScreen
operator|->
name|CloseScreen
operator|=
name|hpSpriteCloseScreen
expr_stmt|;
name|pScreen
operator|->
name|GetImage
operator|=
name|hpSpriteGetImage
expr_stmt|;
name|pScreen
operator|->
name|GetSpans
operator|=
name|hpSpriteGetSpans
expr_stmt|;
name|pScreen
operator|->
name|SourceValidate
operator|=
name|hpSpriteSourceValidate
expr_stmt|;
name|pScreen
operator|->
name|CreateGC
operator|=
name|hpSpriteCreateGC
expr_stmt|;
name|pScreen
operator|->
name|InstallColormap
operator|=
name|hpSpriteInstallColormap
expr_stmt|;
name|pScreen
operator|->
name|StoreColors
operator|=
name|hpSpriteStoreColors
expr_stmt|;
name|pScreen
operator|->
name|PaintWindowBackground
operator|=
name|hpSpritePaintWindowBackground
expr_stmt|;
name|pScreen
operator|->
name|PaintWindowBorder
operator|=
name|hpSpritePaintWindowBorder
expr_stmt|;
name|pScreen
operator|->
name|CopyWindow
operator|=
name|hpSpriteCopyWindow
expr_stmt|;
name|pScreen
operator|->
name|ClearToBackground
operator|=
name|hpSpriteClearToBackground
expr_stmt|;
name|pScreen
operator|->
name|SaveDoomedAreas
operator|=
name|hpSpriteSaveDoomedAreas
expr_stmt|;
name|pScreen
operator|->
name|RestoreAreas
operator|=
name|hpSpriteRestoreAreas
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Screen wrappers  */
end_comment

begin_comment
comment|/*  * CloseScreen wrapper -- unwrap everything, free the private data  * and call the wrapped function  */
end_comment

begin_function
specifier|static
name|Bool
name|hpSpriteCloseScreen
parameter_list|(
name|i
parameter_list|,
name|pScreen
parameter_list|)
name|int
name|i
decl_stmt|;
name|ScreenPtr
name|pScreen
decl_stmt|;
block|{
name|hpPrivScreenPtr
name|pScreenPriv
init|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
name|pScreen
operator|->
name|CloseScreen
operator|=
name|pScreenPriv
operator|->
name|CloseScreen
expr_stmt|;
name|pScreen
operator|->
name|GetImage
operator|=
name|pScreenPriv
operator|->
name|GetImage
expr_stmt|;
name|pScreen
operator|->
name|GetSpans
operator|=
name|pScreenPriv
operator|->
name|GetSpans
expr_stmt|;
name|pScreen
operator|->
name|SourceValidate
operator|=
name|pScreenPriv
operator|->
name|SourceValidate
expr_stmt|;
name|pScreen
operator|->
name|CreateGC
operator|=
name|pScreenPriv
operator|->
name|CreateGC
expr_stmt|;
name|pScreen
operator|->
name|InstallColormap
operator|=
name|pScreenPriv
operator|->
name|InstallColormap
expr_stmt|;
name|pScreen
operator|->
name|StoreColors
operator|=
name|pScreenPriv
operator|->
name|StoreColors
expr_stmt|;
name|pScreen
operator|->
name|PaintWindowBackground
operator|=
name|pScreenPriv
operator|->
name|PaintWindowBackground
expr_stmt|;
name|pScreen
operator|->
name|PaintWindowBorder
operator|=
name|pScreenPriv
operator|->
name|PaintWindowBorder
expr_stmt|;
name|pScreen
operator|->
name|CopyWindow
operator|=
name|pScreenPriv
operator|->
name|CopyWindow
expr_stmt|;
name|pScreen
operator|->
name|ClearToBackground
operator|=
name|pScreenPriv
operator|->
name|ClearToBackground
expr_stmt|;
name|pScreen
operator|->
name|SaveDoomedAreas
operator|=
name|pScreenPriv
operator|->
name|SaveDoomedAreas
expr_stmt|;
name|pScreen
operator|->
name|RestoreAreas
operator|=
name|pScreenPriv
operator|->
name|RestoreAreas
expr_stmt|;
return|return
call|(
modifier|*
name|pScreen
operator|->
name|CloseScreen
call|)
argument_list|(
name|i
argument_list|,
name|pScreen
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteGetImage
parameter_list|(
name|pDrawable
parameter_list|,
name|sx
parameter_list|,
name|sy
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|format
parameter_list|,
name|planemask
parameter_list|,
name|pdstLine
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|int
name|sx
decl_stmt|,
name|sy
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
name|unsigned
name|int
name|format
decl_stmt|;
name|unsigned
name|long
name|planemask
decl_stmt|;
name|pointer
name|pdstLine
decl_stmt|;
block|{
name|ScreenPtr
name|pScreen
init|=
name|pDrawable
operator|->
name|pScreen
decl_stmt|;
name|hpPrivScreenPtr
name|pScreenPriv
decl_stmt|;
name|SCREEN_PROLOGUE
argument_list|(
name|pScreen
argument_list|,
name|GetImage
argument_list|)
expr_stmt|;
name|pScreenPriv
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
operator|&&
name|pScreenPriv
operator|->
name|cstate
operator|==
name|CURSOR_ON
operator|&&
name|ORG_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|pDrawable
operator|->
name|x
argument_list|,
name|pDrawable
operator|->
name|y
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
condition|)
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pScreen
operator|->
name|GetImage
call|)
argument_list|(
name|pDrawable
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|format
argument_list|,
name|planemask
argument_list|,
name|pdstLine
argument_list|)
expr_stmt|;
name|SCREEN_EPILOGUE
argument_list|(
name|pScreen
argument_list|,
name|GetImage
argument_list|,
name|hpSpriteGetImage
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteGetSpans
parameter_list|(
name|pDrawable
parameter_list|,
name|wMax
parameter_list|,
name|ppt
parameter_list|,
name|pwidth
parameter_list|,
name|nspans
parameter_list|,
name|pdstStart
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|int
name|wMax
decl_stmt|;
name|DDXPointPtr
name|ppt
decl_stmt|;
name|int
modifier|*
name|pwidth
decl_stmt|;
name|int
name|nspans
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pdstStart
decl_stmt|;
block|{
name|ScreenPtr
name|pScreen
init|=
name|pDrawable
operator|->
name|pScreen
decl_stmt|;
name|hpPrivScreenPtr
name|pScreenPriv
decl_stmt|;
name|SCREEN_PROLOGUE
argument_list|(
name|pScreen
argument_list|,
name|GetSpans
argument_list|)
expr_stmt|;
name|pScreenPriv
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
operator|&&
name|pScreenPriv
operator|->
name|cstate
operator|==
name|CURSOR_ON
condition|)
block|{
specifier|register
name|DDXPointPtr
name|pts
decl_stmt|;
specifier|register
name|int
modifier|*
name|widths
decl_stmt|;
specifier|register
name|int
name|nPts
decl_stmt|;
specifier|register
name|int
name|xorg
decl_stmt|,
name|yorg
decl_stmt|;
name|xorg
operator|=
name|pDrawable
operator|->
name|x
expr_stmt|;
name|yorg
operator|=
name|pDrawable
operator|->
name|y
expr_stmt|;
for|for
control|(
name|pts
operator|=
name|ppt
operator|,
name|widths
operator|=
name|pwidth
operator|,
name|nPts
operator|=
name|nspans
init|;
name|nPts
operator|--
condition|;
name|pts
operator|++
operator|,
name|widths
operator|++
control|)
block|{
if|if
condition|(
name|SPN_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|pts
operator|->
name|y
operator|+
name|yorg
argument_list|,
name|pts
operator|->
name|x
operator|+
name|xorg
argument_list|,
operator|*
name|widths
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
call|(
modifier|*
name|pScreen
operator|->
name|GetSpans
call|)
argument_list|(
name|pDrawable
argument_list|,
name|wMax
argument_list|,
name|ppt
argument_list|,
name|pwidth
argument_list|,
name|nspans
argument_list|,
name|pdstStart
argument_list|)
expr_stmt|;
name|SCREEN_EPILOGUE
argument_list|(
name|pScreen
argument_list|,
name|GetSpans
argument_list|,
name|hpSpriteGetSpans
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteSourceValidate
parameter_list|(
name|pDrawable
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
block|{
name|ScreenPtr
name|pScreen
init|=
name|pDrawable
operator|->
name|pScreen
decl_stmt|;
name|hpPrivScreenPtr
name|pScreenPriv
decl_stmt|;
name|SCREEN_PROLOGUE
argument_list|(
name|pScreen
argument_list|,
name|SourceValidate
argument_list|)
expr_stmt|;
name|pScreenPriv
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
operator|&&
name|pScreenPriv
operator|->
name|cstate
operator|==
name|CURSOR_ON
operator|&&
name|ORG_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|pDrawable
operator|->
name|x
argument_list|,
name|pDrawable
operator|->
name|y
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pScreen
operator|->
name|SourceValidate
condition|)
call|(
modifier|*
name|pScreen
operator|->
name|SourceValidate
call|)
argument_list|(
name|pDrawable
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|SCREEN_EPILOGUE
argument_list|(
name|pScreen
argument_list|,
name|SourceValidate
argument_list|,
name|hpSpriteSourceValidate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Bool
name|hpSpriteCreateGC
parameter_list|(
name|pGC
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
block|{
name|ScreenPtr
name|pScreen
init|=
name|pGC
operator|->
name|pScreen
decl_stmt|;
name|Bool
name|ret
decl_stmt|;
name|hpSpriteGCPtr
name|pPriv
decl_stmt|;
name|SCREEN_PROLOGUE
argument_list|(
name|pScreen
argument_list|,
name|CreateGC
argument_list|)
expr_stmt|;
name|pPriv
operator|=
operator|(
name|hpSpriteGCPtr
operator|)
name|pGC
operator|->
name|devPrivates
index|[
name|hpSpriteGCIndex
index|]
operator|.
name|ptr
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|pScreen
operator|->
name|CreateGC
call|)
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
name|pPriv
operator|->
name|wrapOps
operator|=
name|NULL
expr_stmt|;
name|pPriv
operator|->
name|wrapFuncs
operator|=
name|pGC
operator|->
name|funcs
expr_stmt|;
name|pGC
operator|->
name|funcs
operator|=
operator|&
name|hpSpriteGCFuncs
expr_stmt|;
name|SCREEN_EPILOGUE
argument_list|(
name|pScreen
argument_list|,
name|CreateGC
argument_list|,
name|hpSpriteCreateGC
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteInstallColormap
parameter_list|(
name|pMap
parameter_list|)
name|ColormapPtr
name|pMap
decl_stmt|;
block|{
name|ScreenPtr
name|pScreen
init|=
name|pMap
operator|->
name|pScreen
decl_stmt|;
name|hpPrivScreenPtr
name|pPriv
decl_stmt|;
name|pPriv
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
name|SCREEN_PROLOGUE
argument_list|(
name|pScreen
argument_list|,
name|InstallColormap
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pScreen
operator|->
name|InstallColormap
call|)
argument_list|(
name|pMap
argument_list|)
expr_stmt|;
name|SCREEN_EPILOGUE
argument_list|(
name|pScreen
argument_list|,
name|InstallColormap
argument_list|,
name|hpSpriteInstallColormap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pPriv
operator|->
name|pInstalledMap
operator|!=
name|pMap
condition|)
block|{
name|pPriv
operator|->
name|pInstalledMap
operator|=
name|pMap
expr_stmt|;
call|(
modifier|*
name|pPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteStoreColors
parameter_list|(
name|pMap
parameter_list|,
name|ndef
parameter_list|,
name|pdef
parameter_list|)
name|ColormapPtr
name|pMap
decl_stmt|;
name|int
name|ndef
decl_stmt|;
name|xColorItem
modifier|*
name|pdef
decl_stmt|;
block|{
name|ScreenPtr
name|pScreen
init|=
name|pMap
operator|->
name|pScreen
decl_stmt|;
name|hpPrivScreenPtr
name|pPriv
decl_stmt|;
if|#
directive|if
literal|0
block|int			i;
endif|#
directive|endif
name|pPriv
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
name|SCREEN_PROLOGUE
argument_list|(
name|pScreen
argument_list|,
name|StoreColors
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pScreen
operator|->
name|StoreColors
call|)
argument_list|(
name|pMap
argument_list|,
name|ndef
argument_list|,
name|pdef
argument_list|)
expr_stmt|;
name|SCREEN_EPILOGUE
argument_list|(
name|pScreen
argument_list|,
name|StoreColors
argument_list|,
name|hpSpriteStoreColors
argument_list|)
expr_stmt|;
if|if
condition|(
name|pPriv
operator|->
name|pInstalledMap
operator|==
name|pMap
condition|)
block|{
if|#
directive|if
literal|0
block|for (i = 0; i< ndef; i++)
comment|/* 	     * XXX direct color will affect pixels other than 	     * pdef[i].pixel -- this will be more difficult... 	     */
block|if (pdef[i].pixel == pPriv->colors[SOURCE_COLOR].pixel || 	        pdef[i].pixel == pPriv->colors[MASK_COLOR].pixel) 	    { 		pPriv->checkPixels = TRUE; 		if (pPriv->isUp&& pPriv->shouldBeUp)
endif|#
directive|endif
call|(
modifier|*
name|pPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|break; 	    }
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|hpSpriteFindColors
parameter_list|(
name|pScreen
parameter_list|,
name|pCursor
parameter_list|,
name|fgpix
parameter_list|,
name|bgpix
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
name|CursorPtr
name|pCursor
decl_stmt|;
name|Pixel
modifier|*
name|fgpix
decl_stmt|,
decl|*
name|bgpix
decl_stmt|;
end_function

begin_block
block|{
name|ColormapPtr
name|cmap
init|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
operator|->
name|pInstalledMap
decl_stmt|;
name|xColorItem
name|fgitem
decl_stmt|,
name|bgitem
decl_stmt|;
name|fgitem
operator|.
name|red
operator|=
name|pCursor
operator|->
name|foreRed
expr_stmt|;
name|fgitem
operator|.
name|green
operator|=
name|pCursor
operator|->
name|foreGreen
expr_stmt|;
name|fgitem
operator|.
name|blue
operator|=
name|pCursor
operator|->
name|foreBlue
expr_stmt|;
name|FakeAllocColor
argument_list|(
name|cmap
argument_list|,
operator|&
name|fgitem
argument_list|)
expr_stmt|;
name|bgitem
operator|.
name|red
operator|=
name|pCursor
operator|->
name|backRed
expr_stmt|;
name|bgitem
operator|.
name|green
operator|=
name|pCursor
operator|->
name|backGreen
expr_stmt|;
name|bgitem
operator|.
name|blue
operator|=
name|pCursor
operator|->
name|backBlue
expr_stmt|;
name|FakeAllocColor
argument_list|(
name|cmap
argument_list|,
operator|&
name|bgitem
argument_list|)
expr_stmt|;
operator|*
name|fgpix
operator|=
name|fgitem
operator|.
name|pixel
expr_stmt|;
operator|*
name|bgpix
operator|=
name|bgitem
operator|.
name|pixel
expr_stmt|;
comment|/* "free" the pixels right away, don't let this confuse you */
name|FakeFreeColor
argument_list|(
name|cmap
argument_list|,
name|fgitem
operator|.
name|pixel
argument_list|)
expr_stmt|;
name|FakeFreeColor
argument_list|(
name|cmap
argument_list|,
name|bgitem
operator|.
name|pixel
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * BackingStore wrappers  */
end_comment

begin_function
specifier|static
name|void
name|hpSpriteSaveDoomedAreas
parameter_list|(
name|pWin
parameter_list|,
name|pObscured
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|)
name|WindowPtr
name|pWin
decl_stmt|;
name|RegionPtr
name|pObscured
decl_stmt|;
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
block|{
name|ScreenPtr
name|pScreen
decl_stmt|;
name|hpPrivScreenPtr
name|pScreenPriv
decl_stmt|;
name|BoxRec
name|cursorBox
decl_stmt|;
name|pScreen
operator|=
name|pWin
operator|->
name|drawable
operator|.
name|pScreen
expr_stmt|;
name|SCREEN_PROLOGUE
argument_list|(
name|pScreen
argument_list|,
name|SaveDoomedAreas
argument_list|)
expr_stmt|;
name|pScreenPriv
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pScreenPriv
operator|->
name|cstate
operator|==
name|CURSOR_ON
condition|)
block|{
name|cursorBox
operator|=
name|pScreenPriv
operator|->
name|saved
expr_stmt|;
if|if
condition|(
name|dx
operator|||
name|dy
condition|)
block|{
name|cursorBox
operator|.
name|x1
operator|+=
name|dx
expr_stmt|;
name|cursorBox
operator|.
name|y1
operator|+=
name|dy
expr_stmt|;
name|cursorBox
operator|.
name|x2
operator|+=
name|dx
expr_stmt|;
name|cursorBox
operator|.
name|y2
operator|+=
name|dy
expr_stmt|;
block|}
if|if
condition|(
call|(
modifier|*
name|pScreen
operator|->
name|RectIn
call|)
argument_list|(
name|pObscured
argument_list|,
operator|&
name|cursorBox
argument_list|)
operator|!=
name|rgnOUT
condition|)
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|pScreen
operator|->
name|SaveDoomedAreas
call|)
argument_list|(
name|pWin
argument_list|,
name|pObscured
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|SCREEN_EPILOGUE
argument_list|(
name|pScreen
argument_list|,
name|SaveDoomedAreas
argument_list|,
name|hpSpriteSaveDoomedAreas
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|RegionPtr
name|hpSpriteRestoreAreas
parameter_list|(
name|pWin
parameter_list|,
name|prgnExposed
parameter_list|)
name|WindowPtr
name|pWin
decl_stmt|;
name|RegionPtr
name|prgnExposed
decl_stmt|;
block|{
name|ScreenPtr
name|pScreen
decl_stmt|;
name|hpPrivScreenPtr
name|pScreenPriv
decl_stmt|;
name|RegionPtr
name|result
decl_stmt|;
name|pScreen
operator|=
name|pWin
operator|->
name|drawable
operator|.
name|pScreen
expr_stmt|;
name|SCREEN_PROLOGUE
argument_list|(
name|pScreen
argument_list|,
name|RestoreAreas
argument_list|)
expr_stmt|;
name|pScreenPriv
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pScreenPriv
operator|->
name|cstate
operator|==
name|CURSOR_ON
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|pScreen
operator|->
name|RectIn
call|)
argument_list|(
name|prgnExposed
argument_list|,
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|)
operator|!=
name|rgnOUT
condition|)
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
call|(
modifier|*
name|pScreen
operator|->
name|RestoreAreas
call|)
argument_list|(
name|pWin
argument_list|,
name|prgnExposed
argument_list|)
expr_stmt|;
name|SCREEN_EPILOGUE
argument_list|(
name|pScreen
argument_list|,
name|RestoreAreas
argument_list|,
name|hpSpriteRestoreAreas
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Window wrappers  */
end_comment

begin_function
specifier|static
name|void
name|hpSpritePaintWindowBackground
parameter_list|(
name|pWin
parameter_list|,
name|pRegion
parameter_list|,
name|what
parameter_list|)
name|WindowPtr
name|pWin
decl_stmt|;
name|RegionPtr
name|pRegion
decl_stmt|;
name|int
name|what
decl_stmt|;
block|{
name|ScreenPtr
name|pScreen
decl_stmt|;
name|hpPrivScreenPtr
name|pScreenPriv
decl_stmt|;
name|pScreen
operator|=
name|pWin
operator|->
name|drawable
operator|.
name|pScreen
expr_stmt|;
name|SCREEN_PROLOGUE
argument_list|(
name|pScreen
argument_list|,
name|PaintWindowBackground
argument_list|)
expr_stmt|;
name|pScreenPriv
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pScreenPriv
operator|->
name|cstate
operator|==
name|CURSOR_ON
condition|)
block|{
comment|/* 	 * If the cursor is on the same screen as the window, check the 	 * region to paint for the cursor and remove it as necessary 	 */
if|if
condition|(
call|(
modifier|*
name|pScreen
operator|->
name|RectIn
call|)
argument_list|(
name|pRegion
argument_list|,
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|)
operator|!=
name|rgnOUT
condition|)
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|pScreen
operator|->
name|PaintWindowBackground
call|)
argument_list|(
name|pWin
argument_list|,
name|pRegion
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|SCREEN_EPILOGUE
argument_list|(
name|pScreen
argument_list|,
name|PaintWindowBackground
argument_list|,
name|hpSpritePaintWindowBackground
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpritePaintWindowBorder
parameter_list|(
name|pWin
parameter_list|,
name|pRegion
parameter_list|,
name|what
parameter_list|)
name|WindowPtr
name|pWin
decl_stmt|;
name|RegionPtr
name|pRegion
decl_stmt|;
name|int
name|what
decl_stmt|;
block|{
name|ScreenPtr
name|pScreen
decl_stmt|;
name|hpPrivScreenPtr
name|pScreenPriv
decl_stmt|;
name|pScreen
operator|=
name|pWin
operator|->
name|drawable
operator|.
name|pScreen
expr_stmt|;
name|SCREEN_PROLOGUE
argument_list|(
name|pScreen
argument_list|,
name|PaintWindowBorder
argument_list|)
expr_stmt|;
name|pScreenPriv
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pScreenPriv
operator|->
name|cstate
operator|==
name|CURSOR_ON
condition|)
block|{
comment|/* 	 * If the cursor is on the same screen as the window, check the 	 * region to paint for the cursor and remove it as necessary 	 */
if|if
condition|(
call|(
modifier|*
name|pScreen
operator|->
name|RectIn
call|)
argument_list|(
name|pRegion
argument_list|,
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|)
operator|!=
name|rgnOUT
condition|)
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|pScreen
operator|->
name|PaintWindowBorder
call|)
argument_list|(
name|pWin
argument_list|,
name|pRegion
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|SCREEN_EPILOGUE
argument_list|(
name|pScreen
argument_list|,
name|PaintWindowBorder
argument_list|,
name|hpSpritePaintWindowBorder
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteCopyWindow
parameter_list|(
name|pWin
parameter_list|,
name|ptOldOrg
parameter_list|,
name|pRegion
parameter_list|)
name|WindowPtr
name|pWin
decl_stmt|;
name|DDXPointRec
name|ptOldOrg
decl_stmt|;
name|RegionPtr
name|pRegion
decl_stmt|;
block|{
name|ScreenPtr
name|pScreen
decl_stmt|;
name|hpPrivScreenPtr
name|pScreenPriv
decl_stmt|;
name|BoxRec
name|cursorBox
decl_stmt|;
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|pScreen
operator|=
name|pWin
operator|->
name|drawable
operator|.
name|pScreen
expr_stmt|;
name|SCREEN_PROLOGUE
argument_list|(
name|pScreen
argument_list|,
name|CopyWindow
argument_list|)
expr_stmt|;
name|pScreenPriv
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pScreenPriv
operator|->
name|cstate
operator|==
name|CURSOR_ON
condition|)
block|{
comment|/* 	 * check both the source and the destination areas.  The given 	 * region is source relative, so offset the cursor box by 	 * the delta position 	 */
name|cursorBox
operator|=
name|pScreenPriv
operator|->
name|saved
expr_stmt|;
name|dx
operator|=
name|pWin
operator|->
name|drawable
operator|.
name|x
operator|-
name|ptOldOrg
operator|.
name|x
expr_stmt|;
name|dy
operator|=
name|pWin
operator|->
name|drawable
operator|.
name|y
operator|-
name|ptOldOrg
operator|.
name|y
expr_stmt|;
name|cursorBox
operator|.
name|x1
operator|-=
name|dx
expr_stmt|;
name|cursorBox
operator|.
name|x2
operator|-=
name|dx
expr_stmt|;
name|cursorBox
operator|.
name|y1
operator|-=
name|dy
expr_stmt|;
name|cursorBox
operator|.
name|y2
operator|-=
name|dy
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|pScreen
operator|->
name|RectIn
call|)
argument_list|(
name|pRegion
argument_list|,
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|)
operator|!=
name|rgnOUT
operator|||
call|(
modifier|*
name|pScreen
operator|->
name|RectIn
call|)
argument_list|(
name|pRegion
argument_list|,
operator|&
name|cursorBox
argument_list|)
operator|!=
name|rgnOUT
condition|)
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|pScreen
operator|->
name|CopyWindow
call|)
argument_list|(
name|pWin
argument_list|,
name|ptOldOrg
argument_list|,
name|pRegion
argument_list|)
expr_stmt|;
name|SCREEN_EPILOGUE
argument_list|(
name|pScreen
argument_list|,
name|CopyWindow
argument_list|,
name|hpSpriteCopyWindow
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteClearToBackground
parameter_list|(
name|pWin
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|generateExposures
parameter_list|)
name|WindowPtr
name|pWin
decl_stmt|;
name|short
name|x
decl_stmt|,
name|y
decl_stmt|;
name|unsigned
name|short
name|w
decl_stmt|,
name|h
decl_stmt|;
name|Bool
name|generateExposures
decl_stmt|;
block|{
name|ScreenPtr
name|pScreen
decl_stmt|;
name|hpPrivScreenPtr
name|pScreenPriv
decl_stmt|;
name|int
name|realw
decl_stmt|,
name|realh
decl_stmt|;
name|pScreen
operator|=
name|pWin
operator|->
name|drawable
operator|.
name|pScreen
expr_stmt|;
name|SCREEN_PROLOGUE
argument_list|(
name|pScreen
argument_list|,
name|ClearToBackground
argument_list|)
expr_stmt|;
name|pScreenPriv
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pScreenPriv
operator|->
name|cstate
operator|==
name|CURSOR_ON
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|realw
operator|=
name|w
operator|)
condition|)
name|realw
operator|=
operator|(
name|int
operator|)
name|pWin
operator|->
name|drawable
operator|.
name|width
operator|-
name|x
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|realh
operator|=
name|h
operator|)
condition|)
name|realh
operator|=
operator|(
name|int
operator|)
name|pWin
operator|->
name|drawable
operator|.
name|height
operator|-
name|y
expr_stmt|;
if|if
condition|(
name|ORG_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|pWin
operator|->
name|drawable
operator|.
name|x
argument_list|,
name|pWin
operator|->
name|drawable
operator|.
name|y
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|realw
argument_list|,
name|realh
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
block|}
block|}
call|(
modifier|*
name|pScreen
operator|->
name|ClearToBackground
call|)
argument_list|(
name|pWin
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|generateExposures
argument_list|)
expr_stmt|;
name|SCREEN_EPILOGUE
argument_list|(
name|pScreen
argument_list|,
name|ClearToBackground
argument_list|,
name|hpSpriteClearToBackground
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * GC Func wrappers  */
end_comment

begin_function
specifier|static
name|void
name|hpSpriteValidateGC
parameter_list|(
name|pGC
parameter_list|,
name|changes
parameter_list|,
name|pDrawable
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
name|Mask
name|changes
decl_stmt|;
name|DrawablePtr
name|pDrawable
decl_stmt|;
block|{
name|GC_FUNC_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|funcs
operator|->
name|ValidateGC
call|)
argument_list|(
name|pGC
argument_list|,
name|changes
argument_list|,
name|pDrawable
argument_list|)
expr_stmt|;
name|pGCPriv
operator|->
name|wrapOps
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
operator|&&
operator|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
operator|)
operator|->
name|viewable
condition|)
block|{
name|WindowPtr
name|pWin
decl_stmt|;
name|RegionPtr
name|pRegion
decl_stmt|;
name|pWin
operator|=
operator|(
name|WindowPtr
operator|)
name|pDrawable
expr_stmt|;
name|pRegion
operator|=
operator|&
name|pWin
operator|->
name|clipList
expr_stmt|;
if|if
condition|(
name|pGC
operator|->
name|subWindowMode
operator|==
name|IncludeInferiors
condition|)
name|pRegion
operator|=
operator|&
name|pWin
operator|->
name|borderClip
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|pDrawable
operator|->
name|pScreen
operator|->
name|RegionNotEmpty
call|)
argument_list|(
name|pRegion
argument_list|)
condition|)
name|pGCPriv
operator|->
name|wrapOps
operator|=
name|pGC
operator|->
name|ops
expr_stmt|;
block|}
name|GC_FUNC_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteChangeGC
parameter_list|(
name|pGC
parameter_list|,
name|mask
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
block|{
name|GC_FUNC_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|funcs
operator|->
name|ChangeGC
call|)
argument_list|(
name|pGC
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|GC_FUNC_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteCopyGC
parameter_list|(
name|pGCSrc
parameter_list|,
name|mask
parameter_list|,
name|pGCDst
parameter_list|)
name|GCPtr
name|pGCSrc
decl_stmt|,
name|pGCDst
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
block|{
name|GC_FUNC_PROLOGUE
argument_list|(
name|pGCDst
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGCDst
operator|->
name|funcs
operator|->
name|CopyGC
call|)
argument_list|(
name|pGCSrc
argument_list|,
name|mask
argument_list|,
name|pGCDst
argument_list|)
expr_stmt|;
name|GC_FUNC_EPILOGUE
argument_list|(
name|pGCDst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteDestroyGC
parameter_list|(
name|pGC
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
block|{
name|GC_FUNC_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|funcs
operator|->
name|DestroyGC
call|)
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
name|GC_FUNC_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteChangeClip
parameter_list|(
name|pGC
parameter_list|,
name|type
parameter_list|,
name|pvalue
parameter_list|,
name|nrects
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|type
decl_stmt|;
name|pointer
name|pvalue
decl_stmt|;
name|int
name|nrects
decl_stmt|;
block|{
name|GC_FUNC_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|funcs
operator|->
name|ChangeClip
call|)
argument_list|(
name|pGC
argument_list|,
name|type
argument_list|,
name|pvalue
argument_list|,
name|nrects
argument_list|)
expr_stmt|;
name|GC_FUNC_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteCopyClip
parameter_list|(
name|pgcDst
parameter_list|,
name|pgcSrc
parameter_list|)
name|GCPtr
name|pgcDst
decl_stmt|,
name|pgcSrc
decl_stmt|;
block|{
name|GC_FUNC_PROLOGUE
argument_list|(
name|pgcDst
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pgcDst
operator|->
name|funcs
operator|->
name|CopyClip
call|)
argument_list|(
name|pgcDst
argument_list|,
name|pgcSrc
argument_list|)
expr_stmt|;
name|GC_FUNC_EPILOGUE
argument_list|(
name|pgcDst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteDestroyClip
parameter_list|(
name|pGC
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
block|{
name|GC_FUNC_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|funcs
operator|->
name|DestroyClip
call|)
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
name|GC_FUNC_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * GC Op wrappers  */
end_comment

begin_function
specifier|static
name|void
name|hpSpriteFillSpans
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nInit
parameter_list|,
name|pptInit
parameter_list|,
name|pwidthInit
parameter_list|,
name|fSorted
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nInit
decl_stmt|;
comment|/* number of spans to fill */
name|DDXPointPtr
name|pptInit
decl_stmt|;
comment|/* pointer to list of start points */
name|int
modifier|*
name|pwidthInit
decl_stmt|;
comment|/* pointer to list of n widths */
name|int
name|fSorted
decl_stmt|;
block|{
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
block|{
specifier|register
name|DDXPointPtr
name|pts
decl_stmt|;
specifier|register
name|int
modifier|*
name|widths
decl_stmt|;
specifier|register
name|int
name|nPts
decl_stmt|;
for|for
control|(
name|pts
operator|=
name|pptInit
operator|,
name|widths
operator|=
name|pwidthInit
operator|,
name|nPts
operator|=
name|nInit
init|;
name|nPts
operator|--
condition|;
name|pts
operator|++
operator|,
name|widths
operator|++
control|)
block|{
if|if
condition|(
name|SPN_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|pts
operator|->
name|y
argument_list|,
name|pts
operator|->
name|x
argument_list|,
operator|*
name|widths
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|nInit
argument_list|,
name|pptInit
argument_list|,
name|pwidthInit
argument_list|,
name|fSorted
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteSetSpans
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|psrc
parameter_list|,
name|ppt
parameter_list|,
name|pwidth
parameter_list|,
name|nspans
parameter_list|,
name|fSorted
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
modifier|*
name|psrc
decl_stmt|;
specifier|register
name|DDXPointPtr
name|ppt
decl_stmt|;
name|int
modifier|*
name|pwidth
decl_stmt|;
name|int
name|nspans
decl_stmt|;
name|int
name|fSorted
decl_stmt|;
block|{
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
block|{
specifier|register
name|DDXPointPtr
name|pts
decl_stmt|;
specifier|register
name|int
modifier|*
name|widths
decl_stmt|;
specifier|register
name|int
name|nPts
decl_stmt|;
for|for
control|(
name|pts
operator|=
name|ppt
operator|,
name|widths
operator|=
name|pwidth
operator|,
name|nPts
operator|=
name|nspans
init|;
name|nPts
operator|--
condition|;
name|pts
operator|++
operator|,
name|widths
operator|++
control|)
block|{
if|if
condition|(
name|SPN_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|pts
operator|->
name|y
argument_list|,
name|pts
operator|->
name|x
argument_list|,
operator|*
name|widths
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|SetSpans
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|psrc
argument_list|,
name|ppt
argument_list|,
name|pwidth
argument_list|,
name|nspans
argument_list|,
name|fSorted
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpritePutImage
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|depth
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|leftPad
parameter_list|,
name|format
parameter_list|,
name|pBits
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|w
decl_stmt|;
name|int
name|h
decl_stmt|;
name|int
name|leftPad
decl_stmt|;
name|int
name|format
decl_stmt|;
name|char
modifier|*
name|pBits
decl_stmt|;
block|{
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
block|{
if|if
condition|(
name|ORG_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|pDrawable
operator|->
name|x
argument_list|,
name|pDrawable
operator|->
name|y
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
block|}
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|PutImage
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|depth
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|leftPad
argument_list|,
name|format
argument_list|,
name|pBits
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|RegionPtr
name|hpSpriteCopyArea
parameter_list|(
name|pSrc
parameter_list|,
name|pDst
parameter_list|,
name|pGC
parameter_list|,
name|srcx
parameter_list|,
name|srcy
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|dstx
parameter_list|,
name|dsty
parameter_list|)
name|DrawablePtr
name|pSrc
decl_stmt|;
name|DrawablePtr
name|pDst
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|srcx
decl_stmt|;
name|int
name|srcy
decl_stmt|;
name|int
name|w
decl_stmt|;
name|int
name|h
decl_stmt|;
name|int
name|dstx
decl_stmt|;
name|int
name|dsty
decl_stmt|;
block|{
name|RegionPtr
name|rgn
decl_stmt|;
name|GC_SETUP
argument_list|(
name|pDst
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
comment|/* check destination/source overlap. */
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDst
argument_list|)
operator|&&
operator|(
name|ORG_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|pDst
operator|->
name|x
argument_list|,
name|pDst
operator|->
name|y
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
operator|||
operator|(
operator|(
name|pDst
operator|==
name|pSrc
operator|)
operator|&&
name|ORG_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|pSrc
operator|->
name|x
argument_list|,
name|pSrc
operator|->
name|y
argument_list|,
name|srcx
argument_list|,
name|srcy
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
operator|)
operator|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDst
operator|->
name|pScreen
argument_list|)
expr_stmt|;
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
name|rgn
operator|=
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|CopyArea
call|)
argument_list|(
name|pSrc
argument_list|,
name|pDst
argument_list|,
name|pGC
argument_list|,
name|srcx
argument_list|,
name|srcy
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
return|return
name|rgn
return|;
block|}
end_function

begin_function
specifier|static
name|RegionPtr
name|hpSpriteCopyPlane
parameter_list|(
name|pSrc
parameter_list|,
name|pDst
parameter_list|,
name|pGC
parameter_list|,
name|srcx
parameter_list|,
name|srcy
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|dstx
parameter_list|,
name|dsty
parameter_list|,
name|plane
parameter_list|)
name|DrawablePtr
name|pSrc
decl_stmt|;
name|DrawablePtr
name|pDst
decl_stmt|;
specifier|register
name|GC
modifier|*
name|pGC
decl_stmt|;
name|int
name|srcx
decl_stmt|,
name|srcy
decl_stmt|;
name|int
name|w
decl_stmt|,
name|h
decl_stmt|;
name|int
name|dstx
decl_stmt|,
name|dsty
decl_stmt|;
name|unsigned
name|long
name|plane
decl_stmt|;
block|{
name|RegionPtr
name|rgn
decl_stmt|;
name|GC_SETUP
argument_list|(
name|pDst
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
comment|/*      * check destination/source for overlap.      */
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDst
argument_list|)
operator|&&
operator|(
name|ORG_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|pDst
operator|->
name|x
argument_list|,
name|pDst
operator|->
name|y
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
operator|||
operator|(
operator|(
name|pDst
operator|==
name|pSrc
operator|)
operator|&&
name|ORG_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|pSrc
operator|->
name|x
argument_list|,
name|pSrc
operator|->
name|y
argument_list|,
name|srcx
argument_list|,
name|srcy
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
operator|)
operator|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDst
operator|->
name|pScreen
argument_list|)
expr_stmt|;
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
name|rgn
operator|=
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|CopyPlane
call|)
argument_list|(
name|pSrc
argument_list|,
name|pDst
argument_list|,
name|pGC
argument_list|,
name|srcx
argument_list|,
name|srcy
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|plane
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
return|return
name|rgn
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpritePolyPoint
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|mode
parameter_list|,
name|npt
parameter_list|,
name|pptInit
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* Origin or Previous */
name|int
name|npt
decl_stmt|;
name|xPoint
modifier|*
name|pptInit
decl_stmt|;
block|{
name|xPoint
name|t
decl_stmt|;
name|int
name|n
decl_stmt|;
name|BoxRec
name|cursor
decl_stmt|;
specifier|register
name|xPoint
modifier|*
name|pts
decl_stmt|;
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|npt
operator|&&
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
block|{
name|cursor
operator|.
name|x1
operator|=
name|pScreenPriv
operator|->
name|saved
operator|.
name|x1
operator|-
name|pDrawable
operator|->
name|x
expr_stmt|;
name|cursor
operator|.
name|y1
operator|=
name|pScreenPriv
operator|->
name|saved
operator|.
name|y1
operator|-
name|pDrawable
operator|->
name|y
expr_stmt|;
name|cursor
operator|.
name|x2
operator|=
name|pScreenPriv
operator|->
name|saved
operator|.
name|x2
operator|-
name|pDrawable
operator|->
name|x
expr_stmt|;
name|cursor
operator|.
name|y2
operator|=
name|pScreenPriv
operator|->
name|saved
operator|.
name|y2
operator|-
name|pDrawable
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CoordModePrevious
condition|)
block|{
name|t
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|y
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pts
operator|=
name|pptInit
operator|,
name|n
operator|=
name|npt
init|;
name|n
operator|--
condition|;
name|pts
operator|++
control|)
block|{
name|t
operator|.
name|x
operator|+=
name|pts
operator|->
name|x
expr_stmt|;
name|t
operator|.
name|y
operator|+=
name|pts
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|cursor
operator|.
name|x1
operator|<=
name|t
operator|.
name|x
operator|&&
name|t
operator|.
name|x
operator|<=
name|cursor
operator|.
name|x2
operator|&&
name|cursor
operator|.
name|y1
operator|<=
name|t
operator|.
name|y
operator|&&
name|t
operator|.
name|y
operator|<=
name|cursor
operator|.
name|y2
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|pts
operator|=
name|pptInit
operator|,
name|n
operator|=
name|npt
init|;
name|n
operator|--
condition|;
name|pts
operator|++
control|)
block|{
if|if
condition|(
name|cursor
operator|.
name|x1
operator|<=
name|pts
operator|->
name|x
operator|&&
name|pts
operator|->
name|x
operator|<=
name|cursor
operator|.
name|x2
operator|&&
name|cursor
operator|.
name|y1
operator|<=
name|pts
operator|->
name|y
operator|&&
name|pts
operator|->
name|y
operator|<=
name|cursor
operator|.
name|y2
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|PolyPoint
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|mode
argument_list|,
name|npt
argument_list|,
name|pptInit
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpritePolylines
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|mode
parameter_list|,
name|npt
parameter_list|,
name|pptInit
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|npt
decl_stmt|;
name|DDXPointPtr
name|pptInit
decl_stmt|;
block|{
name|BoxPtr
name|cursor
decl_stmt|;
specifier|register
name|DDXPointPtr
name|pts
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|lw
decl_stmt|;
name|int
name|extra
decl_stmt|;
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|npt
operator|&&
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
block|{
name|cursor
operator|=
operator|&
name|pScreenPriv
operator|->
name|saved
expr_stmt|;
name|lw
operator|=
name|pGC
operator|->
name|lineWidth
expr_stmt|;
name|x
operator|=
name|pptInit
operator|->
name|x
operator|+
name|pDrawable
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|pptInit
operator|->
name|y
operator|+
name|pDrawable
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|npt
operator|==
literal|1
condition|)
block|{
name|extra
operator|=
name|lw
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|LINE_OVERLAP
argument_list|(
name|cursor
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|extra
argument_list|)
condition|)
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|extra
operator|=
name|lw
operator|>>
literal|1
expr_stmt|;
comment|/* 	     * mitered joins can project quite a way from 	     * the line end; the 11 degree miter limit limits 	     * this extension to 10.43 * lw / 2, rounded up 	     * and converted to int yields 6 * lw 	     */
if|if
condition|(
name|pGC
operator|->
name|joinStyle
operator|==
name|JoinMiter
condition|)
name|extra
operator|=
literal|6
operator|*
name|lw
expr_stmt|;
elseif|else
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|==
name|CapProjecting
condition|)
name|extra
operator|=
name|lw
expr_stmt|;
for|for
control|(
name|pts
operator|=
name|pptInit
operator|+
literal|1
operator|,
name|n
operator|=
name|npt
operator|-
literal|1
init|;
name|n
operator|--
condition|;
name|pts
operator|++
control|)
block|{
name|x1
operator|=
name|x
expr_stmt|;
name|y1
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CoordModeOrigin
condition|)
block|{
name|x2
operator|=
name|pDrawable
operator|->
name|x
operator|+
name|pts
operator|->
name|x
expr_stmt|;
name|y2
operator|=
name|pDrawable
operator|->
name|y
operator|+
name|pts
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
name|x2
operator|=
name|x
operator|+
name|pts
operator|->
name|x
expr_stmt|;
name|y2
operator|=
name|y
operator|+
name|pts
operator|->
name|y
expr_stmt|;
block|}
name|x
operator|=
name|x2
expr_stmt|;
name|y
operator|=
name|y2
expr_stmt|;
name|LINE_SORT
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
if|if
condition|(
name|LINE_OVERLAP
argument_list|(
name|cursor
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|extra
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|Polylines
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|mode
argument_list|,
name|npt
argument_list|,
name|pptInit
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpritePolySegment
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nseg
parameter_list|,
name|pSegs
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nseg
decl_stmt|;
name|xSegment
modifier|*
name|pSegs
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
specifier|register
name|xSegment
modifier|*
name|segs
decl_stmt|;
name|BoxPtr
name|cursor
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|extra
decl_stmt|;
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|&&
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
block|{
name|cursor
operator|=
operator|&
name|pScreenPriv
operator|->
name|saved
expr_stmt|;
name|extra
operator|=
name|pGC
operator|->
name|lineWidth
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|==
name|CapProjecting
condition|)
name|extra
operator|=
name|pGC
operator|->
name|lineWidth
expr_stmt|;
for|for
control|(
name|segs
operator|=
name|pSegs
operator|,
name|n
operator|=
name|nseg
init|;
name|n
operator|--
condition|;
name|segs
operator|++
control|)
block|{
name|x1
operator|=
name|segs
operator|->
name|x1
operator|+
name|pDrawable
operator|->
name|x
expr_stmt|;
name|y1
operator|=
name|segs
operator|->
name|y1
operator|+
name|pDrawable
operator|->
name|y
expr_stmt|;
name|x2
operator|=
name|segs
operator|->
name|x2
operator|+
name|pDrawable
operator|->
name|x
expr_stmt|;
name|y2
operator|=
name|segs
operator|->
name|y2
operator|+
name|pDrawable
operator|->
name|y
expr_stmt|;
name|LINE_SORT
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
if|if
condition|(
name|LINE_OVERLAP
argument_list|(
name|cursor
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|extra
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|PolySegment
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|nseg
argument_list|,
name|pSegs
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpritePolyRectangle
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nrects
parameter_list|,
name|pRects
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nrects
decl_stmt|;
name|xRectangle
modifier|*
name|pRects
decl_stmt|;
block|{
specifier|register
name|xRectangle
modifier|*
name|rects
decl_stmt|;
name|BoxPtr
name|cursor
decl_stmt|;
name|int
name|lw
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
block|{
name|lw
operator|=
name|pGC
operator|->
name|lineWidth
operator|>>
literal|1
expr_stmt|;
name|cursor
operator|=
operator|&
name|pScreenPriv
operator|->
name|saved
expr_stmt|;
for|for
control|(
name|rects
operator|=
name|pRects
operator|,
name|n
operator|=
name|nrects
init|;
name|n
operator|--
condition|;
name|rects
operator|++
control|)
block|{
name|x1
operator|=
name|rects
operator|->
name|x
operator|+
name|pDrawable
operator|->
name|x
expr_stmt|;
name|y1
operator|=
name|rects
operator|->
name|y
operator|+
name|pDrawable
operator|->
name|y
expr_stmt|;
name|x2
operator|=
name|x1
operator|+
operator|(
name|int
operator|)
name|rects
operator|->
name|width
expr_stmt|;
name|y2
operator|=
name|y1
operator|+
operator|(
name|int
operator|)
name|rects
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|LINE_OVERLAP
argument_list|(
name|cursor
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y1
argument_list|,
name|lw
argument_list|)
operator|||
name|LINE_OVERLAP
argument_list|(
name|cursor
argument_list|,
name|x2
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|lw
argument_list|)
operator|||
name|LINE_OVERLAP
argument_list|(
name|cursor
argument_list|,
name|x1
argument_list|,
name|y2
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|lw
argument_list|)
operator|||
name|LINE_OVERLAP
argument_list|(
name|cursor
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x1
argument_list|,
name|y2
argument_list|,
name|lw
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|PolyRectangle
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|nrects
argument_list|,
name|pRects
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpritePolyArc
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|narcs
parameter_list|,
name|parcs
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
specifier|register
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|narcs
decl_stmt|;
name|xArc
modifier|*
name|parcs
decl_stmt|;
block|{
name|BoxPtr
name|cursor
decl_stmt|;
name|int
name|lw
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|register
name|xArc
modifier|*
name|arcs
decl_stmt|;
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
block|{
name|lw
operator|=
name|pGC
operator|->
name|lineWidth
operator|>>
literal|1
expr_stmt|;
name|cursor
operator|=
operator|&
name|pScreenPriv
operator|->
name|saved
expr_stmt|;
for|for
control|(
name|arcs
operator|=
name|parcs
operator|,
name|n
operator|=
name|narcs
init|;
name|n
operator|--
condition|;
name|arcs
operator|++
control|)
block|{
if|if
condition|(
name|ORG_OVERLAP
argument_list|(
name|cursor
argument_list|,
name|pDrawable
operator|->
name|x
argument_list|,
name|pDrawable
operator|->
name|y
argument_list|,
name|arcs
operator|->
name|x
operator|-
name|lw
argument_list|,
name|arcs
operator|->
name|y
operator|-
name|lw
argument_list|,
operator|(
name|int
operator|)
name|arcs
operator|->
name|width
operator|+
name|pGC
operator|->
name|lineWidth
argument_list|,
operator|(
name|int
operator|)
name|arcs
operator|->
name|height
operator|+
name|pGC
operator|->
name|lineWidth
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|PolyArc
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|narcs
argument_list|,
name|parcs
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteFillPolygon
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|shape
parameter_list|,
name|mode
parameter_list|,
name|count
parameter_list|,
name|pPts
parameter_list|)
specifier|register
name|DrawablePtr
name|pDrawable
decl_stmt|;
specifier|register
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|shape
decl_stmt|,
name|mode
decl_stmt|;
name|int
name|count
decl_stmt|;
name|DDXPointPtr
name|pPts
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|minx
decl_stmt|,
name|miny
decl_stmt|,
name|maxx
decl_stmt|,
name|maxy
decl_stmt|;
specifier|register
name|DDXPointPtr
name|pts
decl_stmt|;
name|int
name|n
decl_stmt|;
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|&&
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
block|{
name|x
operator|=
name|pDrawable
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|pDrawable
operator|->
name|y
expr_stmt|;
name|pts
operator|=
name|pPts
expr_stmt|;
name|minx
operator|=
name|maxx
operator|=
name|pts
operator|->
name|x
expr_stmt|;
name|miny
operator|=
name|maxy
operator|=
name|pts
operator|->
name|y
expr_stmt|;
name|pts
operator|++
expr_stmt|;
name|n
operator|=
name|count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CoordModeOrigin
condition|)
block|{
for|for
control|(
init|;
name|n
operator|--
condition|;
name|pts
operator|++
control|)
block|{
if|if
condition|(
name|pts
operator|->
name|x
operator|<
name|minx
condition|)
name|minx
operator|=
name|pts
operator|->
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|pts
operator|->
name|x
operator|>
name|maxx
condition|)
name|maxx
operator|=
name|pts
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|pts
operator|->
name|y
operator|<
name|miny
condition|)
name|miny
operator|=
name|pts
operator|->
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|pts
operator|->
name|y
operator|>
name|maxy
condition|)
name|maxy
operator|=
name|pts
operator|->
name|y
expr_stmt|;
block|}
name|minx
operator|+=
name|x
expr_stmt|;
name|miny
operator|+=
name|y
expr_stmt|;
name|maxx
operator|+=
name|x
expr_stmt|;
name|maxy
operator|+=
name|y
expr_stmt|;
block|}
else|else
block|{
name|x
operator|+=
name|minx
expr_stmt|;
name|y
operator|+=
name|miny
expr_stmt|;
name|minx
operator|=
name|maxx
operator|=
name|x
expr_stmt|;
name|miny
operator|=
name|maxy
operator|=
name|y
expr_stmt|;
for|for
control|(
init|;
name|n
operator|--
condition|;
name|pts
operator|++
control|)
block|{
name|x
operator|+=
name|pts
operator|->
name|x
expr_stmt|;
name|y
operator|+=
name|pts
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|minx
condition|)
name|minx
operator|=
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|>
name|maxx
condition|)
name|maxx
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|miny
condition|)
name|miny
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|y
operator|>
name|maxy
condition|)
name|maxy
operator|=
name|y
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BOX_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|minx
argument_list|,
name|miny
argument_list|,
name|maxx
argument_list|,
name|maxy
argument_list|)
condition|)
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|FillPolygon
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|shape
argument_list|,
name|mode
argument_list|,
name|count
argument_list|,
name|pPts
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpritePolyFillRect
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nrectFill
parameter_list|,
name|prectInit
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nrectFill
decl_stmt|;
comment|/* number of rectangles to fill */
name|xRectangle
modifier|*
name|prectInit
decl_stmt|;
comment|/* Pointer to first rectangle to fill */
block|{
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
block|{
specifier|register
name|int
name|nRect
decl_stmt|;
specifier|register
name|xRectangle
modifier|*
name|pRect
decl_stmt|;
specifier|register
name|int
name|xorg
decl_stmt|,
name|yorg
decl_stmt|;
name|xorg
operator|=
name|pDrawable
operator|->
name|x
expr_stmt|;
name|yorg
operator|=
name|pDrawable
operator|->
name|y
expr_stmt|;
for|for
control|(
name|nRect
operator|=
name|nrectFill
operator|,
name|pRect
operator|=
name|prectInit
init|;
name|nRect
operator|--
condition|;
name|pRect
operator|++
control|)
block|{
if|if
condition|(
name|ORGRECT_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|xorg
argument_list|,
name|yorg
argument_list|,
name|pRect
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|PolyFillRect
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|nrectFill
argument_list|,
name|prectInit
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpritePolyFillArc
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|narcs
parameter_list|,
name|parcs
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|narcs
decl_stmt|;
name|xArc
modifier|*
name|parcs
decl_stmt|;
block|{
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|BoxPtr
name|cursor
decl_stmt|;
specifier|register
name|xArc
modifier|*
name|arcs
decl_stmt|;
name|cursor
operator|=
operator|&
name|pScreenPriv
operator|->
name|saved
expr_stmt|;
for|for
control|(
name|arcs
operator|=
name|parcs
operator|,
name|n
operator|=
name|narcs
init|;
name|n
operator|--
condition|;
name|arcs
operator|++
control|)
block|{
if|if
condition|(
name|ORG_OVERLAP
argument_list|(
name|cursor
argument_list|,
name|pDrawable
operator|->
name|x
argument_list|,
name|pDrawable
operator|->
name|y
argument_list|,
name|arcs
operator|->
name|x
argument_list|,
name|arcs
operator|->
name|y
argument_list|,
operator|(
name|int
operator|)
name|arcs
operator|->
name|width
argument_list|,
operator|(
name|int
operator|)
name|arcs
operator|->
name|height
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|PolyFillArc
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|narcs
argument_list|,
name|parcs
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * general Poly/Image text function.  Extract glyph information,  * compute bounding box and remove cursor if it is overlapped.  */
end_comment

begin_function
specifier|static
name|Bool
name|hpSpriteTextOverlap
parameter_list|(
name|pDraw
parameter_list|,
name|font
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|n
parameter_list|,
name|charinfo
parameter_list|,
name|imageblt
parameter_list|,
name|w
parameter_list|,
name|cursorBox
parameter_list|)
name|DrawablePtr
name|pDraw
decl_stmt|;
name|FontPtr
name|font
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|;
name|CharInfoPtr
modifier|*
name|charinfo
decl_stmt|;
name|Bool
name|imageblt
decl_stmt|;
name|unsigned
name|int
name|w
decl_stmt|;
name|BoxPtr
name|cursorBox
decl_stmt|;
block|{
name|ExtentInfoRec
name|extents
decl_stmt|;
name|x
operator|+=
name|pDraw
operator|->
name|x
expr_stmt|;
name|y
operator|+=
name|pDraw
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|FONTMINBOUNDS
argument_list|(
name|font
argument_list|,
name|characterWidth
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* compute an approximate (but covering) bounding box */
if|if
condition|(
operator|!
name|imageblt
operator|||
operator|(
name|charinfo
index|[
literal|0
index|]
operator|->
name|metrics
operator|.
name|leftSideBearing
operator|<
literal|0
operator|)
condition|)
name|extents
operator|.
name|overallLeft
operator|=
name|charinfo
index|[
literal|0
index|]
operator|->
name|metrics
operator|.
name|leftSideBearing
expr_stmt|;
else|else
name|extents
operator|.
name|overallLeft
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
condition|)
name|extents
operator|.
name|overallRight
operator|=
name|w
operator|-
name|charinfo
index|[
name|n
operator|-
literal|1
index|]
operator|->
name|metrics
operator|.
name|characterWidth
expr_stmt|;
else|else
name|extents
operator|.
name|overallRight
operator|=
name|FONTMAXBOUNDS
argument_list|(
name|font
argument_list|,
name|characterWidth
argument_list|)
operator|*
operator|(
name|n
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|imageblt
operator|&&
operator|(
name|charinfo
index|[
name|n
operator|-
literal|1
index|]
operator|->
name|metrics
operator|.
name|characterWidth
operator|>
name|charinfo
index|[
name|n
operator|-
literal|1
index|]
operator|->
name|metrics
operator|.
name|rightSideBearing
operator|)
condition|)
name|extents
operator|.
name|overallRight
operator|+=
name|charinfo
index|[
name|n
operator|-
literal|1
index|]
operator|->
name|metrics
operator|.
name|characterWidth
expr_stmt|;
else|else
name|extents
operator|.
name|overallRight
operator|+=
name|charinfo
index|[
name|n
operator|-
literal|1
index|]
operator|->
name|metrics
operator|.
name|rightSideBearing
expr_stmt|;
if|if
condition|(
name|imageblt
operator|&&
name|FONTASCENT
argument_list|(
name|font
argument_list|)
operator|>
name|FONTMAXBOUNDS
argument_list|(
name|font
argument_list|,
name|ascent
argument_list|)
condition|)
name|extents
operator|.
name|overallAscent
operator|=
name|FONTASCENT
argument_list|(
name|font
argument_list|)
expr_stmt|;
else|else
name|extents
operator|.
name|overallAscent
operator|=
name|FONTMAXBOUNDS
argument_list|(
name|font
argument_list|,
name|ascent
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageblt
operator|&&
name|FONTDESCENT
argument_list|(
name|font
argument_list|)
operator|>
name|FONTMAXBOUNDS
argument_list|(
name|font
argument_list|,
name|descent
argument_list|)
condition|)
name|extents
operator|.
name|overallDescent
operator|=
name|FONTDESCENT
argument_list|(
name|font
argument_list|)
expr_stmt|;
else|else
name|extents
operator|.
name|overallDescent
operator|=
name|FONTMAXBOUNDS
argument_list|(
name|font
argument_list|,
name|descent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BOX_OVERLAP
argument_list|(
name|cursorBox
argument_list|,
name|x
operator|+
name|extents
operator|.
name|overallLeft
argument_list|,
name|y
operator|-
name|extents
operator|.
name|overallAscent
argument_list|,
name|x
operator|+
name|extents
operator|.
name|overallRight
argument_list|,
name|y
operator|+
name|extents
operator|.
name|overallDescent
argument_list|)
condition|)
return|return
name|FALSE
return|;
elseif|else
if|if
condition|(
name|imageblt
operator|&&
name|w
condition|)
return|return
name|TRUE
return|;
comment|/* if it does overlap, fall through and compute exactly, because 	 * taking down the cursor is expensive enough to make this worth it 	 */
block|}
name|QueryGlyphExtents
argument_list|(
name|font
argument_list|,
name|charinfo
argument_list|,
name|n
argument_list|,
operator|&
name|extents
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageblt
condition|)
block|{
if|if
condition|(
name|extents
operator|.
name|overallWidth
operator|>
name|extents
operator|.
name|overallRight
condition|)
name|extents
operator|.
name|overallRight
operator|=
name|extents
operator|.
name|overallWidth
expr_stmt|;
if|if
condition|(
name|extents
operator|.
name|overallWidth
operator|<
name|extents
operator|.
name|overallLeft
condition|)
name|extents
operator|.
name|overallLeft
operator|=
name|extents
operator|.
name|overallWidth
expr_stmt|;
if|if
condition|(
name|extents
operator|.
name|overallLeft
operator|>
literal|0
condition|)
name|extents
operator|.
name|overallLeft
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|extents
operator|.
name|fontAscent
operator|>
name|extents
operator|.
name|overallAscent
condition|)
name|extents
operator|.
name|overallAscent
operator|=
name|extents
operator|.
name|fontAscent
expr_stmt|;
if|if
condition|(
name|extents
operator|.
name|fontDescent
operator|>
name|extents
operator|.
name|overallDescent
condition|)
name|extents
operator|.
name|overallDescent
operator|=
name|extents
operator|.
name|fontDescent
expr_stmt|;
block|}
return|return
operator|(
name|BOX_OVERLAP
argument_list|(
name|cursorBox
argument_list|,
name|x
operator|+
name|extents
operator|.
name|overallLeft
argument_list|,
name|y
operator|-
name|extents
operator|.
name|overallAscent
argument_list|,
name|x
operator|+
name|extents
operator|.
name|overallRight
argument_list|,
name|y
operator|+
name|extents
operator|.
name|overallDescent
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * values for textType:  */
end_comment

begin_define
define|#
directive|define
name|TT_POLY8
value|0
end_define

begin_define
define|#
directive|define
name|TT_IMAGE8
value|1
end_define

begin_define
define|#
directive|define
name|TT_POLY16
value|2
end_define

begin_define
define|#
directive|define
name|TT_IMAGE16
value|3
end_define

begin_function
specifier|static
name|int
name|hpSpriteText
parameter_list|(
name|pDraw
parameter_list|,
name|pGC
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|count
parameter_list|,
name|chars
parameter_list|,
name|fontEncoding
parameter_list|,
name|textType
parameter_list|,
name|cursorBox
parameter_list|)
name|DrawablePtr
name|pDraw
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|unsigned
name|long
name|count
decl_stmt|;
name|char
modifier|*
name|chars
decl_stmt|;
name|FontEncoding
name|fontEncoding
decl_stmt|;
name|Bool
name|textType
decl_stmt|;
name|BoxPtr
name|cursorBox
decl_stmt|;
block|{
name|CharInfoPtr
modifier|*
name|charinfo
decl_stmt|;
specifier|register
name|CharInfoPtr
modifier|*
name|info
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|int
name|w
decl_stmt|;
name|void
function_decl|(
modifier|*
name|drawFunc
function_decl|)
parameter_list|()
function_decl|;
name|Bool
name|imageblt
decl_stmt|;
name|imageblt
operator|=
operator|(
name|textType
operator|==
name|TT_IMAGE8
operator|)
operator|||
operator|(
name|textType
operator|==
name|TT_IMAGE16
operator|)
expr_stmt|;
name|charinfo
operator|=
operator|(
name|CharInfoPtr
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|CharInfoPtr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|charinfo
condition|)
return|return
name|x
return|;
name|GetGlyphs
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|count
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|chars
argument_list|,
name|fontEncoding
argument_list|,
operator|&
name|n
argument_list|,
name|charinfo
argument_list|)
expr_stmt|;
name|w
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|imageblt
condition|)
for|for
control|(
name|info
operator|=
name|charinfo
operator|,
name|i
operator|=
name|n
init|;
name|i
operator|--
condition|;
name|info
operator|++
control|)
name|w
operator|+=
operator|(
operator|*
name|info
operator|)
operator|->
name|metrics
operator|.
name|characterWidth
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hpSpriteTextOverlap
argument_list|(
name|pDraw
argument_list|,
name|pGC
operator|->
name|font
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|n
argument_list|,
name|charinfo
argument_list|,
name|imageblt
argument_list|,
name|w
argument_list|,
name|cursorBox
argument_list|)
condition|)
operator|(
operator|*
name|getPrivScreenPtr
argument_list|(
name|pDraw
operator|->
name|pScreen
argument_list|)
operator|->
name|CursorOff
operator|)
operator|(
name|pDraw
operator|->
name|pScreen
operator|)
expr_stmt|;
define|#
directive|define
name|AVOID_GLYPHBLT
ifdef|#
directive|ifdef
name|AVOID_GLYPHBLT
comment|/* 	 * On displays like Apollos, which do not optimize the GlyphBlt functions because they 	 * convert fonts to their internal form in RealizeFont and optimize text directly, we 	 * want to invoke the text functions here, not the GlyphBlt functions. 	 */
switch|switch
condition|(
name|textType
condition|)
block|{
case|case
name|TT_POLY8
case|:
name|drawFunc
operator|=
name|pGC
operator|->
name|ops
operator|->
name|PolyText8
expr_stmt|;
break|break;
case|case
name|TT_IMAGE8
case|:
name|drawFunc
operator|=
name|pGC
operator|->
name|ops
operator|->
name|ImageText8
expr_stmt|;
break|break;
case|case
name|TT_POLY16
case|:
name|drawFunc
operator|=
name|pGC
operator|->
name|ops
operator|->
name|PolyText16
expr_stmt|;
break|break;
case|case
name|TT_IMAGE16
case|:
name|drawFunc
operator|=
name|pGC
operator|->
name|ops
operator|->
name|ImageText16
expr_stmt|;
break|break;
block|}
call|(
modifier|*
name|drawFunc
call|)
argument_list|(
name|pDraw
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
name|chars
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* don't AVOID_GLYPHBLT */
comment|/* 	 * On the other hand, if the device does use GlyphBlt ultimately to do text, we 	 * don't want to slow it down by invoking the text functions and having them call 	 * GetGlyphs all over again, so we go directly to the GlyphBlt functions here. 	 */
name|drawFunc
operator|=
name|imageblt
condition|?
name|pGC
operator|->
name|ops
operator|->
name|ImageGlyphBlt
else|:
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
expr_stmt|;
call|(
modifier|*
name|drawFunc
call|)
argument_list|(
name|pDraw
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|n
argument_list|,
name|charinfo
argument_list|,
name|FONTGLYPHS
argument_list|(
name|pGC
operator|->
name|font
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AVOID_GLYPHBLT */
block|}
name|DEALLOCATE_LOCAL
argument_list|(
name|charinfo
argument_list|)
expr_stmt|;
return|return
name|x
operator|+
name|w
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpSpritePolyText8
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|count
parameter_list|,
name|chars
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|chars
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
name|ret
operator|=
name|hpSpriteText
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|count
argument_list|,
name|chars
argument_list|,
name|Linear8Bit
argument_list|,
name|TT_POLY8
argument_list|,
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|PolyText8
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|count
argument_list|,
name|chars
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpSpritePolyText16
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|count
parameter_list|,
name|chars
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|short
modifier|*
name|chars
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
name|ret
operator|=
name|hpSpriteText
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|count
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chars
argument_list|,
name|FONTLASTROW
argument_list|(
name|pGC
operator|->
name|font
argument_list|)
operator|==
literal|0
condition|?
name|Linear16Bit
else|:
name|TwoD16Bit
argument_list|,
name|TT_POLY16
argument_list|,
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|PolyText16
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|count
argument_list|,
name|chars
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteImageText8
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|count
parameter_list|,
name|chars
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|chars
decl_stmt|;
block|{
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
operator|(
name|void
operator|)
name|hpSpriteText
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|count
argument_list|,
name|chars
argument_list|,
name|Linear8Bit
argument_list|,
name|TT_IMAGE8
argument_list|,
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|ImageText8
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|count
argument_list|,
name|chars
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteImageText16
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|count
parameter_list|,
name|chars
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|short
modifier|*
name|chars
decl_stmt|;
block|{
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
condition|)
operator|(
name|void
operator|)
name|hpSpriteText
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|count
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chars
argument_list|,
name|FONTLASTROW
argument_list|(
name|pGC
operator|->
name|font
argument_list|)
operator|==
literal|0
condition|?
name|Linear16Bit
else|:
name|TwoD16Bit
argument_list|,
name|TT_IMAGE16
argument_list|,
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|ImageText16
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|count
argument_list|,
name|chars
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpriteImageGlyphBlt
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|nglyph
parameter_list|,
name|ppci
parameter_list|,
name|pglyphBase
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GC
modifier|*
name|pGC
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|unsigned
name|long
name|nglyph
decl_stmt|;
name|CharInfoPtr
modifier|*
name|ppci
decl_stmt|;
comment|/* array of character info */
name|pointer
name|pglyphBase
decl_stmt|;
comment|/* start of array of glyphs */
block|{
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
operator|&&
name|hpSpriteTextOverlap
argument_list|(
name|pDrawable
argument_list|,
name|pGC
operator|->
name|font
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|nglyph
argument_list|,
name|ppci
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|ImageGlyphBlt
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|nglyph
argument_list|,
name|ppci
argument_list|,
name|pglyphBase
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpritePolyGlyphBlt
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|nglyph
parameter_list|,
name|ppci
parameter_list|,
name|pglyphBase
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|unsigned
name|long
name|nglyph
decl_stmt|;
name|CharInfoPtr
modifier|*
name|ppci
decl_stmt|;
comment|/* array of character info */
name|char
modifier|*
name|pglyphBase
decl_stmt|;
comment|/* start of array of glyphs */
block|{
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
operator|&&
name|hpSpriteTextOverlap
argument_list|(
name|pDrawable
argument_list|,
name|pGC
operator|->
name|font
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|nglyph
argument_list|,
name|ppci
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|nglyph
argument_list|,
name|ppci
argument_list|,
name|pglyphBase
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpSpritePushPixels
parameter_list|(
name|pGC
parameter_list|,
name|pBitMap
parameter_list|,
name|pDrawable
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
name|PixmapPtr
name|pBitMap
decl_stmt|;
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|int
name|w
decl_stmt|,
name|h
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|GC_SETUP
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|GC_CHECK
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pDrawable
argument_list|)
operator|&&
name|ORG_OVERLAP
argument_list|(
operator|&
name|pScreenPriv
operator|->
name|saved
argument_list|,
name|pDrawable
operator|->
name|x
argument_list|,
name|pDrawable
operator|->
name|y
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
condition|)
block|{
call|(
modifier|*
name|pScreenPriv
operator|->
name|CursorOff
call|)
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
block|}
name|GC_OP_PROLOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|PushPixels
call|)
argument_list|(
name|pGC
argument_list|,
name|pBitMap
argument_list|,
name|pDrawable
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|GC_OP_EPILOGUE
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * I don't expect this routine will ever be called, as the GC  * will have been unwrapped for the line drawing  */
end_comment

begin_function
specifier|static
name|void
name|hpSpriteLineHelper
parameter_list|()
block|{
name|FatalError
argument_list|(
literal|"hpSpriteLineHelper called\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

