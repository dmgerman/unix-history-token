begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"X.h"
end_include

begin_define
define|#
directive|define
name|NEED_EVENTS
end_define

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"cursorstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"inputstr.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"../cfb/cfb.h"
end_include

begin_include
include|#
directive|include
file|"mi.h"
end_include

begin_include
include|#
directive|include
file|"topcat.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_decl_stmt
specifier|extern
name|u_char
name|XHP_NewRule
index|[
literal|16
index|]
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * tcSolidFS -- A fast fill routine for filling spans  * with a solid color on a Topcat  * This is the pGC->FillSpans function when FillStyle == Solid and  * drawable is a window  */
end_comment

begin_function
name|void
name|tcSolidFS
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nInit
parameter_list|,
name|pptInit
parameter_list|,
name|pwidthInit
parameter_list|,
name|fSorted
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nInit
decl_stmt|;
comment|/* number of spans to fill */
name|DDXPointPtr
name|pptInit
decl_stmt|;
comment|/* pointer to list of start points */
name|int
modifier|*
name|pwidthInit
decl_stmt|;
comment|/* pointer to list of n widths */
name|int
name|fSorted
decl_stmt|;
block|{
comment|/* next three parameters are post-clip */
name|int
name|n
decl_stmt|;
comment|/* number of spans to fill */
name|DDXPointPtr
name|ppt
decl_stmt|;
comment|/* pointer to list of start points */
name|int
modifier|*
name|pwidth
decl_stmt|;
comment|/* pointer to list of n widths */
name|int
modifier|*
name|pwidthFree
decl_stmt|;
comment|/* copies of the pointers to free */
name|DDXPointPtr
name|pptFree
decl_stmt|;
name|ScreenPtr
name|pScreen
init|=
name|pDrawable
operator|->
name|pScreen
decl_stmt|;
name|u_char
name|pMask
init|=
name|getPlanesMask
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
name|int
name|zmask
init|=
name|pMask
operator|&
name|pGC
operator|->
name|planemask
decl_stmt|;
name|TOPCAT
modifier|*
name|gp_hardware
init|=
name|getTcHardware
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
name|int
name|rop
init|=
name|pGC
operator|->
name|alu
decl_stmt|;
name|int
name|srcpix
init|=
name|pGC
operator|->
name|fgPixel
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pGC
operator|->
name|planemask
operator|)
condition|)
return|return;
name|n
operator|=
name|nInit
operator|*
name|miFindMaxBand
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|pwidth
operator|=
operator|(
name|int
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ppt
operator|=
operator|(
name|DDXPointRec
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|DDXPointRec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ppt
operator|||
operator|!
name|pwidth
condition|)
block|{
name|DEALLOCATE_LOCAL
argument_list|(
name|ppt
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidth
argument_list|)
expr_stmt|;
return|return;
block|}
name|pwidthFree
operator|=
name|pwidth
expr_stmt|;
name|pptFree
operator|=
name|ppt
expr_stmt|;
name|n
operator|=
name|miClipSpans
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
argument_list|,
name|pptInit
argument_list|,
name|pwidthInit
argument_list|,
name|nInit
argument_list|,
name|ppt
argument_list|,
name|pwidth
argument_list|,
name|fSorted
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
if|if
condition|(
operator|*
name|pwidth
condition|)
block|{
comment|/* Write a span from (ppt->x,ppt->y) of width *pwidth */
comment|/* See if we can easily expand our span to a rectangle */
name|int
name|w_height
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|n
operator|&&
name|pwidth
index|[
name|w_height
index|]
operator|==
name|pwidth
index|[
name|w_height
operator|-
literal|1
index|]
operator|&&
name|ppt
index|[
name|w_height
index|]
operator|.
name|x
operator|==
name|ppt
index|[
name|w_height
operator|-
literal|1
index|]
operator|.
name|x
operator|&&
name|ppt
index|[
name|w_height
index|]
operator|.
name|y
operator|==
name|ppt
index|[
name|w_height
operator|-
literal|1
index|]
operator|.
name|y
operator|+
literal|1
condition|)
block|{
name|n
operator|--
expr_stmt|;
name|w_height
operator|++
expr_stmt|;
block|}
name|waitbusy
argument_list|(
name|pMask
argument_list|,
name|gp_hardware
argument_list|)
expr_stmt|;
name|gp_hardware
operator|->
name|write_enable
operator|=
name|zmask
operator|&
name|srcpix
expr_stmt|;
name|gp_hardware
operator|->
name|window_move_replacement_rule
operator|=
name|XHP_NewRule
index|[
name|rop
index|]
index|[
literal|3
index|]
expr_stmt|;
name|gp_hardware
operator|->
name|write_enable
operator|=
name|zmask
operator|&
operator|~
name|srcpix
expr_stmt|;
name|gp_hardware
operator|->
name|window_move_replacement_rule
operator|=
name|XHP_NewRule
index|[
name|rop
index|]
index|[
literal|0
index|]
expr_stmt|;
name|gp_hardware
operator|->
name|write_enable
operator|=
name|zmask
expr_stmt|;
name|gp_hardware
operator|->
name|pixel_write_replacement_rule
operator|=
name|GXcopy
expr_stmt|;
comment|/* XXX catseye */
name|gp_hardware
operator|->
name|frame_buf_write_enable
operator|=
name|zmask
expr_stmt|;
name|gp_hardware
operator|->
name|source_x
operator|=
name|ppt
operator|->
name|x
expr_stmt|;
name|gp_hardware
operator|->
name|source_y
operator|=
name|ppt
operator|->
name|y
expr_stmt|;
name|gp_hardware
operator|->
name|dest_x
operator|=
name|ppt
operator|->
name|x
expr_stmt|;
name|gp_hardware
operator|->
name|dest_y
operator|=
name|ppt
operator|->
name|y
expr_stmt|;
name|gp_hardware
operator|->
name|window_width
operator|=
operator|*
name|pwidth
expr_stmt|;
name|gp_hardware
operator|->
name|window_height
operator|=
name|w_height
expr_stmt|;
name|gp_hardware
operator|->
name|start_move
operator|=
name|zmask
expr_stmt|;
name|pwidth
operator|+=
name|w_height
expr_stmt|;
name|ppt
operator|+=
name|w_height
expr_stmt|;
block|}
name|DEALLOCATE_LOCAL
argument_list|(
name|pptFree
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidthFree
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

