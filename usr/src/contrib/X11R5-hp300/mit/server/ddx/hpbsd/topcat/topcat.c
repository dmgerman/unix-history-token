begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (c) 1986, 1987 by Hewlett-Packard Company Copyright (c) 1986, 1987 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD TO THIS SOFWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE.  Hewlett-Packard shall not be liable for errors  contained herein or direct, indirect, special, incidental or  consequential damages in connection with the furnishing,  performance, or use of this material.  This software is not subject to any license of the American Telephone and Telegraph Company or of the Regents of the University of California.  */
end_comment

begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<grfioctl.h>
end_include

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_define
define|#
directive|define
name|NEED_EVENTS
end_define

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"cursorstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"inputstr.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"hppriv.h"
end_include

begin_include
include|#
directive|include
file|"topcat.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"resource.h"
end_include

begin_include
include|#
directive|include
file|"mibstore.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|TopcatBrainDamage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|catseyeMono
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lastEventTime
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|hpChangeScreens
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|Bool
name|hpInitCursor
argument_list|()
decl_stmt|,
name|cfbCreateDefColormap
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|RegionPtr
name|hpcCopyArea
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mfbRegisterCopyAreaProc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|hpPrivScreenPtr
name|hp_screens
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|_topcat_ident
index|[]
init|=
literal|"@(#)98544A, 98545A, 98547A"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Bool
name|topcatSaveScreen
parameter_list|(
name|pScreen
parameter_list|,
name|on
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
name|Bool
name|on
decl_stmt|;
block|{
name|TOPCAT
modifier|*
name|gp_hardware
init|=
name|getTcHardware
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
if|if
condition|(
name|on
operator|!=
name|SCREEN_SAVER_ON
condition|)
block|{
name|lastEventTime
operator|=
name|GetTimeInMillis
argument_list|()
expr_stmt|;
comment|/* Turn on Video */
name|gp_hardware
operator|->
name|nblank
operator|=
name|TC_VIDEO_ON
expr_stmt|;
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
operator|->
name|screenBlanked
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* Turn off video */
name|gp_hardware
operator|->
name|nblank
operator|=
name|TC_VIDEO_OFF
expr_stmt|;
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
operator|->
name|screenBlanked
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|topcatUpdateColormap
parameter_list|(
name|pScreen
parameter_list|,
name|index
parameter_list|,
name|count
parameter_list|,
name|rmap
parameter_list|,
name|gmap
parameter_list|,
name|bmap
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|,
name|count
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|rmap
decl_stmt|,
decl|*
name|gmap
decl_stmt|,
modifier|*
name|bmap
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|TOPCAT
modifier|*
name|gp_hardware
init|=
name|getTcHardware
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
name|hpPrivScreenPtr
name|pPrivScreen
init|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|Bool
name|toggleScreenSaver
init|=
name|pPrivScreen
operator|->
name|screenBlanked
decl_stmt|;
if|if
condition|(
name|pPrivScreen
operator|->
name|planesMask
operator|==
literal|0x01
condition|)
return|return;
if|if
condition|(
name|toggleScreenSaver
condition|)
comment|/* We hang in status check unless video enabled */
operator|(
name|void
operator|)
name|topcatSaveScreen
argument_list|(
name|pScreen
argument_list|,
name|SCREEN_SAVER_OFF
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|unsigned
name|short
name|id
decl_stmt|;
comment|/* Wait for color map not busy */
while|while
condition|(
name|gp_hardware
operator|->
name|colormap_status
operator|&
literal|0x04
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|gp_hardware
operator|->
name|plane_mask
operator|=
literal|0xff
expr_stmt|;
name|gp_hardware
operator|->
name|red_data
operator|=
name|rmap
index|[
name|index
index|]
expr_stmt|;
name|id
operator|=
name|gp_hardware
operator|->
name|id_reset
expr_stmt|;
name|gp_hardware
operator|->
name|green_data
operator|=
name|gmap
index|[
name|index
index|]
expr_stmt|;
empty_stmt|;
name|id
operator|=
name|gp_hardware
operator|->
name|id_reset
expr_stmt|;
name|gp_hardware
operator|->
name|blue_data
operator|=
name|bmap
index|[
name|index
index|]
expr_stmt|;
empty_stmt|;
name|id
operator|=
name|gp_hardware
operator|->
name|id_reset
expr_stmt|;
name|gp_hardware
operator|->
name|color_index
operator|=
operator|~
name|index
expr_stmt|;
name|id
operator|=
name|gp_hardware
operator|->
name|id_reset
expr_stmt|;
name|gp_hardware
operator|->
name|colormap_writestrobe
operator|=
literal|0xff
expr_stmt|;
name|id
operator|=
name|gp_hardware
operator|->
name|id_reset
expr_stmt|;
comment|/* 	 * Not sure just why we have to do this, but it sure doesn't work 	 * without it. Delay loop slowed and delay after last status added. 	 * Seemed to be needed for faster 350 processor. HACK! 	 */
while|while
condition|(
name|gp_hardware
operator|->
name|colormap_status
operator|&
literal|0x04
condition|)
block|{
name|id
operator|=
name|gp_hardware
operator|->
name|id_reset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
empty_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|gp_hardware
operator|->
name|red_data
operator|=
literal|0
expr_stmt|;
name|id
operator|=
name|gp_hardware
operator|->
name|id_reset
expr_stmt|;
name|gp_hardware
operator|->
name|green_data
operator|=
literal|0
expr_stmt|;
name|id
operator|=
name|gp_hardware
operator|->
name|id_reset
expr_stmt|;
name|gp_hardware
operator|->
name|blue_data
operator|=
literal|0
expr_stmt|;
name|id
operator|=
name|gp_hardware
operator|->
name|id_reset
expr_stmt|;
name|gp_hardware
operator|->
name|color_index
operator|=
literal|0
expr_stmt|;
name|id
operator|=
name|gp_hardware
operator|->
name|id_reset
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|toggleScreenSaver
condition|)
operator|(
name|void
operator|)
name|topcatSaveScreen
argument_list|(
name|pScreen
argument_list|,
name|SCREEN_SAVER_ON
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|catseyeUpdateColormap
parameter_list|(
name|pScreen
parameter_list|,
name|index
parameter_list|,
name|count
parameter_list|,
name|rmap
parameter_list|,
name|gmap
parameter_list|,
name|bmap
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
name|int
name|index
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
name|u_char
modifier|*
name|rmap
decl_stmt|,
decl|*
name|gmap
decl_stmt|,
modifier|*
name|bmap
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|TOPCAT
modifier|*
name|gp_hardware
init|=
name|getTcHardware
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
name|hpPrivScreenPtr
name|pPrivScreen
init|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
name|Bool
name|toggleScreenSaver
init|=
name|pPrivScreen
operator|->
name|screenBlanked
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|pPrivScreen
operator|->
name|planesMask
operator|==
literal|0x01
condition|)
return|return;
comment|/* We hang in status check unless video enabled */
if|if
condition|(
name|toggleScreenSaver
condition|)
operator|(
name|void
operator|)
name|topcatSaveScreen
argument_list|(
name|pScreen
argument_list|,
name|SCREEN_SAVER_OFF
argument_list|)
expr_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|rp
decl_stmt|,
modifier|*
name|gp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|i
operator|=
name|index
expr_stmt|;
name|rp
operator|=
operator|&
name|rmap
index|[
name|i
index|]
expr_stmt|;
name|gp
operator|=
operator|&
name|gmap
index|[
name|i
index|]
expr_stmt|;
name|bp
operator|=
operator|&
name|bmap
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|count
operator|--
condition|;
name|i
operator|++
control|)
block|{
comment|/* Wait for color map not busy */
do|do
block|{
name|tmp
operator|=
literal|0x04
expr_stmt|;
block|}
do|while
condition|(
name|gp_hardware
operator|->
name|colormap_status
operator|&
name|tmp
condition|)
do|;
name|gp_hardware
operator|->
name|plane_mask
operator|=
literal|0xff
expr_stmt|;
name|gp_hardware
operator|->
name|color_index
operator|=
operator|~
name|i
expr_stmt|;
name|gp_hardware
operator|->
name|red_data
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
name|gp_hardware
operator|->
name|green_data
operator|=
operator|*
name|gp
operator|++
expr_stmt|;
name|gp_hardware
operator|->
name|blue_data
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|gp_hardware
operator|->
name|colormap_writestrobe
operator|=
literal|0xff
expr_stmt|;
block|}
block|}
do|do
block|{
name|tmp
operator|=
literal|0x04
expr_stmt|;
block|}
do|while
condition|(
name|gp_hardware
operator|->
name|colormap_status
operator|&
name|tmp
condition|)
do|;
name|gp_hardware
operator|->
name|color_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|toggleScreenSaver
condition|)
operator|(
name|void
operator|)
name|topcatSaveScreen
argument_list|(
name|pScreen
argument_list|,
name|SCREEN_SAVER_ON
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|Bool
name|topcatScreenInfo
parameter_list|(
name|index
parameter_list|,
name|argv
parameter_list|,
name|argc
parameter_list|)
name|int
name|index
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
block|{
name|hpPrivScreenPtr
name|thisScreen
decl_stmt|;
name|topcatPrivPtr
name|topcat
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|gcid
decl_stmt|;
name|thisScreen
operator|=
operator|(
name|hpPrivScreenPtr
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hpPrivScreen
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|topcatPriv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thisScreen
condition|)
return|return
name|FALSE
return|;
name|topcat
operator|=
call|(
name|topcatPrivPtr
call|)
argument_list|(
name|thisScreen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hp_screens
index|[
name|index
index|]
operator|=
name|thisScreen
expr_stmt|;
name|thisScreen
operator|->
name|pHardwareScreen
operator|=
operator|(
name|pointer
operator|)
name|topcat
expr_stmt|;
name|topcat
operator|->
name|topcatDev
operator|=
operator|(
name|TOPCAT
operator|*
operator|)
name|NULL
expr_stmt|;
name|topcat
operator|->
name|InstalledMap
operator|=
operator|(
name|ColormapPtr
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|O_WRONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ErrorF
argument_list|(
literal|"%s: couldn't open %s \n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|{
name|struct
name|grfinfo
name|gi
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|GRFIOCGINFO
argument_list|,
operator|&
name|gi
argument_list|)
operator|<
literal|0
operator|||
name|ioctl
argument_list|(
name|fd
argument_list|,
name|GRFIOCON
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ErrorF
argument_list|(
literal|"%s: couldn't GCON and GCID %s \n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|thisScreen
operator|->
name|fbOffset
operator|=
name|gi
operator|.
name|gd_regsize
expr_stmt|;
name|gcid
operator|=
name|gi
operator|.
name|gd_id
expr_stmt|;
block|}
if|if
condition|(
name|gcid
operator|!=
name|GCID_TOPCAT
condition|)
comment|/* Not a Topcat */
block|{
name|ErrorF
argument_list|(
literal|"%s: device %s not this kind of display.\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|thisScreen
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|thisScreen
operator|->
name|gcid
operator|=
name|gcid
expr_stmt|;
comment|/*      * Map the topcat in to our address space.  We could ask the O.S.      * to map it in where it prefers, but this would limit the amount of      * data we can malloc() at a later time.      * However, we don't know how much address space it will take up until      * we can examine its memWide and memHigh values....      */
block|{
name|u_char
modifier|*
name|Addr
init|=
operator|(
name|u_char
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|str_addr
init|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"XDISPADDR"
argument_list|)
decl_stmt|;
if|if
condition|(
name|str_addr
condition|)
name|Addr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|atoi
argument_list|(
name|str_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|GRFIOCMAP
argument_list|,
operator|&
name|Addr
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|GRFIOCOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"GRFIOCMAP:"
argument_list|)
expr_stmt|;
name|ErrorF
argument_list|(
literal|"%s: Error getting address of %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|topcat
operator|->
name|topcatDev
operator|=
operator|(
name|TOPCAT
operator|*
operator|)
name|Addr
expr_stmt|;
block|}
block|{
name|TOPCAT
modifier|*
name|tc
decl_stmt|;
name|tc
operator|=
name|topcat
operator|->
name|topcatDev
expr_stmt|;
name|thisScreen
operator|->
name|memHeight
operator|=
operator|(
name|tc
operator|->
name|t_memhigh
operator|<<
literal|8
operator|)
operator||
name|tc
operator|->
name|b_memhigh
expr_stmt|;
name|thisScreen
operator|->
name|memWidth
operator|=
operator|(
name|tc
operator|->
name|t_memwide
operator|<<
literal|8
operator|)
operator||
name|tc
operator|->
name|b_memwide
expr_stmt|;
if|if
condition|(
name|tc
operator|->
name|id_second
operator|==
name|ID2_TC
condition|)
name|topcat
operator|->
name|UpdateColormap
operator|=
name|topcatUpdateColormap
expr_stmt|;
else|else
name|topcat
operator|->
name|UpdateColormap
operator|=
name|catseyeUpdateColormap
expr_stmt|;
comment|/* Set up the appropriate wholeGlyph routine */
define|#
directive|define
name|ceWholeGlyph
value|tcWholeGlyph
if|if
condition|(
name|tc
operator|->
name|id_second
operator|<
name|ID2_LCC
condition|)
block|{
if|#
directive|if
literal|0
block|if (tc->bits) 		thisScreen->WholeGlyph = mrtcWholeGlyph; 	    else
endif|#
directive|endif
name|thisScreen
operator|->
name|WholeGlyph
operator|=
name|tcWholeGlyph
expr_stmt|;
block|}
else|else
name|thisScreen
operator|->
name|WholeGlyph
operator|=
name|ceWholeGlyph
expr_stmt|;
block|}
comment|/* store the screen minor number in the devPrivate structure;      * if there are four arguments, the fourth is the screen minor number;      */
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
name|thisScreen
operator|->
name|minor_num
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
name|thisScreen
operator|->
name|minor_num
operator|=
literal|0
expr_stmt|;
name|thisScreen
operator|->
name|screenBlanked
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Configure the topcat hardware masks;  */
end_comment

begin_function
name|void
name|topcatMaskConfig
parameter_list|(
name|pScreen
parameter_list|,
name|writeEnableMask
parameter_list|,
name|replacementRule
parameter_list|)
specifier|register
name|ScreenPtr
name|pScreen
decl_stmt|;
specifier|register
name|int
name|writeEnableMask
decl_stmt|,
name|replacementRule
decl_stmt|;
block|{
specifier|register
name|TOPCAT
modifier|*
name|gp_hardware
init|=
name|getTcHardware
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|int
name|planes
init|=
name|getPlanesMask
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
name|waitbusy
argument_list|(
name|planes
argument_list|,
name|gp_hardware
argument_list|)
expr_stmt|;
comment|/* wait for all planes to quiet */
name|writeEnableMask
operator|&=
name|planes
expr_stmt|;
name|gp_hardware
operator|->
name|write_enable
operator|=
name|writeEnableMask
expr_stmt|;
name|gp_hardware
operator|->
name|frame_buf_write_enable
operator|=
name|writeEnableMask
expr_stmt|;
name|gp_hardware
operator|->
name|pixel_write_replacement_rule
operator|=
name|replacementRule
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for the topcat mover hardware to be not-busy and then initiate  * the requested move operation.  */
end_comment

begin_function
name|void
name|topcatMoveBits
parameter_list|(
name|pScreen
parameter_list|,
name|planeMask
parameter_list|,
name|alu
parameter_list|,
name|sourceX
parameter_list|,
name|sourceY
parameter_list|,
name|destX
parameter_list|,
name|destY
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
name|u_char
name|planeMask
decl_stmt|;
name|int
name|alu
decl_stmt|,
name|sourceX
decl_stmt|,
name|sourceY
decl_stmt|,
name|destX
decl_stmt|,
name|destY
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
block|{
name|u_char
name|pMask
init|=
name|getPlanesMask
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
specifier|register
name|TOPCAT
modifier|*
name|gp_hardware
init|=
name|getTcHardware
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
comment|/* wait for hardware ready. test all possible planes */
while|while
condition|(
operator|(
name|gp_hardware
operator|->
name|move_active
operator|)
operator|&
name|pMask
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|100
condition|;
name|k
operator|++
control|)
empty_stmt|;
comment|/* delay to let topcat mover work */
comment|/* return without doing any other work if no planes are effected...      Note: we have assured that any previous mover operation has completed.*/
if|if
condition|(
operator|(
name|planeMask
operator|&=
name|pMask
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* XXX catseye */
name|gp_hardware
operator|->
name|frame_buf_write_enable
operator|=
name|planeMask
expr_stmt|;
name|gp_hardware
operator|->
name|write_enable
operator|=
name|planeMask
expr_stmt|;
name|gp_hardware
operator|->
name|window_move_replacement_rule
operator|=
name|alu
expr_stmt|;
name|gp_hardware
operator|->
name|source_x
operator|=
name|sourceX
expr_stmt|;
name|gp_hardware
operator|->
name|source_y
operator|=
name|sourceY
expr_stmt|;
name|gp_hardware
operator|->
name|dest_x
operator|=
name|destX
expr_stmt|;
name|gp_hardware
operator|->
name|dest_y
operator|=
name|destY
expr_stmt|;
name|gp_hardware
operator|->
name|window_width
operator|=
name|width
expr_stmt|;
name|gp_hardware
operator|->
name|window_height
operator|=
name|height
expr_stmt|;
comment|/* start move on all GC enabled planes supported by hardware */
name|gp_hardware
operator|->
name|start_move
operator|=
name|planeMask
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|Bool
name|tcCloseScreen
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|Bool
name|topcatCloseScreen
parameter_list|(
name|index
parameter_list|,
name|pScreen
parameter_list|)
name|int
name|index
decl_stmt|;
name|ScreenPtr
name|pScreen
decl_stmt|;
block|{
specifier|register
name|topcatPrivPtr
name|topcat
init|=
operator|(
name|topcatPrivPtr
operator|)
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
operator|->
name|pHardwareScreen
decl_stmt|;
specifier|register
name|u_char
name|pMask
init|=
name|getPlanesMask
argument_list|(
name|pScreen
argument_list|)
decl_stmt|;
specifier|register
name|TOPCAT
modifier|*
name|gp_hardware
init|=
name|topcat
operator|->
name|topcatDev
decl_stmt|;
specifier|static
name|u_char
name|colors
index|[
literal|2
index|]
init|=
block|{
literal|0x00
block|,
literal|0xff
block|}
decl_stmt|;
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
operator|->
name|screenBlanked
operator|=
name|FALSE
expr_stmt|;
call|(
modifier|*
name|topcat
operator|->
name|UpdateColormap
call|)
argument_list|(
name|pScreen
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|colors
argument_list|,
name|colors
argument_list|,
name|colors
argument_list|)
expr_stmt|;
name|waitbusy
argument_list|(
name|pMask
argument_list|,
name|gp_hardware
argument_list|)
expr_stmt|;
name|gp_hardware
operator|->
name|nblank
operator|=
name|TC_VIDEO_ON
expr_stmt|;
name|gp_hardware
operator|->
name|write_enable
operator|=
operator|~
literal|0
expr_stmt|;
name|gp_hardware
operator|->
name|window_move_replacement_rule
operator|=
name|GXclear
expr_stmt|;
name|gp_hardware
operator|->
name|write_enable
operator|=
operator|~
literal|0
expr_stmt|;
name|gp_hardware
operator|->
name|pixel_write_replacement_rule
operator|=
name|GXclear
expr_stmt|;
name|gp_hardware
operator|->
name|source_x
operator|=
literal|0
expr_stmt|;
name|gp_hardware
operator|->
name|source_y
operator|=
literal|0
expr_stmt|;
name|gp_hardware
operator|->
name|dest_x
operator|=
literal|0
expr_stmt|;
name|gp_hardware
operator|->
name|dest_y
operator|=
literal|0
expr_stmt|;
name|gp_hardware
operator|->
name|window_width
operator|=
name|pScreen
operator|->
name|width
expr_stmt|;
name|gp_hardware
operator|->
name|window_height
operator|=
name|pScreen
operator|->
name|height
expr_stmt|;
name|gp_hardware
operator|->
name|start_move
operator|=
operator|~
literal|0
expr_stmt|;
return|return
name|tcCloseScreen
argument_list|(
name|index
argument_list|,
name|pScreen
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tcNumPlanes
parameter_list|(
name|base
parameter_list|,
name|pMask
parameter_list|)
name|VOLATILE
name|u_char
modifier|*
name|base
decl_stmt|;
name|u_char
modifier|*
name|pMask
decl_stmt|;
block|{
name|u_char
name|sample0
decl_stmt|,
name|sample1
decl_stmt|,
name|rwBits
decl_stmt|;
name|int
name|numPlanes
decl_stmt|;
operator|*
name|base
operator|=
literal|0
expr_stmt|;
name|sample0
operator|=
operator|*
name|base
expr_stmt|;
operator|*
name|base
operator|=
literal|0xff
expr_stmt|;
name|sample1
operator|=
operator|*
name|base
expr_stmt|;
name|rwBits
operator|=
name|sample0
operator|^
name|sample1
expr_stmt|;
switch|switch
condition|(
name|rwBits
condition|)
block|{
case|case
literal|0x00
case|:
name|numPlanes
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
name|numPlanes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
name|numPlanes
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|0x07
case|:
name|numPlanes
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|0x0f
case|:
name|numPlanes
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|0x1f
case|:
name|numPlanes
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|0x3f
case|:
name|numPlanes
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|0x7f
case|:
name|numPlanes
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|0xff
case|:
name|numPlanes
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|numPlanes
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
name|pMask
operator|=
name|rwBits
expr_stmt|;
if|if
condition|(
name|TopcatBrainDamage
operator|||
operator|(
name|numPlanes
operator|<
literal|4
operator|&&
name|catseyeMono
operator|)
condition|)
block|{
operator|*
name|pMask
operator|=
literal|0x01
expr_stmt|;
name|numPlanes
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|numPlanes
return|;
block|}
end_function

begin_function
name|Bool
name|topcatScreenInit
parameter_list|(
name|index
parameter_list|,
name|pScreen
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|index
decl_stmt|;
name|ScreenPtr
name|pScreen
decl_stmt|;
name|int
name|argc
decl_stmt|;
comment|/* these two may NOT be changed */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|dpi
decl_stmt|;
name|u_char
name|numPlanes
decl_stmt|;
name|topcatPrivPtr
name|topcat
decl_stmt|;
name|TOPCAT
modifier|*
name|gp_hardware
decl_stmt|;
name|hpPrivScreenPtr
name|pPrivScreen
decl_stmt|;
comment|/* always restore the devPrivate field here;      * if it has not been allocated, this will null it out so code elsewhere      * will be sure to allocate one;      * If we've already allocated one, this will restore it;      */
name|pScreen
operator|->
name|devPrivate
operator|=
operator|(
name|pointer
operator|)
name|hp_screens
index|[
name|index
index|]
expr_stmt|;
name|pPrivScreen
operator|=
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
name|topcat
operator|=
call|(
name|topcatPrivPtr
call|)
argument_list|(
name|pPrivScreen
operator|->
name|pHardwareScreen
argument_list|)
expr_stmt|;
name|gp_hardware
operator|=
name|topcat
operator|->
name|topcatDev
expr_stmt|;
name|pPrivScreen
operator|->
name|MoveBits
operator|=
name|topcatMoveBits
expr_stmt|;
name|pPrivScreen
operator|->
name|MaskConfig
operator|=
name|topcatMaskConfig
expr_stmt|;
name|pPrivScreen
operator|->
name|ChangeScreen
operator|=
name|hpChangeScreens
expr_stmt|;
comment|/* Video card initialized */
name|gp_hardware
operator|->
name|write_enable
operator|=
operator|~
literal|0
expr_stmt|;
name|gp_hardware
operator|->
name|pixel_write_replacement_rule
operator|=
name|GXcopy
expr_stmt|;
name|gp_hardware
operator|->
name|frame_buf_write_enable
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* XXX catseye */
if|if
condition|(
name|gp_hardware
operator|->
name|id_second
operator|!=
name|ID2_TC
condition|)
block|{
name|char
modifier|*
name|foo
init|=
operator|(
name|char
operator|*
operator|)
name|gp_hardware
decl_stmt|;
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|foo
operator|+
literal|0x4510
operator|)
operator|)
operator|=
literal|0x0
expr_stmt|;
comment|/* VB      */
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|foo
operator|+
literal|0x4512
operator|)
operator|)
operator|=
literal|0x0
expr_stmt|;
comment|/* TCNTRL  */
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|foo
operator|+
literal|0x4514
operator|)
operator|)
operator|=
literal|0x0
expr_stmt|;
comment|/* ACNTRL  */
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|foo
operator|+
literal|0x4516
operator|)
operator|)
operator|=
literal|0x0
expr_stmt|;
comment|/* PNCNTRL */
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|foo
operator|+
literal|0x4206
operator|)
operator|)
operator|=
literal|0x90
expr_stmt|;
comment|/* RUG Command/Status */
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|foo
operator|+
literal|0x60A2
operator|)
operator|)
operator|=
literal|0x0
expr_stmt|;
comment|/* Overlay Mask       */
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|foo
operator|+
literal|0x60BC
operator|)
operator|)
operator|=
literal|0x0
expr_stmt|;
comment|/* Ram Select	      */
name|dpi
operator|=
literal|109
expr_stmt|;
comment|/* XXX probably bogus */
block|}
else|else
name|dpi
operator|=
literal|85
expr_stmt|;
comment|/*      * Set up the color map      */
name|numPlanes
operator|=
name|tcNumPlanes
argument_list|(
operator|(
operator|(
name|u_char
operator|*
operator|)
name|gp_hardware
operator|)
operator|+
name|pPrivScreen
operator|->
name|fbOffset
argument_list|,
operator|&
name|pPrivScreen
operator|->
name|planesMask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tcScreenInit
argument_list|(
name|pScreen
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
name|gp_hardware
operator|)
operator|+
name|pPrivScreen
operator|->
name|fbOffset
argument_list|,
operator|(
name|gp_hardware
operator|->
name|t_dispwide
operator|<<
literal|8
operator|)
operator|+
name|gp_hardware
operator|->
name|b_dispwide
argument_list|,
operator|(
name|gp_hardware
operator|->
name|t_disphigh
operator|<<
literal|8
operator|)
operator|+
name|gp_hardware
operator|->
name|b_disphigh
argument_list|,
name|dpi
argument_list|,
name|dpi
argument_list|,
name|numPlanes
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|pScreen
operator|->
name|SaveScreen
operator|=
name|topcatSaveScreen
expr_stmt|;
name|pScreen
operator|->
name|CloseScreen
operator|=
name|topcatCloseScreen
expr_stmt|;
name|mfbRegisterCopyPlaneProc
argument_list|(
name|pScreen
argument_list|,
name|tcCopyPlane
argument_list|)
expr_stmt|;
name|mfbRegisterCopyAreaProc
argument_list|(
name|pScreen
argument_list|,
name|hpcCopyArea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hpInitCursor
argument_list|(
name|pScreen
argument_list|,
literal|8
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|cfbCreateDefColormap
argument_list|(
name|pScreen
argument_list|)
condition|)
block|{
name|ErrorF
argument_list|(
literal|"Can't alloc black& white pixels in topcatScreenInit\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|(
name|void
operator|)
name|topcatSaveScreen
argument_list|(
name|pScreen
argument_list|,
name|SCREEN_SAVER_OFF
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

