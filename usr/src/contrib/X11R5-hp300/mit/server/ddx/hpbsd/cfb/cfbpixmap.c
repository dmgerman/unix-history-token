begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: cfbpixmap.c,v 5.7 91/07/18 23:36:46 keith Exp $ */
end_comment

begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* pixmap management    written by drewry, september 1986     on a monchrome device, a pixmap is a bitmap. */
end_comment

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"servermd.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"cfbmskbits.h"
end_include

begin_include
include|#
directive|include
file|"cfb.h"
end_include

begin_include
include|#
directive|include
file|"mi.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_decl_stmt
specifier|extern
name|void
name|mfbXRotatePixmap
argument_list|()
decl_stmt|,
name|mfbYRotatePixmap
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|BITMAP_BIT_ORDER
operator|==
name|MSBFirst
operator|)
end_if

begin_decl_stmt
specifier|static
name|int
name|masktab
index|[
literal|32
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x80000000
block|,
literal|0xC0000000
block|,
literal|0xE0000000
block|,
literal|0xF0000000
block|,
literal|0xF8000000
block|,
literal|0xFC000000
block|,
literal|0xFE000000
block|,
literal|0xFF000000
block|,
literal|0xFF800000
block|,
literal|0xFFC00000
block|,
literal|0xFFE00000
block|,
literal|0xFFF00000
block|,
literal|0xFFF80000
block|,
literal|0xFFFC0000
block|,
literal|0xFFFE0000
block|,
literal|0xFFFF0000
block|,
literal|0xFFFF8000
block|,
literal|0xFFFFC000
block|,
literal|0xFFFFE000
block|,
literal|0xFFFFF000
block|,
literal|0xFFFFF800
block|,
literal|0xFFFFFC00
block|,
literal|0xFFFFFE00
block|,
literal|0xFFFFFF00
block|,
literal|0xFFFFFF80
block|,
literal|0xFFFFFFC0
block|,
literal|0xFFFFFFE0
block|,
literal|0xFFFFFFF0
block|,
literal|0xFFFFFFF8
block|,
literal|0xFFFFFFFC
block|,
literal|0xFFFFFFFE
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|masktab
index|[
literal|32
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x00000001
block|,
literal|0x00000003
block|,
literal|0x00000007
block|,
literal|0x0000000F
block|,
literal|0x0000001F
block|,
literal|0x0000003F
block|,
literal|0x0000007F
block|,
literal|0x000000FF
block|,
literal|0x000001FF
block|,
literal|0x000003FF
block|,
literal|0x000007FF
block|,
literal|0x00000FFF
block|,
literal|0x00001FFF
block|,
literal|0x00003FFF
block|,
literal|0x00007FFF
block|,
literal|0x0000FFFF
block|,
literal|0x0001FFFF
block|,
literal|0x0003FFFF
block|,
literal|0x0007FFFF
block|,
literal|0x000FFFFF
block|,
literal|0x001FFFFF
block|,
literal|0x003FFFFF
block|,
literal|0x007FFFFF
block|,
literal|0x00FFFFFF
block|,
literal|0x01FFFFFF
block|,
literal|0x03FFFFFF
block|,
literal|0x07FFFFFF
block|,
literal|0x0FFFFFFF
block|,
literal|0x1FFFFFFF
block|,
literal|0x3FFFFFFF
block|,
literal|0x7FFFFFFF
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|PixmapPtr
name|cfbCreatePixmap
parameter_list|(
name|pScreen
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|,
name|bitsPerPixel
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|bitsPerPixel
decl_stmt|;
block|{
specifier|register
name|PixmapPtr
name|pPixmap
decl_stmt|;
specifier|register
name|hpPrivPixmapPtr
name|pPrivPixmap
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|bitsPerPixel
operator|!=
literal|1
operator|&&
name|bitsPerPixel
operator|!=
name|PSZ
condition|)
return|return
name|NullPixmap
return|;
name|pPixmap
operator|=
operator|(
name|PixmapPtr
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PixmapRec
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hpPrivPixmap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pPixmap
condition|)
return|return
name|NullPixmap
return|;
name|pPixmap
operator|->
name|devPrivate
operator|.
name|ptr
operator|=
call|(
name|pointer
call|)
argument_list|(
name|pPixmap
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|type
operator|=
name|DRAWABLE_PIXMAP
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|class
operator|=
literal|0
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|pScreen
operator|=
name|pScreen
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|depth
operator|=
name|bitsPerPixel
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|bitsPerPixel
operator|=
name|bitsPerPixel
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|serialNumber
operator|=
name|NEXT_SERIAL_NUMBER
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|pPixmap
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|pPrivPixmap
operator|=
operator|(
name|hpPrivPixmapPtr
operator|)
name|pPixmap
operator|->
name|devPrivate
operator|.
name|ptr
expr_stmt|;
name|pPrivPixmap
operator|->
name|stride
operator|=
name|PixmapBytePad
argument_list|(
name|width
argument_list|,
name|bitsPerPixel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bitsPerPixel
operator|==
name|PSZ
operator|)
operator|&&
operator|(
name|pPrivPixmap
operator|->
name|pChunk
operator|=
name|hpBufAlloc
argument_list|(
name|pScreen
argument_list|,
name|pPrivPixmap
operator|->
name|stride
argument_list|,
name|height
argument_list|)
operator|)
condition|)
block|{
name|pPrivPixmap
operator|->
name|stride
operator|=
operator|(
call|(
name|hpPrivScreenPtr
call|)
argument_list|(
name|pScreen
operator|->
name|devPrivate
argument_list|)
operator|)
operator|->
name|stride
expr_stmt|;
name|pPixmap
operator|->
name|devKind
operator|=
name|PIXMAP_FRAME_BUFFER
expr_stmt|;
name|pPrivPixmap
operator|->
name|bits
operator|=
call|(
name|pointer
call|)
argument_list|(
operator|(
call|(
name|hpPrivScreenPtr
call|)
argument_list|(
name|pScreen
operator|->
name|devPrivate
argument_list|)
operator|)
operator|->
name|bits
argument_list|)
operator|+
operator|(
name|pPrivPixmap
operator|->
name|pChunk
operator|->
name|y
operator|*
name|pPrivPixmap
operator|->
name|stride
operator|)
operator|+
name|pPrivPixmap
operator|->
name|pChunk
operator|->
name|x
expr_stmt|;
block|}
else|else
comment|/* depth == 1 or no off-screen memory */
block|{
name|pPixmap
operator|->
name|devKind
operator|=
name|PIXMAP_HOST_MEMORY
expr_stmt|;
name|size
operator|=
name|height
operator|*
name|pPrivPixmap
operator|->
name|stride
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pPrivPixmap
operator|->
name|bits
operator|=
operator|(
name|pointer
operator|)
name|xalloc
argument_list|(
name|size
argument_list|)
operator|)
condition|)
block|{
name|xfree
argument_list|(
name|pPixmap
argument_list|)
expr_stmt|;
return|return
name|NullPixmap
return|;
block|}
else|else
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pPrivPixmap
operator|->
name|bits
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|pPixmap
return|;
block|}
end_function

begin_function
name|PixmapPtr
name|cfbCreateOffscreenPixmap
parameter_list|(
name|pScreen
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|,
name|bitsPerPixel
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|bitsPerPixel
decl_stmt|;
block|{
specifier|register
name|PixmapPtr
name|pPixmap
decl_stmt|;
specifier|register
name|hpPrivPixmapPtr
name|pPrivPixmap
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|bitsPerPixel
operator|!=
name|PSZ
condition|)
return|return
name|NullPixmap
return|;
name|pPixmap
operator|=
operator|(
name|PixmapPtr
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PixmapRec
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hpPrivPixmap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pPixmap
condition|)
return|return
name|NullPixmap
return|;
name|pPixmap
operator|->
name|devPrivate
operator|.
name|ptr
operator|=
call|(
name|pointer
call|)
argument_list|(
name|pPixmap
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|type
operator|=
name|DRAWABLE_PIXMAP
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|class
operator|=
literal|0
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|pScreen
operator|=
name|pScreen
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|depth
operator|=
name|bitsPerPixel
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|bitsPerPixel
operator|=
name|bitsPerPixel
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|serialNumber
operator|=
name|NEXT_SERIAL_NUMBER
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|pPixmap
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|pPrivPixmap
operator|=
operator|(
name|hpPrivPixmapPtr
operator|)
name|pPixmap
operator|->
name|devPrivate
operator|.
name|ptr
expr_stmt|;
name|pPrivPixmap
operator|->
name|stride
operator|=
name|PixmapBytePad
argument_list|(
name|width
argument_list|,
name|bitsPerPixel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pPrivPixmap
operator|->
name|pChunk
operator|=
name|hpBufAlloc
argument_list|(
name|pScreen
argument_list|,
name|pPrivPixmap
operator|->
name|stride
argument_list|,
name|height
argument_list|)
operator|)
condition|)
block|{
name|pPrivPixmap
operator|->
name|stride
operator|=
operator|(
call|(
name|hpPrivScreenPtr
call|)
argument_list|(
name|pScreen
operator|->
name|devPrivate
argument_list|)
operator|)
operator|->
name|stride
expr_stmt|;
name|pPixmap
operator|->
name|devKind
operator|=
name|PIXMAP_FRAME_BUFFER
expr_stmt|;
name|pPrivPixmap
operator|->
name|bits
operator|=
call|(
name|pointer
call|)
argument_list|(
operator|(
call|(
name|hpPrivScreenPtr
call|)
argument_list|(
name|pScreen
operator|->
name|devPrivate
argument_list|)
operator|)
operator|->
name|bits
argument_list|)
operator|+
operator|(
name|pPrivPixmap
operator|->
name|pChunk
operator|->
name|y
operator|*
name|pPrivPixmap
operator|->
name|stride
operator|)
operator|+
name|pPrivPixmap
operator|->
name|pChunk
operator|->
name|x
expr_stmt|;
block|}
else|else
comment|/* Cannot create offscreen pixmap */
block|{
name|xfree
argument_list|(
name|pPixmap
argument_list|)
expr_stmt|;
return|return
name|NullPixmap
return|;
block|}
return|return
name|pPixmap
return|;
block|}
end_function

begin_function
name|Bool
name|cfbDestroyPixmap
parameter_list|(
name|pPixmap
parameter_list|)
name|PixmapPtr
name|pPixmap
decl_stmt|;
block|{
comment|/* BOGOSITY ALERT */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|pPixmap
operator|<
literal|42
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|--
name|pPixmap
operator|->
name|refcnt
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|pPixmap
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
name|hpBufFree
argument_list|(
name|pPixmap
operator|->
name|drawable
operator|.
name|pScreen
argument_list|,
operator|(
operator|(
name|hpPrivPixmapPtr
operator|)
name|pPixmap
operator|->
name|devPrivate
operator|.
name|ptr
operator|)
operator|->
name|pChunk
argument_list|)
expr_stmt|;
else|else
name|xfree
argument_list|(
operator|(
operator|(
name|hpPrivPixmapPtr
operator|)
name|pPixmap
operator|->
name|devPrivate
operator|.
name|ptr
operator|)
operator|->
name|bits
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|pPixmap
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|PixmapPtr
name|cfbCopyPixmap
parameter_list|(
name|pSrc
parameter_list|)
specifier|register
name|PixmapPtr
name|pSrc
decl_stmt|;
block|{
specifier|register
name|PixmapPtr
name|pDst
decl_stmt|;
specifier|register
name|int
modifier|*
name|pSrcInt
decl_stmt|,
modifier|*
name|pDstInt
decl_stmt|,
modifier|*
name|pSrcI
decl_stmt|,
modifier|*
name|pDstI
decl_stmt|,
modifier|*
name|pDstMax
decl_stmt|;
specifier|register
name|hpPrivPixmapPtr
name|pPrivDst
decl_stmt|,
name|pPrivSrc
decl_stmt|;
name|int
name|copyWords
decl_stmt|,
name|i
decl_stmt|;
name|void
function_decl|(
modifier|*
name|bitMover
function_decl|)
parameter_list|()
function_decl|;
name|pDst
operator|=
name|cfbCreatePixmap
argument_list|(
name|pSrc
operator|->
name|drawable
operator|.
name|pScreen
argument_list|,
name|pSrc
operator|->
name|drawable
operator|.
name|width
argument_list|,
name|pSrc
operator|->
name|drawable
operator|.
name|height
argument_list|,
name|pSrc
operator|->
name|drawable
operator|.
name|bitsPerPixel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pDst
condition|)
return|return
name|NullPixmap
return|;
name|pPrivSrc
operator|=
operator|(
name|hpPrivPixmapPtr
operator|)
name|pSrc
operator|->
name|devPrivate
operator|.
name|ptr
expr_stmt|;
name|pPrivDst
operator|=
operator|(
name|hpPrivPixmapPtr
operator|)
name|pDst
operator|->
name|devPrivate
operator|.
name|ptr
expr_stmt|;
name|pSrcInt
operator|=
operator|(
name|int
operator|*
operator|)
name|pPrivSrc
operator|->
name|bits
expr_stmt|;
name|pDstInt
operator|=
operator|(
name|int
operator|*
operator|)
name|pPrivDst
operator|->
name|bits
expr_stmt|;
if|if
condition|(
name|pSrc
operator|->
name|drawable
operator|.
name|depth
operator|==
literal|1
condition|)
block|{
comment|/* bit per pixel */
name|pDstMax
operator|=
name|pDstInt
operator|+
operator|(
operator|(
name|pDst
operator|->
name|drawable
operator|.
name|height
operator|*
name|pPrivDst
operator|->
name|stride
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
comment|/* Copy words */
while|while
condition|(
name|pDstInt
operator|<
name|pDstMax
condition|)
operator|*
name|pDstInt
operator|++
operator|=
operator|*
name|pSrcInt
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* byte per pixel */
if|if
condition|(
operator|(
name|pSrc
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
operator|)
operator|&&
operator|(
name|pDst
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
operator|)
condition|)
block|{
name|bitMover
operator|=
operator|(
call|(
name|hpPrivScreenPtr
call|)
argument_list|(
name|pSrc
operator|->
name|drawable
operator|.
name|pScreen
operator|->
name|devPrivate
argument_list|)
operator|)
operator|->
name|MoveBits
expr_stmt|;
call|(
modifier|*
name|bitMover
call|)
argument_list|(
name|pSrc
operator|->
name|drawable
operator|.
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|,
name|pPrivSrc
operator|->
name|pChunk
operator|->
name|x
argument_list|,
name|pPrivSrc
operator|->
name|pChunk
operator|->
name|y
argument_list|,
name|pPrivDst
operator|->
name|pChunk
operator|->
name|x
argument_list|,
name|pPrivDst
operator|->
name|pChunk
operator|->
name|y
argument_list|,
name|pSrc
operator|->
name|drawable
operator|.
name|width
argument_list|,
name|pSrc
operator|->
name|drawable
operator|.
name|height
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pSrc
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
name|WAIT_READY_TO_RENDER
argument_list|(
name|pSrc
operator|->
name|drawable
operator|.
name|pScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDst
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDst
operator|->
name|drawable
operator|.
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|copyWords
operator|=
operator|(
name|pDst
operator|->
name|drawable
operator|.
name|width
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* width will be in bytes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pDst
operator|->
name|drawable
operator|.
name|height
condition|;
name|pSrcInt
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pSrcInt
operator|+
name|pPrivSrc
operator|->
name|stride
operator|)
operator|,
name|pDstInt
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pDstInt
operator|+
name|pPrivDst
operator|->
name|stride
operator|)
operator|,
name|i
operator|++
control|)
block|{
name|pDstMax
operator|=
name|pDstInt
operator|+
name|copyWords
expr_stmt|;
name|pSrcI
operator|=
name|pSrcInt
expr_stmt|;
name|pDstI
operator|=
name|pDstInt
expr_stmt|;
while|while
condition|(
name|pDstI
operator|<
name|pDstMax
condition|)
operator|*
name|pDstI
operator|++
operator|=
operator|*
name|pSrcI
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|pDst
return|;
block|}
end_function

begin_comment
comment|/* replicates a pattern to be a full 32 bits wide.    relies on the fact that each scnaline is longword padded.    doesn't do anything if pixmap is not a factor of 32 wide.    changes width field of pixmap if successful, so that the fast 	cfbXRotatePixmap code gets used if we rotate the pixmap later. 	cfbYRotatePixmap code gets used if we rotate the pixmap later.     calculate number of times to repeat    for each scanline of pattern       zero out area to be filled with replicate       left shift and or in original as many times as needed */
end_comment

begin_function
name|void
name|cfbPadPixmap
parameter_list|(
name|pPixmap
parameter_list|)
name|PixmapPtr
name|pPixmap
decl_stmt|;
block|{
specifier|register
name|int
name|width
init|=
operator|(
name|pPixmap
operator|->
name|drawable
operator|.
name|width
operator|)
operator|*
operator|(
name|pPixmap
operator|->
name|drawable
operator|.
name|bitsPerPixel
operator|)
decl_stmt|;
specifier|register
name|int
name|h
decl_stmt|;
specifier|register
name|int
name|mask
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|p
decl_stmt|;
specifier|register
name|unsigned
name|int
name|bits
decl_stmt|;
comment|/* real pattern bits */
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|rep
decl_stmt|;
comment|/* repeat count for pattern */
name|int
name|stride
decl_stmt|;
if|if
condition|(
name|width
operator|>=
literal|32
condition|)
return|return;
if|if
condition|(
name|pPixmap
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
name|stride
operator|=
operator|(
operator|(
name|hpPrivPixmapPtr
operator|)
name|pPixmap
operator|->
name|devPrivate
operator|.
name|ptr
operator|)
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
else|else
name|stride
operator|=
literal|1
expr_stmt|;
name|rep
operator|=
literal|32
operator|/
name|width
expr_stmt|;
if|if
condition|(
name|rep
operator|*
name|width
operator|!=
literal|32
condition|)
return|return;
name|mask
operator|=
name|masktab
index|[
name|width
index|]
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
operator|(
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
name|pPixmap
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
operator|)
operator|->
name|bits
operator|)
expr_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
name|pPixmap
operator|->
name|drawable
operator|.
name|height
condition|;
name|h
operator|++
control|)
block|{
operator|*
name|p
operator|&=
name|mask
expr_stmt|;
name|bits
operator|=
operator|*
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rep
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
operator|(
name|BITMAP_BIT_ORDER
operator|==
name|MSBFirst
operator|)
name|bits
operator|>>=
name|width
expr_stmt|;
else|#
directive|else
name|bits
operator|<<=
name|width
expr_stmt|;
endif|#
directive|endif
operator|*
name|p
operator||=
name|bits
expr_stmt|;
block|}
name|p
operator|+=
name|stride
expr_stmt|;
block|}
name|pPixmap
operator|->
name|drawable
operator|.
name|width
operator|=
literal|32
operator|/
operator|(
name|pPixmap
operator|->
name|drawable
operator|.
name|bitsPerPixel
operator|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * cfb debugging routine -- assumes pixmap is 1 byte deep   */
end_comment

begin_expr_stmt
specifier|static
name|cfbdumppixmap
argument_list|(
argument|pPix
argument_list|)
name|PixmapPtr
name|pPix
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|int
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|psrc
decl_stmt|,
modifier|*
name|pdst
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|line
index|[
literal|66
index|]
decl_stmt|;
name|ErrorF
argument_list|(
literal|"pPixmap: 0x%x\n"
argument_list|,
name|pPix
argument_list|)
expr_stmt|;
name|ErrorF
argument_list|(
literal|"%d wide %d high\n"
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|width
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|pPix
operator|->
name|drawable
operator|.
name|width
operator|>
literal|64
condition|)
block|{
name|ErrorF
argument_list|(
literal|"too wide to see\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pw
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
operator|(
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
name|pPix
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
operator|)
operator|->
name|bits
expr|;
name|psrc
operator|=
operator|(
name|char
operator|*
operator|)
name|pw
expr|;
comment|/*     for ( i=0; i<pPix->drawable.height; ++i ) 	ErrorF( "0x%x\n", pw[i] ); */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pPix
operator|->
name|drawable
operator|.
name|height
condition|;
operator|++
name|i
control|)
block|{
name|pdst
operator|=
name|line
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pPix
operator|->
name|drawable
operator|.
name|width
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|pdst
operator|++
operator|=
operator|*
name|psrc
operator|++
condition|?
literal|'X'
else|:
literal|' '
expr_stmt|;
block|}
operator|*
name|pdst
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|pdst
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ErrorF
argument_list|(
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notdef */
end_comment

begin_comment
comment|/* Rotates pixmap pPix by w pixels to the right on the screen. Assumes that  * words are 32 bits wide, and that the least significant bit appears on the  * left.  */
end_comment

begin_function
name|void
name|cfbXRotatePixmap
parameter_list|(
name|pPix
parameter_list|,
name|rw
parameter_list|)
name|PixmapPtr
name|pPix
decl_stmt|;
specifier|register
name|int
name|rw
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
modifier|*
name|pw
decl_stmt|,
modifier|*
name|pwFinal
decl_stmt|;
specifier|register
name|unsigned
name|int
name|t
decl_stmt|;
name|int
name|rot
decl_stmt|;
name|hpPrivPixmapPtr
name|pPrivPix
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pPix
operator|==
name|NullPixmap
condition|)
return|return;
switch|switch
condition|(
operator|(
operator|(
name|DrawablePtr
operator|)
name|pPix
operator|)
operator|->
name|bitsPerPixel
condition|)
block|{
case|case
name|PSZ
case|:
break|break;
case|case
literal|1
case|:
name|mfbXRotatePixmap
argument_list|(
name|pPix
argument_list|,
name|rw
argument_list|)
expr_stmt|;
return|return;
default|default:
name|ErrorF
argument_list|(
literal|"cfbXRotatePixmap: unsupported bitsPerPixel %d\n"
argument_list|,
operator|(
operator|(
name|DrawablePtr
operator|)
name|pPix
operator|)
operator|->
name|bitsPerPixel
argument_list|)
expr_stmt|;
return|return;
block|}
name|pPrivPix
operator|=
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
name|pPix
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|pw
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|pPrivPix
operator|->
name|bits
expr_stmt|;
name|modulus
argument_list|(
name|rw
argument_list|,
operator|(
name|int
operator|)
name|pPix
operator|->
name|drawable
operator|.
name|width
argument_list|,
name|rot
argument_list|)
expr_stmt|;
if|if
condition|(
name|rot
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|pPix
operator|->
name|drawable
operator|.
name|width
operator|==
name|PPW
condition|)
block|{
if|if
condition|(
name|pPix
operator|->
name|devKind
operator|==
name|PIXMAP_HOST_MEMORY
condition|)
block|{
name|pwFinal
operator|=
name|pw
operator|+
name|pPix
operator|->
name|drawable
operator|.
name|height
expr_stmt|;
while|while
condition|(
name|pw
operator|<
name|pwFinal
condition|)
block|{
name|t
operator|=
operator|*
name|pw
expr_stmt|;
operator|*
name|pw
operator|++
operator|=
name|SCRRIGHT
argument_list|(
name|t
argument_list|,
name|rot
argument_list|)
operator||
operator|(
name|SCRLEFT
argument_list|(
name|t
argument_list|,
operator|(
name|PPW
operator|-
name|rot
operator|)
argument_list|)
operator|&
name|cfbendtab
index|[
name|rot
index|]
operator|)
expr_stmt|;
block|}
block|}
else|else
comment|/* PIXMAP_FRAME_BUFFER */
block|{
name|int
name|stride
init|=
name|pPrivPix
operator|->
name|stride
operator|>>
literal|2
decl_stmt|;
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pPix
operator|->
name|drawable
operator|.
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pPix
operator|->
name|drawable
operator|.
name|height
condition|;
name|i
operator|++
operator|,
name|pw
operator|+=
name|stride
control|)
block|{
name|t
operator|=
operator|*
name|pw
expr_stmt|;
operator|*
name|pw
operator|=
name|SCRRIGHT
argument_list|(
name|t
argument_list|,
name|rot
argument_list|)
operator||
operator|(
name|SCRLEFT
argument_list|(
name|t
argument_list|,
operator|(
name|PPW
operator|-
name|rot
operator|)
argument_list|)
operator|&
name|cfbendtab
index|[
name|rot
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* slow case */
block|{
name|ErrorF
argument_list|(
literal|"cfb internal error: trying to rotate odd-sized pixmap.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
specifier|register
name|unsigned
name|int
modifier|*
name|pwTmp
decl_stmt|;
name|int
name|size
decl_stmt|,
name|tsize
decl_stmt|;
name|tsize
operator|=
name|PixmapBytePad
argument_list|(
name|pPix
operator|->
name|drawable
operator|.
name|width
operator|-
name|rot
argument_list|,
name|PSZ
argument_list|)
expr_stmt|;
name|pwTmp
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|pPix
operator|->
name|drawable
operator|.
name|height
operator|*
name|tsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pwTmp
condition|)
return|return;
comment|/* divide pw (the pixmap) in two vertically at (w - rot) and swap */
name|tsize
operator|>>=
literal|2
expr_stmt|;
name|size
operator|=
name|pPix
operator|->
name|devKind
operator|>>
literal|2
expr_stmt|;
name|cfbQuickBlt
argument_list|(
operator|(
name|int
operator|*
operator|)
name|pw
argument_list|,
operator|(
name|int
operator|*
operator|)
name|pwTmp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|pPix
operator|->
name|drawable
operator|.
name|width
operator|-
name|rot
argument_list|,
operator|(
name|int
operator|)
name|pPix
operator|->
name|drawable
operator|.
name|height
argument_list|,
name|size
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
name|cfbQuickBlt
argument_list|(
operator|(
name|int
operator|*
operator|)
name|pw
argument_list|,
operator|(
name|int
operator|*
operator|)
name|pw
argument_list|,
operator|(
name|int
operator|)
name|pPix
operator|->
name|drawable
operator|.
name|width
operator|-
name|rot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|rot
argument_list|,
operator|(
name|int
operator|)
name|pPix
operator|->
name|drawable
operator|.
name|height
argument_list|,
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cfbQuickBlt
argument_list|(
operator|(
name|int
operator|*
operator|)
name|pwTmp
argument_list|,
operator|(
name|int
operator|*
operator|)
name|pw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|rot
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|pPix
operator|->
name|drawable
operator|.
name|width
operator|-
name|rot
argument_list|,
operator|(
name|int
operator|)
name|pPix
operator|->
name|drawable
operator|.
name|height
argument_list|,
name|tsize
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pwTmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Rotates pixmap pPix by h lines.  Assumes that h is always less than    pPix->drawable.height    works on any width.  */
end_comment

begin_function
name|void
name|cfbYRotatePixmap
parameter_list|(
name|pPix
parameter_list|,
name|rh
parameter_list|)
specifier|register
name|PixmapPtr
name|pPix
decl_stmt|;
name|int
name|rh
decl_stmt|;
block|{
name|int
name|nbyDown
decl_stmt|;
comment|/* bytes to move down to row 0; also offset of 			   row rh */
name|int
name|nbyUp
decl_stmt|;
comment|/* bytes to move up to line rh; also 			   offset of first line moved down to 0 */
name|char
modifier|*
name|pbase
decl_stmt|;
name|char
modifier|*
name|ptmp
decl_stmt|;
name|int
name|rot
decl_stmt|;
name|hpPrivPixmapPtr
name|pPrivPix
decl_stmt|;
if|if
condition|(
name|pPix
operator|==
name|NullPixmap
condition|)
return|return;
switch|switch
condition|(
operator|(
operator|(
name|DrawablePtr
operator|)
name|pPix
operator|)
operator|->
name|bitsPerPixel
condition|)
block|{
case|case
name|PSZ
case|:
break|break;
case|case
literal|1
case|:
name|mfbYRotatePixmap
argument_list|(
name|pPix
argument_list|,
name|rh
argument_list|)
expr_stmt|;
return|return;
default|default:
name|ErrorF
argument_list|(
literal|"cfbYRotatePixmap: unsupported bitsPerPixel %d\n"
argument_list|,
operator|(
operator|(
name|DrawablePtr
operator|)
name|pPix
operator|)
operator|->
name|bitsPerPixel
argument_list|)
expr_stmt|;
return|return;
block|}
name|pPrivPix
operator|=
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
name|pPix
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|modulus
argument_list|(
name|rh
argument_list|,
operator|(
name|int
operator|)
name|pPix
operator|->
name|drawable
operator|.
name|height
argument_list|,
name|rot
argument_list|)
expr_stmt|;
if|if
condition|(
name|rot
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|pPix
operator|->
name|devKind
operator|==
name|PIXMAP_HOST_MEMORY
condition|)
block|{
name|pbase
operator|=
operator|(
name|char
operator|*
operator|)
name|pPrivPix
operator|->
name|bits
expr_stmt|;
name|nbyDown
operator|=
name|rot
operator|*
name|pPrivPix
operator|->
name|stride
expr_stmt|;
name|nbyUp
operator|=
operator|(
name|pPrivPix
operator|->
name|stride
operator|*
name|pPix
operator|->
name|drawable
operator|.
name|height
operator|)
operator|-
name|nbyDown
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ptmp
operator|=
operator|(
name|char
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|nbyUp
argument_list|)
operator|)
condition|)
return|return;
name|bcopy
argument_list|(
name|pbase
argument_list|,
name|ptmp
argument_list|,
name|nbyUp
argument_list|)
expr_stmt|;
comment|/* save the low rows */
name|bcopy
argument_list|(
name|pbase
operator|+
name|nbyUp
argument_list|,
name|pbase
argument_list|,
name|nbyDown
argument_list|)
expr_stmt|;
comment|/* slide the top rows down */
name|bcopy
argument_list|(
name|ptmp
argument_list|,
name|pbase
operator|+
name|nbyDown
argument_list|,
name|nbyUp
argument_list|)
expr_stmt|;
comment|/* move lower rows up to row rot */
name|DEALLOCATE_LOCAL
argument_list|(
name|ptmp
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* PIXMAP_FRAME_BUFFER */
block|{
comment|/* o.k., divide the pixmap in two horizontally at (h - rh) 	 * pick up the part on the top and make it the temp 	 * pixmap.  then pick up the part on the bottom and make it the top 	 * of the original pixmap. now copy in the part saved in temp and 	 * discard temp. All done. 	 */
name|PixmapPtr
name|pTemp
decl_stmt|;
name|short
name|realTemp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|pPix
operator|->
name|drawable
operator|.
name|width
operator|>
name|PRIV_PIX_WIDTH
operator|)
operator|||
operator|(
operator|(
name|pPix
operator|->
name|drawable
operator|.
name|height
operator|-
name|rot
operator|)
operator|>
name|PRIV_PIX_HEIGHT
operator|)
condition|)
block|{
name|pTemp
operator|=
call|(
modifier|*
name|pPix
operator|->
name|drawable
operator|.
name|pScreen
operator|->
name|CreatePixmap
call|)
argument_list|(
name|pPix
operator|->
name|drawable
operator|.
name|pScreen
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|width
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|height
operator|-
name|rot
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|depth
argument_list|)
expr_stmt|;
name|realTemp
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* use pre-allocated pixmap */
name|pTemp
operator|=
call|(
name|PixmapPtr
call|)
argument_list|(
operator|(
name|hpPrivScreen
operator|*
operator|)
operator|(
name|pPix
operator|->
name|drawable
operator|.
name|pScreen
operator|->
name|devPrivate
operator|)
argument_list|)
operator|->
name|pTmpPixmap
expr_stmt|;
block|}
if|if
condition|(
name|pTemp
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
block|{
specifier|register
name|hpChunk
modifier|*
name|pixChunk
decl_stmt|;
specifier|register
name|hpChunk
modifier|*
name|tempChunk
decl_stmt|;
specifier|register
name|void
function_decl|(
modifier|*
name|bitMover
function_decl|)
parameter_list|()
function_decl|;
name|tempChunk
operator|=
operator|(
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
name|pTemp
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
operator|)
operator|->
name|pChunk
expr_stmt|;
name|pixChunk
operator|=
name|pPrivPix
operator|->
name|pChunk
expr_stmt|;
name|bitMover
operator|=
operator|(
call|(
name|hpPrivScreenPtr
call|)
argument_list|(
name|pPix
operator|->
name|drawable
operator|.
name|pScreen
operator|->
name|devPrivate
argument_list|)
operator|)
operator|->
name|MoveBits
expr_stmt|;
call|(
modifier|*
name|bitMover
call|)
argument_list|(
name|pPix
operator|->
name|drawable
operator|.
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|,
name|pixChunk
operator|->
name|x
argument_list|,
name|pixChunk
operator|->
name|y
argument_list|,
name|tempChunk
operator|->
name|x
argument_list|,
name|tempChunk
operator|->
name|y
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|width
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|height
operator|-
name|rot
argument_list|)
expr_stmt|;
call|(
modifier|*
name|bitMover
call|)
argument_list|(
name|pPix
operator|->
name|drawable
operator|.
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|,
name|pixChunk
operator|->
name|x
argument_list|,
operator|(
name|pixChunk
operator|->
name|y
operator|+
name|pPix
operator|->
name|drawable
operator|.
name|height
operator|-
name|rot
operator|)
argument_list|,
name|pixChunk
operator|->
name|x
argument_list|,
name|pixChunk
operator|->
name|y
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|width
argument_list|,
name|rot
argument_list|)
expr_stmt|;
call|(
modifier|*
name|bitMover
call|)
argument_list|(
name|pPix
operator|->
name|drawable
operator|.
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|,
name|tempChunk
operator|->
name|x
argument_list|,
name|tempChunk
operator|->
name|y
argument_list|,
name|pixChunk
operator|->
name|x
argument_list|,
operator|(
name|pixChunk
operator|->
name|y
operator|+
name|rot
operator|)
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|width
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|height
operator|-
name|rot
argument_list|)
expr_stmt|;
if|if
condition|(
name|realTemp
condition|)
call|(
modifier|*
name|pPix
operator|->
name|drawable
operator|.
name|pScreen
operator|->
name|DestroyPixmap
call|)
argument_list|(
name|pTemp
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* forced to use generic code */
block|{
name|GCPtr
name|pGC
decl_stmt|;
name|CARD32
name|attribute
decl_stmt|;
name|pGC
operator|=
name|GetScratchGC
argument_list|(
name|pPix
operator|->
name|drawable
operator|.
name|depth
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|pScreen
argument_list|)
expr_stmt|;
name|attribute
operator|=
name|GXcopy
expr_stmt|;
name|ChangeGC
argument_list|(
name|pGC
argument_list|,
name|GCFunction
argument_list|,
operator|&
name|attribute
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ValidateGC
argument_list|(
name|pTemp
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|CopyArea
call|)
argument_list|(
name|pPix
argument_list|,
name|pTemp
argument_list|,
name|pGC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|width
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|height
operator|-
name|rot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ValidateGC
argument_list|(
name|pPix
argument_list|,
name|pGC
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|CopyArea
call|)
argument_list|(
name|pPix
argument_list|,
name|pPix
argument_list|,
name|pGC
argument_list|,
literal|0
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|height
operator|-
name|rot
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|width
argument_list|,
name|rot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|CopyArea
call|)
argument_list|(
name|pTemp
argument_list|,
name|pPix
argument_list|,
name|pGC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|width
argument_list|,
name|pPix
operator|->
name|drawable
operator|.
name|height
operator|-
name|rot
argument_list|,
literal|0
argument_list|,
name|rot
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pPix
operator|->
name|drawable
operator|.
name|pScreen
operator|->
name|DestroyPixmap
call|)
argument_list|(
name|pTemp
argument_list|)
expr_stmt|;
name|FreeScratchGC
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|cfbCopyRotatePixmap
parameter_list|(
name|psrcPix
parameter_list|,
name|ppdstPix
parameter_list|,
name|xrot
parameter_list|,
name|yrot
parameter_list|)
specifier|register
name|PixmapPtr
name|psrcPix
decl_stmt|,
decl|*
name|ppdstPix
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|xrot
decl_stmt|,
name|yrot
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PixmapPtr
name|pdstPix
init|=
operator|*
name|ppdstPix
decl_stmt|;
if|#
directive|if
literal|0
block|if (pdstPix&& 	(pdstPix->devKind == psrcPix->devKind)&& 	(pdstPix->drawable.height == psrcPix->drawable.height))     { 	bcopy((char *)psrcPix->devPrivate.ptr, 	      (char *)pdstPix->devPrivate.ptr, 	      psrcPix->drawable.height * psrcPix->devKind); 	pdstPix->drawable.width = psrcPix->drawable.width; 	pdstPix->drawable.depth = psrcPix->drawable.depth; 	pdstPix->drawable.bitsPerPixel = psrcPix->drawable.bitsPerPixel; 	pdstPix->drawable.serialNumber = NEXT_SERIAL_NUMBER;     }     else
endif|#
directive|endif
block|{
if|if
condition|(
name|pdstPix
condition|)
name|cfbDestroyPixmap
argument_list|(
name|pdstPix
argument_list|)
expr_stmt|;
operator|*
name|ppdstPix
operator|=
name|pdstPix
operator|=
name|cfbCopyPixmap
argument_list|(
name|psrcPix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pdstPix
condition|)
return|return;
block|}
name|cfbPadPixmap
argument_list|(
name|pdstPix
argument_list|)
expr_stmt|;
if|if
condition|(
name|xrot
condition|)
name|cfbXRotatePixmap
argument_list|(
name|pdstPix
argument_list|,
name|xrot
argument_list|)
expr_stmt|;
if|if
condition|(
name|yrot
condition|)
name|cfbYRotatePixmap
argument_list|(
name|pdstPix
argument_list|,
name|yrot
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

