begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* $XConsortium: mfbline.c,v 5.12 91/08/13 18:49:01 keith Exp $ */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"mistruct.h"
end_include

begin_include
include|#
directive|include
file|"mfb.h"
end_include

begin_include
include|#
directive|include
file|"maskbits.h"
end_include

begin_comment
comment|/* single-pixel lines on a color frame buffer     NON-SLOPED LINES    horizontal lines are always drawn left to right; we have to move the endpoints right by one after they're swapped.    horizontal lines will be confined to a single band of a region.  the code finds that band (giving up if the lower bound of the band is above the line we're drawing); then it finds the first box in that band that contains part of the line.  we clip the line to subsequent boxes in that band.    vertical lines are always drawn top to bottom (y-increasing.) this requires adding one to the y-coordinate of each endpoint after swapping.     SLOPED LINES    when clipping a sloped line, we bring the second point inside the clipping box, rather than one beyond it, and then add 1 to the length of the line before drawing it.  this lets us use the same box for finding the outcodes for both endpoints.  since the equation for clipping the second endpoint to an edge gives us 1 beyond the edge, we then have to move the point towards the first point by one step on the major axis.    eventually, there will be a diagram here to explain what's going on.  the method uses Cohen-Sutherland outcodes to determine outsideness, and a method similar to Pike's layers for doing the actual clipping.  */
end_comment

begin_define
define|#
directive|define
name|OUTCODES
parameter_list|(
name|result
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|pbox
parameter_list|)
define|\
value|if (x< pbox->x1) \ 	result |= OUT_LEFT; \     else if (x>= pbox->x2) \ 	result |= OUT_RIGHT; \     if (y< pbox->y1) \ 	result |= OUT_ABOVE; \     else if (y>= pbox->y2) \ 	result |= OUT_BELOW;
end_define

begin_define
define|#
directive|define
name|round
parameter_list|(
name|dividend
parameter_list|,
name|divisor
parameter_list|)
define|\
value|( (((dividend)<<1) + (divisor)) / ((divisor)<<1) )
end_define

begin_define
define|#
directive|define
name|ceiling
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
value|(((m)-1)/(n) + 1)
end_define

begin_comment
comment|/* #define SignTimes(sign, n) ((sign) * ((int)(n))) */
end_comment

begin_define
define|#
directive|define
name|SignTimes
parameter_list|(
name|sign
parameter_list|,
name|n
parameter_list|)
define|\
value|( ((sign)<0) ? -(n) : (n) )
end_define

begin_define
define|#
directive|define
name|SWAPINT
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
define|\
value|{  register int _t = i; \    i = j; \    j = _t; \ }
end_define

begin_define
define|#
directive|define
name|SWAPPT
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
define|\
value|{  DDXPointRec _t; \    _t = i; \    i = j; \    j = _t; \ }
end_define

begin_function
name|void
ifdef|#
directive|ifdef
name|POLYSEGMENT
name|mfbSegmentSS
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nseg
parameter_list|,
name|pSeg
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nseg
decl_stmt|;
specifier|register
name|xSegment
modifier|*
name|pSeg
decl_stmt|;
else|#
directive|else
function|mfbLineSS
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|mode
parameter_list|,
name|npt
parameter_list|,
name|pptInit
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* Origin or Previous */
name|int
name|npt
decl_stmt|;
comment|/* number of points */
name|DDXPointPtr
name|pptInit
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|nboxInit
decl_stmt|;
specifier|register
name|int
name|nbox
decl_stmt|;
name|BoxPtr
name|pboxInit
decl_stmt|;
specifier|register
name|BoxPtr
name|pbox
decl_stmt|;
ifndef|#
directive|ifndef
name|POLYSEGMENT
specifier|register
name|DDXPointPtr
name|ppt
decl_stmt|;
comment|/* pointer to list of translated points */
endif|#
directive|endif
name|unsigned
name|int
name|oc1
decl_stmt|;
comment|/* outcode of point 1 */
name|unsigned
name|int
name|oc2
decl_stmt|;
comment|/* outcode of point 2 */
name|int
modifier|*
name|addrl
decl_stmt|;
comment|/* address of destination pixmap */
name|int
name|nlwidth
decl_stmt|;
comment|/* width in longwords of destination pixmap */
name|int
name|xorg
decl_stmt|,
name|yorg
decl_stmt|;
comment|/* origin of window */
name|int
name|adx
decl_stmt|;
comment|/* abs values of dx and dy */
name|int
name|ady
decl_stmt|;
name|int
name|signdx
decl_stmt|;
comment|/* sign of dx and dy */
name|int
name|signdy
decl_stmt|;
name|int
name|e
decl_stmt|,
name|e1
decl_stmt|,
name|e2
decl_stmt|;
comment|/* bresenham error and increments */
name|int
name|len
decl_stmt|;
comment|/* length of segment */
name|int
name|axis
decl_stmt|;
comment|/* major axis */
comment|/* a bunch of temporaries */
specifier|register
name|int
name|y1
decl_stmt|,
name|y2
decl_stmt|;
specifier|register
name|int
name|x1
decl_stmt|,
name|x2
decl_stmt|;
name|RegionPtr
name|cclip
decl_stmt|;
name|int
name|alu
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pGC
operator|->
name|planemask
operator|&
literal|1
operator|)
condition|)
return|return;
name|cclip
operator|=
operator|(
operator|(
name|mfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|mfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
expr_stmt|;
name|alu
operator|=
operator|(
operator|(
name|mfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|mfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|rop
expr_stmt|;
name|pboxInit
operator|=
name|REGION_RECTS
argument_list|(
name|cclip
argument_list|)
expr_stmt|;
name|nboxInit
operator|=
name|REGION_NUM_RECTS
argument_list|(
name|cclip
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
block|{
name|addrl
operator|=
operator|(
name|int
operator|*
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
operator|->
name|bits
expr_stmt|;
name|nlwidth
operator|=
operator|(
name|int
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
block|}
else|else
block|{
name|addrl
operator|=
operator|(
name|int
operator|*
operator|)
name|getPrivPixmapPtr
argument_list|(
name|pDrawable
argument_list|)
operator|->
name|bits
expr_stmt|;
name|nlwidth
operator|=
operator|(
name|int
operator|)
name|getPrivPixmapPtr
argument_list|(
name|pDrawable
argument_list|)
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
block|}
name|xorg
operator|=
name|pDrawable
operator|->
name|x
expr_stmt|;
name|yorg
operator|=
name|pDrawable
operator|->
name|y
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
while|while
condition|(
name|nseg
operator|--
condition|)
else|#
directive|else
name|ppt
operator|=
name|pptInit
expr_stmt|;
name|x2
operator|=
name|ppt
operator|->
name|x
operator|+
name|xorg
expr_stmt|;
name|y2
operator|=
name|ppt
operator|->
name|y
operator|+
name|yorg
expr_stmt|;
while|while
condition|(
operator|--
name|npt
condition|)
endif|#
directive|endif
block|{
name|nbox
operator|=
name|nboxInit
expr_stmt|;
name|pbox
operator|=
name|pboxInit
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
name|x1
operator|=
name|pSeg
operator|->
name|x1
operator|+
name|xorg
expr_stmt|;
name|y1
operator|=
name|pSeg
operator|->
name|y1
operator|+
name|yorg
expr_stmt|;
name|x2
operator|=
name|pSeg
operator|->
name|x2
operator|+
name|xorg
expr_stmt|;
name|y2
operator|=
name|pSeg
operator|->
name|y2
operator|+
name|yorg
expr_stmt|;
name|pSeg
operator|++
expr_stmt|;
else|#
directive|else
name|x1
operator|=
name|x2
expr_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
operator|++
name|ppt
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CoordModePrevious
condition|)
block|{
name|xorg
operator|=
name|x1
expr_stmt|;
name|yorg
operator|=
name|y1
expr_stmt|;
block|}
name|x2
operator|=
name|ppt
operator|->
name|x
operator|+
name|xorg
expr_stmt|;
name|y2
operator|=
name|ppt
operator|->
name|y
operator|+
name|yorg
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|x1
operator|==
name|x2
condition|)
block|{
comment|/* make the line go top to bottom of screen, keeping 	       endpoint semantics 	    */
if|if
condition|(
name|y1
operator|>
name|y2
condition|)
block|{
specifier|register
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|y2
expr_stmt|;
name|y2
operator|=
name|y1
operator|+
literal|1
expr_stmt|;
name|y1
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|y1
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|POLYSEGMENT
elseif|else
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|y2
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* get to first band that might contain part of line */
while|while
condition|(
operator|(
name|nbox
operator|)
operator|&&
operator|(
name|pbox
operator|->
name|y2
operator|<=
name|y1
operator|)
condition|)
block|{
name|pbox
operator|++
expr_stmt|;
name|nbox
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nbox
condition|)
block|{
comment|/* stop when lower edge of box is beyond end of line */
while|while
condition|(
operator|(
name|nbox
operator|)
operator|&&
operator|(
name|y2
operator|>=
name|pbox
operator|->
name|y1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|x1
operator|>=
name|pbox
operator|->
name|x1
operator|)
operator|&&
operator|(
name|x1
operator|<
name|pbox
operator|->
name|x2
operator|)
condition|)
block|{
name|int
name|y1t
decl_stmt|,
name|y2t
decl_stmt|;
comment|/* this box has part of the line in it */
name|y1t
operator|=
name|max
argument_list|(
name|y1
argument_list|,
name|pbox
operator|->
name|y1
argument_list|)
expr_stmt|;
name|y2t
operator|=
name|min
argument_list|(
name|y2
argument_list|,
name|pbox
operator|->
name|y2
argument_list|)
expr_stmt|;
if|if
condition|(
name|y1t
operator|!=
name|y2t
condition|)
block|{
name|mfbVertS
argument_list|(
name|alu
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|x1
argument_list|,
name|y1t
argument_list|,
name|y2t
operator|-
name|y1t
argument_list|)
expr_stmt|;
block|}
block|}
name|nbox
operator|--
expr_stmt|;
name|pbox
operator|++
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|POLYSEGMENT
name|y2
operator|=
name|ppt
operator|->
name|y
operator|+
name|yorg
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
block|{
comment|/* force line from left to right, keeping 	       endpoint semantics 	    */
if|if
condition|(
name|x1
operator|>
name|x2
condition|)
block|{
specifier|register
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|x1
operator|+
literal|1
expr_stmt|;
name|x1
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|x1
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|POLYSEGMENT
elseif|else
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|x2
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* find the correct band */
while|while
condition|(
operator|(
name|nbox
operator|)
operator|&&
operator|(
name|pbox
operator|->
name|y2
operator|<=
name|y1
operator|)
condition|)
block|{
name|pbox
operator|++
expr_stmt|;
name|nbox
operator|--
expr_stmt|;
block|}
comment|/* try to draw the line, if we haven't gone beyond it */
if|if
condition|(
operator|(
name|nbox
operator|)
operator|&&
operator|(
name|pbox
operator|->
name|y1
operator|<=
name|y1
operator|)
condition|)
block|{
name|int
name|tmp
decl_stmt|;
comment|/* when we leave this band, we're done */
name|tmp
operator|=
name|pbox
operator|->
name|y1
expr_stmt|;
while|while
condition|(
operator|(
name|nbox
operator|)
operator|&&
operator|(
name|pbox
operator|->
name|y1
operator|==
name|tmp
operator|)
condition|)
block|{
name|int
name|x1t
decl_stmt|,
name|x2t
decl_stmt|;
if|if
condition|(
name|pbox
operator|->
name|x2
operator|<=
name|x1
condition|)
block|{
comment|/* skip boxes until one might contain start point */
name|nbox
operator|--
expr_stmt|;
name|pbox
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* stop if left of box is beyond right of line */
if|if
condition|(
name|pbox
operator|->
name|x1
operator|>=
name|x2
condition|)
block|{
name|nbox
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|x1t
operator|=
name|max
argument_list|(
name|x1
argument_list|,
name|pbox
operator|->
name|x1
argument_list|)
expr_stmt|;
name|x2t
operator|=
name|min
argument_list|(
name|x2
argument_list|,
name|pbox
operator|->
name|x2
argument_list|)
expr_stmt|;
if|if
condition|(
name|x1t
operator|!=
name|x2t
condition|)
block|{
name|mfbHorzS
argument_list|(
name|alu
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|x1t
argument_list|,
name|y1
argument_list|,
name|x2t
operator|-
name|x1t
argument_list|)
expr_stmt|;
block|}
name|nbox
operator|--
expr_stmt|;
name|pbox
operator|++
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|POLYSEGMENT
name|x2
operator|=
name|ppt
operator|->
name|x
operator|+
name|xorg
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* sloped line */
block|{
name|adx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|ady
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|signdx
operator|=
name|sign
argument_list|(
name|adx
argument_list|)
expr_stmt|;
name|signdy
operator|=
name|sign
argument_list|(
name|ady
argument_list|)
expr_stmt|;
name|adx
operator|=
name|abs
argument_list|(
name|adx
argument_list|)
expr_stmt|;
name|ady
operator|=
name|abs
argument_list|(
name|ady
argument_list|)
expr_stmt|;
if|if
condition|(
name|adx
operator|>
name|ady
condition|)
block|{
name|axis
operator|=
name|X_AXIS
expr_stmt|;
name|e1
operator|=
name|ady
operator|<<
literal|1
expr_stmt|;
name|e2
operator|=
name|e1
operator|-
operator|(
name|adx
operator|<<
literal|1
operator|)
expr_stmt|;
name|e
operator|=
name|e1
operator|-
name|adx
expr_stmt|;
block|}
else|else
block|{
name|axis
operator|=
name|Y_AXIS
expr_stmt|;
name|e1
operator|=
name|adx
operator|<<
literal|1
expr_stmt|;
name|e2
operator|=
name|e1
operator|-
operator|(
name|ady
operator|<<
literal|1
operator|)
expr_stmt|;
name|e
operator|=
name|e1
operator|-
name|ady
expr_stmt|;
block|}
comment|/* we have bresenham parameters and two points. 	       all we have to do now is clip and draw. 	    */
while|while
condition|(
name|nbox
operator|--
condition|)
block|{
name|oc1
operator|=
literal|0
expr_stmt|;
name|oc2
operator|=
literal|0
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc1
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|pbox
argument_list|)
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc2
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|pbox
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oc1
operator||
name|oc2
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
name|len
operator|=
name|adx
expr_stmt|;
else|else
name|len
operator|=
name|ady
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|len
operator|++
expr_stmt|;
endif|#
directive|endif
name|mfbBresS
argument_list|(
name|alu
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|e
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|oc1
operator|&
name|oc2
condition|)
block|{
name|pbox
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     	     * let the mfb helper routine do our work; 	     	     * better than duplicating code... 	     	     */
name|BoxRec
name|box
decl_stmt|;
name|DDXPointRec
name|pt1Copy
decl_stmt|;
comment|/* clipped start point */
name|DDXPointRec
name|pt2Copy
decl_stmt|;
comment|/* clipped end point */
name|int
name|err
decl_stmt|;
comment|/* modified bresenham error term */
name|int
name|clip1
decl_stmt|,
name|clip2
decl_stmt|;
comment|/* clippedness of the endpoints */
name|int
name|clipdx
decl_stmt|,
name|clipdy
decl_stmt|;
comment|/* difference between clipped and 				       	       	   unclipped start point */
name|DDXPointRec
name|pt1
decl_stmt|;
name|pt1
operator|.
name|x
operator|=
name|pt1Copy
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|pt1
operator|.
name|y
operator|=
name|pt1Copy
operator|.
name|y
operator|=
name|y1
expr_stmt|;
name|pt2Copy
operator|.
name|x
operator|=
name|x2
expr_stmt|;
name|pt2Copy
operator|.
name|y
operator|=
name|y2
expr_stmt|;
name|box
operator|.
name|x1
operator|=
name|pbox
operator|->
name|x1
expr_stmt|;
name|box
operator|.
name|y1
operator|=
name|pbox
operator|->
name|y1
expr_stmt|;
name|box
operator|.
name|x2
operator|=
name|pbox
operator|->
name|x2
operator|-
literal|1
expr_stmt|;
name|box
operator|.
name|y2
operator|=
name|pbox
operator|->
name|y2
operator|-
literal|1
expr_stmt|;
name|clip1
operator|=
literal|0
expr_stmt|;
name|clip2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mfbClipLine
argument_list|(
name|pbox
argument_list|,
name|box
argument_list|,
operator|&
name|pt1
argument_list|,
operator|&
name|pt1Copy
argument_list|,
operator|&
name|pt2Copy
argument_list|,
name|adx
argument_list|,
name|ady
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
operator|&
name|clip1
argument_list|,
operator|&
name|clip2
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
name|len
operator|=
name|abs
argument_list|(
name|pt2Copy
operator|.
name|x
operator|-
name|pt1Copy
operator|.
name|x
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|abs
argument_list|(
name|pt2Copy
operator|.
name|y
operator|-
name|pt1Copy
operator|.
name|y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
name|clip2
operator|!=
literal|0
operator|||
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|len
operator|++
expr_stmt|;
else|#
directive|else
name|len
operator|+=
operator|(
name|clip2
operator|!=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
condition|)
block|{
comment|/* unwind bresenham error term to first point */
if|if
condition|(
name|clip1
condition|)
block|{
name|clipdx
operator|=
name|abs
argument_list|(
name|pt1Copy
operator|.
name|x
operator|-
name|x1
argument_list|)
expr_stmt|;
name|clipdy
operator|=
name|abs
argument_list|(
name|pt1Copy
operator|.
name|y
operator|-
name|y1
argument_list|)
expr_stmt|;
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
name|err
operator|=
name|e
operator|+
operator|(
operator|(
name|clipdy
operator|*
name|e2
operator|)
operator|+
operator|(
operator|(
name|clipdx
operator|-
name|clipdy
operator|)
operator|*
name|e1
operator|)
operator|)
expr_stmt|;
else|else
name|err
operator|=
name|e
operator|+
operator|(
operator|(
name|clipdx
operator|*
name|e2
operator|)
operator|+
operator|(
operator|(
name|clipdy
operator|-
name|clipdx
operator|)
operator|*
name|e1
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|err
operator|=
name|e
expr_stmt|;
name|mfbBresS
argument_list|(
name|alu
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
name|pt1Copy
operator|.
name|x
argument_list|,
name|pt1Copy
operator|.
name|y
argument_list|,
name|err
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|pbox
operator|++
expr_stmt|;
block|}
block|}
comment|/* while (nbox--) */
block|}
comment|/* sloped line */
block|}
comment|/* while (nline--) */
ifndef|#
directive|ifndef
name|POLYSEGMENT
comment|/* paint the last point if the end style isn't CapNotLast.        (Assume that a projecting, butt, or round cap that is one         pixel wide is the same as the single pixel of the endpoint.)     */
if|if
condition|(
operator|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
operator|)
operator|&&
operator|(
operator|(
name|ppt
operator|->
name|x
operator|+
name|xorg
operator|!=
name|pptInit
operator|->
name|x
operator|+
name|pDrawable
operator|->
name|x
operator|)
operator|||
operator|(
name|ppt
operator|->
name|y
operator|+
name|yorg
operator|!=
name|pptInit
operator|->
name|y
operator|+
name|pDrawable
operator|->
name|y
operator|)
operator|||
operator|(
name|ppt
operator|==
name|pptInit
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|unsigned
name|int
name|_mask
decl_stmt|;
name|int
name|_incr
decl_stmt|;
if|if
condition|(
name|alu
operator|==
name|RROP_BLACK
condition|)
name|_mask
operator|=
name|rmask
index|[
name|x2
operator|&
literal|0x1f
index|]
expr_stmt|;
else|else
name|_mask
operator|=
name|mask
index|[
name|x2
operator|&
literal|0x1f
index|]
expr_stmt|;
name|_incr
operator|=
operator|(
name|y2
operator|*
name|nlwidth
operator|)
operator|+
operator|(
name|x2
operator|>>
literal|5
operator|)
expr_stmt|;
name|nbox
operator|=
name|nboxInit
expr_stmt|;
name|pbox
operator|=
name|pboxInit
expr_stmt|;
while|while
condition|(
name|nbox
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|x2
operator|>=
name|pbox
operator|->
name|x1
operator|)
operator|&&
operator|(
name|y2
operator|>=
name|pbox
operator|->
name|y1
operator|)
operator|&&
operator|(
name|x2
operator|<
name|pbox
operator|->
name|x2
operator|)
operator|&&
operator|(
name|y2
operator|<
name|pbox
operator|->
name|y2
operator|)
condition|)
block|{
name|addrl
operator|+=
name|_incr
expr_stmt|;
switch|switch
condition|(
name|alu
condition|)
block|{
case|case
name|RROP_BLACK
case|:
operator|*
name|addrl
operator|&=
name|_mask
expr_stmt|;
break|break;
case|case
name|RROP_WHITE
case|:
operator|*
name|addrl
operator||=
name|_mask
expr_stmt|;
break|break;
case|case
name|RROP_INVERT
case|:
operator|*
name|addrl
operator|^=
name|_mask
expr_stmt|;
break|break;
block|}
break|break;
block|}
else|else
name|pbox
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Draw dashed 1-pixel lines.  */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|POLYSEGMENT
name|mfbSegmentSD
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nseg
parameter_list|,
name|pSeg
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
specifier|register
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nseg
decl_stmt|;
specifier|register
name|xSegment
modifier|*
name|pSeg
decl_stmt|;
else|#
directive|else
function|mfbLineSD
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|mode
parameter_list|,
name|npt
parameter_list|,
name|pptInit
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
specifier|register
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* Origin or Previous */
name|int
name|npt
decl_stmt|;
comment|/* number of points */
name|DDXPointPtr
name|pptInit
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|nboxInit
decl_stmt|;
specifier|register
name|int
name|nbox
decl_stmt|;
name|BoxPtr
name|pboxInit
decl_stmt|;
specifier|register
name|BoxPtr
name|pbox
decl_stmt|;
ifndef|#
directive|ifndef
name|POLYSEGMENT
specifier|register
name|DDXPointPtr
name|ppt
decl_stmt|;
comment|/* pointer to list of translated points */
endif|#
directive|endif
specifier|register
name|unsigned
name|int
name|oc1
decl_stmt|;
comment|/* outcode of point 1 */
specifier|register
name|unsigned
name|int
name|oc2
decl_stmt|;
comment|/* outcode of point 2 */
name|int
modifier|*
name|addrl
decl_stmt|;
comment|/* address of destination pixmap */
name|int
name|nlwidth
decl_stmt|;
comment|/* width in longwords of destination pixmap */
name|int
name|xorg
decl_stmt|,
name|yorg
decl_stmt|;
comment|/* origin of window */
name|int
name|adx
decl_stmt|;
comment|/* abs values of dx and dy */
name|int
name|ady
decl_stmt|;
name|int
name|signdx
decl_stmt|;
comment|/* sign of dx and dy */
name|int
name|signdy
decl_stmt|;
name|int
name|e
decl_stmt|,
name|e1
decl_stmt|,
name|e2
decl_stmt|;
comment|/* bresenham error and increments */
name|int
name|len
decl_stmt|;
comment|/* length of segment */
name|int
name|axis
decl_stmt|;
comment|/* major axis */
name|int
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|;
name|RegionPtr
name|cclip
decl_stmt|;
name|int
name|fgrop
decl_stmt|,
name|bgrop
decl_stmt|;
name|unsigned
name|char
modifier|*
name|pDash
decl_stmt|;
name|int
name|dashOffset
decl_stmt|;
name|int
name|numInDashList
decl_stmt|;
name|int
name|dashIndex
decl_stmt|;
name|int
name|isDoubleDash
decl_stmt|;
name|int
name|dashIndexTmp
decl_stmt|,
name|dashOffsetTmp
decl_stmt|;
name|int
name|unclippedlen
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pGC
operator|->
name|planemask
operator|&
literal|1
operator|)
condition|)
return|return;
name|cclip
operator|=
operator|(
operator|(
name|mfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|mfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
expr_stmt|;
name|fgrop
operator|=
operator|(
operator|(
name|mfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|mfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|rop
expr_stmt|;
name|pboxInit
operator|=
name|REGION_RECTS
argument_list|(
name|cclip
argument_list|)
expr_stmt|;
name|nboxInit
operator|=
name|REGION_NUM_RECTS
argument_list|(
name|cclip
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
block|{
name|addrl
operator|=
operator|(
name|int
operator|*
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
operator|->
name|bits
expr_stmt|;
name|nlwidth
operator|=
operator|(
name|int
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
block|}
else|else
block|{
name|addrl
operator|=
operator|(
name|int
operator|*
operator|)
name|getPrivPixmapPtr
argument_list|(
name|pDrawable
argument_list|)
operator|->
name|bits
expr_stmt|;
name|nlwidth
operator|=
operator|(
name|int
operator|)
name|getPrivPixmapPtr
argument_list|(
name|pDrawable
argument_list|)
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
block|}
comment|/* compute initial dash values */
name|pDash
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pGC
operator|->
name|dash
expr_stmt|;
name|numInDashList
operator|=
name|pGC
operator|->
name|numInDashList
expr_stmt|;
name|isDoubleDash
operator|=
operator|(
name|pGC
operator|->
name|lineStyle
operator|==
name|LineDoubleDash
operator|)
expr_stmt|;
name|dashIndex
operator|=
literal|0
expr_stmt|;
name|dashOffset
operator|=
literal|0
expr_stmt|;
name|miStepDash
argument_list|(
operator|(
name|int
operator|)
name|pGC
operator|->
name|dashOffset
argument_list|,
operator|&
name|dashIndex
argument_list|,
name|pDash
argument_list|,
name|numInDashList
argument_list|,
operator|&
name|dashOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDoubleDash
condition|)
name|bgrop
operator|=
name|mfbReduceRop
argument_list|(
name|pGC
operator|->
name|alu
argument_list|,
name|pGC
operator|->
name|bgPixel
argument_list|)
expr_stmt|;
name|xorg
operator|=
name|pDrawable
operator|->
name|x
expr_stmt|;
name|yorg
operator|=
name|pDrawable
operator|->
name|y
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
while|while
condition|(
name|nseg
operator|--
condition|)
else|#
directive|else
name|ppt
operator|=
name|pptInit
expr_stmt|;
name|x2
operator|=
name|ppt
operator|->
name|x
operator|+
name|xorg
expr_stmt|;
name|y2
operator|=
name|ppt
operator|->
name|y
operator|+
name|yorg
expr_stmt|;
while|while
condition|(
operator|--
name|npt
condition|)
endif|#
directive|endif
block|{
name|nbox
operator|=
name|nboxInit
expr_stmt|;
name|pbox
operator|=
name|pboxInit
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
name|x1
operator|=
name|pSeg
operator|->
name|x1
operator|+
name|xorg
expr_stmt|;
name|y1
operator|=
name|pSeg
operator|->
name|y1
operator|+
name|yorg
expr_stmt|;
name|x2
operator|=
name|pSeg
operator|->
name|x2
operator|+
name|xorg
expr_stmt|;
name|y2
operator|=
name|pSeg
operator|->
name|y2
operator|+
name|yorg
expr_stmt|;
name|pSeg
operator|++
expr_stmt|;
else|#
directive|else
name|x1
operator|=
name|x2
expr_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
operator|++
name|ppt
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CoordModePrevious
condition|)
block|{
name|xorg
operator|=
name|x1
expr_stmt|;
name|yorg
operator|=
name|y1
expr_stmt|;
block|}
name|x2
operator|=
name|ppt
operator|->
name|x
operator|+
name|xorg
expr_stmt|;
name|y2
operator|=
name|ppt
operator|->
name|y
operator|+
name|yorg
expr_stmt|;
endif|#
directive|endif
name|adx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|ady
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|signdx
operator|=
name|sign
argument_list|(
name|adx
argument_list|)
expr_stmt|;
name|signdy
operator|=
name|sign
argument_list|(
name|ady
argument_list|)
expr_stmt|;
name|adx
operator|=
name|abs
argument_list|(
name|adx
argument_list|)
expr_stmt|;
name|ady
operator|=
name|abs
argument_list|(
name|ady
argument_list|)
expr_stmt|;
if|if
condition|(
name|adx
operator|>
name|ady
condition|)
block|{
name|axis
operator|=
name|X_AXIS
expr_stmt|;
name|e1
operator|=
name|ady
operator|<<
literal|1
expr_stmt|;
name|e2
operator|=
name|e1
operator|-
operator|(
name|adx
operator|<<
literal|1
operator|)
expr_stmt|;
name|e
operator|=
name|e1
operator|-
name|adx
expr_stmt|;
name|unclippedlen
operator|=
name|adx
expr_stmt|;
block|}
else|else
block|{
name|axis
operator|=
name|Y_AXIS
expr_stmt|;
name|e1
operator|=
name|adx
operator|<<
literal|1
expr_stmt|;
name|e2
operator|=
name|e1
operator|-
operator|(
name|ady
operator|<<
literal|1
operator|)
expr_stmt|;
name|e
operator|=
name|e1
operator|-
name|ady
expr_stmt|;
name|unclippedlen
operator|=
name|ady
expr_stmt|;
block|}
comment|/* we have bresenham parameters and two points. 	   all we have to do now is clip and draw. 	*/
while|while
condition|(
name|nbox
operator|--
condition|)
block|{
name|oc1
operator|=
literal|0
expr_stmt|;
name|oc2
operator|=
literal|0
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc1
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|pbox
argument_list|)
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc2
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|pbox
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oc1
operator||
name|oc2
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|unclippedlen
operator|++
expr_stmt|;
name|dashIndexTmp
operator|=
name|dashIndex
expr_stmt|;
name|dashOffsetTmp
operator|=
name|dashOffset
expr_stmt|;
name|mfbBresD
argument_list|(
name|fgrop
argument_list|,
name|bgrop
argument_list|,
operator|&
name|dashIndexTmp
argument_list|,
name|pDash
argument_list|,
name|numInDashList
argument_list|,
operator|&
name|dashOffsetTmp
argument_list|,
name|isDoubleDash
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|e
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|unclippedlen
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|mfbBresD
argument_list|(
name|fgrop
argument_list|,
name|bgrop
argument_list|,
operator|&
name|dashIndex
argument_list|,
name|pDash
argument_list|,
name|numInDashList
argument_list|,
operator|&
name|dashOffset
argument_list|,
name|isDoubleDash
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|e
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|unclippedlen
argument_list|)
expr_stmt|;
goto|goto
name|dontStep
goto|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|oc1
operator|&
name|oc2
condition|)
block|{
name|pbox
operator|++
expr_stmt|;
block|}
else|else
comment|/* have to clip */
block|{
comment|/* 		 * let the mfb helper routine do our work; 		 * better than duplicating code... 		 */
name|BoxRec
name|box
decl_stmt|;
name|DDXPointRec
name|pt1Copy
decl_stmt|;
comment|/* clipped start point */
name|DDXPointRec
name|pt2Copy
decl_stmt|;
comment|/* clipped end point */
name|int
name|err
decl_stmt|;
comment|/* modified bresenham error term */
name|int
name|clip1
decl_stmt|,
name|clip2
decl_stmt|;
comment|/* clippedness of the endpoints */
name|int
name|clipdx
decl_stmt|,
name|clipdy
decl_stmt|;
comment|/* difference between clipped and 					       unclipped start point */
name|DDXPointRec
name|pt1
decl_stmt|;
name|pt1
operator|.
name|x
operator|=
name|pt1Copy
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|pt1
operator|.
name|y
operator|=
name|pt1Copy
operator|.
name|y
operator|=
name|y1
expr_stmt|;
name|pt2Copy
operator|.
name|x
operator|=
name|x2
expr_stmt|;
name|pt2Copy
operator|.
name|y
operator|=
name|y2
expr_stmt|;
name|box
operator|.
name|x1
operator|=
name|pbox
operator|->
name|x1
expr_stmt|;
name|box
operator|.
name|y1
operator|=
name|pbox
operator|->
name|y1
expr_stmt|;
name|box
operator|.
name|x2
operator|=
name|pbox
operator|->
name|x2
operator|-
literal|1
expr_stmt|;
name|box
operator|.
name|y2
operator|=
name|pbox
operator|->
name|y2
operator|-
literal|1
expr_stmt|;
name|clip1
operator|=
literal|0
expr_stmt|;
name|clip2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mfbClipLine
argument_list|(
name|pbox
argument_list|,
name|box
argument_list|,
operator|&
name|pt1
argument_list|,
operator|&
name|pt1Copy
argument_list|,
operator|&
name|pt2Copy
argument_list|,
name|adx
argument_list|,
name|ady
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
operator|&
name|clip1
argument_list|,
operator|&
name|clip2
argument_list|)
operator|==
literal|1
condition|)
block|{
name|dashIndexTmp
operator|=
name|dashIndex
expr_stmt|;
name|dashOffsetTmp
operator|=
name|dashOffset
expr_stmt|;
if|if
condition|(
name|clip1
condition|)
block|{
name|int
name|dlen
decl_stmt|;
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
name|dlen
operator|=
name|abs
argument_list|(
name|pt1Copy
operator|.
name|x
operator|-
name|x1
argument_list|)
expr_stmt|;
else|else
name|dlen
operator|=
name|abs
argument_list|(
name|pt1Copy
operator|.
name|y
operator|-
name|y1
argument_list|)
expr_stmt|;
name|miStepDash
argument_list|(
name|dlen
argument_list|,
operator|&
name|dashIndexTmp
argument_list|,
name|pDash
argument_list|,
name|numInDashList
argument_list|,
operator|&
name|dashOffsetTmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
name|len
operator|=
name|abs
argument_list|(
name|pt2Copy
operator|.
name|x
operator|-
name|pt1Copy
operator|.
name|x
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|abs
argument_list|(
name|pt2Copy
operator|.
name|y
operator|-
name|pt1Copy
operator|.
name|y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POLYSEGMENT
if|if
condition|(
name|clip2
operator|!=
literal|0
operator|||
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
condition|)
name|len
operator|++
expr_stmt|;
else|#
directive|else
name|len
operator|+=
operator|(
name|clip2
operator|!=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
condition|)
block|{
comment|/* unwind bresenham error term to first point */
if|if
condition|(
name|clip1
condition|)
block|{
name|clipdx
operator|=
name|abs
argument_list|(
name|pt1Copy
operator|.
name|x
operator|-
name|x1
argument_list|)
expr_stmt|;
name|clipdy
operator|=
name|abs
argument_list|(
name|pt1Copy
operator|.
name|y
operator|-
name|y1
argument_list|)
expr_stmt|;
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
name|err
operator|=
name|e
operator|+
operator|(
operator|(
name|clipdy
operator|*
name|e2
operator|)
operator|+
operator|(
operator|(
name|clipdx
operator|-
name|clipdy
operator|)
operator|*
name|e1
operator|)
operator|)
expr_stmt|;
else|else
name|err
operator|=
name|e
operator|+
operator|(
operator|(
name|clipdx
operator|*
name|e2
operator|)
operator|+
operator|(
operator|(
name|clipdy
operator|-
name|clipdx
operator|)
operator|*
name|e1
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|err
operator|=
name|e
expr_stmt|;
name|mfbBresD
argument_list|(
name|fgrop
argument_list|,
name|bgrop
argument_list|,
operator|&
name|dashIndexTmp
argument_list|,
name|pDash
argument_list|,
name|numInDashList
argument_list|,
operator|&
name|dashOffsetTmp
argument_list|,
name|isDoubleDash
argument_list|,
name|addrl
argument_list|,
name|nlwidth
argument_list|,
name|signdx
argument_list|,
name|signdy
argument_list|,
name|axis
argument_list|,
name|pt1Copy
operator|.
name|x
argument_list|,
name|pt1Copy
operator|.
name|y
argument_list|,
name|err
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|pbox
operator|++
expr_stmt|;
block|}
block|}
comment|/* while (nbox--) */
ifndef|#
directive|ifndef
name|POLYSEGMENT
comment|/* 	 * walk the dash list around to the next line 	 */
name|miStepDash
argument_list|(
name|unclippedlen
argument_list|,
operator|&
name|dashIndex
argument_list|,
name|pDash
argument_list|,
name|numInDashList
argument_list|,
operator|&
name|dashOffset
argument_list|)
expr_stmt|;
name|dontStep
label|:
empty_stmt|;
endif|#
directive|endif
block|}
comment|/* while (nline--) */
ifndef|#
directive|ifndef
name|POLYSEGMENT
comment|/* paint the last point if the end style isn't CapNotLast.        (Assume that a projecting, butt, or round cap that is one         pixel wide is the same as the single pixel of the endpoint.)     */
if|if
condition|(
operator|(
name|pGC
operator|->
name|capStyle
operator|!=
name|CapNotLast
operator|)
operator|&&
operator|(
operator|(
name|dashIndex
operator|&
literal|1
operator|)
operator|==
literal|0
operator|||
name|isDoubleDash
operator|)
operator|&&
operator|(
operator|(
name|ppt
operator|->
name|x
operator|+
name|xorg
operator|!=
name|pptInit
operator|->
name|x
operator|+
name|pDrawable
operator|->
name|x
operator|)
operator|||
operator|(
name|ppt
operator|->
name|y
operator|+
name|yorg
operator|!=
name|pptInit
operator|->
name|y
operator|+
name|pDrawable
operator|->
name|y
operator|)
operator|||
operator|(
name|ppt
operator|==
name|pptInit
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|nbox
operator|=
name|nboxInit
expr_stmt|;
name|pbox
operator|=
name|pboxInit
expr_stmt|;
while|while
condition|(
name|nbox
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|x2
operator|>=
name|pbox
operator|->
name|x1
operator|)
operator|&&
operator|(
name|y2
operator|>=
name|pbox
operator|->
name|y1
operator|)
operator|&&
operator|(
name|x2
operator|<
name|pbox
operator|->
name|x2
operator|)
operator|&&
operator|(
name|y2
operator|<
name|pbox
operator|->
name|y2
operator|)
condition|)
block|{
name|unsigned
name|long
name|_mask
decl_stmt|;
name|int
name|rop
decl_stmt|;
name|rop
operator|=
name|fgrop
expr_stmt|;
if|if
condition|(
name|dashIndex
operator|&
literal|1
condition|)
name|rop
operator|=
name|bgrop
expr_stmt|;
if|if
condition|(
name|rop
operator|==
name|RROP_BLACK
condition|)
name|_mask
operator|=
name|rmask
index|[
name|x2
operator|&
literal|0x1f
index|]
expr_stmt|;
else|else
name|_mask
operator|=
name|mask
index|[
name|x2
operator|&
literal|0x1f
index|]
expr_stmt|;
name|addrl
operator|+=
operator|(
name|y2
operator|*
name|nlwidth
operator|)
operator|+
operator|(
name|x2
operator|>>
literal|5
operator|)
expr_stmt|;
if|if
condition|(
name|rop
operator|==
name|RROP_BLACK
condition|)
operator|*
name|addrl
operator|&=
name|_mask
expr_stmt|;
elseif|else
if|if
condition|(
name|rop
operator|==
name|RROP_WHITE
condition|)
operator|*
name|addrl
operator||=
name|_mask
expr_stmt|;
else|else
operator|*
name|addrl
operator|^=
name|_mask
expr_stmt|;
break|break;
block|}
else|else
name|pbox
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|POLYSEGMENT
end_ifndef

begin_comment
comment|/*     the clipping code could be cleaned up some; most of its mess derives from originally being inline in the line code, then pulled out to make clipping dashes easier. */
end_comment

begin_function
name|int
name|mfbClipLine
parameter_list|(
name|pbox
parameter_list|,
name|box
parameter_list|,
name|ppt1Orig
parameter_list|,
name|ppt1
parameter_list|,
name|ppt2
parameter_list|,
name|adx
parameter_list|,
name|ady
parameter_list|,
name|signdx
parameter_list|,
name|signdy
parameter_list|,
name|axis
parameter_list|,
name|pclip1
parameter_list|,
name|pclip2
parameter_list|)
name|BoxPtr
name|pbox
decl_stmt|;
comment|/* box to clip to */
name|BoxRec
name|box
decl_stmt|;
comment|/* box to do calculations with */
name|DDXPointPtr
name|ppt1Orig
decl_stmt|,
name|ppt1
decl_stmt|,
name|ppt2
decl_stmt|;
name|int
name|adx
decl_stmt|,
name|ady
decl_stmt|;
name|int
name|signdx
decl_stmt|,
name|signdy
decl_stmt|;
specifier|register
name|int
name|axis
decl_stmt|;
name|int
modifier|*
name|pclip1
decl_stmt|,
decl|*
name|pclip2
decl_stmt|;
end_function

begin_block
block|{
name|DDXPointRec
name|pt1Orig
decl_stmt|,
name|pt1
decl_stmt|,
name|pt2
decl_stmt|;
specifier|register
name|int
name|swapped
init|=
literal|0
decl_stmt|;
name|int
name|clipDone
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|long
name|utmp
decl_stmt|;
specifier|register
name|int
name|oc1
decl_stmt|,
name|oc2
decl_stmt|;
name|int
name|clip1
decl_stmt|,
name|clip2
decl_stmt|;
name|pt1Orig
operator|=
operator|*
name|ppt1Orig
expr_stmt|;
name|pt1
operator|=
operator|*
name|ppt1
expr_stmt|;
name|pt2
operator|=
operator|*
name|ppt2
expr_stmt|;
name|clip1
operator|=
literal|0
expr_stmt|;
name|clip2
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|oc1
operator|=
literal|0
expr_stmt|;
name|oc2
operator|=
literal|0
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc1
argument_list|,
name|pt1
operator|.
name|x
argument_list|,
name|pt1
operator|.
name|y
argument_list|,
name|pbox
argument_list|)
expr_stmt|;
name|OUTCODES
argument_list|(
name|oc2
argument_list|,
name|pt2
operator|.
name|x
argument_list|,
name|pt2
operator|.
name|y
argument_list|,
name|pbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc1
operator|&
name|oc2
condition|)
name|clipDone
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|oc1
operator||
name|oc2
operator|)
operator|==
literal|0
condition|)
block|{
name|clipDone
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|swapped
condition|)
block|{
name|SWAPPT
argument_list|(
name|pt1
argument_list|,
name|pt2
argument_list|)
expr_stmt|;
name|SWAPINT
argument_list|(
name|oc1
argument_list|,
name|oc2
argument_list|)
expr_stmt|;
name|SWAPINT
argument_list|(
name|clip1
argument_list|,
name|clip2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* have to clip */
block|{
comment|/* only clip one point at a time */
if|if
condition|(
operator|!
name|oc1
condition|)
block|{
name|SWAPPT
argument_list|(
name|pt1
argument_list|,
name|pt2
argument_list|)
expr_stmt|;
name|SWAPINT
argument_list|(
name|oc1
argument_list|,
name|oc2
argument_list|)
expr_stmt|;
name|SWAPINT
argument_list|(
name|clip1
argument_list|,
name|clip2
argument_list|)
expr_stmt|;
name|swapped
operator|=
operator|!
name|swapped
expr_stmt|;
block|}
name|clip1
operator||=
name|oc1
expr_stmt|;
if|if
condition|(
name|oc1
operator|&
name|OUT_LEFT
condition|)
block|{
name|pt1
operator|.
name|x
operator|=
name|box
operator|.
name|x1
expr_stmt|;
name|utmp
operator|=
name|abs
argument_list|(
name|box
operator|.
name|x1
operator|-
name|pt1Orig
operator|.
name|x
argument_list|)
expr_stmt|;
name|utmp
operator|*=
name|ady
expr_stmt|;
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
block|{
name|pt1
operator|.
name|y
operator|=
name|pt1Orig
operator|.
name|y
operator|+
name|SignTimes
argument_list|(
name|signdy
argument_list|,
name|round
argument_list|(
name|utmp
argument_list|,
name|adx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utmp
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|swapped
condition|)
name|utmp
operator|+=
name|ady
expr_stmt|;
else|else
name|utmp
operator|-=
name|ady
expr_stmt|;
name|pt1
operator|.
name|y
operator|=
name|pt1Orig
operator|.
name|y
operator|+
name|SignTimes
argument_list|(
name|signdy
argument_list|,
name|ceiling
argument_list|(
name|utmp
argument_list|,
literal|2
operator|*
name|adx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|swapped
condition|)
name|pt1
operator|.
name|y
operator|-=
name|signdy
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|oc1
operator|&
name|OUT_ABOVE
condition|)
block|{
name|pt1
operator|.
name|y
operator|=
name|box
operator|.
name|y1
expr_stmt|;
name|utmp
operator|=
name|abs
argument_list|(
name|box
operator|.
name|y1
operator|-
name|pt1Orig
operator|.
name|y
argument_list|)
expr_stmt|;
name|utmp
operator|*=
name|adx
expr_stmt|;
if|if
condition|(
name|axis
operator|==
name|Y_AXIS
condition|)
block|{
name|pt1
operator|.
name|x
operator|=
name|pt1Orig
operator|.
name|x
operator|+
name|SignTimes
argument_list|(
name|signdx
argument_list|,
name|round
argument_list|(
name|utmp
argument_list|,
name|ady
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utmp
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|swapped
condition|)
name|utmp
operator|+=
name|adx
expr_stmt|;
else|else
name|utmp
operator|-=
name|adx
expr_stmt|;
name|pt1
operator|.
name|x
operator|=
name|pt1Orig
operator|.
name|x
operator|+
name|SignTimes
argument_list|(
name|signdx
argument_list|,
name|ceiling
argument_list|(
name|utmp
argument_list|,
literal|2
operator|*
name|ady
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|swapped
condition|)
name|pt1
operator|.
name|x
operator|-=
name|signdx
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|oc1
operator|&
name|OUT_RIGHT
condition|)
block|{
name|pt1
operator|.
name|x
operator|=
name|box
operator|.
name|x2
expr_stmt|;
name|utmp
operator|=
name|abs
argument_list|(
name|pt1Orig
operator|.
name|x
operator|-
name|box
operator|.
name|x2
argument_list|)
expr_stmt|;
name|utmp
operator|*=
name|ady
expr_stmt|;
if|if
condition|(
name|axis
operator|==
name|X_AXIS
condition|)
block|{
name|pt1
operator|.
name|y
operator|=
name|pt1Orig
operator|.
name|y
operator|+
name|SignTimes
argument_list|(
name|signdy
argument_list|,
name|round
argument_list|(
name|utmp
argument_list|,
name|adx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utmp
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|swapped
condition|)
name|utmp
operator|+=
name|ady
expr_stmt|;
else|else
name|utmp
operator|-=
name|ady
expr_stmt|;
name|pt1
operator|.
name|y
operator|=
name|pt1Orig
operator|.
name|y
operator|+
name|SignTimes
argument_list|(
name|signdy
argument_list|,
name|ceiling
argument_list|(
name|utmp
argument_list|,
literal|2
operator|*
name|adx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|swapped
condition|)
name|pt1
operator|.
name|y
operator|-=
name|signdy
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|oc1
operator|&
name|OUT_BELOW
condition|)
block|{
name|pt1
operator|.
name|y
operator|=
name|box
operator|.
name|y2
expr_stmt|;
name|utmp
operator|=
name|abs
argument_list|(
name|pt1Orig
operator|.
name|y
operator|-
name|box
operator|.
name|y2
argument_list|)
expr_stmt|;
name|utmp
operator|*=
name|adx
expr_stmt|;
if|if
condition|(
name|axis
operator|==
name|Y_AXIS
condition|)
block|{
name|pt1
operator|.
name|x
operator|=
name|pt1Orig
operator|.
name|x
operator|+
name|SignTimes
argument_list|(
name|signdx
argument_list|,
name|round
argument_list|(
name|utmp
argument_list|,
name|ady
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utmp
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|swapped
condition|)
name|utmp
operator|+=
name|adx
expr_stmt|;
else|else
name|utmp
operator|-=
name|adx
expr_stmt|;
name|pt1
operator|.
name|x
operator|=
name|pt1Orig
operator|.
name|x
operator|+
name|SignTimes
argument_list|(
name|signdx
argument_list|,
name|ceiling
argument_list|(
name|utmp
argument_list|,
literal|2
operator|*
name|ady
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|swapped
condition|)
name|pt1
operator|.
name|x
operator|-=
name|signdx
expr_stmt|;
block|}
block|}
block|}
comment|/* else have to clip */
block|}
do|while
condition|(
operator|!
name|clipDone
condition|)
do|;
operator|*
name|ppt1
operator|=
name|pt1
expr_stmt|;
operator|*
name|ppt2
operator|=
name|pt2
expr_stmt|;
operator|*
name|pclip1
operator|=
name|clip1
expr_stmt|;
operator|*
name|pclip2
operator|=
name|clip2
expr_stmt|;
return|return
name|clipDone
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

