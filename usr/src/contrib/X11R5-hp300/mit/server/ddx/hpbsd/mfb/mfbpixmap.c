begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* $XConsortium: mfbpixmap.c,v 5.5 89/07/28 11:59:59 rws Exp $ */
end_comment

begin_comment
comment|/* pixmap management    written by drewry, september 1986     on a monchrome device, a pixmap is a bitmap. */
end_comment

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"maskbits.h"
end_include

begin_include
include|#
directive|include
file|"mfb.h"
end_include

begin_include
include|#
directive|include
file|"mi.h"
end_include

begin_include
include|#
directive|include
file|"servermd.h"
end_include

begin_function
name|PixmapPtr
name|mfbCreatePixmap
parameter_list|(
name|pScreen
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|,
name|depth
parameter_list|)
name|ScreenPtr
name|pScreen
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
specifier|register
name|PixmapPtr
name|pPixmap
decl_stmt|;
specifier|register
name|hpPrivPixmapPtr
name|pPrivPixmap
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|depth
operator|!=
literal|1
condition|)
return|return
name|NullPixmap
return|;
name|size
operator|=
name|PixmapBytePad
argument_list|(
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pPixmap
operator|=
operator|(
name|PixmapPtr
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PixmapRec
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hpPrivPixmap
argument_list|)
operator|+
operator|(
name|height
operator|*
name|size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pPixmap
condition|)
return|return
name|NullPixmap
return|;
name|pPrivPixmap
operator|=
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
name|pPixmap
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|type
operator|=
name|DRAWABLE_PIXMAP
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|class
operator|=
literal|0
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|pScreen
operator|=
name|pScreen
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|depth
operator|=
literal|1
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|bitsPerPixel
operator|=
literal|1
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|serialNumber
operator|=
name|NEXT_SERIAL_NUMBER
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|pPixmap
operator|->
name|drawable
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|pPixmap
operator|->
name|devKind
operator|=
name|PIXMAP_HOST_MEMORY
expr_stmt|;
name|pPixmap
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|pPixmap
operator|->
name|devPrivate
operator|.
name|ptr
operator|=
operator|(
name|pointer
operator|)
name|pPrivPixmap
expr_stmt|;
name|pPrivPixmap
operator|->
name|stride
operator|=
name|size
expr_stmt|;
name|pPrivPixmap
operator|->
name|bits
operator|=
call|(
name|pointer
call|)
argument_list|(
name|pPrivPixmap
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|pPixmap
return|;
block|}
end_function

begin_function
name|Bool
name|mfbDestroyPixmap
parameter_list|(
name|pPixmap
parameter_list|)
name|PixmapPtr
name|pPixmap
decl_stmt|;
block|{
if|if
condition|(
operator|--
name|pPixmap
operator|->
name|refcnt
condition|)
return|return
name|TRUE
return|;
name|xfree
argument_list|(
name|pPixmap
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|PixmapPtr
name|mfbCopyPixmap
parameter_list|(
name|pSrc
parameter_list|)
specifier|register
name|PixmapPtr
name|pSrc
decl_stmt|;
block|{
specifier|register
name|PixmapPtr
name|pDst
decl_stmt|;
specifier|register
name|hpPrivPixmapPtr
name|pPrivDst
decl_stmt|,
name|pPrivSrc
decl_stmt|;
name|int
name|size
decl_stmt|;
name|pPrivSrc
operator|=
operator|(
name|hpPrivPixmapPtr
operator|)
name|pSrc
operator|->
name|devPrivate
operator|.
name|ptr
expr_stmt|;
name|size
operator|=
name|pSrc
operator|->
name|drawable
operator|.
name|height
operator|*
name|pPrivSrc
operator|->
name|stride
expr_stmt|;
name|pDst
operator|=
operator|(
name|PixmapPtr
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PixmapRec
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hpPrivPixmap
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pDst
condition|)
return|return
name|NullPixmap
return|;
name|pPrivDst
operator|=
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
name|pDst
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pDst
operator|->
name|drawable
operator|=
name|pSrc
operator|->
name|drawable
expr_stmt|;
name|pDst
operator|->
name|drawable
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|pDst
operator|->
name|drawable
operator|.
name|serialNumber
operator|=
name|NEXT_SERIAL_NUMBER
expr_stmt|;
name|pDst
operator|->
name|devKind
operator|=
name|PIXMAP_HOST_MEMORY
expr_stmt|;
name|pDst
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|pDst
operator|->
name|devPrivate
operator|.
name|ptr
operator|=
operator|(
name|pointer
operator|)
name|pPrivDst
expr_stmt|;
name|pPrivDst
operator|->
name|bits
operator|=
call|(
name|pointer
call|)
argument_list|(
name|pPrivDst
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pPrivDst
operator|->
name|stride
operator|=
name|pPrivSrc
operator|->
name|stride
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pPrivSrc
operator|->
name|bits
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pPrivDst
operator|->
name|bits
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|pDst
return|;
block|}
end_function

begin_comment
comment|/* replicates a pattern to be a full 32 bits wide.    relies on the fact that each scnaline is longword padded.    doesn't do anything if pixmap is not a factor of 32 wide.    changes width field of pixmap if successful, so that the fast 	XRotatePixmap code gets used if we rotate the pixmap later.     calculate number of times to repeat    for each scanline of pattern       zero out area to be filled with replicate       left shift and or in original as many times as needed */
end_comment

begin_function
name|void
name|mfbPadPixmap
parameter_list|(
name|pPixmap
parameter_list|)
name|PixmapPtr
name|pPixmap
decl_stmt|;
block|{
specifier|register
name|int
name|width
init|=
name|pPixmap
operator|->
name|drawable
operator|.
name|width
decl_stmt|;
specifier|register
name|int
name|h
decl_stmt|;
specifier|register
name|int
name|mask
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|p
decl_stmt|;
specifier|register
name|unsigned
name|int
name|bits
decl_stmt|;
comment|/* real pattern bits */
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|rep
decl_stmt|;
comment|/* repeat count for pattern */
if|if
condition|(
name|width
operator|>=
literal|32
condition|)
return|return;
name|rep
operator|=
literal|32
operator|/
name|width
expr_stmt|;
if|if
condition|(
name|rep
operator|*
name|width
operator|!=
literal|32
condition|)
return|return;
name|mask
operator|=
name|endtab
index|[
name|width
index|]
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
operator|(
operator|(
name|hpPrivPixmapPtr
operator|)
name|pPixmap
operator|->
name|devPrivate
operator|.
name|ptr
operator|)
operator|->
name|bits
operator|)
expr_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
name|pPixmap
operator|->
name|drawable
operator|.
name|height
condition|;
name|h
operator|++
control|)
block|{
operator|*
name|p
operator|&=
name|mask
expr_stmt|;
name|bits
operator|=
operator|*
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rep
condition|;
name|i
operator|++
control|)
block|{
name|bits
operator|=
name|SCRRIGHT
argument_list|(
name|bits
argument_list|,
name|width
argument_list|)
expr_stmt|;
operator|*
name|p
operator||=
name|bits
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
name|pPixmap
operator|->
name|drawable
operator|.
name|width
operator|=
literal|32
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rotates pixmap pPix by w pixels to the right on the screen. Assumes that  * words are 32 bits wide, and that the least significant bit appears on the  * left.  */
end_comment

begin_function
name|void
name|mfbXRotatePixmap
parameter_list|(
name|pPix
parameter_list|,
name|rw
parameter_list|)
name|PixmapPtr
name|pPix
decl_stmt|;
specifier|register
name|int
name|rw
decl_stmt|;
block|{
specifier|register
name|long
modifier|*
name|pw
decl_stmt|,
modifier|*
name|pwFinal
decl_stmt|;
specifier|register
name|unsigned
name|long
name|t
decl_stmt|;
if|if
condition|(
name|pPix
operator|==
name|NullPixmap
condition|)
return|return;
name|pw
operator|=
operator|(
name|long
operator|*
operator|)
operator|(
operator|(
name|hpPrivPixmapPtr
operator|)
name|pPix
operator|->
name|devPrivate
operator|.
name|ptr
operator|)
operator|->
name|bits
expr_stmt|;
name|rw
operator|%=
operator|(
name|int
operator|)
name|pPix
operator|->
name|drawable
operator|.
name|width
expr_stmt|;
if|if
condition|(
name|rw
operator|<
literal|0
condition|)
name|rw
operator|+=
operator|(
name|int
operator|)
name|pPix
operator|->
name|drawable
operator|.
name|width
expr_stmt|;
if|if
condition|(
name|pPix
operator|->
name|drawable
operator|.
name|width
operator|==
literal|32
condition|)
block|{
name|pwFinal
operator|=
name|pw
operator|+
name|pPix
operator|->
name|drawable
operator|.
name|height
expr_stmt|;
while|while
condition|(
name|pw
operator|<
name|pwFinal
condition|)
block|{
name|t
operator|=
operator|*
name|pw
expr_stmt|;
operator|*
name|pw
operator|++
operator|=
name|SCRRIGHT
argument_list|(
name|t
argument_list|,
name|rw
argument_list|)
operator||
operator|(
name|SCRLEFT
argument_list|(
name|t
argument_list|,
operator|(
literal|32
operator|-
name|rw
operator|)
argument_list|)
operator|&
name|endtab
index|[
name|rw
index|]
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We no longer do this.  Validate doesn't try to rotate odd-size 	 * tiles or stipples.  mfbUnnatural<tile/stipple>FS works directly off 	 * the unrotate tile/stipple in the GC 	 */
name|ErrorF
argument_list|(
literal|"X internal error: trying to rotate odd-sized pixmap.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Rotates pixmap pPix by h lines.  Assumes that h is always less than    pPix->height    works on any width.  */
end_comment

begin_function
name|void
name|mfbYRotatePixmap
parameter_list|(
name|pPix
parameter_list|,
name|rh
parameter_list|)
specifier|register
name|PixmapPtr
name|pPix
decl_stmt|;
name|int
name|rh
decl_stmt|;
block|{
name|int
name|nbyDown
decl_stmt|;
comment|/* bytes to move down to row 0; also offset of 			   row rh */
name|int
name|nbyUp
decl_stmt|;
comment|/* bytes to move up to line rh; also 			   offset of first line moved down to 0 */
name|char
modifier|*
name|pbase
decl_stmt|;
name|char
modifier|*
name|ptmp
decl_stmt|;
name|hpPrivPixmapPtr
name|pPrivPix
decl_stmt|;
name|int
name|height
decl_stmt|;
if|if
condition|(
name|pPix
operator|==
name|NullPixmap
condition|)
return|return;
name|pPrivPix
operator|=
operator|(
name|hpPrivPixmapPtr
operator|)
name|pPix
operator|->
name|devPrivate
operator|.
name|ptr
expr_stmt|;
name|height
operator|=
operator|(
name|int
operator|)
name|pPix
operator|->
name|drawable
operator|.
name|height
expr_stmt|;
name|rh
operator|%=
name|height
expr_stmt|;
if|if
condition|(
name|rh
operator|<
literal|0
condition|)
name|rh
operator|+=
name|height
expr_stmt|;
name|pbase
operator|=
operator|(
name|char
operator|*
operator|)
name|pPrivPix
operator|->
name|bits
expr_stmt|;
name|nbyDown
operator|=
name|rh
operator|*
name|pPrivPix
operator|->
name|stride
expr_stmt|;
name|nbyUp
operator|=
operator|(
name|pPrivPix
operator|->
name|stride
operator|*
name|height
operator|)
operator|-
name|nbyDown
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ptmp
operator|=
operator|(
name|char
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|nbyUp
argument_list|)
operator|)
condition|)
return|return;
name|bcopy
argument_list|(
name|pbase
argument_list|,
name|ptmp
argument_list|,
name|nbyUp
argument_list|)
expr_stmt|;
comment|/* save the low rows */
name|bcopy
argument_list|(
name|pbase
operator|+
name|nbyUp
argument_list|,
name|pbase
argument_list|,
name|nbyDown
argument_list|)
expr_stmt|;
comment|/* slide the top rows down */
name|bcopy
argument_list|(
name|ptmp
argument_list|,
name|pbase
operator|+
name|nbyDown
argument_list|,
name|nbyUp
argument_list|)
expr_stmt|;
comment|/* move lower rows up to row rh */
name|DEALLOCATE_LOCAL
argument_list|(
name|ptmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mfbCopyRotatePixmap
parameter_list|(
name|psrcPix
parameter_list|,
name|ppdstPix
parameter_list|,
name|xrot
parameter_list|,
name|yrot
parameter_list|)
specifier|register
name|PixmapPtr
name|psrcPix
decl_stmt|,
decl|*
name|ppdstPix
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|xrot
decl_stmt|,
name|yrot
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PixmapPtr
name|pdstPix
decl_stmt|;
if|if
condition|(
operator|(
name|pdstPix
operator|=
operator|*
name|ppdstPix
operator|)
operator|&&
operator|(
operator|(
operator|(
name|hpPrivPixmapPtr
operator|)
name|pdstPix
operator|->
name|devPrivate
operator|.
name|ptr
operator|)
operator|->
name|stride
operator|==
operator|(
operator|(
name|hpPrivPixmapPtr
operator|)
name|psrcPix
operator|->
name|devPrivate
operator|.
name|ptr
operator|)
operator|->
name|stride
operator|)
operator|&&
operator|(
name|pdstPix
operator|->
name|drawable
operator|.
name|height
operator|==
name|psrcPix
operator|->
name|drawable
operator|.
name|height
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|hpPrivPixmapPtr
operator|)
name|psrcPix
operator|->
name|devPrivate
operator|.
name|ptr
operator|)
operator|->
name|bits
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|hpPrivPixmapPtr
operator|)
name|pdstPix
operator|->
name|devPrivate
operator|.
name|ptr
operator|)
operator|->
name|bits
argument_list|,
name|psrcPix
operator|->
name|drawable
operator|.
name|height
operator|*
operator|(
operator|(
name|hpPrivPixmapPtr
operator|)
name|psrcPix
operator|->
name|devPrivate
operator|.
name|ptr
operator|)
operator|->
name|stride
argument_list|)
expr_stmt|;
name|pdstPix
operator|->
name|drawable
operator|.
name|width
operator|=
name|psrcPix
operator|->
name|drawable
operator|.
name|width
expr_stmt|;
name|pdstPix
operator|->
name|drawable
operator|.
name|serialNumber
operator|=
name|NEXT_SERIAL_NUMBER
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pdstPix
condition|)
name|mfbDestroyPixmap
argument_list|(
name|pdstPix
argument_list|)
expr_stmt|;
operator|*
name|ppdstPix
operator|=
name|pdstPix
operator|=
name|mfbCopyPixmap
argument_list|(
name|psrcPix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pdstPix
condition|)
return|return;
block|}
name|mfbPadPixmap
argument_list|(
name|pdstPix
argument_list|)
expr_stmt|;
if|if
condition|(
name|xrot
condition|)
name|mfbXRotatePixmap
argument_list|(
name|pdstPix
argument_list|,
name|xrot
argument_list|)
expr_stmt|;
if|if
condition|(
name|yrot
condition|)
name|mfbYRotatePixmap
argument_list|(
name|pdstPix
argument_list|,
name|yrot
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

