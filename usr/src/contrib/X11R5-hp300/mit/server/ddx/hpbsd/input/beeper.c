begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (c) 1986, 1987 by Hewlett-Packard Company Copyright (c) 1986, 1987 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD TO THIS SOFWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE.  Hewlett-Packard shall not be liable for errors  contained herein or direct, indirect, special, incidental or  consequential damages in connection with the furnishing,  performance, or use of this material.  This software is not subject to any license of the American Telephone and Telegraph Company or of the Regents of the University of California.  */
end_comment

begin_comment
comment|/* ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; ; File:         beeper.c ; SCCS:         %A% %G% %U% ; Description:  Access Gator/Bobcat beeper ; Author:       Andreas Paepcke, HPLabs/ATL ; Created:      2-Aug-85 ; Modified:     Thu Oct 15 12:53:00 1987 (Don Bennett) bennett@hpldpb ; Language:     C ; Package:      PSL ; Status:       Experimental (Do Not Distribute) ; ; (c) Copyright 1985, Hewlett-Packard Company, all rights reserved. ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; */
end_comment

begin_comment
comment|/* Public functions:         beep     We offer three voices and a noise source. Each sound is controllable    in pitch, volume and duration. Pitch goes from 0 to 1023, volume goes    from 0 to 15, duration is between 0 and 255 10msec intervalls. A    duration of 0 turns the voice on continuously. A volume of 0 turns    it off.    The manufacturing specs give details    on the programming interface. Here is a summary:     The beeper is accessed through ioctl calls. The request argument is    either "Send data to beeper" or "Read voice values from beeper". The    argument is a pointer to a 4 byte buffer. These four bytes    are defined here.     R0-R3: Register address field. In the order R2, R1, R0:            0 0 0: Voice 1 frequency      0 0 1: Voice 1 attenuation      0 1 0: Voice 2 frequency      0 1 1: Voice 2 attenuation      1 0 0: Voice 3 frequency      1 0 1: Voice 3 attenuation      1 1 0: Noise control      1 1 1: Noise attentuation    F0-F9: 10 bits pitch   A0-A3: Attenuation   D0-D7: Duration in 10msec's    The placement of data in the buffer is a bit srewy:    Byte 0 (Frequency 1):  1 R2 R1 R0 F3 F2 F1 F0     LSB   Byte 1(Frequency 2):  0  0 F9 F8 F7 F6 F5 F4   Byte 2 (Attenuator) :  1 R2 R1 R0 A3 A2 A1 A0   Byte 3 (Duration)   : D7 D6 D5 D4 D3 D2 D1 D0    The volume is inversely proportional to the attenuation. In order   to provide rising numbers for rising loudness to the user, we   expect a volume and modify to get the attenuation. The same goes   for the pitch. In order to calculate frequency of the pitch,   use:              83333/(1023-pitch)    It is possible at any time to request the time any voice has   left to run. This is done by:     F4: Read voice1 timer   F5: Read voice2 timer   F6: Read voice3 timer   F7: Read voice4 timer (noise)    Noise is generated using a shift register. The following controls   are possible for noise:     - Attenuation   - Duration   - Periodic or white noise   - 3 shift rates or output of voice 4 as shift rate    Bytes 0 and 1 of the data buffer must both have identical contents   to control the noise. Attenuation and duration are as in the other   voices. Bytes 0 and 1 should look like this:    1 R2 R1 R0 0 FB NF1 NF0   LSB    R2, R1 and R0 must be 1, 1 and 0. If FB is 0, periodic noise   is generated. If FB is 1, white noise is produced.    NF1 and NF2 control the shift rate of the noise generator:    NF1     NF2     Shift Rate   --------------------------   0       0       M/64   0       1       M/128   1       0       M/256   1       1       Uses tone generator 3 output     M is related to the clock rate.    The voice start routines return 0 if all is well, -1 if we had   trouble accessing the device file for the beeper and -2 if given   parameters were out of range: */
end_comment

begin_define
define|#
directive|define
name|NEED_EVENTS
end_define

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"inputstr.h"
end_include

begin_include
include|#
directive|include
file|"hildef.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__apollo
argument_list|)
end_if

begin_include
include|#
directive|include
file|<apollo/base.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __apollo */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|hp9000
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<hilioctl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hp_osf
argument_list|)
end_if

begin_include
include|#
directive|include
file|<hp/hilioctl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/hilioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hp_osf */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hpux || __hp_osf */
end_comment

begin_comment
comment|/********************************************************************* *DEFINES:                                                            * *********************************************************************/
end_comment

begin_define
define|#
directive|define
name|ALL_OK
value|0
end_define

begin_define
define|#
directive|define
name|ACCESS_PROBLEM
value|-1
end_define

begin_define
define|#
directive|define
name|BAD_RANGE
value|-2
end_define

begin_define
define|#
directive|define
name|VOICE1_FREQ_REG
value|0x80
end_define

begin_comment
comment|/* Top nibbles for byte0 for all voices: */
end_comment

begin_define
define|#
directive|define
name|VOICE2_FREQ_REG
value|0xA0
end_define

begin_define
define|#
directive|define
name|VOICE3_FREQ_REG
value|0xC0
end_define

begin_define
define|#
directive|define
name|NOISE_FREQ_REG
value|0xE0
end_define

begin_define
define|#
directive|define
name|VOICE1_VOL_REG
value|0x90
end_define

begin_comment
comment|/* Top nibbles for byte2 for all voices: */
end_comment

begin_define
define|#
directive|define
name|VOICE2_VOL_REG
value|0xB0
end_define

begin_define
define|#
directive|define
name|VOICE3_VOL_REG
value|0xD0
end_define

begin_define
define|#
directive|define
name|NOISE_VOL_REG
value|0xF0
end_define

begin_define
define|#
directive|define
name|MIN_VOICE
value|1
end_define

begin_comment
comment|/* Legal ranges for parms from user: */
end_comment

begin_define
define|#
directive|define
name|MAX_VOICE
value|3
end_define

begin_define
define|#
directive|define
name|MIN_PITCH
value|0
end_define

begin_define
define|#
directive|define
name|MAX_PITCH
value|1023
end_define

begin_define
define|#
directive|define
name|MIN_DURATION
value|0
end_define

begin_define
define|#
directive|define
name|MAX_DURATION
value|255
end_define

begin_define
define|#
directive|define
name|MIN_VOLUME
value|0
end_define

begin_define
define|#
directive|define
name|MAX_VOLUME
value|15
end_define

begin_define
define|#
directive|define
name|MIN_TYPE
value|0
end_define

begin_define
define|#
directive|define
name|MAX_TYPE
value|1
end_define

begin_define
define|#
directive|define
name|MIN_RATE
value|0
end_define

begin_define
define|#
directive|define
name|MAX_RATE
value|3
end_define

begin_decl_stmt
specifier|extern
name|int
name|beeper_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/********************************************************************* * PUBLIC FUNCTIONS:                                                  * *********************************************************************/
end_comment

begin_comment
comment|/***************************************************************************** *                                                                            * * Beep using specified voice:                                                * *                                                                            * *   TAKES:                                                                   * *                                                                            * *   VOICE    : from 1 to 3                                                   * *   PITCH    : from 0 to 1023 (incl)                                         * *   VOLUME   : from 0 to 15   (incl). Zero turns voice off.                  * *   DURATION : from 0 to 255  (incl). Zero turns voice on continuously.      * *                                                                            * *   RETURNS:                                                                 * *                                                                            * *   0        : All ok                                                        * *   -1       : Cannot access beeper device file                              * *   -2       : Parameter out of range                                        * *                                                                            * ******************************************************************************/
end_comment

begin_macro
name|beep
argument_list|(
argument|voice
argument_list|,
argument|pitch
argument_list|,
argument|volume
argument_list|,
argument|duration
argument_list|)
end_macro

begin_decl_stmt
name|int
name|voice
decl_stmt|,
name|pitch
decl_stmt|,
name|volume
decl_stmt|,
name|duration
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|char
name|vol
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__apollo
argument_list|)
endif|#
directive|endif
comment|/* __apollo */
comment|/* Check whether beeper device has already been opened: */
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
if|if
condition|(
name|beeper_fd
operator|<
literal|0
condition|)
return|return
operator|(
name|ACCESS_PROBLEM
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|__hp9000s300
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp9000s700
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp300
argument_list|)
comment|/* Check ranges of parameters: */
if|if
condition|(
operator|(
name|voice
operator|<
name|MIN_VOICE
operator|)
operator|||
operator|(
name|voice
operator|>
name|MAX_VOICE
operator|)
operator|||
operator|(
name|pitch
operator|<
name|MIN_PITCH
operator|)
operator|||
operator|(
name|pitch
operator|>
name|MAX_PITCH
operator|)
operator|||
operator|(
name|volume
operator|<
name|MIN_VOLUME
operator|)
operator|||
operator|(
name|volume
operator|>
name|MAX_VOLUME
operator|)
operator|||
operator|(
name|duration
operator|<
name|MIN_DURATION
operator|)
operator|||
operator|(
name|duration
operator|>
name|MAX_DURATION
operator|)
condition|)
return|return
operator|(
name|BAD_RANGE
operator|)
return|;
comment|/* Init the voice dependent data bytes. Note the inversion of user's      volume and pitch specs to attenuation:   */
name|volume
operator|=
name|MAX_VOLUME
operator|-
name|volume
expr_stmt|;
name|pitch
operator|=
name|MAX_PITCH
operator|-
name|pitch
expr_stmt|;
switch|switch
condition|(
name|voice
condition|)
block|{
case|case
literal|1
case|:
name|buffer
index|[
literal|0
index|]
operator|=
name|VOICE1_FREQ_REG
operator||
operator|(
name|pitch
operator|&
literal|0x0000000f
operator|)
expr_stmt|;
name|buffer
index|[
literal|2
index|]
operator|=
name|VOICE1_VOL_REG
operator||
operator|(
name|volume
operator|&
literal|0x0000000f
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|buffer
index|[
literal|0
index|]
operator|=
name|VOICE2_FREQ_REG
operator||
operator|(
name|pitch
operator|&
literal|0x0000000f
operator|)
expr_stmt|;
name|buffer
index|[
literal|2
index|]
operator|=
name|VOICE2_VOL_REG
operator||
operator|(
name|volume
operator|&
literal|0x0000000f
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|buffer
index|[
literal|0
index|]
operator|=
name|VOICE3_FREQ_REG
operator||
operator|(
name|pitch
operator|&
literal|0x0000000f
operator|)
expr_stmt|;
name|buffer
index|[
literal|2
index|]
operator|=
name|VOICE3_VOL_REG
operator||
operator|(
name|volume
operator|&
literal|0x0000000f
operator|)
expr_stmt|;
break|break;
block|}
comment|/* The high 6 bits of the pitch go into byte 1: */
name|buffer
index|[
literal|1
index|]
operator|=
literal|0x0000003f
operator|&
operator|(
name|pitch
operator|>>
literal|4
operator|)
expr_stmt|;
name|buffer
index|[
literal|3
index|]
operator|=
name|duration
expr_stmt|;
comment|/* Duration: */
if|if
condition|(
name|ioctl
argument_list|(
name|beeper_fd
argument_list|,
name|EFTSBP
argument_list|,
name|buffer
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ACCESS_PROBLEM
operator|)
return|;
return|return
operator|(
name|ALL_OK
operator|)
return|;
else|#
directive|else
comment|/* building for s800 */
comment|/*     * map input range of 0 - 15 to driver range range of 0 - 255     */
if|if
condition|(
operator|!
name|volume
condition|)
return|return;
if|if
condition|(
name|voice
operator|==
literal|2
condition|)
comment|/*  2 == CLICK_VOICE  which means key click */
block|{
comment|/* doesn't appear there's any way to set the volume or duration           on 800 so I'll just pinch the volume for key clicks.  t.houser 	*/
name|vol
operator|=
operator|(
name|char
operator|)
name|volume
operator|*
operator|(
name|KBD_MAXVOLUME
operator|/
literal|45
operator|)
expr_stmt|;
block|}
else|else
comment|/* beeper */
block|{
name|vol
operator|=
operator|(
name|char
operator|)
name|volume
operator|*
operator|(
name|KBD_MAXVOLUME
operator|/
literal|15
operator|)
expr_stmt|;
block|}
name|ioctl
argument_list|(
name|beeper_fd
argument_list|,
name|KBD_BEEP
argument_list|,
operator|&
name|vol
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __hp9000s300 */
endif|#
directive|endif
comment|/* __hpux || __hp_osf */
block|}
end_block

begin_function
name|void
name|SetBellAttributes
parameter_list|(
name|pDevice
parameter_list|,
name|pCtrl
parameter_list|)
specifier|register
name|HPInputDevice
modifier|*
name|pDevice
decl_stmt|;
specifier|register
name|KeybdCtrl
modifier|*
name|pCtrl
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__apollo
argument_list|)
comment|/* The duration passed in in the pCtrl struct is a 16-bit value.        The units is milliseconds, but the tone_$time function has        units of 4 microseconds.     */
name|int
modifier|*
name|duration
init|=
operator|(
name|int
operator|*
operator|)
name|pDevice
operator|->
name|bell1
decl_stmt|;
operator|*
name|duration
operator|=
name|pCtrl
operator|->
name|bell_duration
operator|*
literal|250
expr_stmt|;
comment|/* save in tone_$time units */
endif|#
directive|endif
comment|/* __apollo */
if|#
directive|if
name|defined
argument_list|(
name|__hp9000s300
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp9000s700
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp300
argument_list|)
specifier|register
name|unsigned
name|char
name|duration
decl_stmt|;
specifier|register
name|int
name|bellPitch
decl_stmt|;
name|duration
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|pCtrl
operator|->
name|bell_duration
operator|/
literal|10
argument_list|)
expr_stmt|;
name|bellPitch
operator|=
name|pCtrl
operator|->
name|bell_pitch
operator|==
literal|0
condition|?
literal|1023
else|:
operator|(
literal|83333
operator|/
name|pCtrl
operator|->
name|bell_pitch
operator|)
expr_stmt|;
if|if
condition|(
name|bellPitch
operator|<
literal|0
condition|)
name|bellPitch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bellPitch
operator|>
literal|1023
condition|)
name|bellPitch
operator|=
literal|1023
expr_stmt|;
name|pDevice
operator|->
name|bell1
index|[
literal|0
index|]
operator|=
name|VOICE1_FREQ_REG
operator||
operator|(
name|bellPitch
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|pDevice
operator|->
name|bell2
index|[
literal|0
index|]
operator|=
name|VOICE2_FREQ_REG
operator||
operator|(
name|bellPitch
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|pDevice
operator|->
name|bell3
index|[
literal|0
index|]
operator|=
name|VOICE3_FREQ_REG
operator||
operator|(
name|bellPitch
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|pDevice
operator|->
name|bell1
index|[
literal|1
index|]
operator|=
literal|0x03f
operator|&
operator|(
name|bellPitch
operator|>>
literal|4
operator|)
expr_stmt|;
name|pDevice
operator|->
name|bell2
index|[
literal|1
index|]
operator|=
literal|0x03f
operator|&
operator|(
name|bellPitch
operator|>>
literal|4
operator|)
expr_stmt|;
name|pDevice
operator|->
name|bell3
index|[
literal|1
index|]
operator|=
literal|0x03f
operator|&
operator|(
name|bellPitch
operator|>>
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|duration
condition|)
block|{
name|pDevice
operator|->
name|bell1
index|[
literal|3
index|]
operator|=
name|pDevice
operator|->
name|bell2
index|[
literal|3
index|]
operator|=
name|pDevice
operator|->
name|bell3
index|[
literal|3
index|]
operator|=
name|duration
expr_stmt|;
block|}
else|else
block|{
name|pDevice
operator|->
name|bell1
index|[
literal|3
index|]
operator|=
name|pDevice
operator|->
name|bell2
index|[
literal|3
index|]
operator|=
name|pDevice
operator|->
name|bell3
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* building on __hp9000s300  or for s700 */
block|}
end_function

begin_function
name|void
name|hpBell
parameter_list|(
name|volume
parameter_list|,
name|pDevice
parameter_list|)
specifier|register
name|int
name|volume
decl_stmt|;
specifier|register
name|DevicePtr
name|pDevice
decl_stmt|;
block|{
specifier|register
name|int
name|attenuation
decl_stmt|,
name|loud
decl_stmt|;
specifier|register
name|HPInputDevice
modifier|*
name|pHPDev
init|=
operator|(
name|HPInputDevice
operator|*
operator|)
operator|(
operator|(
operator|(
name|DeviceIntPtr
operator|)
name|pDevice
operator|)
operator|->
name|public
operator|.
name|devicePrivate
operator|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__apollo
argument_list|)
if|if
condition|(
name|volume
condition|)
block|{
name|int
modifier|*
name|duration
init|=
operator|(
name|int
operator|*
operator|)
name|pHPDev
operator|->
name|bell1
decl_stmt|;
name|time_$clock_t
name|beepTime
decl_stmt|;
name|beepTime
operator|.
name|high16
operator|=
literal|0
expr_stmt|;
name|beepTime
operator|.
name|low32
operator|=
operator|*
name|duration
expr_stmt|;
name|tone_$time
argument_list|(
operator|&
name|beepTime
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __apollo */
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
if|if
condition|(
name|beeper_fd
operator|<
literal|0
condition|)
return|return;
comment|/*      * device independant code has already range checked the volume      */
if|if
condition|(
name|volume
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__hp9000s300
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp9000s700
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp300
argument_list|)
comment|/*           * map input range of 0 - 100 to hardware attenuation range of 15 - 0 	  * we use a temp variable (loud) because of C's penchant for 	  * strange orders of evaluation ie to force the multiply before 	  * the divide           */
name|loud
operator|=
name|volume
operator|*
name|MAX_VOLUME
expr_stmt|;
name|attenuation
operator|=
operator|(
name|char
operator|)
name|MAX_VOLUME
operator|-
name|loud
operator|/
literal|100
expr_stmt|;
comment|/*           * we use all three voices to get a reasonably loud volume           */
name|pHPDev
operator|->
name|bell1
index|[
literal|2
index|]
operator|=
name|VOICE1_VOL_REG
operator||
name|attenuation
expr_stmt|;
name|pHPDev
operator|->
name|bell2
index|[
literal|2
index|]
operator|=
name|VOICE2_VOL_REG
operator||
name|attenuation
expr_stmt|;
name|pHPDev
operator|->
name|bell3
index|[
literal|2
index|]
operator|=
name|VOICE3_VOL_REG
operator||
name|attenuation
expr_stmt|;
name|ioctl
argument_list|(
name|beeper_fd
argument_list|,
name|EFTSBP
argument_list|,
name|pHPDev
operator|->
name|bell1
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|beeper_fd
argument_list|,
name|EFTSBP
argument_list|,
name|pHPDev
operator|->
name|bell2
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|beeper_fd
argument_list|,
name|EFTSBP
argument_list|,
name|pHPDev
operator|->
name|bell3
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* building for s800 */
comment|/*           * map input range of 0 - 100 to driver range range of 0 - 255           */
name|char
name|vol
decl_stmt|;
name|vol
operator|=
name|volume
operator|*
name|KBD_MAXVOLUME
operator|/
literal|100
expr_stmt|;
name|ioctl
argument_list|(
name|beeper_fd
argument_list|,
name|KBD_BEEP
argument_list|,
operator|&
name|vol
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* building on __hp9000s300 or for s700 */
block|}
endif|#
directive|endif
comment|/* __hpux || __hp_osf */
return|return;
block|}
end_function

end_unit

