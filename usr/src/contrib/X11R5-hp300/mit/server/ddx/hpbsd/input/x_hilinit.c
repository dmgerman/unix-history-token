begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: /host/debretts/disk2/X11R5/R5-hp300/mit/server/ddx/hpbsd/input/RCS/x_hilinit.c,v 1.2 1993/04/21 21:44:37 root Exp $ */
end_comment

begin_comment
comment|/******************************************************************* ** **    ********************************************************* **    * **    *  File:          ddx/hp/hp/x_hilinit.c **    * **    *  Contents:      Input initialization routines for the **    *                 X/Starbase Merged Server **    * **    *  Created:       4/28/88 **    * **    *  Last Change:   12/06/88 **    * **    *  Last Release:  IC2 **    * **    *  Revision:      A.01.00 **    * **    *  Author:        --gms **    * **    *  Copyright:     (c) 1988 Hewlett-Packard Company **    * **    ********************************************************* **  ********************************************************************/
end_comment

begin_comment
comment|/*'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' Copyright (c) 1988 by Hewlett-Packard Company Copyright (c) 1987, 1988 by Digital Equipment Corporation, Maynard,                Massachusetts, and the Massachusetts Institute of Technology,                Cambridge, Massachusetts  Permission to use, copy, modify, and distribute this software  and its documentation for any purpose and without fee is hereby  granted, provided that the above copyright notice appear in all  copies and that both that copyright notice and this permission  notice appear in supporting documentation, and that the names of  Hewlett-Packard, Digital or  M.I.T.  not be used in advertising or  publicity pertaining to distribution of the software without specific,  written prior permission.  DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''*/
end_comment

begin_define
define|#
directive|define
name|MAXNAMLEN
value|255
end_define

begin_define
define|#
directive|define
name|NEED_EVENTS
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|hp9000
end_ifdef

begin_define
define|#
directive|define
name|BEEPER_DEVICE
value|"/dev/hil0"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BEEPER_DEVICE
value|"/dev/rhil"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|hp9000
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<hilioctl.h>
end_include

begin_undef
undef|#
directive|undef
name|HILER1
end_undef

begin_undef
undef|#
directive|undef
name|HILDKR
end_undef

begin_define
define|#
directive|define
name|HILER1
value|HILIOCAR1
end_define

begin_define
define|#
directive|define
name|HILDKR
value|HILIOCAROFF
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__hp_osf
end_ifdef

begin_include
include|#
directive|include
file|<hp/hilioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/hilioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|hp9000
end_ifndef

begin_include
include|#
directive|include
file|<dl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hpux */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"hildef.h"
end_include

begin_include
include|#
directive|include
file|"XHPproto.h"
end_include

begin_comment
comment|/* extension constants	*/
end_comment

begin_include
include|#
directive|include
file|"x_hilinit.h"
end_include

begin_include
include|#
directive|include
file|"x_hil.h"
end_include

begin_include
include|#
directive|include
file|"x_serialdrv.h"
end_include

begin_include
include|#
directive|include
file|"inputstr.h"
end_include

begin_include
include|#
directive|include
file|"../../../os/osdep.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XINPUT
end_ifdef

begin_include
include|#
directive|include
file|"XI.h"
end_include

begin_include
include|#
directive|include
file|"XIproto.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Relative
value|0
end_define

begin_define
define|#
directive|define
name|Absolute
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XINPUT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__apollo
end_ifdef

begin_include
include|#
directive|include
file|"screenint.h"
end_include

begin_include
include|#
directive|include
file|"../apollo/apollo.h"
end_include

begin_include
include|#
directive|include
file|"../apollo/smd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __apollo */
end_comment

begin_comment
comment|/******************************************************************  *  * Externs and global variables that may be referenced by other files.  *  */
end_comment

begin_decl_stmt
name|int
name|num_serial_devices
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SerialProcs
name|serialprocs
index|[
name|MAX_DEVICES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HPInputDevice
modifier|*
name|hpKeyboard
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HPInputDevice
modifier|*
name|hpPointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HPInputDevice
modifier|*
name|hptablet_extension
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__hp_osf
end_ifdef

begin_decl_stmt
name|HILQ
modifier|*
name|hil_qp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hil_qd
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hp_osf */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__apollo
end_ifdef

begin_decl_stmt
specifier|extern
name|long
modifier|*
name|apECV
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
modifier|*
name|apLastECV
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fdApollo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|status_$t
name|status
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __apollo */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XINPUT
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|BadDevice
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|BadMode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|IReqCode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|DeviceKeyPress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|DeviceKeyRelease
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|DeviceButtonPress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|DeviceButtonRelease
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|DeviceMotionNotify
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_DONE
end_ifdef

begin_decl_stmt
specifier|extern
name|XID
name|hp_device_ids
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|XID
name|x_device_ids
index|[
name|MAX_DEVICES
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XINPUT */
end_comment

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|dpmotionBuf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|dheadmotionBuf
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|SetBellAttributes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hpBell
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|u_char
name|identity_map
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|mv_mods
decl_stmt|,
name|ptr_mods
decl_stmt|,
name|rs_mods
decl_stmt|,
name|bw_mods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|pointer_amt_bits
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|display
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* display number as a string */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|queue_events_free
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|x11EventQueue
modifier|*
name|events_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|InputInfo
name|inputInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastEventTime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|axes_changed
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|keyboard_click
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|allocated_dev_names
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x_axis
decl_stmt|,
name|y_axis
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|otherndx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|beeper_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ldigit
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|xhp_kbdid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|tablet_xlimit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|tablet_ylimit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|tablet_xorg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|tablet_yorg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|inputs_selected
name|valid_inputs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HPInputDevice
name|l_devs
index|[
name|MAX_LOGICAL_DEVS
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|DeviceIntPtr
name|LookupDeviceIntRec
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|DeviceIntPtr
name|tablet_extension_device
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DeviceIntPtr
name|screen_change_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|HPType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|device_ndx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************  *  * Variables that are global to this file only.  *  */
end_comment

begin_function_decl
specifier|static
name|int
name|init_hil_devs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_device_details
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SetAutoRepeat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|device_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|DevicePtr
name|hpAddInputDevice
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RecordOpenRequest
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SetInputDevice
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mask_from_kcodes
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|loopnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|hilpath
index|[
name|MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ProcessOtherEvent
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|xHPEvent
name|events_array
index|[
name|MAX_EVENTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input event buffer*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|x11EventQueue
name|ev_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count
index|[
name|NUM_DEV_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|prompt
index|[]
init|=
block|{
name|HILP
block|,
name|HILP1
block|,
name|HILP2
block|,
name|HILP3
block|,
name|HILP4
block|,
name|HILP5
block|,
name|HILP6
block|,
name|HILP7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ack
index|[]
init|=
block|{
name|HILA
block|,
name|HILA1
block|,
name|HILA2
block|,
name|HILA3
block|,
name|HILA4
block|,
name|HILA5
block|,
name|HILA6
block|,
name|HILA7
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hpux */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dev_names
index|[
name|MAX_LOGICAL_DEVS
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hp9000s300
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp9000s700
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp300
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|default_names
index|[
name|MAX_LOGICAL_DEVS
index|]
init|=
block|{
literal|"/dev/hil1"
block|,
literal|"/dev/hil2"
block|,
literal|"/dev/hil3"
block|,
literal|"/dev/hil4"
block|,
literal|"/dev/hil5"
block|,
literal|"/dev/hil6"
block|,
literal|"/dev/hil7"
block|,
literal|""
block|,
literal|"/dev/null"
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* building for s800 */
end_comment

begin_decl_stmt
name|char
name|beeper_name
index|[]
init|=
literal|"/dev/hilkbd "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|default_names
index|[
name|MAX_LOGICAL_DEVS
index|]
init|=
block|{
literal|"/dev/hil_0.1"
block|,
literal|"/dev/hil_0.2"
block|,
literal|"/dev/hil_0.3"
block|,
literal|"/dev/hil_0.4"
block|,
literal|"/dev/hil_0.5"
block|,
literal|"/dev/hil_0.6"
block|,
literal|"/dev/hil_0.7"
block|,
literal|"/dev/hil_1.1"
block|,
literal|"/dev/hil_1.2"
block|,
literal|"/dev/hil_1.3"
block|,
literal|"/dev/hil_1.4"
block|,
literal|"/dev/hil_1.5"
block|,
literal|"/dev/hil_1.6"
block|,
literal|"/dev/hil_1.7"
block|,
literal|"/dev/hil_2.1"
block|,
literal|"/dev/hil_2.2"
block|,
literal|"/dev/hil_2.3"
block|,
literal|"/dev/hil_2.4"
block|,
literal|"/dev/hil_2.5"
block|,
literal|"/dev/hil_2.6"
block|,
literal|"/dev/hil_2.7"
block|,
literal|"/dev/hil_3.1"
block|,
literal|"/dev/hil_3.2"
block|,
literal|"/dev/hil_3.3"
block|,
literal|"/dev/hil_3.4"
block|,
literal|"/dev/hil_3.5"
block|,
literal|"/dev/hil_3.6"
block|,
literal|"/dev/hil_3.7"
block|,
literal|""
block|,
literal|"/dev/null"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* building on __hp9000s300 or for s700 */
end_comment

begin_comment
comment|/****************************************************************************  *  * Change acceleration& threshold.  * The DIX routine that handles the ChangePointerControl request has  * already validity checked the values and copied them into the  * DeviceIntRec.  This routine just copies them into fields that are  * the same no matter what kind of device we're dealing with.  *  */
end_comment

begin_function
specifier|static
name|void
name|hpChangePointerControl
parameter_list|(
name|pDevice
parameter_list|,
name|ctrl
parameter_list|)
name|DevicePtr
name|pDevice
decl_stmt|;
name|PtrCtrl
modifier|*
name|ctrl
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|XINPUT
name|PtrFeedbackPtr
name|b
decl_stmt|;
name|b
operator|=
operator|(
operator|(
name|DeviceIntPtr
operator|)
name|pDevice
operator|)
operator|->
name|ptrfeed
expr_stmt|;
name|b
operator|->
name|ctrl
operator|=
operator|*
name|ctrl
expr_stmt|;
else|#
directive|else
specifier|extern
name|int
name|threshold
decl_stmt|;
specifier|extern
name|int
name|acceleration
decl_stmt|;
name|threshold
operator|=
name|ctrl
operator|->
name|threshold
expr_stmt|;
name|acceleration
operator|=
name|ctrl
operator|->
name|num
expr_stmt|;
if|if
condition|(
name|acceleration
operator|<=
literal|0
condition|)
name|acceleration
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* XINPUT */
ifdef|#
directive|ifdef
name|__apollo
block|{
name|smd_$pos_t
name|pos
decl_stmt|;
specifier|extern
name|smd_unit_event_data_t
name|olddata
decl_stmt|;
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|(
name|DeviceIntPtr
operator|)
name|pDevice
operator|==
name|inputInfo
operator|.
name|pointer
condition|)
block|{
name|d
operator|=
name|GET_HPINPUTDEVICE
argument_list|(
operator|(
name|DeviceIntPtr
operator|)
name|pDevice
argument_list|)
expr_stmt|;
name|pos
operator|.
name|column
operator|=
name|d
operator|->
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|pos
operator|.
name|line
operator|=
name|d
operator|->
name|coords
index|[
literal|1
index|]
expr_stmt|;
name|olddata
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
name|smd_$set_unit_cursor_pos
argument_list|(
literal|1
argument_list|,
name|pos
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* __apollo */
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Turn LEDs on or off.  *  */
end_comment

begin_function
specifier|static
name|void
name|SetLeds
parameter_list|(
name|d
parameter_list|,
name|leds
parameter_list|,
name|mask
parameter_list|)
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
name|unsigned
name|int
name|leds
decl_stmt|,
name|mask
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|iob
decl_stmt|;
name|char
name|ioctl_data
index|[
literal|12
index|]
decl_stmt|;
name|HPLedFeedbackControl
name|ctrl
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
if|if
condition|(
name|d
operator|->
name|hil_header
operator|.
name|iob
operator|&
name|HILIOB_PAA
condition|)
comment|/* general prompt */
block|{
if|if
condition|(
name|leds
operator|&
literal|1
condition|)
name|ioctl
argument_list|(
name|d
operator|->
name|file_ds
argument_list|,
name|HILP
argument_list|,
name|ioctl_data
argument_list|)
expr_stmt|;
else|else
name|ioctl
argument_list|(
name|d
operator|->
name|file_ds
argument_list|,
name|HILA
argument_list|,
name|ioctl_data
argument_list|)
expr_stmt|;
name|leds
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|iob
operator|=
operator|(
call|(
name|u_char
call|)
argument_list|(
name|d
operator|->
name|hil_header
operator|.
name|iob
operator|&
name|HILIOB_NPA
argument_list|)
operator|>>
literal|4
operator|)
condition|)
comment|/* prompt 1-7 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|iob
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|leds
operator|&
literal|1
condition|)
name|ioctl
argument_list|(
name|d
operator|->
name|file_ds
argument_list|,
name|prompt
index|[
name|i
index|]
argument_list|,
name|ioctl_data
argument_list|)
expr_stmt|;
else|else
name|ioctl
argument_list|(
name|d
operator|->
name|file_ds
argument_list|,
name|ack
index|[
name|i
index|]
argument_list|,
name|ioctl_data
argument_list|)
expr_stmt|;
name|leds
operator|>>=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __hpux */
if|if
condition|(
name|d
operator|->
name|hpflags
operator|&
name|IS_SERIAL_DEVICE
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_serial_devices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|file_ds
operator|==
name|serialprocs
index|[
name|i
index|]
operator|.
name|fd
condition|)
block|{
name|ctrl
operator|.
name|class
operator|=
name|LedFeedbackClass
expr_stmt|;
name|ctrl
operator|.
name|led_values
operator|=
name|leds
expr_stmt|;
name|ctrl
operator|.
name|led_mask
operator|=
name|mask
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
operator|(
name|serialprocs
index|[
name|i
index|]
operator|.
name|write
operator|)
argument_list|)
argument_list|(
name|d
operator|->
name|file_ds
argument_list|,
name|_XChangeFeedbackControl
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * The members of the ledCtrl structure have the following values:  *  * mask:	1 bit per LED.  * value:	if mask set, turn it on or off.  *  */
end_comment

begin_function
specifier|static
name|void
name|hpChangeLedControl
parameter_list|(
name|pDevice
parameter_list|,
name|ctrl
parameter_list|)
name|DevicePtr
name|pDevice
decl_stmt|;
name|LedCtrl
modifier|*
name|ctrl
decl_stmt|;
block|{
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|GET_HPINPUTDEVICE
argument_list|(
operator|(
name|DeviceIntPtr
operator|)
name|pDevice
argument_list|)
expr_stmt|;
name|SetLeds
argument_list|(
name|d
argument_list|,
name|ctrl
operator|->
name|led_values
argument_list|,
name|ctrl
operator|->
name|led_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * The members of the keybdCtrl structure have the following values:  *  * click:	0(off) - 100 (loud);	-1 => default;  * bell:	0(off) - 100 (loud); 	-1 => default;  * bell_pitch:  Pitch of the bell in Hz;-1 => default;  * bell_duration: in miliseconds;	-1 => default;  *  * keyboard_click is checked whenever a key is pressed, in x_hil.c.  */
end_comment

begin_function
specifier|static
name|void
name|hpChangeKeyboardControl
parameter_list|(
name|pDevice
parameter_list|,
name|ctrl
parameter_list|)
name|DevicePtr
name|pDevice
decl_stmt|;
name|KeybdCtrl
modifier|*
name|ctrl
decl_stmt|;
block|{
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|inputInfo
operator|.
name|keyboard
operator|&&
operator|(
operator|(
name|DeviceIntPtr
operator|)
name|pDevice
operator|)
operator|->
name|id
operator|==
name|inputInfo
operator|.
name|keyboard
operator|->
name|id
condition|)
name|keyboard_click
operator|=
call|(
name|int
call|)
argument_list|(
call|(
name|double
call|)
argument_list|(
name|ctrl
operator|->
name|click
argument_list|)
operator|*
literal|15.0
operator|/
literal|100.0
argument_list|)
expr_stmt|;
name|d
operator|=
name|GET_HPINPUTDEVICE
argument_list|(
operator|(
name|DeviceIntPtr
operator|)
name|pDevice
argument_list|)
expr_stmt|;
name|SetAutoRepeat
argument_list|(
name|d
argument_list|,
name|ctrl
operator|->
name|autoRepeat
argument_list|)
expr_stmt|;
name|SetBellAttributes
argument_list|(
name|d
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|SetLeds
argument_list|(
name|d
argument_list|,
name|ctrl
operator|->
name|leds
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * hpGetDeviceMotionEvents.  *  */
end_comment

begin_function
specifier|static
name|int
name|hpGetDeviceMotionEvents
parameter_list|(
name|dev
parameter_list|,
name|buff
parameter_list|,
name|start
parameter_list|,
name|stop
parameter_list|)
name|DeviceIntPtr
name|dev
decl_stmt|;
name|CARD32
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
block|{
name|HPInputDevice
modifier|*
name|pHPDev
init|=
operator|(
name|HPInputDevice
operator|*
operator|)
name|dev
operator|->
name|public
operator|.
name|devicePrivate
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|evcount
init|=
literal|0
decl_stmt|;
name|int
name|size
init|=
name|pHPDev
operator|->
name|hil_header
operator|.
name|ax_num
operator|+
literal|1
decl_stmt|;
name|int
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|curr
decl_stmt|;
name|int
modifier|*
name|buffp
init|=
operator|(
name|int
operator|*
operator|)
name|buff
decl_stmt|;
name|int
modifier|*
name|pmBuf
init|=
name|dpmotionBuf
index|[
name|dev
operator|->
name|id
index|]
decl_stmt|;
name|int
modifier|*
name|hmBuf
init|=
name|dheadmotionBuf
index|[
name|dev
operator|->
name|id
index|]
decl_stmt|;
if|if
condition|(
name|pmBuf
operator|==
name|hmBuf
condition|)
block|{
if|if
condition|(
operator|*
name|pmBuf
operator|==
literal|0
condition|)
comment|/* no events yet           */
return|return
literal|0
return|;
else|else
name|last
operator|=
name|hmBuf
operator|+
operator|(
literal|99
operator|*
name|size
operator|)
expr_stmt|;
block|}
else|else
name|last
operator|=
name|pmBuf
operator|-
name|size
expr_stmt|;
if|if
condition|(
operator|*
name|pmBuf
operator|==
literal|0
condition|)
comment|/* haven't wrapped yet	    */
name|first
operator|=
name|hmBuf
expr_stmt|;
else|else
name|first
operator|=
name|pmBuf
expr_stmt|;
if|if
condition|(
name|start
operator|>
operator|*
name|last
condition|)
comment|/* start time> last time    */
return|return
literal|0
return|;
else|else
block|{
name|curr
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|*
name|curr
operator|<
name|start
condition|)
block|{
name|curr
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|curr
operator|==
name|hmBuf
operator|+
operator|(
literal|100
operator|*
name|size
operator|)
condition|)
name|curr
operator|=
name|hmBuf
expr_stmt|;
if|if
condition|(
name|curr
operator|==
name|first
condition|)
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|*
name|curr
operator|<=
name|stop
operator|&&
operator|*
name|curr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dev
operator|==
name|inputInfo
operator|.
name|pointer
condition|)
comment|/*X pointer is 16 bits/axis */
block|{
operator|*
name|buffp
operator|++
operator|=
operator|*
name|curr
operator|++
expr_stmt|;
comment|/* copy the time */
operator|*
name|buffp
operator|++
operator|=
operator|*
name|curr
operator|<<
literal|16
operator||
operator|*
operator|(
name|curr
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* copy data for 2 axes */
name|curr
operator|+=
literal|2
expr_stmt|;
block|}
else|else
comment|/* other devices are 32 bits */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
operator|*
name|buffp
operator|++
operator|=
operator|*
name|curr
operator|++
expr_stmt|;
name|evcount
operator|++
expr_stmt|;
if|if
condition|(
name|curr
operator|==
name|hmBuf
operator|+
operator|(
literal|100
operator|*
name|size
operator|)
condition|)
name|curr
operator|=
name|hmBuf
expr_stmt|;
if|if
condition|(
name|curr
operator|==
name|first
condition|)
break|break;
block|}
block|}
return|return
operator|(
name|evcount
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * NOTE: The first parameter passed to this routine is really a DeviceIntPtr.  *       The declaration used here works because the first element of the      *	 structure pointed to by the DeviceIntPtr is a DeviceRec.  *  */
end_comment

begin_function
specifier|static
name|Bool
name|hpDeviceProc
parameter_list|(
name|pDev
parameter_list|,
name|onoff
parameter_list|)
name|DevicePtr
name|pDev
decl_stmt|;
name|int
name|onoff
decl_stmt|;
block|{
name|int
name|keyId
decl_stmt|;
name|unsigned
name|int
name|mask
decl_stmt|;
name|KeySymsRec
modifier|*
name|key_syms
decl_stmt|,
name|keysym_rec
decl_stmt|;
name|CARD8
modifier|*
name|the_modmap
decl_stmt|;
ifdef|#
directive|ifdef
name|__apollo
define|#
directive|define
name|SHORT_STRLEN
value|4
name|char
name|kbdtypestr
index|[
name|SHORT_STRLEN
index|]
decl_stmt|;
name|short
name|kbdtypestrlen
decl_stmt|;
specifier|static
name|char
name|kbdtype
decl_stmt|,
name|kbdsubtype
decl_stmt|;
endif|#
directive|endif
comment|/* __apollo */
name|DeviceIntPtr
name|dev
init|=
operator|(
name|DeviceIntPtr
operator|)
name|pDev
decl_stmt|;
name|HPInputDevice
modifier|*
name|pHPDev
init|=
operator|(
name|HPInputDevice
operator|*
operator|)
name|pDev
operator|->
name|devicePrivate
decl_stmt|;
name|struct
name|hil_desc_record
modifier|*
name|h
init|=
operator|&
name|pHPDev
operator|->
name|hil_header
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|button_count
init|=
name|h
operator|->
name|v_button_count
condition|?
name|h
operator|->
name|v_button_count
else|:
literal|3
decl_stmt|;
name|int
name|mbufsiz
init|=
operator|(
name|h
operator|->
name|ax_num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Time
argument_list|)
operator|)
operator|*
name|MOTION_BUFFER_SIZE
decl_stmt|;
ifdef|#
directive|ifdef
name|XINPUT
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
name|char
modifier|*
name|nptr
decl_stmt|;
endif|#
directive|endif
comment|/* XINPUT */
switch|switch
condition|(
name|onoff
condition|)
block|{
case|case
name|DEVICE_INIT
case|:
name|pDev
operator|->
name|on
operator|=
name|FALSE
expr_stmt|;
name|pHPDev
operator|->
name|pScreen
operator|=
name|screenInfo
operator|.
name|screens
index|[
literal|0
index|]
expr_stmt|;
name|nptr
operator|=
name|strchr
argument_list|(
name|pHPDev
operator|->
name|x_name
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
name|AssignTypeAndName
argument_list|(
name|pDev
argument_list|,
name|pHPDev
operator|->
name|x_atom
argument_list|,
operator|++
name|nptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|num_keys
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
if|if
condition|(
name|h
operator|->
name|iob
operator|&
name|HILIOB_NPA
condition|)
comment|/* PS2 kbd */
block|{
name|keyId
operator|=
name|hil_to_kbd_id
argument_list|(
name|h
operator|->
name|id
operator|+
literal|0x20
argument_list|)
expr_stmt|;
name|pHPDev
operator|->
name|id_detail
operator|=
name|HP_HIL
operator||
name|PC101_KBD
expr_stmt|;
block|}
else|else
name|keyId
operator|=
name|hil_to_kbd_id
argument_list|(
name|h
operator|->
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__apollo
comment|/* 		 * Detect keyboard type and do initialization accordingly. 		 * Note: 		 *   If the keyboard is "3x" but not one of the known types, its 		 *     probably an ISO keyboard.  The Swedish/Finish keymap is 		 *     a superset of ISO (according to Dan G) so I use that. 		 *   Otherwise, use North American as a default. 		 */
name|smd_$inq_kbd_type
argument_list|(
name|SHORT_STRLEN
argument_list|,
name|kbdtypestr
argument_list|,
operator|&
name|kbdtypestrlen
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|kbdtype
operator|=
operator|(
name|kbdtypestrlen
operator|>
literal|0
operator|)
condition|?
name|kbdtypestr
index|[
literal|0
index|]
else|:
literal|'2'
expr_stmt|;
name|kbdsubtype
operator|=
operator|(
name|kbdtypestrlen
operator|>
literal|1
operator|)
condition|?
name|kbdtypestr
index|[
literal|1
index|]
else|:
literal|' '
expr_stmt|;
name|keyId
operator|=
literal|33
expr_stmt|;
comment|/* assume North American (subtype ' ') */
if|if
condition|(
name|kbdtype
operator|==
literal|'3'
condition|)
switch|switch
condition|(
name|kbdsubtype
condition|)
block|{
case|case
literal|' '
case|:
name|keyId
operator|=
literal|33
expr_stmt|;
break|break;
comment|/* North American */
case|case
literal|'a'
case|:
name|keyId
operator|=
literal|34
expr_stmt|;
break|break;
comment|/* German */
case|case
literal|'b'
case|:
name|keyId
operator|=
literal|35
expr_stmt|;
break|break;
comment|/* French */
case|case
literal|'c'
case|:
name|keyId
operator|=
literal|36
expr_stmt|;
break|break;
comment|/* Norwegian/Danish */
case|case
literal|'d'
case|:
name|keyId
operator|=
literal|37
expr_stmt|;
break|break;
comment|/* Swedish/Finish */
case|case
literal|'e'
case|:
name|keyId
operator|=
literal|38
expr_stmt|;
break|break;
comment|/* UK */
case|case
literal|'g'
case|:
name|keyId
operator|=
literal|39
expr_stmt|;
break|break;
comment|/* Swiss */
case|case
literal|'f'
case|:
name|keyId
operator|=
literal|40
expr_stmt|;
break|break;
comment|/* Japanese */
default|default:
name|keyId
operator|=
literal|37
expr_stmt|;
comment|/* unknown - ISO ? */
block|}
endif|#
directive|endif
comment|/* __apollo */
if|if
condition|(
name|pHPDev
operator|->
name|hpflags
operator|&
name|IS_SERIAL_DEVICE
condition|)
block|{
if|if
condition|(
operator|!
name|HPKget_kb_info_by_name
argument_list|(
name|nptr
argument_list|,
operator|&
name|keysym_rec
argument_list|,
operator|&
name|the_modmap
argument_list|)
operator|&&
name|pHPDev
operator|==
name|hpKeyboard
condition|)
name|FatalError
argument_list|(
literal|"Can't find a keymap in the /usr/lib/X11/XHPKeymaps file for the X keyboard device.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|HPKget_maps_by_id
argument_list|(
name|keyId
argument_list|,
operator|&
name|keysym_rec
argument_list|,
operator|&
name|the_modmap
argument_list|)
expr_stmt|;
name|key_syms
operator|=
operator|&
name|keysym_rec
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id
operator|==
name|inputInfo
operator|.
name|keyboard
operator|->
name|id
condition|)
block|{
name|InitKeyboardDeviceStruct
argument_list|(
name|pDev
argument_list|,
name|key_syms
argument_list|,
name|the_modmap
argument_list|,
name|hpBell
argument_list|,
name|hpChangeKeyboardControl
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XINPUT
else|else
block|{
name|InitKeyClassDeviceStruct
argument_list|(
name|dev
argument_list|,
name|key_syms
argument_list|,
name|the_modmap
argument_list|)
expr_stmt|;
name|InitKbdFeedbackClassDeviceStruct
argument_list|(
name|dev
argument_list|,
name|hpBell
argument_list|,
name|hpChangeKeyboardControl
argument_list|)
expr_stmt|;
name|InitFocusClassDeviceStruct
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|num_leds
operator|&&
name|dev
operator|->
name|id
operator|!=
name|inputInfo
operator|.
name|pointer
operator|->
name|id
operator|&&
name|dev
operator|->
name|id
operator|!=
name|inputInfo
operator|.
name|keyboard
operator|->
name|id
condition|)
block|{
name|LedFeedbackPtr
name|led
decl_stmt|;
name|InitLedFeedbackClassDeviceStruct
argument_list|(
name|dev
argument_list|,
name|hpChangeLedControl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
operator|->
name|num_leds
condition|;
name|i
operator|++
control|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
for|for
control|(
name|led
operator|=
name|dev
operator|->
name|leds
init|;
name|led
condition|;
name|led
operator|=
name|led
operator|->
name|next
control|)
name|led
operator|->
name|ctrl
operator|.
name|led_mask
operator|=
name|mask
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XINPUT */
if|if
condition|(
name|h
operator|->
name|ax_num
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|id
operator|==
name|inputInfo
operator|.
name|pointer
operator|->
name|id
condition|)
block|{
if|if
condition|(
name|pHPDev
operator|->
name|dev_type
operator|==
name|NULL_DEVICE
condition|)
block|{
name|pHPDev
operator|->
name|coords
index|[
literal|0
index|]
operator|=
name|pHPDev
operator|->
name|pScreen
operator|->
name|width
expr_stmt|;
name|pHPDev
operator|->
name|coords
index|[
literal|1
index|]
operator|=
name|pHPDev
operator|->
name|pScreen
operator|->
name|height
expr_stmt|;
block|}
else|else
block|{
name|pHPDev
operator|->
name|coords
index|[
literal|0
index|]
operator|=
name|pHPDev
operator|->
name|pScreen
operator|->
name|width
operator|/
literal|2
expr_stmt|;
name|pHPDev
operator|->
name|coords
index|[
literal|1
index|]
operator|=
name|pHPDev
operator|->
name|pScreen
operator|->
name|height
operator|/
literal|2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__apollo
name|smd_$pos_t
name|pos
decl_stmt|;
specifier|extern
name|smd_unit_event_data_t
name|olddata
decl_stmt|;
name|pos
operator|.
name|column
operator|=
name|pHPDev
operator|->
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|pos
operator|.
name|line
operator|=
name|pHPDev
operator|->
name|coords
index|[
literal|1
index|]
expr_stmt|;
name|olddata
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
name|smd_$set_unit_cursor_pos
argument_list|(
literal|1
argument_list|,
name|pos
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __apollo */
name|InitPointerDeviceStruct
argument_list|(
name|pDev
argument_list|,
name|ptr_button_map
argument_list|,
name|button_count
argument_list|,
name|hpGetDeviceMotionEvents
argument_list|,
name|hpChangePointerControl
argument_list|,
name|MOTION_BUFFER_SIZE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XINPUT
else|else
block|{
name|InitFocusClassDeviceStruct
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
if|if
condition|(
name|h
operator|->
name|iob
operator|&
name|HILIOB_PIO
condition|)
name|InitProximityClassDeviceStruct
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __hpux */
name|InitValuatorClassDeviceStruct
argument_list|(
name|dev
argument_list|,
name|h
operator|->
name|ax_num
argument_list|,
name|hpGetDeviceMotionEvents
argument_list|,
literal|100
argument_list|,
operator|(
name|h
operator|->
name|flags
operator|&
name|HIL_ABSOLUTE
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|InitPtrFeedbackClassDeviceStruct
argument_list|(
name|dev
argument_list|,
name|hpChangePointerControl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
operator|(
name|u_char
operator|)
name|h
operator|->
name|ax_num
condition|;
name|i
operator|++
control|)
name|InitValuatorAxisStruct
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|InitValuatorAxisStruct
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|h
operator|->
name|size_x
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|h
operator|->
name|resx
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|h
operator|->
name|resx
argument_list|)
expr_stmt|;
name|InitValuatorAxisStruct
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|h
operator|->
name|size_y
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|h
operator|->
name|resy
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|h
operator|->
name|resy
argument_list|)
expr_stmt|;
name|dpmotionBuf
index|[
name|dev
operator|->
name|id
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|Xalloc
argument_list|(
name|mbufsiz
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dpmotionBuf
index|[
name|dev
operator|->
name|id
index|]
argument_list|,
literal|0
argument_list|,
name|mbufsiz
argument_list|)
expr_stmt|;
name|dheadmotionBuf
index|[
name|dev
operator|->
name|id
index|]
operator|=
name|dpmotionBuf
index|[
name|dev
operator|->
name|id
index|]
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|p_button_count
condition|)
name|InitButtonClassDeviceStruct
argument_list|(
name|dev
argument_list|,
name|button_count
argument_list|,
name|identity_map
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XINPUT */
break|break;
case|case
name|DEVICE_ON
case|:
name|pDev
operator|->
name|on
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|pHPDev
operator|!=
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|__hp_osf
if|if
condition|(
name|pHPDev
operator|->
name|dev_type
operator|!=
name|NULL_DEVICE
condition|)
name|AddEnabledDevice
argument_list|(
name|pHPDev
operator|->
name|file_ds
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __hp_osf */
if|if
condition|(
name|h
operator|->
name|ax_num
condition|)
name|set_scale_and_screen_change
argument_list|(
name|pHPDev
argument_list|)
expr_stmt|;
block|}
name|SetAutoRepeat
argument_list|(
name|pHPDev
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEVICE_OFF
case|:
name|pDev
operator|->
name|on
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id
operator|!=
name|inputInfo
operator|.
name|pointer
operator|->
name|id
operator|&&
name|pHPDev
operator|->
name|file_ds
operator|==
name|hpPointer
operator|->
name|file_ds
condition|)
break|break;
if|if
condition|(
name|pHPDev
operator|!=
name|NULL
operator|&&
name|pHPDev
operator|->
name|file_ds
operator|>=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|__hp_osf
name|RemoveEnabledDevice
argument_list|(
name|pHPDev
operator|->
name|file_ds
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __hp_osf */
name|SetAutoRepeat
argument_list|(
name|pHPDev
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|close_device
argument_list|(
name|pHPDev
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DEVICE_CLOSE
case|:
if|if
condition|(
name|pHPDev
operator|!=
name|NULL
operator|&&
name|pHPDev
operator|->
name|file_ds
operator|>=
literal|0
condition|)
block|{
name|SetAutoRepeat
argument_list|(
name|pHPDev
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__hp_osf
name|RemoveEnabledDevice
argument_list|(
name|pHPDev
operator|->
name|file_ds
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __hp_osf */
name|close_device
argument_list|(
name|pHPDev
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XINPUT
if|if
condition|(
name|dheadmotionBuf
index|[
name|dev
operator|->
name|id
index|]
condition|)
block|{
name|Xfree
argument_list|(
name|dheadmotionBuf
index|[
name|dev
operator|->
name|id
index|]
argument_list|)
expr_stmt|;
name|dheadmotionBuf
index|[
name|dev
operator|->
name|id
index|]
operator|=
name|NULL
expr_stmt|;
name|dpmotionBuf
index|[
name|dev
operator|->
name|id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XINPUT */
if|if
condition|(
name|dev
operator|->
name|id
operator|==
name|inputInfo
operator|.
name|pointer
operator|->
name|id
condition|)
name|close
argument_list|(
name|beeper_fd
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|Success
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * InitInput --  *	Initialize pointer and keyboard devices.  *  */
end_comment

begin_macro
name|InitInput
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|DeviceIntPtr
name|x_init_device
parameter_list|()
function_decl|;
name|int
name|CheckInput
parameter_list|()
function_decl|;
comment|/* Initialize lastEventTime.  Also used to fake an input event for        *   TimeSinceLastInputEvent() so that the screen saver timeouts work        *   correctly when all clients die (in WaitForSomething()).  --CD        */
name|x_axis
operator|=
literal|0
expr_stmt|;
name|y_axis
operator|=
literal|1
expr_stmt|;
name|axes_changed
operator|=
name|FALSE
expr_stmt|;
name|hpPointer
operator|=
name|NULL
expr_stmt|;
name|hpKeyboard
operator|=
name|NULL
expr_stmt|;
name|hptablet_extension
operator|=
name|NULL
expr_stmt|;
name|tablet_width
operator|=
literal|0
expr_stmt|;
name|otherndx
operator|=
literal|2
expr_stmt|;
name|device_ndx
operator|=
name|MAX_POSITIONS
operator|-
literal|1
expr_stmt|;
name|lastEventTime
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_DEV_TYPES
condition|;
name|i
operator|++
control|)
name|count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|__hp_osf
if|if
condition|(
operator|!
name|hil_qp
condition|)
block|{
if|if
condition|(
operator|(
name|beeper_fd
operator|=
name|open
argument_list|(
name|BEEPER_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|ErrorF
argument_list|(
literal|"Unable to open beeper device \"%s\".\n"
argument_list|,
name|BEEPER_DEVICE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPECIAL_68K_OSF
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|beeper_fd
argument_list|,
name|HILALLOCQ
argument_list|,
operator|&
name|hil_qd
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|FatalError
argument_list|(
literal|"Error allocating HIL event queue.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|hil_qp
operator|=
operator|(
name|HILQ
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|HILQ
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_FILE
operator||
name|MAP_SHARED
argument_list|,
name|beeper_fd
argument_list|,
name|hil_qd
operator|*
sizeof|sizeof
argument_list|(
name|HILQ
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|FatalError
argument_list|(
literal|"Unable to map /dev/rhil\n"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|beeper_fd
argument_list|,
name|HILALLOCQ
argument_list|,
operator|&
name|hil_qp
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|FatalError
argument_list|(
literal|"Error allocating HIL event queue.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SPECIAL_68K_OSF */
name|SetInputCheck
argument_list|(
operator|&
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|head
argument_list|,
operator|&
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|tail
argument_list|)
expr_stmt|;
block|}
comment|/* discard all the current input events  */
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|head
operator|=
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|tail
expr_stmt|;
name|AddEnabledDevice
argument_list|(
name|beeper_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __hp_osf */
name|RegisterBlockAndWakeupHandlers
argument_list|(
name|NoopDDA
argument_list|,
name|CheckInput
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|loopnum
operator|=
name|atoi
argument_list|(
name|display
argument_list|)
expr_stmt|;
name|hilpath
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ldigit
operator|=
literal|'\0'
expr_stmt|;
name|get_pointerkeys
argument_list|()
expr_stmt|;
name|fix_modifierkeys
argument_list|()
expr_stmt|;
name|init_l_devs
argument_list|()
expr_stmt|;
name|init_events_queue
argument_list|(
operator|&
name|ev_queue
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
name|init_beeper
argument_list|()
expr_stmt|;
comment|/* beeper_fd = /dev/rhil */
endif|#
directive|endif
comment|/* __hpux */
comment|/*      * Now initialize the devices as far as X is concerned.      */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_DEVICES
operator|&&
name|j
operator|<
name|MAX_LOGICAL_DEVS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|l_devs
index|[
name|j
index|]
operator|.
name|hil_header
operator|.
name|id
operator|==
literal|1
operator|||
comment|/* inaccessible device*/
operator|(
name|l_devs
index|[
name|j
index|]
operator|.
name|dev_type
operator|==
name|NULL_DEVICE
operator|&&
operator|!
operator|(
name|l_devs
index|[
name|j
index|]
operator|.
name|hpflags
operator|&
name|OPEN_THIS_DEVICE
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|l_devs
index|[
name|j
index|]
operator|.
name|file_ds
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|x_init_device
argument_list|(
operator|&
name|l_devs
index|[
name|j
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|l_devs
index|[
name|j
index|]
operator|.
name|open_cnt
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|x_init_device
argument_list|(
operator|&
name|l_devs
index|[
name|j
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/***********************************************************  *  * Perform X initialization for the device.  *  */
end_comment

begin_function
name|DeviceIntPtr
name|x_init_device
parameter_list|(
name|dev
parameter_list|,
name|start_it
parameter_list|)
name|HPInputDevice
modifier|*
name|dev
decl_stmt|;
name|Bool
name|start_it
decl_stmt|;
block|{
name|DevicePtr
name|pXDev
decl_stmt|;
name|pXDev
operator|=
name|hpAddInputDevice
argument_list|(
name|hpDeviceProc
argument_list|,
name|start_it
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|hpKeyboard
condition|)
block|{
name|RegisterKeyboardDevice
argument_list|(
name|pXDev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev_type
operator|==
name|KEYBOARD
condition|)
name|xhp_kbdid
operator|=
name|dev
operator|->
name|hil_header
operator|.
name|id
operator|-
literal|0xA0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev
operator|==
name|hpPointer
condition|)
block|{
name|RegisterPointerDevice
argument_list|(
name|pXDev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPECIAL_68K_OSF
name|miRegisterPointerDevice
argument_list|(
name|screenInfo
operator|.
name|screens
index|[
literal|0
index|]
argument_list|,
name|pXDev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dev
operator|->
name|x_type
operator|==
name|KEYBOARD
condition|)
name|InitKbdFeedbackClassDeviceStruct
argument_list|(
name|pXDev
argument_list|,
name|hpBell
argument_list|,
name|hpChangeKeyboardControl
argument_list|)
expr_stmt|;
name|screen_change_dev
operator|=
operator|(
name|DeviceIntPtr
operator|)
name|pXDev
expr_stmt|;
if|if
condition|(
name|screen_change_amt
operator|==
name|SCREEN_CHANGE_DEFAULT
condition|)
if|if
condition|(
name|dev
operator|->
name|hil_header
operator|.
name|flags
operator|&
name|HIL_ABSOLUTE
condition|)
name|screen_change_amt
operator|=
literal|0
expr_stmt|;
else|else
name|screen_change_amt
operator|=
literal|30
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XINPUT
else|else
block|{
name|RegisterOtherDevice
argument_list|(
name|pXDev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tablet_width
operator|&&
name|dev
operator|->
name|file_ds
operator|==
name|hpPointer
operator|->
name|file_ds
condition|)
block|{
name|tablet_extension_device
operator|=
operator|(
name|DeviceIntPtr
operator|)
name|pXDev
expr_stmt|;
name|hptablet_extension
operator|=
name|dev
expr_stmt|;
name|screen_change_dev
operator|=
name|tablet_extension_device
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* XINPUT */
return|return
operator|(
operator|(
name|DeviceIntPtr
operator|)
name|pXDev
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************  *  * Initialize the l_devs array of structures.  * There is one per logical input device.  *  */
end_comment

begin_decl_stmt
name|int
name|sdev_num
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_macro
name|init_l_devs
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|dev_num
init|=
literal|2
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|fname
index|[
name|MAXNAMLEN
index|]
decl_stmt|;
name|struct
name|opendevs
name|opendevs
index|[
name|MAX_LOGICAL_DEVS
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_LOGICAL_DEVS
condition|;
name|i
operator|++
control|)
block|{
name|opendevs
index|[
name|i
index|]
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|opendevs
index|[
name|i
index|]
operator|.
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
name|opendevs
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opendevs
index|[
name|i
index|]
operator|.
name|path
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_LOGICAL_DEVS
condition|;
name|i
operator|++
control|)
block|{
name|l_devs
index|[
name|i
index|]
operator|.
name|hil_header
operator|.
name|id
operator|=
literal|1
expr_stmt|;
name|l_devs
index|[
name|i
index|]
operator|.
name|hpflags
operator|=
literal|0
expr_stmt|;
name|l_devs
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|ABSOLUTE
expr_stmt|;
name|l_devs
index|[
name|i
index|]
operator|.
name|open_cnt
operator|=
literal|0
expr_stmt|;
name|l_devs
index|[
name|i
index|]
operator|.
name|file_ds
operator|=
operator|-
literal|1
expr_stmt|;
name|l_devs
index|[
name|i
index|]
operator|.
name|x_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|l_devs
index|[
name|i
index|]
operator|.
name|dev_type
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
name|l_devs
index|[
name|i
index|]
operator|.
name|repeat_rate
operator|=
name|HILER1
expr_stmt|;
endif|#
directive|endif
comment|/* __hpux */
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%sX%sdevices"
argument_list|,
name|DEF_DIRECTORY
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|dev_num
operator|=
name|device_files
argument_list|(
name|fp
argument_list|,
name|opendevs
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|compute_device_names
argument_list|(
name|opendevs
argument_list|,
name|dev_num
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
name|init_hil_devs
argument_list|(
name|opendevs
argument_list|,
name|dev_num
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __hpux */
ifdef|#
directive|ifdef
name|__apollo
name|init_apollo_devs
argument_list|(
name|opendevs
argument_list|,
name|dev_num
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __apollo */
ifndef|#
directive|ifndef
name|hp9000
comment|/*      * Check for any dynamically loaded input device drivers.      */
name|init_dynamic_devs
argument_list|(
name|opendevs
argument_list|,
name|sdev_num
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hpPointer
operator|->
name|x_type
operator|==
name|KEYBOARD
condition|)
block|{
name|hpPointer
operator|->
name|hil_header
operator|.
name|v_button_count
operator|=
literal|8
expr_stmt|;
name|hpPointer
operator|->
name|hil_header
operator|.
name|p_button_count
operator|=
literal|8
expr_stmt|;
name|hpPointer
operator|->
name|hil_header
operator|.
name|ax_num
operator|=
literal|2
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/********************************************************************  *  * Compute the names of the input devices we should use.  * If a path for the input devices has been specified, use it.  * Otherwise use /dev/hil.  * If we have multiple HIL loops (series 800), and the display number  * is between 0 and 3, use the corresponding loop.  Otherwise, search  * all loops.  *  */
end_comment

begin_macro
name|compute_device_names
argument_list|(
argument|opendevs
argument_list|,
argument|dev_num
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|opendevs
name|opendevs
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dev_num
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ndx
init|=
name|MAX_POSITIONS
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|hlen
init|=
name|strlen
argument_list|(
name|hilpath
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__hp9000s800
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__hp9000s700
argument_list|)
if|if
condition|(
name|hlen
operator|>
literal|0
operator|&&
name|isdigit
argument_list|(
name|hilpath
index|[
name|hlen
operator|-
literal|1
index|]
argument_list|)
condition|)
comment|/* hilpath ends in digit */
block|{
name|ldigit
operator|=
name|hilpath
index|[
name|hlen
operator|-
literal|1
index|]
expr_stmt|;
name|hilpath
index|[
name|hlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|loopnum
operator|>=
literal|0
operator|&&
name|loopnum
operator|<
literal|4
condition|)
comment|/* X invoked with display # */
name|ldigit
operator|=
name|display
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* __hp9000s800 */
if|if
condition|(
name|hlen
operator|>
literal|0
condition|)
name|allocated_dev_names
operator|=
name|TRUE
expr_stmt|;
else|else
name|allocated_dev_names
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_LOGICAL_DEVS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hlen
operator|>
literal|0
operator|&&
name|i
operator|<
name|MAX_POSITIONS
condition|)
block|{
if|if
condition|(
name|allocated_dev_names
operator|==
name|TRUE
condition|)
name|Xfree
argument_list|(
name|dev_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dev_names
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|Xalloc
argument_list|(
name|strlen
argument_list|(
name|hilpath
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldigit
operator|==
literal|'\0'
operator|||
name|i
operator|<
literal|7
condition|)
block|{
name|strcpy
argument_list|(
name|dev_names
index|[
name|i
index|]
argument_list|,
name|hilpath
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dev_names
index|[
name|i
index|]
argument_list|,
name|suffix
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|dev_names
index|[
name|i
index|]
operator|=
name|default_names
index|[
name|i
index|]
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__hp9000s800
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__hp9000s700
argument_list|)
if|if
condition|(
name|ldigit
operator|!=
literal|'\0'
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_POSITIONS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|7
condition|)
block|{
name|suffix
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|ldigit
expr_stmt|;
name|dev_names
index|[
name|i
index|]
index|[
literal|9
index|]
operator|=
name|ldigit
expr_stmt|;
block|}
else|else
block|{
name|dev_names
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|suffix
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* __hp9000s800 */
while|while
condition|(
operator|--
name|dev_num
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|opendevs
index|[
name|dev_num
index|]
operator|.
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_POSITIONS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|opendevs
index|[
name|dev_num
index|]
operator|.
name|path
argument_list|,
name|dev_names
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|MAX_POSITIONS
condition|)
name|strcpy
argument_list|(
name|dev_names
index|[
name|ndx
operator|--
index|]
argument_list|,
name|opendevs
index|[
name|dev_num
index|]
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_LOGICAL_DEVS
condition|;
name|i
operator|++
control|)
name|strcpy
argument_list|(
name|l_devs
index|[
name|i
index|]
operator|.
name|dev_name
argument_list|,
name|dev_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/********************************************************************  *  * Find the requested key and pointer devices.  * If no key or pointer device was named, find a default one.  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
end_if

begin_function
specifier|static
name|int
name|init_hil_devs
parameter_list|(
name|opendevs
parameter_list|,
name|numdev
parameter_list|)
name|struct
name|opendevs
name|opendevs
index|[]
decl_stmt|;
name|int
name|numdev
decl_stmt|;
block|{
name|Bool
name|OnlyOpenExplicit
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|spare
init|=
name|MAX_LOGICAL_DEVS
operator|-
literal|2
decl_stmt|;
name|HPInputDevice
modifier|*
name|d
decl_stmt|,
modifier|*
name|last_mouse
init|=
name|NULL
decl_stmt|,
modifier|*
name|last_pointer
init|=
name|NULL
decl_stmt|,
modifier|*
name|last_keyboard
init|=
name|NULL
decl_stmt|,
modifier|*
name|last_key_device
init|=
name|NULL
decl_stmt|;
comment|/*****************************************************************************  *  * Attempt to open all devices and find out what they are.  * Find out which will be the default devices.  * Count them so that we can assign names by position.  * A device that can't be opened is considered not present.  *  */
if|if
condition|(
name|opendevs
index|[
name|XKEYBOARD
index|]
operator|.
name|path
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|opendevs
index|[
name|XPOINTER
index|]
operator|.
name|path
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|OnlyOpenExplicit
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_LOGICAL_DEVS
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
operator|&
name|l_devs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|OnlyOpenExplicit
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numdev
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|opendevs
index|[
name|j
index|]
operator|.
name|path
argument_list|,
name|d
operator|->
name|dev_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|numdev
condition|)
continue|continue;
block|}
if|if
condition|(
name|open_device
argument_list|(
name|d
argument_list|)
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numdev
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|dev_type
operator|==
name|opendevs
index|[
name|j
index|]
operator|.
name|type
operator|&&
name|count
index|[
name|d
operator|->
name|dev_type
index|]
operator|==
name|opendevs
index|[
name|j
index|]
operator|.
name|pos
operator|)
operator|||
operator|(
name|opendevs
index|[
name|j
index|]
operator|.
name|type
operator|==
operator|-
literal|1
operator|&&
name|strcmp
argument_list|(
name|opendevs
index|[
name|j
index|]
operator|.
name|path
argument_list|,
name|d
operator|->
name|dev_name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|d
operator|->
name|hpflags
operator||=
name|OPEN_THIS_DEVICE
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|XKEYBOARD
operator|&&
name|hpKeyboard
operator|==
name|NULL
condition|)
name|hpKeyboard
operator|=
name|d
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|==
name|XPOINTER
operator|&&
name|hpPointer
operator|==
name|NULL
condition|)
name|hpPointer
operator|=
name|d
expr_stmt|;
else|else
name|d
operator|->
name|hpflags
operator||=
name|MERGED_DEVICE
expr_stmt|;
block|}
block|}
name|count
index|[
name|d
operator|->
name|dev_type
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dev_type
operator|==
name|MOUSE
condition|)
name|last_mouse
operator|=
name|d
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|dev_type
operator|==
name|KEYBOARD
condition|)
name|last_keyboard
operator|=
name|d
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|x_type
operator|==
name|KEYBOARD
condition|)
name|last_key_device
operator|=
name|d
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|x_type
operator|==
name|MOUSE
condition|)
name|last_pointer
operator|=
name|d
expr_stmt|;
block|}
block|}
comment|/*****************************************************************************  *  * If the user didn't pick a keyboard and pointer, assign a default.  * If present, defaults are the last keyboard and last mouse.  *  */
if|if
condition|(
name|hpKeyboard
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|last_keyboard
operator|!=
name|NULL
condition|)
name|hpKeyboard
operator|=
name|last_keyboard
expr_stmt|;
elseif|else
if|if
condition|(
name|last_key_device
operator|!=
name|NULL
condition|)
name|hpKeyboard
operator|=
name|last_key_device
expr_stmt|;
else|else
name|FatalError
argument_list|(
literal|"Couldn't find a key device - X server terminating!\n"
argument_list|)
expr_stmt|;
name|hpKeyboard
operator|->
name|hpflags
operator||=
name|OPEN_THIS_DEVICE
expr_stmt|;
name|hpKeyboard
operator|->
name|hpflags
operator|&=
operator|~
name|MERGED_DEVICE
expr_stmt|;
block|}
if|if
condition|(
name|hpPointer
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|last_mouse
operator|!=
name|NULL
condition|)
name|hpPointer
operator|=
name|last_mouse
expr_stmt|;
elseif|else
if|if
condition|(
name|last_pointer
operator|!=
name|NULL
condition|)
name|hpPointer
operator|=
name|last_pointer
expr_stmt|;
else|else
name|hpPointer
operator|=
name|hpKeyboard
expr_stmt|;
name|hpPointer
operator|->
name|hpflags
operator||=
name|OPEN_THIS_DEVICE
expr_stmt|;
name|hpPointer
operator|->
name|hpflags
operator|&=
operator|~
name|MERGED_DEVICE
expr_stmt|;
block|}
if|if
condition|(
name|hpPointer
operator|==
name|hpKeyboard
condition|)
block|{
name|hpKeyboard
operator|->
name|hpflags
operator||=
name|SECOND_LOGICAL_DEVICE
expr_stmt|;
name|l_devs
index|[
name|spare
index|]
operator|=
operator|*
name|hpKeyboard
expr_stmt|;
name|hpPointer
operator|=
operator|&
name|l_devs
index|[
name|spare
index|]
expr_stmt|;
block|}
comment|/*****************************************************************************  *  * If tablet subsetting specified and the pointer is not a tablet,  * force the last tablet (if there is one) to be the pointer.   * The tablet must also be accessible as an extension device.  *  */
if|if
condition|(
name|tablet_width
condition|)
block|{
if|if
condition|(
name|hpPointer
operator|->
name|dev_type
operator|!=
name|TABLET
condition|)
block|{
for|for
control|(
name|i
operator|=
name|MAX_LOGICAL_DEVS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|l_devs
index|[
name|i
index|]
operator|.
name|dev_type
operator|==
name|TABLET
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|hpPointer
operator|->
name|hpflags
operator|&=
operator|~
name|OPEN_THIS_DEVICE
expr_stmt|;
name|hpPointer
operator|=
operator|&
name|l_devs
index|[
name|i
index|]
expr_stmt|;
name|hpPointer
operator|->
name|hpflags
operator||=
name|OPEN_THIS_DEVICE
expr_stmt|;
name|l_devs
index|[
name|spare
index|]
operator|=
operator|*
name|hpPointer
expr_stmt|;
comment|/* will also be extension device */
name|l_devs
index|[
name|spare
index|]
operator|.
name|hpflags
operator||=
name|SECOND_LOGICAL_DEVICE
expr_stmt|;
block|}
block|}
else|else
block|{
name|l_devs
index|[
name|spare
index|]
operator|=
operator|*
name|hpPointer
expr_stmt|;
comment|/* will also be an extension device */
name|l_devs
index|[
name|spare
index|]
operator|.
name|hpflags
operator||=
name|SECOND_LOGICAL_DEVICE
expr_stmt|;
block|}
block|}
comment|/***********************************************************************  *  * Now close all the devices that X was not instructed to use.  *  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_LOGICAL_DEVS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|l_devs
index|[
name|i
index|]
operator|.
name|hpflags
operator|&
name|OPEN_THIS_DEVICE
operator|)
condition|)
name|close_device
argument_list|(
operator|&
name|l_devs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hpux */
end_comment

begin_comment
comment|/***********************************************************************  *  * Open the beeper device.  * On s800 machines, this is /dev/hilkbd#, where # is 0...3.  * On s300 and s700, this is /dev/rhil.  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
end_if

begin_macro
name|init_beeper
argument_list|()
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|__hp9000s300
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp9000s700
argument_list|)
operator|||
name|defined
argument_list|(
name|hp300
argument_list|)
if|if
condition|(
operator|(
name|beeper_fd
operator|=
name|open
argument_list|(
name|BEEPER_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|ErrorF
argument_list|(
literal|"Unable to open beeper device \"%s\".\n"
argument_list|,
name|BEEPER_DEVICE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*__hp9000s300 or __hp9000s700 */
if|#
directive|if
name|defined
argument_list|(
name|__hp9000s800
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__hp9000s700
argument_list|)
name|int
name|len
decl_stmt|;
if|if
condition|(
name|ldigit
operator|!=
literal|'\0'
condition|)
name|beeper_name
index|[
literal|11
index|]
operator|=
name|ldigit
expr_stmt|;
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|hpKeyboard
operator|->
name|dev_name
argument_list|)
expr_stmt|;
name|beeper_name
index|[
literal|11
index|]
operator|=
name|hpKeyboard
operator|->
name|dev_name
index|[
name|len
operator|-
literal|3
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|beeper_name
index|[
literal|11
index|]
operator|>=
literal|'0'
operator|&&
name|beeper_name
index|[
literal|11
index|]
operator|<
literal|'4'
operator|)
operator|&&
operator|(
name|beeper_fd
operator|=
name|open
argument_list|(
name|beeper_name
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|ErrorF
argument_list|(
literal|"Unable to open beeper device \"%s\".\n"
argument_list|,
name|beeper_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*__hp9000s800&& !__hp9000s700 */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hpux */
end_comment

begin_comment
comment|/***********************************************************************  *  * Initialize Domain input devices.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__apollo
end_ifdef

begin_function
specifier|static
name|int
name|init_apollo_devs
parameter_list|(
name|opendevs
parameter_list|,
name|numdev
parameter_list|)
name|struct
name|opendevs
name|opendevs
index|[]
decl_stmt|;
name|int
name|numdev
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|fdApollo
condition|)
name|fdApollo
operator|=
name|MakeSMDStream
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|l_devs
index|[
literal|0
index|]
operator|.
name|dev_name
argument_list|,
literal|"Apollo_internal"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|l_devs
index|[
literal|1
index|]
operator|.
name|dev_name
argument_list|,
literal|"Apollo_internal"
argument_list|)
expr_stmt|;
name|l_devs
index|[
literal|1
index|]
operator|.
name|x_type
operator|=
name|KEYBOARD
expr_stmt|;
name|l_devs
index|[
literal|1
index|]
operator|.
name|dev_type
operator|=
name|KEYBOARD
expr_stmt|;
name|l_devs
index|[
literal|1
index|]
operator|.
name|hil_header
operator|.
name|id
operator|=
literal|0xdf
expr_stmt|;
name|l_devs
index|[
literal|0
index|]
operator|.
name|hil_header
operator|.
name|num_keys
operator|=
literal|113
expr_stmt|;
name|strcpy
argument_list|(
name|l_devs
index|[
literal|1
index|]
operator|.
name|x_name
argument_list|,
literal|"FIRST_KEYBOARD"
argument_list|)
expr_stmt|;
name|l_devs
index|[
literal|1
index|]
operator|.
name|x_atom
operator|=
name|MakeAtom
argument_list|(
literal|"KEYBOARD"
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|l_devs
index|[
literal|1
index|]
operator|.
name|file_ds
operator|=
name|fdApollo
expr_stmt|;
name|l_devs
index|[
literal|0
index|]
operator|.
name|x_type
operator|=
name|MOUSE
expr_stmt|;
name|l_devs
index|[
literal|0
index|]
operator|.
name|dev_type
operator|=
name|MOUSE
expr_stmt|;
name|l_devs
index|[
literal|0
index|]
operator|.
name|hil_header
operator|.
name|id
operator|=
literal|0x68
expr_stmt|;
name|l_devs
index|[
literal|0
index|]
operator|.
name|hil_header
operator|.
name|ax_num
operator|=
literal|2
expr_stmt|;
name|l_devs
index|[
literal|0
index|]
operator|.
name|hil_header
operator|.
name|p_button_count
operator|=
literal|3
expr_stmt|;
name|l_devs
index|[
literal|0
index|]
operator|.
name|hil_header
operator|.
name|v_button_count
operator|=
literal|5
expr_stmt|;
name|l_devs
index|[
literal|0
index|]
operator|.
name|hil_header
operator|.
name|size_x
operator|=
name|screenInfo
operator|.
name|screens
index|[
literal|0
index|]
operator|->
name|width
expr_stmt|;
name|l_devs
index|[
literal|0
index|]
operator|.
name|hil_header
operator|.
name|size_y
operator|=
name|screenInfo
operator|.
name|screens
index|[
literal|0
index|]
operator|->
name|height
expr_stmt|;
name|strcpy
argument_list|(
name|l_devs
index|[
literal|0
index|]
operator|.
name|x_name
argument_list|,
literal|"FIRST_MOUSE"
argument_list|)
expr_stmt|;
name|l_devs
index|[
literal|0
index|]
operator|.
name|x_atom
operator|=
name|MakeAtom
argument_list|(
literal|"MOUSE"
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|l_devs
index|[
literal|0
index|]
operator|.
name|file_ds
operator|=
name|fdApollo
expr_stmt|;
if|if
condition|(
name|opendevs
index|[
name|XPOINTER
index|]
operator|.
name|type
operator|==
name|KEYBOARD
condition|)
block|{
name|l_devs
index|[
literal|1
index|]
operator|.
name|hpflags
operator||=
name|SECOND_LOGICAL_DEVICE
expr_stmt|;
name|l_devs
index|[
name|MAX_LOGICAL_DEVS
operator|-
literal|2
index|]
operator|=
name|l_devs
index|[
literal|1
index|]
expr_stmt|;
name|l_devs
index|[
literal|0
index|]
operator|.
name|file_ds
operator|=
operator|-
literal|1
expr_stmt|;
name|hpPointer
operator|=
operator|&
name|l_devs
index|[
name|MAX_LOGICAL_DEVS
operator|-
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hpPointer
operator|==
name|NULL
operator|||
name|open_device
argument_list|(
name|hpPointer
argument_list|)
operator|<
literal|0
condition|)
name|hpPointer
operator|=
operator|&
name|l_devs
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
name|l_devs
index|[
literal|0
index|]
operator|.
name|hil_header
operator|.
name|id
operator|=
literal|1
expr_stmt|;
name|l_devs
index|[
literal|0
index|]
operator|.
name|file_ds
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hpKeyboard
operator|==
name|NULL
operator|||
name|open_device
argument_list|(
name|hpKeyboard
argument_list|)
operator|<
literal|0
condition|)
name|hpKeyboard
operator|=
operator|&
name|l_devs
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __apollo */
end_comment

begin_comment
comment|/****************************************************************************  *  * open_device opens one of the input devices.  * The dev_name is filled in by device_files(), or is the default.  * If the open fails, it may be because the keyboard and pointer  * are the same device, and the device is already open.  *  */
end_comment

begin_macro
name|open_device
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|__apollo
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|d
operator|->
name|dev_name
argument_list|,
literal|"Apollo_internal"
argument_list|)
condition|)
name|fd
operator|=
name|fdApollo
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* __apollo */
name|fd
operator|=
name|open
argument_list|(
name|d
operator|->
name|dev_name
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
name|fd
operator|)
return|;
if|if
condition|(
name|get_device_details
argument_list|(
name|fd
argument_list|,
name|d
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|d
operator|->
name|file_ds
operator|=
name|fd
expr_stmt|;
name|BITSET
argument_list|(
name|valid_inputs
operator|.
name|input_mask
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
name|valid_inputs
operator|.
name|max_fd
condition|)
name|valid_inputs
operator|.
name|max_fd
operator|=
name|fd
expr_stmt|;
ifdef|#
directive|ifdef
name|__hp_osf
ifdef|#
directive|ifdef
name|SPECIAL_68K_OSF
if|if
condition|(
name|d
operator|->
name|dev_type
operator|!=
name|NULL_DEVICE
operator|&&
name|ioctl
argument_list|(
name|d
operator|->
name|file_ds
argument_list|,
name|HILMAPQ
argument_list|,
operator|&
name|hil_qd
argument_list|)
operator|<
literal|0
condition|)
name|FatalError
argument_list|(
literal|"HILMAPQ failed for device %s\n"
argument_list|,
name|d
operator|->
name|dev_name
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|d
operator|->
name|dev_type
operator|!=
name|NULL_DEVICE
operator|&&
name|ioctl
argument_list|(
name|d
operator|->
name|file_ds
argument_list|,
name|HILMAPQ
argument_list|,
operator|&
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|qnum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|FatalError
argument_list|(
literal|"HILMAPQ failed for device %s, file_ds=%d errno=%d\n"
argument_list|,
name|d
operator|->
name|dev_name
argument_list|,
name|d
operator|->
name|file_ds
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SPECIAL_68K_OSF */
endif|#
directive|endif
comment|/* __hp_osf */
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * Query the hil device for detailed information.  *  */
end_comment

begin_function
specifier|static
name|int
name|get_device_details
parameter_list|(
name|file_ds
parameter_list|,
name|input_dev
parameter_list|)
name|int
name|file_ds
decl_stmt|;
name|HPInputDevice
modifier|*
name|input_dev
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|dev_status
decl_stmt|;
name|u_char
name|describe
index|[
literal|11
index|]
decl_stmt|,
name|iob
decl_stmt|;
name|struct
name|hil_desc_record
modifier|*
name|hd
decl_stmt|;
name|int
name|hi_resol
init|=
literal|0
decl_stmt|;
name|int
name|lo_resol
init|=
literal|0
decl_stmt|;
name|int
name|support_it
init|=
name|TRUE
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
name|LatchKey
argument_list|(
name|input_dev
argument_list|,
name|CAPSCODE
argument_list|)
expr_stmt|;
name|input_dev
operator|->
name|led
index|[
name|NLOCK
index|]
operator|=
name|LockMask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|11
condition|;
name|i
operator|++
control|)
name|describe
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|dev_status
operator|=
name|ioctl
argument_list|(
name|file_ds
argument_list|,
name|HILID
argument_list|,
operator|&
operator|(
name|describe
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|hd
operator|=
operator|&
operator|(
name|input_dev
operator|->
name|hil_header
operator|)
expr_stmt|;
if|if
condition|(
name|dev_status
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|hp9000
name|ioctl
argument_list|(
name|file_ds
argument_list|,
name|HILIOCHPUX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hd
operator|->
name|id
operator|=
name|describe
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|id
operator|>=
literal|0xE0
condition|)
comment|/* HP98203C - not supported */
block|{
name|close
argument_list|(
name|file_ds
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|hd
operator|->
name|id
operator|>=
literal|0xA0
operator|&&
name|hd
operator|->
name|id
operator|<
literal|0xC0
condition|)
comment|/* compressed keyboard      */
block|{
name|close
argument_list|(
name|file_ds
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|hd
operator|->
name|flags
operator|=
name|describe
index|[
literal|1
index|]
expr_stmt|;
name|input_dev
operator|->
name|hpflags
operator||=
name|DATA_IS_8_BITS
expr_stmt|;
name|hd
operator|->
name|ax_num
operator|=
operator|(
name|hd
operator|->
name|flags
operator|&
name|HIL_NUM_AXES
operator|)
expr_stmt|;
comment|/* 	 * 	 * if # of axes indicate it is a positional device 	 * then gather resolution.	 	 * if 16 bits of information are reported, resolution is 	 * in counts/ cm.  In this case, convert to counts/ meter. 	 * 	 */
if|if
condition|(
name|hd
operator|->
name|ax_num
condition|)
block|{
name|lo_resol
operator|=
name|describe
index|[
literal|2
index|]
expr_stmt|;
name|hi_resol
operator|=
name|describe
index|[
literal|3
index|]
expr_stmt|;
name|hd
operator|->
name|resx
operator|=
name|hd
operator|->
name|resy
operator|=
operator|(
name|hi_resol
operator|<<
literal|8
operator|)
operator|+
name|lo_resol
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|flags
operator|&
name|HIL_16_BITS
condition|)
block|{
name|input_dev
operator|->
name|hpflags
operator||=
name|DATA_IS_16_BITS
expr_stmt|;
name|hd
operator|->
name|resx
operator|=
name|hd
operator|->
name|resy
operator|=
name|hd
operator|->
name|resx
operator|*
literal|100
expr_stmt|;
block|}
comment|/* If it is an absolute device, gather size */
if|if
condition|(
name|hd
operator|->
name|flags
operator|&
name|HIL_ABSOLUTE
condition|)
block|{
switch|switch
condition|(
name|hd
operator|->
name|ax_num
condition|)
block|{
case|case
literal|2
case|:
name|hd
operator|->
name|size_y
operator|=
operator|(
name|int
operator|)
name|describe
index|[
literal|6
index|]
operator||
operator|(
operator|(
name|int
operator|)
name|describe
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
case|case
literal|1
case|:
name|hd
operator|->
name|size_x
operator|=
operator|(
name|int
operator|)
name|describe
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|int
operator|)
name|describe
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
default|default:
break|break;
block|}
name|iob
operator|=
name|describe
index|[
literal|4
operator|+
name|hd
operator|->
name|ax_num
operator|*
literal|2
index|]
expr_stmt|;
block|}
else|else
name|iob
operator|=
name|describe
index|[
literal|4
index|]
expr_stmt|;
block|}
else|else
block|{
name|iob
operator|=
name|describe
index|[
literal|2
index|]
expr_stmt|;
name|hd
operator|->
name|resx
operator|=
name|hd
operator|->
name|resy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hd
operator|->
name|flags
operator|&
name|HIL_IOB
condition|)
name|hd
operator|->
name|iob
operator|=
name|iob
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|iob
operator|&
name|HILIOB_BUTTONS
condition|)
block|{
name|hd
operator|->
name|p_button_count
operator|=
name|hd
operator|->
name|iob
operator|&
name|HILIOB_BUTTONS
expr_stmt|;
name|hd
operator|->
name|v_button_count
operator|=
name|hd
operator|->
name|iob
operator|&
name|HILIOB_BUTTONS
expr_stmt|;
comment|/* 	    * initialize structures for emulating 3 buttons 	    * where we have 2, or 5 buttons where we have 3. 	    */
if|if
condition|(
name|hd
operator|->
name|p_button_count
operator|==
literal|2
condition|)
name|hd
operator|->
name|v_button_count
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|hd
operator|->
name|p_button_count
operator|==
literal|3
operator|||
name|hd
operator|->
name|p_button_count
operator|==
literal|4
condition|)
name|hd
operator|->
name|v_button_count
operator|=
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|hd
operator|->
name|iob
operator|&
name|HAS_LEDS
condition|)
block|{
name|hd
operator|->
name|num_leds
operator|=
name|hd
operator|->
name|iob
operator|&
name|HILIOB_NPA
expr_stmt|;
if|if
condition|(
operator|!
name|hd
operator|->
name|num_leds
condition|)
name|hd
operator|->
name|num_leds
operator|=
literal|1
expr_stmt|;
block|}
name|get_device_type
argument_list|(
name|input_dev
argument_list|,
name|hd
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hd
operator|->
name|size_x
operator|=
name|hd
operator|->
name|size_y
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|ax_num
operator|=
literal|2
expr_stmt|;
name|hd
operator|->
name|p_button_count
operator|=
literal|3
expr_stmt|;
name|hd
operator|->
name|v_button_count
operator|=
literal|3
expr_stmt|;
name|hd
operator|->
name|min_kcode
operator|=
literal|10
expr_stmt|;
name|hd
operator|->
name|max_kcode
operator|=
literal|135
expr_stmt|;
name|hd
operator|->
name|num_keys
operator|=
literal|109
expr_stmt|;
name|input_dev
operator|->
name|hil_header
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|input_dev
operator|->
name|dev_type
operator|=
name|NULL_DEVICE
expr_stmt|;
name|input_dev
operator|->
name|x_type
operator|=
name|XOTHER
expr_stmt|;
name|strcpy
argument_list|(
name|input_dev
operator|->
name|x_name
argument_list|,
literal|"FIRST_NULL"
argument_list|)
expr_stmt|;
name|support_it
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __hpux */
return|return
operator|(
name|support_it
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * This routine determines the type of the input device.  * dev_type is the actual type, x_type is what X considers it to be  * (mouse or keyboard).  * The 9-knob box and quadrature box have the same HIL id.  * But if it doesn't have 3 axes, it's not a 9-knob box.  *  */
end_comment

begin_macro
name|get_device_type
argument_list|(
argument|dev
argument_list|,
argument|id
argument_list|)
end_macro

begin_decl_stmt
name|HPInputDevice
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|dev_count
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devices
index|[
name|i
index|]
operator|.
name|dev_type
operator|!=
name|NULL_DEVICE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|id
operator|>=
name|devices
index|[
name|i
index|]
operator|.
name|lowid
operator|&&
name|id
operator|<=
name|devices
index|[
name|i
index|]
operator|.
name|highid
condition|)
block|{
if|if
condition|(
name|id
operator|==
name|NINE_KNOB_ID
operator|&&
name|dev
operator|->
name|hil_header
operator|.
name|ax_num
operator|!=
literal|3
condition|)
name|i
operator|=
name|QUAD_INDEX
expr_stmt|;
name|dev
operator|->
name|hil_header
operator|.
name|min_kcode
operator|=
name|devices
index|[
name|i
index|]
operator|.
name|min_kcode
expr_stmt|;
name|dev
operator|->
name|hil_header
operator|.
name|max_kcode
operator|=
name|devices
index|[
name|i
index|]
operator|.
name|max_kcode
expr_stmt|;
name|dev
operator|->
name|hil_header
operator|.
name|num_keys
operator|=
name|devices
index|[
name|i
index|]
operator|.
name|num_keys
expr_stmt|;
name|dev
operator|->
name|dev_type
operator|=
name|devices
index|[
name|i
index|]
operator|.
name|dev_type
expr_stmt|;
name|dev
operator|->
name|x_type
operator|=
name|devices
index|[
name|i
index|]
operator|.
name|x_type
expr_stmt|;
name|dev_count
operator|=
name|count
index|[
name|dev
operator|->
name|dev_type
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|dev
operator|->
name|x_name
argument_list|,
name|position
index|[
name|dev_count
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dev
operator|->
name|x_name
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dev
operator|->
name|x_name
argument_list|,
name|devices
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|dev
operator|->
name|x_atom
operator|=
name|MakeAtom
argument_list|(
name|devices
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|strlen
argument_list|(
name|devices
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * This routine recalculates the device x_name.  * The x_name is a string created by concatenating the device type and position.  * The position may change if a device that was previously inaccessible  * to X is made accessible.  *  */
end_comment

begin_macro
name|recalculate_x_name
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_DEV_TYPES
condition|;
name|i
operator|++
control|)
name|count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_LOGICAL_DEVS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_LOGICAL_DEVS
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|l_devs
index|[
name|j
index|]
operator|.
name|dev_name
argument_list|,
literal|"/dev/null"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|dev_names
index|[
name|i
index|]
argument_list|,
name|l_devs
index|[
name|j
index|]
operator|.
name|dev_name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|l_devs
index|[
name|j
index|]
operator|.
name|file_ds
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|l_devs
index|[
name|j
index|]
operator|.
name|hpflags
operator|&
name|SECOND_LOGICAL_DEVICE
condition|)
continue|continue;
name|get_device_type
argument_list|(
operator|&
name|l_devs
index|[
name|j
index|]
argument_list|,
name|l_devs
index|[
name|j
index|]
operator|.
name|hil_header
operator|.
name|id
argument_list|)
expr_stmt|;
name|count
index|[
name|l_devs
index|[
name|j
index|]
operator|.
name|dev_type
index|]
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|open_device
argument_list|(
operator|&
name|l_devs
index|[
name|j
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|count
index|[
name|l_devs
index|[
name|j
index|]
operator|.
name|dev_type
index|]
operator|++
expr_stmt|;
name|close_device
argument_list|(
operator|&
name|l_devs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|l_devs
index|[
name|j
index|]
operator|.
name|x_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * SetAutoRepeat (onoff)  *  Enable or disable the auto repeat feature of the specified device.  */
end_comment

begin_function
specifier|static
name|void
name|SetAutoRepeat
parameter_list|(
name|d
parameter_list|,
name|onoff
parameter_list|)
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
name|int
name|onoff
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
name|char
name|ioctl_data
index|[
literal|12
index|]
decl_stmt|;
name|int
name|state
init|=
name|HILDKR
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|hpflags
operator|&
name|IS_SERIAL_DEVICE
condition|)
return|return;
if|if
condition|(
name|onoff
condition|)
name|state
operator|=
name|d
operator|->
name|repeat_rate
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|file_ds
operator|!=
operator|-
literal|1
condition|)
block|{
name|ioctl
argument_list|(
name|d
operator|->
name|file_ds
argument_list|,
name|state
argument_list|,
name|ioctl_data
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*__hpux */
block|}
end_function

begin_comment
comment|/********************************************************************  *  * If the file "/usr/lib/X11/X[display#]devices exists, this routine   * processes it.  * It translates the strings in the file to a device type and relative  * position on the HIL.  *  */
end_comment

begin_decl_stmt
name|struct
name|opendevs
name|serial
index|[
name|MAX_DEVICES
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|device_files
parameter_list|(
name|fd
parameter_list|,
name|opendevs
parameter_list|)
name|FILE
modifier|*
name|fd
decl_stmt|;
name|struct
name|opendevs
name|opendevs
index|[]
decl_stmt|;
block|{
name|char
name|buf
index|[
name|MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|devuse
index|[
name|MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|path
index|[
name|MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|pos
index|[
name|MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|fgets
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|;
name|int
name|other
init|=
name|XOTHER
decl_stmt|;
name|int
name|sother
init|=
name|XOTHER
decl_stmt|;
name|int
name|parms
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|MAXNAMLEN
operator|+
literal|1
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|other
operator|==
name|MAX_LOGICAL_DEVS
condition|)
block|{
name|ErrorF
argument_list|(
literal|"Too many X*devices entries. Ignoring \"%s\".\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pos
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|path
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|devuse
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|parms
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s%s%s"
argument_list|,
name|pos
argument_list|,
name|path
argument_list|,
name|devuse
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
comment|/* comment, skip it */
continue|continue;
elseif|else
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
comment|/* 1 parm           */
name|parms
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|devuse
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
comment|/* 2 parms        */
name|parms
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|parms
operator|==
name|EOF
condition|)
comment|/* blank line            */
continue|continue;
elseif|else
if|if
condition|(
name|parms
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|pos
argument_list|)
condition|;
name|i
operator|++
control|)
name|pos
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|pos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pos
argument_list|,
literal|"BEGIN_DEVICE_DESCRIPTION"
argument_list|)
operator|==
literal|0
condition|)
name|parse_description
argument_list|(
name|fd
argument_list|,
name|serial
argument_list|,
operator|&
name|sother
argument_list|)
expr_stmt|;
else|else
block|{
name|ErrorF
argument_list|(
literal|"Invalid X*devices entry: \"%s\" - Entry skipped\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|parms
operator|==
literal|2
condition|)
comment|/* device name specified */
name|parse_2_parms
argument_list|(
name|pos
argument_list|,
name|path
argument_list|,
name|opendevs
argument_list|,
operator|&
name|other
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parms
operator|==
literal|3
condition|)
name|parse_3_parms
argument_list|(
name|pos
argument_list|,
name|path
argument_list|,
name|devuse
argument_list|,
name|opendevs
argument_list|,
operator|&
name|other
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|other
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************  *  * This routine is invoked when two parameters are specified.  * Either they are a device path and intended use, or a device loop path.  *  */
end_comment

begin_macro
name|parse_2_parms
argument_list|(
argument|dev
argument_list|,
argument|use
argument_list|,
argument|o
argument_list|,
argument|ondx
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|use
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|opendevs
name|o
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|ondx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|use
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|use
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|use
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|use
argument_list|,
literal|"HIL_PATH"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|hilpath
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|use
argument_list|,
literal|"POINTER"
argument_list|)
operator|==
literal|0
condition|)
name|ndx
operator|=
name|XPOINTER
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|use
argument_list|,
literal|"KEYBOARD"
argument_list|)
operator|==
literal|0
condition|)
name|ndx
operator|=
name|XKEYBOARD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|use
argument_list|,
literal|"OTHER"
argument_list|)
operator|==
literal|0
condition|)
name|ndx
operator|=
operator|(
operator|*
name|ondx
operator|)
operator|++
expr_stmt|;
else|else
block|{
name|ErrorF
argument_list|(
literal|"Bad device use \"%s\" in X*devices file - Entry skipped.\n"
argument_list|,
name|use
argument_list|)
expr_stmt|;
return|return;
block|}
name|o
index|[
name|ndx
index|]
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|o
index|[
name|ndx
index|]
operator|.
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|o
index|[
name|ndx
index|]
operator|.
name|path
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***********************************************************************  *  * This routine is invoked when three parameters are specified.  * They are a position, a device type, and its intended use.  *  */
end_comment

begin_macro
name|parse_3_parms
argument_list|(
argument|pos
argument_list|,
argument|name
argument_list|,
argument|use
argument_list|,
argument|o
argument_list|,
argument|ondx
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|use
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|opendevs
name|o
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|ondx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|ndx
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|pos
argument_list|)
condition|;
name|i
operator|++
control|)
name|pos
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|pos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|use
argument_list|)
condition|;
name|i
operator|++
control|)
name|use
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|use
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|use
argument_list|,
literal|"POINTER"
argument_list|)
operator|==
literal|0
condition|)
name|ndx
operator|=
name|XPOINTER
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|use
argument_list|,
literal|"KEYBOARD"
argument_list|)
operator|==
literal|0
condition|)
name|ndx
operator|=
name|XKEYBOARD
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|use
argument_list|,
literal|"OTHER"
argument_list|)
operator|==
literal|0
condition|)
name|ndx
operator|=
operator|*
name|ondx
expr_stmt|;
else|else
block|{
name|ErrorF
argument_list|(
literal|"Bad device use \"%s\" in X*devices file - Entry skipped.\n"
argument_list|,
name|use
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_POSITIONS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|position
index|[
name|i
index|]
argument_list|,
name|pos
argument_list|)
operator|==
literal|0
condition|)
block|{
name|o
index|[
name|ndx
index|]
operator|.
name|pos
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|MAX_POSITIONS
condition|)
comment|/* failed, skip to next */
block|{
name|ErrorF
argument_list|(
literal|"Bad ordinal \"%s\" in X*devices file - Entry skipped.\n"
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|name
argument_list|)
condition|;
name|i
operator|++
control|)
name|name
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_DEV_TYPES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|devices
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|o
index|[
name|ndx
index|]
operator|.
name|type
operator|=
name|devices
index|[
name|i
index|]
operator|.
name|dev_type
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|MAX_DEV_TYPES
condition|)
comment|/* failed, skip to next */
block|{
name|ErrorF
argument_list|(
literal|"Bad device type \"%s\" in X*devices file - Entry skipped.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ndx
operator|==
operator|*
name|ondx
condition|)
operator|(
operator|*
name|ondx
operator|)
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/********************************************************************  *  *  *  *  */
end_comment

begin_macro
name|parse_description
argument_list|(
argument|fd
argument_list|,
argument|o
argument_list|,
argument|ondx
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|opendevs
name|o
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|ondx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ndx
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
name|ubuf
index|[
literal|256
index|]
decl_stmt|,
name|name
index|[
literal|256
index|]
decl_stmt|,
name|uname
index|[
literal|256
index|]
decl_stmt|,
name|path
index|[
literal|256
index|]
decl_stmt|,
name|var
index|[
literal|64
index|]
decl_stmt|,
name|use
index|[
literal|64
index|]
decl_stmt|,
name|entry
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|fgets
parameter_list|()
function_decl|;
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|entry
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|ubuf
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|ubuf
argument_list|,
literal|"PATH %s"
argument_list|,
name|var
argument_list|)
operator|==
literal|1
condition|)
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|var
argument_list|,
name|path
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|ubuf
argument_list|,
literal|"NAME %s"
argument_list|,
name|uname
argument_list|)
operator|==
literal|1
condition|)
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|var
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|ubuf
argument_list|,
literal|"ENTRYPOINT %s"
argument_list|,
name|var
argument_list|)
operator|==
literal|1
condition|)
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|var
argument_list|,
name|entry
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|ubuf
argument_list|,
literal|"USE %s"
argument_list|,
name|use
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|use
argument_list|,
literal|"POINTER"
argument_list|)
condition|)
name|ndx
operator|=
name|XPOINTER
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|use
argument_list|,
literal|"KEYBOARD"
argument_list|)
condition|)
name|ndx
operator|=
name|XKEYBOARD
expr_stmt|;
else|else
name|ndx
operator|=
operator|(
operator|*
name|ondx
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|ubuf
argument_list|,
literal|" %s"
argument_list|,
name|var
argument_list|)
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"END_DEVICE_DESCRIPTION"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|device_ndx
operator|<
literal|0
condition|)
block|{
name|ErrorF
argument_list|(
literal|"Too many devices in X*devices file - entry skipped.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ndx
operator|!=
operator|-
literal|1
operator|&&
name|path
condition|)
block|{
name|o
index|[
name|ndx
index|]
operator|.
name|type
operator|=
literal|99
expr_stmt|;
name|strcpy
argument_list|(
name|o
index|[
name|ndx
index|]
operator|.
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|o
index|[
name|ndx
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
index|[
literal|0
index|]
condition|)
name|strcpy
argument_list|(
name|o
index|[
name|ndx
index|]
operator|.
name|entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
else|else
block|{
name|len
operator|=
name|strcspn
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|o
index|[
name|ndx
index|]
operator|.
name|entry
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|o
index|[
name|ndx
index|]
operator|.
name|entry
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|o
index|[
name|ndx
index|]
operator|.
name|entry
argument_list|,
literal|"_Init"
argument_list|)
expr_stmt|;
block|}
name|sdev_num
operator|++
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|ErrorF
argument_list|(
literal|"Invalid line in device description - ignored.\n"
argument_list|)
expr_stmt|;
name|ErrorF
argument_list|(
literal|"line was: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|ErrorF
argument_list|(
literal|"No END_DESCRIPTION line in X*devices file - description skipped.\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/********************************************************************  *  * get_codes()  * Used to assign codes to keys used to move the pointer.  * Also to assign numbers to the amount to move the pointer.  * This routine uses the index into the file to determine the keycode.  * The down keycode is (index * 2), the up keycode is that plus 1.  * If the type is NUMBER, the key string is assumed to be an ascii  * representation of a number.  * This is used as the increment to move the pointer.  *  */
end_comment

begin_define
define|#
directive|define
name|MAX_HIL_KEYS
value|128
end_define

begin_expr_stmt
specifier|static
name|get_codes
argument_list|(
argument|key
argument_list|,
argument|code
argument_list|,
argument|type
argument_list|)
name|char
operator|*
name|key
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|key
argument_list|)
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|key
operator|+
name|i
operator|)
operator|=
name|toupper
argument_list|(
operator|*
operator|(
name|key
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|UCHAR_NUMBER
operator|||
name|type
operator|==
name|USHORT_NUMBER
operator|||
name|type
operator|==
name|UINT_NUMBER
condition|)
block|{
operator|*
name|code
operator|=
name|atoi
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|STRING
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_STRINGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|strings
index|[
name|i
index|]
operator|.
name|string
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|code
operator|=
name|strings
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_HIL_KEYS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|keyset1
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|code
operator|=
name|i
operator|+
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_HIL_KEYS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|newkeyset1
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|code
operator|=
name|i
operator|+
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* __hpux */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/********************************************************************  *  * get_vars()  * get the address of variables to contain keycodes for pointer functions.  *  */
end_comment

begin_expr_stmt
specifier|static
name|get_vars
argument_list|(
argument|func
argument_list|,
argument|codevar
argument_list|,
argument|index
argument_list|)
name|char
operator|*
name|func
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_char
modifier|*
modifier|*
name|codevar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|index
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|func
argument_list|)
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|func
operator|+
name|i
operator|)
operator|=
name|toupper
argument_list|(
operator|*
operator|(
name|func
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_POINTER_FUNCS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|func
argument_list|,
name|pointerfunc
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|codevar
operator|=
name|pointerfunc
index|[
name|i
index|]
operator|.
name|code
expr_stmt|;
operator|*
name|index
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/********************************************************************  *  * get_pointerkeys().  * This routine provides the ability to configure keyboard keys to   * move the pointer and act like buttons on the pointer device.  * The file processed is the X*pointerkeys file, which consists  * of pairs.  The form is:  *  * 	function	key, modifier, or value  *  * Look at the pointerfunc table in x_hilinit.h to understand this code.  * There are 3 types of assignment done:  * 	1). keys - have both a down and an up code to assign.  *	2). modifiers - are a bit position in a mask.  *	3). values - are a single integer number.  * Possible errors:  *	1). only 1 of the pair was specified.  *	2). an invalid function was specified.  *	3). an invalid key or modifier was specified.  */
end_comment

begin_macro
name|get_pointerkeys
argument_list|()
end_macro

begin_block
block|{
name|char
name|fname
index|[
name|MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|cret
decl_stmt|;
name|int
name|vret
decl_stmt|;
name|int
name|ret2
decl_stmt|;
name|int
name|index
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|function
index|[
name|MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|key
index|[
name|MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|fgets
parameter_list|()
function_decl|;
name|int
name|code
decl_stmt|;
union|union
block|{
name|u_char
modifier|*
name|cptr
decl_stmt|;
name|u_short
modifier|*
name|sptr
decl_stmt|;
name|u_int
modifier|*
name|iptr
decl_stmt|;
block|}
name|codevar
union|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%sX%spointerkeys"
argument_list|,
name|DEF_DIRECTORY
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|MAXNAMLEN
operator|+
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ret2
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s%s"
argument_list|,
name|function
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* comments begin with a '#'.  Skip them. */
if|if
condition|(
name|function
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
comment|/* comment, skip it 	*/
continue|continue;
if|if
condition|(
name|ret2
operator|==
literal|2
condition|)
comment|/* error if< 2 items 	*/
block|{
name|vret
operator|=
name|get_vars
argument_list|(
name|function
argument_list|,
operator|&
name|codevar
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|vret
operator|<
literal|0
condition|)
comment|/* invalid function     */
block|{
name|ErrorF
argument_list|(
literal|"Bad function \"%s\" skipped in X*pointerkeys file.\n"
argument_list|,
name|function
argument_list|)
expr_stmt|;
continue|continue;
comment|/* error - skip this one*/
block|}
name|cret
operator|=
name|get_codes
argument_list|(
name|key
argument_list|,
operator|&
name|code
argument_list|,
name|pointerfunc
index|[
name|index
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|cret
operator|<
literal|0
operator|&&
comment|/* not a key or modifier*/
name|pointerfunc
index|[
name|index
index|]
operator|.
name|type
operator|==
name|KEY
condition|)
comment|/* but must be  */
block|{
name|ErrorF
argument_list|(
literal|"Bad key name \"%s\" skipped in X*pointerkeys file.\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
continue|continue;
comment|/* error - skip this one*/
block|}
if|if
condition|(
name|pointerfunc
index|[
name|index
index|]
operator|.
name|type
operator|==
name|MODIFIER
condition|)
comment|/* modifier - compute bit*/
operator|*
name|codevar
operator|.
name|cptr
operator|=
name|code
operator|-
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|pointerfunc
index|[
name|index
index|]
operator|.
name|type
operator|==
name|UINT_NUMBER
condition|)
operator|*
name|codevar
operator|.
name|iptr
operator|=
name|code
expr_stmt|;
comment|/* code for 16-bit number */
elseif|else
if|if
condition|(
name|pointerfunc
index|[
name|index
index|]
operator|.
name|type
operator|==
name|USHORT_NUMBER
condition|)
operator|*
name|codevar
operator|.
name|sptr
operator|=
name|code
expr_stmt|;
comment|/* code for 16-bit number */
else|else
operator|*
name|codevar
operator|.
name|cptr
operator|=
name|code
expr_stmt|;
comment|/* code for 8-bit key */
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* fgets adds a newline */
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|ErrorF
argument_list|(
literal|"Bad entry \"%s\" skipped in X*pointerkeys file.\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * TimeSinceLastInputEvent()  * - aparently returns time in miliseconds since last input event  *  */
end_comment

begin_macro
name|TimeSinceLastInputEvent
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|lastEventTime
operator|==
literal|0
condition|)
name|lastEventTime
operator|=
name|GetTimeInMillis
argument_list|()
expr_stmt|;
return|return
name|GetTimeInMillis
argument_list|()
operator|-
name|lastEventTime
return|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * hpAddInputDevice(deviceProc, autoStart, pHPDev)  * create an X input device, then assign pHPDev to it's devicePrivate field.  *  */
end_comment

begin_function
specifier|static
name|DevicePtr
name|hpAddInputDevice
parameter_list|(
name|deviceProc
parameter_list|,
name|autoStart
parameter_list|,
name|pHPDev
parameter_list|)
name|DeviceProc
name|deviceProc
decl_stmt|;
name|Bool
name|autoStart
decl_stmt|;
name|HPInputDevice
modifier|*
name|pHPDev
decl_stmt|;
block|{
name|DevicePtr
name|pXDev
decl_stmt|;
if|if
condition|(
operator|(
name|pXDev
operator|=
name|AddInputDevice
argument_list|(
name|deviceProc
argument_list|,
name|autoStart
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FatalError
argument_list|(
literal|"Too many input devices - X server terminating!\n"
argument_list|)
expr_stmt|;
name|pHPDev
operator|->
name|dev_id
operator|=
operator|(
operator|(
name|DeviceIntPtr
operator|)
name|pXDev
operator|)
operator|->
name|id
expr_stmt|;
ifdef|#
directive|ifdef
name|XINPUT
if|if
condition|(
name|pHPDev
operator|==
name|hpPointer
condition|)
block|{
ifdef|#
directive|ifdef
name|NOT_DONE
name|hp_device_ids
index|[
name|pHPDev
operator|->
name|dev_id
index|]
operator|=
name|XPOINTER
expr_stmt|;
endif|#
directive|endif
name|x_device_ids
index|[
name|XPOINTER
index|]
operator|=
name|pHPDev
operator|->
name|dev_id
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pHPDev
operator|==
name|hpKeyboard
condition|)
block|{
ifdef|#
directive|ifdef
name|NOT_DONE
name|hp_device_ids
index|[
name|pHPDev
operator|->
name|dev_id
index|]
operator|=
name|XKEYBOARD
expr_stmt|;
endif|#
directive|endif
name|x_device_ids
index|[
name|XKEYBOARD
index|]
operator|=
name|pHPDev
operator|->
name|dev_id
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NOT_DONE
name|hp_device_ids
index|[
name|pHPDev
operator|->
name|dev_id
index|]
operator|=
name|otherndx
expr_stmt|;
endif|#
directive|endif
name|x_device_ids
index|[
name|otherndx
operator|++
index|]
operator|=
name|pHPDev
operator|->
name|dev_id
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XINPUT */
name|pXDev
operator|->
name|devicePrivate
operator|=
operator|(
name|pointer
operator|)
name|pHPDev
expr_stmt|;
return|return
name|pXDev
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * We allow any keycode to be specified as a modifer, Even one that can't  * be generated by our keyboard.  *  */
end_comment

begin_macro
name|LegalModifier
argument_list|(
argument|key
argument_list|,
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|BYTE
name|key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DeviceIntPtr
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * close_device closes one of the input devices.  *  */
end_comment

begin_macro
name|close_device
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BITCLEAR
argument_list|(
name|valid_inputs
operator|.
name|input_mask
argument_list|,
name|d
operator|->
name|file_ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|file_ds
operator|==
name|valid_inputs
operator|.
name|max_fd
condition|)
block|{
name|valid_inputs
operator|.
name|max_fd
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__apollo
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|d
operator|->
name|dev_name
argument_list|,
literal|"Apollo_internal"
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* __apollo */
ifdef|#
directive|ifdef
name|__hp_osf
if|if
condition|(
name|d
operator|->
name|file_ds
operator|!=
operator|-
literal|1
condition|)
name|ioctl
argument_list|(
name|d
operator|->
name|file_ds
argument_list|,
name|HILUNMAPQ
argument_list|,
operator|&
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|qnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ANYSET
argument_list|(
name|valid_inputs
operator|.
name|input_mask
argument_list|)
condition|)
block|{
name|RemoveEnabledDevice
argument_list|(
name|beeper_fd
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|beeper_fd
argument_list|,
name|HILFREEQ
argument_list|,
operator|&
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|qnum
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|beeper_fd
argument_list|)
expr_stmt|;
name|hil_qp
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __hp_osf */
name|close
argument_list|(
name|d
operator|->
name|file_ds
argument_list|)
expr_stmt|;
name|d
operator|->
name|file_ds
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*****************************  *  * init_events_queue (queue)  *   */
end_comment

begin_macro
name|init_events_queue
argument_list|(
argument|queue
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|x11EventQueue
modifier|*
name|queue
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|queue
operator|->
name|events
operator|=
name|events_array
expr_stmt|;
name|queue
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|queue
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
name|queue
operator|->
name|size
operator|=
name|MAX_EVENTS
expr_stmt|;
name|events_queue
operator|=
name|queue
expr_stmt|;
block|}
end_block

begin_comment
comment|/*****************************************************************  *  * allocate_event ()  *	allocates the next available event to the caller and increments  *	the tail pointer of the events queue; sets queue_events_free as needed.  *  */
end_comment

begin_function
name|xHPEvent
modifier|*
name|allocate_event
parameter_list|()
block|{
name|xHPEvent
modifier|*
name|event
decl_stmt|;
name|event
operator|=
operator|&
operator|(
operator|(
name|events_queue
operator|->
name|events
operator|)
index|[
name|events_queue
operator|->
name|tail
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|events_queue
operator|->
name|tail
operator|==
name|WR_EVENTS
condition|)
name|events_queue
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
else|else
operator|(
name|events_queue
operator|->
name|tail
operator|)
operator|++
expr_stmt|;
name|queue_events_free
operator|--
expr_stmt|;
if|if
condition|(
name|queue_events_free
operator|==
literal|0
condition|)
name|ErrorF
argument_list|(
literal|"Server Internal events queue is full!!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|event
operator|)
return|;
block|}
end_function

begin_macro
name|deallocate_event
argument_list|(
argument|ev
argument_list|)
end_macro

begin_decl_stmt
name|xHPEvent
modifier|*
name|ev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|xHPEvent
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|tail
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|first
decl_stmt|;
name|tail
operator|=
operator|&
operator|(
operator|(
name|events_queue
operator|->
name|events
operator|)
index|[
name|events_queue
operator|->
name|tail
index|]
operator|)
expr_stmt|;
name|last
operator|=
operator|&
operator|(
operator|(
name|events_queue
operator|->
name|events
operator|)
index|[
name|WR_EVENTS
index|]
operator|)
expr_stmt|;
name|first
operator|=
operator|&
operator|(
operator|(
name|events_queue
operator|->
name|events
operator|)
index|[
literal|0
index|]
operator|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|ev
init|;
name|tmp
operator|!=
name|tail
condition|;
name|tmp
operator|++
control|)
if|if
condition|(
name|tmp
operator|==
name|last
condition|)
block|{
operator|*
name|tmp
operator|=
operator|*
name|first
expr_stmt|;
name|tmp
operator|=
name|first
operator|-
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|tmp
operator|=
operator|*
operator|(
name|tmp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|events_queue
operator|->
name|tail
operator|==
literal|0
condition|)
name|events_queue
operator|->
name|tail
operator|=
name|WR_EVENTS
expr_stmt|;
else|else
name|events_queue
operator|->
name|tail
operator|--
expr_stmt|;
name|queue_events_free
operator|++
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|int
name|apLeave_X
decl_stmt|,
name|apReenter_X
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  in hp/apollo/apInit2.c */
end_comment

begin_macro
name|CheckInput
argument_list|(
argument|data
argument_list|,
argument|result
argument_list|,
argument|LastSelectMask
argument_list|)
end_macro

begin_decl_stmt
name|pointer
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|LastSelectMask
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|devicesReadable
index|[
name|mskcnt
index|]
decl_stmt|;
specifier|extern
name|long
name|EnabledDevices
index|[]
decl_stmt|;
specifier|extern
name|Bool
name|display_borrowed
decl_stmt|;
comment|/* in x_hil.c */
if|if
condition|(
name|result
operator|<=
literal|0
condition|)
return|return;
name|MASKANDSETBITS
argument_list|(
name|devicesReadable
argument_list|,
name|LastSelectMask
argument_list|,
name|EnabledDevices
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__apollo
if|if
condition|(
name|apReenter_X
condition|)
name|apReturnFromDM
argument_list|()
expr_stmt|;
if|if
condition|(
name|display_borrowed
condition|)
return|return;
while|while
condition|(
name|GetSMDEvent
argument_list|(
name|TRUE
argument_list|,
name|NULL
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|apLeave_X
condition|)
name|apReturnToDM
argument_list|()
expr_stmt|;
name|BITCLEAR
argument_list|(
name|devicesReadable
argument_list|,
name|fdApollo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __apollo */
ifdef|#
directive|ifdef
name|__hp_osf
name|BITCLEAR
argument_list|(
name|devicesReadable
argument_list|,
name|beeper_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __hp_osf */
if|if
condition|(
name|ANYSET
argument_list|(
name|devicesReadable
argument_list|)
condition|)
name|store_inputs
argument_list|(
name|devicesReadable
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|XINPUT
end_ifdef

begin_macro
name|AddOtherInputDevices
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|HPInputDevice
modifier|*
name|hp
decl_stmt|,
modifier|*
name|tmphp
decl_stmt|;
name|DeviceIntPtr
name|dev
decl_stmt|;
name|Bool
name|found
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|hp
operator|=
name|l_devs
init|;
name|i
operator|<
name|MAX_LOGICAL_DEVS
condition|;
name|hp
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|found
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|dev
operator|=
name|inputInfo
operator|.
name|devices
init|;
name|dev
condition|;
name|dev
operator|=
name|dev
operator|->
name|next
control|)
block|{
name|tmphp
operator|=
name|GET_HPINPUTDEVICE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|tmphp
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|dev
operator|=
name|inputInfo
operator|.
name|off_devices
init|;
name|found
operator|==
name|FALSE
operator|&&
name|dev
condition|;
name|dev
operator|=
name|dev
operator|->
name|next
control|)
block|{
name|tmphp
operator|=
name|GET_HPINPUTDEVICE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|tmphp
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
operator|==
name|FALSE
operator|&&
name|hp
operator|->
name|x_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|strcmp
argument_list|(
name|hp
operator|->
name|dev_name
argument_list|,
literal|"/dev/null"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|dev
operator|=
name|x_init_device
argument_list|(
name|hp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|dev
operator|->
name|inited
operator|=
operator|(
call|(
modifier|*
name|dev
operator|->
name|deviceProc
call|)
argument_list|(
name|dev
argument_list|,
name|DEVICE_INIT
argument_list|)
operator|==
name|Success
operator|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|ChangeKeyboardDevice
argument_list|(
argument|old_dev
argument_list|,
argument|new_dev
argument_list|)
end_macro

begin_decl_stmt
name|DeviceIntPtr
name|old_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DeviceIntPtr
name|new_dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CARD8
name|tmp
decl_stmt|;
name|HPInputDevice
modifier|*
name|old
init|=
name|GET_HPINPUTDEVICE
argument_list|(
name|old_dev
argument_list|)
decl_stmt|;
name|HPInputDevice
modifier|*
name|new
init|=
name|GET_HPINPUTDEVICE
argument_list|(
name|new_dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|->
name|hpflags
operator|&
name|OPEN_THIS_DEVICE
condition|)
block|{
name|old
operator|->
name|open_cnt
operator|--
expr_stmt|;
name|old
operator|->
name|hpflags
operator|&=
operator|~
name|OPEN_THIS_DEVICE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOT_DONE
name|tmp
operator|=
name|hp_device_ids
index|[
name|new_dev
operator|->
name|id
index|]
expr_stmt|;
name|hp_device_ids
index|[
name|new_dev
operator|->
name|id
index|]
operator|=
name|XKEYBOARD
expr_stmt|;
name|hp_device_ids
index|[
name|old_dev
operator|->
name|id
index|]
operator|=
name|tmp
expr_stmt|;
endif|#
directive|endif
name|x_device_ids
index|[
name|XKEYBOARD
index|]
operator|=
name|new_dev
operator|->
name|id
expr_stmt|;
name|x_device_ids
index|[
name|tmp
index|]
operator|=
name|old
operator|->
name|dev_id
expr_stmt|;
name|hpKeyboard
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|Success
operator|)
return|;
block|}
end_block

begin_macro
name|ChangePointerDevice
argument_list|(
argument|old_dev
argument_list|,
argument|new_dev
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|DeviceIntPtr
name|old_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DeviceIntPtr
name|new_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|XID
name|tmp
decl_stmt|;
name|HPInputDevice
modifier|*
name|old
init|=
name|GET_HPINPUTDEVICE
argument_list|(
name|old_dev
argument_list|)
decl_stmt|;
name|HPInputDevice
modifier|*
name|new
init|=
name|GET_HPINPUTDEVICE
argument_list|(
name|new_dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_dev
operator|==
name|tablet_extension_device
condition|)
return|return
operator|(
name|BadDevice
operator|)
return|;
name|x_axis
operator|=
name|x
expr_stmt|;
name|y_axis
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|x_axis
operator|!=
literal|0
operator|||
name|y_axis
operator|!=
literal|1
condition|)
name|axes_changed
operator|=
name|TRUE
expr_stmt|;
else|else
name|axes_changed
operator|=
name|FALSE
expr_stmt|;
name|new
operator|->
name|coords
index|[
literal|0
index|]
operator|=
name|old
operator|->
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|new
operator|->
name|coords
index|[
literal|1
index|]
operator|=
name|old
operator|->
name|coords
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|hpflags
operator|&
name|OPEN_THIS_DEVICE
condition|)
block|{
name|old
operator|->
name|open_cnt
operator|--
expr_stmt|;
name|old
operator|->
name|hpflags
operator|&=
operator|~
name|OPEN_THIS_DEVICE
expr_stmt|;
block|}
name|screen_change_dev
operator|=
name|new_dev
expr_stmt|;
ifdef|#
directive|ifdef
name|NOT_DONE
name|tmp
operator|=
name|hp_device_ids
index|[
name|new_dev
operator|->
name|id
index|]
expr_stmt|;
name|hp_device_ids
index|[
name|new_dev
operator|->
name|id
index|]
operator|=
name|XPOINTER
expr_stmt|;
name|hp_device_ids
index|[
name|old_dev
operator|->
name|id
index|]
operator|=
name|tmp
expr_stmt|;
endif|#
directive|endif
name|x_device_ids
index|[
name|XPOINTER
index|]
operator|=
name|new_dev
operator|->
name|id
expr_stmt|;
name|x_device_ids
index|[
name|tmp
index|]
operator|=
name|old
operator|->
name|dev_id
expr_stmt|;
name|hpPointer
operator|=
name|new
expr_stmt|;
ifdef|#
directive|ifdef
name|__apollo
block|{
name|smd_$pos_t
name|pos
decl_stmt|;
name|pos
operator|.
name|column
operator|=
name|hpPointer
operator|->
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|pos
operator|.
name|line
operator|=
name|hpPointer
operator|->
name|coords
index|[
literal|1
index|]
expr_stmt|;
name|smd_$set_unit_cursor_pos
argument_list|(
literal|1
argument_list|,
name|pos
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __apollo */
name|InitFocusClassDeviceStruct
argument_list|(
name|old_dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|Success
operator|)
return|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * Turn on a non-standard device.  *  */
end_comment

begin_macro
name|OpenInputDevice
argument_list|(
argument|dev
argument_list|,
argument|client
argument_list|,
argument|status
argument_list|)
end_macro

begin_decl_stmt
name|DeviceIntPtr
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ClientPtr
name|client
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|status
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|mode
decl_stmt|;
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
name|DeviceClientsPtr
name|tmp
decl_stmt|;
if|if
condition|(
operator|*
name|status
operator|!=
name|Success
condition|)
comment|/* kludge - if not Success, */
name|mode
operator|=
operator|(
operator|*
name|status
operator|>>
literal|8
operator|)
expr_stmt|;
comment|/* called from HPSetInputDevice */
else|else
comment|/* mode hidden in 2nd byte	*/
name|mode
operator|=
name|DEVICE_EVENTS
operator||
name|ON
expr_stmt|;
operator|*
name|status
operator|=
name|Success
expr_stmt|;
name|d
operator|=
name|GET_HPINPUTDEVICE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|file_ds
operator|==
operator|-
literal|1
condition|)
comment|/* device not yet open   */
block|{
if|if
condition|(
name|open_device
argument_list|(
name|d
argument_list|)
operator|<
literal|0
condition|)
comment|/* couldn't open device  */
block|{
operator|*
name|status
operator|=
name|BadDevice
expr_stmt|;
return|return;
block|}
name|recalculate_x_name
argument_list|()
expr_stmt|;
comment|/* recalculate names	*/
block|}
else|else
block|{
for|for
control|(
name|tmp
operator|=
operator|(
name|DeviceClientsPtr
operator|)
name|d
operator|->
name|clients
init|;
name|tmp
operator|!=
name|NULL
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
name|tmp
operator|->
name|mode
operator|!=
name|mode
condition|)
block|{
operator|*
name|status
operator|=
name|BadMode
expr_stmt|;
return|return;
block|}
block|}
name|SetInputDevice
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|dev
operator|->
name|startup
operator|=
literal|1
expr_stmt|;
name|RecordOpenRequest
argument_list|(
name|client
argument_list|,
name|d
argument_list|,
name|dev
operator|->
name|id
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***********************************************************************  *  * Record a successful request from a client to open an input device.  *  */
end_comment

begin_function
specifier|static
name|void
name|RecordOpenRequest
parameter_list|(
name|client
parameter_list|,
name|d
parameter_list|,
name|id
parameter_list|,
name|token
parameter_list|)
specifier|register
name|ClientPtr
name|client
decl_stmt|;
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
name|CARD8
name|id
decl_stmt|;
name|int
name|token
decl_stmt|;
block|{
name|DeviceClientsPtr
name|tmp
decl_stmt|;
name|DeviceClientsPtr
name|new_client
decl_stmt|;
name|d
operator|->
name|open_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|clients
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|tmp
operator|=
operator|(
name|DeviceClientsPtr
operator|)
name|d
operator|->
name|clients
init|;
name|tmp
operator|!=
name|NULL
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
name|tmp
operator|->
name|client
operator|==
name|client
condition|)
block|{
name|tmp
operator|->
name|count
operator|++
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|tmp
operator|->
name|next
operator|==
name|NULL
condition|)
break|break;
name|new_client
operator|=
operator|(
name|DeviceClients
operator|*
operator|)
name|Xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DeviceClients
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|new_client
expr_stmt|;
block|}
else|else
block|{
name|new_client
operator|=
operator|(
name|DeviceClients
operator|*
operator|)
name|Xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DeviceClients
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|clients
operator|=
name|new_client
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_client
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|DeviceClients
argument_list|)
argument_list|)
expr_stmt|;
name|new_client
operator|->
name|resource
operator|=
name|FakeClientID
argument_list|(
name|client
operator|->
name|index
argument_list|)
expr_stmt|;
name|new_client
operator|->
name|client
operator|=
name|client
expr_stmt|;
name|new_client
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new_client
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|new_client
operator|->
name|mode
operator|=
name|token
expr_stmt|;
name|AddResource
argument_list|(
name|new_client
operator|->
name|resource
argument_list|,
name|HPType
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***********************************************************************  *  * Turn off a device because a client died.  * Also called when a client closes a device.  *  */
end_comment

begin_function
name|int
name|HPShutDownDevice
parameter_list|(
name|deviceid
parameter_list|,
name|clientid
parameter_list|)
name|CARD8
name|deviceid
decl_stmt|;
name|int
name|clientid
decl_stmt|;
block|{
name|DeviceIntPtr
name|dev
init|=
name|NULL
decl_stmt|;
name|DeviceClientsPtr
name|tmp
decl_stmt|;
name|DeviceClientsPtr
name|save
decl_stmt|;
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|deviceid
operator|==
name|inputInfo
operator|.
name|pointer
operator|->
name|id
condition|)
name|d
operator|=
name|hpPointer
expr_stmt|;
elseif|else
if|if
condition|(
name|deviceid
operator|==
name|inputInfo
operator|.
name|keyboard
operator|->
name|id
condition|)
name|d
operator|=
name|hpKeyboard
expr_stmt|;
else|else
block|{
name|dev
operator|=
name|LookupDeviceIntRec
argument_list|(
name|deviceid
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return;
name|d
operator|=
name|GET_HPINPUTDEVICE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|clients
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
operator|(
name|DeviceClientsPtr
operator|)
name|d
operator|->
name|clients
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|resource
operator|==
name|clientid
condition|)
block|{
name|d
operator|->
name|open_cnt
operator|-=
name|tmp
operator|->
name|count
expr_stmt|;
name|d
operator|->
name|clients
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|Xfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|save
operator|=
name|tmp
operator|,
name|tmp
operator|=
name|tmp
operator|->
name|next
init|;
name|tmp
operator|!=
name|NULL
condition|;
name|save
operator|=
name|tmp
operator|,
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tmp
operator|->
name|resource
operator|==
name|clientid
condition|)
block|{
name|d
operator|->
name|open_cnt
operator|-=
name|tmp
operator|->
name|count
expr_stmt|;
name|save
operator|->
name|next
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|Xfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|clients
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dev
operator|&&
name|d
operator|->
name|open_cnt
operator|==
literal|0
condition|)
name|DisableDevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
block|{
name|d
operator|->
name|mode
operator|=
name|ABSOLUTE
expr_stmt|;
name|d
operator|->
name|hpflags
operator||=
name|MERGED_DEVICE
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Turn off an extension device.  * This code does not allow the keyboard or pointer to be turned off.  *  */
end_comment

begin_macro
name|CloseInputDevice
argument_list|(
argument|dev
argument_list|,
argument|client
argument_list|)
end_macro

begin_decl_stmt
name|DeviceIntPtr
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ClientPtr
name|client
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
name|DeviceClientsPtr
name|tmp
decl_stmt|;
name|d
operator|=
name|GET_HPINPUTDEVICE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
operator|(
name|DeviceClientsPtr
operator|)
name|d
operator|->
name|clients
init|;
name|tmp
operator|!=
name|NULL
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
name|tmp
operator|->
name|client
operator|==
name|client
condition|)
block|{
name|tmp
operator|->
name|count
operator|--
expr_stmt|;
name|d
operator|->
name|open_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|FreeResource
argument_list|(
name|tmp
operator|->
name|resource
argument_list|,
name|RT_NONE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * Change the state of a non-standard device.  * Modes are:  *    ON - turn the device on.  *    OFF - turn the device off.  *    SYSTEM_EVENTS - report the standard input events.  *    DEVICE_EVENTS - report the extension input events.  *  */
end_comment

begin_function
specifier|static
name|void
name|SetInputDevice
parameter_list|(
name|d
parameter_list|,
name|mode
parameter_list|)
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|mode
operator|&
name|DEVICE_EVENTS
operator|)
operator|==
name|DEVICE_EVENTS
condition|)
block|{
name|d
operator|->
name|mode
operator|=
name|RELATIVE
expr_stmt|;
name|d
operator|->
name|hpflags
operator|&=
operator|~
name|MERGED_DEVICE
expr_stmt|;
block|}
else|else
block|{
name|mode
operator||=
name|ABSOLUTE
expr_stmt|;
name|d
operator|->
name|mode
operator|=
name|ABSOLUTE
expr_stmt|;
name|d
operator|->
name|hpflags
operator||=
name|MERGED_DEVICE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mode
operator|&
name|ABSOLUTE
operator|)
operator|==
name|ABSOLUTE
condition|)
block|{
name|d
operator|->
name|coords
index|[
literal|0
index|]
operator|=
name|hpPointer
operator|->
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|d
operator|->
name|coords
index|[
literal|1
index|]
operator|=
name|hpPointer
operator|->
name|coords
index|[
literal|1
index|]
expr_stmt|;
name|d
operator|->
name|mode
operator|=
name|ABSOLUTE
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
name|d
operator|->
name|coords
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|coords
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* __hpux */
name|d
operator|->
name|mode
operator|=
name|RELATIVE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Change the mode of an extension device.  * This is for devices such as graphics tablets that can report either  * relative or absolute motion.  * We currently do not support this.  *  */
end_comment

begin_expr_stmt
name|SetDeviceMode
argument_list|(
name|client
argument_list|,
name|dev
argument_list|,
name|mode
argument_list|)
specifier|register
name|ClientPtr
name|client
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|DeviceIntPtr
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|GET_HPINPUTDEVICE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dev_type
operator|==
name|NULL_DEVICE
condition|)
return|return
name|Success
return|;
if|if
condition|(
name|d
operator|->
name|hpflags
operator|&
name|IS_SERIAL_DEVICE
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_serial_devices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|file_ds
operator|==
name|serialprocs
index|[
name|i
index|]
operator|.
name|fd
condition|)
if|if
condition|(
operator|(
operator|*
operator|(
name|serialprocs
index|[
name|i
index|]
operator|.
name|write
operator|)
operator|)
operator|(
name|d
operator|->
name|file_ds
operator|,
name|_XSetDeviceMode
operator|,
operator|&
name|mode
operator|)
operator|==
name|WRITE_SUCCESS
condition|)
return|return
name|Success
return|;
return|return
name|BadMatch
return|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * Set the value of valuators on an extension device.  * This is needed for some devices that can report both  * relative and absolute motion.  Some may require that the  * initial values be set when switching modes.  * We currently do not support this.  *  */
end_comment

begin_expr_stmt
name|SetDeviceValuators
argument_list|(
name|client
argument_list|,
name|dev
argument_list|,
name|valuators
argument_list|,
name|first_valuator
argument_list|,
name|num_valuators
argument_list|)
specifier|register
name|ClientPtr
name|client
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|DeviceIntPtr
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|valuators
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|first_valuator
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_valuators
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
name|HPResolutionControl
name|ctrl
decl_stmt|;
name|d
operator|=
name|GET_HPINPUTDEVICE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dev_type
operator|==
name|NULL_DEVICE
condition|)
return|return
name|Success
return|;
if|if
condition|(
name|d
operator|->
name|hpflags
operator|&
name|IS_SERIAL_DEVICE
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_serial_devices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|file_ds
operator|==
name|serialprocs
index|[
name|i
index|]
operator|.
name|fd
condition|)
block|{
name|ctrl
operator|.
name|first_valuator
operator|=
name|first_valuator
expr_stmt|;
name|ctrl
operator|.
name|num_valuators
operator|=
name|num_valuators
expr_stmt|;
name|ctrl
operator|.
name|resolutions
operator|=
name|valuators
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|serialprocs
index|[
name|i
index|]
operator|.
name|write
operator|)
operator|)
operator|(
name|d
operator|->
name|file_ds
operator|,
name|_XSetDeviceValuators
operator|,
operator|&
name|ctrl
operator|)
operator|==
name|WRITE_SUCCESS
condition|)
return|return
name|Success
return|;
block|}
return|return
name|BadMatch
return|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * Change the resolution of valuators on an extension device.  * This is needed for some devices that have multiple resolutions.  * We currently do not support this.  *  */
end_comment

begin_function
name|int
name|ChangeDeviceControl
parameter_list|(
name|client
parameter_list|,
name|dev
parameter_list|,
name|control
parameter_list|)
specifier|register
name|ClientPtr
name|client
decl_stmt|;
name|DeviceIntPtr
name|dev
decl_stmt|;
name|xDeviceCtl
modifier|*
name|control
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
name|xDeviceResolutionCtl
modifier|*
name|dctrl
decl_stmt|;
name|HPResolutionControl
name|ctrl
decl_stmt|;
name|d
operator|=
name|GET_HPINPUTDEVICE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dev_type
operator|==
name|NULL_DEVICE
condition|)
return|return
name|Success
return|;
if|if
condition|(
name|d
operator|->
name|hpflags
operator|&
name|IS_SERIAL_DEVICE
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_serial_devices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|file_ds
operator|==
name|serialprocs
index|[
name|i
index|]
operator|.
name|fd
condition|)
block|{
name|dctrl
operator|=
operator|(
name|xDeviceResolutionCtl
operator|*
operator|)
name|control
expr_stmt|;
name|ctrl
operator|.
name|first_valuator
operator|=
name|dctrl
operator|->
name|first_valuator
expr_stmt|;
name|ctrl
operator|.
name|num_valuators
operator|=
name|dctrl
operator|->
name|num_valuators
expr_stmt|;
name|ctrl
operator|.
name|resolutions
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|dctrl
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|serialprocs
index|[
name|i
index|]
operator|.
name|write
operator|)
operator|)
operator|(
name|d
operator|->
name|file_ds
operator|,
name|_XChangeDeviceControl
operator|,
operator|&
name|ctrl
operator|)
operator|==
name|WRITE_SUCCESS
condition|)
return|return
name|Success
return|;
block|}
return|return
name|BadMatch
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XINPUT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
end_if

begin_define
define|#
directive|define
name|LEFT_SHIFT_CODE
value|0x05
end_define

begin_define
define|#
directive|define
name|RIGHT_SHIFT_CODE
value|0x04
end_define

begin_define
define|#
directive|define
name|LEFT_MOD1_CODE
value|0x03
end_define

begin_define
define|#
directive|define
name|RIGHT_MOD1_CODE
value|0x02
end_define

begin_define
define|#
directive|define
name|RIGHT_CONTROL_CODE
value|0x00
end_define

begin_define
define|#
directive|define
name|LEFT_CONTROL_CODE
value|0x06
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hpux */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__apollo
end_ifdef

begin_define
define|#
directive|define
name|LEFT_SHIFT_CODE
value|0x5e
end_define

begin_define
define|#
directive|define
name|RIGHT_SHIFT_CODE
value|0x6a
end_define

begin_define
define|#
directive|define
name|LEFT_MOD1_CODE
value|0x75
end_define

begin_define
define|#
directive|define
name|RIGHT_MOD1_CODE
value|0x77
end_define

begin_define
define|#
directive|define
name|LEFT_CONTROL_CODE
value|0x43
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __apollo */
end_comment

begin_define
define|#
directive|define
name|LEFT_SHIFT_BIT
value|0x20
end_define

begin_define
define|#
directive|define
name|RIGHT_SHIFT_BIT
value|0x10
end_define

begin_define
define|#
directive|define
name|LEFT_MOD1_BIT
value|0x08
end_define

begin_define
define|#
directive|define
name|RIGHT_MOD1_BIT
value|0x04
end_define

begin_define
define|#
directive|define
name|RIGHT_CONTROL_BIT
value|0x01
end_define

begin_define
define|#
directive|define
name|LEFT_CONTROL_BIT
value|0x40
end_define

begin_define
define|#
directive|define
name|MAX_KEY_MODS
value|3
end_define

begin_macro
name|fix_modifierkeys
argument_list|()
end_macro

begin_block
block|{
name|u_char
name|tmp
index|[
literal|3
index|]
decl_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
name|tmp
index|[
literal|2
index|]
operator|=
literal|0xff
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|pointer_amt_mods
index|[
literal|0
index|]
expr_stmt|;
name|mask_from_kcodes
argument_list|(
name|tmp
argument_list|,
operator|&
name|pointer_amt_bits
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|pointer_amt_mods
index|[
literal|1
index|]
expr_stmt|;
name|mask_from_kcodes
argument_list|(
name|tmp
argument_list|,
operator|&
name|pointer_amt_bits
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|pointer_amt_mods
index|[
literal|2
index|]
expr_stmt|;
name|mask_from_kcodes
argument_list|(
name|tmp
argument_list|,
operator|&
name|pointer_amt_bits
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|mask_from_kcodes
argument_list|(
name|pointer_key_mods
argument_list|,
operator|&
name|ptr_mods
argument_list|)
expr_stmt|;
name|mask_from_kcodes
argument_list|(
name|pointer_amt_mods
argument_list|,
operator|&
name|mv_mods
argument_list|)
expr_stmt|;
name|mask_from_kcodes
argument_list|(
name|reset_mods
argument_list|,
operator|&
name|rs_mods
argument_list|)
expr_stmt|;
name|mask_from_kcodes
argument_list|(
name|borrow_mode_mods
argument_list|,
operator|&
name|bw_mods
argument_list|)
expr_stmt|;
name|mv_mods
operator|&=
operator|~
name|ptr_mods
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|mask_from_kcodes
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|u_char
modifier|*
name|src
decl_stmt|;
name|u_char
modifier|*
name|dst
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_KEY_MODS
condition|;
name|i
operator|++
operator|,
name|src
operator|++
control|)
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
case|case
name|LEFT_SHIFT_CODE
case|:
operator|*
name|dst
operator||=
name|LEFT_SHIFT_BIT
expr_stmt|;
break|break;
case|case
name|RIGHT_SHIFT_CODE
case|:
operator|*
name|dst
operator||=
name|RIGHT_SHIFT_BIT
expr_stmt|;
break|break;
case|case
name|LEFT_MOD1_CODE
case|:
operator|*
name|dst
operator||=
name|LEFT_MOD1_BIT
expr_stmt|;
break|break;
case|case
name|RIGHT_MOD1_CODE
case|:
operator|*
name|dst
operator||=
name|RIGHT_MOD1_BIT
expr_stmt|;
break|break;
case|case
name|LEFT_CONTROL_CODE
case|:
operator|*
name|dst
operator||=
name|LEFT_CONTROL_BIT
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
case|case
name|RIGHT_CONTROL_CODE
case|:
operator|*
name|dst
operator||=
name|RIGHT_CONTROL_BIT
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* __hpux || __hp_osf */
default|default:
break|break;
block|}
block|}
end_function

begin_macro
name|get_down_modifiers
argument_list|(
argument|kptr
argument_list|,
argument|down_mods
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|kptr
decl_stmt|,
modifier|*
name|down_mods
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
operator|*
name|down_mods
operator|=
name|kptr
index|[
literal|1
index|]
operator|&
literal|0x7d
expr_stmt|;
comment|/* mask off break and repeat cursor */
endif|#
directive|endif
comment|/* __hpux */
ifdef|#
directive|ifdef
name|__apollo
operator|*
name|down_mods
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kptr
index|[
literal|9
index|]
operator|&
literal|0x08
condition|)
operator|*
name|down_mods
operator||=
name|LEFT_CONTROL_BIT
expr_stmt|;
if|if
condition|(
name|kptr
index|[
literal|12
index|]
operator|&
literal|0x40
condition|)
operator|*
name|down_mods
operator||=
name|LEFT_SHIFT_BIT
expr_stmt|;
if|if
condition|(
name|kptr
index|[
literal|14
index|]
operator|&
literal|0x04
condition|)
operator|*
name|down_mods
operator||=
name|RIGHT_SHIFT_BIT
expr_stmt|;
if|if
condition|(
name|kptr
index|[
literal|15
index|]
operator|&
literal|0x80
condition|)
operator|*
name|down_mods
operator||=
name|RIGHT_MOD1_BIT
expr_stmt|;
if|if
condition|(
name|kptr
index|[
literal|15
index|]
operator|&
literal|0x20
condition|)
operator|*
name|down_mods
operator||=
name|LEFT_MOD1_BIT
expr_stmt|;
endif|#
directive|endif
comment|/* __apollo */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__apollo
end_ifdef

begin_macro
name|DisableAllInput
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|DeviceIntPtr
name|dev
decl_stmt|,
name|next
decl_stmt|;
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|dev
operator|=
name|inputInfo
operator|.
name|devices
init|;
name|dev
condition|;
name|dev
operator|=
name|next
control|)
block|{
name|next
operator|=
name|dev
operator|->
name|next
expr_stmt|;
name|d
operator|=
name|GET_HPINPUTDEVICE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|RemoveEnabledDevice
argument_list|(
name|d
operator|->
name|file_ds
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|EnableAllInput
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|DeviceIntPtr
name|dev
decl_stmt|,
name|next
decl_stmt|;
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|dev
operator|=
name|inputInfo
operator|.
name|devices
init|;
name|dev
condition|;
name|dev
operator|=
name|next
control|)
block|{
name|next
operator|=
name|dev
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|inited
operator|&&
name|dev
operator|->
name|startup
condition|)
block|{
name|d
operator|=
name|GET_HPINPUTDEVICE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|AddEnabledDevice
argument_list|(
name|d
operator|->
name|file_ds
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
name|int
name|xosWindowPrivateIndex
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __apollo */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|hp9000
end_ifndef

begin_comment
comment|/*****************************************************************************  *  * Dynamically load drivers to support non-HIL input devices.  *  */
end_comment

begin_decl_stmt
name|HPInputDeviceHeader
name|zdhdr
decl_stmt|;
end_decl_stmt

begin_macro
name|init_dynamic_devs
argument_list|(
argument|opendevs
argument_list|,
argument|numdev
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|opendevs
name|opendevs
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numdev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|fd
decl_stmt|,
name|use
decl_stmt|,
name|sndx
init|=
literal|0
decl_stmt|;
name|HPInputDeviceHeader
name|dhdr
decl_stmt|;
name|Bool
function_decl|(
modifier|*
name|driverInit
function_decl|)
parameter_list|()
function_decl|;
name|char
name|fname
index|[
literal|255
index|]
decl_stmt|;
name|shl_t
name|ldr_module_id
decl_stmt|;
name|long
name|ldr_module_entry
decl_stmt|;
name|int
name|ret_val
decl_stmt|;
name|char
name|driver_path
index|[
literal|255
index|]
decl_stmt|;
name|char
name|driver_init
index|[
literal|255
index|]
decl_stmt|;
comment|/*     * For each device,      *     1). find an available device private struct,     *     2). make sure the user has told us the device path and use,     *     3). make sure the driver knows about this device,     *     4). call the driver to open and configure it.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdev
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|serial
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
condition|)
continue|continue;
name|strcpy
argument_list|(
name|driver_path
argument_list|,
literal|"/usr/lib/X11/extensions/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|driver_path
argument_list|,
name|serial
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__hp9000s300
argument_list|)
name|strcpy
argument_list|(
name|driver_init
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|driver_init
argument_list|,
name|serial
index|[
name|i
index|]
operator|.
name|entry
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|driver_init
argument_list|,
name|serial
index|[
name|i
index|]
operator|.
name|entry
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __hp9000s300 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_serial_devices
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|serialprocs
index|[
name|j
index|]
operator|.
name|driver_name
argument_list|,
name|serial
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|num_serial_devices
condition|)
comment|/* this driver wasn't previously loaded */
block|{
comment|/* 	     * Dynamically load the driver. 	     */
name|ldr_module_id
operator|=
name|shl_load
argument_list|(
name|driver_path
argument_list|,
name|BIND_IMMEDIATE
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldr_module_id
operator|==
name|NULL
condition|)
block|{
name|ErrorF
argument_list|(
literal|"Failed to load serial input device driver %s\n"
argument_list|,
name|driver_path
argument_list|)
expr_stmt|;
name|ErrorF
argument_list|(
literal|"Check spelling and case of device name.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|ldr_module_id
operator|=
name|serialprocs
index|[
name|j
index|]
operator|.
name|ldr_module_id
expr_stmt|;
name|sndx
operator|=
name|j
expr_stmt|;
comment|/* 	 * Now look for the main entry point by name. 	 */
name|ret_val
operator|=
name|shl_findsym
argument_list|(
operator|&
name|ldr_module_id
argument_list|,
name|driver_init
argument_list|,
name|TYPE_PROCEDURE
argument_list|,
operator|&
name|ldr_module_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|ErrorF
argument_list|(
literal|"Couldn't find main entry point %s in serial input device driver %s, retval is %x\n"
argument_list|,
name|driver_init
argument_list|,
name|driver_path
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
name|ErrorF
argument_list|(
literal|"Check spelling and case of device name and entrypoint.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * Call that entry point to initialize driver. 	 */
name|driverInit
operator|=
operator|(
name|pfrb
operator|)
name|ldr_module_entry
expr_stmt|;
name|ret_val
operator|=
call|(
modifier|*
name|driverInit
call|)
argument_list|(
operator|&
name|serialprocs
index|[
name|sndx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|INIT_SUCCESS
condition|)
block|{
name|ErrorF
argument_list|(
literal|"Couldn't initialize serial input device driver %s\n"
argument_list|,
name|driver_path
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dhdr
operator|=
name|zdhdr
expr_stmt|;
name|strcpy
argument_list|(
name|dhdr
operator|.
name|path
argument_list|,
name|serial
index|[
name|i
index|]
operator|.
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|serialprocs
index|[
name|sndx
index|]
operator|.
name|configure
operator|)
operator|)
operator|(
operator|&
name|dhdr
operator|,
operator|&
name|use
operator|)
operator|==
name|INIT_SUCCESS
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|l_devs
index|[
name|k
index|]
operator|.
name|hil_header
operator|.
name|id
operator|!=
literal|1
operator|&&
name|k
operator|<
name|MAX_DEVICES
operator|-
literal|1
condition|;
name|k
operator|++
control|)
empty_stmt|;
name|serialprocs
index|[
name|sndx
index|]
operator|.
name|fd
operator|=
name|dhdr
operator|.
name|file_ds
expr_stmt|;
name|strcpy
argument_list|(
name|l_devs
index|[
name|k
index|]
operator|.
name|x_name
argument_list|,
literal|"FIRST_"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fname
argument_list|,
name|serialprocs
index|[
name|sndx
index|]
operator|.
name|x_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|l_devs
index|[
name|k
index|]
operator|.
name|x_name
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|l_devs
index|[
name|k
index|]
operator|.
name|x_atom
operator|=
name|MakeAtom
argument_list|(
name|fname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l_devs
index|[
name|k
index|]
operator|.
name|x_atom
condition|)
name|l_devs
index|[
name|k
index|]
operator|.
name|x_atom
operator|=
name|MakeAtom
argument_list|(
name|fname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x_init_dynamic_device
argument_list|(
operator|&
name|l_devs
index|[
name|k
index|]
argument_list|,
operator|&
name|dhdr
argument_list|,
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|XPOINTER
condition|)
block|{
if|if
condition|(
name|hpPointer
operator|&&
name|hpPointer
operator|->
name|file_ds
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|hpPointer
operator|->
name|file_ds
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|fd
operator|=
name|hpPointer
operator|->
name|file_ds
init|;
name|j
operator|<
name|MAX_DEVICES
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|l_devs
index|[
name|j
index|]
operator|.
name|file_ds
operator|==
name|fd
condition|)
name|l_devs
index|[
name|j
index|]
operator|.
name|file_ds
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|hpPointer
operator|=
operator|&
name|l_devs
index|[
name|k
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|XKEYBOARD
condition|)
block|{
if|if
condition|(
name|hpKeyboard
operator|&&
name|hpKeyboard
operator|->
name|file_ds
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|hpKeyboard
operator|->
name|file_ds
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|fd
operator|=
name|hpKeyboard
operator|->
name|file_ds
init|;
name|j
operator|<
name|MAX_DEVICES
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|l_devs
index|[
name|j
index|]
operator|.
name|file_ds
operator|==
name|fd
condition|)
name|l_devs
index|[
name|j
index|]
operator|.
name|file_ds
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|hpKeyboard
operator|=
operator|&
name|l_devs
index|[
name|k
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sndx
operator|==
name|num_serial_devices
condition|)
block|{
name|strcpy
argument_list|(
name|serialprocs
index|[
name|sndx
index|]
operator|.
name|driver_name
argument_list|,
name|serial
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|serialprocs
index|[
name|sndx
index|]
operator|.
name|ldr_module_id
operator|=
name|ldr_module_id
expr_stmt|;
name|num_serial_devices
operator|++
expr_stmt|;
block|}
block|}
else|else
name|ErrorF
argument_list|(
literal|"Couldn't initialize serial input device %s\n"
argument_list|,
name|serial
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|DYNAMIC_DEVICE
value|0xffff
end_define

begin_macro
name|x_init_dynamic_device
argument_list|(
argument|d
argument_list|,
argument|dhdr
argument_list|,
argument|use
argument_list|)
end_macro

begin_decl_stmt
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HPInputDeviceHeader
modifier|*
name|dhdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|use
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|strcpy
argument_list|(
name|d
operator|->
name|dev_name
argument_list|,
name|dhdr
operator|->
name|path
argument_list|)
expr_stmt|;
name|d
operator|->
name|hil_header
operator|.
name|resx
operator|=
name|dhdr
operator|->
name|resolution
operator|*
literal|100
expr_stmt|;
name|d
operator|->
name|hil_header
operator|.
name|resy
operator|=
name|dhdr
operator|->
name|resolution
operator|*
literal|100
expr_stmt|;
name|d
operator|->
name|hil_header
operator|.
name|size_x
operator|=
name|dhdr
operator|->
name|max_x
expr_stmt|;
name|d
operator|->
name|hil_header
operator|.
name|size_y
operator|=
name|dhdr
operator|->
name|max_y
expr_stmt|;
name|d
operator|->
name|file_ds
operator|=
name|dhdr
operator|->
name|file_ds
expr_stmt|;
name|BITSET
argument_list|(
name|valid_inputs
operator|.
name|input_mask
argument_list|,
name|dhdr
operator|->
name|file_ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|dhdr
operator|->
name|file_ds
operator|>
name|valid_inputs
operator|.
name|max_fd
condition|)
name|valid_inputs
operator|.
name|max_fd
operator|=
name|dhdr
operator|->
name|file_ds
expr_stmt|;
name|d
operator|->
name|hil_header
operator|.
name|ax_num
operator|=
name|dhdr
operator|->
name|ax_num
expr_stmt|;
name|d
operator|->
name|hil_header
operator|.
name|p_button_count
operator|=
name|dhdr
operator|->
name|num_buttons
expr_stmt|;
name|d
operator|->
name|hil_header
operator|.
name|v_button_count
operator|=
name|dhdr
operator|->
name|num_buttons
expr_stmt|;
name|d
operator|->
name|hil_header
operator|.
name|num_keys
operator|=
name|dhdr
operator|->
name|num_keys
expr_stmt|;
name|d
operator|->
name|hil_header
operator|.
name|min_kcode
operator|=
name|dhdr
operator|->
name|min_kcode
expr_stmt|;
name|d
operator|->
name|hil_header
operator|.
name|max_kcode
operator|=
name|dhdr
operator|->
name|max_kcode
expr_stmt|;
if|if
condition|(
name|dhdr
operator|->
name|flags
operator|&
name|ABSOLUTE_DATA
condition|)
block|{
name|d
operator|->
name|mode
operator|=
name|ABSOLUTE
expr_stmt|;
name|d
operator|->
name|hil_header
operator|.
name|flags
operator|=
name|HIL_ABSOLUTE
expr_stmt|;
block|}
else|else
name|d
operator|->
name|mode
operator|=
name|RELATIVE
expr_stmt|;
name|d
operator|->
name|hpflags
operator|=
name|IS_SERIAL_DEVICE
operator||
name|OPEN_THIS_DEVICE
expr_stmt|;
name|d
operator|->
name|hpflags
operator||=
operator|(
name|dhdr
operator|->
name|flags
operator|&
name|DATA_SIZE_BITS
operator|)
expr_stmt|;
name|d
operator|->
name|dev_type
operator|=
name|DYNAMIC_DEVICE
expr_stmt|;
name|d
operator|->
name|hil_header
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|hil_header
operator|.
name|num_leds
operator|=
name|dhdr
operator|->
name|num_leds
expr_stmt|;
if|if
condition|(
name|dhdr
operator|->
name|num_keys
condition|)
name|d
operator|->
name|x_type
operator|=
name|KEYBOARD
expr_stmt|;
else|else
name|d
operator|->
name|x_type
operator|=
name|MOUSE
expr_stmt|;
if|if
condition|(
name|use
operator|==
name|XPOINTER
condition|)
name|hpPointer
operator|=
name|d
expr_stmt|;
elseif|else
if|if
condition|(
name|use
operator|==
name|XKEYBOARD
condition|)
name|hpKeyboard
operator|=
name|d
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

