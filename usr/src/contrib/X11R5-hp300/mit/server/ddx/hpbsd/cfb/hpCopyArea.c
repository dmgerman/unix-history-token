begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1986, 1987, 1988 by Hewlett-Packard Company HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD TO THIS SOFWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE.  Hewlett-Packard shall not be liable for errors  contained herein or direct, indirect, special, incidental or  consequential damages in connection with the furnishing,  performance, or use of this material. */
end_comment

begin_comment
comment|/* $XConsortium: hpCopyArea.c,v 1.4 88/09/30 14:16:22 jim Exp $ */
end_comment

begin_comment
comment|/*   * hpCopyArea.c : a copy area for HP displays  * Author: C Durland  (aided and abetted by Mr. J. Daniels)  */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"mi.h"
end_include

begin_include
include|#
directive|include
file|"servermd.h"
end_include

begin_include
include|#
directive|include
file|"cfb.h"
end_include

begin_comment
comment|/*   MTOS : main memory to screen  MTOM : main mem to main mem, screen to main mem  STOS : screen to screen 			    DESTINATION 			       | screen | main memory 			window | pixmap | pixmap 	SOURCE	      .--------|--------|-------    window	      |  STOS  |  STOS  | MTOM    screen pixmap      |  STOS  |  STOS  | MTOM    main memory pixmap |  MTOS  |  MTOS  | MTOM  			Dest clip list		Source clip list    window		composite clip		inferiors or window clip list    screen pixmap	maybe a client clip	no    main memory pixmap	maybe a client clip	no */
end_comment

begin_define
define|#
directive|define
name|COPYROW
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|n
parameter_list|)
value|memcpy(to,from,n)
end_define

begin_define
define|#
directive|define
name|PIXER
parameter_list|(
name|Drawable
parameter_list|)
value|((hpPrivPixmapPtr)((PixmapPtr)Drawable)->devPrivate.ptr)
end_define

begin_define
define|#
directive|define
name|SCRMER
parameter_list|(
name|Drawable
parameter_list|)
value|getPrivScreenPtr(Drawable->pScreen)
end_define

begin_define
define|#
directive|define
name|DEVKIND
parameter_list|(
name|Drawable
parameter_list|)
value|((PixmapPtr)Drawable)->devKind
end_define

begin_define
define|#
directive|define
name|SWEAT_PLANES_MASK
parameter_list|(
name|Drawable
parameter_list|,
name|planesmask
parameter_list|)
define|\
value|((SCRMER(Drawable)->planesMask& planesmask) !=	\     SCRMER(Drawable)->planesMask)
end_define

begin_comment
comment|/* Clip rectangle (x,y)-(x+w,y+h) against (a,b)-(c,d) 	 * Returns the cliped (x,y) and w,h 	 */
end_comment

begin_function
name|void
name|clipper
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|cx
parameter_list|,
name|cy
parameter_list|,
name|cw
parameter_list|,
name|ch
parameter_list|)
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|int
modifier|*
name|cx
decl_stmt|,
decl|*
name|cy
decl_stmt|,
modifier|*
name|cw
decl_stmt|,
modifier|*
name|ch
decl_stmt|;
end_function

begin_block
block|{
operator|*
name|cw
operator|=
name|min
argument_list|(
name|x
operator|+
name|w
argument_list|,
name|c
argument_list|)
operator|-
operator|(
operator|*
name|cx
operator|=
name|max
argument_list|(
name|x
argument_list|,
name|a
argument_list|)
operator|)
expr_stmt|;
operator|*
name|ch
operator|=
name|min
argument_list|(
name|y
operator|+
name|h
argument_list|,
name|d
argument_list|)
operator|-
operator|(
operator|*
name|cy
operator|=
name|max
argument_list|(
name|y
argument_list|,
name|b
argument_list|)
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Check to see if can copy area between two rectangles: 	 *   If the dest is above the source: can copy 	 *   else if they overlap:  Can't copy 	 * Have to check horizontal because of clip lists.  boxes is the sum 	 *  of the number of clip rectangles for the source and dest. 	 * Returns: FALSE if can copy area (ie any overlap don't matter) 	 *    true if got a overlap problem 	 */
end_comment

begin_function
specifier|static
name|int
name|lapdog
parameter_list|(
name|srcx
parameter_list|,
name|srcy
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|dstx
parameter_list|,
name|dsty
parameter_list|,
name|boxes
parameter_list|)
name|int
name|srcx
decl_stmt|,
name|srcy
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|,
name|dstx
decl_stmt|,
name|dsty
decl_stmt|,
name|boxes
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|srcy
operator|<=
name|dsty
operator|)
operator|||
operator|(
operator|(
name|boxes
operator|>
literal|2
operator|)
operator|&&
operator|(
name|srcx
operator|<
name|dstx
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|min
argument_list|(
name|srcx
argument_list|,
name|dstx
argument_list|)
operator|+
name|w
operator|-
name|max
argument_list|(
name|srcx
argument_list|,
name|dstx
argument_list|)
operator|)
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|min
argument_list|(
name|srcy
argument_list|,
name|dsty
argument_list|)
operator|+
name|h
operator|-
name|max
argument_list|(
name|srcy
argument_list|,
name|dsty
argument_list|)
operator|)
operator|>
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copy rectangles from screen to screen using the block mover 	 * Overlapping moves: 	 *   Assumes that block mover can handle overlapping copies. 	 *   If there is a clip list, care must be taken so that copying 	 *     a block does not trash a block to be copied. 	 * (?tx, ?ty) are translation constants to convert pixmaps 	 *   to screen coordinates.  0 if not a pixmap. 	 */
end_comment

begin_function
name|void
name|ScreenToScreen
parameter_list|(
name|drawable
parameter_list|,
name|gc
parameter_list|,
name|sx
parameter_list|,
name|sy
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|,
name|sbox
parameter_list|,
name|sboxes
parameter_list|,
name|dbox
parameter_list|,
name|dboxes
parameter_list|,
name|stx
parameter_list|,
name|sty
parameter_list|,
name|dtx
parameter_list|,
name|dty
parameter_list|)
name|DrawablePtr
name|drawable
decl_stmt|;
name|GCPtr
name|gc
decl_stmt|;
name|int
name|sx
decl_stmt|,
name|sy
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|sboxes
decl_stmt|,
name|dboxes
decl_stmt|,
name|stx
decl_stmt|,
name|sty
decl_stmt|,
name|dtx
decl_stmt|,
name|dty
decl_stmt|;
name|BoxPtr
name|sbox
decl_stmt|,
name|dbox
decl_stmt|;
comment|/* the clip lists */
block|{
specifier|register
name|BoxPtr
name|btr
decl_stmt|;
name|int
name|j
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|w1
decl_stmt|,
name|h1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|w2
decl_stmt|,
name|h2
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|tx
init|=
name|sx
operator|-
name|dx
decl_stmt|,
name|ty
init|=
name|sy
operator|-
name|dy
decl_stmt|;
name|ScreenPtr
name|Screen
init|=
name|drawable
operator|->
name|pScreen
decl_stmt|;
if|if
condition|(
name|gc
operator|->
name|alu
operator|==
name|GXnoop
condition|)
return|return;
comment|/* no op => don't do nothin */
for|for
control|(
init|;
name|sboxes
operator|--
condition|;
name|sbox
operator|++
control|)
comment|/* for each source box */
block|{
comment|/* intersect source and source clip rectangle */
name|clipper
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|sbox
operator|->
name|x1
argument_list|,
name|sbox
operator|->
name|y1
argument_list|,
name|sbox
operator|->
name|x2
argument_list|,
name|sbox
operator|->
name|y2
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|w1
argument_list|,
operator|&
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|w1
operator|<=
literal|0
operator|||
name|h1
operator|<=
literal|0
condition|)
continue|continue;
comment|/* translate box to dst coordinates */
name|a
operator|=
name|x1
operator|-
name|tx
expr_stmt|;
name|b
operator|=
name|y1
operator|-
name|ty
expr_stmt|;
name|c
operator|=
name|a
operator|+
name|w1
expr_stmt|;
name|d
operator|=
name|b
operator|+
name|h1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|dboxes
operator|,
name|btr
operator|=
name|dbox
init|;
name|j
operator|--
condition|;
name|btr
operator|++
control|)
comment|/* copy to the dest box */
block|{
comment|/* intersect dst and dst clip rectangles */
name|clipper
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|btr
operator|->
name|x1
argument_list|,
name|btr
operator|->
name|y1
argument_list|,
name|btr
operator|->
name|x2
argument_list|,
name|btr
operator|->
name|y2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|,
operator|&
name|w2
argument_list|,
operator|&
name|h2
argument_list|)
expr_stmt|;
if|if
condition|(
name|w2
operator|<=
literal|0
operator|||
name|h2
operator|<=
literal|0
condition|)
continue|continue;
comment|/* intersect clipped src and clipped dst rectangles */
name|clipper
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|,
name|w2
argument_list|,
name|h2
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|w1
argument_list|,
operator|&
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|w1
operator|<=
literal|0
operator|||
name|h1
operator|<=
literal|0
condition|)
continue|continue;
operator|(
operator|*
name|getPrivScreenPtr
argument_list|(
name|Screen
argument_list|)
operator|->
name|MoveBits
operator|)
operator|(
name|Screen
operator|,
name|gc
operator|->
name|planemask
operator|,
name|gc
operator|->
name|alu
operator|,
name|x1
operator|+
name|tx
operator|+
name|stx
operator|,
name|y1
operator|+
name|ty
operator|+
name|sty
operator|,
name|x1
operator|+
name|dtx
operator|,
name|y1
operator|+
name|dty
operator|,
name|w1
operator|,
name|h1
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* copy a rectangle of bytes: no processing */
end_comment

begin_function
specifier|static
name|void
name|CopyRec0
parameter_list|(
name|dst
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|dst_stride
parameter_list|,
name|alu
parameter_list|)
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
name|int
name|w
decl_stmt|,
name|h
decl_stmt|,
name|dst_stride
decl_stmt|,
name|alu
decl_stmt|;
block|{
specifier|register
name|int
name|z
decl_stmt|;
switch|switch
condition|(
name|alu
condition|)
block|{
case|case
name|GXclear
case|:
name|z
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 0 */
case|case
name|GXset
case|:
name|z
operator|=
operator|~
literal|0
expr_stmt|;
break|break;
comment|/* 1 */
block|}
while|while
condition|(
name|h
operator|--
condition|)
comment|/* copy h rows */
block|{
name|memset
argument_list|(
name|dst
argument_list|,
name|z
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|dst_stride
expr_stmt|;
comment|/* move to next row */
block|}
block|}
end_function

begin_comment
comment|/* copy a rectangle of bytes: only process src */
end_comment

begin_comment
comment|/* two cases: GXcopy& GXcopyInverted */
end_comment

begin_function
specifier|static
name|void
name|CopyRec1
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|src_stride
parameter_list|,
name|dst_stride
parameter_list|,
name|alu
parameter_list|)
specifier|register
name|char
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|w
decl_stmt|,
name|h
decl_stmt|,
name|src_stride
decl_stmt|,
name|dst_stride
decl_stmt|,
name|alu
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|alu
operator|==
name|GXcopy
condition|)
while|while
condition|(
name|h
operator|--
condition|)
comment|/* copy h rows */
block|{
name|COPYROW
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|src
operator|+=
name|src_stride
expr_stmt|;
name|dst
operator|+=
name|dst_stride
expr_stmt|;
comment|/* move to next row */
block|}
else|else
while|while
condition|(
name|h
operator|--
condition|)
comment|/* copy h rows */
block|{
name|j
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
name|dst
index|[
name|j
index|]
operator|=
operator|~
name|src
index|[
name|j
index|]
expr_stmt|;
name|src
operator|+=
name|src_stride
expr_stmt|;
name|dst
operator|+=
name|dst_stride
expr_stmt|;
comment|/* move to next row */
block|}
block|}
end_block

begin_comment
comment|/* copy a rectangle of bytes: process src& dst */
end_comment

begin_function
specifier|static
name|void
name|CopyRec2
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|,
name|src_stride
parameter_list|,
name|dst_stride
parameter_list|,
name|alu
parameter_list|,
name|planesmask
parameter_list|)
specifier|register
name|char
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|w
decl_stmt|,
name|h
decl_stmt|,
name|src_stride
decl_stmt|,
name|dst_stride
decl_stmt|,
name|alu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|long
name|int
name|planesmask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|a
decl_stmt|,
name|b
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
comment|/*!!! slime bag note: if planesmask> 8 bits this routine no workie */
while|while
condition|(
name|h
operator|--
condition|)
comment|/* copy h rows */
block|{
name|j
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
comment|/* copy a row */
block|{
name|a
operator|=
name|src
index|[
name|j
index|]
expr_stmt|;
name|b
operator|=
name|dst
index|[
name|j
index|]
expr_stmt|;
switch|switch
condition|(
name|alu
condition|)
block|{
case|case
name|GXclear
case|:
name|a
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 0 */
case|case
name|GXset
case|:
name|a
operator|=
operator|~
literal|0
expr_stmt|;
break|break;
comment|/* 1 */
case|case
name|GXcopyInverted
case|:
name|b
operator|=
operator|~
name|a
expr_stmt|;
break|break;
comment|/* ~src */
comment|/*	      case GXcopy: a = a; break;		/* src */
case|case
name|GXand
case|:
name|a
operator|=
name|a
operator|&
name|b
expr_stmt|;
break|break;
comment|/* src AND dst */
case|case
name|GXandReverse
case|:
name|a
operator|=
name|a
operator|&
operator|(
operator|~
name|b
operator|)
expr_stmt|;
break|break;
comment|/* src AND NOT dst */
case|case
name|GXandInverted
case|:
name|a
operator|=
operator|(
operator|~
name|a
operator|)
operator|&
name|b
expr_stmt|;
break|break;
comment|/* NOT src AND dst */
case|case
name|GXxor
case|:
name|a
operator|=
name|a
operator|^
name|b
expr_stmt|;
break|break;
comment|/* src XOR dst */
case|case
name|GXor
case|:
name|a
operator|=
name|a
operator||
name|b
expr_stmt|;
break|break;
comment|/* src OR dst */
case|case
name|GXnor
case|:
name|a
operator|=
operator|(
operator|~
name|a
operator|)
operator|&
operator|(
operator|~
name|b
operator|)
expr_stmt|;
break|break;
comment|/* NOT src AND NOT dst */
case|case
name|GXequiv
case|:
name|a
operator|=
operator|(
operator|~
name|a
operator|)
operator|^
name|b
expr_stmt|;
break|break;
comment|/* NOT src XOR dst */
case|case
name|GXinvert
case|:
name|a
operator|=
operator|~
name|b
expr_stmt|;
break|break;
comment|/* NOT dst */
case|case
name|GXorReverse
case|:
name|a
operator|=
name|a
operator||
operator|(
operator|~
name|b
operator|)
expr_stmt|;
break|break;
comment|/* src OR NOT dst */
case|case
name|GXorInverted
case|:
name|a
operator|=
operator|(
operator|~
name|a
operator|)
operator||
name|b
expr_stmt|;
break|break;
comment|/* NOT src OR dst */
case|case
name|GXnand
case|:
name|a
operator|=
operator|(
operator|~
name|a
operator|)
operator||
operator|(
operator|~
name|b
operator|)
expr_stmt|;
break|break;
comment|/* NOT src OR NOT dst */
block|}
name|dst
index|[
name|j
index|]
operator|=
operator|(
name|a
operator|&
name|planesmask
operator|)
operator||
operator|(
name|b
operator|&
operator|~
name|planesmask
operator|)
expr_stmt|;
block|}
name|src
operator|+=
name|src_stride
expr_stmt|;
name|dst
operator|+=
name|dst_stride
expr_stmt|;
comment|/* move to next row */
block|}
block|}
end_block

begin_comment
comment|/* move bytes from main memory to main memory 	 *   or move bytes from screen to main memory 	 * concerns: Replacement rule, overlapping copies, 	 * Only works for depths of 1 and multiples of 8. 	 */
end_comment

begin_function
name|void
name|MemToMem
parameter_list|(
name|SrcDrawable
parameter_list|,
name|DstDrawable
parameter_list|,
name|gc
parameter_list|,
name|sx
parameter_list|,
name|sy
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|,
name|sbox
parameter_list|,
name|sboxes
parameter_list|,
name|dbox
parameter_list|,
name|dboxes
parameter_list|)
name|DrawablePtr
name|SrcDrawable
decl_stmt|,
name|DstDrawable
decl_stmt|;
name|GCPtr
name|gc
decl_stmt|;
name|int
name|sx
decl_stmt|,
name|sy
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|sboxes
decl_stmt|,
name|dboxes
decl_stmt|;
name|BoxPtr
name|sbox
decl_stmt|,
name|dbox
decl_stmt|;
comment|/* the clip lists */
block|{
name|unsigned
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|presrc
decl_stmt|;
specifier|register
name|int
name|src_stride
decl_stmt|,
name|dst_stride
decl_stmt|;
name|int
name|j
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|w1
decl_stmt|,
name|h1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|w2
decl_stmt|,
name|h2
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|tx
init|=
name|sx
operator|-
name|dx
decl_stmt|,
name|ty
init|=
name|sy
operator|-
name|dy
decl_stmt|,
name|alu
decl_stmt|,
name|fake_alu
decl_stmt|,
name|DepthInBytes
init|=
name|SrcDrawable
operator|->
name|depth
operator|/
literal|8
decl_stmt|;
name|unsigned
name|long
name|int
name|planesmask
decl_stmt|;
specifier|register
name|BoxPtr
name|btr
decl_stmt|;
if|if
condition|(
operator|(
name|alu
operator|=
name|gc
operator|->
name|alu
operator|)
operator|==
name|GXnoop
condition|)
return|return;
comment|/* no op => don't do nothin */
name|fake_alu
operator|=
name|alu
expr_stmt|;
name|planesmask
operator|=
name|gc
operator|->
name|planemask
expr_stmt|;
if|if
condition|(
name|DepthInBytes
operator|<
literal|1
condition|)
comment|/* moving bits */
block|{
name|DepthInBytes
operator|=
literal|1
expr_stmt|;
comment|/* fake around */
if|if
condition|(
name|planesmask
operator|==
literal|0
condition|)
return|return;
comment|/* no bits will be changed */
name|planesmask
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* all bits can be changed */
block|}
comment|/* check to see if gotta sweat the planes mask */
if|if
condition|(
name|SWEAT_PLANES_MASK
argument_list|(
name|SrcDrawable
argument_list|,
name|planesmask
argument_list|)
condition|)
name|fake_alu
operator|=
literal|666
expr_stmt|;
name|dst_stride
operator|=
name|PIXER
argument_list|(
name|DstDrawable
argument_list|)
operator|->
name|stride
expr_stmt|;
if|if
condition|(
name|SrcDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
comment|/* from screen */
block|{
name|src_stride
operator|=
name|SCRMER
argument_list|(
name|SrcDrawable
argument_list|)
operator|->
name|stride
expr_stmt|;
name|presrc
operator|=
name|SCRMER
argument_list|(
name|SrcDrawable
argument_list|)
operator|->
name|bits
expr_stmt|;
block|}
else|else
comment|/* from main memory or offscreen pixmap */
block|{
name|src_stride
operator|=
name|PIXER
argument_list|(
name|SrcDrawable
argument_list|)
operator|->
name|stride
expr_stmt|;
name|presrc
operator|=
name|PIXER
argument_list|(
name|SrcDrawable
argument_list|)
operator|->
name|bits
expr_stmt|;
block|}
for|for
control|(
init|;
name|sboxes
operator|--
condition|;
name|sbox
operator|++
control|)
comment|/* for each source box */
block|{
comment|/* intersect src and src clip rectangle */
name|clipper
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|sbox
operator|->
name|x1
argument_list|,
name|sbox
operator|->
name|y1
argument_list|,
name|sbox
operator|->
name|x2
argument_list|,
name|sbox
operator|->
name|y2
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|w1
argument_list|,
operator|&
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|w1
operator|<=
literal|0
operator|||
name|h1
operator|<=
literal|0
condition|)
continue|continue;
comment|/* translate box to dst coordinates */
name|a
operator|=
name|x1
operator|-
name|tx
expr_stmt|;
name|b
operator|=
name|y1
operator|-
name|ty
expr_stmt|;
name|c
operator|=
name|a
operator|+
name|w1
expr_stmt|;
name|d
operator|=
name|b
operator|+
name|h1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|dboxes
operator|,
name|btr
operator|=
name|dbox
init|;
name|j
operator|--
condition|;
name|btr
operator|++
control|)
block|{
comment|/* intersect dst and dst clip rectangles */
name|clipper
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|btr
operator|->
name|x1
argument_list|,
name|btr
operator|->
name|y1
argument_list|,
name|btr
operator|->
name|x2
argument_list|,
name|btr
operator|->
name|y2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|,
operator|&
name|w2
argument_list|,
operator|&
name|h2
argument_list|)
expr_stmt|;
if|if
condition|(
name|w2
operator|<=
literal|0
operator|||
name|h2
operator|<=
literal|0
condition|)
continue|continue;
comment|/* intersect clipped src and clipped dst rectangles */
name|clipper
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|,
name|w2
argument_list|,
name|h2
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|w1
argument_list|,
operator|&
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|w1
operator|<=
literal|0
operator|||
name|h1
operator|<=
literal|0
condition|)
continue|continue;
name|w1
operator|*=
name|DepthInBytes
expr_stmt|;
comment|/* convert rectangle to addresses */
name|src
operator|=
name|presrc
operator|+
operator|(
name|x1
operator|+
name|tx
operator|)
operator|*
name|DepthInBytes
operator|+
operator|(
name|y1
operator|+
name|ty
operator|)
operator|*
name|src_stride
expr_stmt|;
name|dst
operator|=
name|PIXER
argument_list|(
name|DstDrawable
argument_list|)
operator|->
name|bits
operator|+
name|x1
operator|*
name|DepthInBytes
operator|+
name|y1
operator|*
name|dst_stride
expr_stmt|;
switch|switch
condition|(
name|fake_alu
condition|)
block|{
case|case
name|GXclear
case|:
case|case
name|GXset
case|:
name|CopyRec0
argument_list|(
name|dst
argument_list|,
name|w1
argument_list|,
name|h1
argument_list|,
name|dst_stride
argument_list|,
name|alu
argument_list|)
expr_stmt|;
break|break;
case|case
name|GXcopy
case|:
case|case
name|GXcopyInverted
case|:
name|CopyRec1
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|w1
argument_list|,
name|h1
argument_list|,
name|src_stride
argument_list|,
name|dst_stride
argument_list|,
name|alu
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CopyRec2
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|w1
argument_list|,
name|h1
argument_list|,
name|src_stride
argument_list|,
name|dst_stride
argument_list|,
name|alu
argument_list|,
name|planesmask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Move bytes from main memory to screen memory. 	 * (dtx,dty) are translation constants to convert pixmaps 	 *   to screen coordinates.  0 if not a pixmap. 	 */
end_comment

begin_function
name|void
name|MemToScreen
parameter_list|(
name|SrcDrawable
parameter_list|,
name|DstDrawable
parameter_list|,
name|gc
parameter_list|,
name|sx
parameter_list|,
name|sy
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|,
name|dboxes
parameter_list|,
name|dbox
parameter_list|,
name|dtx
parameter_list|,
name|dty
parameter_list|)
name|DrawablePtr
name|SrcDrawable
decl_stmt|,
name|DstDrawable
decl_stmt|;
name|GCPtr
name|gc
decl_stmt|;
name|int
name|sx
decl_stmt|,
name|sy
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|dboxes
decl_stmt|,
name|dtx
decl_stmt|,
name|dty
decl_stmt|;
name|BoxPtr
name|dbox
decl_stmt|;
comment|/* the dst clip list */
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
specifier|register
name|int
name|src_stride
decl_stmt|,
name|dst_stride
decl_stmt|;
name|int
name|w
decl_stmt|,
name|h
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|DepthInBytes
init|=
name|SrcDrawable
operator|->
name|depth
operator|/
literal|8
decl_stmt|;
comment|/* setup hardware */
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|gc
operator|->
name|pScreen
argument_list|,
name|gc
operator|->
name|planemask
argument_list|,
name|gc
operator|->
name|alu
argument_list|)
expr_stmt|;
name|src_stride
operator|=
name|PIXER
argument_list|(
name|SrcDrawable
argument_list|)
operator|->
name|stride
expr_stmt|;
name|dst_stride
operator|=
name|SCRMER
argument_list|(
name|DstDrawable
argument_list|)
operator|->
name|stride
expr_stmt|;
for|for
control|(
init|;
name|dboxes
operator|--
condition|;
name|dbox
operator|++
control|)
block|{
comment|/* intersect dst and clip rectangles */
name|clipper
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dbox
operator|->
name|x1
argument_list|,
name|dbox
operator|->
name|y1
argument_list|,
name|dbox
operator|->
name|x2
argument_list|,
name|dbox
operator|->
name|y2
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|w
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
name|w
operator|*=
name|DepthInBytes
expr_stmt|;
if|if
condition|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
condition|)
continue|continue;
comment|/* convert rectangle to addresses */
name|src
operator|=
name|PIXER
argument_list|(
name|SrcDrawable
argument_list|)
operator|->
name|bits
operator|+
operator|(
name|sx
operator|+
operator|(
name|x1
operator|-
name|dx
operator|)
operator|)
operator|*
name|DepthInBytes
operator|+
operator|(
name|sy
operator|+
operator|(
name|y1
operator|-
name|dy
operator|)
operator|)
operator|*
name|src_stride
expr_stmt|;
name|dst
operator|=
name|SCRMER
argument_list|(
name|DstDrawable
argument_list|)
operator|->
name|bits
operator|+
operator|(
name|x1
operator|+
name|dtx
operator|)
operator|*
name|DepthInBytes
operator|+
operator|(
name|y1
operator|+
name|dty
operator|)
operator|*
name|dst_stride
expr_stmt|;
comment|/* copy rectangle */
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|COPYROW
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|src
operator|+=
name|src_stride
expr_stmt|;
name|dst
operator|+=
name|dst_stride
expr_stmt|;
comment|/* move to next row */
block|}
block|}
block|}
end_function

begin_comment
comment|/* reverse banding */
end_comment

begin_function
specifier|static
name|void
name|spud
parameter_list|(
name|list
parameter_list|,
name|n
parameter_list|)
name|BoxRec
modifier|*
name|list
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|BoxRec
name|box
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
name|n
operator|,
name|k
operator|=
name|n
operator|/
literal|2
init|;
name|j
operator|<
name|k
condition|;
control|)
block|{
name|box
operator|=
name|list
index|[
name|j
index|]
expr_stmt|;
name|list
index|[
name|j
operator|++
index|]
operator|=
name|list
index|[
operator|--
name|i
index|]
expr_stmt|;
name|list
index|[
name|i
index|]
operator|=
name|box
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* reverse horizontal banding */
end_comment

begin_function
specifier|static
name|void
name|spudd
parameter_list|(
name|list
parameter_list|,
name|n
parameter_list|)
specifier|register
name|BoxRec
modifier|*
name|list
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|=
name|i
control|)
block|{
for|for
control|(
name|i
operator|=
name|j
operator|+
literal|1
init|;
name|i
operator|<
name|n
operator|&&
name|list
index|[
name|i
index|]
operator|.
name|y1
operator|==
name|list
index|[
name|j
index|]
operator|.
name|y1
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|spud
argument_list|(
operator|&
name|list
index|[
name|j
index|]
argument_list|,
name|i
operator|-
name|j
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|extern
name|RegionPtr
name|NotClippedByChildren
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|RegionPtr
name|hpfbCopyArea
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|RegionPtr
name|hpcCopyArea
parameter_list|(
name|pSrcDrawable
parameter_list|,
name|pDstDrawable
parameter_list|,
name|pGC
parameter_list|,
name|xIn
parameter_list|,
name|yIn
parameter_list|,
name|widthSrc
parameter_list|,
name|heightSrc
parameter_list|,
name|xOut
parameter_list|,
name|yOut
parameter_list|)
name|DrawablePtr
name|pSrcDrawable
decl_stmt|,
name|pDstDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|xIn
decl_stmt|,
name|yIn
decl_stmt|,
name|widthSrc
decl_stmt|,
name|heightSrc
decl_stmt|,
name|xOut
decl_stmt|,
name|yOut
decl_stmt|;
block|{
name|BoxRec
modifier|*
name|scl
decl_stmt|,
modifier|*
name|dcl
decl_stmt|,
name|sbox
decl_stmt|;
name|int
name|srcx
decl_stmt|,
name|srcy
decl_stmt|,
name|dstx
decl_stmt|,
name|dsty
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|,
name|dboxes
decl_stmt|,
name|sboxes
decl_stmt|,
name|stx
decl_stmt|,
name|sty
decl_stmt|,
name|dtx
decl_stmt|,
name|dty
decl_stmt|,
name|expose
init|=
literal|0
decl_stmt|,
name|lowlife
init|=
literal|0
decl_stmt|;
name|RegionPtr
name|sHitList
init|=
name|NULL
decl_stmt|;
comment|/* the source hit list */
name|RegionPtr
name|prgnExposed
init|=
name|NULL
decl_stmt|;
specifier|extern
name|RegionPtr
name|mfbCopyArea
parameter_list|()
function_decl|;
comment|/* ignore UNDRAWABLE_WINDOWs in the hope DIX takes care of them */
if|if
condition|(
operator|(
name|pDstDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|WindowPtr
operator|)
name|pDstDrawable
operator|)
operator|->
name|realized
operator|)
condition|)
return|return
operator|(
name|RegionPtr
operator|)
name|NULL
return|;
name|dstx
operator|=
name|xOut
expr_stmt|;
name|dsty
operator|=
name|yOut
expr_stmt|;
name|width
operator|=
name|widthSrc
expr_stmt|;
name|height
operator|=
name|heightSrc
expr_stmt|;
comment|/* clip the left and top edges of the source */
if|if
condition|(
name|xIn
operator|<
literal|0
condition|)
block|{
name|expose
operator|=
literal|1
expr_stmt|;
name|srcx
operator|=
name|pSrcDrawable
operator|->
name|x
expr_stmt|;
name|width
operator|+=
name|xIn
expr_stmt|;
block|}
else|else
name|srcx
operator|=
name|xIn
operator|+
name|pSrcDrawable
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|yIn
operator|<
literal|0
condition|)
block|{
name|expose
operator|=
literal|1
expr_stmt|;
name|srcy
operator|=
name|pSrcDrawable
operator|->
name|y
expr_stmt|;
name|height
operator|+=
name|yIn
expr_stmt|;
block|}
else|else
name|srcy
operator|=
name|yIn
operator|+
name|pSrcDrawable
operator|->
name|y
expr_stmt|;
comment|/* lookup or create the source clip lists */
name|stx
operator|=
name|sty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pSrcDrawable
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
condition|)
block|{
comment|/* clip right and bottom edges of source */
if|if
condition|(
name|width
operator|>
name|pSrcDrawable
operator|->
name|width
condition|)
block|{
name|expose
operator|=
literal|1
expr_stmt|;
name|width
operator|=
name|pSrcDrawable
operator|->
name|width
expr_stmt|;
block|}
if|if
condition|(
name|height
operator|>
name|pSrcDrawable
operator|->
name|height
condition|)
block|{
name|expose
operator|=
literal|1
expr_stmt|;
name|height
operator|=
name|pSrcDrawable
operator|->
name|height
expr_stmt|;
block|}
comment|/* if screen pixmap& going to use the block mover, translate */
if|if
condition|(
name|DEVKIND
argument_list|(
name|pSrcDrawable
argument_list|)
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
block|{
name|stx
operator|=
name|PIXER
argument_list|(
name|pSrcDrawable
argument_list|)
operator|->
name|pChunk
operator|->
name|x
expr_stmt|;
name|sty
operator|=
name|PIXER
argument_list|(
name|pSrcDrawable
argument_list|)
operator|->
name|pChunk
operator|->
name|y
expr_stmt|;
block|}
name|sbox
operator|.
name|x2
operator|=
operator|(
name|sbox
operator|.
name|x1
operator|=
name|srcx
operator|)
operator|+
name|width
expr_stmt|;
name|sbox
operator|.
name|y2
operator|=
operator|(
name|sbox
operator|.
name|y1
operator|=
name|srcy
operator|)
operator|+
name|height
expr_stmt|;
name|scl
operator|=
operator|&
name|sbox
expr_stmt|;
name|sboxes
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* source is a window */
block|{
name|expose
operator|=
literal|1
expr_stmt|;
comment|/* hard to figure out for a window so expose always */
comment|/* translate window to screen coordinates */
if|if
condition|(
name|pGC
operator|->
name|subWindowMode
operator|==
name|IncludeInferiors
condition|)
block|{
comment|/* included window can write over parent => overlap problem 	     *  (if included window is source and parent is dest) 	     */
if|if
condition|(
name|pDstDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
name|lowlife
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pSrcDrawable
operator|==
name|pDstDrawable
operator|&&
name|pGC
operator|->
name|clientClipType
operator|==
name|CT_NONE
condition|)
block|{
name|scl
operator|=
name|REGION_RECTS
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|sboxes
operator|=
name|REGION_NUM_RECTS
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* gotta create a new clip list */
block|{
name|sHitList
operator|=
name|NotClippedByChildren
argument_list|(
operator|(
name|WindowPtr
operator|)
name|pSrcDrawable
argument_list|)
expr_stmt|;
name|scl
operator|=
name|REGION_RECTS
argument_list|(
name|sHitList
argument_list|)
expr_stmt|;
name|sboxes
operator|=
name|REGION_NUM_RECTS
argument_list|(
name|sHitList
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|scl
operator|=
name|REGION_RECTS
argument_list|(
operator|&
operator|(
operator|(
name|WindowPtr
operator|)
name|pSrcDrawable
operator|)
operator|->
name|clipList
argument_list|)
expr_stmt|;
name|sboxes
operator|=
name|REGION_NUM_RECTS
argument_list|(
operator|&
operator|(
operator|(
name|WindowPtr
operator|)
name|pSrcDrawable
operator|)
operator|->
name|clipList
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* lookup the dest clip list and any translation */
name|dcl
operator|=
name|REGION_RECTS
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|dboxes
operator|=
name|REGION_NUM_RECTS
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|dtx
operator|=
name|dty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pDstDrawable
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
condition|)
block|{
if|if
condition|(
name|DEVKIND
argument_list|(
name|pDstDrawable
argument_list|)
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
block|{
name|dtx
operator|=
name|PIXER
argument_list|(
name|pDstDrawable
argument_list|)
operator|->
name|pChunk
operator|->
name|x
expr_stmt|;
name|dty
operator|=
name|PIXER
argument_list|(
name|pDstDrawable
argument_list|)
operator|->
name|pChunk
operator|->
name|y
expr_stmt|;
block|}
comment|/* else dest is in main mem& composite clip is OK */
block|}
else|else
comment|/* dest is a window */
block|{
if|if
condition|(
name|pGC
operator|->
name|miTranslate
condition|)
comment|/* translate window to screen coordinates */
block|{
name|dstx
operator|+=
name|pDstDrawable
operator|->
name|x
expr_stmt|;
name|dsty
operator|+=
name|pDstDrawable
operator|->
name|y
expr_stmt|;
block|}
block|}
comment|/* figure out who to call to actually do the copy area */
if|if
condition|(
name|pDstDrawable
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
operator|&&
name|DEVKIND
argument_list|(
name|pDstDrawable
argument_list|)
operator|==
name|PIXMAP_HOST_MEMORY
condition|)
comment|/* MTOM */
block|{
if|if
condition|(
name|pSrcDrawable
operator|->
name|depth
operator|==
literal|1
condition|)
comment|/* can only handle some bitmaps */
block|{
if|if
condition|(
operator|(
name|pSrcDrawable
operator|!=
name|pDstDrawable
operator|||
operator|!
name|lapdog
argument_list|(
name|srcx
argument_list|,
name|srcy
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|sboxes
operator|+
name|dboxes
argument_list|)
operator|)
operator|&&
name|srcx
operator|==
literal|0
operator|&&
name|srcy
operator|==
literal|0
operator|&&
name|dstx
operator|==
literal|0
operator|&&
name|dsty
operator|==
literal|0
operator|&&
operator|(
name|width
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
block|{
name|width
operator|/=
literal|8
expr_stmt|;
goto|goto
name|mtom
goto|;
block|}
comment|/* let mfb handle most of the bit maps */
return|return
name|mfbCopyArea
argument_list|(
name|pSrcDrawable
argument_list|,
name|pDstDrawable
argument_list|,
name|pGC
argument_list|,
name|xIn
argument_list|,
name|yIn
argument_list|,
name|widthSrc
argument_list|,
name|heightSrc
argument_list|,
name|xOut
argument_list|,
name|yOut
argument_list|)
return|;
block|}
comment|/* can't handle overlapping moves unless overlap don't matter */
if|if
condition|(
name|pSrcDrawable
operator|==
name|pDstDrawable
operator|&&
name|lapdog
argument_list|(
name|srcx
argument_list|,
name|srcy
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|sboxes
operator|+
name|dboxes
argument_list|)
operator|&&
operator|(
name|SWEAT_PLANES_MASK
argument_list|(
name|pSrcDrawable
argument_list|,
name|pGC
operator|->
name|planemask
argument_list|)
operator|||
operator|(
name|pGC
operator|->
name|alu
operator|!=
name|GXclear
operator|&&
name|pGC
operator|->
name|alu
operator|!=
name|GXset
operator|&&
name|pGC
operator|->
name|alu
operator|!=
name|GXnoop
operator|)
operator|)
condition|)
block|{
return|return
name|hpfbCopyArea
argument_list|(
name|pSrcDrawable
argument_list|,
name|pDstDrawable
argument_list|,
name|pGC
argument_list|,
name|xIn
argument_list|,
name|yIn
argument_list|,
name|widthSrc
argument_list|,
name|heightSrc
argument_list|,
name|xOut
argument_list|,
name|yOut
argument_list|)
return|;
block|}
name|mtom
label|:
name|MemToMem
argument_list|(
name|pSrcDrawable
argument_list|,
name|pDstDrawable
argument_list|,
name|pGC
argument_list|,
name|srcx
argument_list|,
name|srcy
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|scl
argument_list|,
name|sboxes
argument_list|,
name|dcl
argument_list|,
name|dboxes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pSrcDrawable
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
operator|&&
name|DEVKIND
argument_list|(
name|pSrcDrawable
argument_list|)
operator|==
name|PIXMAP_HOST_MEMORY
condition|)
comment|/* MTOS */
name|MemToScreen
argument_list|(
name|pSrcDrawable
argument_list|,
name|pDstDrawable
argument_list|,
name|pGC
argument_list|,
name|srcx
argument_list|,
name|srcy
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|dboxes
argument_list|,
name|dcl
argument_list|,
name|dtx
argument_list|,
name|dty
argument_list|)
expr_stmt|;
elseif|else
comment|/* STOS */
if|if
condition|(
operator|(
name|pSrcDrawable
operator|==
name|pDstDrawable
operator|||
name|lowlife
operator|)
operator|&&
operator|(
name|sboxes
operator|+
name|dboxes
operator|>
literal|2
operator|)
operator|&&
name|lapdog
argument_list|(
name|srcx
argument_list|,
name|srcy
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|sboxes
operator|+
name|dboxes
argument_list|)
operator|&&
operator|(
name|srcy
operator|<
name|dsty
operator|||
name|srcx
operator|<
name|dstx
operator|)
condition|)
comment|/* overlap */
block|{
name|BoxRec
modifier|*
name|sl
decl_stmt|,
modifier|*
name|dl
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* allocate new clip lists */
name|sl
operator|=
operator|(
name|BoxRec
operator|*
operator|)
name|xalloc
argument_list|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|sboxes
operator|+
name|dboxes
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|BoxRec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dl
operator|=
operator|&
name|sl
index|[
name|sboxes
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sboxes
condition|;
name|j
operator|++
control|)
name|sl
index|[
name|j
index|]
operator|=
name|scl
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dboxes
condition|;
name|j
operator|++
control|)
name|dl
index|[
name|j
index|]
operator|=
name|dcl
index|[
name|j
index|]
expr_stmt|;
comment|/* reverse vertical& horizontal banding */
if|if
condition|(
name|srcy
operator|<
name|dsty
operator|||
operator|(
name|srcy
operator|<
name|dsty
operator|&&
name|srcx
operator|<
name|dstx
operator|)
condition|)
block|{
name|spud
argument_list|(
name|sl
argument_list|,
name|sboxes
argument_list|)
expr_stmt|;
name|spud
argument_list|(
name|dl
argument_list|,
name|dboxes
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* reverse horizontal banding */
block|{
name|spudd
argument_list|(
name|sl
argument_list|,
name|sboxes
argument_list|)
expr_stmt|;
name|spudd
argument_list|(
name|dl
argument_list|,
name|dboxes
argument_list|)
expr_stmt|;
block|}
name|ScreenToScreen
argument_list|(
name|pSrcDrawable
argument_list|,
name|pGC
argument_list|,
name|srcx
argument_list|,
name|srcy
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|sl
argument_list|,
name|sboxes
argument_list|,
name|dl
argument_list|,
name|dboxes
argument_list|,
name|stx
argument_list|,
name|sty
argument_list|,
name|dtx
argument_list|,
name|dty
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sl
argument_list|)
expr_stmt|;
block|}
else|else
name|ScreenToScreen
argument_list|(
name|pSrcDrawable
argument_list|,
name|pGC
argument_list|,
name|srcx
argument_list|,
name|srcy
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|scl
argument_list|,
name|sboxes
argument_list|,
name|dcl
argument_list|,
name|dboxes
argument_list|,
name|stx
argument_list|,
name|sty
argument_list|,
name|dtx
argument_list|,
name|dty
argument_list|)
expr_stmt|;
comment|/* let miHandleExposures() handle all the exposure stuff 'cause      *   it knows lots more than I do.  It also sends noExpose      *   events if needbe.      * Note: Other CopyAreas use (cfbPrivGC *)(pGC->devPriv))->fExpose      *   instead of pGC->graphicsExposures.  This is because      *   mfbPutImage is brain damaged and since HP don't use it, I      *   can use graphicsExposures.      */
if|if
condition|(
name|pGC
operator|->
name|graphicsExposures
condition|)
name|prgnExposed
operator|=
name|miHandleExposures
argument_list|(
name|pSrcDrawable
argument_list|,
name|pDstDrawable
argument_list|,
name|pGC
argument_list|,
name|xIn
argument_list|,
name|yIn
argument_list|,
name|widthSrc
argument_list|,
name|heightSrc
argument_list|,
name|xOut
argument_list|,
name|yOut
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sHitList
condition|)
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|RegionDestroy
call|)
argument_list|(
name|sHitList
argument_list|)
expr_stmt|;
return|return
name|prgnExposed
return|;
block|}
end_function

begin_comment
comment|/* HPFBCOPYAREA -- "public" entry for the CopyArea request   * For requests operating within a single topcat frame buffer.  * For each rectangle in the source region  *   move rectangle using topcat pixel mover hardware  */
end_comment

begin_function
specifier|static
name|RegionPtr
name|hpfbCopyArea
parameter_list|(
name|pSrcDrawable
parameter_list|,
name|pDstDrawable
parameter_list|,
name|pGC
parameter_list|,
name|xIn
parameter_list|,
name|yIn
parameter_list|,
name|widthSrc
parameter_list|,
name|heightSrc
parameter_list|,
name|xOut
parameter_list|,
name|yOut
parameter_list|)
specifier|register
name|DrawablePtr
name|pSrcDrawable
decl_stmt|;
specifier|register
name|DrawablePtr
name|pDstDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|xIn
decl_stmt|,
name|yIn
decl_stmt|;
name|int
name|widthSrc
decl_stmt|,
name|heightSrc
decl_stmt|;
name|int
name|xOut
decl_stmt|,
name|yOut
decl_stmt|;
block|{
name|DDXPointPtr
name|ppt
decl_stmt|,
name|pptFirst
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pwidthFirst
decl_stmt|,
modifier|*
name|pwidth
decl_stmt|,
modifier|*
name|pbits
decl_stmt|;
name|BoxRec
name|srcBox
decl_stmt|,
modifier|*
name|prect
decl_stmt|;
comment|/* may be a new region, or just a copy */
name|RegionPtr
name|prgnSrcClip
decl_stmt|,
name|prgnDstClip
decl_stmt|;
comment|/* non-0 if we've created a src clip */
name|int
name|realSrcClip
init|=
literal|0
decl_stmt|,
name|useOrdering
init|=
literal|0
decl_stmt|;
name|int
name|srcx
decl_stmt|,
name|srcy
decl_stmt|,
name|dstx
decl_stmt|,
name|dsty
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|,
name|xMin
decl_stmt|,
name|xMax
decl_stmt|,
name|yMin
decl_stmt|,
name|yMax
decl_stmt|;
name|unsigned
name|int
modifier|*
name|ordering
decl_stmt|;
name|RegionPtr
name|prgnExposed
decl_stmt|;
name|int
name|numRects
decl_stmt|;
name|BoxPtr
name|boxes
decl_stmt|;
comment|/* clip the left and top edges of the source */
if|if
condition|(
name|xIn
operator|<
literal|0
condition|)
block|{
name|widthSrc
operator|+=
name|xIn
expr_stmt|;
name|srcx
operator|=
name|pSrcDrawable
operator|->
name|x
expr_stmt|;
block|}
else|else
name|srcx
operator|=
name|xIn
operator|+
name|pSrcDrawable
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|yIn
operator|<
literal|0
condition|)
block|{
name|heightSrc
operator|+=
name|yIn
expr_stmt|;
name|srcy
operator|=
name|pSrcDrawable
operator|->
name|y
expr_stmt|;
block|}
else|else
name|srcy
operator|=
name|yIn
operator|+
name|pSrcDrawable
operator|->
name|y
expr_stmt|;
comment|/* If the destination isn't realized, this is easy */
if|if
condition|(
operator|(
name|pDstDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|WindowPtr
operator|)
name|pDstDrawable
operator|)
operator|->
name|realized
operator|)
condition|)
return|return
operator|(
name|RegionPtr
operator|)
name|NULL
return|;
comment|/* clip the source */
if|if
condition|(
name|pSrcDrawable
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
condition|)
block|{
name|BoxRec
name|box
decl_stmt|;
name|box
operator|.
name|x1
operator|=
name|pSrcDrawable
operator|->
name|x
expr_stmt|;
name|box
operator|.
name|y1
operator|=
name|pSrcDrawable
operator|->
name|y
expr_stmt|;
name|box
operator|.
name|x2
operator|=
name|pSrcDrawable
operator|->
name|x
operator|+
operator|(
name|int
operator|)
name|pSrcDrawable
operator|->
name|width
expr_stmt|;
name|box
operator|.
name|y2
operator|=
name|pSrcDrawable
operator|->
name|y
operator|+
operator|(
name|int
operator|)
name|pSrcDrawable
operator|->
name|height
expr_stmt|;
name|prgnSrcClip
operator|=
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|RegionCreate
call|)
argument_list|(
operator|&
name|box
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|realSrcClip
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|prgnSrcClip
operator|=
operator|&
operator|(
operator|(
name|WindowPtr
operator|)
name|pSrcDrawable
operator|)
operator|->
name|clipList
expr_stmt|;
name|srcBox
operator|.
name|x1
operator|=
name|srcx
expr_stmt|;
name|srcBox
operator|.
name|y1
operator|=
name|srcy
expr_stmt|;
name|srcBox
operator|.
name|x2
operator|=
name|srcx
operator|+
name|widthSrc
expr_stmt|;
name|srcBox
operator|.
name|y2
operator|=
name|srcy
operator|+
name|heightSrc
expr_stmt|;
name|dstx
operator|=
name|xOut
expr_stmt|;
name|dsty
operator|=
name|yOut
expr_stmt|;
if|if
condition|(
name|pGC
operator|->
name|miTranslate
condition|)
block|{
name|dstx
operator|+=
name|pDstDrawable
operator|->
name|x
expr_stmt|;
name|dsty
operator|+=
name|pDstDrawable
operator|->
name|y
expr_stmt|;
block|}
name|prgnDstClip
operator|=
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
expr_stmt|;
name|numRects
operator|=
name|REGION_NUM_RECTS
argument_list|(
name|prgnSrcClip
argument_list|)
expr_stmt|;
name|boxes
operator|=
name|REGION_RECTS
argument_list|(
name|prgnSrcClip
argument_list|)
expr_stmt|;
name|ordering
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|numRects
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ordering
condition|)
return|return
operator|(
name|RegionPtr
operator|)
name|NULL
return|;
comment|/* If not the same drawable then order of move doesn't matter.        Following assumes that boxes are sorted from top        to bottom and left to right.     */
if|if
condition|(
name|pSrcDrawable
operator|!=
name|pDstDrawable
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numRects
condition|;
name|i
operator|++
control|)
name|ordering
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
else|else
block|{
comment|/* within same drawable, must sequence moves carefully! */
name|useOrdering
operator|=
literal|1
expr_stmt|;
comment|/* must pay attention to this ordering later! */
if|if
condition|(
name|dsty
operator|<=
name|srcBox
operator|.
name|y1
condition|)
block|{
comment|/* Scroll up or stationary vertical. 				   Vertical order OK */
if|if
condition|(
name|dstx
operator|<=
name|srcBox
operator|.
name|x1
condition|)
comment|/* Scroll left or stationary horizontal. 				      Horizontal order OK as well */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numRects
condition|;
name|i
operator|++
control|)
name|ordering
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
else|else
block|{
comment|/* scroll right. must reverse horizontal banding of rects. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|1
operator|,
name|xMax
operator|=
literal|0
init|;
name|i
operator|<
name|numRects
condition|;
name|j
operator|=
name|i
operator|+
literal|1
operator|,
name|xMax
operator|=
name|i
control|)
block|{
comment|/* find extent of current horizontal band */
name|y
operator|=
name|boxes
index|[
name|i
index|]
operator|.
name|y1
expr_stmt|;
comment|/* band has this y coordinate */
while|while
condition|(
operator|(
name|j
operator|<
name|numRects
operator|)
operator|&&
operator|(
name|boxes
index|[
name|j
index|]
operator|.
name|y1
operator|==
name|y
operator|)
condition|)
name|j
operator|++
expr_stmt|;
comment|/* reverse the horizontal band in the output ordering */
for|for
control|(
name|j
operator|--
init|;
name|j
operator|>=
name|xMax
condition|;
name|j
operator|--
operator|,
name|i
operator|++
control|)
name|ordering
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Scroll down. Must reverse vertical banding. */
if|if
condition|(
name|dstx
operator|<
name|srcBox
operator|.
name|x1
condition|)
block|{
comment|/* Scroll left. Horizontal order OK. */
for|for
control|(
name|i
operator|=
name|numRects
operator|-
literal|1
operator|,
name|j
operator|=
name|i
operator|-
literal|1
operator|,
name|yMin
operator|=
name|i
operator|,
name|yMax
operator|=
literal|0
init|;
name|i
operator|>=
literal|0
condition|;
name|j
operator|=
name|i
operator|-
literal|1
operator|,
name|yMin
operator|=
name|i
control|)
block|{
comment|/* find extent of current horizontal band */
name|y
operator|=
name|boxes
index|[
name|i
index|]
operator|.
name|y1
expr_stmt|;
comment|/* band has this y coordinate */
while|while
condition|(
operator|(
name|j
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|boxes
index|[
name|j
index|]
operator|.
name|y1
operator|==
name|y
operator|)
condition|)
name|j
operator|--
expr_stmt|;
comment|/* reverse the horizontal band in the output ordering */
for|for
control|(
name|j
operator|++
init|;
name|j
operator|<=
name|yMin
condition|;
name|j
operator|++
operator|,
name|i
operator|--
operator|,
name|yMax
operator|++
control|)
name|ordering
index|[
name|yMax
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
else|else
comment|/* Scroll right or horizontal stationary. 		    Reverse horizontal order as well (if stationary, horizontal 		    order can be swapped without penalty and this is faster 		    to compute). */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|numRects
operator|-
literal|1
init|;
name|i
operator|<
name|numRects
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
name|ordering
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|pSrcDrawable
operator|->
name|pScreen
operator|==
name|pDstDrawable
operator|->
name|pScreen
operator|)
operator|&&
operator|(
operator|(
operator|(
name|pSrcDrawable
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
operator|)
operator|&&
operator|(
operator|(
operator|(
name|PixmapPtr
operator|)
name|pSrcDrawable
operator|)
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
operator|)
operator|)
operator|||
operator|(
name|pSrcDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|pDstDrawable
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
operator|)
operator|&&
operator|(
operator|(
operator|(
name|PixmapPtr
operator|)
name|pDstDrawable
operator|)
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
operator|)
operator|)
operator|||
operator|(
name|pDstDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
operator|)
operator|)
condition|)
block|{
comment|/* Copy area within portions of a single screens frame buffer. 	 * For each visible portion of source, move into visible 	 * portions of destination utilizing area mover. 	 */
name|BoxRec
name|dstBox
decl_stmt|,
modifier|*
name|prect2
decl_stmt|;
name|int
name|sxMin
decl_stmt|,
name|sxMax
decl_stmt|,
name|syMin
decl_stmt|,
name|syMax
decl_stmt|,
comment|/* source for actual move */
name|dxMin
decl_stmt|,
name|dxMax
decl_stmt|,
name|dyMin
decl_stmt|,
name|dyMax
decl_stmt|;
comment|/* dest for actual move */
specifier|register
name|hpPrivScreenPtr
name|pPrivScreen
decl_stmt|;
name|void
argument_list|(
operator|*
name|bitMover
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|maskConfig
argument_list|)
argument_list|()
decl_stmt|;
name|pPrivScreen
operator|=
name|getPrivScreenPtr
argument_list|(
name|pGC
operator|->
name|pScreen
argument_list|)
expr_stmt|;
name|bitMover
operator|=
name|pPrivScreen
operator|->
name|MoveBits
expr_stmt|;
name|maskConfig
operator|=
name|pPrivScreen
operator|->
name|MaskConfig
expr_stmt|;
if|if
condition|(
name|pSrcDrawable
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
condition|)
block|{
comment|/* make screen relative */
specifier|register
name|hpChunk
modifier|*
name|pixChunk
init|=
operator|(
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
operator|(
operator|(
name|PixmapPtr
operator|)
name|pSrcDrawable
operator|)
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
operator|)
operator|->
name|pChunk
decl_stmt|;
name|boxes
index|[
literal|0
index|]
operator|.
name|x1
operator|+=
name|pixChunk
operator|->
name|x
expr_stmt|;
name|boxes
index|[
literal|0
index|]
operator|.
name|y1
operator|+=
name|pixChunk
operator|->
name|y
expr_stmt|;
name|boxes
index|[
literal|0
index|]
operator|.
name|x2
operator|+=
name|pixChunk
operator|->
name|x
expr_stmt|;
name|boxes
index|[
literal|0
index|]
operator|.
name|y2
operator|+=
name|pixChunk
operator|->
name|y
expr_stmt|;
name|srcBox
operator|.
name|x1
operator|+=
name|pixChunk
operator|->
name|x
expr_stmt|;
name|srcBox
operator|.
name|y1
operator|+=
name|pixChunk
operator|->
name|y
expr_stmt|;
name|srcBox
operator|.
name|x2
operator|+=
name|pixChunk
operator|->
name|x
expr_stmt|;
name|srcBox
operator|.
name|y2
operator|+=
name|pixChunk
operator|->
name|y
expr_stmt|;
name|srcx
operator|+=
name|pixChunk
operator|->
name|x
expr_stmt|;
name|srcy
operator|+=
name|pixChunk
operator|->
name|y
expr_stmt|;
block|}
if|if
condition|(
name|pDstDrawable
operator|->
name|type
operator|==
name|DRAWABLE_PIXMAP
condition|)
block|{
comment|/* make screen relative */
specifier|register
name|hpChunk
modifier|*
name|pixChunk
init|=
operator|(
name|hpChunk
operator|*
operator|)
operator|(
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
operator|(
operator|(
name|PixmapPtr
operator|)
name|pDstDrawable
operator|)
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
operator|)
operator|->
name|pChunk
decl_stmt|;
name|REGION_RECTS
argument_list|(
name|prgnDstClip
argument_list|)
index|[
literal|0
index|]
operator|.
name|x1
operator|+=
name|pixChunk
operator|->
name|x
expr_stmt|;
name|REGION_RECTS
argument_list|(
name|prgnDstClip
argument_list|)
index|[
literal|0
index|]
operator|.
name|y1
operator|+=
name|pixChunk
operator|->
name|y
expr_stmt|;
name|REGION_RECTS
argument_list|(
name|prgnDstClip
argument_list|)
index|[
literal|0
index|]
operator|.
name|x2
operator|+=
name|pixChunk
operator|->
name|x
expr_stmt|;
name|REGION_RECTS
argument_list|(
name|prgnDstClip
argument_list|)
index|[
literal|0
index|]
operator|.
name|y2
operator|+=
name|pixChunk
operator|->
name|y
expr_stmt|;
name|dstx
operator|+=
name|pixChunk
operator|->
name|x
expr_stmt|;
name|dsty
operator|+=
name|pixChunk
operator|->
name|y
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numRects
condition|;
name|i
operator|++
control|)
block|{
name|prect
operator|=
operator|&
name|boxes
index|[
name|ordering
index|[
name|i
index|]
index|]
expr_stmt|;
comment|/* find portion of move contained in this visible portion of window */
name|xMin
operator|=
name|max
argument_list|(
name|prect
operator|->
name|x1
argument_list|,
name|srcBox
operator|.
name|x1
argument_list|)
expr_stmt|;
name|xMax
operator|=
name|min
argument_list|(
name|prect
operator|->
name|x2
argument_list|,
name|srcBox
operator|.
name|x2
argument_list|)
expr_stmt|;
name|yMin
operator|=
name|max
argument_list|(
name|prect
operator|->
name|y1
argument_list|,
name|srcBox
operator|.
name|y1
argument_list|)
expr_stmt|;
name|yMax
operator|=
name|min
argument_list|(
name|prect
operator|->
name|y2
argument_list|,
name|srcBox
operator|.
name|y2
argument_list|)
expr_stmt|;
comment|/* exit loop unless there is something visible */
if|if
condition|(
name|xMax
operator|<=
name|xMin
operator|||
name|yMax
operator|<=
name|yMin
condition|)
continue|continue;
comment|/* destination box for visible portion of source */
name|dstBox
operator|.
name|x1
operator|=
name|xMin
operator|-
operator|(
name|srcx
operator|-
name|dstx
operator|)
expr_stmt|;
name|dstBox
operator|.
name|y1
operator|=
name|yMin
operator|-
operator|(
name|srcy
operator|-
name|dsty
operator|)
expr_stmt|;
name|dstBox
operator|.
name|x2
operator|=
name|dstBox
operator|.
name|x1
operator|+
name|xMax
operator|-
name|xMin
expr_stmt|;
name|dstBox
operator|.
name|y2
operator|=
name|dstBox
operator|.
name|y1
operator|+
name|yMax
operator|-
name|yMin
expr_stmt|;
comment|/* find visible portions of destination */
name|prect2
operator|=
name|REGION_RECTS
argument_list|(
name|prgnDstClip
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGION_NUM_RECTS
argument_list|(
name|prgnDstClip
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|useOrdering
condition|)
name|prect2
operator|=
operator|&
name|REGION_RECTS
argument_list|(
name|prgnDstClip
argument_list|)
index|[
name|ordering
index|[
name|j
index|]
index|]
expr_stmt|;
else|else
name|prect2
operator|=
operator|&
name|REGION_RECTS
argument_list|(
name|prgnDstClip
argument_list|)
index|[
name|j
index|]
expr_stmt|;
name|dxMin
operator|=
name|max
argument_list|(
name|prect2
operator|->
name|x1
argument_list|,
name|dstBox
operator|.
name|x1
argument_list|)
expr_stmt|;
name|dxMax
operator|=
name|min
argument_list|(
name|prect2
operator|->
name|x2
argument_list|,
name|dstBox
operator|.
name|x2
argument_list|)
expr_stmt|;
name|dyMin
operator|=
name|max
argument_list|(
name|prect2
operator|->
name|y1
argument_list|,
name|dstBox
operator|.
name|y1
argument_list|)
expr_stmt|;
name|dyMax
operator|=
name|min
argument_list|(
name|prect2
operator|->
name|y2
argument_list|,
name|dstBox
operator|.
name|y2
argument_list|)
expr_stmt|;
comment|/* any portion of destination visible in this area? */
if|if
condition|(
name|dxMax
operator|<=
name|dxMin
operator|||
name|dyMax
operator|<=
name|dyMin
condition|)
continue|continue;
comment|/* will further clip source if destination was also clipped */
name|sxMin
operator|=
name|xMin
operator|+
name|max
argument_list|(
operator|(
name|prect2
operator|->
name|x1
operator|-
name|dstBox
operator|.
name|x1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|syMin
operator|=
name|yMin
operator|+
name|max
argument_list|(
operator|(
name|prect2
operator|->
name|y1
operator|-
name|dstBox
operator|.
name|y1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sxMax
operator|=
name|xMax
operator|+
name|min
argument_list|(
operator|(
name|prect2
operator|->
name|x2
operator|-
name|dstBox
operator|.
name|x2
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|syMax
operator|=
name|yMax
operator|+
name|min
argument_list|(
operator|(
name|prect2
operator|->
name|y2
operator|-
name|dstBox
operator|.
name|y2
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|bitMover
call|)
argument_list|(
name|pGC
operator|->
name|pScreen
argument_list|,
name|pGC
operator|->
name|planemask
argument_list|,
name|pGC
operator|->
name|alu
argument_list|,
name|sxMin
argument_list|,
name|syMin
argument_list|,
name|dxMin
argument_list|,
name|dyMin
argument_list|,
operator|(
name|sxMax
operator|-
name|sxMin
operator|)
argument_list|,
operator|(
name|syMax
operator|-
name|syMin
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* no place for hardware assist */
name|pptFirst
operator|=
name|ppt
operator|=
operator|(
name|DDXPointPtr
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|heightSrc
operator|*
sizeof|sizeof
argument_list|(
name|DDXPointRec
argument_list|)
argument_list|)
expr_stmt|;
name|pwidthFirst
operator|=
name|pwidth
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|heightSrc
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pptFirst
operator|||
operator|!
name|pwidthFirst
condition|)
block|{
name|DEALLOCATE_LOCAL
argument_list|(
name|ordering
argument_list|)
expr_stmt|;
if|if
condition|(
name|pptFirst
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pptFirst
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwidthFirst
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidthFirst
argument_list|)
expr_stmt|;
return|return
operator|(
name|RegionPtr
operator|)
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numRects
condition|;
name|i
operator|++
control|)
block|{
name|prect
operator|=
operator|&
name|boxes
index|[
name|ordering
index|[
name|i
index|]
index|]
expr_stmt|;
name|xMin
operator|=
name|max
argument_list|(
name|prect
operator|->
name|x1
argument_list|,
name|srcBox
operator|.
name|x1
argument_list|)
expr_stmt|;
name|xMax
operator|=
name|min
argument_list|(
name|prect
operator|->
name|x2
argument_list|,
name|srcBox
operator|.
name|x2
argument_list|)
expr_stmt|;
name|yMin
operator|=
name|max
argument_list|(
name|prect
operator|->
name|y1
argument_list|,
name|srcBox
operator|.
name|y1
argument_list|)
expr_stmt|;
name|yMax
operator|=
name|min
argument_list|(
name|prect
operator|->
name|y2
argument_list|,
name|srcBox
operator|.
name|y2
argument_list|)
expr_stmt|;
comment|/* is there anything visible here? */
if|if
condition|(
name|xMax
operator|<=
name|xMin
operator|||
name|yMax
operator|<=
name|yMin
condition|)
continue|continue;
name|ppt
operator|=
name|pptFirst
expr_stmt|;
name|pwidth
operator|=
name|pwidthFirst
expr_stmt|;
name|y
operator|=
name|yMin
expr_stmt|;
name|height
operator|=
name|yMax
operator|-
name|yMin
expr_stmt|;
name|width
operator|=
name|xMax
operator|-
name|xMin
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|height
condition|;
name|j
operator|++
control|)
block|{
name|ppt
operator|->
name|x
operator|=
name|xMin
expr_stmt|;
name|ppt
operator|++
operator|->
name|y
operator|=
name|y
operator|++
expr_stmt|;
operator|*
name|pwidth
operator|++
operator|=
name|width
expr_stmt|;
block|}
name|pbits
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|xalloc
argument_list|(
name|height
operator|*
name|PixmapBytePad
argument_list|(
name|width
argument_list|,
name|pSrcDrawable
operator|->
name|depth
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbits
condition|)
block|{
call|(
modifier|*
name|pSrcDrawable
operator|->
name|pScreen
operator|->
name|GetSpans
call|)
argument_list|(
name|pSrcDrawable
argument_list|,
name|width
argument_list|,
name|pptFirst
argument_list|,
name|pwidthFirst
argument_list|,
name|height
argument_list|,
name|pbits
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pptFirst
expr_stmt|;
name|pwidth
operator|=
name|pwidthFirst
expr_stmt|;
name|xMin
operator|-=
operator|(
name|srcx
operator|-
name|dstx
operator|)
expr_stmt|;
name|y
operator|=
name|yMin
operator|-
operator|(
name|srcy
operator|-
name|dsty
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|height
condition|;
name|j
operator|++
control|)
block|{
name|ppt
operator|->
name|x
operator|=
name|xMin
expr_stmt|;
name|ppt
operator|++
operator|->
name|y
operator|=
name|y
operator|++
expr_stmt|;
operator|*
name|pwidth
operator|++
operator|=
name|width
expr_stmt|;
block|}
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|SetSpans
call|)
argument_list|(
name|pDstDrawable
argument_list|,
name|pGC
argument_list|,
name|pbits
argument_list|,
name|pptFirst
argument_list|,
name|pwidthFirst
argument_list|,
name|height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|pbits
argument_list|)
expr_stmt|;
block|}
block|}
name|DEALLOCATE_LOCAL
argument_list|(
name|pptFirst
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidthFirst
argument_list|)
expr_stmt|;
block|}
name|DEALLOCATE_LOCAL
argument_list|(
name|ordering
argument_list|)
expr_stmt|;
name|prgnExposed
operator|=
name|miHandleExposures
argument_list|(
name|pSrcDrawable
argument_list|,
name|pDstDrawable
argument_list|,
name|pGC
argument_list|,
name|xIn
argument_list|,
name|yIn
argument_list|,
name|widthSrc
argument_list|,
name|heightSrc
argument_list|,
name|xOut
argument_list|,
name|yOut
argument_list|,
operator|(
name|unsigned
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|realSrcClip
condition|)
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|RegionDestroy
call|)
argument_list|(
name|prgnSrcClip
argument_list|)
expr_stmt|;
return|return
name|prgnExposed
return|;
block|}
end_function

end_unit

