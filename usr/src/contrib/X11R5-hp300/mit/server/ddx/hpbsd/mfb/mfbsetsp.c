begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Combined Purdue/PurduePlus patches, level 2.0, 1/17/89 */
end_comment

begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* $XConsortium: mfbsetsp.c,v 5.3 89/09/13 18:58:28 rws Exp $ */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"mfb.h"
end_include

begin_include
include|#
directive|include
file|"maskbits.h"
end_include

begin_include
include|#
directive|include
file|"servermd.h"
end_include

begin_comment
comment|/* mfbSetScanline -- copies the bits from psrc to the drawable starting at  * (xStart, y) and continuing to (xEnd, y).  xOrigin tells us where psrc   * starts on the scanline. (I.e., if this scanline passes through multiple  * boxes, we may not want to start grabbing bits at psrc but at some offset  * further on.)   */
end_comment

begin_macro
name|mfbSetScanline
argument_list|(
argument|y
argument_list|,
argument|xOrigin
argument_list|,
argument|xStart
argument_list|,
argument|xEnd
argument_list|,
argument|psrc
argument_list|,
argument|alu
argument_list|,
argument|pdstBase
argument_list|,
argument|widthDst
argument_list|)
end_macro

begin_decl_stmt
name|int
name|y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xOrigin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where this scanline starts */
end_comment

begin_decl_stmt
name|int
name|xStart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first bit to use from scanline */
end_comment

begin_decl_stmt
name|int
name|xEnd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last bit to use from scanline + 1 */
end_comment

begin_decl_stmt
specifier|register
name|int
modifier|*
name|psrc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|alu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* raster op */
end_comment

begin_decl_stmt
name|int
modifier|*
name|pdstBase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of the drawable */
end_comment

begin_decl_stmt
name|int
name|widthDst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of drawable in words */
end_comment

begin_block
block|{
name|int
name|w
decl_stmt|;
comment|/* width of scanline in bits */
specifier|register
name|int
modifier|*
name|pdst
decl_stmt|;
comment|/* where to put the bits */
specifier|register
name|int
name|tmpSrc
decl_stmt|;
comment|/* scratch buffer to collect bits in */
name|int
name|dstBit
decl_stmt|;
comment|/* offset in bits from beginning of  					 * word */
specifier|register
name|int
name|nstart
decl_stmt|;
comment|/* number of bits from first partial */
specifier|register
name|int
name|nend
decl_stmt|;
comment|/* " " last partial word */
name|int
name|offSrc
decl_stmt|;
name|int
name|startmask
decl_stmt|,
name|endmask
decl_stmt|,
name|nlMiddle
decl_stmt|,
name|nl
decl_stmt|;
name|pdst
operator|=
name|pdstBase
operator|+
operator|(
name|y
operator|*
name|widthDst
operator|)
operator|+
operator|(
name|xStart
operator|>>
literal|5
operator|)
expr_stmt|;
name|psrc
operator|+=
operator|(
name|xStart
operator|-
name|xOrigin
operator|)
operator|>>
literal|5
expr_stmt|;
name|offSrc
operator|=
operator|(
name|xStart
operator|-
name|xOrigin
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|w
operator|=
name|xEnd
operator|-
name|xStart
expr_stmt|;
name|dstBit
operator|=
name|xStart
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|dstBit
operator|+
name|w
operator|<=
literal|32
condition|)
block|{
name|getandputrop
argument_list|(
argument|psrc
argument_list|,
argument|offSrc
argument_list|,
argument|dstBit
argument_list|,
argument|w
argument_list|,
argument|pdst
argument_list|,
argument|alu
argument_list|)
block|}
else|else
block|{
name|maskbits
argument_list|(
name|xStart
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|,
name|endmask
argument_list|,
name|nlMiddle
argument_list|)
expr_stmt|;
if|if
condition|(
name|startmask
condition|)
name|nstart
operator|=
literal|32
operator|-
name|dstBit
expr_stmt|;
else|else
name|nstart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|endmask
condition|)
name|nend
operator|=
name|xEnd
operator|&
literal|0x1f
expr_stmt|;
else|else
name|nend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|startmask
condition|)
block|{
name|getandputrop
argument_list|(
argument|psrc
argument_list|,
argument|offSrc
argument_list|,
argument|dstBit
argument_list|,
argument|nstart
argument_list|,
argument|pdst
argument_list|,
argument|alu
argument_list|)
name|pdst
operator|++
expr_stmt|;
name|offSrc
operator|+=
name|nstart
expr_stmt|;
if|if
condition|(
name|offSrc
operator|>
literal|31
condition|)
block|{
name|psrc
operator|++
expr_stmt|;
name|offSrc
operator|-=
literal|32
expr_stmt|;
block|}
block|}
name|nl
operator|=
name|nlMiddle
expr_stmt|;
while|while
condition|(
name|nl
operator|--
condition|)
block|{
name|getbits
argument_list|(
name|psrc
argument_list|,
name|offSrc
argument_list|,
literal|32
argument_list|,
name|tmpSrc
argument_list|)
expr_stmt|;
name|DoRop
argument_list|(
operator|*
name|pdst
argument_list|,
name|alu
argument_list|,
name|tmpSrc
argument_list|,
operator|*
name|pdst
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
name|psrc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|endmask
condition|)
block|{
name|getandputrop0
argument_list|(
name|psrc
argument_list|,
name|offSrc
argument_list|,
name|nend
argument_list|,
name|pdst
argument_list|,
name|alu
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* SetSpans -- for each span copy pwidth[i] bits from psrc to pDrawable at  * ppt[i] using the raster op from the GC.  If fSorted is TRUE, the scanlines  * are in increasing Y order.  * Source bit lines are server scanline padded so that they always begin  * on a word boundary.  */
end_comment

begin_function
name|void
name|mfbSetSpans
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|psrc
parameter_list|,
name|ppt
parameter_list|,
name|pwidth
parameter_list|,
name|nspans
parameter_list|,
name|fSorted
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
modifier|*
name|psrc
decl_stmt|;
specifier|register
name|DDXPointPtr
name|ppt
decl_stmt|;
name|int
modifier|*
name|pwidth
decl_stmt|;
name|int
name|nspans
decl_stmt|;
name|int
name|fSorted
decl_stmt|;
block|{
name|int
modifier|*
name|pdstBase
decl_stmt|;
comment|/* start of dst bitmap */
name|int
name|widthDst
decl_stmt|;
comment|/* width of bitmap in words */
specifier|register
name|BoxPtr
name|pbox
decl_stmt|,
name|pboxLast
decl_stmt|,
name|pboxTest
decl_stmt|;
specifier|register
name|DDXPointPtr
name|pptLast
decl_stmt|;
name|int
name|alu
decl_stmt|;
name|RegionPtr
name|prgnDst
decl_stmt|;
name|int
name|xStart
decl_stmt|,
name|xEnd
decl_stmt|;
name|int
name|yMax
decl_stmt|;
name|alu
operator|=
name|pGC
operator|->
name|alu
expr_stmt|;
name|prgnDst
operator|=
operator|(
operator|(
name|mfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|mfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
expr_stmt|;
name|pptLast
operator|=
name|ppt
operator|+
name|nspans
expr_stmt|;
name|yMax
operator|=
name|pDrawable
operator|->
name|y
operator|+
operator|(
name|int
operator|)
name|pDrawable
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|pDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
block|{
name|pdstBase
operator|=
operator|(
name|int
operator|*
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
operator|->
name|bits
expr_stmt|;
name|widthDst
operator|=
operator|(
name|int
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
block|}
else|else
block|{
name|pdstBase
operator|=
operator|(
name|int
operator|*
operator|)
name|getPrivPixmapPtr
argument_list|(
name|pDrawable
argument_list|)
operator|->
name|bits
expr_stmt|;
name|widthDst
operator|=
operator|(
name|int
operator|)
name|getPrivPixmapPtr
argument_list|(
name|pDrawable
argument_list|)
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
block|}
name|pbox
operator|=
name|REGION_RECTS
argument_list|(
name|prgnDst
argument_list|)
expr_stmt|;
name|pboxLast
operator|=
name|pbox
operator|+
name|REGION_NUM_RECTS
argument_list|(
name|prgnDst
argument_list|)
expr_stmt|;
if|if
condition|(
name|fSorted
condition|)
block|{
comment|/* scan lines sorted in ascending order. Because they are sorted, we      * don't have to check each scanline against each clip box.  We can be      * sure that this scanline only has to be clipped to boxes at or after the      * beginning of this y-band       */
name|pboxTest
operator|=
name|pbox
expr_stmt|;
while|while
condition|(
name|ppt
operator|<
name|pptLast
condition|)
block|{
name|pbox
operator|=
name|pboxTest
expr_stmt|;
if|if
condition|(
name|ppt
operator|->
name|y
operator|>=
name|yMax
condition|)
break|break;
while|while
condition|(
name|pbox
operator|<
name|pboxLast
condition|)
block|{
if|if
condition|(
name|pbox
operator|->
name|y1
operator|>
name|ppt
operator|->
name|y
condition|)
block|{
comment|/* scanline is before clip box */
break|break;
block|}
elseif|else
if|if
condition|(
name|pbox
operator|->
name|y2
operator|<=
name|ppt
operator|->
name|y
condition|)
block|{
comment|/* clip box is before scanline */
name|pboxTest
operator|=
operator|++
name|pbox
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|pbox
operator|->
name|x1
operator|>
name|ppt
operator|->
name|x
operator|+
operator|*
name|pwidth
condition|)
block|{
comment|/* clip box is to right of scanline */
break|break;
block|}
elseif|else
if|if
condition|(
name|pbox
operator|->
name|x2
operator|<=
name|ppt
operator|->
name|x
condition|)
block|{
comment|/* scanline is to right of clip box */
name|pbox
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* at least some of the scanline is in the current clip box */
name|xStart
operator|=
name|max
argument_list|(
name|pbox
operator|->
name|x1
argument_list|,
name|ppt
operator|->
name|x
argument_list|)
expr_stmt|;
name|xEnd
operator|=
name|min
argument_list|(
name|ppt
operator|->
name|x
operator|+
operator|*
name|pwidth
argument_list|,
name|pbox
operator|->
name|x2
argument_list|)
expr_stmt|;
name|mfbSetScanline
argument_list|(
name|ppt
operator|->
name|y
argument_list|,
name|ppt
operator|->
name|x
argument_list|,
name|xStart
argument_list|,
name|xEnd
argument_list|,
name|psrc
argument_list|,
name|alu
argument_list|,
name|pdstBase
argument_list|,
name|widthDst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppt
operator|->
name|x
operator|+
operator|*
name|pwidth
operator|<=
name|pbox
operator|->
name|x2
condition|)
block|{
comment|/* End of the line, as it were */
break|break;
block|}
else|else
name|pbox
operator|++
expr_stmt|;
block|}
comment|/* We've tried this line against every box; it must be outside them 	     * all.  move on to the next point */
name|ppt
operator|++
expr_stmt|;
name|psrc
operator|+=
name|PixmapWidthInPadUnits
argument_list|(
operator|*
name|pwidth
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pwidth
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* scan lines not sorted. We must clip each line against all the boxes */
while|while
condition|(
name|ppt
operator|<
name|pptLast
condition|)
block|{
if|if
condition|(
name|ppt
operator|->
name|y
operator|>=
literal|0
operator|&&
name|ppt
operator|->
name|y
operator|<
name|yMax
condition|)
block|{
for|for
control|(
name|pbox
operator|=
name|REGION_RECTS
argument_list|(
name|prgnDst
argument_list|)
init|;
name|pbox
operator|<
name|pboxLast
condition|;
name|pbox
operator|++
control|)
block|{
if|if
condition|(
name|pbox
operator|->
name|y1
operator|>
name|ppt
operator|->
name|y
condition|)
block|{
comment|/* rest of clip region is above this scanline, 			 * skip it */
break|break;
block|}
if|if
condition|(
name|pbox
operator|->
name|y2
operator|<=
name|ppt
operator|->
name|y
condition|)
block|{
comment|/* clip box is below scanline */
name|pbox
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pbox
operator|->
name|x1
operator|<=
name|ppt
operator|->
name|x
operator|+
operator|*
name|pwidth
operator|&&
name|pbox
operator|->
name|x2
operator|>
name|ppt
operator|->
name|x
condition|)
block|{
name|xStart
operator|=
name|max
argument_list|(
name|pbox
operator|->
name|x1
argument_list|,
name|ppt
operator|->
name|x
argument_list|)
expr_stmt|;
name|xEnd
operator|=
name|min
argument_list|(
name|pbox
operator|->
name|x2
argument_list|,
name|ppt
operator|->
name|x
operator|+
operator|*
name|pwidth
argument_list|)
expr_stmt|;
name|mfbSetScanline
argument_list|(
name|ppt
operator|->
name|y
argument_list|,
name|ppt
operator|->
name|x
argument_list|,
name|xStart
argument_list|,
name|xEnd
argument_list|,
name|psrc
argument_list|,
name|alu
argument_list|,
name|pdstBase
argument_list|,
name|widthDst
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|psrc
operator|+=
name|PixmapWidthInPadUnits
argument_list|(
operator|*
name|pwidth
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ppt
operator|++
expr_stmt|;
name|pwidth
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

