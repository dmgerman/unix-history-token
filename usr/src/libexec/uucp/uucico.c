begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* uucico.c    This is the main UUCP communication program.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: uucico.c,v $    Revision 1.92  1992/04/06  21:10:14  ian    Marc Boucher: set *pqsys to NULL in faccept_call     Revision 1.91  1992/03/30  04:07:13  ian    Dirk Musstopf: remove temporary file if receive fails     Revision 1.90  1992/03/28  22:06:38  ian    Michael I Bushnell: renamed enum tstatus to avoid header file conflict     Revision 1.89  1992/03/28  20:52:11  ian    Petri Helenius: must dump controlling terminal when going to next alternate     Revision 1.88  1992/03/28  20:31:55  ian    Franc,ois Pinard: allow a name to be given to an alternate     Revision 1.87  1992/03/28  19:40:26  ian    Close log and statistics file at each master/slave role switch     Revision 1.86  1992/03/28  04:45:31  ian    Mark E. Mallett: minor cleanup     Revision 1.85  1992/03/17  18:42:21  ian    T. William Wells: set current time in status file when call completes     Revision 1.84  1992/03/17  01:03:03  ian    Miscellaneous cleanup     Revision 1.83  1992/03/16  05:16:03  ian    Recognize SVR4 -U flag     Revision 1.82  1992/03/16  04:38:00  ian    Turn off DEBUG_PORT for handshake debugging     Revision 1.81  1992/03/15  04:51:17  ian    Keep an array of signals we've received rather than a single variable     Revision 1.80  1992/03/12  19:54:43  ian    Debugging based on types rather than number     Revision 1.79  1992/03/11  19:53:55  ian    Improved chat script debugging     Revision 1.78  1992/03/11  00:18:50  ian    Save temporary file if file send fails     Revision 1.77  1992/03/10  23:01:20  ian    Don't run uuxqt if we got a SIGTERM     Revision 1.76  1992/03/10  21:47:39  ian    Added protocol command for ports     Revision 1.75  1992/03/09  20:14:37  ian    Ted Lindgreen: added max-remote-debug command     Revision 1.74  1992/03/09  19:52:50  ian    Ted Lindgreen: strip parity from initial handshake strings     Revision 1.73  1992/03/09  19:42:43  ian    Ted Lindgreen: don't send mail for nonexistent file     Revision 1.72  1992/03/09  05:37:10  ian    Only look for hangup string in debugging mode     Revision 1.71  1992/03/09  05:29:20  ian    Ted Lindgreen: report requested grade on an incoming call     Revision 1.70  1992/03/09  05:08:16  ian    Added status for wrong time to call, not used if system can't be called     Revision 1.69  1992/03/08  17:45:41  ian    Ted Lindgreen: start uuxqt for only one system if appropriate     Revision 1.68  1992/03/08  17:08:20  ian    Ted Lindgreen: ignore -u option     Revision 1.67  1992/03/08  16:42:41  ian    Ted Lindgreen: report port and login name in log file     Revision 1.66  1992/03/07  02:56:30  ian    Rewrote time routines     Revision 1.65  1992/03/04  15:05:51  ian    Michael Haberler: some systems send \n after Shere     Revision 1.64  1992/03/04  00:36:44  ian    Michael Richardson: better chat script debugging     Revision 1.63  1992/03/03  21:01:20  ian    Use strict timeout in fsserial_read, eliminate all race conditions     Revision 1.62  1992/03/03  06:06:48  ian    T. William Wells: don't complain about missing configuration files     Revision 1.61  1992/02/29  04:07:08  ian    Added -j option to uucp and uux     Revision 1.60  1992/02/29  01:06:59  ian    Chip Salzenberg: recheck file permissions before sending     Revision 1.59  1992/02/27  05:40:54  ian    T. William Wells: detach from controlling terminal, handle signals safely     Revision 1.58  1992/02/24  22:38:45  ian    Don't treat an extra argument as a port     Revision 1.57  1992/02/24  04:58:47  ian    Only permit files to be received into directories that are world-writeable     Revision 1.56  1992/02/23  19:50:50  ian    Handle READ and WRITE in Permissions correctly     Revision 1.55  1992/02/23  03:26:51  ian    Overhaul to use automatic configure shell script     Revision 1.54  1992/02/20  22:57:19  ian    Chip Salzenberg: some systems truncate the Shere= machine name     Revision 1.53  1992/02/19  19:36:07  ian    Rearranged time functions     Revision 1.52  1992/02/14  21:32:50  ian    Niels Baggesen: under HAVE_BNU_LOGGING, don't lost system name when dieing     Revision 1.51  1992/02/09  05:21:55  ian    Bob Denny: call fmail_transfer before fsysdep_did_work     Revision 1.50  1992/02/08  22:33:32  ian    Only get the current working directory if it's going to be needed     Revision 1.49  1992/02/08  20:33:57  ian    Handle all possible signals raised by abort     Revision 1.48  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.47  1992/02/07  17:08:15  ian    Bob Denny: retry time not reached is not an error     Revision 1.46  1992/01/29  18:37:27  ian    Patrick Smith: only wait a short time for the hangup message     Revision 1.45  1992/01/28  04:34:10  ian    Marty Shannon: -f uucp flag not handled correctly     Revision 1.44  1992/01/28  03:50:42  ian    Chip Salzenberg: set .Status correctly if wrong time to call     Revision 1.43  1992/01/21  19:39:12  ian    Chip Salzenberg: uucp and uux start uucico for right system, not any     Revision 1.42  1992/01/20  16:44:54  ian    Marty Shannon: update .Status file if it's the wrong time to call     Revision 1.41  1992/01/19  02:27:00  ian    Marty Shannon: update .Status file on incoming calls     Revision 1.40  1992/01/18  22:48:53  ian    Reworked sending of mail and general handling of failed transfers     Revision 1.39  1992/01/15  07:06:29  ian    Set configuration directory in Makefile rather than sysdep.h     Revision 1.38  1992/01/14  04:38:43  ian    Chip Salzenberg: only declare sportinfo if it will be used     Revision 1.37  1992/01/12  19:53:05  ian    John Antypas: pass in sportinfo structure for fdo_call to use     Revision 1.36  1992/01/05  03:09:17  ian    Changed abProgram and abVersion to non const to avoid compiler bug     Revision 1.35  1992/01/04  21:53:36  ian    Start up uuxqt even if a call fails     Revision 1.34  1991/12/31  19:43:13  ian    Added 'e' protocol     Revision 1.33  1991/12/28  04:33:09  ian    Set fmasterdone correctly in slave mode     Revision 1.32  1991/12/23  05:15:54  ian    David Nugent: set debugging level for a specific system     Revision 1.31  1991/12/21  23:10:43  ian    Terry Gardner: record failed file transfers in statistics file     Revision 1.30  1991/12/21  22:17:20  ian    Change protocol ordering to 't', 'g', 'f'     Revision 1.29  1991/12/21  22:07:47  ian    John Theus: don't warn if port file does not exist     Revision 1.28  1991/12/20  04:30:24  ian    Terry Gardner: record conversation time in log file     Revision 1.27  1991/12/20  00:42:24  ian    Clear user name from error message given by getting next command     Revision 1.26  1991/12/18  05:12:00  ian    Added -l option to uucico to prompt for login name once and then exit     Revision 1.25  1991/12/18  03:54:14  ian    Made error messages to terminal appear more normal     Revision 1.24  1991/12/17  04:55:01  ian    David Nugent: ignore SIGHUP in uucico and uuxqt     Revision 1.23  1991/12/15  03:42:33  ian    Added tprocess_chat_cmd for all chat commands, and added CMDTABTYPE_PREFIX     Revision 1.22  1991/12/11  03:59:19  ian    Create directories when necessary; don't just assume they exist     Revision 1.21  1991/11/21  22:17:06  ian    Add version string, print version when printing usage     Revision 1.20  1991/11/16  00:33:28  ian    Remove ?: operator between string literal and variable     Revision 1.19  1991/11/14  03:40:10  ian    Try to figure out whether stdin is a TCP port     Revision 1.18  1991/11/14  03:20:13  ian    Added seven-bit and reliable commands to help when selecting protocols     Revision 1.17  1991/11/13  23:08:40  ian    Expand remote pathnames in uucp and uux; fix up uux special cases     Revision 1.16  1991/11/12  19:47:04  ian    Add called-chat set of commands to run a chat script on an incoming call     Revision 1.15  1991/11/12  18:25:33  ian    Added 't' protocol     Revision 1.14  1991/11/11  23:47:24  ian    Added chat-program to run a program to do a chat script     Revision 1.13  1991/11/11  19:32:03  ian    Added breceive_char to read characters through protocol buffering     Revision 1.12  1991/11/11  18:55:52  ian    Get protocol parameters from port and dialer for incoming calls     Revision 1.11  1991/11/11  16:59:05  ian    Eliminate fread_port_info, allow NULL pflock arg to ffind_port     Revision 1.10  1991/11/11  04:21:16  ian    Added 'f' protocol     Revision 1.9  1991/11/10  19:24:22  ian    Added pffile protocol entry point for file level control     Revision 1.8  1991/11/09  18:53:07  ian    Reworked protocol interface     Revision 1.7  1991/11/07  18:15:38  ian    Chip Salzenberg: move CMAXRETRIES to conf.h for easy configuration     Revision 1.6  1991/09/19  03:06:04  ian    Chip Salzenberg: put BNU temporary files in system's directory     Revision 1.5  1991/09/19  02:30:37  ian    From Chip Salzenberg: check whether signal is ignored differently     Revision 1.4  1991/09/19  02:22:44  ian    Chip Salzenberg's patch to allow ";retrytime" at the end of a time string     Revision 1.3  1991/09/12  05:04:26  ian    Changed sense of \0 return from btime_low_grade on calltimegrade     Revision 1.2  1991/09/11  02:33:14  ian    Added ffork argument to fsysdep_run       Revision 1.1  1991/09/10  19:40:31  ian    Initial revision       */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|uucico_rcsid
index|[]
init|=
literal|"$Id: uucico.c,v 1.92 1992/04/06 21:10:14 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"uutime.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The program name.  */
end_comment

begin_decl_stmt
name|char
name|abProgram
index|[]
init|=
literal|"uucico"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the known protocols.    bname, ffullduplex, qcmds, pfstart, pfshutdown, pfsendcmd, pzgetspace,    pfsenddata, pfprocess, pfwait, pffile  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sprotocol
name|asProtocols
index|[]
init|=
block|{
block|{
literal|'t'
block|,
name|FALSE
block|,
name|RELIABLE_ENDTOEND
operator||
name|RELIABLE_RELIABLE
operator||
name|RELIABLE_EIGHT
block|,
name|asTproto_params
block|,
name|ftstart
block|,
name|ftshutdown
block|,
name|ftsendcmd
block|,
name|ztgetspace
block|,
name|ftsenddata
block|,
name|ftprocess
block|,
name|ftwait
block|,
name|ftfile
block|}
block|,
block|{
literal|'e'
block|,
name|FALSE
block|,
name|RELIABLE_ENDTOEND
operator||
name|RELIABLE_RELIABLE
operator||
name|RELIABLE_EIGHT
block|,
name|asEproto_params
block|,
name|festart
block|,
name|feshutdown
block|,
name|fesendcmd
block|,
name|zegetspace
block|,
name|fesenddata
block|,
name|feprocess
block|,
name|fewait
block|,
name|fefile
block|}
block|,
block|{
literal|'g'
block|,
name|FALSE
block|,
name|RELIABLE_EIGHT
block|,
name|asGproto_params
block|,
name|fgstart
block|,
name|fgshutdown
block|,
name|fgsendcmd
block|,
name|zggetspace
block|,
name|fgsenddata
block|,
name|fgprocess
block|,
name|fgwait
block|,
name|NULL
block|}
block|,
block|{
literal|'f'
block|,
name|FALSE
block|,
name|RELIABLE_RELIABLE
block|,
name|asFproto_params
block|,
name|ffstart
block|,
name|ffshutdown
block|,
name|ffsendcmd
block|,
name|zfgetspace
block|,
name|ffsenddata
block|,
name|ffprocess
block|,
name|ffwait
block|,
name|fffile
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CPROTOCOLS
value|(sizeof asProtocols / sizeof asProtocols[0])
end_define

begin_comment
comment|/* Locked system.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLocked_system
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ssysteminfo
name|sLocked_system
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|uusage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uabort
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcall
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
expr|struct
name|sport
operator|*
name|qport
operator|,
name|boolean
name|fforce
operator|,
name|int
name|bgrade
operator|,
name|boolean
name|fnodetach
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fdo_call
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
expr|struct
name|sport
operator|*
name|qport
operator|,
expr|struct
name|sstatus
operator|*
name|qstat
operator|,
name|int
name|cretry
operator|,
name|boolean
operator|*
name|pfcalled
operator|,
expr|struct
name|sport
operator|*
name|quse
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcall_failed
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
expr|enum
name|tstatus_type
name|twhy
operator|,
expr|struct
name|sstatus
operator|*
name|qstat
operator|,
name|int
name|cretry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|flogin_prompt
name|P
argument_list|(
operator|(
expr|struct
name|sport
operator|*
name|qport
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|faccept_call
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zlogin
operator|,
expr|struct
name|sport
operator|*
name|qport
operator|,
specifier|const
expr|struct
name|ssysteminfo
operator|*
operator|*
name|pqsys
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fuucp
name|P
argument_list|(
operator|(
name|boolean
name|fmaster
operator|,
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
name|int
name|bgrade
operator|,
name|boolean
name|fnew
operator|,
name|long
name|cmax_receive
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fdo_xcmd
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
name|boolean
name|fcaller
operator|,
specifier|const
expr|struct
name|scmd
operator|*
name|qcmd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fok_to_send
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfrom
operator|,
name|boolean
name|flocal
operator|,
name|boolean
name|fcaller
operator|,
name|boolean
name|fspool
operator|,
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
specifier|const
name|char
operator|*
name|zuser
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fok_to_receive
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zto
operator|,
name|boolean
name|flocal
operator|,
name|boolean
name|fcaller
operator|,
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
specifier|const
name|char
operator|*
name|zuser
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|frequest_ok
name|P
argument_list|(
operator|(
name|boolean
name|flocal
operator|,
name|boolean
name|fcaller
operator|,
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
specifier|const
name|char
operator|*
name|zuser
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsend_uucp_cmd
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|z
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zget_uucp_cmd
name|P
argument_list|(
operator|(
name|boolean
name|frequired
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zget_typed_line
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Long getopt options.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|asLongopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|option
modifier|*
name|_getopt_long_options
init|=
name|asLongopts
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
comment|/* getopt return value  */
name|int
name|iopt
decl_stmt|;
comment|/* Don't detach from controlling terminal.  */
name|boolean
name|fnodetach
init|=
name|FALSE
decl_stmt|;
comment|/* Configuration file name  */
specifier|const
name|char
modifier|*
name|zconfig
init|=
name|NULL
decl_stmt|;
comment|/* System to call  */
specifier|const
name|char
modifier|*
name|zsystem
init|=
name|NULL
decl_stmt|;
comment|/* Port to use; in master mode, call out on this port.  In slave mode,      accept logins on this port.  If port not specified, then in master      mode figure it out for each system, and in slave mode use stdin and      stdout.  */
specifier|const
name|char
modifier|*
name|zport
init|=
name|NULL
decl_stmt|;
comment|/* Port information for the port name in zport.  */
name|struct
name|sport
name|sportinfo
decl_stmt|;
comment|/* Pointer to port to use, or NULL if unknown.  */
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
comment|/* Whether to start uuxqt when done.  */
name|boolean
name|fuuxqt
init|=
name|TRUE
decl_stmt|;
comment|/* Whether to force a call despite status of previous call  */
name|boolean
name|fforce
init|=
name|FALSE
decl_stmt|;
comment|/* Whether we are the master  */
name|boolean
name|fmaster
init|=
name|FALSE
decl_stmt|;
comment|/* Whether to give a single login prompt.  */
name|boolean
name|flogin
init|=
name|FALSE
decl_stmt|;
comment|/* Whether to do an endless loop of accepting calls  */
name|boolean
name|floop
init|=
name|FALSE
decl_stmt|;
comment|/* Whether to wait for an inbound call after doing an outbound call  */
name|boolean
name|fwait
init|=
name|FALSE
decl_stmt|;
name|boolean
name|fret
init|=
name|TRUE
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|int
name|iholddebug
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|iopt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"DefI:lp:qr:s:S:u:x:X:w"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|iopt
condition|)
block|{
case|case
literal|'D'
case|:
comment|/* Don't detach from controlling terminal.  */
name|fnodetach
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* Do an endless loop of accepting calls.  */
name|floop
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Force a call even if it hasn't been long enough since the last 	     failed call.  */
name|fforce
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Set configuration file name (default is in sysdep.h).  */
name|zconfig
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Prompt for login name and password.  */
name|flogin
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Port to use  */
name|zport
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* Don't start uuxqt.  */
name|fuuxqt
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Set mode: -r1 for master, -r0 for slave (default)  */
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'1'
operator|&&
name|optarg
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|fmaster
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|optarg
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|fmaster
operator|=
name|FALSE
expr_stmt|;
else|else
name|uusage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Set system name  */
name|zsystem
operator|=
name|optarg
expr_stmt|;
name|fmaster
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Set system name and force call like -f  */
name|zsystem
operator|=
name|optarg
expr_stmt|;
name|fforce
operator|=
name|TRUE
expr_stmt|;
name|fmaster
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Some versions of uucpd invoke uucico with a -u argument 	     specifying the login name.  I'm told it is safe to ignore 	     this value, although perhaps we should use it rather than 	     zsysdep_login_name ().  */
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* Set debugging level  */
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'w'
case|:
comment|/* Call out and then wait for a call in  */
name|fwait
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Long option found, and flag value set.  */
break|break;
default|default:
name|uusage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|!=
name|argc
condition|)
name|uusage
argument_list|()
expr_stmt|;
if|if
condition|(
name|fwait
operator|&&
name|zport
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -w requires -e\n"
argument_list|,
name|abProgram
argument_list|)
expr_stmt|;
name|uusage
argument_list|()
expr_stmt|;
block|}
name|uread_config
argument_list|(
name|zconfig
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGINT
name|usysdep_signal
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|usysdep_signal
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|usysdep_signal
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|usysdep_signal
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|usysdep_signal
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usysdep_initialize
argument_list|(
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ulog_to_file
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ulog_fatal_fn
argument_list|(
name|uabort
argument_list|)
expr_stmt|;
comment|/* If a port was named, get its information.  */
if|if
condition|(
name|zport
operator|==
name|NULL
condition|)
name|qport
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|ffind_port
argument_list|(
name|zport
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
operator|&
name|sportinfo
argument_list|,
operator|(
name|boolean
argument_list|(
argument|*
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|sport
operator|*
operator|,
name|boolean
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: No such port"
argument_list|,
name|zport
argument_list|)
expr_stmt|;
name|ulog_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|qport
operator|=
operator|&
name|sportinfo
expr_stmt|;
block|}
if|if
condition|(
name|fmaster
condition|)
block|{
comment|/* If a system was named, call it up.  Otherwise check all the 	 known systems, and call all the ones which have work to do.  */
if|if
condition|(
name|zsystem
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fread_system_info
argument_list|(
name|zsystem
argument_list|,
operator|&
name|sLocked_system
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Unknown system %s"
argument_list|,
name|zsystem
argument_list|)
expr_stmt|;
comment|/* Detach from the controlling terminal for the call.  This 	     probably makes sense only on Unix.  We want the modem 	     line to become the controlling terminal.  */
if|if
condition|(
operator|!
name|fnodetach
operator|&&
operator|(
name|qport
operator|==
name|NULL
operator|||
name|qport
operator|->
name|ttype
operator|!=
name|PORTTYPE_STDIN
operator|)
condition|)
name|usysdep_detach
argument_list|()
expr_stmt|;
name|ulog_system
argument_list|(
name|sLocked_system
operator|.
name|zname
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iholddebug
operator|=
name|iDebug
expr_stmt|;
name|iDebug
operator||=
name|sLocked_system
operator|.
name|idebug
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fsysdep_lock_system
argument_list|(
operator|&
name|sLocked_system
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"System already locked"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|fLocked_system
operator|=
name|TRUE
expr_stmt|;
name|fret
operator|=
name|fcall
argument_list|(
operator|&
name|sLocked_system
argument_list|,
name|qport
argument_list|,
name|fforce
argument_list|,
name|BGRADE_HIGH
argument_list|,
name|fnodetach
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_unlock_system
argument_list|(
operator|&
name|sLocked_system
argument_list|)
expr_stmt|;
name|fLocked_system
operator|=
name|FALSE
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iDebug
operator|=
name|iholddebug
expr_stmt|;
endif|#
directive|endif
name|ulog_system
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|csystems
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|pas
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|bgrade
decl_stmt|;
name|boolean
name|fdidone
decl_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
name|fdidone
operator|=
name|FALSE
expr_stmt|;
name|uread_all_system_info
argument_list|(
operator|&
name|csystems
argument_list|,
operator|&
name|pas
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|csystems
operator|&&
operator|!
name|FGOT_SIGNAL
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fsysdep_has_work
argument_list|(
operator|&
name|pas
index|[
name|i
index|]
argument_list|,
operator|&
name|bgrade
argument_list|)
condition|)
block|{
name|fdidone
operator|=
name|TRUE
expr_stmt|;
comment|/* Detach from the controlling terminal.  On Unix 		     this means that we will wind up forking a new 		     process for each system we call.  */
if|if
condition|(
operator|!
name|fnodetach
operator|&&
operator|(
name|qport
operator|==
name|NULL
operator|||
name|qport
operator|->
name|ttype
operator|!=
name|PORTTYPE_STDIN
operator|)
condition|)
name|usysdep_detach
argument_list|()
expr_stmt|;
name|ulog_system
argument_list|(
name|pas
index|[
name|i
index|]
operator|.
name|zname
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iholddebug
operator|=
name|iDebug
expr_stmt|;
name|iDebug
operator||=
name|pas
index|[
name|i
index|]
operator|.
name|idebug
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fsysdep_lock_system
argument_list|(
operator|&
name|pas
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"System already locked"
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|sLocked_system
operator|=
name|pas
index|[
name|i
index|]
expr_stmt|;
name|fLocked_system
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fcall
argument_list|(
operator|&
name|pas
index|[
name|i
index|]
argument_list|,
name|qport
argument_list|,
name|fforce
argument_list|,
name|bgrade
argument_list|,
name|fnodetach
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
comment|/* Now ignore any SIGHUP that we got.  */
name|afSignal
index|[
name|INDEXSIG_SIGHUP
index|]
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_unlock_system
argument_list|(
operator|&
name|pas
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fLocked_system
operator|=
name|FALSE
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iDebug
operator|=
name|iholddebug
expr_stmt|;
endif|#
directive|endif
name|ulog_system
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fdidone
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"No work"
argument_list|)
expr_stmt|;
block|}
comment|/* If requested, wait for calls after dialing out.  */
if|if
condition|(
name|fwait
condition|)
block|{
name|floop
operator|=
name|TRUE
expr_stmt|;
name|fmaster
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fmaster
condition|)
block|{
comment|/* If a port was specified by name, we go into endless loop 	 mode.  In this mode, we wait for calls and prompt them with 	 "login:" and "Password:", so that they think we are a regular 	 UNIX system.  If we aren't in endless loop mode, we have been 	 called by some other system.  If flogin is TRUE, we prompt 	 with "login:" and "Password:" a single time.  */
name|fret
operator|=
name|TRUE
expr_stmt|;
name|zsystem
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|qport
operator|!=
name|NULL
condition|)
block|{
comment|/* Detach from the controlling terminal, so that the port we 	     are about to use becomes our controlling terminal.  */
if|if
condition|(
operator|!
name|fnodetach
operator|&&
name|qport
operator|->
name|ttype
operator|!=
name|PORTTYPE_STDIN
condition|)
name|usysdep_detach
argument_list|()
expr_stmt|;
name|floop
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fport_lock
argument_list|(
name|qport
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Port %s is locked"
argument_list|,
name|qport
operator|->
name|zname
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fret
condition|)
block|{
if|if
condition|(
operator|!
name|fport_open
argument_list|(
name|qport
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
name|TRUE
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|fret
condition|)
block|{
if|if
condition|(
name|floop
condition|)
block|{
while|while
condition|(
operator|!
name|FGOT_SIGNAL
argument_list|()
operator|&&
name|flogin_prompt
argument_list|(
name|qport
argument_list|)
condition|)
block|{
comment|/* Now ignore any SIGHUP that we got.  */
name|afSignal
index|[
name|INDEXSIG_SIGHUP
index|]
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fLocked_system
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_unlock_system
argument_list|(
operator|&
name|sLocked_system
argument_list|)
expr_stmt|;
name|fLocked_system
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fport_reset
argument_list|()
condition|)
break|break;
block|}
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flogin
condition|)
name|fret
operator|=
name|flogin_prompt
argument_list|(
name|qport
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iholddebug
operator|=
name|iDebug
expr_stmt|;
endif|#
directive|endif
name|fret
operator|=
name|faccept_call
argument_list|(
name|zsysdep_login_name
argument_list|()
argument_list|,
name|qport
argument_list|,
operator|&
name|qsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsys
operator|!=
name|NULL
condition|)
name|zsystem
operator|=
name|qsys
operator|->
name|zname
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iDebug
operator|=
name|iholddebug
expr_stmt|;
endif|#
directive|endif
block|}
block|}
operator|(
name|void
operator|)
name|fport_close
argument_list|(
name|fret
argument_list|)
expr_stmt|;
if|if
condition|(
name|fLocked_system
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_unlock_system
argument_list|(
operator|&
name|sLocked_system
argument_list|)
expr_stmt|;
name|fLocked_system
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
name|ulog_close
argument_list|()
expr_stmt|;
name|ustats_close
argument_list|()
expr_stmt|;
comment|/* If we got a SIGTERM, perhaps because the system is going down,      don't run uuxqt.  We go ahead and run it for any other signal,      since I think they indicate more temporary conditions.  */
if|if
condition|(
name|afSignal
index|[
name|INDEXSIG_SIGTERM
index|]
condition|)
name|fuuxqt
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fuuxqt
condition|)
block|{
comment|/* Detach from the controlling terminal before starting up uuxqt, 	 so that it runs as a true daemon.  */
if|if
condition|(
operator|!
name|fnodetach
condition|)
name|usysdep_detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|zsystem
operator|==
name|NULL
condition|)
name|fret
operator|=
name|fsysdep_run
argument_list|(
name|FALSE
argument_list|,
literal|"uuxqt"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|fret
operator|=
name|fsysdep_run
argument_list|(
name|FALSE
argument_list|,
literal|"uuxqt"
argument_list|,
literal|"-s"
argument_list|,
name|zsystem
argument_list|)
expr_stmt|;
block|}
name|usysdep_exit
argument_list|(
name|fret
argument_list|)
expr_stmt|;
comment|/* Avoid complaints about not returning.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print out a usage message.  */
end_comment

begin_function
specifier|static
name|void
name|uusage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Taylor UUCP version %s, copyright (C) 1991, 1992 Ian Lance Taylor\n"
argument_list|,
name|abVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: uucico [options]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -s,-S system: Call system (-S implies -f)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -f: Force call despite system status\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -r state: 1 for master, 0 for slave (default)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -p port: Specify port (implies -e)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -l: prompt for login name and password\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -e: Endless loop of login prompts and daemon execution\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -w: After calling out, wait for incoming calls\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -q: Don't start uuxqt when done\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -x,-X debug: Set debugging level\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -I file: Set configuration file to use (default %s%s)\n"
argument_list|,
name|NEWCONFIGLIB
argument_list|,
name|CONFIGFILE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called when a LOG_FATAL error occurs.  */
end_comment

begin_function
specifier|static
name|void
name|uabort
parameter_list|()
block|{
name|ustats_failed
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_BNU_LOGGING
comment|/* When using BNU logging, it's a pain to have no system name.  */
name|ulog_system
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|qPort
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fport_close
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fLocked_system
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_unlock_system
argument_list|(
operator|&
name|sLocked_system
argument_list|)
expr_stmt|;
name|fLocked_system
operator|=
name|FALSE
expr_stmt|;
block|}
name|ulog_close
argument_list|()
expr_stmt|;
name|ustats_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call another system, trying all the possible sets of calling    instructions.  The fprepare_call function should already have been    called.  The qsys argument is the system to call.  The qport    argument is the port to use, and may be NULL.  If the fforce    argument is TRUE, a call is forced even if not enough time has    passed since the last failed call.  The bgrade argument is the    highest grade of work to be done for the system.  The qstat    argument holds the status of the system.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcall
parameter_list|(
name|qsys
parameter_list|,
name|qport
parameter_list|,
name|fforce
parameter_list|,
name|bgrade
parameter_list|,
name|fnodetach
parameter_list|)
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
name|boolean
name|fforce
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
name|boolean
name|fnodetach
decl_stmt|;
block|{
name|boolean
name|fbadtime
decl_stmt|,
name|fnevertime
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qorigsys
decl_stmt|;
name|struct
name|sstatus
name|sstat
decl_stmt|;
name|qorigsys
operator|=
name|qsys
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_get_status
argument_list|(
name|qorigsys
argument_list|,
operator|&
name|sstat
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Make sure it's been long enough since the last failed call.  */
if|if
condition|(
operator|!
name|fforce
condition|)
block|{
ifdef|#
directive|ifdef
name|CMAXRETRIES
if|#
directive|if
name|CMAXRETRIES
operator|>
literal|0
if|if
condition|(
name|sstat
operator|.
name|cretries
operator|>=
name|CMAXRETRIES
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Too many retries"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
comment|/* CMAXRETRIES> 0 */
endif|#
directive|endif
comment|/* defined (CMAXRETRIES) */
if|if
condition|(
name|sstat
operator|.
name|ttype
operator|!=
name|STATUS_COMPLETE
operator|&&
name|sstat
operator|.
name|ilast
operator|+
name|sstat
operator|.
name|cwait
operator|>
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Retry time not reached"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|fbadtime
operator|=
name|TRUE
expr_stmt|;
name|fnevertime
operator|=
name|TRUE
expr_stmt|;
do|do
block|{
name|struct
name|sspan
modifier|*
name|qtime
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qnext
decl_stmt|;
name|qtime
operator|=
name|qtimegrade_parse
argument_list|(
name|qsys
operator|->
name|ztime
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtime
operator|!=
name|NULL
condition|)
block|{
name|long
name|ival
decl_stmt|;
name|int
name|cretry
decl_stmt|;
name|boolean
name|fmatch
decl_stmt|;
name|fnevertime
operator|=
name|FALSE
expr_stmt|;
comment|/* The value returned in ival by fspan_match is the lowest 	     grade which may be done at this time.  */
name|fmatch
operator|=
operator|(
name|ftimespan_match
argument_list|(
name|qtime
argument_list|,
operator|&
name|ival
argument_list|,
operator|&
name|cretry
argument_list|)
operator|&&
name|igradecmp
argument_list|(
name|bgrade
argument_list|,
operator|(
name|int
operator|)
name|ival
argument_list|)
operator|<=
literal|0
operator|)
expr_stmt|;
name|utimespan_free
argument_list|(
name|qtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmatch
condition|)
block|{
name|boolean
name|fret
decl_stmt|,
name|fcalled
decl_stmt|;
name|struct
name|sport
name|sportinfo
decl_stmt|;
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
return|return
name|FALSE
return|;
name|fbadtime
operator|=
name|FALSE
expr_stmt|;
name|fret
operator|=
name|fdo_call
argument_list|(
name|qsys
argument_list|,
name|qport
argument_list|,
operator|&
name|sstat
argument_list|,
name|cretry
argument_list|,
operator|&
name|fcalled
argument_list|,
operator|&
name|sportinfo
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fport_close
argument_list|(
name|fret
argument_list|)
expr_stmt|;
if|if
condition|(
name|fret
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|fcalled
condition|)
return|return
name|FALSE
return|;
comment|/* Now we have to dump that port so that we can aquire a 		 new one.  */
if|if
condition|(
operator|!
name|fnodetach
condition|)
name|usysdep_detach
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Look for the next alternate with different calling 	 instructions.  */
name|qnext
operator|=
name|qsys
expr_stmt|;
do|do
block|{
name|qnext
operator|=
name|qnext
operator|->
name|qalternate
expr_stmt|;
block|}
do|while
condition|(
name|qnext
operator|!=
name|NULL
operator|&&
name|qsys
operator|->
name|ztime
operator|==
name|qnext
operator|->
name|ztime
operator|&&
name|qsys
operator|->
name|zport
operator|==
name|qnext
operator|->
name|zport
operator|&&
name|qsys
operator|->
name|qport
operator|==
name|qnext
operator|->
name|qport
operator|&&
name|qsys
operator|->
name|ibaud
operator|==
name|qnext
operator|->
name|ibaud
operator|&&
name|qsys
operator|->
name|zphone
operator|==
name|qnext
operator|->
name|zphone
operator|&&
name|qsys
operator|->
name|schat
operator|.
name|zprogram
operator|==
name|qnext
operator|->
name|schat
operator|.
name|zprogram
operator|&&
name|qsys
operator|->
name|schat
operator|.
name|zchat
operator|==
name|qnext
operator|->
name|schat
operator|.
name|zchat
condition|)
do|;
name|qsys
operator|=
name|qnext
expr_stmt|;
block|}
do|while
condition|(
name|qsys
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|fbadtime
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Wrong time to call"
argument_list|)
expr_stmt|;
comment|/* Update the status, unless the system can never be called.  If 	 the system can never be called, there is little point to 	 putting in a ``wrong time to call'' message.  We don't change 	 the number of retries, although we do set the wait until the 	 next retry to 0.  */
if|if
condition|(
operator|!
name|fnevertime
condition|)
block|{
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_WRONG_TIME
expr_stmt|;
name|sstat
operator|.
name|ilast
operator|=
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|cwait
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qorigsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Do the actual work of calling another system, such as dialing and    logging in.  The qsys argument is the system to call, the qport    argument is the port to use, and the qstat argument holds the    current status of the ssystem.  If we log in successfully, set    *pfcalled to TRUE; this is used to distinguish a failed dial from a    failure during the call.  The quse argument is passed in because    this function does not call fport_close, so if it reads in a port    structure to open it must not keep it on the stack.  */
end_comment

begin_function
specifier|static
name|boolean
name|fdo_call
parameter_list|(
name|qsys
parameter_list|,
name|qport
parameter_list|,
name|qstat
parameter_list|,
name|cretry
parameter_list|,
name|pfcalled
parameter_list|,
name|quse
parameter_list|)
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
name|struct
name|sstatus
modifier|*
name|qstat
decl_stmt|;
name|int
name|cretry
decl_stmt|;
name|boolean
modifier|*
name|pfcalled
decl_stmt|;
name|struct
name|sport
modifier|*
name|quse
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zstr
decl_stmt|;
name|boolean
name|fnew
decl_stmt|;
name|int
name|cdial_proto_params
decl_stmt|;
name|struct
name|sproto_param
modifier|*
name|qdial_proto_params
decl_stmt|;
name|int
name|idial_reliable
decl_stmt|;
name|long
name|istart_time
decl_stmt|;
operator|*
name|pfcalled
operator|=
name|FALSE
expr_stmt|;
comment|/* If no port was specified on the command line, use any port      defined for the system.  To select the system port: 1) see if      port information was specified directly; 2) see if a port was      named; 3) get an available port given the baud rate.  We don't      change the system status if a port is unavailable; i.e. we don't      force the system to wait for the retry time.  */
if|if
condition|(
name|qport
operator|==
name|NULL
condition|)
name|qport
operator|=
name|qsys
operator|->
name|qport
expr_stmt|;
if|if
condition|(
name|qport
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fport_lock
argument_list|(
name|qport
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Port \"%s\" already locked"
argument_list|,
name|qport
operator|->
name|zname
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ffind_port
argument_list|(
name|qsys
operator|->
name|zport
argument_list|,
name|qsys
operator|->
name|ibaud
argument_list|,
name|qsys
operator|->
name|ihighbaud
argument_list|,
name|quse
argument_list|,
name|fport_lock
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|qport
operator|=
name|quse
expr_stmt|;
comment|/* The port is locked by ffind_port.  */
block|}
comment|/* Now try to call the system.  */
if|if
condition|(
operator|!
name|fport_open
argument_list|(
name|qport
argument_list|,
name|qsys
operator|->
name|ibaud
argument_list|,
name|qsys
operator|->
name|ihighbaud
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_PORT_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|qsys
operator|->
name|zalternate
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Calling system %s (port %s)"
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|zLdevice
operator|==
name|NULL
condition|?
literal|"unknown"
else|:
name|zLdevice
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Calling system %s (alternate %s, port %s)"
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|qsys
operator|->
name|zalternate
argument_list|,
name|zLdevice
operator|==
name|NULL
condition|?
literal|"unknown"
else|:
name|zLdevice
argument_list|)
expr_stmt|;
name|cdial_proto_params
operator|=
literal|0
expr_stmt|;
name|qdial_proto_params
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|fport_dial
argument_list|(
name|qsys
argument_list|,
operator|&
name|cdial_proto_params
argument_list|,
operator|&
name|qdial_proto_params
argument_list|,
operator|&
name|idial_reliable
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_DIAL_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|fchat
argument_list|(
operator|&
name|qsys
operator|->
name|schat
argument_list|,
name|qsys
argument_list|,
operator|(
specifier|const
expr|struct
name|sdialer
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|qPort
operator|->
name|zname
argument_list|,
name|iport_baud
argument_list|()
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_LOGIN_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qstat
operator|->
name|ttype
operator|=
name|STATUS_TALKING
expr_stmt|;
name|qstat
operator|->
name|ilast
operator|=
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|qstat
operator|->
name|cretries
operator|=
literal|0
expr_stmt|;
name|qstat
operator|->
name|cwait
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
name|qstat
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Login successful"
argument_list|)
expr_stmt|;
operator|*
name|pfcalled
operator|=
name|TRUE
expr_stmt|;
name|istart_time
operator|=
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* We should now see "Shere" from the other system.  Apparently      some systems send "Shere=foo" where foo is the remote name.  */
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_HANDSHAKE_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|zstr
argument_list|,
literal|"Shere"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_HANDSHAKE_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad initialization string"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zstr
index|[
literal|5
index|]
operator|==
literal|'='
condition|)
block|{
specifier|const
name|char
modifier|*
name|zheresys
decl_stmt|;
name|int
name|icmp
decl_stmt|;
comment|/* Some UUCP packages only provide seven characters in the Shere 	 machine name.  */
name|zheresys
operator|=
name|zstr
operator|+
literal|6
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|zheresys
argument_list|)
operator|==
literal|7
condition|)
name|icmp
operator|=
name|strncmp
argument_list|(
name|zheresys
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
literal|7
argument_list|)
expr_stmt|;
else|else
name|icmp
operator|=
name|strcmp
argument_list|(
name|zheresys
argument_list|,
name|qsys
operator|->
name|zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmp
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_HANDSHAKE_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Called wrong system (%s)"
argument_list|,
name|zheresys
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
elseif|else
if|if
condition|(
name|zstr
index|[
literal|5
index|]
operator|!=
literal|'\0'
condition|)
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|,
literal|"fdo_call: Strange Shere: %s"
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We now send "S" name switches, where name is our UUCP name.  If      we are using sequence numbers with this system, we send a -Q      argument with the sequence number.  If the call-timegrade command      was used, we send a -p argument and a -vgrade= argument with the      grade to send us (we send both argument to make it more likely      that one is recognized).  We always send a -N (for new) switch to      indicate that we are prepared to accept file sizes.  */
block|{
name|char
name|bgrade
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuse_local
decl_stmt|;
name|char
modifier|*
name|zsend
decl_stmt|;
comment|/* Determine the grade we should request of the other system.  A        '\0' means that no restrictions have been made.  */
name|bgrade
operator|=
name|btimegrade
argument_list|(
name|qsys
operator|->
name|zcalltimegrade
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsys
operator|->
name|zlocalname
operator|!=
name|NULL
condition|)
name|zuse_local
operator|=
name|qsys
operator|->
name|zlocalname
expr_stmt|;
else|else
name|zuse_local
operator|=
name|zLocalname
expr_stmt|;
name|zsend
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zuse_local
argument_list|)
operator|+
literal|70
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qsys
operator|->
name|fsequence
condition|)
block|{
if|if
condition|(
name|bgrade
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"S%s -N"
argument_list|,
name|zuse_local
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"S%s -p%c -vgrade=%c -N"
argument_list|,
name|zuse_local
argument_list|,
name|bgrade
argument_list|,
name|bgrade
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|iseq
decl_stmt|;
name|iseq
operator|=
name|isysdep_get_sequence
argument_list|(
name|qsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|iseq
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_HANDSHAKE_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bgrade
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"S%s -Q%ld -N"
argument_list|,
name|zuse_local
argument_list|,
name|iseq
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"S%s -Q%ld -p%c -vgrade=%c -N"
argument_list|,
name|zuse_local
argument_list|,
name|iseq
argument_list|,
name|bgrade
argument_list|,
name|bgrade
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fsend_uucp_cmd
argument_list|(
name|zsend
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_HANDSHAKE_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Now we should see ROK or Rreason where reason gives a cryptic      reason for failure.  If we are talking to a counterpart, we will      get back ROKN.  */
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_HANDSHAKE_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zstr
index|[
literal|0
index|]
operator|!=
literal|'R'
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_HANDSHAKE_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad reponse to handshake string (%s)"
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|zstr
operator|+
literal|1
argument_list|,
literal|"OKN"
argument_list|)
operator|==
literal|0
condition|)
name|fnew
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zstr
operator|+
literal|1
argument_list|,
literal|"OK"
argument_list|)
operator|==
literal|0
condition|)
name|fnew
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zstr
operator|+
literal|1
argument_list|,
literal|"CB"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Remote system will call back"
argument_list|)
expr_stmt|;
name|qstat
operator|->
name|ttype
operator|=
name|STATUS_COMPLETE
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_HANDSHAKE_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Handshake failed (%s)"
argument_list|,
name|zstr
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* The slave should now send \020Pprotos\0 where protos is a list of      supported protocols.  Each protocol is a single character.  */
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_HANDSHAKE_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zstr
index|[
literal|0
index|]
operator|!=
literal|'P'
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_HANDSHAKE_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad protocol handshake (%s)"
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Now decide which protocol to use.  The system and the port may      have their own list of protocols.  */
block|{
name|int
name|i
decl_stmt|;
name|char
name|ab
index|[
literal|5
index|]
decl_stmt|;
name|i
operator|=
name|CPROTOCOLS
expr_stmt|;
if|if
condition|(
name|qsys
operator|->
name|zprotocols
operator|!=
name|NULL
operator|||
name|qPort
operator|->
name|zprotocols
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|zproto
decl_stmt|;
if|if
condition|(
name|qsys
operator|->
name|zprotocols
operator|!=
name|NULL
condition|)
name|zproto
operator|=
name|qsys
operator|->
name|zprotocols
expr_stmt|;
else|else
name|zproto
operator|=
name|qPort
operator|->
name|zprotocols
expr_stmt|;
for|for
control|(
init|;
operator|*
name|zproto
operator|!=
literal|'\0'
condition|;
name|zproto
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|zstr
operator|+
literal|1
argument_list|,
operator|*
name|zproto
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CPROTOCOLS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|asProtocols
index|[
name|i
index|]
operator|.
name|bname
operator|==
operator|*
name|zproto
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|CPROTOCOLS
condition|)
break|break;
block|}
block|}
block|}
else|else
block|{
name|int
name|ir
decl_stmt|;
comment|/* If neither the system nor the port specified a list of 	   protocols, we want only protocols that match the known 	   reliability of the dialer and the port.  If we have no 	   reliability information, we default to a reliable eight bit 	   connection.  */
name|ir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|qPort
operator|->
name|ireliable
operator|&
name|RELIABLE_SPECIFIED
operator|)
operator|!=
literal|0
condition|)
name|ir
operator|=
name|qPort
operator|->
name|ireliable
expr_stmt|;
if|if
condition|(
operator|(
name|idial_reliable
operator|&
name|RELIABLE_SPECIFIED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ir
operator|!=
literal|0
condition|)
name|ir
operator|&=
name|idial_reliable
expr_stmt|;
else|else
name|ir
operator|=
name|idial_reliable
expr_stmt|;
block|}
if|if
condition|(
name|ir
operator|==
literal|0
condition|)
name|ir
operator|=
name|RELIABLE_RELIABLE
operator||
name|RELIABLE_EIGHT
operator||
name|RELIABLE_SPECIFIED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CPROTOCOLS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ipr
decl_stmt|;
name|ipr
operator|=
name|asProtocols
index|[
name|i
index|]
operator|.
name|ireliable
expr_stmt|;
if|if
condition|(
operator|(
name|ipr
operator|&
name|ir
operator|)
operator|!=
name|ipr
condition|)
continue|continue;
if|if
condition|(
name|strchr
argument_list|(
name|zstr
operator|+
literal|1
argument_list|,
name|asProtocols
index|[
name|i
index|]
operator|.
name|bname
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|CPROTOCOLS
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
literal|"UN"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_HANDSHAKE_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No mutually supported protocols"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qProto
operator|=
operator|&
name|asProtocols
index|[
name|i
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"U%c"
argument_list|,
name|qProto
operator|->
name|bname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_uucp_cmd
argument_list|(
name|ab
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_HANDSHAKE_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Run any protocol parameter commands.  */
if|if
condition|(
name|qProto
operator|->
name|qcmds
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qsys
operator|->
name|cproto_params
operator|!=
literal|0
condition|)
name|uapply_proto_params
argument_list|(
name|qProto
operator|->
name|bname
argument_list|,
name|qProto
operator|->
name|qcmds
argument_list|,
name|qsys
operator|->
name|cproto_params
argument_list|,
name|qsys
operator|->
name|qproto_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|qPort
operator|->
name|cproto_params
operator|!=
literal|0
condition|)
name|uapply_proto_params
argument_list|(
name|qProto
operator|->
name|bname
argument_list|,
name|qProto
operator|->
name|qcmds
argument_list|,
name|qPort
operator|->
name|cproto_params
argument_list|,
name|qPort
operator|->
name|qproto_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdial_proto_params
operator|!=
literal|0
condition|)
name|uapply_proto_params
argument_list|(
name|qProto
operator|->
name|bname
argument_list|,
name|qProto
operator|->
name|qcmds
argument_list|,
name|cdial_proto_params
argument_list|,
name|qdial_proto_params
argument_list|)
expr_stmt|;
block|}
comment|/* Turn on the selected protocol.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|qProto
operator|->
name|pfstart
call|)
argument_list|(
name|TRUE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_HANDSHAKE_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Now we have succesfully logged in as the master.  */
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Handshake successful"
argument_list|)
expr_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
name|long
name|iend_time
decl_stmt|;
name|fret
operator|=
name|fuucp
argument_list|(
name|TRUE
argument_list|,
name|qsys
argument_list|,
literal|'\0'
argument_list|,
name|fnew
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|usysdep_get_work_free
argument_list|(
name|qsys
argument_list|)
expr_stmt|;
comment|/* If we jumped out due to an error, shutdown the protocol.  */
if|if
condition|(
operator|!
name|fret
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|qProto
operator|->
name|pfshutdown
argument_list|)
argument_list|()
expr_stmt|;
name|ustats_failed
argument_list|()
expr_stmt|;
block|}
comment|/* Now send the hangup message.  As the caller, we send six O's        and expect to receive seven O's.  We send the six O's twice        to help the other side.  We don't worry about errors here.  */
if|if
condition|(
name|fsend_uucp_cmd
argument_list|(
literal|"OOOOOO"
argument_list|)
operator|&&
name|fsend_uucp_cmd
argument_list|(
literal|"OOOOOO"
argument_list|)
condition|)
block|{
comment|/* We don't even look for the hangup string from the other 	   side unless we're in debugging mode.  */
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|fret
operator|&&
name|FDEBUGGING
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|)
condition|)
block|{
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|!=
name|NULL
condition|)
block|{
comment|/* The Ultrix UUCP only sends six O's, although I 		   think it should send seven.  Because of this, we 		   only check for six.  */
if|if
condition|(
name|strstr
argument_list|(
name|zstr
argument_list|,
literal|"OOOOOO"
argument_list|)
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"No hangup from remote"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
name|iend_time
operator|=
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Call complete (%ld seconds)"
argument_list|,
name|iend_time
operator|-
name|istart_time
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fret
condition|)
block|{
operator|(
name|void
operator|)
name|fcall_failed
argument_list|(
name|qsys
argument_list|,
name|STATUS_FAILED
argument_list|,
name|qstat
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|qstat
operator|->
name|ttype
operator|=
name|STATUS_COMPLETE
expr_stmt|;
name|qstat
operator|->
name|ilast
operator|=
name|iend_time
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* A small helper routine to write out the system status when something    goes wrong.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcall_failed
parameter_list|(
name|qsys
parameter_list|,
name|twhy
parameter_list|,
name|qstat
parameter_list|,
name|cretry
parameter_list|)
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|enum
name|tstatus_type
name|twhy
decl_stmt|;
name|struct
name|sstatus
modifier|*
name|qstat
decl_stmt|;
name|int
name|cretry
decl_stmt|;
block|{
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|,
literal|"fcall_failed: Cause %d (%s)"
argument_list|,
operator|(
name|int
operator|)
name|twhy
argument_list|,
name|azStatus
index|[
operator|(
name|int
operator|)
name|twhy
index|]
argument_list|)
expr_stmt|;
name|qstat
operator|->
name|ttype
operator|=
name|twhy
expr_stmt|;
name|qstat
operator|->
name|cretries
operator|++
expr_stmt|;
name|qstat
operator|->
name|ilast
operator|=
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cretry
operator|==
literal|0
condition|)
name|qstat
operator|->
name|cwait
operator|=
name|CRETRY_WAIT
argument_list|(
name|qstat
operator|->
name|cretries
argument_list|)
expr_stmt|;
else|else
name|qstat
operator|->
name|cwait
operator|=
name|cretry
operator|*
literal|60
expr_stmt|;
return|return
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
name|qstat
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Prompt for a login name and a password, and run as the slave.  */
end_comment

begin_function
specifier|static
name|boolean
name|flogin_prompt
parameter_list|(
name|qport
parameter_list|)
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|,
modifier|*
name|zpass
decl_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|,
literal|"flogin_prompt: Waiting for login"
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|fport_write
argument_list|(
literal|"login: "
argument_list|,
sizeof|sizeof
expr|"login: "
operator|-
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|zuser
operator|=
name|zget_typed_line
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|zuser
operator|!=
name|NULL
operator|&&
operator|*
name|zuser
operator|==
literal|'\0'
condition|)
do|;
if|if
condition|(
name|zuser
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zhold
decl_stmt|;
name|zhold
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zuser
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zhold
argument_list|,
name|zuser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fport_write
argument_list|(
literal|"Password:"
argument_list|,
sizeof|sizeof
expr|"Password:"
operator|-
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|zpass
operator|=
name|zget_typed_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|zpass
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fcheck_login
argument_list|(
name|zhold
argument_list|,
name|zpass
argument_list|)
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|int
name|iholddebug
decl_stmt|;
endif|#
directive|endif
comment|/* We ignore the return value of faccept_call because we 		 really don't care whether the call succeeded or not. 		 We are going to reset the port anyhow.  */
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iholddebug
operator|=
name|iDebug
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|faccept_call
argument_list|(
name|zhold
argument_list|,
name|qport
argument_list|,
operator|(
specifier|const
expr|struct
name|ssysteminfo
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iDebug
operator|=
name|iholddebug
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Accept a call from a remote system.  If pqsys is not NULL, *pqsys    will be set to the system that called in if known.  */
end_comment

begin_function
specifier|static
name|boolean
name|faccept_call
parameter_list|(
name|zlogin
parameter_list|,
name|qport
parameter_list|,
name|pqsys
parameter_list|)
specifier|const
name|char
modifier|*
name|zlogin
decl_stmt|;
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
modifier|*
name|pqsys
decl_stmt|;
block|{
name|long
name|istart_time
decl_stmt|;
name|int
name|cdial_proto_params
decl_stmt|;
name|struct
name|sproto_param
modifier|*
name|qdial_proto_params
decl_stmt|;
name|int
name|idial_reliable
decl_stmt|;
name|boolean
name|ftcp_port
decl_stmt|;
specifier|const
name|char
modifier|*
name|zport
decl_stmt|;
name|char
modifier|*
name|zsend
decl_stmt|,
modifier|*
name|zspace
decl_stmt|;
specifier|const
name|char
modifier|*
name|zstr
decl_stmt|;
name|struct
name|ssysteminfo
name|ssys
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|boolean
name|fnew
decl_stmt|;
name|char
name|bgrade
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuse_local
decl_stmt|;
name|struct
name|sstatus
name|sstat
decl_stmt|;
name|long
name|cmax_receive
decl_stmt|;
name|boolean
name|frestart
decl_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
name|struct
name|sport
name|sportinfo
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pqsys
operator|!=
name|NULL
condition|)
operator|*
name|pqsys
operator|=
name|NULL
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Incoming call (login %s port %s)"
argument_list|,
name|zlogin
operator|==
name|NULL
condition|?
literal|"unknown"
else|:
name|zlogin
argument_list|,
name|zLdevice
operator|==
name|NULL
condition|?
literal|"unknown"
else|:
name|zLdevice
argument_list|)
expr_stmt|;
name|istart_time
operator|=
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Figure out protocol parameters determined by the port.  If no      port was specified we're reading standard input, so try to get      the port name and read information from the port file.  We only      use the port information to get protocol parameters; we don't      want to start treating the port as though it were a modem, for      example.  */
if|if
condition|(
name|qport
operator|!=
name|NULL
condition|)
block|{
name|zport
operator|=
name|qport
operator|->
name|zname
expr_stmt|;
name|ftcp_port
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|zport
operator|=
name|zsysdep_port_name
argument_list|(
operator|&
name|ftcp_port
argument_list|)
expr_stmt|;
comment|/* We want to get the protocol parameters for the port.  If we 	 aren't using HAVE_TAYLOR_CONFIG, that information isn't 	 stored anyhow, so we don't bother to look it up.  */
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
if|if
condition|(
name|zport
operator|!=
name|NULL
operator|&&
name|zPortfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ffind_port
argument_list|(
name|zport
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
operator|&
name|sportinfo
argument_list|,
operator|(
name|boolean
argument_list|(
argument|*
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|sport
operator|*
operator|,
name|boolean
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
condition|)
name|qport
operator|=
operator|&
name|sportinfo
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
if|if
condition|(
name|zport
operator|==
name|NULL
condition|)
name|zport
operator|=
literal|"unknown"
expr_stmt|;
block|}
comment|/* If we've managed to figure out that this is a modem port, now try      to get protocol parameters from the dialer.  */
name|cdial_proto_params
operator|=
literal|0
expr_stmt|;
name|qdial_proto_params
operator|=
name|NULL
expr_stmt|;
name|idial_reliable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qport
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qport
operator|->
name|ttype
operator|==
name|PORTTYPE_MODEM
condition|)
block|{
if|if
condition|(
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdialer
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zcopy
decl_stmt|;
name|char
modifier|*
name|zdial
decl_stmt|;
name|struct
name|sdialer
name|sdialerinfo
decl_stmt|;
comment|/* We use the first dialer in the sequence.  */
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdialer
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zcopy
argument_list|,
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdialer
argument_list|)
expr_stmt|;
name|zdial
operator|=
name|strtok
argument_list|(
name|zcopy
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread_dialer_info
argument_list|(
name|zdial
argument_list|,
operator|&
name|sdialerinfo
argument_list|)
condition|)
block|{
name|cdial_proto_params
operator|=
name|sdialerinfo
operator|.
name|cproto_params
expr_stmt|;
name|qdial_proto_params
operator|=
name|sdialerinfo
operator|.
name|qproto_params
expr_stmt|;
name|idial_reliable
operator|=
name|sdialerinfo
operator|.
name|ireliable
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|qdialer
operator|!=
name|NULL
condition|)
block|{
name|cdial_proto_params
operator|=
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|qdialer
operator|->
name|cproto_params
expr_stmt|;
name|qdial_proto_params
operator|=
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|qdialer
operator|->
name|qproto_params
expr_stmt|;
name|idial_reliable
operator|=
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|qdialer
operator|->
name|ireliable
expr_stmt|;
block|}
block|}
if|#
directive|if
name|HAVE_TCP
elseif|else
if|if
condition|(
name|qport
operator|->
name|ttype
operator|==
name|PORTTYPE_TCP
condition|)
name|ftcp_port
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If it's a TCP port, it's fully reliable.  Even if HAVE_TCP is not      supported, zsysdep_port_name may be able to figure this out (not      on Unix, though).  */
if|if
condition|(
name|ftcp_port
condition|)
name|idial_reliable
operator|=
operator|(
name|RELIABLE_SPECIFIED
operator||
name|RELIABLE_ENDTOEND
operator||
name|RELIABLE_RELIABLE
operator||
name|RELIABLE_EIGHT
operator|)
expr_stmt|;
comment|/* We have to check to see whether some system uses this login name      to indicate a different local name.  Obviously, this means that      any system which uses this login name must expect the alternate      system name.  */
name|zuse_local
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fUnknown_ok
condition|)
block|{
for|for
control|(
name|qsys
operator|=
operator|&
name|sUnknown
init|;
name|qsys
operator|!=
name|NULL
condition|;
name|qsys
operator|=
name|qsys
operator|->
name|qalternate
control|)
block|{
if|if
condition|(
name|qsys
operator|->
name|zlocalname
operator|!=
name|NULL
operator|&&
name|qsys
operator|->
name|zcalled_login
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|qsys
operator|->
name|zcalled_login
argument_list|,
name|zlogin
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zuse_local
operator|=
name|qsys
operator|->
name|zlocalname
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|zuse_local
operator|==
name|NULL
condition|)
block|{
name|struct
name|ssysteminfo
modifier|*
name|pas
decl_stmt|;
name|int
name|isys
decl_stmt|,
name|csystems
decl_stmt|;
name|zuse_local
operator|=
name|zLocalname
expr_stmt|;
name|uread_all_system_info
argument_list|(
operator|&
name|csystems
argument_list|,
operator|&
name|pas
argument_list|)
expr_stmt|;
for|for
control|(
name|isys
operator|=
literal|0
init|;
name|isys
operator|<
name|csystems
condition|;
name|isys
operator|++
control|)
block|{
for|for
control|(
name|qsys
operator|=
operator|&
name|pas
index|[
name|isys
index|]
init|;
name|qsys
operator|!=
name|NULL
condition|;
name|qsys
operator|=
name|qsys
operator|->
name|qalternate
control|)
block|{
if|if
condition|(
name|qsys
operator|->
name|zlocalname
operator|!=
name|NULL
operator|&&
name|qsys
operator|->
name|zcalled_login
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|qsys
operator|->
name|zcalled_login
argument_list|,
name|zlogin
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zuse_local
operator|=
name|qsys
operator|->
name|zlocalname
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|qsys
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
comment|/* Tell the remote system who we are.   */
name|zsend
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zuse_local
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"Shere=%s"
argument_list|,
name|zuse_local
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_uucp_cmd
argument_list|(
name|zsend
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|zstr
index|[
literal|0
index|]
operator|!=
literal|'S'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad introduction string"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|++
name|zstr
expr_stmt|;
name|zspace
operator|=
name|strchr
argument_list|(
name|zstr
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|zspace
operator|!=
name|NULL
condition|)
operator|*
name|zspace
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fread_system_info
argument_list|(
name|zstr
argument_list|,
operator|&
name|ssys
argument_list|)
condition|)
name|qsys
operator|=
operator|&
name|ssys
expr_stmt|;
else|else
block|{
comment|/* We have no information on this system.  */
if|if
condition|(
operator|!
name|fUnknown_ok
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
literal|"RYou are unknown to me"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Call from unknown system %s"
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We have to translate the name to a canonical form for the 	 benefit of systems which only allow short system names.  */
name|sUnknown
operator|.
name|zname
operator|=
name|ztranslate_system
argument_list|(
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sUnknown
operator|.
name|zname
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
literal|"RYou are unknown to me"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qsys
operator|=
operator|&
name|sUnknown
expr_stmt|;
block|}
if|if
condition|(
name|pqsys
operator|!=
name|NULL
condition|)
operator|*
name|pqsys
operator|=
name|qsys
expr_stmt|;
if|if
condition|(
operator|!
name|fcheck_validate
argument_list|(
name|zlogin
argument_list|,
name|qsys
operator|->
name|zname
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
literal|"RLOGIN"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"System %s used wrong login name %s"
argument_list|,
name|zstr
argument_list|,
name|zlogin
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|qsys
operator|->
name|zcalled_login
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qany
decl_stmt|;
comment|/* Choose an alternate system definition based on the 	 login name.  */
name|qany
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|qsys
operator|!=
name|NULL
condition|;
name|qsys
operator|=
name|qsys
operator|->
name|qalternate
control|)
block|{
if|if
condition|(
name|qsys
operator|->
name|zcalled_login
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qany
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|qsys
operator|->
name|zcalled_login
argument_list|,
literal|"ANY"
argument_list|)
operator|==
literal|0
condition|)
name|qany
operator|=
name|qsys
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|qsys
operator|->
name|zcalled_login
argument_list|,
name|zlogin
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|qany
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
literal|"RLOGIN"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"System %s used wrong login name %s"
argument_list|,
name|zstr
argument_list|,
name|zlogin
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qsys
operator|=
name|qany
expr_stmt|;
block|}
block|}
name|ulog_system
argument_list|(
name|qsys
operator|->
name|zname
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|iDebug
operator||=
name|qsys
operator|->
name|idebug
expr_stmt|;
endif|#
directive|endif
comment|/* See if we are supposed to call the system back.  This will queue      up an empty command.  It would be better to actually call back      directly at this point as well.  */
if|if
condition|(
name|qsys
operator|->
name|fcallback
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
literal|"RCB"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Will call back"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zsysdep_spool_commands
argument_list|(
name|qsys
argument_list|,
name|BGRADE_HIGH
argument_list|,
literal|0
argument_list|,
operator|(
specifier|const
expr|struct
name|scmd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We only permit one call at a time from a remote system.  Lock it.  */
if|if
condition|(
operator|!
name|fsysdep_lock_system
argument_list|(
name|qsys
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
literal|"RLCK"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"System already locked"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|sLocked_system
operator|=
operator|*
name|qsys
expr_stmt|;
name|fLocked_system
operator|=
name|TRUE
expr_stmt|;
comment|/* Set the system status.  We don't really care if we can't get the      earlier status.  We also don't want to kill the conversation just      because we can't output the .Status file, so we ignore any      errors.  */
if|if
condition|(
operator|!
name|fsysdep_get_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
condition|)
block|{
name|sstat
operator|.
name|cretries
operator|=
literal|0
expr_stmt|;
name|sstat
operator|.
name|cwait
operator|=
literal|0
expr_stmt|;
block|}
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_TALKING
expr_stmt|;
name|sstat
operator|.
name|ilast
operator|=
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
comment|/* Check the arguments of the remote system.  We accept -x# to set      our debugging level and -Q# for a sequence number.  We may insist      on a sequence number.  The -p and -vgrade= arguments are taken to      specify the lowest job grade that we should transfer; I think      this is the traditional meaning, but I don't know.  The -N switch      means that we are talking to another instance of ourselves.  The      -U switch specifies the ulimit of the remote system, which we      treat as the maximum file size that may be sent.  The -R switch      means that the remote system supports file restart; we don't.  */
name|fnew
operator|=
name|FALSE
expr_stmt|;
name|bgrade
operator|=
name|BGRADE_LOW
expr_stmt|;
name|cmax_receive
operator|=
operator|(
name|long
operator|)
operator|-
literal|1
expr_stmt|;
name|frestart
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|zspace
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|qsys
operator|->
name|fsequence
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
literal|"RBADSEQ"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No sequence number (call rejected)"
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
operator|++
name|zspace
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|zspace
argument_list|)
argument_list|)
condition|)
operator|++
name|zspace
expr_stmt|;
while|while
condition|(
operator|*
name|zspace
operator|!=
literal|'\0'
condition|)
block|{
name|boolean
name|frecognized
decl_stmt|;
name|char
modifier|*
name|znext
decl_stmt|;
name|frecognized
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|*
name|zspace
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|zspace
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'x'
case|:
name|frecognized
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
block|{
name|int
name|iwant
decl_stmt|;
name|iwant
operator|=
name|atoi
argument_list|(
name|zspace
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fnew
condition|)
name|iwant
operator|=
operator|(
literal|1
operator|<<
name|iwant
operator|)
operator|-
literal|1
expr_stmt|;
name|iwant
operator|&=
name|qsys
operator|->
name|imax_remote_debug
expr_stmt|;
if|if
condition|(
operator|(
name|iDebug
operator||
name|iwant
operator|)
operator|!=
name|iDebug
condition|)
block|{
name|iDebug
operator||=
name|iwant
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Setting debugging mode to 0%o"
argument_list|,
name|iDebug
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
literal|'Q'
case|:
name|frecognized
operator|=
name|TRUE
expr_stmt|;
block|{
name|long
name|iseq
decl_stmt|;
if|if
condition|(
operator|!
name|qsys
operator|->
name|fsequence
condition|)
break|break;
name|iseq
operator|=
name|atol
argument_list|(
name|zspace
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|iseq
operator|!=
name|isysdep_get_sequence
argument_list|(
name|qsys
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fsend_uucp_cmd
argument_list|(
literal|"RBADSEQ"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Out of sequence call rejected"
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
break|break;
case|case
literal|'p'
case|:
comment|/* We don't accept a space between the -p and the 		     grade, although we should.  */
name|frecognized
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|FGRADE_LEGAL
argument_list|(
name|zspace
index|[
literal|2
index|]
argument_list|)
condition|)
name|bgrade
operator|=
name|zspace
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|zspace
operator|+
literal|1
argument_list|,
literal|"vgrade="
argument_list|,
sizeof|sizeof
expr|"vgrade="
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|frecognized
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|FGRADE_LEGAL
argument_list|(
name|zspace
index|[
sizeof|sizeof
expr|"vgrade="]
argument_list|)
condition|)
name|bgrade
operator|=
name|zspace
index|[
sizeof|sizeof
expr|"vgrade="]
expr_stmt|;
block|}
break|break;
case|case
literal|'N'
case|:
name|frecognized
operator|=
name|TRUE
expr_stmt|;
name|fnew
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|frecognized
operator|=
name|TRUE
expr_stmt|;
block|{
name|long
name|c
decl_stmt|;
name|c
operator|=
name|strtol
argument_list|(
name|zspace
operator|+
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
name|cmax_receive
operator|=
name|c
operator|*
operator|(
name|long
operator|)
literal|512
expr_stmt|;
block|}
break|break;
case|case
literal|'R'
case|:
name|frecognized
operator|=
name|TRUE
expr_stmt|;
name|frestart
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|znext
operator|=
name|zspace
expr_stmt|;
while|while
condition|(
operator|*
name|znext
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|znext
argument_list|)
argument_list|)
condition|)
operator|++
name|znext
expr_stmt|;
if|if
condition|(
operator|!
name|frecognized
condition|)
block|{
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|;
comment|/* We could just use %.*s for this, but it's probably 		 not portable.  */
name|clen
operator|=
name|znext
operator|-
name|zspace
expr_stmt|;
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|zcopy
argument_list|,
name|zspace
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|zcopy
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Unrecognized argument %s"
argument_list|,
name|zcopy
argument_list|)
expr_stmt|;
block|}
name|zspace
operator|=
name|znext
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|zspace
argument_list|)
argument_list|)
condition|)
operator|++
name|zspace
expr_stmt|;
block|}
block|}
comment|/* We recognized the system, and the sequence number (if any) was      OK.  Send an ROK, and send a list of protocols.  If we got the -N      switch, send ROKN to confirm it.  */
if|if
condition|(
operator|!
name|fsend_uucp_cmd
argument_list|(
name|fnew
condition|?
literal|"ROKN"
else|:
literal|"ROK"
argument_list|)
condition|)
block|{
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|qsys
operator|->
name|zprotocols
operator|!=
name|NULL
operator|||
operator|(
name|qport
operator|!=
name|NULL
operator|&&
name|qport
operator|->
name|zprotocols
operator|!=
name|NULL
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|zprotos
decl_stmt|;
if|if
condition|(
name|qsys
operator|->
name|zprotocols
operator|!=
name|NULL
condition|)
name|zprotos
operator|=
name|qsys
operator|->
name|zprotocols
expr_stmt|;
else|else
name|zprotos
operator|=
name|qport
operator|->
name|zprotocols
expr_stmt|;
name|zsend
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zprotos
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"P%s"
argument_list|,
name|zprotos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|zset
decl_stmt|;
name|int
name|ir
decl_stmt|;
name|zsend
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|CPROTOCOLS
operator|+
literal|2
argument_list|)
expr_stmt|;
name|zset
operator|=
name|zsend
expr_stmt|;
operator|*
name|zset
operator|++
operator|=
literal|'P'
expr_stmt|;
comment|/* If the system did not specify a list of protocols, we want 	   only protocols that match the known reliability of the 	   dialer and the port.  If we have no information, we default 	   to a reliable eight bit connection.  */
name|ir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qport
operator|!=
name|NULL
operator|&&
operator|(
name|qport
operator|->
name|ireliable
operator|&
name|RELIABLE_SPECIFIED
operator|)
operator|!=
literal|0
condition|)
name|ir
operator|=
name|qport
operator|->
name|ireliable
expr_stmt|;
if|if
condition|(
operator|(
name|idial_reliable
operator|&
name|RELIABLE_SPECIFIED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ir
operator|!=
literal|0
condition|)
name|ir
operator|&=
name|idial_reliable
expr_stmt|;
else|else
name|ir
operator|=
name|idial_reliable
expr_stmt|;
block|}
if|if
condition|(
name|ir
operator|==
literal|0
condition|)
name|ir
operator|=
name|RELIABLE_RELIABLE
operator||
name|RELIABLE_EIGHT
operator||
name|RELIABLE_SPECIFIED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CPROTOCOLS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ipr
decl_stmt|;
name|ipr
operator|=
name|asProtocols
index|[
name|i
index|]
operator|.
name|ireliable
expr_stmt|;
if|if
condition|(
operator|(
name|ipr
operator|&
name|ir
operator|)
operator|!=
name|ipr
condition|)
continue|continue;
operator|*
name|zset
operator|++
operator|=
name|asProtocols
index|[
name|i
index|]
operator|.
name|bname
expr_stmt|;
block|}
operator|*
name|zset
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fsend_uucp_cmd
argument_list|(
name|zsend
argument_list|)
condition|)
block|{
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* The master will now send back the selected protocol.  */
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|==
name|NULL
condition|)
block|{
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zstr
index|[
literal|0
index|]
operator|!=
literal|'U'
operator|||
name|zstr
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad protocol response string"
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zstr
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No supported protocol"
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CPROTOCOLS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|asProtocols
index|[
name|i
index|]
operator|.
name|bname
operator|==
name|zstr
index|[
literal|1
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|CPROTOCOLS
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No supported protocol"
argument_list|)
expr_stmt|;
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qProto
operator|=
operator|&
name|asProtocols
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Run the chat script for when a call is received.  */
if|if
condition|(
operator|!
name|fchat
argument_list|(
operator|&
name|qsys
operator|->
name|scalled_chat
argument_list|,
name|qsys
argument_list|,
operator|(
specifier|const
expr|struct
name|sdialer
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|zport
argument_list|,
name|iport_baud
argument_list|()
argument_list|)
condition|)
block|{
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
name|sstat
operator|.
name|ilast
operator|=
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Run any protocol parameter commands.  There should be a way to      read the dialer information if there is any to permit modem      specific protocol parameters, but for now there isn't.  */
if|if
condition|(
name|qProto
operator|->
name|qcmds
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qsys
operator|->
name|cproto_params
operator|!=
literal|0
condition|)
name|uapply_proto_params
argument_list|(
name|qProto
operator|->
name|bname
argument_list|,
name|qProto
operator|->
name|qcmds
argument_list|,
name|qsys
operator|->
name|cproto_params
argument_list|,
name|qsys
operator|->
name|qproto_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|qport
operator|!=
name|NULL
operator|&&
name|qport
operator|->
name|cproto_params
operator|!=
literal|0
condition|)
name|uapply_proto_params
argument_list|(
name|qProto
operator|->
name|bname
argument_list|,
name|qProto
operator|->
name|qcmds
argument_list|,
name|qport
operator|->
name|cproto_params
argument_list|,
name|qport
operator|->
name|qproto_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdial_proto_params
operator|!=
literal|0
condition|)
name|uapply_proto_params
argument_list|(
name|qProto
operator|->
name|bname
argument_list|,
name|qProto
operator|->
name|qcmds
argument_list|,
name|cdial_proto_params
argument_list|,
name|qdial_proto_params
argument_list|)
expr_stmt|;
block|}
comment|/* Turn on the selected protocol.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|qProto
operator|->
name|pfstart
call|)
argument_list|(
name|FALSE
argument_list|)
condition|)
block|{
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
name|sstat
operator|.
name|ilast
operator|=
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If we using HAVE_BNU_LOGGING, then the previous ``incoming call''      message went to the general log, since we didn't know the system      name at that point.  In that case, we repeat the port and login      names.  */
if|#
directive|if
name|HAVE_BNU_LOGGING
if|if
condition|(
name|bgrade
operator|==
name|BGRADE_LOW
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Handshake successful (login %s port %s)"
argument_list|,
name|zlogin
operator|==
name|NULL
condition|?
literal|"unknown"
else|:
name|zlogin
argument_list|,
name|zLdevice
operator|==
name|NULL
condition|?
literal|"unknown"
else|:
name|zLdevice
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Handshake successful (login %s port %s grade %c)"
argument_list|,
name|zlogin
operator|==
name|NULL
condition|?
literal|"unknown"
else|:
name|zlogin
argument_list|,
name|zLdevice
operator|==
name|NULL
condition|?
literal|"unknown"
else|:
name|zLdevice
argument_list|,
name|bgrade
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_BNU_LOGGING */
if|if
condition|(
name|bgrade
operator|==
name|BGRADE_LOW
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Handshake successful"
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Handshake successful (grade %c)"
argument_list|,
name|bgrade
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_BNU_LOGGING */
block|{
name|boolean
name|fret
decl_stmt|;
name|long
name|iend_time
decl_stmt|;
name|fret
operator|=
name|fuucp
argument_list|(
name|FALSE
argument_list|,
name|qsys
argument_list|,
name|bgrade
argument_list|,
name|fnew
argument_list|,
name|cmax_receive
argument_list|)
expr_stmt|;
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|usysdep_get_work_free
argument_list|(
name|qsys
argument_list|)
expr_stmt|;
comment|/* If we bombed out due to an error, shut down the protocol.  */
if|if
condition|(
operator|!
name|fret
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|qProto
operator|->
name|pfshutdown
argument_list|)
argument_list|()
expr_stmt|;
name|ustats_failed
argument_list|()
expr_stmt|;
block|}
comment|/* Hangup.  As the answerer, we send seven O's and expect to see        six.  */
if|if
condition|(
name|fsend_uucp_cmd
argument_list|(
literal|"OOOOOOO"
argument_list|)
operator|&&
name|fsend_uucp_cmd
argument_list|(
literal|"OOOOOOO"
argument_list|)
condition|)
block|{
comment|/* We don't even look for the hangup string from the other 	   side unless we're in debugging mode.  */
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|fret
operator|&&
name|FDEBUGGING
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|)
condition|)
block|{
name|zstr
operator|=
name|zget_uucp_cmd
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|zstr
argument_list|,
literal|"OOOOOO"
argument_list|)
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"No hangup from remote"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
name|iend_time
operator|=
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Call complete (%ld seconds)"
argument_list|,
name|iend_time
operator|-
name|istart_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|fret
condition|)
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_COMPLETE
expr_stmt|;
else|else
name|sstat
operator|.
name|ttype
operator|=
name|STATUS_FAILED
expr_stmt|;
name|sstat
operator|.
name|ilast
operator|=
name|iend_time
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_set_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function runs the main UUCP protocol.  It is called when the    two systems have succesfully connected.  It transfers files back    and forth until neither system has any more work to do.  The    traditional UUCP protocol has a master which sends files to the    slave or requests files from the slave (a single file is requested    with the R command; a wildcarded file name is requested with the X    command).  The slave simply obeys the commands of the master.  When    the master has done all its work, it requests a hangup.  If the    slave has work to do it refuses the hangup and becomes the new    master.     This is essentially a half-duplex connection, in that files are    only transferred in one direction at a time.  This is not    unreasonable, since generally one site is receiving a lot of news    from the other site, and I believe that Telebit modems are    basically half-duplex in that it takes a comparatively long time to    turn the line around.  However, it is possible to design a    full-duplex protocol which would be useful in some situtations when    using V.32 (or a network) and this function attempts to support    this possibility.     Traditionally the work to be done is kept in a set of files whose    names begin with C.[system][grade][pid], where system is the remote    system name, grade is the grade of transfer, and pid makes the file    name unique.  Each line in these files is a command, and each line    can be treated independently.  We let the system dependent layer    handle all of this.  This will let us use some other scheme on    systems in which the fourteen character filename length limit    restricts the name of the remote system to seven characters (the    usual restriction cited is six characters; I do not yet know where    this comes from).     Here are the types of commands, along with the definitions of the    variables they use in the fuucp function.     'S' -- Send a file from master to slave.      zfrom -- master file name      zto -- slave file name      zuser -- user who requested the transfer      zoptions -- list of options      ztemp -- temporary file name on master (used unless option c)      imode -- mode to give file      znotify -- user to notify (if option n)       The options are:      C -- file copied to spool (use ztemp rather than zfrom)      c -- file not copied to spool (use zfrom rather than ztemp)      d -- create directories if necessary      f -- do not create directories      m -- notify originator (in zuser) when complete      n -- notify recipient (in znotify) when complete       I assume that the n option is implemented by the remote system.     'R' -- Retrieve a file from slave to master.      zfrom -- slave file name      zto -- master file name      zuser -- user who requested the transfer      zoptions -- list of options       The options are the same as in case 'S', except that option n is      not supported.  If zto is a directory, we must create a file in      that directory using the last component of zfrom.     'X' -- Execute wildcard transfer from slave to master.      zfrom -- wildcard file name      zto -- local file (hopefully a directory)      zuser -- user who requested the transfer      zoptions -- list of options       The options are presumably the same as in case 'R'.  It may be      permissible to have no zuser or zoptions.  The zto name will have      local! prepended to it already (where local is the local system      name).       This command is merely sent over to the remote system, where it      is executed.  When the remote system becomes the master, it sends      the files back.     'H' -- Hangup      This is used by the master to indicate a transfer of control.  If      slave has nothing to do, it responds with HY and the conversation      is finished.  Otherwise, the slave becomes the master, and      vice-versa.  */
end_comment

begin_function
specifier|static
name|boolean
name|fuucp
parameter_list|(
name|fmaster
parameter_list|,
name|qsys
parameter_list|,
name|bgrade
parameter_list|,
name|fnew
parameter_list|,
name|cmax_receive
parameter_list|)
name|boolean
name|fmaster
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
name|boolean
name|fnew
decl_stmt|;
name|long
name|cmax_receive
decl_stmt|;
block|{
name|boolean
name|fcaller
decl_stmt|,
name|fmasterdone
decl_stmt|,
name|fnowork
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlocal_size
decl_stmt|,
modifier|*
name|zremote_size
decl_stmt|;
name|long
name|clocal_size
decl_stmt|,
name|cremote_size
decl_stmt|,
name|cmax_ever
decl_stmt|;
name|fcaller
operator|=
name|fmaster
expr_stmt|;
name|fmasterdone
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|qProto
operator|->
name|ffullduplex
operator|&&
operator|!
name|fmaster
condition|)
name|fmasterdone
operator|=
name|TRUE
expr_stmt|;
comment|/* Make sure we have a spool directory for this system.  */
if|if
condition|(
operator|!
name|fsysdep_make_spool_dir
argument_list|(
name|qsys
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If we are not the caller, the grade will be passed in as an      argument.  If we are the caller, we compute the grade in this      function so that we can recompute if time has passed.  */
if|if
condition|(
name|fcaller
condition|)
name|bgrade
operator|=
name|btimegrade
argument_list|(
name|qsys
operator|->
name|ztime
argument_list|)
expr_stmt|;
if|if
condition|(
name|bgrade
operator|==
literal|'\0'
condition|)
name|fnowork
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|fsysdep_get_work_init
argument_list|(
name|qsys
argument_list|,
name|bgrade
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|fnowork
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Determine the maximum sizes we can send and receive.  */
if|if
condition|(
name|fcaller
condition|)
block|{
name|zlocal_size
operator|=
name|qsys
operator|->
name|zcall_local_size
expr_stmt|;
name|zremote_size
operator|=
name|qsys
operator|->
name|zcall_remote_size
expr_stmt|;
block|}
else|else
block|{
name|zlocal_size
operator|=
name|qsys
operator|->
name|zcalled_local_size
expr_stmt|;
name|zremote_size
operator|=
name|qsys
operator|->
name|zcalled_remote_size
expr_stmt|;
block|}
name|clocal_size
operator|=
name|cmax_size_now
argument_list|(
name|zlocal_size
argument_list|)
expr_stmt|;
name|cremote_size
operator|=
name|cmax_size_now
argument_list|(
name|zremote_size
argument_list|)
expr_stmt|;
name|cmax_ever
operator|=
operator|(
name|long
operator|)
operator|-
literal|2
expr_stmt|;
comment|/* Loop while we have local commands to execute and while we receive      remote commands.  */
while|while
condition|(
name|TRUE
condition|)
block|{
if|#
directive|if
operator|!
name|HAVE_ALLOCA
comment|/* This only works if we know that no caller of this function is 	 holding an alloca'ed pointer.  */
operator|(
name|void
operator|)
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* If we're doing any debugging, close the log and debugging 	 files regularly.  This will let people copy them off and 	 remove them while the conversation is in progresss.  */
if|if
condition|(
name|iDebug
operator|!=
literal|0
condition|)
block|{
name|ulog_close
argument_list|()
expr_stmt|;
name|ustats_close
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* We send a command to the remote system if 	 we are the master or 	 this is full duplex protocol which is ready for a command and 	 we haven't finished executing commands.  */
if|if
condition|(
name|fmaster
operator|||
operator|(
name|qProto
operator|->
name|ffullduplex
operator|&&
operator|!
name|fmasterdone
operator|)
condition|)
block|{
name|struct
name|scmd
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|zmail
decl_stmt|,
modifier|*
name|zuse
decl_stmt|;
name|boolean
name|fspool
decl_stmt|,
name|fnever
decl_stmt|;
name|openfile_t
name|e
init|=
name|EFILECLOSED
decl_stmt|;
name|boolean
name|fgone
decl_stmt|;
comment|/* Get the next work line for this system.  All the arguments 	     are left pointing into a static buffer, so they must be 	     copied out before the next call.  */
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnowork
condition|)
name|s
operator|.
name|bcmd
operator|=
literal|'H'
expr_stmt|;
else|else
block|{
name|s
operator|.
name|zuser
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_get_work
argument_list|(
name|qsys
argument_list|,
name|bgrade
argument_list|,
operator|&
name|s
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ulog_user
argument_list|(
name|s
operator|.
name|zuser
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|s
operator|.
name|bcmd
condition|)
block|{
case|case
literal|'S'
case|:
comment|/* Send a file.  */
name|fspool
operator|=
name|fspool_file
argument_list|(
name|s
operator|.
name|zfrom
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fspool
condition|)
block|{
name|zuse
operator|=
name|zsysdep_real_file_name
argument_list|(
name|qsys
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zuse
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|s
operator|.
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"cannot form file name"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|zLocalname
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* The 'C' option means that the file has been 		     copied to the spool directory.  */
if|if
condition|(
name|strchr
argument_list|(
name|s
operator|.
name|zoptions
argument_list|,
literal|'C'
argument_list|)
operator|!=
name|NULL
condition|)
name|fspool
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fok_to_send
argument_list|(
name|zuse
argument_list|,
name|TRUE
argument_list|,
name|fcaller
argument_list|,
name|fspool
argument_list|,
name|qsys
argument_list|,
name|s
operator|.
name|zuser
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Not permitted to send %s"
argument_list|,
name|zuse
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|s
operator|.
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"not permitted to send"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|zLocalname
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If we're copying the real file, use its mode 		     directly rather than the mode copied into the 		     command file.  */
if|if
condition|(
operator|!
name|fspool
condition|)
name|e
operator|=
name|esysdep_open_send
argument_list|(
name|qsys
argument_list|,
name|zuse
argument_list|,
name|TRUE
argument_list|,
name|s
operator|.
name|zuser
argument_list|,
operator|&
name|s
operator|.
name|imode
argument_list|,
operator|&
name|s
operator|.
name|cbytes
argument_list|,
operator|&
name|fgone
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fspool
condition|)
block|{
name|unsigned
name|int
name|idummy
decl_stmt|;
name|zuse
operator|=
name|zsysdep_spool_file_name
argument_list|(
name|qsys
argument_list|,
name|s
operator|.
name|ztemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zuse
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|s
operator|.
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"cannot form file name"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|zLocalname
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
break|break;
block|}
name|e
operator|=
name|esysdep_open_send
argument_list|(
name|qsys
argument_list|,
name|zuse
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|idummy
argument_list|,
operator|&
name|s
operator|.
name|cbytes
argument_list|,
operator|&
name|fgone
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|e
argument_list|)
condition|)
block|{
comment|/* If the file does not exist, fgone will be set to 		     TRUE.  In this case we might have sent the file 		     the last time we talked to the remote system, 		     because we might have been interrupted in the 		     middle of a command file.  To avoid confusion, we 		     don't send a mail message.  */
if|if
condition|(
operator|!
name|fgone
condition|)
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|s
operator|.
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"cannot open file"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|zLocalname
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|.
name|cbytes
operator|!=
operator|-
literal|1
condition|)
block|{
name|boolean
name|fsmall
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|fsmall
operator|=
name|FALSE
expr_stmt|;
name|fnever
operator|=
name|FALSE
expr_stmt|;
name|zerr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmax_receive
operator|!=
operator|-
literal|1
operator|&&
name|cmax_receive
operator|<
name|s
operator|.
name|cbytes
condition|)
block|{
name|fsmall
operator|=
name|TRUE
expr_stmt|;
name|fnever
operator|=
name|TRUE
expr_stmt|;
name|zerr
operator|=
literal|"too large for receiver"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clocal_size
operator|!=
operator|-
literal|1
operator|&&
name|clocal_size
operator|<
name|s
operator|.
name|cbytes
condition|)
block|{
name|fsmall
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|cmax_ever
operator|==
operator|-
literal|2
condition|)
block|{
name|long
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|c1
operator|=
name|cmax_size_ever
argument_list|(
name|qsys
operator|->
name|zcall_local_size
argument_list|)
expr_stmt|;
name|c2
operator|=
name|cmax_size_ever
argument_list|(
name|qsys
operator|->
name|zcalled_local_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|>
name|c2
condition|)
name|cmax_ever
operator|=
name|c1
expr_stmt|;
else|else
name|cmax_ever
operator|=
name|c2
expr_stmt|;
block|}
if|if
condition|(
name|cmax_ever
operator|==
operator|-
literal|1
operator|||
name|cmax_ever
operator|>=
name|s
operator|.
name|cbytes
condition|)
name|zerr
operator|=
literal|"too large to send now"
expr_stmt|;
else|else
block|{
name|fnever
operator|=
name|TRUE
expr_stmt|;
name|zerr
operator|=
literal|"too large to send"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fsmall
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"File %s is %s"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnever
condition|)
block|{
specifier|const
name|char
modifier|*
name|zsaved
decl_stmt|;
name|zsaved
operator|=
name|zsysdep_save_temp_file
argument_list|(
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|s
operator|.
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|zerr
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|zLocalname
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|zsaved
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Sending %s"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|)
expr_stmt|;
comment|/* The send file function is responsible for notifying 		 the user upon success (if option m) or failure, and 		 for closing the file.  This allows it to not complete 		 immediately.  */
if|if
condition|(
name|strchr
argument_list|(
name|s
operator|.
name|zoptions
argument_list|,
literal|'m'
argument_list|)
operator|==
name|NULL
condition|)
name|zmail
operator|=
name|NULL
expr_stmt|;
else|else
name|zmail
operator|=
name|s
operator|.
name|zuser
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_file
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
operator|&
name|s
argument_list|,
name|zmail
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|fnew
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
literal|'R'
case|:
comment|/* Receive a file.  */
if|if
condition|(
name|fspool_file
argument_list|(
name|s
operator|.
name|zto
argument_list|)
condition|)
block|{
comment|/* Normal users are not allowed to receive files in 		     the spool directory, and to make it particularly 		     difficult we require a special option '9'.  This 		     is used only by uux when a file must be requested 		     from one system and then sent to another.  */
if|if
condition|(
name|s
operator|.
name|zto
index|[
literal|0
index|]
operator|!=
literal|'D'
operator|||
name|strchr
argument_list|(
name|s
operator|.
name|zoptions
argument_list|,
literal|'9'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Not permitted to receive %s"
argument_list|,
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|s
operator|.
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"not permitted to receive"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|zLocalname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
break|break;
block|}
name|zuse
operator|=
name|zsysdep_spool_file_name
argument_list|(
name|qsys
argument_list|,
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
if|if
condition|(
name|zuse
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|s
operator|.
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"cannot form file name"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|zLocalname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|zuse
operator|=
name|zsysdep_real_file_name
argument_list|(
name|qsys
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|s
operator|.
name|zfrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|zuse
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|s
operator|.
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"cannot form file name"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|zLocalname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Check permissions.  */
if|if
condition|(
operator|!
name|fok_to_receive
argument_list|(
name|zuse
argument_list|,
name|TRUE
argument_list|,
name|fcaller
argument_list|,
name|qsys
argument_list|,
name|s
operator|.
name|zuser
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Not permitted to receive %s"
argument_list|,
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|s
operator|.
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"not permitted to receive"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|zLocalname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* The 'f' option means that directories should not 		     be created if they do not already exist.  */
if|if
condition|(
name|strchr
argument_list|(
name|s
operator|.
name|zoptions
argument_list|,
literal|'f'
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_make_dirs
argument_list|(
name|zuse
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|s
operator|.
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"cannot create directories"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|zLocalname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|e
operator|=
name|esysdep_open_receive
argument_list|(
name|qsys
argument_list|,
name|zuse
argument_list|,
operator|&
name|s
operator|.
name|ztemp
argument_list|,
operator|&
name|s
operator|.
name|cbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|e
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|s
operator|.
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"cannot open file"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|zLocalname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Here s.cbytes represents the amount of free space we 		 have.  We want to adjust it by the amount of free 		 space permitted for this system.  If there is a 		 maximum transfer size, we may want to use that as an 		 amount of free space.  */
if|if
condition|(
name|s
operator|.
name|cbytes
operator|!=
operator|-
literal|1
condition|)
block|{
name|s
operator|.
name|cbytes
operator|-=
name|qsys
operator|->
name|cfree_space
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|cbytes
operator|<
literal|0
condition|)
name|s
operator|.
name|cbytes
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|clocal_size
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|s
operator|.
name|cbytes
operator|==
operator|-
literal|1
operator|||
name|clocal_size
operator|<
name|s
operator|.
name|cbytes
operator|)
condition|)
name|s
operator|.
name|cbytes
operator|=
name|clocal_size
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Receiving %s"
argument_list|,
name|zuse
argument_list|)
expr_stmt|;
name|s
operator|.
name|zto
operator|=
name|zuse
expr_stmt|;
comment|/* As with the send routine, this function is 		 responsible for mailing a message to the user on 		 failure or on success if the m option is set, and is 		 also responsible for closing the file.  */
if|if
condition|(
name|strchr
argument_list|(
name|s
operator|.
name|zoptions
argument_list|,
literal|'m'
argument_list|)
operator|==
name|NULL
condition|)
name|zmail
operator|=
name|NULL
expr_stmt|;
else|else
name|zmail
operator|=
name|s
operator|.
name|zuser
expr_stmt|;
comment|/* The imode argument (passed as 0666) will be corrected 		 with information from the remote system.  */
name|s
operator|.
name|imode
operator|=
literal|0666
expr_stmt|;
if|if
condition|(
operator|!
name|freceive_file
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
operator|&
name|s
argument_list|,
name|zmail
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|fnew
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
literal|'X'
case|:
comment|/* Request a file copy.  This is used to request a file 		 to be sent to another machine, as well as to get a 		 wildcarded filespec.  */
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Requesting work: %s to %s"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fxcmd
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|fnever
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fnever
condition|)
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|s
operator|.
name|zuser
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"wildcard request denied"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|zLocalname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* There is nothing left to do; hang up.  If we are not the 		 master, take no action (this allows for two-way 		 protocols.  */
name|fmasterdone
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fmaster
condition|)
block|{
if|if
condition|(
operator|!
name|fhangup_request
argument_list|()
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Hangup failed"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fmaster
operator|=
name|FALSE
expr_stmt|;
comment|/* Close the log file at every master/slave switch. 		     This will cut down on the amount of time we have 		     an old log file open.  */
name|ulog_close
argument_list|()
expr_stmt|;
name|ustats_close
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Unknown command '%c'"
argument_list|,
name|s
operator|.
name|bcmd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* We look for a command from the other system if we are the 	 slave or this is a full-duplex protocol and the slave still 	 has work to do.  */
if|if
condition|(
operator|!
name|fmaster
operator|||
name|qProto
operator|->
name|ffullduplex
condition|)
block|{
name|struct
name|scmd
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuse
decl_stmt|,
modifier|*
name|zmail
decl_stmt|;
name|openfile_t
name|e
decl_stmt|;
name|char
name|bhave_grade
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
comment|/* We are the slave.  Get the next command from the other 	     system.  */
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgetcmd
argument_list|(
name|fmaster
argument_list|,
operator|&
name|s
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|s
operator|.
name|bcmd
operator|!=
literal|'H'
operator|&&
name|s
operator|.
name|bcmd
operator|!=
literal|'Y'
condition|)
name|ulog_user
argument_list|(
name|s
operator|.
name|zuser
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
operator|.
name|bcmd
condition|)
block|{
case|case
literal|'S'
case|:
comment|/* The master wants to send a file to us.  */
if|if
condition|(
name|fspool_file
argument_list|(
name|s
operator|.
name|zto
argument_list|)
condition|)
block|{
name|zuse
operator|=
name|zsysdep_spool_file_name
argument_list|(
name|qsys
argument_list|,
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
comment|/* We don't accept remote command files.  */
if|if
condition|(
name|zuse
operator|==
name|NULL
operator|||
name|s
operator|.
name|zto
index|[
literal|0
index|]
operator|==
literal|'C'
condition|)
block|{
if|if
condition|(
operator|!
name|ftransfer_fail
argument_list|(
literal|'S'
argument_list|,
name|FAILURE_PERM
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
else|else
block|{
name|zuse
operator|=
name|zsysdep_real_file_name
argument_list|(
name|qsys
argument_list|,
name|s
operator|.
name|zto
argument_list|,
name|s
operator|.
name|zfrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|zuse
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ftransfer_fail
argument_list|(
literal|'S'
argument_list|,
name|FAILURE_PERM
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
comment|/* Check permissions.  */
if|if
condition|(
operator|!
name|fok_to_receive
argument_list|(
name|zuse
argument_list|,
name|FALSE
argument_list|,
name|fcaller
argument_list|,
name|qsys
argument_list|,
name|s
operator|.
name|zuser
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Not permitted to receive %s"
argument_list|,
name|zuse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ftransfer_fail
argument_list|(
literal|'S'
argument_list|,
name|FAILURE_PERM
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|s
operator|.
name|zoptions
argument_list|,
literal|'f'
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_make_dirs
argument_list|(
name|zuse
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ftransfer_fail
argument_list|(
literal|'S'
argument_list|,
name|FAILURE_PERM
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
name|e
operator|=
name|esysdep_open_receive
argument_list|(
name|qsys
argument_list|,
name|zuse
argument_list|,
operator|&
name|s
operator|.
name|ztemp
argument_list|,
operator|&
name|cbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ftransfer_fail
argument_list|(
literal|'S'
argument_list|,
name|FAILURE_OPEN
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
comment|/* Adjust the number of bytes we are prepared to receive 		 according to the amount of free space we are supposed 		 to leave available and the maximum file size we are 		 permitted to transfer.  */
if|if
condition|(
name|cbytes
operator|!=
operator|-
literal|1
condition|)
block|{
name|cbytes
operator|-=
name|qsys
operator|->
name|cfree_space
expr_stmt|;
if|if
condition|(
name|cbytes
operator|<
literal|0
condition|)
name|cbytes
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cremote_size
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|cbytes
operator|==
operator|-
literal|1
operator|||
name|cremote_size
operator|<
name|cbytes
operator|)
condition|)
name|cbytes
operator|=
name|cremote_size
expr_stmt|;
comment|/* If the number of bytes we are prepared to receive 		 is less than the file size, we must fail.  */
if|if
condition|(
name|s
operator|.
name|cbytes
operator|!=
operator|-
literal|1
operator|&&
name|cbytes
operator|!=
operator|-
literal|1
operator|&&
name|cbytes
operator|<
name|s
operator|.
name|cbytes
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s is too big to receive"
argument_list|,
name|zuse
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|s
operator|.
name|ztemp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ftransfer_fail
argument_list|(
literal|'S'
argument_list|,
name|FAILURE_SIZE
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Receiving %s"
argument_list|,
name|zuse
argument_list|)
expr_stmt|;
name|s
operator|.
name|zto
operator|=
name|zuse
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|s
operator|.
name|zoptions
argument_list|,
literal|'n'
argument_list|)
operator|==
name|NULL
condition|)
name|zmail
operator|=
name|NULL
expr_stmt|;
else|else
name|zmail
operator|=
name|s
operator|.
name|znotify
expr_stmt|;
name|s
operator|.
name|pseq
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|freceive_file
argument_list|(
name|FALSE
argument_list|,
name|e
argument_list|,
operator|&
name|s
argument_list|,
name|zmail
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|fnew
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
literal|'R'
case|:
comment|/* The master wants to get a file from us.  */
if|if
condition|(
name|fspool_file
argument_list|(
name|s
operator|.
name|zfrom
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No permission to send %s"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ftransfer_fail
argument_list|(
literal|'R'
argument_list|,
name|FAILURE_PERM
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
name|zuse
operator|=
name|zsysdep_real_file_name
argument_list|(
name|qsys
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zuse
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ftransfer_fail
argument_list|(
literal|'R'
argument_list|,
name|FAILURE_PERM
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
if|if
condition|(
operator|!
name|fok_to_send
argument_list|(
name|zuse
argument_list|,
name|FALSE
argument_list|,
name|fcaller
argument_list|,
name|FALSE
argument_list|,
name|qsys
argument_list|,
name|s
operator|.
name|zuser
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No permission to send %s"
argument_list|,
name|zuse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ftransfer_fail
argument_list|(
literal|'R'
argument_list|,
name|FAILURE_PERM
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
name|e
operator|=
name|esysdep_open_send
argument_list|(
name|qsys
argument_list|,
name|zuse
argument_list|,
name|TRUE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|s
operator|.
name|imode
argument_list|,
operator|&
name|cbytes
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ftransfer_fail
argument_list|(
literal|'R'
argument_list|,
name|FAILURE_OPEN
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
comment|/* If the file is larger than the amount of space 		 the other side reported, we can't send it.  */
if|if
condition|(
name|cbytes
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|(
name|s
operator|.
name|cbytes
operator|!=
operator|-
literal|1
operator|&&
name|s
operator|.
name|cbytes
operator|<
name|cbytes
operator|)
operator|||
operator|(
name|cremote_size
operator|!=
operator|-
literal|1
operator|&&
name|cremote_size
operator|<
name|cbytes
operator|)
operator|||
operator|(
name|cmax_receive
operator|!=
operator|-
literal|1
operator|&&
name|cmax_receive
operator|<
name|cbytes
operator|)
operator|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s is too large to send"
argument_list|,
name|zuse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ftransfer_fail
argument_list|(
literal|'R'
argument_list|,
name|FAILURE_SIZE
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Sending %s"
argument_list|,
name|zuse
argument_list|)
expr_stmt|;
comment|/* Pass in the real size of the file.  */
name|s
operator|.
name|cbytes
operator|=
name|cbytes
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_file
argument_list|(
name|FALSE
argument_list|,
name|e
argument_list|,
operator|&
name|s
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|fnew
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
literal|'X'
case|:
comment|/* This is an execution request.  We are being asked to 		 send one or more files to a destination on either the 		 local or a remote system.  We do this by spooling up 		 commands for the destination system.  */
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Work requested: %s to %s"
argument_list|,
name|s
operator|.
name|zfrom
argument_list|,
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdo_xcmd
argument_list|(
name|qsys
argument_list|,
name|fcaller
argument_list|,
operator|&
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fxcmd_confirm
argument_list|()
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ftransfer_fail
argument_list|(
literal|'X'
argument_list|,
name|FAILURE_PERM
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|'H'
case|:
comment|/* The master wants to hang up.  If we have something to 		 do, become the master.  Otherwise, agree to hang up. 		 We recheck the grades allowed at this time, since a 		 lot of time may have passed.  */
if|if
condition|(
name|fcaller
condition|)
name|bgrade
operator|=
name|btimegrade
argument_list|(
name|qsys
operator|->
name|ztime
argument_list|)
expr_stmt|;
if|if
condition|(
name|bgrade
operator|!=
literal|'\0'
operator|&&
name|fsysdep_has_work
argument_list|(
name|qsys
argument_list|,
operator|&
name|bhave_grade
argument_list|)
operator|&&
name|igradecmp
argument_list|(
name|bgrade
argument_list|,
name|bhave_grade
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fmasterdone
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_get_work_init
argument_list|(
name|qsys
argument_list|,
name|bgrade
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|fnowork
operator|=
name|FALSE
expr_stmt|;
block|}
name|fmasterdone
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|fhangup_reply
argument_list|(
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|fmaster
operator|=
name|TRUE
expr_stmt|;
comment|/* Recalculate the maximum sizes we can send, since 		     the time might have changed significantly.  */
name|clocal_size
operator|=
name|cmax_size_now
argument_list|(
name|zlocal_size
argument_list|)
expr_stmt|;
name|cremote_size
operator|=
name|cmax_size_now
argument_list|(
name|zremote_size
argument_list|)
expr_stmt|;
comment|/* Close the log file at every switch of master and 		     slave.  */
name|ulog_close
argument_list|()
expr_stmt|;
name|ustats_close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* The hangup_reply function will shut down the 		     protocol.  */
return|return
name|fhangup_reply
argument_list|(
name|TRUE
argument_list|)
return|;
block|}
break|break;
case|case
literal|'Y'
case|:
comment|/* This is returned when a hangup has been confirmed and 		 the protocol has been shut down.  */
return|return
name|TRUE
return|;
default|default:
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Unknown command %c"
argument_list|,
name|s
operator|.
name|bcmd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Do an 'X' request for another system.  The other system has    basically requested us to execute a uucp command for them.  */
end_comment

begin_function
specifier|static
name|boolean
name|fdo_xcmd
parameter_list|(
name|qsys
parameter_list|,
name|fcaller
parameter_list|,
name|q
parameter_list|)
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|boolean
name|fcaller
decl_stmt|;
specifier|const
name|struct
name|scmd
modifier|*
name|q
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zexclam
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdestfile
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|;
name|struct
name|ssysteminfo
name|sdestsys
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qdestsys
decl_stmt|;
name|char
modifier|*
name|zuser
init|=
name|NULL
decl_stmt|;
name|char
name|aboptions
index|[
literal|5
index|]
decl_stmt|;
name|char
modifier|*
name|zoptions
init|=
name|NULL
decl_stmt|;
name|boolean
name|fmkdirs
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
name|zexclam
operator|=
name|strchr
argument_list|(
name|q
operator|->
name|zto
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zexclam
operator|==
name|NULL
operator|||
name|zexclam
operator|==
name|q
operator|->
name|zto
operator|||
name|strncmp
argument_list|(
name|zLocalname
argument_list|,
name|q
operator|->
name|zto
argument_list|,
name|zexclam
operator|-
name|q
operator|->
name|zto
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The files are supposed to be copied to the 	 local system.  */
name|qdestsys
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zexclam
operator|==
name|NULL
condition|)
name|zdestfile
operator|=
name|q
operator|->
name|zto
expr_stmt|;
else|else
name|zdestfile
operator|=
name|zexclam
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|clen
decl_stmt|;
name|clen
operator|=
name|zexclam
operator|-
name|q
operator|->
name|zto
expr_stmt|;
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|zcopy
argument_list|,
name|q
operator|->
name|zto
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|zcopy
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|fread_system_info
argument_list|(
name|zcopy
argument_list|,
operator|&
name|sdestsys
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fUnknown_ok
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Destination system %s unknown"
argument_list|,
name|zcopy
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|sdestsys
operator|=
name|sUnknown
expr_stmt|;
name|sdestsys
operator|.
name|zname
operator|=
name|zcopy
expr_stmt|;
block|}
name|qdestsys
operator|=
operator|&
name|sdestsys
expr_stmt|;
name|zdestfile
operator|=
name|zexclam
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|qdestsys
operator|!=
name|NULL
condition|)
block|{
name|zuser
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|qdestsys
operator|->
name|zname
argument_list|)
operator|+
name|strlen
argument_list|(
name|q
operator|->
name|zuser
argument_list|)
operator|+
sizeof|sizeof
expr|"!"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zuser
argument_list|,
literal|"%s!%s"
argument_list|,
name|qdestsys
operator|->
name|zname
argument_list|,
name|q
operator|->
name|zuser
argument_list|)
expr_stmt|;
name|zoptions
operator|=
name|aboptions
expr_stmt|;
operator|*
name|zoptions
operator|++
operator|=
literal|'C'
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|q
operator|->
name|zoptions
argument_list|,
literal|'d'
argument_list|)
operator|!=
name|NULL
condition|)
operator|*
name|zoptions
operator|++
operator|=
literal|'d'
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|q
operator|->
name|zoptions
argument_list|,
literal|'m'
argument_list|)
operator|!=
name|NULL
condition|)
operator|*
name|zoptions
operator|++
operator|=
literal|'m'
expr_stmt|;
operator|*
name|zoptions
operator|=
literal|'\0'
expr_stmt|;
name|fmkdirs
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|fmkdirs
operator|=
name|strchr
argument_list|(
name|q
operator|->
name|zoptions
argument_list|,
literal|'f'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
comment|/* Now we have to process each source file.  The      source specification may or may use wildcards.  */
if|if
condition|(
operator|!
name|fsysdep_wildcard_start
argument_list|(
name|qsys
argument_list|,
name|q
operator|->
name|zfrom
argument_list|)
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
operator|(
name|zfile
operator|=
name|zsysdep_wildcard
argument_list|(
name|qsys
argument_list|,
name|q
operator|->
name|zfrom
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|zsend
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
name|char
name|abtname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zfile
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zcopy
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
name|zfile
operator|=
name|zcopy
expr_stmt|;
comment|/* Make sure the remote system is permitted to read the 	 specified file.  */
name|zsend
operator|=
name|qsys
operator|->
name|zremote_send
expr_stmt|;
if|if
condition|(
operator|!
name|fcaller
operator|&&
name|qsys
operator|->
name|zcalled_remote_send
operator|!=
name|NULL
condition|)
name|zsend
operator|=
name|qsys
operator|->
name|zcalled_remote_send
expr_stmt|;
if|if
condition|(
operator|!
name|fin_directory_list
argument_list|(
name|qsys
argument_list|,
name|zfile
argument_list|,
name|zsend
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Not permitted to send %s"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_wildcard_end
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|qdestsys
operator|!=
name|NULL
condition|)
block|{
comment|/* We really should get the original grade here.  */
name|zto
operator|=
name|zsysdep_data_file_name
argument_list|(
name|qdestsys
argument_list|,
name|BDEFAULT_UUCP_GRADE
argument_list|,
name|abtname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|zrec
decl_stmt|;
name|zto
operator|=
name|zsysdep_real_file_name
argument_list|(
name|qsys
argument_list|,
name|zexclam
operator|+
literal|1
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|zto
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_wildcard_end
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We only accept a local destination if the remote system 	     has the right to create files there.  */
name|zrec
operator|=
name|qsys
operator|->
name|zremote_receive
expr_stmt|;
if|if
condition|(
operator|!
name|fcaller
operator|&&
name|qsys
operator|->
name|zcalled_remote_receive
operator|!=
name|NULL
condition|)
name|zrec
operator|=
name|qsys
operator|->
name|zcalled_remote_receive
expr_stmt|;
if|if
condition|(
operator|!
name|fin_directory_list
argument_list|(
name|qsys
argument_list|,
name|zto
argument_list|,
name|zrec
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Not permitted to receive %s"
argument_list|,
name|zto
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_wildcard_end
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Copy the file either to the final destination or to the 	 spool directory.  */
if|if
condition|(
operator|!
name|fcopy_file
argument_list|(
name|zfile
argument_list|,
name|zto
argument_list|,
name|qdestsys
operator|==
name|NULL
argument_list|,
name|fmkdirs
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_wildcard_end
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If there is a destination system, queue it up.  */
if|if
condition|(
name|qdestsys
operator|!=
name|NULL
condition|)
block|{
name|struct
name|scmd
name|ssend
decl_stmt|;
name|ssend
operator|.
name|bcmd
operator|=
literal|'S'
expr_stmt|;
name|ssend
operator|.
name|pseq
operator|=
name|NULL
expr_stmt|;
name|ssend
operator|.
name|zfrom
operator|=
name|zfile
expr_stmt|;
name|ssend
operator|.
name|zto
operator|=
name|zdestfile
expr_stmt|;
name|ssend
operator|.
name|zuser
operator|=
name|zuser
expr_stmt|;
name|ssend
operator|.
name|zoptions
operator|=
name|aboptions
expr_stmt|;
name|ssend
operator|.
name|ztemp
operator|=
name|abtname
expr_stmt|;
name|ssend
operator|.
name|imode
operator|=
name|isysdep_file_mode
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssend
operator|.
name|imode
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_wildcard_end
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ssend
operator|.
name|znotify
operator|=
literal|""
expr_stmt|;
name|ssend
operator|.
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|zsysdep_spool_commands
argument_list|(
name|qdestsys
argument_list|,
name|BDEFAULT_UUCP_GRADE
argument_list|,
literal|1
argument_list|,
operator|&
name|ssend
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_wildcard_end
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|fsysdep_wildcard_end
argument_list|()
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See whether it's OK to send a file to another system, according to    the permissions recorded for that system.  If the file is not in    the spool directory, this also makes sure that the user has    permission to access the file and all its containing directories.     zfile -- file to send    flocal -- TRUE if the send was requested locally    fcaller -- TRUE if the local system called the other system    fspool -- TRUE if file was copied to spool directory    qsys -- remote system information    zuser -- user who requested the action  */
end_comment

begin_function
specifier|static
name|boolean
name|fok_to_send
parameter_list|(
name|zfile
parameter_list|,
name|flocal
parameter_list|,
name|fcaller
parameter_list|,
name|fspool
parameter_list|,
name|qsys
parameter_list|,
name|zuser
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
name|boolean
name|flocal
decl_stmt|;
name|boolean
name|fcaller
decl_stmt|;
name|boolean
name|fspool
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
operator|!
name|frequest_ok
argument_list|(
name|flocal
argument_list|,
name|fcaller
argument_list|,
name|qsys
argument_list|,
name|zuser
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|flocal
condition|)
block|{
name|z
operator|=
name|qsys
operator|->
name|zlocal_send
expr_stmt|;
if|if
condition|(
operator|!
name|fcaller
operator|&&
name|qsys
operator|->
name|zcalled_local_send
operator|!=
name|NULL
condition|)
name|z
operator|=
name|qsys
operator|->
name|zcalled_local_send
expr_stmt|;
block|}
else|else
block|{
name|z
operator|=
name|qsys
operator|->
name|zremote_send
expr_stmt|;
if|if
condition|(
operator|!
name|fcaller
operator|&&
name|qsys
operator|->
name|zcalled_remote_send
operator|!=
name|NULL
condition|)
name|z
operator|=
name|qsys
operator|->
name|zcalled_remote_send
expr_stmt|;
block|}
comment|/* If fspool is TRUE, we don't want to check file accessibility.  If      this was not a local request, we pass a NULL down as the user      name, since zuser has no meaning on this system.  */
return|return
name|fin_directory_list
argument_list|(
name|qsys
argument_list|,
name|zfile
argument_list|,
name|z
argument_list|,
operator|!
name|fspool
argument_list|,
name|TRUE
argument_list|,
name|flocal
condition|?
name|zuser
else|:
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* See whether it's OK to receive a file from another system.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|fok_to_receive
parameter_list|(
name|zto
parameter_list|,
name|flocal
parameter_list|,
name|fcaller
parameter_list|,
name|qsys
parameter_list|,
name|zuser
parameter_list|)
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
name|boolean
name|flocal
decl_stmt|;
name|boolean
name|fcaller
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
operator|!
name|frequest_ok
argument_list|(
name|flocal
argument_list|,
name|fcaller
argument_list|,
name|qsys
argument_list|,
name|zuser
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|flocal
condition|)
block|{
name|z
operator|=
name|qsys
operator|->
name|zlocal_receive
expr_stmt|;
if|if
condition|(
operator|!
name|fcaller
operator|&&
name|qsys
operator|->
name|zcalled_local_receive
operator|!=
name|NULL
condition|)
name|z
operator|=
name|qsys
operator|->
name|zcalled_local_receive
expr_stmt|;
block|}
else|else
block|{
name|z
operator|=
name|qsys
operator|->
name|zremote_receive
expr_stmt|;
if|if
condition|(
operator|!
name|fcaller
operator|&&
name|qsys
operator|->
name|zcalled_remote_receive
operator|!=
name|NULL
condition|)
name|z
operator|=
name|qsys
operator|->
name|zcalled_remote_receive
expr_stmt|;
block|}
return|return
name|fin_directory_list
argument_list|(
name|qsys
argument_list|,
name|zto
argument_list|,
name|z
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|flocal
condition|?
name|zuser
else|:
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* See whether a request is OK.  This depends on which system placed    the call and which system made the request.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|frequest_ok
parameter_list|(
name|flocal
parameter_list|,
name|fcaller
parameter_list|,
name|qsys
parameter_list|,
name|zuser
parameter_list|)
name|boolean
name|flocal
decl_stmt|;
name|boolean
name|fcaller
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
block|{
if|if
condition|(
name|flocal
condition|)
block|{
if|if
condition|(
name|fcaller
condition|)
return|return
name|qsys
operator|->
name|fcall_transfer
return|;
else|else
return|return
name|qsys
operator|->
name|fcalled_transfer
return|;
block|}
else|else
block|{
if|if
condition|(
name|fcaller
condition|)
return|return
name|qsys
operator|->
name|fcall_request
return|;
else|else
return|return
name|qsys
operator|->
name|fcalled_request
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a string to the other system beginning with a DLE    character and terminated with a null byte.  This is only    used when no protocol is in force.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsend_uucp_cmd
parameter_list|(
name|z
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
block|{
name|char
modifier|*
name|zalc
decl_stmt|;
name|int
name|cwrite
decl_stmt|;
name|cwrite
operator|=
name|strlen
argument_list|(
name|z
argument_list|)
operator|+
literal|2
expr_stmt|;
name|zalc
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|cwrite
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zalc
argument_list|,
literal|"\020%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
return|return
name|fport_write
argument_list|(
name|zalc
argument_list|,
name|cwrite
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a UUCP command beginning with a DLE character and ending with a    null byte.  This is only used when no protocol is in force.  This    implementation has the potential of being seriously slow.  It also    doesn't have any real error recovery.  The frequired argument is    passed as TRUE if we need the string; we don't care that much if    we're closing down the connection anyhow.  */
end_comment

begin_define
define|#
directive|define
name|CTIMEOUT
value|(120)
end_define

begin_define
define|#
directive|define
name|CSHORTTIMEOUT
value|(10)
end_define

begin_define
define|#
directive|define
name|CINCREMENT
value|(10)
end_define

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|zget_uucp_cmd
parameter_list|(
name|frequired
parameter_list|)
name|boolean
name|frequired
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|zalc
decl_stmt|;
specifier|static
name|int
name|calc
decl_stmt|;
name|int
name|cgot
decl_stmt|;
name|long
name|iendtime
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|int
name|cchars
decl_stmt|;
name|int
name|iolddebug
decl_stmt|;
endif|#
directive|endif
name|iendtime
operator|=
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|frequired
condition|)
name|iendtime
operator|+=
name|CTIMEOUT
expr_stmt|;
else|else
name|iendtime
operator|+=
name|CSHORTTIMEOUT
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|cchars
operator|=
literal|0
expr_stmt|;
name|iolddebug
operator|=
name|iDebug
expr_stmt|;
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"zget_uucp_cmd: Got \""
argument_list|)
expr_stmt|;
name|iDebug
operator|&=
operator|~
operator|(
name|DEBUG_INCOMING
operator||
name|DEBUG_PORT
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cgot
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|ctimeout
operator|=
call|(
name|int
call|)
argument_list|(
name|iendtime
operator|-
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|b
decl_stmt|;
name|b
operator|=
name|breceive_char
argument_list|(
name|ctimeout
argument_list|,
name|frequired
argument_list|)
expr_stmt|;
comment|/* Now b == -1 on timeout, -2 on error.  */
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\" (%s)"
argument_list|,
name|b
operator|==
operator|-
literal|1
condition|?
literal|"timeout"
else|:
literal|"error"
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|b
operator|==
operator|-
literal|1
operator|&&
name|frequired
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timeout"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Apparently some systems use parity on these strings, so we 	 strip the parity bit.  This may need to be configurable at 	 some point, although only if system names can have eight bit 	 characters.  */
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|BUCHAR
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
name|b
operator|&=
literal|0x7f
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|)
condition|)
block|{
name|char
name|ab
index|[
literal|5
index|]
decl_stmt|;
operator|++
name|cchars
expr_stmt|;
if|if
condition|(
name|cchars
operator|>
literal|60
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"zget_uucp_cmd: Got \""
argument_list|)
expr_stmt|;
name|cchars
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|cdebug_char
argument_list|(
name|ab
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|"%s"
argument_list|,
name|ab
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|cgot
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|!=
literal|'\020'
condition|)
continue|continue;
name|cgot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* If we see another DLE, something has gone wrong; continue 	 as though this were the first one we saw.  */
if|if
condition|(
name|b
operator|==
literal|'\020'
condition|)
block|{
name|cgot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Some systems send a trailing \n on the Shere line.  As far as 	 I can tell this line can never contain a \n, so this 	 modification should be safe enough.  */
if|if
condition|(
name|b
operator|==
literal|'\r'
operator|||
name|b
operator|==
literal|'\n'
condition|)
name|b
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cgot
operator|>=
name|calc
condition|)
block|{
name|calc
operator|+=
name|CINCREMENT
expr_stmt|;
name|zalc
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|zalc
argument_list|,
name|calc
argument_list|)
expr_stmt|;
block|}
name|zalc
index|[
name|cgot
index|]
operator|=
operator|(
name|char
operator|)
name|b
expr_stmt|;
operator|++
name|cgot
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|'\0'
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|zalc
return|;
block|}
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_HANDSHAKE
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\" (timeout)"
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|frequired
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timeout"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Read a sequence of characters up to a newline or carriage return, and    return the line without the line terminating character.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|zget_typed_line
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|zalc
decl_stmt|;
specifier|static
name|int
name|calc
decl_stmt|;
name|int
name|cgot
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|int
name|cchars
decl_stmt|;
name|int
name|iolddebug
decl_stmt|;
name|cchars
operator|=
literal|0
expr_stmt|;
name|iolddebug
operator|=
name|iDebug
expr_stmt|;
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"zget_typed_line: Got \""
argument_list|)
expr_stmt|;
name|iDebug
operator|&=
operator|~
operator|(
name|DEBUG_INCOMING
operator||
name|DEBUG_PORT
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cgot
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|int
name|b
decl_stmt|;
name|b
operator|=
name|breceive_char
argument_list|(
name|CTIMEOUT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Now b == -1 on timeout, -2 on error.  */
if|if
condition|(
name|b
operator|==
operator|-
literal|2
operator|||
name|FGOT_SIGNAL
argument_list|()
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\" (error)"
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|char
name|ab
index|[
literal|5
index|]
decl_stmt|;
operator|++
name|cchars
expr_stmt|;
if|if
condition|(
name|cchars
operator|>
literal|60
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"zget_typed_line: Got \""
argument_list|)
expr_stmt|;
name|cchars
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|cdebug_char
argument_list|(
name|ab
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|"%s"
argument_list|,
name|ab
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|cgot
operator|>=
name|calc
condition|)
block|{
name|calc
operator|+=
name|CINCREMENT
expr_stmt|;
name|zalc
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|zalc
argument_list|,
name|calc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
literal|'\r'
operator|||
name|b
operator|==
literal|'\n'
condition|)
name|b
operator|=
literal|'\0'
expr_stmt|;
name|zalc
index|[
name|cgot
index|]
operator|=
operator|(
name|char
operator|)
name|b
expr_stmt|;
operator|++
name|cgot
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|'\0'
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|zalc
return|;
block|}
block|}
block|}
end_function

end_unit

