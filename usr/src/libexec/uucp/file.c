begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* file.c    Generic routines to handle files.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: file.c,v $    Revision 1.16  1992/03/30  04:07:13  ian    Dirk Musstopf: remove temporary file if receive fails     Revision 1.15  1992/03/17  00:31:33  ian    Changed iRecmode to unsigned int     Revision 1.14  1992/03/11  01:18:15  ian    Niels Baggesen: drop the connection on a write failure     Revision 1.13  1992/03/11  00:18:50  ian    Save temporary file if file send fails     Revision 1.12  1992/02/29  01:06:59  ian    Chip Salzenberg: recheck file permissions before sending     Revision 1.11  1992/02/19  19:36:07  ian    Rearranged time functions     Revision 1.10  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.9  1992/01/18  22:48:53  ian    Reworked sending of mail and general handling of failed transfers     Revision 1.8  1991/12/21  23:10:43  ian    Terry Gardner: record failed file transfers in statistics file     Revision 1.7  1991/12/17  07:09:58  ian    Record statistics in fractions of a second     Revision 1.6  1991/12/10  19:29:02  ian    Move statistics file stuff from file.c to log.c     Revision 1.5  1991/11/10  19:24:22  ian    Added pffile protocol entry point for file level control     Revision 1.4  1991/11/08  04:30:50  ian    Hannu Strang: flush statistics file after each line     Revision 1.3  1991/11/07  19:42:16  ian    Chip Salzenberg: declare inline functions consistently     Revision 1.2  1991/09/19  03:23:34  ian    Chip Salzenberg: append to private debugging file, don't overwrite it     Revision 1.1  1991/09/10  19:40:31  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|file_rcsid
index|[]
init|=
literal|"$Id: file.c,v 1.16 1992/03/30 04:07:13 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Current file being sent.  */
end_comment

begin_decl_stmt
name|openfile_t
name|eSendfile
init|=
name|EFILECLOSED
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current file being received.  */
end_comment

begin_decl_stmt
name|openfile_t
name|eRecfile
init|=
name|EFILECLOSED
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This file has to keep several strings.  I don't want to pay for the    overhead (small as it is) of calling malloc for each one, and I also    don't want to truncate the strings.  So I use a structure which holds    strings up to a certain length, and call malloc for longer strings.    NULL strings are indistinguishable from empty strings, which turns    out not to matter.  */
end_comment

begin_define
define|#
directive|define
name|CSTRLEN
value|(30)
end_define

begin_struct
struct|struct
name|sstring
block|{
name|char
name|ab
index|[
name|CSTRLEN
index|]
decl_stmt|;
name|char
modifier|*
name|zalloc
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
name|__inline__
specifier|static
name|boolean
name|ffsetstring
name|P
argument_list|(
operator|(
expr|struct
name|sstring
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|__inline__
specifier|static
specifier|const
name|char
modifier|*
name|zfgetstring
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|sstring
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|__inline__
specifier|static
name|void
name|uffreestring
name|P
argument_list|(
operator|(
expr|struct
name|sstring
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|__inline__
specifier|static
name|boolean
name|ffsetstring
parameter_list|(
name|q
parameter_list|,
name|z
parameter_list|)
name|struct
name|sstring
modifier|*
name|q
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
block|{
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
name|q
operator|->
name|ab
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|z
argument_list|)
operator|<
name|CSTRLEN
condition|)
name|strcpy
argument_list|(
name|q
operator|->
name|ab
argument_list|,
name|z
argument_list|)
expr_stmt|;
else|else
block|{
name|q
operator|->
name|zalloc
operator|=
name|strdup
argument_list|(
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|zalloc
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Not enough memory to store command"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|__inline__
specifier|static
specifier|const
name|char
modifier|*
name|zfgetstring
parameter_list|(
name|q
parameter_list|)
specifier|const
name|struct
name|sstring
modifier|*
name|q
decl_stmt|;
block|{
if|if
condition|(
name|q
operator|->
name|zalloc
operator|!=
name|NULL
condition|)
return|return
name|q
operator|->
name|zalloc
return|;
else|else
return|return
name|q
operator|->
name|ab
return|;
block|}
end_function

begin_function
name|__inline__
specifier|static
name|void
name|uffreestring
parameter_list|(
name|q
parameter_list|)
name|struct
name|sstring
modifier|*
name|q
decl_stmt|;
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|q
operator|->
name|zalloc
argument_list|)
expr_stmt|;
name|q
operator|->
name|zalloc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Information we keep for the file being sent.  We have to be able to    send mail to the user when the transfer is finished, we have to be    able to report error messages sensibly, and we have to be able to    clear this send request out of the work queue if we initiated the    send.  */
end_comment

begin_comment
comment|/* Work queue sequence number.  */
end_comment

begin_decl_stmt
specifier|static
name|pointer
name|pSendseq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File name being transferred from.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sstring
name|sSendfrom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File name being transferred to.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sstring
name|sSendto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* System being transferred to.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sstring
name|sSendtosys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Requesting user name.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sstring
name|sSenduser
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User to send mail to.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sstring
name|sSendmail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start time.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|iSendstart_secs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|iSendstart_micros
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate whether we had an error during the transfer.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fSenderror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store information about a file being sent.  */
end_comment

begin_function
name|boolean
name|fstore_sendfile
parameter_list|(
name|e
parameter_list|,
name|pseq
parameter_list|,
name|zfrom
parameter_list|,
name|zto
parameter_list|,
name|ztosys
parameter_list|,
name|zuser
parameter_list|,
name|zmail
parameter_list|)
name|openfile_t
name|e
decl_stmt|;
name|pointer
name|pseq
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztosys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
specifier|const
name|char
modifier|*
name|zmail
decl_stmt|;
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|ffileisopen
argument_list|(
name|eSendfile
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fstore_sendfile: In progress"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ffsetstring
argument_list|(
operator|&
name|sSendfrom
argument_list|,
name|zfrom
argument_list|)
operator|||
operator|!
name|ffsetstring
argument_list|(
operator|&
name|sSendto
argument_list|,
name|zto
argument_list|)
operator|||
operator|!
name|ffsetstring
argument_list|(
operator|&
name|sSendtosys
argument_list|,
name|ztosys
argument_list|)
operator|||
operator|!
name|ffsetstring
argument_list|(
operator|&
name|sSenduser
argument_list|,
name|zuser
argument_list|)
operator|||
operator|!
name|ffsetstring
argument_list|(
operator|&
name|sSendmail
argument_list|,
name|zmail
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|eSendfile
operator|=
name|e
expr_stmt|;
name|pSendseq
operator|=
name|pseq
expr_stmt|;
name|iSendstart_secs
operator|=
name|isysdep_process_time
argument_list|(
operator|&
name|iSendstart_micros
argument_list|)
expr_stmt|;
name|fSenderror
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up after sending a file.  The freceived argument indicates    whether the other file received it successfully.  The cbytes    argument is the number of bytes that were sent (for the statistics    entry).  The zwhy argument holds a reason for failure if freceived    is FALSE.  The fnever argument is TRUE if the file was not received    correctly and, moreover, will never be received correctly.  */
end_comment

begin_function
name|boolean
name|fsent_file
parameter_list|(
name|freceived
parameter_list|,
name|cbytes
parameter_list|,
name|zwhy
parameter_list|,
name|fnever
parameter_list|)
name|boolean
name|freceived
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwhy
decl_stmt|;
name|boolean
name|fnever
decl_stmt|;
block|{
name|boolean
name|f
decl_stmt|;
name|long
name|isecs
decl_stmt|,
name|imicros
decl_stmt|;
name|f
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fSenderror
condition|)
name|freceived
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ffileisopen
argument_list|(
name|eSendfile
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|eSendfile
argument_list|)
expr_stmt|;
name|isecs
operator|=
name|isysdep_process_time
argument_list|(
operator|&
name|imicros
argument_list|)
expr_stmt|;
name|imicros
operator|-=
name|iSendstart_micros
expr_stmt|;
if|if
condition|(
name|imicros
operator|<
literal|0
condition|)
block|{
name|imicros
operator|+=
literal|1000000
expr_stmt|;
name|isecs
operator|--
expr_stmt|;
block|}
name|isecs
operator|-=
name|iSendstart_secs
expr_stmt|;
name|ustats
argument_list|(
name|freceived
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sSenduser
argument_list|)
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sSendtosys
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|cbytes
argument_list|,
name|isecs
argument_list|,
name|imicros
argument_list|)
expr_stmt|;
if|if
condition|(
name|freceived
condition|)
block|{
specifier|const
name|char
modifier|*
name|zmail
decl_stmt|;
name|zmail
operator|=
name|zfgetstring
argument_list|(
operator|&
name|sSendmail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zmail
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|fmail_transfer
argument_list|(
name|TRUE
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sSenduser
argument_list|)
argument_list|,
name|zmail
argument_list|,
name|zwhy
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sSendfrom
argument_list|)
argument_list|,
name|zLocalname
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sSendto
argument_list|)
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sSendtosys
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
name|f
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|pSendseq
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_did_work
argument_list|(
name|pSendseq
argument_list|)
condition|)
name|f
operator|=
name|FALSE
expr_stmt|;
name|pSendseq
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If the transfer failed, we only try to save the file and send 	 mail if it was requested locally (in which case pSendseq != 	 NULL) and it will never succeed.  We send mail to sSendmail 	 if defined, otherwise to sSenduser.  I hope this is 	 reasonable.  */
if|if
condition|(
name|pSendseq
operator|!=
name|NULL
operator|&&
name|fnever
condition|)
block|{
if|if
condition|(
operator|!
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sSenduser
argument_list|)
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sSendmail
argument_list|)
argument_list|,
name|zwhy
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sSendfrom
argument_list|)
argument_list|,
name|zLocalname
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sSendto
argument_list|)
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sSendtosys
argument_list|)
argument_list|,
name|zsysdep_save_temp_file
argument_list|(
name|pSendseq
argument_list|)
argument_list|)
condition|)
name|f
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_did_work
argument_list|(
name|pSendseq
argument_list|)
condition|)
name|f
operator|=
name|FALSE
expr_stmt|;
name|pSendseq
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|eSendfile
operator|=
name|EFILECLOSED
expr_stmt|;
name|uffreestring
argument_list|(
operator|&
name|sSendfrom
argument_list|)
expr_stmt|;
name|uffreestring
argument_list|(
operator|&
name|sSendto
argument_list|)
expr_stmt|;
name|uffreestring
argument_list|(
operator|&
name|sSendtosys
argument_list|)
expr_stmt|;
name|uffreestring
argument_list|(
operator|&
name|sSenduser
argument_list|)
expr_stmt|;
name|uffreestring
argument_list|(
operator|&
name|sSendmail
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* Some error occurred while sending a file.  Mark an error and let    fsent_file handle everything else.  This used to differentiate    between temporary and permanent errors, but I've decided that all    transmission errors are temporary.  */
end_comment

begin_function
name|void
name|usendfile_error
parameter_list|()
block|{
name|fSenderror
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Information we keep for the file being received.  We have to be    able to move the file into its final location with the correct    mode, we have to be able to send mail to the user when the transfer    is finished, we have to be able to report error messages sensibly,    and we have to be able to clear this receive request out of the    work queue if we initiated the receive.  */
end_comment

begin_comment
comment|/* Work queue sequence number.  */
end_comment

begin_decl_stmt
specifier|static
name|pointer
name|pRecseq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File name being transferred from.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sstring
name|sRecfrom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File name being transferred to.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sstring
name|sRecto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* System being transferred from.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sstring
name|sRecfromsys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Requesting user name.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sstring
name|sRecuser
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Final file mode.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|iRecmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User to send mail to.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sstring
name|sRecmail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary file name (as returned by esysdep_open_receive).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sstring
name|sRectemp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start time.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|iRecstart_secs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|iRecstart_micros
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate whether we had an error during the transfer.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fRecerror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store information about a file being received.  */
end_comment

begin_function
name|boolean
name|fstore_recfile
parameter_list|(
name|e
parameter_list|,
name|pseq
parameter_list|,
name|zfrom
parameter_list|,
name|zto
parameter_list|,
name|zfromsys
parameter_list|,
name|zuser
parameter_list|,
name|imode
parameter_list|,
name|zmail
parameter_list|,
name|ztemp
parameter_list|)
name|openfile_t
name|e
decl_stmt|;
name|pointer
name|pseq
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfromsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
name|unsigned
name|int
name|imode
decl_stmt|;
specifier|const
name|char
modifier|*
name|zmail
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztemp
decl_stmt|;
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|ffileisopen
argument_list|(
name|eRecfile
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fstore_recfile: In progress"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ffsetstring
argument_list|(
operator|&
name|sRecfrom
argument_list|,
name|zfrom
argument_list|)
operator|||
operator|!
name|ffsetstring
argument_list|(
operator|&
name|sRecto
argument_list|,
name|zto
argument_list|)
operator|||
operator|!
name|ffsetstring
argument_list|(
operator|&
name|sRecfromsys
argument_list|,
name|zfromsys
argument_list|)
operator|||
operator|!
name|ffsetstring
argument_list|(
operator|&
name|sRecuser
argument_list|,
name|zuser
argument_list|)
operator|||
operator|!
name|ffsetstring
argument_list|(
operator|&
name|sRecmail
argument_list|,
name|zmail
argument_list|)
operator|||
operator|!
name|ffsetstring
argument_list|(
operator|&
name|sRectemp
argument_list|,
name|ztemp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|eRecfile
operator|=
name|e
expr_stmt|;
name|pRecseq
operator|=
name|pseq
expr_stmt|;
name|iRecmode
operator|=
name|imode
expr_stmt|;
name|iRecstart_secs
operator|=
name|isysdep_process_time
argument_list|(
operator|&
name|iRecstart_micros
argument_list|)
expr_stmt|;
name|fRecerror
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up after receiving a file.  The argument indicates whether    the data was received correctly.  We do not confirm the file    reception to the other system unless this function returns TRUE.    This may be called when no file receive is in progress if a fatal    program error occurs.  The zwhy and fnever arguments are valid if    fsent is FALSE; fnever is TRUE if the file receive can never    succeed.  */
end_comment

begin_function
name|boolean
name|freceived_file
parameter_list|(
name|fsent
parameter_list|,
name|cbytes
parameter_list|,
name|zwhy
parameter_list|,
name|fnever
parameter_list|)
name|boolean
name|fsent
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwhy
decl_stmt|;
name|boolean
name|fnever
decl_stmt|;
block|{
name|long
name|isecs
decl_stmt|,
name|imicros
decl_stmt|;
if|if
condition|(
name|fRecerror
condition|)
name|fsent
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ffileisopen
argument_list|(
name|eRecfile
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ffileclose
argument_list|(
name|eRecfile
argument_list|)
condition|)
block|{
if|if
condition|(
name|fsent
condition|)
block|{
name|zwhy
operator|=
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|fnever
operator|=
name|FALSE
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"close: %s"
argument_list|,
name|zwhy
argument_list|)
expr_stmt|;
block|}
name|fsent
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fsent
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_move_file
argument_list|(
name|zfgetstring
argument_list|(
operator|&
name|sRectemp
argument_list|)
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sRecto
argument_list|)
argument_list|,
name|iRecmode
argument_list|,
name|TRUE
argument_list|,
operator|(
name|pRecseq
operator|!=
name|NULL
condition|?
name|zfgetstring
argument_list|(
operator|&
name|sRecuser
argument_list|)
else|:
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
operator|)
argument_list|)
condition|)
block|{
name|zwhy
operator|=
literal|"could not move to final location"
expr_stmt|;
name|fnever
operator|=
name|TRUE
expr_stmt|;
name|fsent
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zfgetstring
argument_list|(
operator|&
name|sRectemp
argument_list|)
argument_list|)
expr_stmt|;
name|isecs
operator|=
name|isysdep_process_time
argument_list|(
operator|&
name|imicros
argument_list|)
expr_stmt|;
name|imicros
operator|-=
name|iRecstart_micros
expr_stmt|;
if|if
condition|(
name|imicros
operator|<
literal|0
condition|)
block|{
name|imicros
operator|+=
literal|1000000
expr_stmt|;
name|isecs
operator|--
expr_stmt|;
block|}
name|isecs
operator|-=
name|iRecstart_secs
expr_stmt|;
name|ustats
argument_list|(
name|fsent
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sRecuser
argument_list|)
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sRecfromsys
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|cbytes
argument_list|,
name|isecs
argument_list|,
name|imicros
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsent
condition|)
block|{
specifier|const
name|char
modifier|*
name|zmail
decl_stmt|;
name|zmail
operator|=
name|zfgetstring
argument_list|(
operator|&
name|sRecmail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zmail
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|TRUE
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sRecuser
argument_list|)
argument_list|,
name|zmail
argument_list|,
name|zwhy
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sRecfrom
argument_list|)
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sRecfromsys
argument_list|)
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sRecto
argument_list|)
argument_list|,
name|zLocalname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pRecseq
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_did_work
argument_list|(
name|pRecseq
argument_list|)
condition|)
name|fsent
operator|=
name|FALSE
expr_stmt|;
name|pRecseq
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If the transfer failed, we send mail if it was requested 	 locally and if it can never succeed.  */
if|if
condition|(
name|pRecseq
operator|!=
name|NULL
operator|&&
name|fnever
condition|)
block|{
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sRecuser
argument_list|)
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sRecmail
argument_list|)
argument_list|,
name|zwhy
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sRecfrom
argument_list|)
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sRecfromsys
argument_list|)
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sRecto
argument_list|)
argument_list|,
name|zLocalname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_did_work
argument_list|(
name|pRecseq
argument_list|)
condition|)
name|fsent
operator|=
name|FALSE
expr_stmt|;
name|pRecseq
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|eRecfile
operator|=
name|EFILECLOSED
expr_stmt|;
name|uffreestring
argument_list|(
operator|&
name|sRecfrom
argument_list|)
expr_stmt|;
name|uffreestring
argument_list|(
operator|&
name|sRecto
argument_list|)
expr_stmt|;
name|uffreestring
argument_list|(
operator|&
name|sRecfromsys
argument_list|)
expr_stmt|;
name|uffreestring
argument_list|(
operator|&
name|sRecuser
argument_list|)
expr_stmt|;
name|uffreestring
argument_list|(
operator|&
name|sRecmail
argument_list|)
expr_stmt|;
name|uffreestring
argument_list|(
operator|&
name|sRectemp
argument_list|)
expr_stmt|;
return|return
name|fsent
return|;
block|}
end_function

begin_comment
comment|/* Some error occurred while receiving a file.  Note that we had an    error, so that when we close up we know that something went wrong.    We leave the file open because it's easier to handle everything in    freceived_file.  This used to differentiate between permanent    errors and temporary errors, but I've decided that all errors that    occur while the file is being transferred are temporary.  */
end_comment

begin_function
name|void
name|urecfile_error
parameter_list|()
block|{
name|fRecerror
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* There was some sort of protocol error while receiving the file,    so we want to try it again.  We must truncate the file.  */
end_comment

begin_function
name|boolean
name|frecfile_rewind
parameter_list|()
block|{
name|eRecfile
operator|=
name|esysdep_truncate
argument_list|(
name|eRecfile
argument_list|,
name|zfgetstring
argument_list|(
operator|&
name|sRectemp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|eRecfile
argument_list|)
condition|)
block|{
name|urecfile_error
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send mail about a file transfer.  We send to the given mailing    address if there is one, otherwise to the user.  */
end_comment

begin_function
name|boolean
name|fmail_transfer
parameter_list|(
name|fsuccess
parameter_list|,
name|zuser
parameter_list|,
name|zmail
parameter_list|,
name|zwhy
parameter_list|,
name|zfromfile
parameter_list|,
name|zfromsys
parameter_list|,
name|ztofile
parameter_list|,
name|ztosys
parameter_list|,
name|zsaved
parameter_list|)
name|boolean
name|fsuccess
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
specifier|const
name|char
modifier|*
name|zmail
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwhy
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfromfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfromsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztofile
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztosys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsaved
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zsendto
decl_stmt|;
specifier|const
name|char
modifier|*
name|az
index|[
literal|20
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|zmail
operator|!=
name|NULL
operator|&&
operator|*
name|zmail
operator|!=
literal|'\0'
condition|)
name|zsendto
operator|=
name|zmail
expr_stmt|;
else|else
name|zsendto
operator|=
name|zuser
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"The file\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zfromsys
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"!"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zfromfile
expr_stmt|;
if|if
condition|(
name|fsuccess
condition|)
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\nwas successfully transferred to\n\t"
expr_stmt|;
else|else
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\ncould not be transferred to\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|ztosys
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"!"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|ztofile
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\nas requested by\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zuser
expr_stmt|;
if|if
condition|(
operator|!
name|fsuccess
condition|)
block|{
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\nfor the following reason:\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zwhy
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|zsaved
operator|!=
name|NULL
condition|)
block|{
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zsaved
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\n"
expr_stmt|;
block|}
return|return
name|fsysdep_mail
argument_list|(
name|zsendto
argument_list|,
name|fsuccess
condition|?
literal|"UUCP succeeded"
else|:
literal|"UUCP failed"
argument_list|,
name|i
argument_list|,
name|az
argument_list|)
return|;
block|}
end_function

end_unit

