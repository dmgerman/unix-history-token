begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* util.c    Utilities for the UUCP package.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: util.c,v $    Revision 1.11  1992/03/12  19:56:10  ian    Debugging based on types rather than number     Revision 1.10  1992/03/02  04:53:07  ian    Marc Unangst: added HAVE_SCO_LOCKFILES configuration parameter     Revision 1.9  1992/02/23  03:26:51  ian    Overhaul to use automatic configure shell script     Revision 1.8  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.7  1992/01/19  18:29:05  ian    Added HAVE_BSEARCH configuration parameter     Revision 1.6  1992/01/15  20:40:04  ian    Mike Park: some systems don't have<limits.h>     Revision 1.5  1991/12/28  06:10:50  ian    Added HAVE_STRCHR and HAVE_INDEX to conf.h     Revision 1.4  1991/12/28  03:49:23  ian    Added HAVE_MEMFNS and HAVE_BFNS; changed uses of memset to bzero     Revision 1.3  1991/12/11  19:35:48  ian    Mark Powell: put in my own version of strtol     Revision 1.2  1991/11/21  21:20:41  ian    Brian Campbell: offer str{n}icmp as an alternative to str{n}casecmp     Revision 1.1  1991/09/10  19:40:31  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|util_rcsid
index|[]
init|=
literal|"$Id: util.c,v 1.11 1992/03/12 19:56:10 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_LIMITS_H
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Allocate a block of memory without fail.  */
end_comment

begin_function
name|pointer
name|xmalloc
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|pointer
name|pret
decl_stmt|;
name|pret
operator|=
name|malloc
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|pret
operator|==
name|NULL
operator|&&
name|c
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
name|pret
return|;
block|}
end_function

begin_comment
comment|/* Realloc a block of memory without fail.  Supposedly some versions of    realloc can't handle a NULL first argument, so we check for that    here.  */
end_comment

begin_function
name|pointer
name|xrealloc
parameter_list|(
name|p
parameter_list|,
name|c
parameter_list|)
name|pointer
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|pointer
name|pret
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|xmalloc
argument_list|(
name|c
argument_list|)
return|;
name|pret
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|pret
operator|==
name|NULL
operator|&&
name|c
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
name|pret
return|;
block|}
end_function

begin_comment
comment|/* Some versions of free (like the one in SCO Unix 3.2.2) don't handle    null pointers correctly, so we go through our own routine.  */
end_comment

begin_function
name|void
name|xfree
parameter_list|(
name|p
parameter_list|)
name|pointer
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a string of arbitrary length from a stdio file, returning an    malloced memory area.  */
end_comment

begin_define
define|#
directive|define
name|CFGETSDEFAULT
value|(63)
end_define

begin_function
name|char
modifier|*
name|zfgets
parameter_list|(
name|e
parameter_list|,
name|fbackslash
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
name|boolean
name|fbackslash
decl_stmt|;
block|{
name|char
modifier|*
name|zret
decl_stmt|,
modifier|*
name|z
decl_stmt|,
modifier|*
name|zend
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|int
name|ichar
decl_stmt|;
name|clen
operator|=
name|CFGETSDEFAULT
expr_stmt|;
comment|/* Allocate one extra byte for the '\0'.  */
name|zret
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|z
operator|=
name|zret
expr_stmt|;
name|zend
operator|=
name|zret
operator|+
name|clen
expr_stmt|;
while|while
condition|(
operator|(
name|ichar
operator|=
name|getc
argument_list|(
name|e
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|z
operator|>=
name|zend
condition|)
block|{
name|char
modifier|*
name|znew
decl_stmt|;
name|clen
operator|+=
name|CFGETSDEFAULT
expr_stmt|;
comment|/* Allocate one extra byte for the '\0'.  */
name|znew
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|zret
argument_list|,
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|z
operator|=
name|znew
operator|+
operator|(
name|z
operator|-
name|zret
operator|)
expr_stmt|;
name|zret
operator|=
name|znew
expr_stmt|;
name|zend
operator|=
name|zret
operator|+
name|clen
expr_stmt|;
block|}
operator|*
name|z
operator|++
operator|=
operator|(
name|char
operator|)
name|ichar
expr_stmt|;
if|if
condition|(
name|ichar
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|fbackslash
operator|||
name|z
operator|-
name|zret
operator|<
literal|2
operator|||
name|z
index|[
operator|-
literal|2
index|]
operator|!=
literal|'\\'
condition|)
break|break;
name|z
operator|-=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|z
operator|==
name|zret
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|z
operator|=
literal|'\0'
expr_stmt|;
return|return
name|zret
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|HAVE_STRDUP
end_if

begin_comment
comment|/* Duplicate a string in memory.  */
end_comment

begin_function
name|char
modifier|*
name|strdup
parameter_list|(
name|z
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
block|{
name|char
modifier|*
name|zret
decl_stmt|;
name|zret
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|z
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zret
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|zret
argument_list|,
name|z
argument_list|)
expr_stmt|;
return|return
name|zret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_STRDUP */
end_comment

begin_comment
comment|/* Duplicate a string in memory with no errors.  */
end_comment

begin_function
name|char
modifier|*
name|xstrdup
parameter_list|(
name|z
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
block|{
name|char
modifier|*
name|zret
decl_stmt|;
name|zret
operator|=
name|strdup
argument_list|(
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|zret
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
name|zret
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|HAVE_STRSTR
end_if

begin_comment
comment|/* Look for one string inside another.  */
end_comment

begin_function
name|char
modifier|*
name|strstr
parameter_list|(
name|zhold
parameter_list|,
name|zwithin
parameter_list|)
specifier|const
name|char
modifier|*
name|zhold
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwithin
decl_stmt|;
block|{
specifier|register
name|char
name|b
decl_stmt|;
specifier|register
name|char
name|bwithin
decl_stmt|;
if|if
condition|(
operator|(
name|bwithin
operator|=
operator|*
name|zwithin
operator|++
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|zhold
return|;
while|while
condition|(
operator|(
name|b
operator|=
operator|*
name|zhold
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|bwithin
operator|==
name|b
condition|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|zout
decl_stmt|,
modifier|*
name|zin
decl_stmt|;
name|zout
operator|=
name|zhold
expr_stmt|;
name|zin
operator|=
name|zwithin
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|zin
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|zhold
operator|-
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|*
name|zout
operator|++
operator|==
operator|*
name|zin
operator|++
condition|)
do|;
block|}
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_STRSTR */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|HAVE_STRCASECMP
operator|&&
operator|!
name|HAVE_STRICMP
end_if

begin_comment
comment|/* Do a case insensitive string comparison.  */
end_comment

begin_function
name|int
name|strcasecmp
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|)
specifier|const
name|char
modifier|*
name|z1
decl_stmt|;
specifier|const
name|char
modifier|*
name|z2
decl_stmt|;
block|{
name|char
name|b1
decl_stmt|,
name|b2
decl_stmt|;
while|while
condition|(
operator|(
name|b1
operator|=
operator|*
name|z1
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|b2
operator|=
operator|*
name|z2
operator|++
expr_stmt|;
if|if
condition|(
name|b2
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|b1
operator|!=
name|b2
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|BUCHAR
argument_list|(
name|b1
argument_list|)
argument_list|)
condition|)
name|b1
operator|=
name|tolower
argument_list|(
name|BUCHAR
argument_list|(
name|b1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|BUCHAR
argument_list|(
name|b2
argument_list|)
argument_list|)
condition|)
name|b2
operator|=
name|tolower
argument_list|(
name|BUCHAR
argument_list|(
name|b2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|!=
name|b2
condition|)
return|return
name|b1
operator|-
name|b2
return|;
block|}
block|}
if|if
condition|(
operator|*
name|z2
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|strncasecmp
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|,
name|c
parameter_list|)
specifier|const
name|char
modifier|*
name|z1
decl_stmt|;
specifier|const
name|char
modifier|*
name|z2
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|char
name|b1
decl_stmt|,
name|b2
decl_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
name|b1
operator|=
operator|*
name|z1
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|b2
operator|=
operator|*
name|z2
operator|++
expr_stmt|;
if|if
condition|(
name|b2
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|b1
operator|!=
name|b2
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|BUCHAR
argument_list|(
name|b1
argument_list|)
argument_list|)
condition|)
name|b1
operator|=
name|tolower
argument_list|(
name|BUCHAR
argument_list|(
name|b1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|BUCHAR
argument_list|(
name|b2
argument_list|)
argument_list|)
condition|)
name|b2
operator|=
name|tolower
argument_list|(
name|BUCHAR
argument_list|(
name|b2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|!=
name|b2
condition|)
return|return
name|b1
operator|-
name|b2
return|;
block|}
operator|--
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|z2
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_STRCASECMP&& ! HAVE_STRICMP */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|HAVE_MEMCHR
end_if

begin_comment
comment|/* Find a single byte in a memory block.  */
end_comment

begin_function
name|pointer
name|memchr
parameter_list|(
name|parg
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|constpointer
name|parg
decl_stmt|;
name|int
name|b
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|parg
decl_stmt|;
name|b
operator|=
name|BUCHAR
argument_list|(
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
if|if
condition|(
name|BUCHAR
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|==
name|b
condition|)
return|return
operator|(
name|pointer
operator|)
operator|--
name|p
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_MEMCHR */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_MEMCMP
operator|&&
operator|!
name|HAVE_BCMP
end_if

begin_comment
comment|/* Compare two memory blocks.  */
end_comment

begin_function
name|int
name|memcmp
parameter_list|(
name|p1arg
parameter_list|,
name|p2arg
parameter_list|,
name|c
parameter_list|)
name|constpointer
name|p1arg
decl_stmt|;
name|constpointer
name|p2arg
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p1
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|p1arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|p2
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|p2arg
decl_stmt|;
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
return|return
name|BUCHAR
argument_list|(
operator|*
operator|--
name|p1
argument_list|)
operator|-
name|BUCHAR
argument_list|(
operator|*
operator|--
name|p2
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_MEMCMP&& ! HAVE_BCMP */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_MEMCPY
operator|&&
operator|!
name|HAVE_BCOPY
end_if

begin_comment
comment|/* Copy one memory block to another.  */
end_comment

begin_function
name|pointer
name|memcpy
parameter_list|(
name|ptoarg
parameter_list|,
name|pfromarg
parameter_list|,
name|c
parameter_list|)
name|pointer
name|ptoarg
decl_stmt|;
name|constpointer
name|pfromarg
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|char
modifier|*
name|pto
init|=
operator|(
name|char
operator|*
operator|)
name|ptoarg
decl_stmt|;
specifier|const
name|char
modifier|*
name|pfrom
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|pfromarg
decl_stmt|;
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
operator|*
name|pto
operator|++
operator|=
operator|*
name|pfrom
operator|++
expr_stmt|;
return|return
name|ptoarg
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_MEMCPY&& ! HAVE_BCOPY */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_BZERO
operator|&&
operator|!
name|HAVE_MEMSET
end_if

begin_comment
comment|/* Zero out a block of memory.  */
end_comment

begin_function
name|void
name|bzero
parameter_list|(
name|parg
parameter_list|,
name|c
parameter_list|)
name|pointer
name|parg
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|parg
decl_stmt|;
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_BZERO&& ! HAVE_MEMSET */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_MEMMOVE
end_if

begin_comment
comment|/* Move a memory block safely despite overlap.  This function is    almost impossible to write in strictly conforming C, because it    wants to compare pointers to different objects, but this    implementation will suffice for all normal systems.  I hope.  */
end_comment

begin_function
name|pointer
name|xmemmove
parameter_list|(
name|pto
parameter_list|,
name|pfrom
parameter_list|,
name|c
parameter_list|)
name|pointer
name|pto
decl_stmt|;
name|constpointer
name|pfrom
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|char
modifier|*
name|zto
init|=
operator|(
name|char
operator|*
operator|)
name|pto
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfrom
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|pfrom
decl_stmt|;
if|if
condition|(
name|zto
operator|<=
name|zfrom
operator|||
name|zto
operator|>=
name|zfrom
operator|+
name|c
condition|)
block|{
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
operator|*
name|zto
operator|++
operator|=
operator|*
name|zfrom
operator|++
expr_stmt|;
block|}
else|else
block|{
name|zto
operator|+=
name|c
expr_stmt|;
name|zfrom
operator|+=
name|c
expr_stmt|;
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
operator|*
operator|--
name|zto
operator|=
operator|*
operator|--
name|zfrom
expr_stmt|;
block|}
return|return
name|pto
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_MEMMOVE */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|HAVE_STRCHR
operator|&&
operator|!
name|HAVE_INDEX
end_if

begin_comment
comment|/* I doubt there are any systems for which this is true, but who    knows?  Provide my own version of strchr.  */
end_comment

begin_comment
comment|/* Look for a character in a string.  This is supposed to work for a    null byte, although we never actually call it with one.  */
end_comment

begin_function
name|char
modifier|*
name|strchr
parameter_list|(
name|z
parameter_list|,
name|b
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|b
decl_stmt|;
block|{
name|b
operator|=
operator|(
name|char
operator|)
name|b
expr_stmt|;
while|while
condition|(
operator|*
name|z
operator|!=
name|b
condition|)
if|if
condition|(
operator|*
name|z
operator|++
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|char
operator|*
operator|)
name|z
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_STRCHR&& ! HAVE_INDEX */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_STRRCHR
operator|&&
operator|!
name|HAVE_RINDEX
end_if

begin_comment
comment|/* Look for the last occurrence of a character in a string.  This is    supposed to work for a null byte, although we never actually call    it with one.  */
end_comment

begin_function
name|char
modifier|*
name|strrchr
parameter_list|(
name|z
parameter_list|,
name|b
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|b
decl_stmt|;
block|{
name|char
modifier|*
name|zret
decl_stmt|;
name|b
operator|=
operator|(
name|char
operator|)
name|b
expr_stmt|;
name|zret
operator|=
name|NULL
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|z
operator|==
name|b
condition|)
name|zret
operator|=
operator|(
name|char
operator|*
operator|)
name|z
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|z
operator|++
operator|!=
literal|'\0'
condition|)
do|;
return|return
name|zret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_STRRCHR&& ! HAVE_RINDEX */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|HAVE_STRLWR
end_if

begin_comment
comment|/* Convert a string to lower case.  */
end_comment

begin_function
name|char
modifier|*
name|strlwr
parameter_list|(
name|zarg
parameter_list|)
name|char
modifier|*
name|zarg
decl_stmt|;
block|{
name|char
modifier|*
name|z
init|=
name|zarg
decl_stmt|;
while|while
condition|(
operator|*
name|z
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|z
argument_list|)
condition|)
operator|*
name|z
operator|=
name|tolower
argument_list|(
operator|*
name|z
argument_list|)
expr_stmt|;
operator|++
name|z
expr_stmt|;
block|}
return|return
name|zarg
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_STRLWR */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|HAVE_STRTOL
end_if

begin_comment
comment|/* My own version of strtol.  This assumes that the upper case    characters appear in sequence and that the lower case characters    appear in sequence.  It also assumes that unsigned arithmetic is    performed correctly, but that's probably a safe assumption.  This    code needs only a couple of changes to also work as strtoul.  */
end_comment

begin_comment
comment|/* We need definitions for LONG_MAX and LONG_MIN; the limits that    appear here are those guaranteed by the C standard.  The value for    LONG_MIN is one greater than that applicable to most computers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_MAX
end_ifndef

begin_define
define|#
directive|define
name|LONG_MAX
value|(2147483647)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_MIN
end_ifndef

begin_define
define|#
directive|define
name|LONG_MIN
value|(- 2147483647)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|long
name|strtol
parameter_list|(
name|zarg
parameter_list|,
name|pzend
parameter_list|,
name|ibase
parameter_list|)
specifier|const
name|char
modifier|*
name|zarg
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzend
decl_stmt|;
name|int
name|ibase
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|z
decl_stmt|,
modifier|*
name|zsubj
decl_stmt|;
name|boolean
name|fsign
decl_stmt|;
name|unsigned
name|long
name|ival
decl_stmt|;
name|boolean
name|foverflow
decl_stmt|;
name|z
operator|=
name|zarg
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
condition|)
operator|++
name|z
expr_stmt|;
name|fsign
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|==
literal|'+'
condition|)
operator|++
name|z
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|z
operator|==
literal|'-'
condition|)
block|{
operator|++
name|z
expr_stmt|;
name|fsign
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ibase
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|z
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|z
index|[
literal|1
index|]
operator|==
literal|'X'
condition|)
block|{
name|z
operator|+=
literal|2
expr_stmt|;
name|ibase
operator|=
literal|16
expr_stmt|;
block|}
else|else
name|ibase
operator|=
literal|8
expr_stmt|;
block|}
else|else
name|ibase
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ibase
operator|==
literal|16
operator|&&
operator|*
name|z
operator|==
literal|'0'
operator|&&
operator|(
name|z
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|z
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
name|z
operator|+=
literal|2
expr_stmt|;
block|}
name|ival
operator|=
literal|0
expr_stmt|;
name|foverflow
operator|=
name|FALSE
expr_stmt|;
name|zsubj
operator|=
name|z
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|int
name|inext
decl_stmt|;
name|unsigned
name|long
name|itmp
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
condition|)
name|inext
operator|=
operator|*
name|z
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
condition|)
name|inext
operator|=
operator|*
name|z
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
condition|)
name|inext
operator|=
operator|*
name|z
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|inext
operator|>=
name|ibase
condition|)
break|break;
name|itmp
operator|=
name|ival
operator|*
name|ibase
operator|+
name|inext
expr_stmt|;
comment|/* Operations on unsigned values are performed using modulos 	 arithmetic.  Therefore any overflow will result in a smaller 	 number.  Note that we can't simply return out on overflow, 	 because we still have to determine the end of the subject 	 sequence.  */
if|if
condition|(
name|itmp
operator|<
name|ival
condition|)
name|foverflow
operator|=
name|TRUE
expr_stmt|;
name|ival
operator|=
name|itmp
expr_stmt|;
operator|++
name|z
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|==
name|zsubj
condition|)
block|{
if|if
condition|(
name|pzend
operator|!=
name|NULL
condition|)
operator|*
name|pzend
operator|=
operator|(
name|char
operator|*
operator|)
name|zarg
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pzend
operator|!=
name|NULL
condition|)
operator|*
name|pzend
operator|=
operator|(
name|char
operator|*
operator|)
name|z
expr_stmt|;
comment|/* Now checked for overflow as a signed type.  If this were strtoul,      we would just leave out this check.  Converting LONG_MIN, a      negative number, to unsigned long means adding it to ULONG_MAX +      1, which can not overflow since long and unsigned long are the      same size.  Negating an unsigned long, say i, means performing      the operation (ULONG_MAX + 1) - i, which clearly can not      overflow.  The result is thus (ULONG_MAX + 1) - ((ULONG_MAX + 1)      + LONG_MIN) == - LONG_MIN, which is the magnitude we are looking      for.  */
if|if
condition|(
name|fsign
condition|?
name|ival
operator|>
operator|(
name|unsigned
name|long
operator|)
name|LONG_MAX
else|:
name|ival
operator|>
operator|-
operator|(
name|unsigned
name|long
operator|)
name|LONG_MIN
condition|)
name|foverflow
operator|=
name|TRUE
expr_stmt|;
comment|/* If this were strtoul, we would return ULONG_MAX on overflow      regardless of the value of fsign.  */
if|if
condition|(
name|foverflow
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
if|if
condition|(
name|fsign
condition|)
return|return
name|LONG_MIN
return|;
else|else
return|return
name|LONG_MAX
return|;
block|}
if|if
condition|(
name|fsign
condition|)
name|ival
operator|=
operator|-
name|ival
expr_stmt|;
comment|/* If this were strtoul, we would not case the value before      returning.  */
return|return
operator|(
name|long
operator|)
name|ival
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_STRTOL */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|HAVE_BSEARCH
end_if

begin_comment
comment|/* Search for a key in a sorted array.  The third and fourth arguments    should be size_t, but int will suffice for my uses and spare me    from defining size_t portably.  */
end_comment

begin_function_decl
name|pointer
name|bsearch
parameter_list|(
name|pkey
parameter_list|,
name|parray
parameter_list|,
name|celes
parameter_list|,
name|cbytes
parameter_list|,
name|pficmp
parameter_list|)
name|constpointer
name|pkey
decl_stmt|;
name|constpointer
name|parray
decl_stmt|;
name|int
name|celes
decl_stmt|;
name|int
name|cbytes
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*pficmp
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
name|constpointer
operator|,
name|constpointer
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|const
name|char
modifier|*
name|zarray
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|parray
decl_stmt|;
name|int
name|ilow
decl_stmt|,
name|ihigh
decl_stmt|,
name|itrial
decl_stmt|;
name|ilow
operator|=
literal|0
expr_stmt|;
name|ihigh
operator|=
name|celes
expr_stmt|;
while|while
condition|(
name|ilow
operator|<
name|ihigh
condition|)
block|{
specifier|const
name|char
modifier|*
name|zcheck
decl_stmt|;
name|int
name|icmp
decl_stmt|;
name|itrial
operator|=
operator|(
name|ilow
operator|+
name|ihigh
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* Here ilow<= itrial< ihigh */
name|zcheck
operator|=
name|zarray
operator|+
name|itrial
operator|*
name|cbytes
expr_stmt|;
name|icmp
operator|=
call|(
modifier|*
name|pficmp
call|)
argument_list|(
name|pkey
argument_list|,
operator|(
name|constpointer
operator|)
name|zcheck
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmp
operator|<
literal|0
condition|)
name|ihigh
operator|=
name|itrial
expr_stmt|;
elseif|else
if|if
condition|(
name|icmp
operator|>
literal|0
condition|)
name|ilow
operator|=
name|itrial
operator|+
literal|1
expr_stmt|;
else|else
return|return
operator|(
name|pointer
operator|)
name|zcheck
return|;
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_BSEARCH */
end_comment

end_unit

