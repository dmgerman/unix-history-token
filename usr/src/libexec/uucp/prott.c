begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* prott.c    The 't' protocol.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: prott.c,v $    Revision 1.16  1992/03/30  04:49:10  ian    Niels Baggesen: added debugging types abnormal and uucp-proto     Revision 1.15  1992/03/17  01:03:03  ian    Miscellaneous cleanup     Revision 1.14  1992/03/13  22:59:25  ian    Have breceive_char go through freceive_data     Revision 1.13  1992/03/12  19:56:10  ian    Debugging based on types rather than number     Revision 1.12  1992/02/08  19:55:32  ian    Shifts of integers by more than 15 are not portable     Revision 1.11  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.10  1992/01/16  18:16:58  ian    Niels Baggesen: add some debugging messages     Revision 1.9  1991/12/31  19:34:19  ian    Added number of bytes to pffile protocol entry point     Revision 1.8  1991/12/28  03:49:23  ian    Added HAVE_MEMFNS and HAVE_BFNS; changed uses of memset to bzero     Revision 1.7  1991/12/17  22:13:14  ian    David Nugent: zero out garbage before sending data     Revision 1.6  1991/11/16  00:31:01  ian    Increased default 't' and 'f' protocol timeouts     Revision 1.5  1991/11/15  23:27:21  ian    Include system.h in prott.c and protf.c     Revision 1.4  1991/11/15  23:20:59  ian    Changed sleep to usysdep_sleep     Revision 1.3  1991/11/15  21:00:59  ian    Efficiency hacks for 'f' and 't' protocols     Revision 1.2  1991/11/13  20:44:20  ian    Learned author     Revision 1.1  1991/11/12  18:26:03  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|prott_rcsid
index|[]
init|=
literal|"$Id: prott.c,v 1.16 1992/03/30 04:49:10 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* This implementation is based on code written by Rick Adams.     This code implements the 't' protocol, which does no error checking    whatsoever and thus requires an end-to-end verified eight bit    communication line, such as is provided by TCP.  Using it with a    modem is unadvisable, since errors can occur between the modem and    the computer.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The buffer size we use.  */
end_comment

begin_define
define|#
directive|define
name|CTBUFSIZE
value|(1024)
end_define

begin_comment
comment|/* The offset in the buffer to the data.  */
end_comment

begin_define
define|#
directive|define
name|CTFRAMELEN
value|(4)
end_define

begin_comment
comment|/* Commands are sent in multiples of this size.  */
end_comment

begin_define
define|#
directive|define
name|CTPACKSIZE
value|(512)
end_define

begin_comment
comment|/* A pointer to the buffer we will use.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zTbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we are receiving a file.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fTfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The timeout we use.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cTtimeout
init|=
literal|120
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scmdtab
name|asTproto_params
index|[]
init|=
block|{
block|{
literal|"timeout"
block|,
name|CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cTtimeout
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local function.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|ftprocess_data
name|P
argument_list|(
operator|(
name|boolean
operator|*
name|pfexit
operator|,
name|int
operator|*
name|pcneed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Start the protocol.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|ftstart
parameter_list|(
name|fmaster
parameter_list|)
name|boolean
name|fmaster
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|fport_set
argument_list|(
name|PORTSETTING_EIGHT
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|zTbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|CTBUFSIZE
operator|+
name|CTFRAMELEN
argument_list|)
expr_stmt|;
comment|/* The first two bytes of the buffer are always zero.  */
name|zTbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|zTbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fTfile
operator|=
name|FALSE
expr_stmt|;
name|usysdep_sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stop the protocol.  */
end_comment

begin_function
name|boolean
name|ftshutdown
parameter_list|()
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zTbuf
argument_list|)
expr_stmt|;
name|zTbuf
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a command string.  We send everything up to and including the    null byte.  The number of bytes we send must be a multiple of    TPACKSIZE.  */
end_comment

begin_function
name|boolean
name|ftsendcmd
parameter_list|(
name|z
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
block|{
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|zalc
decl_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"ftsendcmd: Sending command \"%s\""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|z
argument_list|)
expr_stmt|;
comment|/* We need to send the smallest multiple of CTPACKSIZE which is      greater than clen (not equal to clen, since we need room for the      null byte).  */
name|clen
operator|=
operator|(
operator|(
name|clen
operator|/
name|CTPACKSIZE
operator|)
operator|+
literal|1
operator|)
operator|*
name|CTPACKSIZE
expr_stmt|;
name|zalc
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|clen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zalc
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zalc
argument_list|,
name|z
argument_list|)
expr_stmt|;
return|return
name|fsend_data
argument_list|(
name|zalc
argument_list|,
name|clen
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get space to be filled with data.  We provide a buffer which has    four bytes at the start available to hold the length.  */
end_comment

begin_function
name|char
modifier|*
name|ztgetspace
parameter_list|(
name|pclen
parameter_list|)
name|int
modifier|*
name|pclen
decl_stmt|;
block|{
operator|*
name|pclen
operator|=
name|CTBUFSIZE
expr_stmt|;
return|return
name|zTbuf
operator|+
name|CTFRAMELEN
return|;
block|}
end_function

begin_comment
comment|/* Send out some data.  We are allowed to modify the four bytes    preceding the buffer.  This allows us to send the entire block with    header bytes in a single call.  */
end_comment

begin_function
name|boolean
name|ftsenddata
parameter_list|(
name|zdata
parameter_list|,
name|cdata
parameter_list|)
name|char
modifier|*
name|zdata
decl_stmt|;
name|int
name|cdata
decl_stmt|;
block|{
comment|/* Here we do htonl by hand, since it doesn't exist everywhere.  We      know that the amount of data cannot be greater than CTBUFSIZE, so      the first two bytes of this value will always be 0.  They were      set to 0 in ftstart so we don't touch them here.  This is useful      because we cannot portably right shift by 24 or 16, since we      might be dealing with sixteen bit integers.  */
name|zdata
index|[
operator|-
literal|2
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|cdata
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|zdata
index|[
operator|-
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|cdata
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* We pass FALSE to fsend_data since we don't expect the other side      to be sending us anything just now.  */
return|return
name|fsend_data
argument_list|(
name|zdata
operator|-
name|CTFRAMELEN
argument_list|,
name|cdata
operator|+
name|CTFRAMELEN
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process any data in the receive buffer.  */
end_comment

begin_function
name|boolean
name|ftprocess
parameter_list|(
name|pfexit
parameter_list|)
name|boolean
modifier|*
name|pfexit
decl_stmt|;
block|{
return|return
name|ftprocess_data
argument_list|(
name|pfexit
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process data and return the amount we need in *pfneed.  */
end_comment

begin_function
specifier|static
name|boolean
name|ftprocess_data
parameter_list|(
name|pfexit
parameter_list|,
name|pcneed
parameter_list|)
name|boolean
modifier|*
name|pfexit
decl_stmt|;
name|int
modifier|*
name|pcneed
decl_stmt|;
block|{
name|int
name|cinbuf
decl_stmt|,
name|cfirst
decl_stmt|,
name|clen
decl_stmt|;
operator|*
name|pfexit
operator|=
name|FALSE
expr_stmt|;
name|cinbuf
operator|=
name|iPrecend
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cinbuf
operator|<
literal|0
condition|)
name|cinbuf
operator|+=
name|CRECBUFLEN
expr_stmt|;
if|if
condition|(
operator|!
name|fTfile
condition|)
block|{
comment|/* We are not receiving a file.  Commands are read in chunks of 	 CTPACKSIZE.  */
while|while
condition|(
name|cinbuf
operator|>=
name|CTPACKSIZE
condition|)
block|{
name|cfirst
operator|=
name|CRECBUFLEN
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cfirst
operator|>
name|CTPACKSIZE
condition|)
name|cfirst
operator|=
name|CTPACKSIZE
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"ftprocess_data: Got %d command bytes"
argument_list|,
name|cfirst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
name|cfirst
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|cfirst
operator|<
name|CTPACKSIZE
operator|&&
operator|!
operator|*
name|pfexit
condition|)
block|{
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|abPrecbuf
argument_list|,
name|CTPACKSIZE
operator|-
name|cfirst
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|CTPACKSIZE
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
if|if
condition|(
operator|*
name|pfexit
condition|)
return|return
name|TRUE
return|;
name|cinbuf
operator|-=
name|CTPACKSIZE
expr_stmt|;
block|}
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
name|CTPACKSIZE
operator|-
name|cinbuf
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Here we are receiving a file.  The data comes in blocks.  The      first four bytes contain the length, followed by that amount of      data.  */
while|while
condition|(
name|cinbuf
operator|>=
name|CTFRAMELEN
condition|)
block|{
comment|/* The length is stored in network byte order, MSB first.  */
name|clen
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|abPrecbuf
index|[
name|iPrecstart
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|abPrecbuf
index|[
operator|(
name|iPrecstart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
index|]
operator|&
literal|0xff
operator|)
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|abPrecbuf
index|[
operator|(
name|iPrecstart
operator|+
literal|2
operator|)
operator|%
name|CRECBUFLEN
index|]
operator|&
literal|0xff
operator|)
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|abPrecbuf
index|[
operator|(
name|iPrecstart
operator|+
literal|3
operator|)
operator|%
name|CRECBUFLEN
index|]
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|cinbuf
operator|<
name|clen
operator|+
name|CTFRAMELEN
condition|)
block|{
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
name|clen
operator|+
name|CTFRAMELEN
operator|-
name|cinbuf
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|CTFRAMELEN
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
name|cfirst
operator|=
name|CRECBUFLEN
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|cfirst
operator|>
name|clen
condition|)
name|cfirst
operator|=
name|clen
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"ftprocess_data: Got %d data bytes"
argument_list|,
name|cfirst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
name|cfirst
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|cfirst
operator|<
name|clen
condition|)
block|{
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|abPrecbuf
argument_list|,
name|clen
operator|-
name|cfirst
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|clen
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
if|if
condition|(
operator|*
name|pfexit
condition|)
return|return
name|TRUE
return|;
name|cinbuf
operator|-=
name|clen
operator|+
name|CTFRAMELEN
expr_stmt|;
block|}
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
name|CTFRAMELEN
operator|-
name|cinbuf
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for data to come in and process it until we've reached the end    of a command or a file.  */
end_comment

begin_function
name|boolean
name|ftwait
parameter_list|()
block|{
while|while
condition|(
name|TRUE
condition|)
block|{
name|boolean
name|fexit
decl_stmt|;
name|int
name|cneed
decl_stmt|,
name|crec
decl_stmt|;
if|if
condition|(
operator|!
name|ftprocess_data
argument_list|(
operator|&
name|fexit
argument_list|,
operator|&
name|cneed
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fexit
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|freceive_data
argument_list|(
name|cneed
argument_list|,
operator|&
name|crec
argument_list|,
name|cTtimeout
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|crec
operator|==
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timed out waiting for data"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* File level routine, to set fTfile correctly.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|ftfile
parameter_list|(
name|fstart
parameter_list|,
name|fsend
parameter_list|,
name|pfredo
parameter_list|,
name|cbytes
parameter_list|)
name|boolean
name|fstart
decl_stmt|;
name|boolean
name|fsend
decl_stmt|;
name|boolean
modifier|*
name|pfredo
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
block|{
if|if
condition|(
name|pfredo
operator|!=
name|NULL
condition|)
operator|*
name|pfredo
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|fsend
condition|)
name|fTfile
operator|=
name|fstart
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

