begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* log.c    Routines to add entries to the log files.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: log.c,v $    Revision 1.29  1992/04/01  21:58:35  ian    Added CLOSE_LOGFILES configuration parameter     Revision 1.28  1992/03/28  19:40:26  ian    Close log and statistics file at each master/slave role switch     Revision 1.27  1992/03/15  04:51:17  ian    Keep an array of signals we've received rather than a single variable     Revision 1.26  1992/03/12  19:54:43  ian    Debugging based on types rather than number     Revision 1.25  1992/03/08  16:42:41  ian    Ted Lindgreen: report port and login name in log file     Revision 1.24  1992/03/04  00:36:44  ian    Michael Richardson: better chat script debugging     Revision 1.23  1992/02/27  05:40:54  ian    T. William Wells: detach from controlling terminal, handle signals safely     Revision 1.22  1992/02/19  19:36:07  ian    Rearranged time functions     Revision 1.21  1992/02/18  04:33:38  ian    Don't use headers when outputting to terminal     Revision 1.20  1992/02/14  07:51:49  ian    Michael Nolan: don't refer to eLdebug if DEBUG is 0     Revision 1.19  1992/02/08  20:33:57  ian    Handle all possible signals raised by abort     Revision 1.18  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.17  1992/02/01  00:51:28  ian    Michael Nolan: call abort if SIGABRT is not defined     Revision 1.16  1992/01/28  04:51:34  ian    Marty Shannon: don't report failed transfers with BNU logging     Revision 1.15  1992/01/16  18:07:18  ian    Niels Baggesen: add FAILED to end of xferstats line if appropriate     Revision 1.14  1992/01/12  19:32:29  ian    Handle HAVE_BNU_LOGGING with no %s in zLogfile     Revision 1.13  1992/01/05  04:41:48  ian    Tweaked HAVE_V2_LOGGING output slightly     Revision 1.12  1991/12/29  05:00:27  ian    Was not allocating enough space in zldate_and_time     Revision 1.11  1991/12/29  04:04:18  ian    Added a bunch of extern definitions     Revision 1.10  1991/12/29  02:59:50  ian    Lele Gaifax: put full year in log file     Revision 1.9  1991/12/21  23:10:43  ian    Terry Gardner: record failed file transfers in statistics file     Revision 1.8  1991/12/18  03:54:14  ian    Made error messages to terminal appear more normal     Revision 1.7  1991/12/18  03:14:52  ian    Use a fixed number of fields in log messages     Revision 1.6  1991/12/17  07:09:58  ian    Record statistics in fractions of a second     Revision 1.5  1991/12/13  04:02:23  ian    David Nugent: move ERROR: from start of line to after date and time     Revision 1.4  1991/12/11  04:21:37  ian    Arne Ludwig: merge in Arne Ludwig's patches for V2 and BNU style logging     Revision 1.3  1991/11/07  20:32:04  ian    Chip Salzenberg: allow ANSI_C to be defined in conf.h     Revision 1.2  1991/09/19  03:23:34  ian    Chip Salzenberg: append to private debugging file, don't overwrite it     Revision 1.1  1991/09/10  19:40:31  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|log_rcsid
index|[]
init|=
literal|"$Id: log.c,v 1.29 1992/04/01 21:58:35 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|ANSI_C
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_TIME_H
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_TIME_T
end_if

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_T
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_TIME_T */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_TIME_T */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_comment
comment|/* External functions.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fflush
argument_list|()
decl_stmt|,
name|fclose
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_VFPRINTF
end_if

begin_function_decl
specifier|extern
name|int
name|vfprintf
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Static functions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zldate_and_time
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The function to call when a LOG_FATAL error occurs.  */
end_comment

begin_expr_stmt
specifier|static
name|void
argument_list|(
argument|*fLfatal
argument_list|)
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Whether to go to a file.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ID number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iLid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current user name.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zLuser
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current system name.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zLsystem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current device name.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zLdevice
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The open log file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|eLlog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we have tried to open the log file.  We need this because    we don't want to keep trying to open the log file if we failed the    first time.  It can't be static because under HAVE_BNU_LOGGING we    may have to write to various different log files.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLlog_tried
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|DEBUG
operator|>
literal|1
end_if

begin_comment
comment|/* The open debugging file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|eLdebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we've tried to open the debugging file.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLdebug_tried
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we've written out any debugging information.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLdebugging
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The open statistics file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|eLstats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we've tried to open the statistics file.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fLstats_tried
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The array of signals.  The elements are only set to TRUE by the    default signal handler.  They are only set to FALSE if we don't    care whether we got the signal or not.  */
end_comment

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|afSignal
index|[
name|INDEXSIG_COUNT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The array of signals to log.  The elements are only set to TRUE by    the default signal handler.  They are set to FALSE when the signal    is logged in ulog.  This means that if a signal comes in at just    the right time we won't log it (or, rather, we'll log it once    instead of twice), but that is not a catatrophe.  */
end_comment

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|afLog_signal
index|[
name|INDEXSIG_COUNT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Signal names to use when logging signals.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|azSignal_names
index|[
name|INDEXSIG_COUNT
index|]
init|=
name|INDEXSIG_NAMES
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Set the function to call on a LOG_FATAL error.  */
end_comment

begin_function_decl
name|void
name|ulog_fatal_fn
parameter_list|(
name|pfn
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*pfn
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|fLfatal
operator|=
name|pfn
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Decide whether to send log message to the file or not.  */
end_comment

begin_function
name|void
name|ulog_to_file
parameter_list|(
name|ffile
parameter_list|)
name|boolean
name|ffile
decl_stmt|;
block|{
name|fLfile
operator|=
name|ffile
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the ID number.  This will be called by the usysdep_initialize    if there is something sensible to set it to.  */
end_comment

begin_function
name|void
name|ulog_id
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|iLid
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the user we are making log entries for.  The arguments will be    copied into memory.  */
end_comment

begin_function
name|void
name|ulog_user
parameter_list|(
name|zuser
parameter_list|)
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
block|{
if|if
condition|(
name|zuser
operator|==
name|NULL
operator|||
name|zLuser
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|zuser
argument_list|,
name|zLuser
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zLuser
argument_list|)
expr_stmt|;
if|if
condition|(
name|zuser
operator|==
name|NULL
condition|)
name|zLuser
operator|=
name|NULL
expr_stmt|;
else|else
name|zLuser
operator|=
name|xstrdup
argument_list|(
name|zuser
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the system name we are making log entries for.  The name is copied    into memory.  */
end_comment

begin_function
name|void
name|ulog_system
parameter_list|(
name|zsystem
parameter_list|)
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
block|{
if|if
condition|(
name|zsystem
operator|==
name|NULL
operator|||
name|zLsystem
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|zsystem
argument_list|,
name|zLsystem
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zLsystem
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsystem
operator|==
name|NULL
condition|)
name|zLsystem
operator|=
name|NULL
expr_stmt|;
else|else
name|zLsystem
operator|=
name|xstrdup
argument_list|(
name|zsystem
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_BNU_LOGGING
comment|/* Under BNU logging we now must write to a different log file.  */
if|if
condition|(
name|eLlog
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eLlog
argument_list|)
expr_stmt|;
name|eLlog
operator|=
name|NULL
expr_stmt|;
name|fLlog_tried
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_BNU_LOGGING */
block|}
block|}
end_function

begin_comment
comment|/* Set the device name.  This is copied into memory.  */
end_comment

begin_function
name|void
name|ulog_device
parameter_list|(
name|zdevice
parameter_list|)
specifier|const
name|char
modifier|*
name|zdevice
decl_stmt|;
block|{
if|if
condition|(
name|zdevice
operator|==
name|NULL
operator|||
name|zLdevice
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|zdevice
argument_list|,
name|zLdevice
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zLdevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdevice
operator|==
name|NULL
condition|)
name|zLdevice
operator|=
name|NULL
expr_stmt|;
else|else
name|zLdevice
operator|=
name|xstrdup
argument_list|(
name|zdevice
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a log entry.  We make a token concession to non ANSI_C systems,    but it clearly won't always work.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|ANSI_C
end_if

begin_undef
undef|#
directive|undef
name|HAVE_VFPRINTF
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*VARARGS2*/
end_comment

begin_if
if|#
directive|if
name|HAVE_VFPRINTF
end_if

begin_decl_stmt
name|void
name|ulog
argument_list|(
expr|enum
name|tlog
name|ttype
argument_list|,
specifier|const
name|char
operator|*
name|zmsg
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|void
name|ulog
argument_list|(
name|ttype
argument_list|,
name|zmsg
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
decl|enum
name|tlog
name|ttype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zmsg
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|#
directive|if
name|HAVE_VFPRINTF
name|va_list
name|parg
decl_stmt|;
endif|#
directive|endif
name|FILE
modifier|*
name|e
decl_stmt|,
modifier|*
name|edebug
decl_stmt|;
name|boolean
name|fstart
decl_stmt|,
name|fend
decl_stmt|;
specifier|const
name|char
modifier|*
name|zhdr
decl_stmt|,
modifier|*
name|zstr
decl_stmt|;
comment|/* Log any received signal.  We do it this way to avoid calling ulog      from the signal handler.  A few routines call ulog to get this      message out with zmsg == NULL.  */
block|{
specifier|static
name|boolean
name|fdoing_sigs
decl_stmt|;
if|if
condition|(
operator|!
name|fdoing_sigs
condition|)
block|{
name|int
name|isig
decl_stmt|;
name|fdoing_sigs
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|isig
operator|=
literal|0
init|;
name|isig
operator|<
name|INDEXSIG_COUNT
condition|;
name|isig
operator|++
control|)
block|{
if|if
condition|(
name|afLog_signal
index|[
name|isig
index|]
condition|)
block|{
name|afLog_signal
index|[
name|isig
index|]
operator|=
name|FALSE
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Got %s signal"
argument_list|,
name|azSignal_names
index|[
name|isig
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fdoing_sigs
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zmsg
operator|==
name|NULL
condition|)
return|return;
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* If we've had a debugging file open in the past, then we want to      write all log file entries to the debugging file even if it's      currently closed.  */
if|if
condition|(
name|fLfile
operator|&&
name|eLdebug
operator|==
name|NULL
operator|&&
operator|!
name|fLdebug_tried
operator|&&
operator|(
name|fLdebugging
operator|||
operator|(
name|int
operator|)
name|ttype
operator|>=
operator|(
name|int
operator|)
name|LOG_DEBUG
operator|)
condition|)
block|{
name|fLdebug_tried
operator|=
name|TRUE
expr_stmt|;
name|eLdebug
operator|=
name|esysdep_fopen
argument_list|(
name|zDebugfile
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|fLdebugging
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG> 1 */
if|if
condition|(
operator|!
name|fLfile
condition|)
name|e
operator|=
name|stderr
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|ttype
operator|>=
operator|(
name|int
operator|)
name|LOG_DEBUG
condition|)
block|{
name|e
operator|=
name|eLdebug
expr_stmt|;
comment|/* If we can't open the debugging file, don't output any 	 debugging messages.  */
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* DEBUG> 1 */
else|else
block|{
if|if
condition|(
name|eLlog
operator|==
name|NULL
operator|&&
operator|!
name|fLlog_tried
condition|)
block|{
name|fLlog_tried
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_BNU_LOGGING
name|eLlog
operator|=
name|esysdep_fopen
argument_list|(
name|zLogfile
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_BNU_LOGGING */
block|{
specifier|const
name|char
modifier|*
name|zsys
decl_stmt|;
name|char
modifier|*
name|zfile
decl_stmt|;
comment|/* We want to write to .Log/program/system, e.g.  	 	       .Log/uucico/uunet.  The system name may not be set.  */
if|if
condition|(
name|zLsystem
operator|==
name|NULL
condition|)
name|zsys
operator|=
literal|"ANY"
expr_stmt|;
else|else
name|zsys
operator|=
name|zLsystem
expr_stmt|;
name|zfile
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zLogfile
argument_list|)
operator|+
name|strlen
argument_list|(
name|abProgram
argument_list|)
operator|+
name|strlen
argument_list|(
name|zsys
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zfile
argument_list|,
name|zLogfile
argument_list|,
name|abProgram
argument_list|,
name|zsys
argument_list|)
expr_stmt|;
name|eLlog
operator|=
name|esysdep_fopen
argument_list|(
name|zfile
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_BNU_LOGGING */
if|if
condition|(
name|eLlog
operator|==
name|NULL
condition|)
block|{
comment|/* We can't open the log file.  We don't even have a 		 safe way to report this problem, since we may not be 		 able to write to stderr (it may, for example, be 		 attached to the incoming call).  */
if|if
condition|(
name|fLfatal
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|fLfatal
call|)
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|e
operator|=
name|eLlog
expr_stmt|;
comment|/* eLlog might be NULL here because we might try to open the log 	 file recursively via esysdep_fopen.  */
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return;
block|}
name|edebug
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
operator|(
name|int
operator|)
name|ttype
operator|<
operator|(
name|int
operator|)
name|LOG_DEBUG
condition|)
name|edebug
operator|=
name|eLdebug
expr_stmt|;
endif|#
directive|endif
name|fstart
operator|=
name|TRUE
expr_stmt|;
name|fend
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|ttype
condition|)
block|{
case|case
name|LOG_NORMAL
case|:
name|zhdr
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|LOG_ERROR
case|:
name|zhdr
operator|=
literal|"ERROR: "
expr_stmt|;
break|break;
case|case
name|LOG_FATAL
case|:
name|zhdr
operator|=
literal|"FATAL: "
expr_stmt|;
break|break;
if|#
directive|if
name|DEBUG
operator|>
literal|1
case|case
name|LOG_DEBUG
case|:
name|zhdr
operator|=
literal|"DEBUG: "
expr_stmt|;
break|break;
case|case
name|LOG_DEBUG_START
case|:
name|zhdr
operator|=
literal|"DEBUG: "
expr_stmt|;
name|fend
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LOG_DEBUG_CONTINUE
case|:
name|zhdr
operator|=
name|NULL
expr_stmt|;
name|fstart
operator|=
name|FALSE
expr_stmt|;
name|fend
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LOG_DEBUG_END
case|:
name|zhdr
operator|=
name|NULL
expr_stmt|;
name|fstart
operator|=
name|FALSE
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|zhdr
operator|=
literal|"???: "
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fstart
condition|)
block|{
if|if
condition|(
operator|!
name|fLfile
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s: "
argument_list|,
name|abProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"%s: "
argument_list|,
name|abProgram
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s "
argument_list|,
name|abProgram
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"%s "
argument_list|,
name|abProgram
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_TAYLOR_LOGGING */
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s "
argument_list|,
name|zLuser
operator|==
name|NULL
condition|?
literal|"uucp"
else|:
name|zLuser
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"%s "
argument_list|,
name|zLuser
operator|==
name|NULL
condition|?
literal|"uucp"
else|:
name|zLuser
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_LOGGING */
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s "
argument_list|,
name|zLsystem
operator|==
name|NULL
condition|?
literal|"-"
else|:
name|zLsystem
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"%s "
argument_list|,
name|zLsystem
operator|==
name|NULL
condition|?
literal|"-"
else|:
name|zLsystem
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s "
argument_list|,
name|zLuser
operator|==
name|NULL
condition|?
literal|"-"
else|:
name|zLuser
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"%s "
argument_list|,
name|zLuser
operator|==
name|NULL
condition|?
literal|"-"
else|:
name|zLuser
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_LOGGING */
name|zstr
operator|=
name|zldate_and_time
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"(%s"
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"(%s"
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|iLid
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
operator|!
name|HAVE_BNU_LOGGING
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" %d"
argument_list|,
name|iLid
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|" %d"
argument_list|,
name|iLid
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_TAYLOR_LOGGING */
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"-%d"
argument_list|,
name|iLid
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"-%d"
argument_list|,
name|iLid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_TAYLOR_LOGGING */
else|#
directive|else
comment|/* HAVE_BNU_LOGGING */
comment|/* I assume that the second number here is meant to be 		 some sort of file sequence number, and that it should 		 correspond to the sequence number in the statistics 		 file.  I don't have any really convenient way to do 		 this, so I won't unless somebody thinks it's very 		 important.  */
name|fprintf
argument_list|(
name|e
argument_list|,
literal|",%d,%d"
argument_list|,
name|iLid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|",%d,%d"
argument_list|,
name|iLid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_BNU_LOGGING */
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s"
argument_list|,
name|zhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"%s"
argument_list|,
name|zhdr
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|HAVE_VFPRINTF
name|va_start
argument_list|(
name|parg
argument_list|,
name|zmsg
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|e
argument_list|,
name|zmsg
argument_list|,
name|parg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|parg
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
block|{
name|va_start
argument_list|(
name|parg
argument_list|,
name|zmsg
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|edebug
argument_list|,
name|zmsg
argument_list|,
name|parg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|parg
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! HAVE_VFPRINTF */
name|fprintf
argument_list|(
name|e
argument_list|,
name|zmsg
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
name|zmsg
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_VFPRINTF */
if|if
condition|(
name|fend
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|edebug
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|edebug
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|edebug
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttype
operator|==
name|LOG_FATAL
condition|)
block|{
if|if
condition|(
name|fLfatal
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|fLfatal
call|)
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|CLOSE_LOGFILES
name|ulog_close
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Close the log file.  There's nothing useful we can do with errors,    so we don't check for them.  */
end_comment

begin_function
name|void
name|ulog_close
parameter_list|()
block|{
comment|/* Make sure we logged any signal we received.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|eLlog
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eLlog
argument_list|)
expr_stmt|;
name|eLlog
operator|=
name|NULL
expr_stmt|;
name|fLlog_tried
operator|=
name|FALSE
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|eLdebug
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eLdebug
argument_list|)
expr_stmt|;
name|eLdebug
operator|=
name|NULL
expr_stmt|;
name|fLdebug_tried
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an entry to the statistics file.  We may eventually want to put    failed file transfers in here, but we currently do not.  */
end_comment

begin_function
name|void
name|ustats
parameter_list|(
name|fsucceeded
parameter_list|,
name|zuser
parameter_list|,
name|zsystem
parameter_list|,
name|fsent
parameter_list|,
name|cbytes
parameter_list|,
name|csecs
parameter_list|,
name|cmicros
parameter_list|)
name|boolean
name|fsucceeded
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
name|boolean
name|fsent
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
name|long
name|csecs
decl_stmt|;
name|long
name|cmicros
decl_stmt|;
block|{
name|long
name|cbps
decl_stmt|;
comment|/* On a system which can determine microseconds we might very well      have both csecs == 0 and cmicros == 0.  */
if|if
condition|(
name|csecs
operator|==
literal|0
operator|&&
name|cmicros
operator|==
literal|0
condition|)
name|cbps
operator|=
literal|0
expr_stmt|;
else|else
name|cbps
operator|=
operator|(
literal|1000
operator|*
name|cbytes
operator|)
operator|/
operator|(
name|csecs
operator|*
literal|1000
operator|+
name|cmicros
operator|/
literal|1000
operator|)
expr_stmt|;
if|if
condition|(
name|eLstats
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fLstats_tried
condition|)
return|return;
name|fLstats_tried
operator|=
name|TRUE
expr_stmt|;
name|eLstats
operator|=
name|esysdep_fopen
argument_list|(
name|zStatfile
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eLstats
operator|==
name|NULL
condition|)
return|return;
block|}
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|fprintf
argument_list|(
name|eLstats
argument_list|,
literal|"%s %s (%s) %s%s %ld bytes in %ld.%03ld seconds (%ld bytes/sec)\n"
argument_list|,
name|zuser
argument_list|,
name|zsystem
argument_list|,
name|zldate_and_time
argument_list|()
argument_list|,
name|fsucceeded
condition|?
literal|""
else|:
literal|"failed after "
argument_list|,
name|fsent
condition|?
literal|"sent"
else|:
literal|"received"
argument_list|,
name|cbytes
argument_list|,
name|csecs
argument_list|,
name|cmicros
operator|/
literal|1000
argument_list|,
name|cbps
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_LOGGING */
if|#
directive|if
name|HAVE_V2_LOGGING
name|fprintf
argument_list|(
name|eLstats
argument_list|,
literal|"%s %s (%s) (%ld) %s %s %ld bytes %ld seconds\n"
argument_list|,
name|zuser
argument_list|,
name|zsystem
argument_list|,
name|zldate_and_time
argument_list|()
argument_list|,
operator|(
name|long
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fsent
condition|?
literal|"sent"
else|:
literal|"received"
argument_list|,
name|fsucceeded
condition|?
literal|"data"
else|:
literal|"failed after"
argument_list|,
name|cbytes
argument_list|,
name|csecs
operator|+
name|cmicros
operator|/
literal|500000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_V2_LOGGING */
if|#
directive|if
name|HAVE_BNU_LOGGING
block|{
specifier|static
name|int
name|iseq
decl_stmt|;
comment|/* I don't know what the 'M' or the 'C' mean.  This format expects        us to get the time in fractions of a second; on Unix we could        use times to do this, and we probably should.  The sequence        number should probably correspond to the sequence number in the        log file, but that is currently always 0; using this fake        sequence number will still at least reveal which transfers are        from different calls.  We don't report a failed data transfer        with this format.  */
if|if
condition|(
operator|!
name|fsucceeded
condition|)
return|return;
operator|++
name|iseq
expr_stmt|;
name|fprintf
argument_list|(
name|eLstats
argument_list|,
literal|"%s!%s M (%s) (C,%d,%d) [%s] %s %ld / %ld.%03ld secs, %ld %s\n"
argument_list|,
name|zsystem
argument_list|,
name|zuser
argument_list|,
name|zldate_and_time
argument_list|()
argument_list|,
name|iLid
argument_list|,
name|iseq
argument_list|,
name|zLdevice
operator|==
name|NULL
condition|?
literal|"unknown"
else|:
name|zLdevice
argument_list|,
name|fsent
condition|?
literal|"->"
else|:
literal|"<-"
argument_list|,
name|cbytes
argument_list|,
name|csecs
argument_list|,
name|cmicros
operator|/
literal|1000
argument_list|,
name|cbps
argument_list|,
literal|"bytes/sec"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_BNU_LOGGING */
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|eLstats
argument_list|)
expr_stmt|;
if|#
directive|if
name|CLOSE_LOGFILES
name|ustats_close
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Close the statistics file.  */
end_comment

begin_function
name|void
name|ustats_close
parameter_list|()
block|{
if|if
condition|(
name|eLstats
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|eLstats
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|eLstats
operator|=
name|NULL
expr_stmt|;
name|fLstats_tried
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the date and time in a form used for a log entry.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|zldate_and_time
parameter_list|()
block|{
name|long
name|isecs
decl_stmt|,
name|imicros
decl_stmt|;
name|struct
name|tm
name|s
decl_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
specifier|static
name|char
name|ab
index|[
sizeof|sizeof
expr|"1991-12-31 12:00:00.00"]
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_V2_LOGGING
specifier|static
name|char
name|ab
index|[
sizeof|sizeof
expr|"12/31-12:00"]
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_BNU_LOGGING
specifier|static
name|char
name|ab
index|[
sizeof|sizeof
expr|"12/31-12:00:00"]
expr_stmt|;
endif|#
directive|endif
name|isecs
operator|=
name|isysdep_time
argument_list|(
operator|&
name|imicros
argument_list|)
expr_stmt|;
name|usysdep_localtime
argument_list|(
name|isecs
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_LOGGING
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%04d-%02d-%02d %02d:%02d:%02d.%02d"
argument_list|,
name|s
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|s
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|s
operator|.
name|tm_mday
argument_list|,
name|s
operator|.
name|tm_hour
argument_list|,
name|s
operator|.
name|tm_min
argument_list|,
name|s
operator|.
name|tm_sec
argument_list|,
call|(
name|int
call|)
argument_list|(
name|imicros
operator|/
literal|10000
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_V2_LOGGING
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%d/%d-%02d:%02d"
argument_list|,
name|s
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|s
operator|.
name|tm_mday
argument_list|,
name|s
operator|.
name|tm_hour
argument_list|,
name|s
operator|.
name|tm_min
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_BNU_LOGGING
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%d/%d-%02d:%02d:%02d"
argument_list|,
name|s
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|s
operator|.
name|tm_mday
argument_list|,
name|s
operator|.
name|tm_hour
argument_list|,
name|s
operator|.
name|tm_min
argument_list|,
name|s
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ab
return|;
block|}
end_function

end_unit

