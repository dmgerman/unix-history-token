begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* uucp.c    Prepare to copy a file to or from a remote system.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: uucp.c,v $    Revision 1.25  1992/03/15  04:51:17  ian    Keep an array of signals we've received rather than a single variable     Revision 1.24  1992/03/12  21:55:09  ian    Use fake local name when generating an execution request     Revision 1.23  1992/03/12  19:54:43  ian    Debugging based on types rather than number     Revision 1.22  1992/02/29  04:07:08  ian    Added -j option to uucp and uux     Revision 1.21  1992/02/29  01:06:59  ian    Chip Salzenberg: recheck file permissions before sending     Revision 1.20  1992/02/27  05:40:54  ian    T. William Wells: detach from controlling terminal, handle signals safely     Revision 1.19  1992/02/24  04:58:47  ian    Only permit files to be received into directories that are world-writeable     Revision 1.18  1992/02/23  03:26:51  ian    Overhaul to use automatic configure shell script     Revision 1.17  1992/02/14  05:17:09  ian    Niels Baggesen: have to copy abtname into memory     Revision 1.16  1992/02/08  22:33:32  ian    Only get the current working directory if it's going to be needed     Revision 1.15  1992/02/08  20:33:57  ian    Handle all possible signals raised by abort     Revision 1.14  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.13  1992/02/02  20:56:25  ian    Do local copy to zsysdep_real_file_name, not zsysdep_in_dir     Revision 1.12  1992/02/02  20:34:36  ian    Niels Baggesen: must check user permissions on access to local files     Revision 1.11  1992/01/21  19:39:12  ian    Chip Salzenberg: uucp and uux start uucico for right system, not any     Revision 1.10  1992/01/15  07:06:29  ian    Set configuration directory in Makefile rather than sysdep.h     Revision 1.9  1992/01/05  03:09:17  ian    Changed abProgram and abVersion to non const to avoid compiler bug     Revision 1.8  1991/12/21  21:09:01  ian    Use ulog to report illegal grade error message     Revision 1.7  1991/12/18  03:54:14  ian    Made error messages to terminal appear more normal     Revision 1.6  1991/12/11  03:59:19  ian    Create directories when necessary; don't just assume they exist     Revision 1.5  1991/11/21  22:17:06  ian    Add version string, print version when printing usage     Revision 1.4  1991/11/13  23:08:40  ian    Expand remote pathnames in uucp and uux; fix up uux special cases     Revision 1.3  1991/09/19  02:30:37  ian    From Chip Salzenberg: check whether signal is ignored differently     Revision 1.2  1991/09/11  02:33:14  ian    Added ffork argument to fsysdep_run     Revision 1.1  1991/09/10  19:40:31  ian    Initial revision       */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|uucp_rcsid
index|[]
init|=
literal|"$Id: uucp.c,v 1.25 1992/03/15 04:51:17 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The program name.  */
end_comment

begin_decl_stmt
name|char
name|abProgram
index|[]
init|=
literal|"uucp"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Long getopt options.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|asClongopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|option
modifier|*
name|_getopt_long_options
init|=
name|asClongopts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ucusage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ucadd_cmd
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
specifier|const
expr|struct
name|scmd
operator|*
name|qcmd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ucspool_cmds
name|P
argument_list|(
operator|(
name|int
name|bgrade
operator|,
name|boolean
name|fjobid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zcone_system
name|P
argument_list|(
operator|(
name|boolean
operator|*
name|pfany
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ucrecord_file
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ucabort
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|iopt
decl_stmt|;
comment|/* -c,-C: if true, copy to spool directory.  */
name|boolean
name|fcopy
init|=
name|TRUE
decl_stmt|;
comment|/* -d,-f: if true, create directories if they don't exist.  */
name|boolean
name|fmkdirs
init|=
name|TRUE
decl_stmt|;
comment|/* -g: job grade.  */
name|char
name|bgrade
init|=
name|BDEFAULT_UUCP_GRADE
decl_stmt|;
comment|/* -I: configuration file name.  */
specifier|const
name|char
modifier|*
name|zconfig
init|=
name|NULL
decl_stmt|;
comment|/* -j: output job id.  */
name|boolean
name|fjobid
init|=
name|FALSE
decl_stmt|;
comment|/* -m: mail to requesting user.  */
name|boolean
name|fmail
init|=
name|FALSE
decl_stmt|;
comment|/* -n: notify remote user.  */
specifier|const
name|char
modifier|*
name|znotify
init|=
literal|""
decl_stmt|;
comment|/* -r: don't start uucico when finished.  */
name|boolean
name|fuucico
init|=
name|TRUE
decl_stmt|;
comment|/* -s: report status to named file.  */
specifier|const
name|char
modifier|*
name|zstatus_file
init|=
name|NULL
decl_stmt|;
comment|/* -W: expand local file names only.  */
name|boolean
name|fexpand
init|=
name|TRUE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|boolean
name|fgetcwd
decl_stmt|;
name|char
modifier|*
name|zexclam
decl_stmt|;
name|char
modifier|*
name|zdestfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|zconst
decl_stmt|;
name|struct
name|ssysteminfo
name|sdestsys
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qdestsys
decl_stmt|;
name|boolean
name|flocaldest
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
name|char
name|absend_options
index|[
literal|5
index|]
decl_stmt|;
name|char
name|abrec_options
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|zoptions
decl_stmt|;
name|boolean
name|fexit
decl_stmt|;
while|while
condition|(
operator|(
name|iopt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cCdfg:I:jmn:rs:Wx:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|iopt
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* Do not copy local files to spool directory.  */
name|fcopy
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Copy local files to spool directory.  */
name|fcopy
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Create directories if necessary.  */
name|fmkdirs
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Do not create directories if they don't exist.  */
name|fmkdirs
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Set job grade.  */
name|bgrade
operator|=
name|optarg
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Name configuration file.  */
name|zconfig
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
comment|/* Output job id.  */
name|fjobid
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Mail to requesting user.  */
name|fmail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Notify remote user.  */
name|znotify
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Don't start uucico when finished.  */
name|fuucico
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Report status to named file.  */
name|zstatus_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/* Expand only local file names.  */
name|fexpand
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* Set debugging level.  */
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|0
case|:
comment|/* Long option found and flag set.  */
break|break;
default|default:
name|ucusage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|FGRADE_LEGAL
argument_list|(
name|bgrade
argument_list|)
condition|)
block|{
comment|/* We use LOG_NORMAL rather than LOG_ERROR because this is going 	 to stderr rather than to the log file, and we don't need the 	 ERROR header string.  */
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Ignoring illegal grade"
argument_list|)
expr_stmt|;
name|bgrade
operator|=
name|BDEFAULT_UUCP_GRADE
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|-
name|optind
operator|<
literal|2
condition|)
name|ucusage
argument_list|()
expr_stmt|;
name|uread_config
argument_list|(
name|zconfig
argument_list|)
expr_stmt|;
comment|/* See if we are going to need to know the current directory.  We      just check each argument to see whether it's an absolute      pathname.  We actually aren't going to need the cwd if fexpand is      FALSE and the file is remote, but so what.  */
name|fgetcwd
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|zexclam
operator|=
name|strrchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zexclam
operator|==
name|NULL
condition|)
name|zexclam
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
else|else
operator|++
name|zexclam
expr_stmt|;
if|if
condition|(
name|fsysdep_needs_cwd
argument_list|(
name|zexclam
argument_list|)
condition|)
block|{
name|fgetcwd
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|SIGINT
name|usysdep_signal
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|usysdep_signal
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|usysdep_signal
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|usysdep_signal
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|usysdep_signal
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usysdep_initialize
argument_list|(
name|FALSE
argument_list|,
name|fgetcwd
argument_list|)
expr_stmt|;
name|ulog_fatal_fn
argument_list|(
name|ucabort
argument_list|)
expr_stmt|;
name|zuser
operator|=
name|zsysdep_login_name
argument_list|()
expr_stmt|;
comment|/* Set up the options.  */
name|zoptions
operator|=
name|absend_options
expr_stmt|;
if|if
condition|(
name|fcopy
condition|)
operator|*
name|zoptions
operator|++
operator|=
literal|'C'
expr_stmt|;
else|else
operator|*
name|zoptions
operator|++
operator|=
literal|'c'
expr_stmt|;
if|if
condition|(
name|fmkdirs
condition|)
operator|*
name|zoptions
operator|++
operator|=
literal|'d'
expr_stmt|;
else|else
operator|*
name|zoptions
operator|++
operator|=
literal|'f'
expr_stmt|;
if|if
condition|(
name|fmail
condition|)
operator|*
name|zoptions
operator|++
operator|=
literal|'m'
expr_stmt|;
if|if
condition|(
operator|*
name|znotify
operator|!=
literal|'\0'
condition|)
operator|*
name|zoptions
operator|++
operator|=
literal|'n'
expr_stmt|;
operator|*
name|zoptions
operator|=
literal|'\0'
expr_stmt|;
name|zoptions
operator|=
name|abrec_options
expr_stmt|;
if|if
condition|(
name|fmkdirs
condition|)
operator|*
name|zoptions
operator|++
operator|=
literal|'d'
expr_stmt|;
else|else
operator|*
name|zoptions
operator|++
operator|=
literal|'f'
expr_stmt|;
if|if
condition|(
name|fmail
condition|)
operator|*
name|zoptions
operator|++
operator|=
literal|'m'
expr_stmt|;
operator|*
name|zoptions
operator|=
literal|'\0'
expr_stmt|;
name|zexclam
operator|=
name|strchr
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zexclam
operator|==
name|NULL
condition|)
block|{
name|zdestfile
operator|=
name|argv
index|[
name|argc
operator|-
literal|1
index|]
expr_stmt|;
name|qdestsys
operator|=
operator|&
name|sLocalsys
expr_stmt|;
name|flocaldest
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|;
name|clen
operator|=
name|zexclam
operator|-
name|argv
index|[
name|argc
operator|-
literal|1
index|]
expr_stmt|;
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|zcopy
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|zcopy
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zdestfile
operator|=
name|zexclam
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|zcopy
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|zcopy
argument_list|,
name|zLocalname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|qdestsys
operator|=
operator|&
name|sLocalsys
expr_stmt|;
name|flocaldest
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fread_system_info
argument_list|(
name|zcopy
argument_list|,
operator|&
name|sdestsys
argument_list|)
condition|)
name|qdestsys
operator|=
operator|&
name|sdestsys
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|fUnknown_ok
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"System %s unknown"
argument_list|,
name|zcopy
argument_list|)
expr_stmt|;
name|qdestsys
operator|=
operator|&
name|sUnknown
expr_stmt|;
name|sUnknown
operator|.
name|zname
operator|=
name|zcopy
expr_stmt|;
block|}
name|flocaldest
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_make_spool_dir
argument_list|(
name|qdestsys
argument_list|)
condition|)
block|{
name|ulog_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If the destination file is not an absolute path, expand it      with the current directory.  */
if|if
condition|(
name|fexpand
operator|||
name|flocaldest
condition|)
block|{
name|zconst
operator|=
name|zsysdep_add_cwd
argument_list|(
name|zdestfile
argument_list|,
name|flocaldest
argument_list|)
expr_stmt|;
if|if
condition|(
name|zconst
operator|==
name|NULL
condition|)
block|{
name|ulog_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|zdestfile
operator|=
name|xstrdup
argument_list|(
name|zconst
argument_list|)
expr_stmt|;
block|}
comment|/* Check that we have permission to receive into the desired      directory.  If we don't have permission, uucico will fail.  */
if|if
condition|(
name|flocaldest
condition|)
block|{
if|if
condition|(
operator|!
name|fin_directory_list
argument_list|(
operator|&
name|sLocalsys
argument_list|,
name|zdestfile
argument_list|,
name|sLocalsys
operator|.
name|zlocal_receive
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|zuser
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Not permitted to receive to %s"
argument_list|,
name|zdestfile
argument_list|)
expr_stmt|;
block|}
comment|/* Process each file.  */
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
operator|-
literal|1
operator|&&
operator|!
name|FGOT_SIGNAL
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|scmd
name|s
decl_stmt|;
name|zexclam
operator|=
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zexclam
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|zfrom
decl_stmt|;
comment|/* This is a local file.  Make sure we get it out of the 	     original directory.  We don't support local wildcards 	     yet (if ever).  */
name|zconst
operator|=
name|zsysdep_add_cwd
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zconst
operator|==
name|NULL
condition|)
name|ucabort
argument_list|()
expr_stmt|;
name|zfrom
operator|=
name|xstrdup
argument_list|(
name|zconst
argument_list|)
expr_stmt|;
comment|/* Make sure the user has access to this file, since we are 	     running setuid.  */
if|if
condition|(
operator|!
name|fsysdep_access
argument_list|(
name|zfrom
argument_list|)
condition|)
name|ucabort
argument_list|()
expr_stmt|;
if|if
condition|(
name|flocaldest
condition|)
block|{
name|char
modifier|*
name|zto
decl_stmt|;
comment|/* Copy one local file to another.  */
name|zconst
operator|=
name|zsysdep_real_file_name
argument_list|(
operator|&
name|sLocalsys
argument_list|,
name|zdestfile
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zconst
operator|==
name|NULL
condition|)
name|ucabort
argument_list|()
expr_stmt|;
name|zto
operator|=
name|xstrdup
argument_list|(
name|zconst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fcopy_file
argument_list|(
name|zfrom
argument_list|,
name|zto
argument_list|,
name|FALSE
argument_list|,
name|fmkdirs
argument_list|)
condition|)
name|ucabort
argument_list|()
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|abtname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|unsigned
name|int
name|imode
decl_stmt|;
comment|/* Copy a local file to a remote file.  We may have to 		 copy the local file to the spool directory.  */
name|imode
operator|=
name|isysdep_file_mode
argument_list|(
name|zfrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|==
literal|0
condition|)
name|ucabort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fcopy
condition|)
block|{
comment|/* Make sure the daemon will be permitted to send 		     this file.  */
if|if
condition|(
operator|!
name|fsysdep_daemon_access
argument_list|(
name|zfrom
argument_list|)
condition|)
name|ucabort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fin_directory_list
argument_list|(
operator|&
name|sLocalsys
argument_list|,
name|zfrom
argument_list|,
name|sLocalsys
operator|.
name|zlocal_send
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|zuser
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Not permitted to send from %s"
argument_list|,
name|zfrom
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|abtname
argument_list|,
literal|"D.0"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|zdata
decl_stmt|;
name|zconst
operator|=
name|zsysdep_data_file_name
argument_list|(
name|qdestsys
argument_list|,
name|bgrade
argument_list|,
name|abtname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zconst
operator|==
name|NULL
condition|)
name|ucabort
argument_list|()
expr_stmt|;
name|zdata
operator|=
name|xstrdup
argument_list|(
name|zconst
argument_list|)
expr_stmt|;
name|ucrecord_file
argument_list|(
name|zdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fcopy_file
argument_list|(
name|zfrom
argument_list|,
name|zdata
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
condition|)
name|ucabort
argument_list|()
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zdata
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|bcmd
operator|=
literal|'S'
expr_stmt|;
name|s
operator|.
name|pseq
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|zfrom
operator|=
name|zfrom
expr_stmt|;
name|s
operator|.
name|zto
operator|=
name|zdestfile
expr_stmt|;
name|s
operator|.
name|zuser
operator|=
name|zuser
expr_stmt|;
name|s
operator|.
name|zoptions
operator|=
name|absend_options
expr_stmt|;
name|s
operator|.
name|ztemp
operator|=
name|xstrdup
argument_list|(
name|abtname
argument_list|)
expr_stmt|;
name|s
operator|.
name|imode
operator|=
name|imode
expr_stmt|;
name|s
operator|.
name|znotify
operator|=
name|znotify
expr_stmt|;
name|s
operator|.
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
name|ucadd_cmd
argument_list|(
name|qdestsys
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|qfromsys
decl_stmt|;
comment|/* Add the current directory to the filename if it's not 	     already there.  */
if|if
condition|(
name|fexpand
condition|)
block|{
name|zconst
operator|=
name|zsysdep_add_cwd
argument_list|(
name|zexclam
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zconst
operator|==
name|NULL
condition|)
name|ucabort
argument_list|()
expr_stmt|;
name|zconst
operator|=
name|xstrdup
argument_list|(
name|zconst
argument_list|)
expr_stmt|;
block|}
else|else
name|zconst
operator|=
name|zexclam
operator|+
literal|1
expr_stmt|;
comment|/* Read the system information.  */
name|clen
operator|=
name|zexclam
operator|-
name|argv
index|[
name|i
index|]
expr_stmt|;
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|zcopy
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|zcopy
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qfromsys
operator|=
operator|(
operator|(
expr|struct
name|ssysteminfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|fread_system_info
argument_list|(
name|zcopy
argument_list|,
name|qfromsys
argument_list|)
condition|)
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zcopy
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|qfromsys
operator|=
name|sUnknown
expr_stmt|;
name|qfromsys
operator|->
name|zname
operator|=
name|zcopy
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fsysdep_make_spool_dir
argument_list|(
name|qfromsys
argument_list|)
condition|)
name|ucabort
argument_list|()
expr_stmt|;
if|if
condition|(
name|flocaldest
condition|)
block|{
name|char
modifier|*
name|zto
decl_stmt|;
comment|/* Fetch a file from a remote system.  If the remote 		 filespec is wildcarded, we must generate an 'X' 		 request.  We currently check for Unix shell 		 wildcards.  Note that it should do no harm to mistake 		 a non-wildcard for a wildcard.  */
if|if
condition|(
name|strchr
argument_list|(
name|zconst
argument_list|,
literal|'*'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|zconst
argument_list|,
literal|'?'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|zconst
argument_list|,
literal|'['
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|zuse
decl_stmt|;
if|if
condition|(
name|qfromsys
operator|->
name|zlocalname
operator|!=
name|NULL
condition|)
name|zuse
operator|=
name|qfromsys
operator|->
name|zlocalname
expr_stmt|;
else|else
name|zuse
operator|=
name|zLocalname
expr_stmt|;
name|s
operator|.
name|bcmd
operator|=
literal|'X'
expr_stmt|;
name|zto
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zuse
argument_list|)
operator|+
name|strlen
argument_list|(
name|zdestfile
argument_list|)
operator|+
sizeof|sizeof
expr|"!"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zto
argument_list|,
literal|"%s!%s"
argument_list|,
name|zuse
argument_list|,
name|zdestfile
argument_list|)
expr_stmt|;
name|zto
operator|=
name|xstrdup
argument_list|(
name|zto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|.
name|bcmd
operator|=
literal|'R'
expr_stmt|;
name|zto
operator|=
name|zdestfile
expr_stmt|;
block|}
name|s
operator|.
name|pseq
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|zfrom
operator|=
name|zconst
expr_stmt|;
name|s
operator|.
name|zto
operator|=
name|zto
expr_stmt|;
name|s
operator|.
name|zuser
operator|=
name|zuser
expr_stmt|;
name|s
operator|.
name|zoptions
operator|=
name|abrec_options
expr_stmt|;
name|s
operator|.
name|ztemp
operator|=
literal|""
expr_stmt|;
name|s
operator|.
name|imode
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|znotify
operator|=
literal|""
expr_stmt|;
name|s
operator|.
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
name|ucadd_cmd
argument_list|(
name|qfromsys
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Move a file from one remote system to another.  */
name|s
operator|.
name|bcmd
operator|=
literal|'X'
expr_stmt|;
name|s
operator|.
name|pseq
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|zfrom
operator|=
name|zconst
expr_stmt|;
name|s
operator|.
name|zto
operator|=
name|argv
index|[
name|argc
operator|-
literal|1
index|]
expr_stmt|;
name|s
operator|.
name|zuser
operator|=
name|zuser
expr_stmt|;
name|s
operator|.
name|zoptions
operator|=
name|abrec_options
expr_stmt|;
name|s
operator|.
name|ztemp
operator|=
literal|""
expr_stmt|;
name|s
operator|.
name|imode
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|znotify
operator|=
literal|""
expr_stmt|;
name|s
operator|.
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
name|ucadd_cmd
argument_list|(
name|qfromsys
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* See if we got an interrupt, presumably from the user.  */
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
name|ucabort
argument_list|()
expr_stmt|;
comment|/* Now push out the actual commands, making log entries for them.  */
name|ulog_to_file
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ulog_user
argument_list|(
name|zuser
argument_list|)
expr_stmt|;
name|ucspool_cmds
argument_list|(
name|bgrade
argument_list|,
name|fjobid
argument_list|)
expr_stmt|;
name|ulog_close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fuucico
condition|)
name|fexit
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|zsys
decl_stmt|;
name|boolean
name|fany
decl_stmt|;
name|zsys
operator|=
name|zcone_system
argument_list|(
operator|&
name|fany
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsys
operator|!=
name|NULL
condition|)
name|fexit
operator|=
name|fsysdep_run
argument_list|(
name|TRUE
argument_list|,
literal|"uucico"
argument_list|,
literal|"-s"
argument_list|,
name|zsys
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fany
condition|)
name|fexit
operator|=
name|fsysdep_run
argument_list|(
name|TRUE
argument_list|,
literal|"uucico"
argument_list|,
literal|"-r1"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|fexit
operator|=
name|TRUE
expr_stmt|;
block|}
name|usysdep_exit
argument_list|(
name|fexit
argument_list|)
expr_stmt|;
comment|/* Avoid error about not returning.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ucusage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Taylor UUCP version %s, copyright (C) 1991, 1992 Ian Lance Taylor\n"
argument_list|,
name|abVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: uucp [options] file1 [file2 ...] dest\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -c: Do not copy local files to spool directory\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -C: Copy local files to spool directory (default)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -d: Create necessary directories (default)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -f: Do not create directories (fail if they do not exist)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -g grade: Set job grade (must be alphabetic)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -m: Report status of copy by mail\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -n user: Report status of copy by mail to remote user\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -r: Do not start uucico daemon\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -s file: Report completion status to file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -j: Report job id\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -x debug: Set debugging level\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -I file: Set configuration file to use (default %s%s)\n"
argument_list|,
name|NEWCONFIGLIB
argument_list|,
name|CONFIGFILE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We keep a list of jobs for each system.  */
end_comment

begin_struct
struct|struct
name|sjob
block|{
name|struct
name|sjob
modifier|*
name|qnext
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|int
name|ccmds
decl_stmt|;
name|struct
name|scmd
modifier|*
name|pascmds
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|sjob
modifier|*
name|qCjobs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ucadd_cmd
parameter_list|(
name|qsys
parameter_list|,
name|qcmd
parameter_list|)
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
block|{
name|struct
name|sjob
modifier|*
name|qjob
decl_stmt|;
for|for
control|(
name|qjob
operator|=
name|qCjobs
init|;
name|qjob
operator|!=
name|NULL
condition|;
name|qjob
operator|=
name|qjob
operator|->
name|qnext
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|qjob
operator|->
name|qsys
operator|->
name|zname
argument_list|,
name|qsys
operator|->
name|zname
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|qjob
operator|==
name|NULL
condition|)
block|{
name|qjob
operator|=
operator|(
expr|struct
name|sjob
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sjob
argument_list|)
argument_list|)
expr_stmt|;
name|qjob
operator|->
name|qnext
operator|=
name|qCjobs
expr_stmt|;
name|qjob
operator|->
name|qsys
operator|=
name|qsys
expr_stmt|;
name|qjob
operator|->
name|ccmds
operator|=
literal|0
expr_stmt|;
name|qjob
operator|->
name|pascmds
operator|=
name|NULL
expr_stmt|;
name|qCjobs
operator|=
name|qjob
expr_stmt|;
block|}
name|qjob
operator|->
name|pascmds
operator|=
operator|(
operator|(
expr|struct
name|scmd
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|qjob
operator|->
name|pascmds
argument_list|,
operator|(
name|qjob
operator|->
name|ccmds
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scmd
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|qjob
operator|->
name|pascmds
index|[
name|qjob
operator|->
name|ccmds
index|]
operator|=
operator|*
name|qcmd
expr_stmt|;
operator|++
name|qjob
operator|->
name|ccmds
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ucspool_cmds
parameter_list|(
name|bgrade
parameter_list|,
name|fjobid
parameter_list|)
name|int
name|bgrade
decl_stmt|;
name|boolean
name|fjobid
decl_stmt|;
block|{
name|struct
name|sjob
modifier|*
name|qjob
decl_stmt|;
specifier|const
name|char
modifier|*
name|zjobid
decl_stmt|;
for|for
control|(
name|qjob
operator|=
name|qCjobs
init|;
name|qjob
operator|!=
name|NULL
condition|;
name|qjob
operator|=
name|qjob
operator|->
name|qnext
control|)
block|{
name|ulog_system
argument_list|(
name|qjob
operator|->
name|qsys
operator|->
name|zname
argument_list|)
expr_stmt|;
name|zjobid
operator|=
name|zsysdep_spool_commands
argument_list|(
name|qjob
operator|->
name|qsys
argument_list|,
name|bgrade
argument_list|,
name|qjob
operator|->
name|ccmds
argument_list|,
name|qjob
operator|->
name|pascmds
argument_list|)
expr_stmt|;
if|if
condition|(
name|zjobid
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|qcmd
operator|=
name|qjob
operator|->
name|pascmds
init|;
name|i
operator|<
name|qjob
operator|->
name|ccmds
condition|;
name|i
operator|++
operator|,
name|qcmd
operator|++
control|)
block|{
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'S'
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Queuing send of %s to %s"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'R'
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Queuing request of %s to %s"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Queuing execution (%s to %s)"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fjobid
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zjobid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return the system name for which we have created commands, or NULL    if we've created commands for more than one system.  Set *pfany to    FALSE if we didn't create work for any system.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|zcone_system
parameter_list|(
name|pfany
parameter_list|)
name|boolean
modifier|*
name|pfany
decl_stmt|;
block|{
if|if
condition|(
name|qCjobs
operator|==
name|NULL
condition|)
block|{
operator|*
name|pfany
operator|=
name|FALSE
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|pfany
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|qCjobs
operator|->
name|qnext
operator|==
name|NULL
condition|)
return|return
name|qCjobs
operator|->
name|qsys
operator|->
name|zname
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Keep track of all files we have created so that we can delete them    if we get a signal.  The argument will be on the heap.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ccfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|pcaz
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ucrecord_file
parameter_list|(
name|zfile
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
block|{
name|pcaz
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pcaz
argument_list|,
operator|(
name|ccfiles
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pcaz
index|[
name|ccfiles
index|]
operator|=
name|zfile
expr_stmt|;
operator|++
name|ccfiles
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete all the files we have recorded and exit.  */
end_comment

begin_function
specifier|static
name|void
name|ucabort
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccfiles
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|remove
argument_list|(
name|pcaz
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ulog_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

