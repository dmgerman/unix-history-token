begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* prot.c    Protocol support routines to move commands and data around.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: prot.c,v $    Revision 1.21  1992/04/02  22:51:09  ian    Add gcc 2.0 format checking to ulog, and fixed discovered problems     Revision 1.20  1992/03/30  04:49:10  ian    Niels Baggesen: added debugging types abnormal and uucp-proto     Revision 1.19  1992/03/30  04:07:13  ian    Dirk Musstopf: remove temporary file if receive fails     Revision 1.18  1992/03/13  22:59:25  ian    Have breceive_char go through freceive_data     Revision 1.17  1992/03/12  19:56:10  ian    Debugging based on types rather than number     Revision 1.16  1992/03/11  01:18:15  ian    Niels Baggesen: drop the connection on a write failure     Revision 1.15  1992/03/11  00:18:50  ian    Save temporary file if file send fails     Revision 1.14  1992/02/09  05:21:55  ian    Bob Denny: call fmail_transfer before fsysdep_did_work     Revision 1.13  1992/02/08  19:41:24  ian    Simplify pffile calls for ancient stupid compilers     Revision 1.12  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.11  1992/01/18  22:48:53  ian    Reworked sending of mail and general handling of failed transfers     Revision 1.10  1992/01/16  18:16:58  ian    Niels Baggesen: add some debugging messages     Revision 1.9  1991/12/31  19:34:19  ian    Added number of bytes to pffile protocol entry point     Revision 1.8  1991/12/30  04:28:30  ian    John Theus: check for EOF to work around bug in fread     Revision 1.7  1991/12/21  23:10:43  ian    Terry Gardner: record failed file transfers in statistics file     Revision 1.6  1991/12/13  04:33:38  ian    Franc,ois Pinard: don't bother to warn if the final HY doesn't come in     Revision 1.5  1991/11/15  21:00:59  ian    Efficiency hacks for 'f' and 't' protocols     Revision 1.4  1991/11/11  19:32:03  ian    Added breceive_char to read characters through protocol buffering     Revision 1.3  1991/11/11  04:21:16  ian    Added 'f' protocol     Revision 1.2  1991/11/10  19:24:22  ian    Added pffile protocol entry point for file level control     Revision 1.1  1991/11/09  18:51:50  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|prot_rcsid
index|[]
init|=
literal|"$Id: prot.c,v 1.21 1992/04/02 22:51:09 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* This file implements the generic UUCP protocol for making and    confirming file transfer requests.  This involves sending ASCII    strings back and forth between the communicating daemons.  It would    be possible to use a different scheme when designing a new    protocol, but this scheme is used by all traditional UUCP    protocols.  */
end_comment

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fpsendfile_confirm
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fprecfile_confirm
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fploop
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|upadd_cmd
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|z
operator|,
name|int
name|clen
operator|,
name|boolean
name|flast
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Variables visible to the protocol-specific routines.  */
end_comment

begin_comment
comment|/* Protocol structure.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|sprotocol
modifier|*
name|qProto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer to hold received data.  */
end_comment

begin_decl_stmt
name|char
name|abPrecbuf
index|[
name|CRECBUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of start of data in abPrecbuf.  */
end_comment

begin_decl_stmt
name|int
name|iPrecstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of end of data (first byte not included in data) in abPrecbuf.  */
end_comment

begin_decl_stmt
name|int
name|iPrecend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether an unexpected shutdown is OK now; this is used to avoid    giving a warning for systems that hang up in a hurry.  */
end_comment

begin_decl_stmt
name|boolean
name|fPerror_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of data sent for current send file; -1 means there is no    current send file.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cPsent_bytes
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of data received for current receive file; -1 means there is    no current receive file.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cPreceived_bytes
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Send a file.  If we are the master, we must send a command to    transfer the file and wait for a confirmation that we can begin    sending the file.  If we are the slave, the master has sent us a    command and is waiting for a reply; we must confirm that we will    send the file.  Either way, we begin transferring data.     This function returns FALSE if there is a communication failure.    It returns TRUE otherwise, even if the file transfer failed.  */
end_comment

begin_function
name|boolean
name|fsend_file
parameter_list|(
name|fmaster
parameter_list|,
name|e
parameter_list|,
name|qcmd
parameter_list|,
name|zmail
parameter_list|,
name|ztosys
parameter_list|,
name|fnew
parameter_list|)
name|boolean
name|fmaster
decl_stmt|;
name|openfile_t
name|e
decl_stmt|;
specifier|const
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|zmail
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztosys
decl_stmt|;
name|boolean
name|fnew
decl_stmt|;
block|{
if|if
condition|(
name|fmaster
condition|)
block|{
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|zsend
decl_stmt|;
specifier|const
name|char
modifier|*
name|zrec
decl_stmt|;
comment|/* Send the string 	 S zfrom zto zuser zoptions ztemp imode znotify 	 to the remote system.  We put a '-' in front of the (possibly 	 empty) options and a '0' in front of the mode.  The remote 	 system will ignore ztemp, but it is supposed to be sent anyhow. 	 If fnew is TRUE, we also send the size; in this case if ztemp 	 is empty we must send it as "".  */
name|clen
operator|=
operator|(
name|strlen
argument_list|(
name|qcmd
operator|->
name|zfrom
argument_list|)
operator|+
name|strlen
argument_list|(
name|qcmd
operator|->
name|zto
argument_list|)
operator|+
name|strlen
argument_list|(
name|qcmd
operator|->
name|zuser
argument_list|)
operator|+
name|strlen
argument_list|(
name|qcmd
operator|->
name|zoptions
argument_list|)
operator|+
name|strlen
argument_list|(
name|qcmd
operator|->
name|ztemp
argument_list|)
operator|+
name|strlen
argument_list|(
name|qcmd
operator|->
name|znotify
argument_list|)
operator|+
literal|50
operator|)
expr_stmt|;
name|zsend
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fnew
condition|)
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"S %s %s %s -%s %s 0%o %s"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|,
name|qcmd
operator|->
name|zoptions
argument_list|,
name|qcmd
operator|->
name|ztemp
argument_list|,
name|qcmd
operator|->
name|imode
argument_list|,
name|qcmd
operator|->
name|znotify
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|znotify
decl_stmt|;
if|if
condition|(
name|qcmd
operator|->
name|znotify
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|znotify
operator|=
name|qcmd
operator|->
name|znotify
expr_stmt|;
else|else
name|znotify
operator|=
literal|"\"\""
expr_stmt|;
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"S %s %s %s -%s %s 0%o %s %ld"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|,
name|qcmd
operator|->
name|zoptions
argument_list|,
name|qcmd
operator|->
name|ztemp
argument_list|,
name|qcmd
operator|->
name|imode
argument_list|,
name|znotify
argument_list|,
name|qcmd
operator|->
name|cbytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|zsend
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Now we must await a reply.  */
name|zrec
operator|=
name|zgetcmd
argument_list|()
expr_stmt|;
if|if
condition|(
name|zrec
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zrec
index|[
literal|0
index|]
operator|!=
literal|'S'
operator|||
operator|(
name|zrec
index|[
literal|1
index|]
operator|!=
literal|'Y'
operator|&&
name|zrec
index|[
literal|1
index|]
operator|!=
literal|'N'
operator|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad response to send request"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zrec
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|boolean
name|fnever
decl_stmt|;
name|fnever
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|zrec
index|[
literal|2
index|]
operator|==
literal|'2'
condition|)
name|zerr
operator|=
literal|"permission denied"
expr_stmt|;
elseif|else
if|if
condition|(
name|zrec
index|[
literal|2
index|]
operator|==
literal|'4'
condition|)
block|{
name|zerr
operator|=
literal|"remote cannot create work files"
expr_stmt|;
name|fnever
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zrec
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
name|zerr
operator|=
literal|"too large for receiver now"
expr_stmt|;
name|fnever
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zrec
index|[
literal|2
index|]
operator|==
literal|'7'
condition|)
block|{
comment|/* The file is too large to ever send.  */
name|zerr
operator|=
literal|"too large for receiver"
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|zset
decl_stmt|;
name|zset
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
expr|"unknown reason: "
operator|+
name|strlen
argument_list|(
name|zrec
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zset
argument_list|,
literal|"unknown reason: %s"
argument_list|,
name|zrec
argument_list|)
expr_stmt|;
name|zerr
operator|=
name|zset
expr_stmt|;
block|}
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't send %s: %s"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnever
condition|)
block|{
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|,
name|zmail
argument_list|,
name|zerr
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|zLocalname
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
name|ztosys
argument_list|,
name|zsysdep_save_temp_file
argument_list|(
name|qcmd
operator|->
name|pseq
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|qcmd
operator|->
name|pseq
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
block|}
else|else
block|{
name|char
name|absend
index|[
literal|20
index|]
decl_stmt|;
comment|/* We are the slave; confirm that we will send the file.  We 	 send the file mode in the confirmation string.  */
name|sprintf
argument_list|(
name|absend
argument_list|,
literal|"RY 0%o"
argument_list|,
name|qcmd
operator|->
name|imode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|absend
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Record the file we are sending, and let the protocol take over.  */
if|if
condition|(
operator|!
name|fstore_sendfile
argument_list|(
name|e
argument_list|,
name|qcmd
operator|->
name|pseq
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
name|ztosys
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|,
name|zmail
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cPsent_bytes
operator|=
literal|0
expr_stmt|;
comment|/* Tell the protocol that we are starting to send a file.  */
if|if
condition|(
name|qProto
operator|->
name|pffile
operator|!=
name|NULL
condition|)
block|{
name|boolean
argument_list|(
argument|*pffile
argument_list|)
name|P
argument_list|(
operator|(
name|boolean
operator|,
name|boolean
operator|,
name|boolean
operator|*
operator|,
name|long
operator|)
argument_list|)
expr_stmt|;
comment|/* Simplify expression for ancient compilers.  */
name|pffile
operator|=
name|qProto
operator|->
name|pffile
expr_stmt|;
if|if
condition|(
operator|!
name|pffile
argument_list|(
name|TRUE
argument_list|,
name|TRUE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|,
name|qcmd
operator|->
name|cbytes
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|fploop
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Confirm that a file has been received correctly by the other side.    Return FALSE for a communication error.  We expect the receiving    system to send back CY; if an error occurred while moving the    received file into its final location, the receiving system will    send back CN5.  */
end_comment

begin_function
specifier|static
name|boolean
name|fpsendfile_confirm
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|zrec
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|zrec
operator|=
name|zgetcmd
argument_list|()
expr_stmt|;
if|if
condition|(
name|zrec
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|cbytes
operator|=
name|cPsent_bytes
expr_stmt|;
name|cPsent_bytes
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|zrec
index|[
literal|0
index|]
operator|!=
literal|'C'
operator|||
operator|(
name|zrec
index|[
literal|1
index|]
operator|!=
literal|'Y'
operator|&&
name|zrec
index|[
literal|1
index|]
operator|!=
literal|'N'
operator|)
condition|)
block|{
name|zerr
operator|=
literal|"Bad confirmation for sent file"
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsent_file
argument_list|(
name|FALSE
argument_list|,
name|cbytes
argument_list|,
name|zerr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zrec
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
if|if
condition|(
name|zrec
index|[
literal|2
index|]
operator|==
literal|'5'
condition|)
name|zerr
operator|=
literal|"File could not be stored in final location"
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|zset
decl_stmt|;
name|zset
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
expr|"File send failed: "
operator|+
name|strlen
argument_list|(
name|zrec
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zset
argument_list|,
literal|"File send failed: %s"
argument_list|,
name|zrec
argument_list|)
expr_stmt|;
name|zerr
operator|=
name|zset
expr_stmt|;
block|}
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsent_file
argument_list|(
name|FALSE
argument_list|,
name|cbytes
argument_list|,
name|zerr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fsent_file
argument_list|(
name|TRUE
argument_list|,
name|cbytes
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Receive a file.  If we are the master, we must set up a file    request and wait for the other side to confirm it.  If we are the    slave, we must confirm a request made by the other side.  We then    start receiving the file.     This function must return FALSE if there is a communication error    and TRUE otherwise.  We return TRUE even if the file transfer    fails.  */
end_comment

begin_function
name|boolean
name|freceive_file
parameter_list|(
name|fmaster
parameter_list|,
name|e
parameter_list|,
name|qcmd
parameter_list|,
name|zmail
parameter_list|,
name|zfromsys
parameter_list|,
name|fnew
parameter_list|)
name|boolean
name|fmaster
decl_stmt|;
name|openfile_t
name|e
decl_stmt|;
specifier|const
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|zmail
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfromsys
decl_stmt|;
name|boolean
name|fnew
decl_stmt|;
block|{
name|unsigned
name|int
name|imode
decl_stmt|;
if|if
condition|(
name|fmaster
condition|)
block|{
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|zsend
decl_stmt|;
specifier|const
name|char
modifier|*
name|zrec
decl_stmt|;
comment|/* We send the string 	 R from to user options 	 We put a dash in front of options.  If we are talking to a 	 counterpart, we also send the maximum size file we are 	 prepared to accept, as returned by esysdep_open_receive.  */
name|clen
operator|=
operator|(
name|strlen
argument_list|(
name|qcmd
operator|->
name|zfrom
argument_list|)
operator|+
name|strlen
argument_list|(
name|qcmd
operator|->
name|zto
argument_list|)
operator|+
name|strlen
argument_list|(
name|qcmd
operator|->
name|zuser
argument_list|)
operator|+
name|strlen
argument_list|(
name|qcmd
operator|->
name|zoptions
argument_list|)
operator|+
literal|30
operator|)
expr_stmt|;
name|zsend
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fnew
condition|)
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"R %s %s %s -%s"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|,
name|qcmd
operator|->
name|zoptions
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"R %s %s %s -%s %ld"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|,
name|qcmd
operator|->
name|zoptions
argument_list|,
name|qcmd
operator|->
name|cbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|zsend
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qcmd
operator|->
name|ztemp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Wait for a reply.  */
name|zrec
operator|=
name|zgetcmd
argument_list|()
expr_stmt|;
if|if
condition|(
name|zrec
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qcmd
operator|->
name|ztemp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zrec
index|[
literal|0
index|]
operator|!=
literal|'R'
operator|||
operator|(
name|zrec
index|[
literal|1
index|]
operator|!=
literal|'Y'
operator|&&
name|zrec
index|[
literal|1
index|]
operator|!=
literal|'N'
operator|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad response to receive request"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qcmd
operator|->
name|ztemp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zrec
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
if|if
condition|(
name|zrec
index|[
literal|2
index|]
operator|==
literal|'2'
condition|)
name|zerr
operator|=
literal|"no such file"
expr_stmt|;
elseif|else
if|if
condition|(
name|zrec
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
comment|/* We sent over the maximum file size we were prepared 		 to receive, and the remote system is telling us that 		 the file is larger than that.  Try again later.  It 		 would be better if we could know whether there will 		 ever be enough room.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't receive %s: too large"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qcmd
operator|->
name|ztemp
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|char
modifier|*
name|zset
decl_stmt|;
name|zset
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
expr|"unknown reason: "
operator|+
name|strlen
argument_list|(
name|zrec
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zset
argument_list|,
literal|"unknown reason: %s"
argument_list|,
name|zrec
argument_list|)
expr_stmt|;
name|zerr
operator|=
name|zset
expr_stmt|;
block|}
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't receive %s: %s"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qcmd
operator|->
name|ztemp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fmail_transfer
argument_list|(
name|FALSE
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|,
name|zmail
argument_list|,
name|zerr
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|zfromsys
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
name|zLocalname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_did_work
argument_list|(
name|qcmd
operator|->
name|pseq
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* The mode should have been sent as "RY 0%o".  If it wasn't, 	 we use 0666.  */
name|imode
operator|=
operator|(
name|unsigned
name|int
operator|)
name|strtol
argument_list|(
name|zrec
operator|+
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|==
literal|0
condition|)
name|imode
operator|=
literal|0666
expr_stmt|;
block|}
else|else
block|{
comment|/* Tell the other system to go ahead and send.  */
if|if
condition|(
operator|!
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
literal|"SY"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ffileclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|qcmd
operator|->
name|ztemp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|imode
operator|=
name|qcmd
operator|->
name|imode
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fstore_recfile
argument_list|(
name|e
argument_list|,
name|qcmd
operator|->
name|pseq
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
name|zfromsys
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|,
name|imode
argument_list|,
name|zmail
argument_list|,
name|qcmd
operator|->
name|ztemp
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cPreceived_bytes
operator|=
literal|0
expr_stmt|;
comment|/* Tell the protocol that we are starting to receive a file.  */
if|if
condition|(
name|qProto
operator|->
name|pffile
operator|!=
name|NULL
condition|)
block|{
name|boolean
argument_list|(
argument|*pffile
argument_list|)
name|P
argument_list|(
operator|(
name|boolean
operator|,
name|boolean
operator|,
name|boolean
operator|*
operator|,
name|long
operator|)
argument_list|)
expr_stmt|;
comment|/* Simplify expression for ancient compilers.  */
name|pffile
operator|=
name|qProto
operator|->
name|pffile
expr_stmt|;
if|if
condition|(
operator|!
name|pffile
argument_list|(
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|fploop
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Confirm that a file was received correctly.  */
end_comment

begin_function
specifier|static
name|boolean
name|fprecfile_confirm
parameter_list|()
block|{
name|long
name|cbytes
decl_stmt|;
name|cbytes
operator|=
name|cPreceived_bytes
expr_stmt|;
name|cPreceived_bytes
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|freceived_file
argument_list|(
name|TRUE
argument_list|,
name|cbytes
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
literal|"CY"
argument_list|)
return|;
else|else
return|return
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
literal|"CN5"
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a transfer request.  This is only called by the master.  It    ignored the pseq entry in the scmd structure.  */
end_comment

begin_function
name|boolean
name|fxcmd
parameter_list|(
name|qcmd
parameter_list|,
name|pfnever
parameter_list|)
specifier|const
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
name|boolean
modifier|*
name|pfnever
decl_stmt|;
block|{
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|zsend
decl_stmt|;
specifier|const
name|char
modifier|*
name|zrec
decl_stmt|;
operator|*
name|pfnever
operator|=
name|FALSE
expr_stmt|;
comment|/* We send the string      X from to user options      We put a dash in front of options.  */
name|clen
operator|=
operator|(
name|strlen
argument_list|(
name|qcmd
operator|->
name|zfrom
argument_list|)
operator|+
name|strlen
argument_list|(
name|qcmd
operator|->
name|zto
argument_list|)
operator|+
name|strlen
argument_list|(
name|qcmd
operator|->
name|zuser
argument_list|)
operator|+
name|strlen
argument_list|(
name|qcmd
operator|->
name|zoptions
argument_list|)
operator|+
literal|7
operator|)
expr_stmt|;
name|zsend
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|clen
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zsend
argument_list|,
literal|"X %s %s %s -%s"
argument_list|,
name|qcmd
operator|->
name|zfrom
argument_list|,
name|qcmd
operator|->
name|zto
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|,
name|qcmd
operator|->
name|zoptions
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|zsend
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Wait for a reply.  */
name|zrec
operator|=
name|zgetcmd
argument_list|()
expr_stmt|;
if|if
condition|(
name|zrec
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|zrec
index|[
literal|0
index|]
operator|!=
literal|'X'
operator|||
operator|(
name|zrec
index|[
literal|1
index|]
operator|!=
literal|'Y'
operator|&&
name|zrec
index|[
literal|1
index|]
operator|!=
literal|'N'
operator|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad response to wildcard request"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zrec
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Work request denied"
argument_list|)
expr_stmt|;
operator|*
name|pfnever
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Confirm a transfer request.  */
end_comment

begin_function
name|boolean
name|fxcmd_confirm
parameter_list|()
block|{
return|return
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
literal|"XY"
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Signal a file transfer failure to the other side.  This is only called    by the slave.  */
end_comment

begin_function
name|boolean
name|ftransfer_fail
parameter_list|(
name|bcmd
parameter_list|,
name|twhy
parameter_list|)
name|int
name|bcmd
decl_stmt|;
name|enum
name|tfailure
name|twhy
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
switch|switch
condition|(
name|bcmd
condition|)
block|{
case|case
literal|'S'
case|:
switch|switch
condition|(
name|twhy
condition|)
block|{
case|case
name|FAILURE_PERM
case|:
name|z
operator|=
literal|"SN2"
expr_stmt|;
break|break;
case|case
name|FAILURE_OPEN
case|:
name|z
operator|=
literal|"SN4"
expr_stmt|;
break|break;
case|case
name|FAILURE_SIZE
case|:
name|z
operator|=
literal|"SN6"
expr_stmt|;
break|break;
default|default:
name|z
operator|=
literal|"SN"
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'R'
case|:
switch|switch
condition|(
name|twhy
condition|)
block|{
case|case
name|FAILURE_PERM
case|:
case|case
name|FAILURE_OPEN
case|:
name|z
operator|=
literal|"RN2"
expr_stmt|;
break|break;
case|case
name|FAILURE_SIZE
case|:
name|z
operator|=
literal|"RN6"
expr_stmt|;
break|break;
default|default:
name|z
operator|=
literal|"RN"
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'X'
case|:
name|z
operator|=
literal|"XN"
expr_stmt|;
break|break;
default|default:
if|#
directive|if
name|DEBUG
operator|>
literal|0
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"ftransfer_fail: Can't happen"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
return|return
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
name|z
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get and parse a command from the other system.  Handle hangups    specially.  */
end_comment

begin_function
name|boolean
name|fgetcmd
parameter_list|(
name|fmaster
parameter_list|,
name|qcmd
parameter_list|)
name|boolean
name|fmaster
decl_stmt|;
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|z
decl_stmt|;
specifier|static
name|int
name|c
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
specifier|const
name|char
modifier|*
name|zcmd
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|zcmd
operator|=
name|zgetcmd
argument_list|()
expr_stmt|;
if|if
condition|(
name|zcmd
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|clen
operator|=
name|strlen
argument_list|(
name|zcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|+
literal|1
operator|>
name|c
condition|)
block|{
name|c
operator|=
name|clen
operator|+
literal|1
expr_stmt|;
name|z
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|z
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|z
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fparse_cmd
argument_list|(
name|z
argument_list|,
name|qcmd
argument_list|)
condition|)
continue|continue;
comment|/* Handle hangup commands specially.  If it's just 'H', return 	 it.  If it's 'N', the other side is denying a hangup request 	 which we can just ignore (since the top level code assumes 	 that hangup requests are denied).  If it's 'Y', the other 	 side is confirming a hangup request.  In this case we confirm 	 with an "HY", wait for yet another "HY" from the other side, 	 and then finally shut down the protocol (I don't know why it 	 works this way, but it does).  We then return a 'Y' command 	 to the top level code.  */
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'N'
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|fmaster
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Got hangup reply as master"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'Y'
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|fmaster
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Got hangup reply as master"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't check errors rigorously here, since the other side 	     might jump the gun and hang up.  */
if|if
condition|(
operator|!
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
literal|"HY"
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|fPerror_ok
operator|=
name|TRUE
expr_stmt|;
name|zcmd
operator|=
name|zgetcmd
argument_list|()
expr_stmt|;
name|fPerror_ok
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|zcmd
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|strcmp
argument_list|(
name|zcmd
argument_list|,
literal|"HY"
argument_list|)
operator|!=
literal|0
condition|)
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"fgetcmd: Got \"%s\" when expecting \"HY\""
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
name|void
call|)
argument_list|(
name|qProto
operator|->
name|pfshutdown
argument_list|)
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hangup.  */
end_comment

begin_function
name|boolean
name|fhangup_request
parameter_list|()
block|{
return|return
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
literal|"H"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Reply to a hangup request.  This is only called by the slave.  If    fconfirm is TRUE, we are closing down the protocol.  We send an HY    message.  The master responds with an HY message.  We send another    HY message, and then shut down the protocol.  */
end_comment

begin_function
name|boolean
name|fhangup_reply
parameter_list|(
name|fconfirm
parameter_list|)
name|boolean
name|fconfirm
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|fconfirm
condition|)
return|return
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
literal|"HN"
argument_list|)
return|;
else|else
block|{
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
operator|!
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
literal|"HY"
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|z
operator|=
name|zgetcmd
argument_list|()
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"HY"
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Got \"%s\" when expecting \"HY\""
argument_list|,
name|z
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
call|(
name|qProto
operator|->
name|pfsendcmd
call|)
argument_list|(
literal|"HY"
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
call|(
name|qProto
operator|->
name|pfshutdown
call|)
argument_list|()
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Loop sending and/or receiving data.  If there is a file to send,    this will send it until the entire file has been sent or a command    has been received from the remote system or a complete file has    been received from the remote system.  Otherwise this will simply    call the protocol to wait until a complete file or command has been    received from the remote system.  */
end_comment

begin_function
specifier|static
name|boolean
name|fploop
parameter_list|()
block|{
name|boolean
name|fexit
decl_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"fploop: Main protocol loop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffileisopen
argument_list|(
name|eSendfile
argument_list|)
condition|)
block|{
name|int
name|iend
decl_stmt|;
name|iend
operator|=
name|iPrecend
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* We keep sending out packets until we have something 	     in the receive buffer.  */
while|while
condition|(
name|iend
operator|==
name|iPrecend
condition|)
block|{
name|char
modifier|*
name|zdata
decl_stmt|;
name|int
name|cdata
decl_stmt|;
comment|/* Get a packet and fill it with data.  */
name|zdata
operator|=
call|(
name|qProto
operator|->
name|pzgetspace
call|)
argument_list|(
operator|&
name|cdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ffileeof
argument_list|(
name|eSendfile
argument_list|)
condition|)
name|cdata
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|cdata
operator|=
name|cfileread
argument_list|(
name|eSendfile
argument_list|,
name|zdata
argument_list|,
name|cdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffilereaderror
argument_list|(
name|eSendfile
argument_list|,
name|cdata
argument_list|)
condition|)
block|{
comment|/* The protocol gives us no way to report a file 			 sending error, so we just drop the connection. 			 What else can we do?  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"read: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|usendfile_error
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|!
call|(
name|qProto
operator|->
name|pfsenddata
call|)
argument_list|(
name|zdata
argument_list|,
name|cdata
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cPsent_bytes
operator|+=
name|cdata
expr_stmt|;
comment|/* If we have reached the end of the file, tell the 		 protocol that the file is finished (the protocol 		 could also detect this by looking for zero passed as 		 the data length to the send data routine, but would 		 have no convenient way to tell us to redo the file 		 send).  If we are not supposed to redo the file 		 transfer, wait for confirmation and return out to get 		 the next file.  */
if|if
condition|(
name|cdata
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|qProto
operator|->
name|pffile
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|fredo
decl_stmt|;
name|boolean
argument_list|(
argument|*pffile
argument_list|)
name|P
argument_list|(
operator|(
name|boolean
operator|,
name|boolean
operator|,
name|boolean
operator|*
operator|,
name|long
operator|)
argument_list|)
expr_stmt|;
comment|/* Simplify expression for ancient compilers.  */
name|pffile
operator|=
name|qProto
operator|->
name|pffile
expr_stmt|;
if|if
condition|(
operator|!
name|pffile
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|&
name|fredo
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fredo
condition|)
block|{
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Resending file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffilerewind
argument_list|(
name|eSendfile
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"rewind: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|usendfile_error
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
continue|continue;
block|}
block|}
return|return
name|fpsendfile_confirm
argument_list|()
return|;
block|}
block|}
comment|/* Process the data in the receive buffer, and decide 	     whether it's time to get out.  */
if|if
condition|(
operator|!
call|(
name|qProto
operator|->
name|pfprocess
call|)
argument_list|(
operator|&
name|fexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fexit
condition|)
return|return
name|TRUE
return|;
name|iend
operator|=
name|iPrecend
expr_stmt|;
block|}
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|0
comment|/* If there is no file to send, there really should be a file to      receive.  */
if|if
condition|(
operator|!
name|ffileisopen
argument_list|(
name|eRecfile
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fploop: No send or receive file"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We have no file to send.  Wait for data to come in.  */
return|return
call|(
name|qProto
operator|->
name|pfwait
call|)
argument_list|()
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is called by the protocol routines when data has    arrived.  Some protocols may know whether the data is for a command    or a file; for others, if a receive file is open it is for the file    and is otherwise for a command.  This function will set *pfexit to    TRUE if it has received a complete file (assumed to be true if    cdata is zero) or a complete command (assumed to be true if the    argument data contains a null byte).  It will return FALSE on    error.  */
end_comment

begin_function
name|boolean
name|fgot_data
parameter_list|(
name|zdata
parameter_list|,
name|cdata
parameter_list|,
name|fcmd
parameter_list|,
name|ffile
parameter_list|,
name|pfexit
parameter_list|)
specifier|const
name|char
modifier|*
name|zdata
decl_stmt|;
name|int
name|cdata
decl_stmt|;
name|boolean
name|fcmd
decl_stmt|;
name|boolean
name|ffile
decl_stmt|;
name|boolean
modifier|*
name|pfexit
decl_stmt|;
block|{
operator|*
name|pfexit
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|fcmd
operator|&&
operator|!
name|ffile
condition|)
block|{
if|if
condition|(
name|ffileisopen
argument_list|(
name|eRecfile
argument_list|)
condition|)
name|ffile
operator|=
name|TRUE
expr_stmt|;
else|else
name|fcmd
operator|=
name|TRUE
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|ffile
operator|&&
operator|!
name|ffileisopen
argument_list|(
name|eRecfile
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fgot_data: No file to receive into"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ffile
condition|)
block|{
if|if
condition|(
name|cdata
operator|==
literal|0
condition|)
block|{
comment|/* The file transfer is complete.  If the protocol has a 	     file level routine, call it to see whether we have to 	     receive the file again.  */
if|if
condition|(
name|qProto
operator|->
name|pffile
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|fredo
decl_stmt|;
name|boolean
argument_list|(
argument|*pffile
argument_list|)
name|P
argument_list|(
operator|(
name|boolean
operator|,
name|boolean
operator|,
name|boolean
operator|*
operator|,
name|long
operator|)
argument_list|)
expr_stmt|;
comment|/* Simplify expression for ancient compilers.  */
name|pffile
operator|=
name|qProto
operator|->
name|pffile
expr_stmt|;
if|if
condition|(
operator|!
name|pffile
argument_list|(
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|fredo
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fredo
condition|)
block|{
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"File being resent"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frecfile_rewind
argument_list|()
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|fprecfile_confirm
argument_list|()
condition|)
return|return
name|FALSE
return|;
operator|*
name|pfexit
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|int
name|cwrote
decl_stmt|;
comment|/* Cast zdata to avoid warnings because of erroneous 	     prototypes on Ultrix.  */
name|cwrote
operator|=
name|cfilewrite
argument_list|(
name|eRecfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|zdata
argument_list|,
name|cdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwrote
operator|!=
name|cdata
condition|)
block|{
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
if|if
condition|(
name|cwrote
operator|<
literal|0
condition|)
name|zerr
operator|=
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
else|else
name|zerr
operator|=
literal|"could not write all data"
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"write: %s"
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
name|urecfile_error
argument_list|()
expr_stmt|;
comment|/* Any write error is almost certainly a temporary 		 condition, or else UUCP would not be functioning at 		 all.  If we continue to accept the file, we will wind 		 up rejecting it at the end (what else could we do?) 		 and the remote system will throw away the request. 		 We're better off just dropping the connection, which 		 is what happens when we return FALSE, and trying 		 again later.  */
return|return
name|FALSE
return|;
block|}
name|cPreceived_bytes
operator|+=
name|cdata
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
comment|/* We want to add this data to the current command string.  If 	 there is no null character in the data, this string will be 	 continued by the next packet.  Otherwise this must be the 	 last string in the command, and we don't care about what 	 comes after the null byte.  */
name|z
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|memchr
argument_list|(
operator|(
name|constpointer
operator|)
name|zdata
argument_list|,
literal|'\0'
argument_list|,
name|cdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
name|upadd_cmd
argument_list|(
name|zdata
argument_list|,
name|cdata
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
name|upadd_cmd
argument_list|(
name|zdata
argument_list|,
name|z
operator|-
name|zdata
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|pfexit
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is called by fgot_data when a command string is    received.  We must queue up received commands since we don't know    when we'll be able to get to them (for example, the    acknowledgements for the last few packets of a sent file may    contain the string indicating whether the file was received    correctly).  */
end_comment

begin_struct
struct|struct
name|spcmdqueue
block|{
name|struct
name|spcmdqueue
modifier|*
name|qnext
decl_stmt|;
name|int
name|csize
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|spcmdqueue
modifier|*
name|qPcmd_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|spcmdqueue
modifier|*
name|qPcmd_free
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|upadd_cmd
parameter_list|(
name|z
parameter_list|,
name|clen
parameter_list|,
name|flast
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|boolean
name|flast
decl_stmt|;
block|{
name|struct
name|spcmdqueue
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|qPcmd_free
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|q
operator|=
operator|(
expr|struct
name|spcmdqueue
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spcmdqueue
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|qnext
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|csize
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|clen
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|z
operator|=
name|NULL
expr_stmt|;
name|qPcmd_free
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|clen
operator|+
name|clen
operator|+
literal|1
operator|>
name|q
operator|->
name|csize
condition|)
block|{
name|q
operator|->
name|csize
operator|=
name|q
operator|->
name|clen
operator|+
name|clen
operator|+
literal|1
expr_stmt|;
name|q
operator|->
name|z
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|q
operator|->
name|z
argument_list|,
name|q
operator|->
name|csize
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|q
operator|->
name|z
operator|+
name|q
operator|->
name|clen
argument_list|,
name|z
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|q
operator|->
name|clen
operator|+=
name|clen
expr_stmt|;
name|q
operator|->
name|z
index|[
name|q
operator|->
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If the last string in this command, add it to the queue of      finished commands.  */
if|if
condition|(
name|flast
condition|)
block|{
name|struct
name|spcmdqueue
modifier|*
modifier|*
name|pq
decl_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
name|qPcmd_queue
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
control|)
empty_stmt|;
operator|*
name|pq
operator|=
name|q
expr_stmt|;
name|qPcmd_free
operator|=
name|q
operator|->
name|qnext
expr_stmt|;
name|q
operator|->
name|qnext
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get a command string.  We just have to wait until the receive    packet function gives us something in qPcmd_queue.  The return    value of this may be treated as a static buffer; it will last    at least until the next packet is received.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zgetcmd
parameter_list|()
block|{
name|struct
name|spcmdqueue
modifier|*
name|q
decl_stmt|;
comment|/* Wait until a command comes in.  */
while|while
condition|(
name|qPcmd_queue
operator|==
name|NULL
condition|)
block|{
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"zgetcmd: Waiting for packet"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
name|qProto
operator|->
name|pfwait
call|)
argument_list|()
condition|)
return|return
name|NULL
return|;
block|}
name|q
operator|=
name|qPcmd_queue
expr_stmt|;
name|qPcmd_queue
operator|=
name|q
operator|->
name|qnext
expr_stmt|;
name|q
operator|->
name|clen
operator|=
literal|0
expr_stmt|;
comment|/* We must not replace qPcmd_free, because it may already be      receiving a new command string.  */
if|if
condition|(
name|qPcmd_free
operator|==
name|NULL
condition|)
block|{
name|q
operator|->
name|qnext
operator|=
name|NULL
expr_stmt|;
name|qPcmd_free
operator|=
name|q
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|qnext
operator|=
name|qPcmd_free
operator|->
name|qnext
expr_stmt|;
name|qPcmd_free
operator|->
name|qnext
operator|=
name|q
expr_stmt|;
block|}
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"zgetcmd: Got command \"%s\""
argument_list|,
name|q
operator|->
name|z
argument_list|)
expr_stmt|;
return|return
name|q
operator|->
name|z
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We want to output and input at the same time, if supported on this    machine.  If we have something to send, we send it all while    accepting a large amount of data.  Once we have sent everything we    look at whatever we have received.  If data comes in faster than we    can send it, we may run out of buffer space.  */
end_comment

begin_function
name|boolean
name|fsend_data
parameter_list|(
name|zsend
parameter_list|,
name|csend
parameter_list|,
name|fdoread
parameter_list|)
specifier|const
name|char
modifier|*
name|zsend
decl_stmt|;
name|int
name|csend
decl_stmt|;
name|boolean
name|fdoread
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|fdoread
condition|)
return|return
name|fport_write
argument_list|(
name|zsend
argument_list|,
name|csend
argument_list|)
return|;
while|while
condition|(
name|csend
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|zrec
decl_stmt|;
name|int
name|crec
decl_stmt|,
name|csent
decl_stmt|;
if|if
condition|(
name|iPrecend
operator|<
name|iPrecstart
condition|)
block|{
name|zrec
operator|=
name|abPrecbuf
operator|+
name|iPrecend
expr_stmt|;
name|crec
operator|=
name|iPrecstart
operator|-
name|iPrecend
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iPrecend
operator|<
name|CRECBUFLEN
condition|)
block|{
name|zrec
operator|=
name|abPrecbuf
operator|+
name|iPrecend
expr_stmt|;
name|crec
operator|=
name|CRECBUFLEN
operator|-
name|iPrecend
expr_stmt|;
block|}
else|else
block|{
name|zrec
operator|=
name|abPrecbuf
expr_stmt|;
name|crec
operator|=
name|iPrecstart
operator|-
literal|1
expr_stmt|;
block|}
name|csent
operator|=
name|csend
expr_stmt|;
if|if
condition|(
operator|!
name|fport_io
argument_list|(
name|zsend
argument_list|,
operator|&
name|csent
argument_list|,
name|zrec
argument_list|,
operator|&
name|crec
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|csend
operator|-=
name|csent
expr_stmt|;
name|zsend
operator|+=
name|csent
expr_stmt|;
name|iPrecend
operator|=
operator|(
name|iPrecend
operator|+
name|crec
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read data from the other system when we have nothing to send.  The    argument cneed is the amount of data the caller wants, and ctimeout    is the timeout in seconds.  The function sets *pcrec to the amount    of data which was actually received, which may be less than cneed    if there isn't enough room in the receive buffer.  If no data is    received before the timeout expires, *pcrec will be returned as 0.    If an error occurs, the function returns FALSE.  If the freport    argument is FALSE, no error should be reported.  */
end_comment

begin_function
name|boolean
name|freceive_data
parameter_list|(
name|cneed
parameter_list|,
name|pcrec
parameter_list|,
name|ctimeout
parameter_list|,
name|freport
parameter_list|)
name|int
name|cneed
decl_stmt|;
name|int
modifier|*
name|pcrec
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
name|boolean
name|freport
decl_stmt|;
block|{
comment|/* Set *pcrec to the maximum amount of data we can read.  fport_read      expects *pcrec to be the buffer size, and sets it to the amount      actually received.  */
if|if
condition|(
name|iPrecend
operator|<
name|iPrecstart
condition|)
operator|*
name|pcrec
operator|=
name|iPrecstart
operator|-
name|iPrecend
operator|-
literal|1
expr_stmt|;
else|else
block|{
operator|*
name|pcrec
operator|=
name|CRECBUFLEN
operator|-
name|iPrecend
expr_stmt|;
if|if
condition|(
name|iPrecstart
operator|==
literal|0
condition|)
operator|--
operator|(
operator|*
name|pcrec
operator|)
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|0
comment|/* If we have no room in the buffer, we're in trouble.  The      protocols must be written to ensure that this can't happen.  */
if|if
condition|(
operator|*
name|pcrec
operator|==
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"freceive_data: No room in buffer"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we don't have room for all the data the caller wants, we      simply have to expect less.  We'll get the rest later.  */
if|if
condition|(
operator|*
name|pcrec
operator|<
name|cneed
condition|)
name|cneed
operator|=
operator|*
name|pcrec
expr_stmt|;
if|if
condition|(
operator|!
name|fport_read
argument_list|(
name|abPrecbuf
operator|+
name|iPrecend
argument_list|,
name|pcrec
argument_list|,
name|cneed
argument_list|,
name|ctimeout
argument_list|,
name|freport
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iPrecend
operator|=
operator|(
name|iPrecend
operator|+
operator|*
name|pcrec
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a single character.  Get it out of the receive buffer if it's    there, otherwise ask freceive_data for at least one character.    This is used because as a protocol is shutting down freceive_data    may read ahead and eat characters that should be read outside the    protocol routines.  We call freceive_data rather than fport_read    with an argument of 1 so that we can get all the available data in    a single system call.  The ctimeout argument is the timeout in    seconds; the freport argument is FALSE if no error should be    reported.  This returns a character, or -1 on timeout or -2 on    error.  */
end_comment

begin_function
name|int
name|breceive_char
parameter_list|(
name|ctimeout
parameter_list|,
name|freport
parameter_list|)
name|int
name|ctimeout
decl_stmt|;
name|boolean
name|freport
decl_stmt|;
block|{
name|char
name|b
decl_stmt|;
if|if
condition|(
name|iPrecstart
operator|==
name|iPrecend
condition|)
block|{
name|int
name|crec
decl_stmt|;
if|if
condition|(
operator|!
name|freceive_data
argument_list|(
literal|1
argument_list|,
operator|&
name|crec
argument_list|,
name|ctimeout
argument_list|,
name|freport
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
name|crec
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|b
operator|=
name|abPrecbuf
index|[
name|iPrecstart
index|]
expr_stmt|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
return|return
name|BUCHAR
argument_list|(
name|b
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This routine is called when an error occurred and we are crashing    out of the connection.  It is only used to report statistics on    failed transfers to the statistics file.  Note that the number of    bytes we report as having been sent has little or nothing to do    with the number of bytes the remote site actually received.  */
end_comment

begin_function
name|void
name|ustats_failed
parameter_list|()
block|{
name|long
name|cbytes
decl_stmt|;
if|if
condition|(
name|cPsent_bytes
operator|!=
operator|-
literal|1
condition|)
block|{
name|cbytes
operator|=
name|cPsent_bytes
expr_stmt|;
name|cPsent_bytes
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fsent_file
argument_list|(
name|FALSE
argument_list|,
name|cbytes
argument_list|,
literal|"connection failure"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cPreceived_bytes
operator|!=
operator|-
literal|1
condition|)
block|{
name|cbytes
operator|=
name|cPreceived_bytes
expr_stmt|;
name|cPreceived_bytes
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|freceived_file
argument_list|(
name|FALSE
argument_list|,
name|cbytes
argument_list|,
literal|"connection failure"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

