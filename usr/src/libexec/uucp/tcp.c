begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tcp.c    Code to handle TCP connections.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: tcp.c,v $    Revision 1.16  1992/03/30  15:37:22  ian    Petri Helenius: TCP server never started uuxqt     Revision 1.15  1992/03/17  02:44:08  ian    Declare _exit     Revision 1.14  1992/03/17  00:34:10  ian    Cast argument to bzero     Revision 1.13  1992/03/15  04:51:17  ian    Keep an array of signals we've received rather than a single variable     Revision 1.12  1992/03/15  01:54:46  ian    All execs are now done in isspawn, all waits are done in iswait     Revision 1.11  1992/03/12  19:56:10  ian    Debugging based on types rather than number     Revision 1.10  1992/03/11  02:09:57  ian    Franc,ois Pinard: retry fork several times before giving up     Revision 1.9  1992/03/10  22:57:03  ian    Petri Helenius: have server fork twice to avoid zombies     Revision 1.8  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.7  1991/12/28  03:49:23  ian    Added HAVE_MEMFNS and HAVE_BFNS; changed uses of memset to bzero     Revision 1.6  1991/12/26  22:54:32  ian    Monty Solomon: cast arguments to avoid prototype errors     Revision 1.5  1991/12/22  22:14:19  ian    Monty Solomon: added HAVE_UNISTD_H configuration parameter     Revision 1.4  1991/12/10  19:45:05  ian    Added ulog_device to record device name for log file     Revision 1.3  1991/11/24  20:06:08  ian    Michael Haberler: itcp_port_number of a number wasn't calling htons     Revision 1.2  1991/11/14  03:20:13  ian    Added seven-bit and reliable commands to help when selecting protocols     Revision 1.1  1991/11/13  20:38:00  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|tcp_rcsid
index|[]
init|=
literal|"$Id: tcp.c,v 1.16 1992/03/30 15:37:22 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_TCP
end_if

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|USE_STDIO
operator|&&
name|HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_comment
comment|/* External functions.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|close
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|socket
argument_list|()
decl_stmt|,
name|bind
argument_list|()
decl_stmt|,
name|listen
argument_list|()
decl_stmt|,
name|accept
argument_list|()
decl_stmt|,
name|connect
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|_exit
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* This code handles TCP connections by providing a set of routines    that are called by the port routines.  It assumes a Berkeley socket    interface.  */
end_comment

begin_comment
comment|/* The normal "uucp" port number.  */
end_comment

begin_define
define|#
directive|define
name|IUUCP_PORT
value|(540)
end_define

begin_comment
comment|/* Local function to get the port number from a name.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|itcp_port_number
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zport
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Lock a port.  There is no need to lock a TCP port.  */
end_comment

begin_function
name|boolean
name|ftcp_lock
parameter_list|(
name|qport
parameter_list|,
name|fin
parameter_list|)
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
name|boolean
name|fin
decl_stmt|;
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open a port.  If the fwait argument is TRUE, we are running as a    server.  Otherwise we are just trying to reach another system.  */
end_comment

begin_function
name|boolean
name|ftcp_open
parameter_list|(
name|qport
parameter_list|,
name|ibaud
parameter_list|,
name|fwait
parameter_list|)
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
name|boolean
name|fwait
decl_stmt|;
block|{
name|struct
name|sockaddr_in
name|s
decl_stmt|;
name|ulog_device
argument_list|(
literal|"TCP"
argument_list|)
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|o
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|o
operator|==
operator|-
literal|1
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"socket: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If we aren't waiting for a connection, we're done.  */
if|if
condition|(
operator|!
name|fwait
condition|)
return|return
name|TRUE
return|;
comment|/* Run as a server and wait for a new connection.  The code in      uucico.c has already detached us from our controlling terminal.      From this point on if the server gets an error we exit; we only      return if we have received a connection.  It would be more robust      to respawn the server if it fails; someday.  */
name|bzero
argument_list|(
operator|(
name|pointer
operator|)
operator|&
name|s
argument_list|,
sizeof|sizeof
name|s
argument_list|)
expr_stmt|;
name|s
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|s
operator|.
name|sin_port
operator|=
name|itcp_port_number
argument_list|(
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|zport
argument_list|)
expr_stmt|;
name|s
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|o
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|s
argument_list|,
sizeof|sizeof
name|s
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"bind: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|o
argument_list|,
literal|5
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"listen: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|FGOT_SIGNAL
argument_list|()
condition|)
block|{
name|int
name|clen
decl_stmt|;
name|int
name|onew
decl_stmt|;
name|pid_t
name|ipid
decl_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"ftcp_open: Waiting for connections"
argument_list|)
expr_stmt|;
name|clen
operator|=
sizeof|sizeof
name|s
expr_stmt|;
name|onew
operator|=
name|accept
argument_list|(
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|o
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|s
argument_list|,
operator|&
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
name|onew
operator|==
operator|-
literal|1
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"accept: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"ftcp_open: Got connection; forking"
argument_list|)
expr_stmt|;
name|ipid
operator|=
name|isfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ipid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|o
argument_list|)
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|o
operator|=
name|onew
expr_stmt|;
comment|/* Now we fork and let our parent die, so that we become 	     a child of init.  This lets the main server code wait 	     for its child and then continue without accumulating 	     zombie children.  */
name|ipid
operator|=
name|isfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|ipid
operator|<
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ipid
operator|!=
literal|0
condition|)
name|_exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|onew
argument_list|)
expr_stmt|;
comment|/* Now wait for the child.  */
operator|(
name|void
operator|)
name|iswait
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ipid
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* We got a signal.  */
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Avoid compiler warnings.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Close the port.  */
end_comment

begin_function
name|boolean
name|ftcp_close
parameter_list|(
name|qport
parameter_list|,
name|fsuccess
parameter_list|)
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
name|boolean
name|fsuccess
decl_stmt|;
block|{
if|if
condition|(
name|close
argument_list|(
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|o
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"close: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reset the port.  This will be called by a child which was forked    off in ftcp_open, above.  We don't want uucico to continue looping    and giving login prompts, so we pretend that we received a SIGINT    signal.  This should probably be handled more cleanly.  */
end_comment

begin_function
name|boolean
name|ftcp_reset
parameter_list|(
name|qport
parameter_list|)
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
block|{
name|afSignal
index|[
name|INDEXSIG_SIGINT
index|]
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dial out on a TCP port, so to speak: connect to a remote computer.  */
end_comment

begin_function
name|boolean
name|ftcp_dial
parameter_list|(
name|qport
parameter_list|,
name|qsys
parameter_list|,
name|pcproto_params
parameter_list|,
name|pqproto_params
parameter_list|,
name|pireliable
parameter_list|)
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|int
modifier|*
name|pcproto_params
decl_stmt|;
name|struct
name|sproto_param
modifier|*
modifier|*
name|pqproto_params
decl_stmt|;
name|int
modifier|*
name|pireliable
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zhost
decl_stmt|;
name|struct
name|sockaddr_in
name|s
decl_stmt|;
name|struct
name|hostent
modifier|*
name|q
decl_stmt|;
comment|/* There are no dialer protocol parameters, but a TCP connection is      fully reliable.  */
operator|*
name|pcproto_params
operator|=
literal|0
expr_stmt|;
operator|*
name|pqproto_params
operator|=
name|NULL
expr_stmt|;
operator|*
name|pireliable
operator|=
operator|(
name|RELIABLE_SPECIFIED
operator||
name|RELIABLE_ENDTOEND
operator||
name|RELIABLE_RELIABLE
operator||
name|RELIABLE_EIGHT
operator|)
expr_stmt|;
name|zhost
operator|=
name|qsys
operator|->
name|zphone
expr_stmt|;
if|if
condition|(
name|zhost
operator|==
name|NULL
condition|)
name|zhost
operator|=
name|qsys
operator|->
name|zname
expr_stmt|;
comment|/* Cast argument to avoid prototype error on NeXT.  */
name|q
operator|=
name|gethostbyname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"gethostbyname (%s): %s"
argument_list|,
name|zhost
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|s
operator|.
name|sin_family
operator|=
name|q
operator|->
name|h_addrtype
expr_stmt|;
name|s
operator|.
name|sin_port
operator|=
name|itcp_port_number
argument_list|(
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|zport
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|s
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|q
operator|->
name|h_addr
argument_list|,
name|q
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|o
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|s
argument_list|,
sizeof|sizeof
name|s
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"connect: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the baud rate.  */
end_comment

begin_function
name|long
name|itcp_baud
parameter_list|(
name|qport
parameter_list|)
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the port number given a name.  The argument will almost always    be "uucp" so we cache that value.  The return value is always in    network byte order.  This returns -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|itcp_port_number
parameter_list|(
name|zname
parameter_list|)
specifier|const
name|char
modifier|*
name|zname
decl_stmt|;
block|{
name|boolean
name|fuucp
decl_stmt|;
specifier|static
name|int
name|iuucp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|zend
decl_stmt|;
name|struct
name|servent
modifier|*
name|q
decl_stmt|;
name|fuucp
operator|=
name|strcmp
argument_list|(
name|zname
argument_list|,
literal|"uucp"
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|fuucp
operator|&&
name|iuucp
operator|!=
literal|0
condition|)
return|return
name|iuucp
return|;
comment|/* Try it as a number first.  */
name|i
operator|=
name|strtol
argument_list|(
name|zname
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
operator|*
name|zend
operator|==
literal|'\0'
condition|)
return|return
name|htons
argument_list|(
name|i
argument_list|)
return|;
comment|/* Cast arguments to avoid prototype errors on NeXT.  */
name|q
operator|=
name|getservbyname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zname
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
comment|/* We know that the "uucp" service should be 540, even if isn't 	 in /etc/services.  */
if|if
condition|(
name|fuucp
condition|)
block|{
name|iuucp
operator|=
name|htons
argument_list|(
name|IUUCP_PORT
argument_list|)
expr_stmt|;
return|return
name|iuucp
return|;
block|}
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"getservbyname (%s): %s"
argument_list|,
name|zname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fuucp
condition|)
name|iuucp
operator|=
name|q
operator|->
name|s_port
expr_stmt|;
return|return
name|q
operator|->
name|s_port
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TCP */
end_comment

end_unit

