begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* protf.c    The 'f' protocol.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: protf.c,v $    Revision 1.15  1992/03/30  04:49:10  ian    Niels Baggesen: added debugging types abnormal and uucp-proto     Revision 1.14  1992/03/17  01:03:03  ian    Miscellaneous cleanup     Revision 1.13  1992/03/13  22:59:25  ian    Have breceive_char go through freceive_data     Revision 1.12  1992/03/12  19:56:10  ian    Debugging based on types rather than number     Revision 1.11  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.10  1992/01/16  18:16:58  ian    Niels Baggesen: add some debugging messages     Revision 1.9  1992/01/14  04:35:23  ian    Chip Salzenberg: implement this patch correctly     Revision 1.8  1992/01/14  04:21:59  ian    Chip Salzenberg: avoid use before set warning     Revision 1.7  1991/12/31  19:34:19  ian    Added number of bytes to pffile protocol entry point     Revision 1.6  1991/12/20  03:02:01  ian    Oleg Tabarovsky: added statistical messages to 'g' and 'f' protocols     Revision 1.5  1991/12/20  00:01:54  ian    Franc,ois Pinard: don't crash 'f' protocol because of an illegal byte     Revision 1.4  1991/11/16  00:31:01  ian    Increased default 't' and 'f' protocol timeouts     Revision 1.3  1991/11/15  23:32:15  ian    Don't use 1 second timeouts--loses data on System V     Revision 1.2  1991/11/15  21:00:59  ian    Efficiency hacks for 'f' and 't' protocols     Revision 1.1  1991/11/11  04:21:16  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|protf_rcsid
index|[]
init|=
literal|"$Id: protf.c,v 1.15 1992/03/30 04:49:10 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"prot.h"
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* This implementation is based on code by Piet Beertema, CWI,    Amsterdam, Sep 1984.     This code implements the 'f' protocol, which requires a    flow-controlled error-free seven-bit data path.  It does check for    errors, but only at the end of each file transmission, so a noisy    line without error correcting modems will be unusable.     The conversion to seven bit data is done as follows, where b    represents the character to convert:        0<= b<=  037: 0172, b + 0100 (0100 to 0137)     040<= b<= 0171:       b        ( 040 to 0171)    0172<= b<= 0177: 0173, b - 0100 ( 072 to 077)    0200<= b<= 0237: 0174, b - 0100 (0100 to 0137)    0240<= b<= 0371: 0175, b - 0200 ( 040 to 0171)    0372<= b<= 0377: 0176, b - 0300 ( 072 to 077)     This causes all output bytes to be in the range 040 to 0176; these    are the printable ASCII characters.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Internal functions.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|ffprocess_data
name|P
argument_list|(
operator|(
name|boolean
operator|*
name|pfexit
operator|,
name|int
operator|*
name|pcneed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of the buffer we allocate to store outgoing data in.  */
end_comment

begin_define
define|#
directive|define
name|CFBUFSIZE
value|(256)
end_define

begin_comment
comment|/* The timeout to wait for data to arrive before giving up.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cFtimeout
init|=
literal|120
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum number of retries.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cFmaxretries
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The buffer we allocate for outgoing data.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zFbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if we are receiving a file rather than a command.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fFfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The checksum so far.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|iFcheck
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last special byte (0172 to 0176) or 0 if none.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|bFspecial
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of times we have retried this file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cFretries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scmdtab
name|asFproto_params
index|[]
init|=
block|{
block|{
literal|"timeout"
block|,
name|CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cFtimeout
block|,
name|NULL
block|}
block|,
block|{
literal|"retries"
block|,
name|CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cFmaxretries
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Statistics.  */
end_comment

begin_comment
comment|/* The number of data bytes sent in files.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cFsent_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of actual bytes sent in files.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cFsent_bytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of data bytes received in files.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cFrec_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of actual bytes received in files.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cFrec_bytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of file retries when sending.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cFsend_retries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of file retries when receiving.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cFrec_retries
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Start the protocol.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|ffstart
parameter_list|(
name|fmaster
parameter_list|)
name|boolean
name|fmaster
decl_stmt|;
block|{
name|cFsent_data
operator|=
literal|0
expr_stmt|;
name|cFsent_bytes
operator|=
literal|0
expr_stmt|;
name|cFrec_data
operator|=
literal|0
expr_stmt|;
name|cFrec_bytes
operator|=
literal|0
expr_stmt|;
name|cFsend_retries
operator|=
literal|0
expr_stmt|;
name|cFrec_retries
operator|=
literal|0
expr_stmt|;
comment|/* Allow XON/XOFF to work.  */
if|if
condition|(
operator|!
name|fport_set
argument_list|(
name|PORTSETTING_SEVEN
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We sleep to allow the other side to reset the terminal; this is      what Mr. Beertema's code does.  */
name|usysdep_sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Shutdown the protocol.  */
end_comment

begin_function
name|boolean
name|ffshutdown
parameter_list|()
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zFbuf
argument_list|)
expr_stmt|;
name|zFbuf
operator|=
name|NULL
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Protocol 'f': sent %ld bytes for %ld, received %ld bytes for %ld"
argument_list|,
name|cFsent_bytes
argument_list|,
name|cFsent_data
argument_list|,
name|cFrec_bytes
argument_list|,
name|cFrec_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cFsend_retries
operator|!=
literal|0
operator|||
name|cFrec_retries
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Protocol 'f' file retries: %ld sending, %ld receiving"
argument_list|,
name|cFsend_retries
argument_list|,
name|cFrec_retries
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a command string.  We just send the string followed by a carriage    return.  */
end_comment

begin_function
name|boolean
name|ffsendcmd
parameter_list|(
name|z
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
block|{
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|zalc
decl_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_UUCP_PROTO
argument_list|,
literal|"ffsendcmd: Sending command \"%s\""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|zalc
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|clen
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zalc
argument_list|,
literal|"%s\r"
argument_list|,
name|z
argument_list|)
expr_stmt|;
return|return
name|fsend_data
argument_list|(
name|zalc
argument_list|,
name|clen
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get space to be filled with data.  We allocate the space from the    heap.  */
end_comment

begin_function
name|char
modifier|*
name|zfgetspace
parameter_list|(
name|pclen
parameter_list|)
name|int
modifier|*
name|pclen
decl_stmt|;
block|{
operator|*
name|pclen
operator|=
name|CFBUFSIZE
expr_stmt|;
if|if
condition|(
name|zFbuf
operator|==
name|NULL
condition|)
name|zFbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|CFBUFSIZE
argument_list|)
expr_stmt|;
return|return
name|zFbuf
return|;
block|}
end_function

begin_comment
comment|/* Send out a data packet.  We have to encode the data into seven bits    and accumulate a checksum.  */
end_comment

begin_function
name|boolean
name|ffsenddata
parameter_list|(
name|zdata
parameter_list|,
name|cdata
parameter_list|)
name|char
modifier|*
name|zdata
decl_stmt|;
name|int
name|cdata
decl_stmt|;
block|{
name|char
name|ab
index|[
name|CFBUFSIZE
operator|*
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|ze
decl_stmt|;
specifier|register
name|unsigned
name|int
name|itmpchk
decl_stmt|;
name|cFsent_data
operator|+=
name|cdata
expr_stmt|;
name|ze
operator|=
name|ab
expr_stmt|;
name|itmpchk
operator|=
name|iFcheck
expr_stmt|;
while|while
condition|(
name|cdata
operator|--
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|b
decl_stmt|;
comment|/* Rotate the checksum left.  */
if|if
condition|(
operator|(
name|itmpchk
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
name|itmpchk
operator|<<=
literal|1
expr_stmt|;
else|else
block|{
name|itmpchk
operator|<<=
literal|1
expr_stmt|;
operator|++
name|itmpchk
expr_stmt|;
block|}
comment|/* Add the next byte into the checksum.  */
name|b
operator|=
operator|*
name|zdata
operator|++
operator|&
literal|0xff
expr_stmt|;
name|itmpchk
operator|+=
name|b
expr_stmt|;
comment|/* Encode the byte.  */
if|if
condition|(
name|b
operator|<=
literal|0177
condition|)
block|{
if|if
condition|(
name|b
operator|<=
literal|037
condition|)
block|{
operator|*
name|ze
operator|++
operator|=
literal|'\172'
expr_stmt|;
operator|*
name|ze
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|b
operator|+
literal|0100
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|<=
literal|0171
condition|)
operator|*
name|ze
operator|++
operator|=
operator|(
name|char
operator|)
name|b
expr_stmt|;
else|else
block|{
operator|*
name|ze
operator|++
operator|=
literal|'\173'
expr_stmt|;
operator|*
name|ze
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|b
operator|-
literal|0100
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|b
operator|<=
literal|0237
condition|)
block|{
operator|*
name|ze
operator|++
operator|=
literal|'\174'
expr_stmt|;
operator|*
name|ze
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|b
operator|-
literal|0100
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|<=
literal|0371
condition|)
block|{
operator|*
name|ze
operator|++
operator|=
literal|'\175'
expr_stmt|;
operator|*
name|ze
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|b
operator|-
literal|0200
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ze
operator|++
operator|=
literal|'\176'
expr_stmt|;
operator|*
name|ze
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|b
operator|-
literal|0300
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|iFcheck
operator|=
name|itmpchk
expr_stmt|;
name|cFsent_bytes
operator|+=
name|ze
operator|-
name|ab
expr_stmt|;
comment|/* Passing FALSE tells fsend_data not to bother looking for incoming      information, since we really don't expect any.  */
return|return
name|fsend_data
argument_list|(
name|ab
argument_list|,
name|ze
operator|-
name|ab
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process any data in the receive buffer.  */
end_comment

begin_function
name|boolean
name|ffprocess
parameter_list|(
name|pfexit
parameter_list|)
name|boolean
modifier|*
name|pfexit
decl_stmt|;
block|{
return|return
name|ffprocess_data
argument_list|(
name|pfexit
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process data and return the amount of data we are looking for in    *pcneed.  The 'f' protocol doesn't really reveal this, but when    transferring file we know that we need at least seven characters    for the checksum.  */
end_comment

begin_function
specifier|static
name|boolean
name|ffprocess_data
parameter_list|(
name|pfexit
parameter_list|,
name|pcneed
parameter_list|)
name|boolean
modifier|*
name|pfexit
decl_stmt|;
name|int
modifier|*
name|pcneed
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|int
name|itmpchk
decl_stmt|;
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
operator|*
name|pcneed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|fFfile
condition|)
block|{
comment|/* A command continues until a '\r' character, which we turn 	 into '\0' before calling fgot_data.  */
while|while
condition|(
name|iPrecstart
operator|!=
name|iPrecend
condition|)
block|{
for|for
control|(
name|i
operator|=
name|iPrecstart
init|;
name|i
operator|<
name|CRECBUFLEN
operator|&&
name|i
operator|!=
name|iPrecend
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|abPrecbuf
index|[
name|i
index|]
operator|==
literal|'\r'
condition|)
block|{
name|int
name|istart
decl_stmt|;
name|abPrecbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|istart
operator|=
name|iPrecstart
expr_stmt|;
name|iPrecstart
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
return|return
name|fgot_data
argument_list|(
name|abPrecbuf
operator|+
name|istart
argument_list|,
name|i
operator|-
name|istart
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pfexit
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|abPrecbuf
operator|+
name|iPrecstart
argument_list|,
name|i
operator|-
name|iPrecstart
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|iPrecstart
operator|=
name|i
operator|%
name|CRECBUFLEN
expr_stmt|;
block|}
operator|*
name|pfexit
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Here the data is destined for a file, and we must decode it.  */
name|itmpchk
operator|=
name|iFcheck
expr_stmt|;
while|while
condition|(
name|iPrecstart
operator|!=
name|iPrecend
condition|)
block|{
name|char
modifier|*
name|zstart
decl_stmt|,
modifier|*
name|zto
decl_stmt|,
modifier|*
name|zfrom
decl_stmt|;
name|int
name|c
decl_stmt|;
name|zto
operator|=
name|zfrom
operator|=
name|zstart
operator|=
name|abPrecbuf
operator|+
name|iPrecstart
expr_stmt|;
name|c
operator|=
name|iPrecend
operator|-
name|iPrecstart
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|c
operator|=
name|CRECBUFLEN
operator|-
name|iPrecstart
expr_stmt|;
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
block|{
name|int
name|b
decl_stmt|;
name|b
operator|=
operator|*
name|zfrom
operator|++
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|b
operator|<
literal|040
operator|||
name|b
operator|>
literal|0176
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal byte %d"
argument_list|,
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Characters>= 0172 are always special characters.  The 	     only legal pair of consecutive special characters 	     are 0176 0176 which immediately precede the four 	     digit checksum.  */
if|if
condition|(
name|b
operator|>=
literal|0172
condition|)
block|{
if|if
condition|(
name|bFspecial
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bFspecial
operator|!=
literal|0176
operator|||
name|b
operator|!=
literal|0176
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal bytes %d %d"
argument_list|,
name|bFspecial
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|bFspecial
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Pass any initial data.  */
if|if
condition|(
name|zto
operator|!=
name|zstart
condition|)
block|{
comment|/* Don't count the checksum in the received bytes.  */
name|cFrec_bytes
operator|+=
name|zfrom
operator|-
name|zstart
operator|-
literal|2
expr_stmt|;
name|cFrec_data
operator|+=
name|zto
operator|-
name|zstart
expr_stmt|;
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|zstart
argument_list|,
name|zto
operator|-
name|zstart
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* The next characters we want to read are the 		     checksum, so skip the second 0176.  */
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|zfrom
operator|-
name|zstart
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
name|iFcheck
operator|=
name|itmpchk
expr_stmt|;
comment|/* Tell fgot_data that we've read the entire file by 		     passing 0 length data.  This will set *pfexit to 		     TRUE and call fffile to verify the checksum.  */
return|return
name|fgot_data
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
return|;
block|}
comment|/* Here we have encountered a special character that 		 does not follow another special character.  */
name|bFspecial
operator|=
operator|(
name|char
operator|)
name|b
expr_stmt|;
block|}
else|else
block|{
name|int
name|bnext
decl_stmt|;
comment|/* Here we have encountered a nonspecial character.  */
switch|switch
condition|(
name|bFspecial
condition|)
block|{
default|default:
name|bnext
operator|=
name|b
expr_stmt|;
break|break;
case|case
literal|0172
case|:
name|bnext
operator|=
name|b
operator|-
literal|0100
expr_stmt|;
break|break;
case|case
literal|0173
case|:
case|case
literal|0174
case|:
name|bnext
operator|=
name|b
operator|+
literal|0100
expr_stmt|;
break|break;
case|case
literal|0175
case|:
name|bnext
operator|=
name|b
operator|+
literal|0200
expr_stmt|;
break|break;
case|case
literal|0176
case|:
name|bnext
operator|=
name|b
operator|+
literal|0300
expr_stmt|;
break|break;
block|}
operator|*
name|zto
operator|++
operator|=
operator|(
name|char
operator|)
name|bnext
expr_stmt|;
name|bFspecial
operator|=
literal|0
expr_stmt|;
comment|/* Rotate the checksum left.  */
if|if
condition|(
operator|(
name|itmpchk
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
name|itmpchk
operator|<<=
literal|1
expr_stmt|;
else|else
block|{
name|itmpchk
operator|<<=
literal|1
expr_stmt|;
operator|++
name|itmpchk
expr_stmt|;
block|}
comment|/* Add the next byte into the checksum.  */
name|itmpchk
operator|+=
name|bnext
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zto
operator|!=
name|zstart
condition|)
block|{
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"ffprocess: Calling fgot_data with %d bytes"
argument_list|,
name|zto
operator|-
name|zstart
argument_list|)
expr_stmt|;
name|cFrec_data
operator|+=
name|zto
operator|-
name|zstart
expr_stmt|;
if|if
condition|(
operator|!
name|fgot_data
argument_list|(
name|zstart
argument_list|,
name|zto
operator|-
name|zstart
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|pfexit
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|cFrec_bytes
operator|+=
name|zfrom
operator|-
name|zstart
expr_stmt|;
name|iPrecstart
operator|=
operator|(
name|iPrecstart
operator|+
name|zfrom
operator|-
name|zstart
operator|)
operator|%
name|CRECBUFLEN
expr_stmt|;
block|}
name|iFcheck
operator|=
name|itmpchk
expr_stmt|;
if|if
condition|(
name|pcneed
operator|!=
name|NULL
condition|)
block|{
comment|/* At this point we may have seen the first 0176 in the checksum 	 but not the second.  The checksum is at least seven 	 characters long (0176 0176 a b c d \r).  This won't help 	 much, but reading seven characters is a lot better than 	 reading two, which is what I saw in a 2400 baud log file.  */
if|if
condition|(
name|bFspecial
operator|==
literal|0176
condition|)
operator|*
name|pcneed
operator|=
literal|6
expr_stmt|;
else|else
operator|*
name|pcneed
operator|=
literal|7
expr_stmt|;
block|}
operator|*
name|pfexit
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for data to come in and process it until we've finished a    command or a file.  */
end_comment

begin_function
name|boolean
name|ffwait
parameter_list|()
block|{
while|while
condition|(
name|TRUE
condition|)
block|{
name|boolean
name|fexit
decl_stmt|;
name|int
name|cneed
decl_stmt|,
name|crec
decl_stmt|;
if|if
condition|(
operator|!
name|ffprocess_data
argument_list|(
operator|&
name|fexit
argument_list|,
operator|&
name|cneed
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fexit
condition|)
return|return
name|TRUE
return|;
comment|/* We only ask for one character at a time.  This could wind up 	 being quite inefficient, since we might only get one 	 character back from each read.  We really want to do 	 something like get all available characters, then sleep for 	 half a second and get all available characters again, and 	 keep this up until we don't get anything after sleeping.  */
if|if
condition|(
operator|!
name|freceive_data
argument_list|(
name|cneed
argument_list|,
operator|&
name|crec
argument_list|,
name|cFtimeout
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|crec
operator|==
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timed out waiting for data"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* File level operations.  Reset the checksums when starting to send    or receive a file, and output the checksum when we've finished    sending a file.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|fffile
parameter_list|(
name|fstart
parameter_list|,
name|fsend
parameter_list|,
name|pfredo
parameter_list|,
name|cbytes
parameter_list|)
name|boolean
name|fstart
decl_stmt|;
name|boolean
name|fsend
decl_stmt|;
name|boolean
modifier|*
name|pfredo
decl_stmt|;
name|long
name|cbytes
decl_stmt|;
block|{
if|if
condition|(
name|fstart
condition|)
block|{
name|iFcheck
operator|=
literal|0xffff
expr_stmt|;
name|cFretries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fsend
condition|)
block|{
name|bFspecial
operator|=
literal|0
expr_stmt|;
name|fFfile
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
operator|*
name|pfredo
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fsend
condition|)
block|{
name|char
name|ab
index|[
literal|8
index|]
decl_stmt|;
comment|/* Send the final checksum.  */
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"\176\176%04x\r"
argument_list|,
name|iFcheck
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsend_data
argument_list|(
name|ab
argument_list|,
literal|7
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Now look for the acknowledgement.  */
name|z
operator|=
name|zgetcmd
argument_list|()
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* An R means to retry sending the file.  */
if|if
condition|(
operator|*
name|z
operator|==
literal|'R'
condition|)
block|{
operator|++
name|cFretries
expr_stmt|;
if|if
condition|(
name|cFretries
operator|>
name|cFmaxretries
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Too many retries"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|pfredo
operator|=
name|TRUE
expr_stmt|;
name|iFcheck
operator|=
literal|0xffff
expr_stmt|;
operator|++
name|cFsend_retries
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|'G'
condition|)
return|return
name|TRUE
return|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PROTO
argument_list|,
literal|"fffile: Got \"%s\""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"File send failed"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|unsigned
name|int
name|icheck
decl_stmt|;
comment|/* We next expect to receive a command.  */
name|fFfile
operator|=
name|FALSE
expr_stmt|;
comment|/* Get the checksum.  */
name|z
operator|=
name|zgetcmd
argument_list|()
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|strlen
argument_list|(
name|z
argument_list|)
operator|!=
literal|4
operator|||
operator|!
name|isxdigit
argument_list|(
name|z
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|isxdigit
argument_list|(
name|z
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isxdigit
argument_list|(
name|z
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|isxdigit
argument_list|(
name|z
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad checksum format"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|icheck
operator|=
name|strtol
argument_list|(
name|z
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|icheck
operator|!=
operator|(
name|iFcheck
operator|&
literal|0xffff
operator|)
condition|)
block|{
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_PROTO
operator||
name|DEBUG_ABNORMAL
argument_list|,
literal|"Checksum failed; calculated 0x%x, got 0x%x"
argument_list|,
name|iFcheck
operator|&
literal|0xffff
argument_list|,
name|icheck
argument_list|)
expr_stmt|;
operator|++
name|cFretries
expr_stmt|;
if|if
condition|(
name|cFretries
operator|>
name|cFmaxretries
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Too many retries"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ffsendcmd
argument_list|(
literal|"Q"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|pfredo
operator|=
name|TRUE
expr_stmt|;
name|iFcheck
operator|=
literal|0xffff
expr_stmt|;
name|bFspecial
operator|=
literal|0
expr_stmt|;
name|fFfile
operator|=
name|TRUE
expr_stmt|;
operator|++
name|cFrec_retries
expr_stmt|;
comment|/* Send an R to tell the other side to resend the file.  */
return|return
name|ffsendcmd
argument_list|(
literal|"R"
argument_list|)
return|;
block|}
comment|/* Send a G to tell the other side the file was received 	     correctly.  */
return|return
name|ffsendcmd
argument_list|(
literal|"G"
argument_list|)
return|;
block|}
block|}
block|}
end_function

end_unit

