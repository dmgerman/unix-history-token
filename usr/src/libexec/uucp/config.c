begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* config.c    Read the configuration file.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: config.c,v $    Revision 1.29  1992/03/28  22:06:38  ian    Michael I Bushnell: renamed enum tstatus to avoid header file conflict     Revision 1.28  1992/03/28  21:47:55  ian    David J. MacKenzie: allow backslash to quote newline in config files     Revision 1.27  1992/03/28  04:26:12  ian    David J. MacKenzie: cMaxuuxqts is independent of HAVE_TAYLOR_CONFIG     Revision 1.26  1992/03/18  23:12:37  ian    Handle CMDTABTYPE_FULLSTRING correctly if there are no arguments     Revision 1.25  1992/03/17  01:03:03  ian    Miscellaneous cleanup     Revision 1.24  1992/03/12  19:54:43  ian    Debugging based on types rather than number     Revision 1.23  1992/03/11  22:06:37  ian    Marty Shannon: added max-uuxqts command     Revision 1.22  1992/03/09  05:08:16  ian    Added status for wrong time to call, not used if system can't be called     Revision 1.21  1992/03/04  21:39:04  ian    Local variables in igradecmp have to be integers     Revision 1.20  1992/03/03  06:06:48  ian    T. William Wells: don't complain about missing configuration files     Revision 1.19  1992/02/29  01:06:59  ian    Chip Salzenberg: recheck file permissions before sending     Revision 1.18  1992/02/24  04:58:47  ian    Only permit files to be received into directories that are world-writeable     Revision 1.17  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.16  1992/01/15  07:06:29  ian    Set configuration directory in Makefile rather than sysdep.h     Revision 1.15  1992/01/14  04:04:17  ian    Chip Salzenberg: strcmp is a macro on AIX     Revision 1.14  1991/12/29  04:04:18  ian    Added a bunch of extern definitions     Revision 1.13  1991/12/29  01:54:46  ian    Terry Gardner: allow a # character to be quoted in a configuration file     Revision 1.12  1991/12/22  20:57:57  ian    Added externs for strcasecmp or strncasecmp     Revision 1.11  1991/12/18  03:54:14  ian    Made error messages to terminal appear more normal     Revision 1.10  1991/12/15  03:42:33  ian    Added tprocess_chat_cmd for all chat commands, and added CMDTABTYPE_PREFIX     Revision 1.9  1991/12/13  22:43:06  ian    Don't continually allocate and free the list of arguments     Revision 1.8  1991/12/09  18:39:46  ian    Richard Todd: the pushed back line is specific to a particular multi file     Revision 1.7  1991/12/09  16:59:48  ian    Richard Todd: don't warn if special "#" command is unrecognized     Revision 1.6  1991/12/07  18:05:20  ian    Franc,ois Pinard: no limit to number of arguments     Revision 1.5  1991/12/03  02:38:26  ian    Don't treat numbers with leading zeroes as octal     Revision 1.4  1991/12/01  19:35:38  ian    David Nugent: read V2 and BNU files by default even with TAYLOR_CONFIG     Revision 1.3  1991/11/26  02:04:49  ian    Bob Denny: add explicit extern for strcmp and strcasecmp     Revision 1.2  1991/09/19  02:38:21  ian    Chip Salzenberg: V2 and BNU dialcodes files are relative to CONFIGLIB     Revision 1.1  1991/09/10  19:38:34  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|config_rcsid
index|[]
init|=
literal|"$Id: config.c,v 1.29 1992/03/28 22:06:38 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_comment
comment|/* Some systems make strcmp a macro, which screws us up since we want    to declare it since we will take its address later.  */
end_comment

begin_undef
undef|#
directive|undef
name|strcmp
end_undef

begin_undef
undef|#
directive|undef
name|strncmp
end_undef

begin_comment
comment|/* External functions.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|strcmp
argument_list|()
decl_stmt|,
name|strncmp
argument_list|()
decl_stmt|,
name|strcasecmp
argument_list|()
decl_stmt|,
name|strncasecmp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|fclose
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|umulti_pushback
name|P
argument_list|(
operator|(
expr|struct
name|smulti_file
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Status strings.  These must match enum tstatus_type.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|azStatus
index|[]
init|=
block|{
literal|"Conversation complete"
block|,
literal|"Port unavailable"
block|,
literal|"Dial failed"
block|,
literal|"Login failed"
block|,
literal|"Handshake failed"
block|,
literal|"Call failed"
block|,
literal|"Talking"
block|,
literal|"Wrong time to call"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local node name.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zLocalname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Spool directory.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zSpooldir
init|=
name|SPOOLDIR
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|DEBUG
operator|>
literal|1
end_if

begin_comment
comment|/* Debugging level.  */
end_comment

begin_decl_stmt
name|int
name|iDebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging file name.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zDebugfile
init|=
name|DEBUGFILE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Public directory.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zPubdir
init|=
name|PUBDIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Log file name.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zLogfile
init|=
name|LOGFILE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Statistics file name.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zStatfile
init|=
name|STATFILE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dialcode file names.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zDialcodefile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum number of uuxqt processes which may be running at one    time.  If this is zero, there is no limit.  */
end_comment

begin_decl_stmt
name|int
name|cMaxuuxqts
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_if
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
end_if

begin_comment
comment|/* System file names.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zSysfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Port file names.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zPortfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dialer file names.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zDialfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Call out login and password file names.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zCallfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Call in login and password file names.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zPwdfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command table used to parse the configuration file.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|tcmdtabret
name|tcadd
name|P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
specifier|const
name|char
operator|*
name|zerr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|scmdtab
name|asCmds
index|[]
init|=
block|{
comment|/* System name.  */
block|{
literal|"nodename"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zLocalname
block|,
name|NULL
block|}
block|,
block|{
literal|"hostname"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zLocalname
block|,
name|NULL
block|}
block|,
block|{
literal|"uuname"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zLocalname
block|,
name|NULL
block|}
block|,
comment|/* Spool directory.  */
block|{
literal|"spool"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zSpooldir
block|,
name|NULL
block|}
block|,
comment|/* System information files.  */
block|{
literal|"sysfile"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
operator|(
name|pointer
operator|)
operator|&
name|zSysfile
block|,
name|tcadd
block|}
block|,
comment|/* Port files.  */
block|{
literal|"portfile"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
operator|(
name|pointer
operator|)
operator|&
name|zPortfile
block|,
name|tcadd
block|}
block|,
comment|/* Dial files.  */
block|{
literal|"dialfile"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
operator|(
name|pointer
operator|)
operator|&
name|zDialfile
block|,
name|tcadd
block|}
block|,
comment|/* Dialcode files.  */
block|{
literal|"dialcodefile"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
operator|(
name|pointer
operator|)
operator|&
name|zDialcodefile
block|,
name|tcadd
block|}
block|,
comment|/* Public directory.  */
block|{
literal|"pubdir"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zPubdir
block|,
name|NULL
block|}
block|,
comment|/* Call out login name and password files.  */
block|{
literal|"callfile"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
operator|(
name|pointer
operator|)
operator|&
name|zCallfile
block|,
name|tcadd
block|}
block|,
comment|/* Call in login name and password files.  */
block|{
literal|"passwdfile"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
operator|(
name|pointer
operator|)
operator|&
name|zPwdfile
block|,
name|tcadd
block|}
block|,
comment|/* Log file.  */
block|{
literal|"logfile"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zLogfile
block|,
name|NULL
block|}
block|,
comment|/* Statistics file.  */
block|{
literal|"statfile"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zStatfile
block|,
name|NULL
block|}
block|,
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* Debugging file.  */
block|{
literal|"debugfile"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zDebugfile
block|,
name|NULL
block|}
block|,
comment|/* Debugging level.  */
block|{
literal|"debug"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
operator|(
name|pointer
operator|)
operator|&
name|iDebug
block|,
name|tidebug_parse
block|}
block|,
endif|#
directive|endif
comment|/* Command for unknown system.  */
block|{
literal|"unknown"
block|,
name|CMDTABTYPE_FN
block|,
name|NULL
block|,
name|tiunknown
block|}
block|,
comment|/* Maximum number of uuxqt processes.  */
block|{
literal|"max-uuxqts"
block|,
name|CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|cMaxuuxqts
block|,
name|NULL
block|}
block|,
if|#
directive|if
name|HAVE_V2_CONFIG
block|{
literal|"v2-files"
block|,
name|CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|fV2
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|HAVE_BNU_CONFIG
block|{
literal|"bnu-files"
block|,
name|CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|fBnu
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
comment|/* End marker.  */
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add strings to a string variable, separating with spaces.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tcadd
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|uadd_string
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|pvar
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TAYLOR_CONFIG */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Process commands from a stdio file according to a command table.    The character '#' introduces a comment.  Exactly one of e and    qmulti must be NULL.  If we get the first line of a multi file, we    attempt to process the command "#"; this command will not arise    from a normal command file, and lets the caller take special action    at the start of a new file.  If we are reading with zmulti_gets, we    ignore the zerr argument and instead use the name of the file.  */
end_comment

begin_function
name|void
name|uprocesscmds
parameter_list|(
name|e
parameter_list|,
name|qmulti
parameter_list|,
name|qcmds
parameter_list|,
name|zerr
parameter_list|,
name|iflags
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
name|struct
name|smulti_file
modifier|*
name|qmulti
decl_stmt|;
specifier|const
name|struct
name|scmdtab
modifier|*
name|qcmds
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|int
name|iflags
decl_stmt|;
block|{
while|while
condition|(
name|TRUE
condition|)
block|{
specifier|static
name|char
modifier|*
modifier|*
name|pzargs
decl_stmt|;
specifier|static
name|int
name|calloc_args
decl_stmt|;
name|char
modifier|*
name|zget
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|int
name|cargs
decl_stmt|;
name|enum
name|tcmdtabret
name|t
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzhold_args
decl_stmt|;
name|int
name|chold_alloc_args
decl_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
name|zget
operator|=
name|zfgets
argument_list|(
name|e
argument_list|,
operator|(
name|iflags
operator|&
name|CMDFLAG_BACKSLASH
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|boolean
name|ffirst
decl_stmt|;
name|zget
operator|=
name|zmulti_gets
argument_list|(
name|qmulti
argument_list|,
operator|&
name|ffirst
argument_list|,
operator|&
name|zerr
argument_list|,
operator|(
name|iflags
operator|&
name|CMDFLAG_BACKSLASH
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zget
operator|!=
name|NULL
operator|&&
name|ffirst
condition|)
block|{
name|char
modifier|*
name|zargs
decl_stmt|;
name|zargs
operator|=
operator|(
name|char
operator|*
operator|)
literal|"#"
expr_stmt|;
name|t
operator|=
name|tprocess_one_cmd
argument_list|(
literal|1
argument_list|,
operator|&
name|zargs
argument_list|,
name|qcmds
argument_list|,
name|zerr
argument_list|,
name|iflags
operator|&
operator|~
name|CMDFLAG_WARNUNRECOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|CMDTABRET_EXIT
operator|||
name|t
operator|==
name|CMDTABRET_FREE_AND_EXIT
condition|)
block|{
name|umulti_pushback
argument_list|(
name|qmulti
argument_list|,
name|zget
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|zget
operator|==
name|NULL
condition|)
return|return;
comment|/* Any # character not preceeded by a backslash starts a 	 comment.  */
name|z
operator|=
name|zget
expr_stmt|;
while|while
condition|(
operator|(
name|z
operator|=
name|strchr
argument_list|(
name|z
argument_list|,
literal|'#'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|z
operator|==
name|zget
operator|||
operator|*
operator|(
name|z
operator|-
literal|1
operator|)
operator|!=
literal|'\\'
condition|)
block|{
operator|*
name|z
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
comment|/* Remove the backslash.  */
name|xmemmove
argument_list|(
name|z
operator|-
literal|1
argument_list|,
name|z
argument_list|,
name|strlen
argument_list|(
name|z
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|z
operator|=
name|zget
expr_stmt|;
name|cargs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
while|while
condition|(
operator|*
name|z
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|cargs
operator|>=
name|calloc_args
condition|)
block|{
name|calloc_args
operator|+=
literal|10
expr_stmt|;
name|pzargs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pzargs
argument_list|,
name|calloc_args
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pzargs
index|[
name|cargs
index|]
operator|=
name|z
expr_stmt|;
operator|++
name|cargs
expr_stmt|;
while|while
condition|(
operator|*
name|z
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|==
literal|'\0'
condition|)
break|break;
operator|*
name|z
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|cargs
operator|<=
literal|0
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zget
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Save off the static variables to allow this function to 	 be called recursively.  */
name|pzhold_args
operator|=
name|pzargs
expr_stmt|;
name|chold_alloc_args
operator|=
name|calloc_args
expr_stmt|;
name|pzargs
operator|=
name|NULL
expr_stmt|;
name|calloc_args
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|tprocess_one_cmd
argument_list|(
name|cargs
argument_list|,
name|pzhold_args
argument_list|,
name|qcmds
argument_list|,
name|zerr
argument_list|,
name|iflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzargs
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|pzargs
argument_list|)
expr_stmt|;
name|pzargs
operator|=
name|pzhold_args
expr_stmt|;
name|calloc_args
operator|=
name|chold_alloc_args
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|CMDTABRET_FREE
operator|||
name|t
operator|==
name|CMDTABRET_FREE_AND_EXIT
condition|)
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zget
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|CMDTABRET_EXIT
operator|||
name|t
operator|==
name|CMDTABRET_FREE_AND_EXIT
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Process a single command.  */
end_comment

begin_function
name|enum
name|tcmdtabret
name|tprocess_one_cmd
parameter_list|(
name|cargs
parameter_list|,
name|azargs
parameter_list|,
name|qcmds
parameter_list|,
name|zerr
parameter_list|,
name|iflags
parameter_list|)
name|int
name|cargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|azargs
decl_stmt|;
specifier|const
name|struct
name|scmdtab
modifier|*
name|qcmds
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|int
name|iflags
decl_stmt|;
block|{
specifier|const
name|struct
name|scmdtab
modifier|*
name|q
decl_stmt|;
name|int
argument_list|(
argument|*pfcmp
argument_list|)
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iflags
operator|&
name|CMDFLAG_CASESIGNIFICANT
operator|)
operator|!=
literal|0
condition|)
name|pfcmp
operator|=
name|strcmp
expr_stmt|;
else|else
name|pfcmp
operator|=
name|strcasecmp
expr_stmt|;
for|for
control|(
name|q
operator|=
name|qcmds
init|;
name|q
operator|->
name|zcmd
operator|!=
name|NULL
condition|;
name|q
operator|++
control|)
block|{
name|int
name|itype
decl_stmt|;
name|int
name|callowed
decl_stmt|;
name|itype
operator|=
name|TTYPE_CMDTABTYPE
argument_list|(
name|q
operator|->
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|itype
operator|!=
name|CMDTABTYPE_PREFIX
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|pfcmp
call|)
argument_list|(
name|q
operator|->
name|zcmd
argument_list|,
name|azargs
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
name|int
name|clen
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|q
operator|->
name|zcmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iflags
operator|&
name|CMDFLAG_CASESIGNIFICANT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|q
operator|->
name|zcmd
argument_list|,
name|azargs
index|[
literal|0
index|]
argument_list|,
name|clen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|q
operator|->
name|zcmd
argument_list|,
name|azargs
index|[
literal|0
index|]
argument_list|,
name|clen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
block|}
name|callowed
operator|=
name|CARGS_CMDTABTYPE
argument_list|(
name|q
operator|->
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|callowed
operator|!=
literal|0
operator|&&
name|callowed
operator|!=
name|cargs
condition|)
block|{
if|if
condition|(
name|zerr
operator|!=
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: Wrong number of arguments"
argument_list|,
name|zerr
argument_list|,
name|q
operator|->
name|zcmd
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
elseif|else
if|if
condition|(
name|itype
operator|==
name|TTYPE_CMDTABTYPE
argument_list|(
name|CMDTABTYPE_STRING
argument_list|)
condition|)
block|{
if|if
condition|(
name|cargs
operator|!=
literal|1
operator|&&
name|cargs
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|zerr
operator|!=
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: Wrong number of arguments"
argument_list|,
name|zerr
argument_list|,
name|q
operator|->
name|zcmd
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
if|if
condition|(
name|cargs
operator|==
literal|1
condition|)
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|q
operator|->
name|pvar
operator|=
literal|""
expr_stmt|;
else|else
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|q
operator|->
name|pvar
operator|=
name|azargs
index|[
literal|1
index|]
expr_stmt|;
return|return
name|CMDTABRET_CONTINUE
return|;
block|}
elseif|else
if|if
condition|(
name|itype
operator|==
name|TTYPE_CMDTABTYPE
argument_list|(
name|CMDTABTYPE_INT
argument_list|)
operator|||
name|itype
operator|==
name|TTYPE_CMDTABTYPE
argument_list|(
name|CMDTABTYPE_LONG
argument_list|)
condition|)
block|{
name|long
name|i
decl_stmt|;
name|char
modifier|*
name|zend
decl_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|azargs
index|[
literal|1
index|]
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zend
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zerr
operator|!=
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: Bad number"
argument_list|,
name|zerr
argument_list|,
name|q
operator|->
name|zcmd
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
if|if
condition|(
name|itype
operator|==
name|TTYPE_CMDTABTYPE
argument_list|(
name|CMDTABTYPE_INT
argument_list|)
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|q
operator|->
name|pvar
operator|=
operator|(
name|int
operator|)
name|i
expr_stmt|;
else|else
operator|*
operator|(
name|long
operator|*
operator|)
name|q
operator|->
name|pvar
operator|=
name|i
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
elseif|else
if|if
condition|(
name|itype
operator|==
name|TTYPE_CMDTABTYPE
argument_list|(
name|CMDTABTYPE_BOOLEAN
argument_list|)
condition|)
block|{
name|char
name|b
decl_stmt|;
name|b
operator|=
name|azargs
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|'y'
operator|||
name|b
operator|==
literal|'Y'
operator|||
name|b
operator|==
literal|'t'
operator|||
name|b
operator|==
literal|'T'
condition|)
operator|*
operator|(
name|boolean
operator|*
operator|)
name|q
operator|->
name|pvar
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
literal|'n'
operator|||
name|b
operator|==
literal|'N'
operator|||
name|b
operator|==
literal|'f'
operator|||
name|b
operator|==
literal|'F'
condition|)
operator|*
operator|(
name|boolean
operator|*
operator|)
name|q
operator|->
name|pvar
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|zerr
operator|!=
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: Bad boolean"
argument_list|,
name|zerr
argument_list|,
name|q
operator|->
name|zcmd
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
elseif|else
if|if
condition|(
name|itype
operator|==
name|TTYPE_CMDTABTYPE
argument_list|(
name|CMDTABTYPE_FULLSTRING
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|clen
decl_stmt|;
name|char
modifier|*
name|zset
decl_stmt|;
comment|/* Use all the arguments separated by a ' ' 	     character.  */
name|clen
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|cargs
condition|;
name|i
operator|++
control|)
name|clen
operator|+=
name|strlen
argument_list|(
name|azargs
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|zset
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|clen
argument_list|)
expr_stmt|;
operator|*
name|zset
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|cargs
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|zset
argument_list|,
name|azargs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|zset
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|cargs
condition|)
name|strcat
argument_list|(
name|zset
argument_list|,
name|azargs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|q
operator|->
name|pvar
operator|=
name|zset
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
elseif|else
if|if
condition|(
name|itype
operator|==
name|TTYPE_CMDTABTYPE
argument_list|(
name|CMDTABTYPE_FN
argument_list|)
operator|||
name|itype
operator|==
name|TTYPE_CMDTABTYPE
argument_list|(
name|CMDTABTYPE_PREFIX
argument_list|)
condition|)
return|return
call|(
modifier|*
name|q
operator|->
name|ptfn
call|)
argument_list|(
name|cargs
argument_list|,
name|azargs
argument_list|,
name|q
operator|->
name|pvar
argument_list|,
name|zerr
argument_list|)
return|;
else|else
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|0
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"tprocess_one_cmd: Can't happen (0x%x)"
argument_list|,
name|itype
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CMDTABRET_FREE
return|;
block|}
block|}
if|if
condition|(
operator|(
name|iflags
operator|&
name|CMDFLAG_WARNUNRECOG
operator|)
operator|!=
literal|0
operator|&&
name|zerr
operator|!=
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: Unrecognized command %s"
argument_list|,
name|zerr
argument_list|,
name|azargs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read the configuration file.  If we can't open the configuration file,    and we're trying to read the default, don't report an error.  This    permits people to not have a configuration file at all if they are    satisfied with the compiled in defaults.  */
end_comment

begin_function
name|void
name|uread_config
parameter_list|(
name|zname
parameter_list|)
specifier|const
name|char
modifier|*
name|zname
decl_stmt|;
block|{
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
name|FILE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|zdefault
decl_stmt|;
name|zdefault
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
name|NEWCONFIGLIB
operator|+
sizeof|sizeof
name|CONFIGFILE
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zdefault
argument_list|,
literal|"%s%s"
argument_list|,
name|NEWCONFIGLIB
argument_list|,
name|CONFIGFILE
argument_list|)
expr_stmt|;
comment|/* On UNIX we will be probably be running suid to uucp.  We don't want      to let somebody run us and specify some arbitrary file as the      configuration file, since that might let them examine files they      have no access to.  */
if|if
condition|(
name|zname
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zname
argument_list|,
name|zdefault
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|fsysdep_other_config
argument_list|(
name|zname
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't read %s; using %s"
argument_list|,
name|zname
argument_list|,
name|zdefault
argument_list|)
expr_stmt|;
name|zname
operator|=
name|zdefault
expr_stmt|;
block|}
if|if
condition|(
name|zname
operator|==
name|NULL
condition|)
name|zname
operator|=
name|zdefault
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|zname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zname
argument_list|,
name|zdefault
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|abProgram
argument_list|,
name|zname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We haven't yet called usysdep_initialize, so it should be 	     safe to just exit.  */
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* Just use defaults.  */
block|}
else|else
block|{
name|uiunknown_start
argument_list|()
expr_stmt|;
name|uprocesscmds
argument_list|(
name|e
argument_list|,
operator|(
expr|struct
name|smulti_file
operator|*
operator|)
name|NULL
argument_list|,
name|asCmds
argument_list|,
name|zname
argument_list|,
name|CMDFLAG_BACKSLASH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|uiunknown_end
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! HAVE_TAYLOR_CONFIG */
name|uiunknown_start
argument_list|()
expr_stmt|;
name|uiunknown_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_TAYLOR_CONFIG */
if|if
condition|(
name|zLocalname
operator|==
name|NULL
condition|)
block|{
name|zLocalname
operator|=
name|zsysdep_local_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|zLocalname
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't get local node name\n"
argument_list|,
name|abProgram
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|uisetup_localsys
argument_list|()
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
comment|/* Get the defaults for the file names.  */
define|#
directive|define
name|SETDEFAULT
parameter_list|(
name|z
parameter_list|,
name|zfile
parameter_list|)
define|\
value|if (z == NULL) \     { \       z = (char *) xmalloc (sizeof NEWCONFIGLIB + sizeof zfile - 1); \       strcpy (z, NEWCONFIGLIB); \       strcat (z, zfile); \       if (! fsysdep_file_exists (z)) \ 	{ \ 	  xfree ((pointer) z); \ 	  z = NULL; \ 	} \     }
name|SETDEFAULT
argument_list|(
name|zSysfile
argument_list|,
name|SYSFILE
argument_list|)
expr_stmt|;
name|SETDEFAULT
argument_list|(
name|zPortfile
argument_list|,
name|PORTFILE
argument_list|)
expr_stmt|;
name|SETDEFAULT
argument_list|(
name|zDialfile
argument_list|,
name|DIALFILE
argument_list|)
expr_stmt|;
name|SETDEFAULT
argument_list|(
name|zDialcodefile
argument_list|,
name|DIALCODEFILE
argument_list|)
expr_stmt|;
name|SETDEFAULT
argument_list|(
name|zPwdfile
argument_list|,
name|PASSWDFILE
argument_list|)
expr_stmt|;
name|SETDEFAULT
argument_list|(
name|zCallfile
argument_list|,
name|CALLFILE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
if|#
directive|if
name|HAVE_BNU_CONFIG
comment|/* If we are supposed to read standard BNU files, read Sysfiles to      get any nonstandard file names.  */
if|if
condition|(
name|fBnu
condition|)
name|ubnu_read_sysfiles
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_BNU_CONFIG */
comment|/* The format of the dialcodes file is the same for all systems, so      if additional configuration are being used we add the files in      here to save having to do it when the dialcodes file is read.  */
if|#
directive|if
name|HAVE_V2_CONFIG
if|if
condition|(
name|fV2
condition|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|z
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
name|OLDCONFIGLIB
operator|+
sizeof|sizeof
name|V2_DIALCODES
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|z
argument_list|,
literal|"%s%s"
argument_list|,
name|OLDCONFIGLIB
argument_list|,
name|V2_DIALCODES
argument_list|)
expr_stmt|;
name|uadd_string
argument_list|(
operator|&
name|zDialcodefile
argument_list|,
name|z
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_V2_CONFIG */
if|#
directive|if
name|HAVE_BNU_CONFIG
if|if
condition|(
name|fBnu
condition|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|z
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
name|OLDCONFIGLIB
operator|+
sizeof|sizeof
name|BNU_DIALCODES
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|z
argument_list|,
literal|"%s%s"
argument_list|,
name|OLDCONFIGLIB
argument_list|,
name|BNU_DIALCODES
argument_list|)
expr_stmt|;
name|uadd_string
argument_list|(
operator|&
name|zDialcodefile
argument_list|,
name|z
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_BNU_CONFIG */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a string to a list of strings separated by a separator    character.  */
end_comment

begin_function
name|void
name|uadd_string
parameter_list|(
name|pz
parameter_list|,
name|z
parameter_list|,
name|bsep
parameter_list|)
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|bsep
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|pz
operator|==
name|NULL
condition|)
operator|*
name|pz
operator|=
name|xstrdup
argument_list|(
name|z
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|clen
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
operator|*
name|pz
argument_list|)
expr_stmt|;
operator|*
name|pz
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
operator|*
name|pz
argument_list|,
name|clen
operator|+
name|strlen
argument_list|(
name|z
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pz
operator|)
index|[
name|clen
index|]
operator|=
operator|(
name|char
operator|)
name|bsep
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|pz
operator|+
name|clen
operator|+
literal|1
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|DEBUG
operator|>
literal|1
end_if

begin_comment
comment|/* Parse a debugging string.  This may be a simple number, which sets    the given number of bits in iDebug, or it may be a series of single    letters.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|azDebug_names
index|[]
init|=
name|DEBUG_NAMES
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|idebug_parse
parameter_list|(
name|z
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
block|{
name|char
modifier|*
name|zend
decl_stmt|;
name|int
name|i
decl_stmt|,
name|iret
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|,
modifier|*
name|ztok
decl_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|z
argument_list|,
operator|&
name|zend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zend
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|15
condition|)
name|i
operator|=
literal|15
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|<<
name|i
operator|)
operator|-
literal|1
return|;
block|}
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|z
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zcopy
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|iret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ztok
operator|=
name|strtok
argument_list|(
name|zcopy
argument_list|,
literal|","
argument_list|)
init|;
name|ztok
operator|!=
name|NULL
condition|;
name|ztok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|ztok
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iret
operator|=
name|DEBUG_MAX
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|azDebug_names
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|ztok
argument_list|,
name|azDebug_names
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|azDebug_names
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iret
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|azDebug_names
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Unrecognized debugging option \"%s\""
argument_list|,
name|ztok
argument_list|)
expr_stmt|;
block|}
return|return
name|iret
return|;
block|}
end_function

begin_comment
comment|/* Parse a debugging string in a configuration file.  The pvar    arguments points to the field to set.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|enum
name|tcmdtabret
name|tidebug_parse
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|int
modifier|*
name|pidebug
init|=
operator|(
name|int
operator|*
operator|)
name|pvar
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
name|strncasecmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|DEBUG_NONE
argument_list|,
name|strlen
argument_list|(
name|DEBUG_NONE
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pidebug
operator|=
literal|0
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
operator|*
name|pidebug
operator||=
name|idebug_parse
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG> 1 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Given a file name that may actually be several file names each    separated with a single space character, we want to be able to read    lines from them as though they were catenated to form a single    file.  This set of routines allows us to do that easily, although    only for one set of files at a time.  One line can be pushed back,    which can be convenient for the first line of a file.  */
end_comment

begin_struct
struct|struct
name|smulti_file
block|{
comment|/* Names of next files to open.  */
name|char
modifier|*
name|z
decl_stmt|;
comment|/* String to free up when done.  */
name|char
modifier|*
name|zfree
decl_stmt|;
comment|/* Current file.  */
name|FILE
modifier|*
name|e
decl_stmt|;
comment|/* Current file name.  */
name|char
modifier|*
name|zname
decl_stmt|;
comment|/* Next line to return.  */
name|char
modifier|*
name|znext
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|struct
name|smulti_file
modifier|*
name|qmulti_open
parameter_list|(
name|znames
parameter_list|)
specifier|const
name|char
modifier|*
name|znames
decl_stmt|;
block|{
name|struct
name|smulti_file
modifier|*
name|qret
decl_stmt|;
name|qret
operator|=
operator|(
expr|struct
name|smulti_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|smulti_file
argument_list|)
argument_list|)
expr_stmt|;
name|qret
operator|->
name|z
operator|=
name|qret
operator|->
name|zfree
operator|=
name|xstrdup
argument_list|(
name|znames
argument_list|)
expr_stmt|;
name|qret
operator|->
name|zname
operator|=
name|NULL
expr_stmt|;
name|qret
operator|->
name|e
operator|=
name|NULL
expr_stmt|;
name|qret
operator|->
name|znext
operator|=
name|NULL
expr_stmt|;
return|return
name|qret
return|;
block|}
end_function

begin_comment
comment|/* Read the next line from a multiply opened set of files.  */
end_comment

begin_function
name|char
modifier|*
name|zmulti_gets
parameter_list|(
name|q
parameter_list|,
name|pffirst
parameter_list|,
name|pzname
parameter_list|,
name|fbackslash
parameter_list|)
name|struct
name|smulti_file
modifier|*
name|q
decl_stmt|;
name|boolean
modifier|*
name|pffirst
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pzname
decl_stmt|;
name|boolean
name|fbackslash
decl_stmt|;
block|{
if|if
condition|(
name|pffirst
operator|!=
name|NULL
condition|)
operator|*
name|pffirst
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|znext
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|z
operator|=
name|q
operator|->
name|znext
expr_stmt|;
name|q
operator|->
name|znext
operator|=
name|NULL
expr_stmt|;
return|return
name|z
return|;
block|}
while|while
condition|(
name|TRUE
condition|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|e
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zret
decl_stmt|;
name|zret
operator|=
name|zfgets
argument_list|(
name|q
operator|->
name|e
argument_list|,
name|fbackslash
argument_list|)
expr_stmt|;
if|if
condition|(
name|zret
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pzname
operator|!=
name|NULL
condition|)
operator|*
name|pzname
operator|=
name|q
operator|->
name|zname
expr_stmt|;
return|return
name|zret
return|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|q
operator|->
name|e
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|e
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|q
operator|->
name|e
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|q
operator|->
name|z
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|z
operator|=
name|q
operator|->
name|z
expr_stmt|;
name|q
operator|->
name|z
operator|+=
name|strcspn
argument_list|(
name|z
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|->
name|z
operator|!=
literal|'\0'
condition|)
operator|*
name|q
operator|->
name|z
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|q
operator|->
name|e
operator|=
name|fopen
argument_list|(
name|z
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|e
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fopen (%s): %s"
argument_list|,
name|z
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|pffirst
operator|!=
name|NULL
condition|)
operator|*
name|pffirst
operator|=
name|TRUE
expr_stmt|;
name|q
operator|->
name|zname
operator|=
name|z
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Push back a line so that it is read by the next call to    zmulti_gets.  This is sometimes used on the first line of a file in    uprocesscmds.  */
end_comment

begin_function
specifier|static
name|void
name|umulti_pushback
parameter_list|(
name|q
parameter_list|,
name|z
parameter_list|)
name|struct
name|smulti_file
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|q
operator|->
name|znext
operator|!=
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"umulti_pushback: Can't happen"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|znext
operator|=
name|z
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close the multiple file, even though a read is in progress.  If    zmulti_gets returns NULL, the files will have been closed.  */
end_comment

begin_function
name|boolean
name|fmulti_close
parameter_list|(
name|q
parameter_list|)
name|struct
name|smulti_file
modifier|*
name|q
decl_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|e
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|q
operator|->
name|e
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|q
operator|->
name|zfree
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|q
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See whether a file is in a directory list, and make sure the user    has appropriate access.  */
end_comment

begin_function
name|boolean
name|fin_directory_list
parameter_list|(
name|qsys
parameter_list|,
name|zfile
parameter_list|,
name|zdirs
parameter_list|,
name|fcheck
parameter_list|,
name|freadable
parameter_list|,
name|zuser
parameter_list|)
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdirs
decl_stmt|;
name|boolean
name|fcheck
decl_stmt|;
name|boolean
name|freadable
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
block|{
name|char
modifier|*
name|zcopy
decl_stmt|;
name|boolean
name|fmatch
decl_stmt|;
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zdirs
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zcopy
argument_list|,
name|zdirs
argument_list|)
expr_stmt|;
name|fmatch
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|*
name|zcopy
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|z
operator|=
name|zcopy
operator|+
name|strcspn
argument_list|(
name|zcopy
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|==
literal|'\0'
condition|)
operator|--
name|z
expr_stmt|;
else|else
operator|*
name|z
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|zcopy
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|fsysdep_in_directory
argument_list|(
name|qsys
argument_list|,
name|zfile
argument_list|,
name|zcopy
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
name|fmatch
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fsysdep_in_directory
argument_list|(
name|qsys
argument_list|,
name|zfile
argument_list|,
name|zcopy
argument_list|,
name|fcheck
argument_list|,
name|freadable
argument_list|,
name|zuser
argument_list|)
condition|)
name|fmatch
operator|=
name|TRUE
expr_stmt|;
block|}
name|zcopy
operator|=
name|z
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|fmatch
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See whether a file is a spool file.  Spool file names are specially    crafted to hand around to other UUCP packages.  They always begin    with 'C', 'D' or 'X', and the second character is always a period.    The remaining characters are any character that could appear in a    system name.  */
end_comment

begin_function
name|boolean
name|fspool_file
parameter_list|(
name|zfile
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
operator|*
name|zfile
operator|!=
literal|'C'
operator|&&
operator|*
name|zfile
operator|!=
literal|'D'
operator|&&
operator|*
name|zfile
operator|!=
literal|'X'
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|zfile
index|[
literal|1
index|]
operator|!=
literal|'.'
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|z
operator|=
name|zfile
operator|+
literal|2
init|;
operator|*
name|z
operator|!=
literal|'\0'
condition|;
name|z
operator|++
control|)
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
operator|&&
operator|*
name|z
operator|!=
literal|'_'
operator|&&
operator|*
name|z
operator|!=
literal|'-'
operator|&&
operator|*
name|z
operator|!=
literal|'.'
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two grades, returning< 0 if the first should be executed    before the second, == 0 if they are the same, and> 0 if the first    should be executed after the second.  This code assumes that the    upper case letters appear in sequence and the lower case letters    appear in sequence.  */
end_comment

begin_function
name|int
name|igradecmp
parameter_list|(
name|barg1
parameter_list|,
name|barg2
parameter_list|)
name|int
name|barg1
decl_stmt|;
name|int
name|barg2
decl_stmt|;
block|{
name|int
name|b1
decl_stmt|,
name|b2
decl_stmt|;
comment|/* Make sure the arguments are unsigned.  */
name|b1
operator|=
operator|(
name|int
operator|)
name|BUCHAR
argument_list|(
name|barg1
argument_list|)
expr_stmt|;
name|b2
operator|=
operator|(
name|int
operator|)
name|BUCHAR
argument_list|(
name|barg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|b1
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|b2
argument_list|)
condition|)
return|return
name|b1
operator|-
name|b2
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|b1
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|b2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|b2
argument_list|)
condition|)
return|return
name|b1
operator|-
name|b2
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|islower
argument_list|(
name|b2
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
name|b1
operator|-
name|b2
return|;
block|}
block|}
end_function

end_unit

