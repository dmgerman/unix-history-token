begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* time.c    Routines to deal with UUCP time strings.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: time.c,v $    Revision 1.12  1992/03/17  00:32:40  ian    Cast argument to qttime_parse     Revision 1.11  1992/03/09  05:08:16  ian    Added status for wrong time to call, not used if system can't be called     Revision 1.10  1992/03/08  01:52:34  ian    Removed extraneous semicolons     Revision 1.9  1992/03/07  02:56:30  ian    Rewrote time routines     Revision 1.8  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.7  1992/01/11  17:30:10  ian    John Antypas: use memcpy instead of relying on structure assignment     Revision 1.6  1991/12/29  04:04:18  ian    Added a bunch of extern definitions     Revision 1.5  1991/12/22  20:57:57  ian    Added externs for strcasecmp or strncasecmp     Revision 1.4  1991/09/19  02:22:44  ian    Chip Salzenberg's patch to allow ";retrytime" at the end of a time string     Revision 1.3  1991/09/12  05:04:44  ian    Wrong sense of comparison in btime_low_grade     Revision 1.2  1991/09/11  16:59:00  ian    fcheck_time and btime_low_grade looped endlessly on unusual grades       Revision 1.1  1991/09/10  19:40:31  ian    Initial revision       */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|time_rcsid
index|[]
init|=
literal|"$Id: time.c,v 1.12 1992/03/17 00:32:40 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
name|HAVE_TIME_H
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_TIME_T
end_if

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_T
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_TIME_T */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_TIME_T */
end_comment

begin_include
include|#
directive|include
file|"uutime.h"
end_include

begin_comment
comment|/* External functions.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|strncasecmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sspan
modifier|*
name|qtnew
name|P
argument_list|(
operator|(
expr|struct
name|sspan
operator|*
name|qnext
operator|,
name|long
name|ival
operator|,
name|int
name|istart
operator|,
name|int
name|iend
operator|,
name|int
name|cretry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sspan
modifier|*
name|qtadd_span
name|P
argument_list|(
operator|(
expr|struct
name|sspan
operator|*
name|qlist
operator|,
name|long
name|ival
operator|,
name|int
name|istart
operator|,
name|int
name|iend
operator|,
name|boolean
argument_list|(
argument|*picmp
argument_list|)
name|P
argument_list|(
operator|(
name|long
operator|,
name|long
operator|)
argument_list|)
operator|,
name|int
name|cretry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sspan
modifier|*
name|qttime_parse
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|ztime
operator|,
expr|struct
name|sspan
operator|*
name|qlist
operator|,
name|long
name|ival
operator|,
name|boolean
argument_list|(
argument|*picmp
argument_list|)
name|P
argument_list|(
operator|(
name|long
operator|,
name|long
operator|)
argument_list|)
operator|,
name|int
name|cretry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* A helper function to create a new time span with the specified    arguments.  */
end_comment

begin_function
specifier|static
name|struct
name|sspan
modifier|*
name|qtnew
parameter_list|(
name|qnext
parameter_list|,
name|ival
parameter_list|,
name|istart
parameter_list|,
name|iend
parameter_list|,
name|cretry
parameter_list|)
name|struct
name|sspan
modifier|*
name|qnext
decl_stmt|;
name|long
name|ival
decl_stmt|;
name|int
name|istart
decl_stmt|;
name|int
name|iend
decl_stmt|;
name|int
name|cretry
decl_stmt|;
block|{
name|struct
name|sspan
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|sspan
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sspan
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|qnext
operator|=
name|qnext
expr_stmt|;
name|q
operator|->
name|ival
operator|=
name|ival
expr_stmt|;
name|q
operator|->
name|istart
operator|=
name|istart
expr_stmt|;
name|q
operator|->
name|iend
operator|=
name|iend
expr_stmt|;
name|q
operator|->
name|cretry
operator|=
name|cretry
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/* A simple function to free a list of time spans.  */
end_comment

begin_function
name|void
name|utimespan_free
parameter_list|(
name|q
parameter_list|)
name|struct
name|sspan
modifier|*
name|q
decl_stmt|;
block|{
while|while
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sspan
modifier|*
name|qnext
decl_stmt|;
name|qnext
operator|=
name|q
operator|->
name|qnext
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|qnext
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a time span to an existing list of time spans.  We keep the    list sorted by time to make this operation easier.  This modifies    the existing list, and returns the modified version.  It takes a    comparison function which should return< 0 if the first argument    should take precedence over the second argument and == 0 if they    are the same (for grades this is igradecmp; for sizes it is minus    (the binary operator)).  */
end_comment

begin_function_decl
specifier|static
name|struct
name|sspan
modifier|*
name|qtadd_span
parameter_list|(
name|qlist
parameter_list|,
name|ival
parameter_list|,
name|istart
parameter_list|,
name|iend
parameter_list|,
name|picmp
parameter_list|,
name|cretry
parameter_list|)
name|struct
name|sspan
modifier|*
name|qlist
decl_stmt|;
name|long
name|ival
decl_stmt|;
name|int
name|istart
decl_stmt|;
name|int
name|iend
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*picmp
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
name|long
operator|,
name|long
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cretry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sspan
modifier|*
modifier|*
name|pq
decl_stmt|;
comment|/* istart< iend  */
for|for
control|(
name|pq
operator|=
operator|&
name|qlist
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
control|)
block|{
name|int
name|icmp
decl_stmt|;
comment|/* Invariant: PREV (*pq) == NULL || PREV (*pq)->iend<= istart  */
comment|/* istart< iend&& (*pq)->istart< (*pq)->iend  */
if|if
condition|(
name|iend
operator|<=
operator|(
operator|*
name|pq
operator|)
operator|->
name|istart
condition|)
block|{
comment|/* istart< iend<= (*pq)->istart< (*pq)->iend  */
comment|/* No overlap, and we're at the right spot.  See if we can 	     combine these spans.  */
if|if
condition|(
name|iend
operator|==
operator|(
operator|*
name|pq
operator|)
operator|->
name|istart
operator|&&
name|cretry
operator|==
operator|(
operator|*
name|pq
operator|)
operator|->
name|cretry
operator|&&
call|(
modifier|*
name|picmp
call|)
argument_list|(
name|ival
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|ival
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|pq
operator|)
operator|->
name|istart
operator|=
name|istart
expr_stmt|;
return|return
name|qlist
return|;
block|}
comment|/* We couldn't combine them.  */
break|break;
block|}
if|if
condition|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|iend
operator|<=
name|istart
condition|)
block|{
comment|/* (*pq)->istart< (*pq)->iend<= istart< iend  */
comment|/* No overlap.  Try attaching this span.  */
if|if
condition|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|iend
operator|==
name|istart
operator|&&
operator|(
operator|*
name|pq
operator|)
operator|->
name|cretry
operator|==
name|cretry
operator|&&
operator|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
operator|==
name|NULL
operator|||
name|iend
operator|<=
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
operator|->
name|istart
operator|)
operator|&&
call|(
modifier|*
name|picmp
call|)
argument_list|(
name|ival
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|ival
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|pq
operator|)
operator|->
name|iend
operator|=
name|iend
expr_stmt|;
return|return
name|qlist
return|;
block|}
comment|/* Couldn't attach; keep looking for the right spot.  We 	     might be able to combine part of the new span onto an 	     existing span, but it's probably not worth it.  */
continue|continue;
block|}
comment|/* istart< iend&& (*pq)->istart< (*pq)->iend&& istart< (*pq)->iend&& (*pq)->istart< iend  */
comment|/* Overlap.  */
name|icmp
operator|=
call|(
modifier|*
name|picmp
call|)
argument_list|(
name|ival
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|ival
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmp
operator|==
literal|0
condition|)
block|{
comment|/* Just expand the old span to include the new span.  */
if|if
condition|(
name|istart
operator|<
operator|(
operator|*
name|pq
operator|)
operator|->
name|istart
condition|)
operator|(
operator|*
name|pq
operator|)
operator|->
name|istart
operator|=
name|istart
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|iend
operator|<
name|iend
condition|)
operator|(
operator|*
name|pq
operator|)
operator|->
name|iend
operator|=
name|iend
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|icmp
operator|<
literal|0
condition|)
block|{
comment|/* Replace the old span with the new span.  */
if|if
condition|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|istart
operator|<
name|istart
condition|)
block|{
comment|/* Save the initial portion of the old span.  */
operator|*
name|pq
operator|=
name|qtnew
argument_list|(
operator|*
name|pq
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|ival
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|istart
argument_list|,
name|istart
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|cretry
argument_list|)
expr_stmt|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
expr_stmt|;
block|}
if|if
condition|(
name|iend
operator|<
operator|(
operator|*
name|pq
operator|)
operator|->
name|iend
condition|)
block|{
comment|/* Save the final portion of the old span.  */
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
operator|=
name|qtnew
argument_list|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|ival
argument_list|,
name|iend
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|iend
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|cretry
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|pq
operator|)
operator|->
name|ival
operator|=
name|ival
expr_stmt|;
operator|(
operator|*
name|pq
operator|)
operator|->
name|istart
operator|=
name|istart
expr_stmt|;
operator|(
operator|*
name|pq
operator|)
operator|->
name|iend
operator|=
name|iend
expr_stmt|;
operator|(
operator|*
name|pq
operator|)
operator|->
name|cretry
operator|=
name|cretry
expr_stmt|;
block|}
else|else
block|{
comment|/* Leave the old span untouched.  */
if|if
condition|(
name|istart
operator|<
operator|(
operator|*
name|pq
operator|)
operator|->
name|istart
condition|)
block|{
comment|/* Put in the initial portion of the new span.  */
operator|*
name|pq
operator|=
name|qtnew
argument_list|(
operator|*
name|pq
argument_list|,
name|ival
argument_list|,
name|istart
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|istart
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|iend
operator|<
name|iend
condition|)
block|{
comment|/* Put in the final portion of the new span.  */
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
operator|=
name|qtnew
argument_list|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
argument_list|,
name|ival
argument_list|,
operator|(
operator|*
name|pq
operator|)
operator|->
name|iend
argument_list|,
name|iend
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|qlist
return|;
block|}
comment|/* This is the spot for the new span, and there's no overlap.  */
operator|*
name|pq
operator|=
name|qtnew
argument_list|(
operator|*
name|pq
argument_list|,
name|ival
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
return|return
name|qlist
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* An array of weekday abbreviations.  The code below assumes that    each one starts with a lower case letter.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|zname
decl_stmt|;
name|int
name|imin
decl_stmt|;
name|int
name|imax
decl_stmt|;
block|}
name|asTdays
index|[]
init|=
block|{
block|{
literal|"any"
block|,
literal|0
block|,
literal|6
block|}
block|,
block|{
literal|"wk"
block|,
literal|1
block|,
literal|5
block|}
block|,
block|{
literal|"su"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"mo"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"tu"
block|,
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|"we"
block|,
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|"th"
block|,
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|"fr"
block|,
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|"sa"
block|,
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|"never"
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Parse a time string and add it to a span list.  This function is    given the value and comparison function to use.  The time string    continues to a null byte, a space or a semicolon.  This returns the    new span list, or NULL on error.  If no time matches, it will wind    up returning qlist, which may itself be NULL.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|sspan
modifier|*
name|qttime_parse
parameter_list|(
name|ztime
parameter_list|,
name|qlist
parameter_list|,
name|ival
parameter_list|,
name|picmp
parameter_list|,
name|cretry
parameter_list|)
specifier|const
name|char
modifier|*
name|ztime
decl_stmt|;
name|struct
name|sspan
modifier|*
name|qlist
decl_stmt|;
name|long
name|ival
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*picmp
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
name|long
operator|,
name|long
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cretry
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|const
name|char
modifier|*
name|zend
decl_stmt|;
name|char
name|bfirst
decl_stmt|;
name|int
name|i
decl_stmt|;
name|zend
operator|=
name|ztime
operator|+
name|strcspn
argument_list|(
name|ztime
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
if|if
condition|(
name|pasTtable
operator|==
name|NULL
condition|)
name|uinittimetables
argument_list|()
expr_stmt|;
comment|/* Expand the string using a timetable.  */
name|bfirst
operator|=
name|tolower
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|ztime
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cTtable
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bfirst
operator|==
name|tolower
argument_list|(
name|BUCHAR
argument_list|(
name|pasTtable
index|[
name|i
index|]
operator|.
name|zname
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|&&
name|strncasecmp
argument_list|(
name|ztime
argument_list|,
name|pasTtable
index|[
name|i
index|]
operator|.
name|zname
argument_list|,
name|zend
operator|-
name|ztime
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ztime
operator|=
name|pasTtable
index|[
name|i
index|]
operator|.
name|ztime
expr_stmt|;
name|zend
operator|=
name|ztime
operator|+
name|strlen
argument_list|(
name|ztime
argument_list|)
expr_stmt|;
comment|/* Now search the table for this string.  */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Look through the portions of the time string separated by a      comma or a vertical bar.  */
for|for
control|(
init|;
name|ztime
operator|<
name|zend
condition|;
name|ztime
operator|+=
name|strcspn
argument_list|(
name|ztime
argument_list|,
literal|",|"
argument_list|)
control|)
block|{
name|int
name|iday
decl_stmt|;
name|boolean
name|afday
index|[
literal|7
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|istart
decl_stmt|,
name|iend
decl_stmt|;
if|if
condition|(
operator|*
name|ztime
operator|==
literal|','
operator|||
operator|*
name|ztime
operator|==
literal|'|'
condition|)
operator|++
name|ztime
expr_stmt|;
for|for
control|(
name|iday
operator|=
literal|0
init|;
name|iday
operator|<
literal|7
condition|;
name|iday
operator|++
control|)
name|afday
index|[
name|iday
index|]
operator|=
name|FALSE
expr_stmt|;
comment|/* Get the days.  */
name|z
operator|=
name|ztime
expr_stmt|;
do|do
block|{
name|bfirst
operator|=
name|tolower
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|iday
operator|=
literal|0
init|;
name|asTdays
index|[
name|iday
index|]
operator|.
name|zname
operator|!=
name|NULL
condition|;
name|iday
operator|++
control|)
block|{
name|int
name|clen
decl_stmt|;
if|if
condition|(
name|bfirst
operator|!=
name|asTdays
index|[
name|iday
index|]
operator|.
name|zname
index|[
literal|0
index|]
condition|)
continue|continue;
name|clen
operator|=
name|strlen
argument_list|(
name|asTdays
index|[
name|iday
index|]
operator|.
name|zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|z
argument_list|,
name|asTdays
index|[
name|iday
index|]
operator|.
name|zname
argument_list|,
name|clen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|iset
decl_stmt|;
for|for
control|(
name|iset
operator|=
name|asTdays
index|[
name|iday
index|]
operator|.
name|imin
init|;
name|iset
operator|<=
name|asTdays
index|[
name|iday
index|]
operator|.
name|imax
condition|;
name|iset
operator|++
control|)
name|afday
index|[
name|iset
index|]
operator|=
name|TRUE
expr_stmt|;
name|z
operator|+=
name|clen
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|asTdays
index|[
name|iday
index|]
operator|.
name|zname
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: unparseable time string"
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
do|while
condition|(
name|isalpha
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
condition|)
do|;
comment|/* Get the hours.  */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
condition|)
block|{
name|istart
operator|=
literal|0
expr_stmt|;
name|iend
operator|=
literal|24
operator|*
literal|60
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|zendnum
decl_stmt|;
name|istart
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|z
argument_list|,
operator|&
name|zendnum
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zendnum
operator|!=
literal|'-'
operator|||
operator|!
name|isdigit
argument_list|(
name|BUCHAR
argument_list|(
name|zendnum
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: unparseable time string"
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|z
operator|=
name|zendnum
operator|+
literal|1
expr_stmt|;
name|iend
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|z
argument_list|,
operator|&
name|zendnum
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zendnum
operator|!=
literal|'\0'
operator|&&
operator|*
name|zendnum
operator|!=
literal|' '
operator|&&
operator|*
name|zendnum
operator|!=
literal|';'
operator|&&
operator|*
name|zendnum
operator|!=
literal|','
operator|&&
operator|*
name|zendnum
operator|!=
literal|'|'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: unparseable time string"
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|istart
operator|=
operator|(
name|istart
operator|/
literal|100
operator|)
operator|*
literal|60
operator|+
name|istart
operator|%
literal|100
expr_stmt|;
name|iend
operator|=
operator|(
name|iend
operator|/
literal|100
operator|)
operator|*
literal|60
operator|+
name|iend
operator|%
literal|100
expr_stmt|;
block|}
comment|/* Add the times we've found onto the list.  */
for|for
control|(
name|iday
operator|=
literal|0
init|;
name|iday
operator|<
literal|7
condition|;
name|iday
operator|++
control|)
block|{
if|if
condition|(
name|afday
index|[
name|iday
index|]
condition|)
block|{
name|int
name|iminute
decl_stmt|;
name|iminute
operator|=
name|iday
operator|*
literal|24
operator|*
literal|60
expr_stmt|;
if|if
condition|(
name|istart
operator|<
name|iend
condition|)
name|qlist
operator|=
name|qtadd_span
argument_list|(
name|qlist
argument_list|,
name|ival
argument_list|,
name|iminute
operator|+
name|istart
argument_list|,
name|iminute
operator|+
name|iend
argument_list|,
name|picmp
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Wrap around midnight.  */
name|qlist
operator|=
name|qtadd_span
argument_list|(
name|qlist
argument_list|,
name|ival
argument_list|,
name|iminute
argument_list|,
name|iminute
operator|+
name|iend
argument_list|,
name|picmp
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
name|qlist
operator|=
name|qtadd_span
argument_list|(
name|qlist
argument_list|,
name|ival
argument_list|,
name|iminute
operator|+
name|istart
argument_list|,
name|iminute
operator|+
literal|24
operator|*
literal|60
argument_list|,
name|picmp
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|qlist
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* See if the current time matches a time span.  If it does, return    TRUE, set *pival to the value for the matching span, and set    *pcretry to the retry for the matching span.  Otherwise return    FALSE.  */
end_comment

begin_function
name|boolean
name|ftimespan_match
parameter_list|(
name|qspan
parameter_list|,
name|pival
parameter_list|,
name|pcretry
parameter_list|)
specifier|const
name|struct
name|sspan
modifier|*
name|qspan
decl_stmt|;
name|long
modifier|*
name|pival
decl_stmt|;
name|int
modifier|*
name|pcretry
decl_stmt|;
block|{
name|time_t
name|inow
decl_stmt|;
name|struct
name|tm
modifier|*
name|qtm
decl_stmt|;
name|int
name|itm
decl_stmt|;
specifier|const
name|struct
name|sspan
modifier|*
name|q
decl_stmt|;
name|time
argument_list|(
operator|&
name|inow
argument_list|)
expr_stmt|;
name|qtm
operator|=
name|localtime
argument_list|(
operator|&
name|inow
argument_list|)
expr_stmt|;
comment|/* Get the number of minutes since Sunday for the time.  */
name|itm
operator|=
name|qtm
operator|->
name|tm_wday
operator|*
literal|24
operator|*
literal|60
operator|+
name|qtm
operator|->
name|tm_hour
operator|*
literal|60
operator|+
name|qtm
operator|->
name|tm_min
expr_stmt|;
for|for
control|(
name|q
operator|=
name|qspan
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|qnext
control|)
block|{
if|if
condition|(
name|q
operator|->
name|istart
operator|<=
name|itm
operator|&&
name|itm
operator|<=
name|q
operator|->
name|iend
condition|)
block|{
if|if
condition|(
name|pival
operator|!=
name|NULL
condition|)
operator|*
name|pival
operator|=
name|q
operator|->
name|ival
expr_stmt|;
if|if
condition|(
name|pcretry
operator|!=
name|NULL
condition|)
operator|*
name|pcretry
operator|=
name|q
operator|->
name|cretry
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two work grades.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|itgradecmp
name|P
argument_list|(
operator|(
name|long
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|itgradecmp
parameter_list|(
name|i1
parameter_list|,
name|i2
parameter_list|)
name|long
name|i1
decl_stmt|;
name|long
name|i2
decl_stmt|;
block|{
return|return
name|igradecmp
argument_list|(
operator|(
name|int
operator|)
name|i1
argument_list|,
operator|(
name|int
operator|)
name|i2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a time grade string into a time span.  A time grade string is    a series of single character work grades followed by time strings.    The time string may end with a semicolon and a retry time.  Each    grade/time/retry tuple is separated by a single space.  This    function returns a time span, or NULL if no time matches or an    error occurs. */
end_comment

begin_function
name|struct
name|sspan
modifier|*
name|qtimegrade_parse
parameter_list|(
name|ztimegrade
parameter_list|)
specifier|const
name|char
modifier|*
name|ztimegrade
decl_stmt|;
block|{
name|struct
name|sspan
modifier|*
name|qret
decl_stmt|;
if|if
condition|(
name|ztimegrade
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|qret
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
specifier|const
name|char
modifier|*
name|zretry
decl_stmt|;
name|int
name|cretry
decl_stmt|;
name|struct
name|sspan
modifier|*
name|qnext
decl_stmt|;
name|zretry
operator|=
name|ztimegrade
operator|+
name|strcspn
argument_list|(
name|ztimegrade
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zretry
operator|==
literal|';'
condition|)
name|cretry
operator|=
name|atoi
argument_list|(
name|zretry
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|cretry
operator|=
literal|0
expr_stmt|;
name|qnext
operator|=
name|qttime_parse
argument_list|(
name|ztimegrade
operator|+
literal|1
argument_list|,
name|qret
argument_list|,
operator|(
name|long
operator|)
operator|*
name|ztimegrade
argument_list|,
name|itgradecmp
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnext
operator|!=
name|NULL
condition|)
name|qret
operator|=
name|qnext
expr_stmt|;
name|ztimegrade
operator|+=
name|strcspn
argument_list|(
name|ztimegrade
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ztimegrade
operator|==
literal|'\0'
condition|)
break|break;
operator|++
name|ztimegrade
expr_stmt|;
block|}
return|return
name|qret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare sizes when putting them into a timestring.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|itsizecmp
name|P
argument_list|(
operator|(
name|long
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|itsizecmp
parameter_list|(
name|i1
parameter_list|,
name|i2
parameter_list|)
name|long
name|i1
decl_stmt|;
name|long
name|i2
decl_stmt|;
block|{
comment|/* We can't just return i1 - i2 because that would be a long.  */
if|if
condition|(
name|i1
operator|<
name|i2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|i1
operator|==
name|i2
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse a time size string into a span.  A time size string is a    size, a space, a time string, a space, repeated.  There is no retry    time associated with a time size string.  */
end_comment

begin_function
name|struct
name|sspan
modifier|*
name|qtimesize_parse
parameter_list|(
name|ztimesize
parameter_list|)
specifier|const
name|char
modifier|*
name|ztimesize
decl_stmt|;
block|{
name|struct
name|sspan
modifier|*
name|qret
decl_stmt|;
if|if
condition|(
name|ztimesize
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|qret
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|long
name|isize
decl_stmt|;
name|char
modifier|*
name|zend
decl_stmt|;
name|struct
name|sspan
modifier|*
name|qnext
decl_stmt|;
name|isize
operator|=
name|strtol
argument_list|(
name|ztimesize
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
operator|*
name|zend
operator|!=
literal|' '
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"qtimesize_parse: Can't happen"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|zend
expr_stmt|;
name|qnext
operator|=
name|qttime_parse
argument_list|(
name|zend
argument_list|,
name|qret
argument_list|,
name|isize
argument_list|,
name|itsizecmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnext
operator|!=
name|NULL
condition|)
name|qret
operator|=
name|qnext
expr_stmt|;
name|ztimesize
operator|=
name|zend
operator|+
name|strcspn
argument_list|(
name|zend
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ztimesize
operator|==
literal|'\0'
condition|)
break|break;
operator|++
name|ztimesize
expr_stmt|;
block|}
return|return
name|qret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine the grade of work we are permitted to do at the current    time, given a time/grade string.  Return a null byte if no grades    are legal.  */
end_comment

begin_function
name|char
name|btimegrade
parameter_list|(
name|ztimegrade
parameter_list|)
specifier|const
name|char
modifier|*
name|ztimegrade
decl_stmt|;
block|{
name|struct
name|sspan
modifier|*
name|qspan
decl_stmt|;
name|boolean
name|fmatch
decl_stmt|;
name|long
name|ival
decl_stmt|;
name|qspan
operator|=
name|qtimegrade_parse
argument_list|(
name|ztimegrade
argument_list|)
expr_stmt|;
if|if
condition|(
name|qspan
operator|==
name|NULL
condition|)
return|return
literal|'\0'
return|;
name|fmatch
operator|=
name|ftimespan_match
argument_list|(
name|qspan
argument_list|,
operator|&
name|ival
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|utimespan_free
argument_list|(
name|qspan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fmatch
condition|)
return|return
literal|'\0'
return|;
return|return
operator|(
name|int
operator|)
name|ival
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine the maximum size that may be transferred at the present    time, according to a time size string.  This returns -1 if there    are no restrictions.  */
end_comment

begin_function
name|long
name|cmax_size_now
parameter_list|(
name|ztimesize
parameter_list|)
specifier|const
name|char
modifier|*
name|ztimesize
decl_stmt|;
block|{
name|struct
name|sspan
modifier|*
name|qspan
decl_stmt|;
name|boolean
name|fmatch
decl_stmt|;
name|long
name|ival
decl_stmt|;
name|qspan
operator|=
name|qtimesize_parse
argument_list|(
name|ztimesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|qspan
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|fmatch
operator|=
name|ftimespan_match
argument_list|(
name|qspan
argument_list|,
operator|&
name|ival
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|utimespan_free
argument_list|(
name|qspan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fmatch
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ival
return|;
block|}
end_function

begin_comment
comment|/* Determine the maximum size that may ever be transferred, according    to a time size string.  This returns -1 if there is no limit.  */
end_comment

begin_function
name|long
name|cmax_size_ever
parameter_list|(
name|ztimesize
parameter_list|)
specifier|const
name|char
modifier|*
name|ztimesize
decl_stmt|;
block|{
name|struct
name|sspan
modifier|*
name|qspan
decl_stmt|;
name|long
name|imax
decl_stmt|;
name|struct
name|sspan
modifier|*
name|q
decl_stmt|;
name|qspan
operator|=
name|qtimesize_parse
argument_list|(
name|ztimesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|qspan
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Look through the list of spans.  If there is any gap larger than      1 hour, we assume there are no restrictions.  Otherwise we keep      track of the largest value we see.  I picked 1 hour arbitrarily,      on the theory that a 1 hour span to transfer large files might      actually occur, and is probably not an accident.  */
if|if
condition|(
name|qspan
operator|->
name|istart
operator|>=
literal|60
condition|)
block|{
name|utimespan_free
argument_list|(
name|qspan
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|imax
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|q
operator|=
name|qspan
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|qnext
control|)
block|{
if|if
condition|(
name|q
operator|->
name|qnext
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|iend
operator|<=
literal|6
operator|*
literal|24
operator|*
literal|60
operator|+
literal|23
operator|*
literal|60
condition|)
block|{
name|utimespan_free
argument_list|(
name|qspan
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|q
operator|->
name|iend
operator|+
literal|60
operator|<=
name|q
operator|->
name|qnext
operator|->
name|istart
condition|)
block|{
name|utimespan_free
argument_list|(
name|qspan
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|imax
operator|<
name|q
operator|->
name|ival
condition|)
name|imax
operator|=
name|q
operator|->
name|ival
expr_stmt|;
block|}
name|utimespan_free
argument_list|(
name|qspan
argument_list|)
expr_stmt|;
return|return
name|imax
return|;
block|}
end_function

end_unit

