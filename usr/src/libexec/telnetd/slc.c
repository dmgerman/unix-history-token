begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)slc.c	5.8 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"telnetd.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LINEMODE
end_ifdef

begin_comment
comment|/*  * local varibles  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|def_slcbuf
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|def_slclen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|slcchange
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* change to slc is requested */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|slcptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer into slc buffer */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|slcbuf
index|[
name|NSLC
operator|*
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for slc negotiation */
end_comment

begin_comment
comment|/*  * send_slc  *  * Write out the current special characters to the client.  */
end_comment

begin_function
name|void
name|send_slc
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Send out list of triplets of special characters 	 * to client.  We only send info on the characters 	 * that are currently supported. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NSLC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|slctab
index|[
name|i
index|]
operator|.
name|defset
operator|.
name|flag
operator|&
name|SLC_LEVELBITS
operator|)
operator|==
name|SLC_NOSUPPORT
condition|)
continue|continue;
name|add_slc
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|i
argument_list|,
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|flag
argument_list|,
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end of send_slc */
end_comment

begin_comment
comment|/*  * default_slc  *  * Set pty special characters to all the defaults.  */
end_comment

begin_function
name|void
name|default_slc
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NSLC
condition|;
name|i
operator|++
control|)
block|{
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|val
operator|=
name|slctab
index|[
name|i
index|]
operator|.
name|defset
operator|.
name|val
expr_stmt|;
if|if
condition|(
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|val
operator|==
call|(
name|cc_t
call|)
argument_list|(
name|_POSIX_VDISABLE
argument_list|)
condition|)
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|flag
operator|=
name|SLC_NOSUPPORT
expr_stmt|;
else|else
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|flag
operator|=
name|slctab
index|[
name|i
index|]
operator|.
name|defset
operator|.
name|flag
expr_stmt|;
if|if
condition|(
name|slctab
index|[
name|i
index|]
operator|.
name|sptr
condition|)
block|{
operator|*
operator|(
name|slctab
index|[
name|i
index|]
operator|.
name|sptr
operator|)
operator|=
name|slctab
index|[
name|i
index|]
operator|.
name|defset
operator|.
name|val
expr_stmt|;
block|}
block|}
name|slcchange
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of default_slc */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LINEMODE */
end_comment

begin_comment
comment|/*  * get_slc_defaults  *  * Initialize the slc mapping table.  */
end_comment

begin_function
name|void
name|get_slc_defaults
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|init_termbuf
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NSLC
condition|;
name|i
operator|++
control|)
block|{
name|slctab
index|[
name|i
index|]
operator|.
name|defset
operator|.
name|flag
operator|=
name|spcset
argument_list|(
name|i
argument_list|,
operator|&
name|slctab
index|[
name|i
index|]
operator|.
name|defset
operator|.
name|val
argument_list|,
operator|&
name|slctab
index|[
name|i
index|]
operator|.
name|sptr
argument_list|)
expr_stmt|;
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|flag
operator|=
name|SLC_NOSUPPORT
expr_stmt|;
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|val
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end of get_slc_defaults */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LINEMODE
end_ifdef

begin_comment
comment|/*  * add_slc  *  * Add an slc triplet to the slc buffer.  */
end_comment

begin_function
name|void
name|add_slc
parameter_list|(
name|func
parameter_list|,
name|flag
parameter_list|,
name|val
parameter_list|)
specifier|register
name|char
name|func
decl_stmt|,
name|flag
decl_stmt|;
specifier|register
name|cc_t
name|val
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|slcptr
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|func
operator|)
operator|==
literal|0xff
condition|)
operator|*
name|slcptr
operator|++
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|slcptr
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|flag
operator|)
operator|==
literal|0xff
condition|)
operator|*
name|slcptr
operator|++
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|slcptr
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|val
operator|)
operator|==
literal|0xff
condition|)
operator|*
name|slcptr
operator|++
operator|=
literal|0xff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of add_slc */
end_comment

begin_comment
comment|/*  * start_slc  *  * Get ready to process incoming slc's and respond to them.  *  * The parameter getit is non-zero if it is necessary to grab a copy  * of the terminal control structures.  */
end_comment

begin_function
name|void
name|start_slc
parameter_list|(
name|getit
parameter_list|)
specifier|register
name|int
name|getit
decl_stmt|;
block|{
name|slcchange
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getit
condition|)
name|init_termbuf
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|slcbuf
argument_list|,
literal|"%c%c%c%c"
argument_list|,
name|IAC
argument_list|,
name|SB
argument_list|,
name|TELOPT_LINEMODE
argument_list|,
name|LM_SLC
argument_list|)
expr_stmt|;
name|slcptr
operator|=
name|slcbuf
operator|+
literal|4
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of start_slc */
end_comment

begin_comment
comment|/*  * end_slc  *  * Finish up the slc negotiation.  If something to send, then send it.  */
end_comment

begin_function
name|int
name|end_slc
parameter_list|(
name|bufp
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
modifier|*
name|bufp
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|void
name|netflush
parameter_list|()
function_decl|;
comment|/* 	 * If a change has occured, store the new terminal control 	 * structures back to the terminal driver. 	 */
if|if
condition|(
name|slcchange
condition|)
block|{
name|set_termbuf
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * If the pty state has not yet been fully processed and there is a 	 * deferred slc request from the client, then do not send any 	 * sort of slc negotiation now.  We will respond to the client's 	 * request very soon. 	 */
if|if
condition|(
name|def_slcbuf
operator|&&
operator|(
name|terminit
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|slcptr
operator|>
operator|(
name|slcbuf
operator|+
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|bufp
condition|)
block|{
operator|*
name|bufp
operator|=
operator|&
name|slcbuf
index|[
literal|4
index|]
expr_stmt|;
return|return
operator|(
name|slcptr
operator|-
name|slcbuf
operator|-
literal|4
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|slcptr
argument_list|,
literal|"%c%c"
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
name|slcptr
operator|+=
literal|2
expr_stmt|;
name|len
operator|=
name|slcptr
operator|-
name|slcbuf
expr_stmt|;
name|writenet
argument_list|(
name|slcbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|netflush
argument_list|()
expr_stmt|;
comment|/* force it out immediately */
name|DIAG
argument_list|(
argument|TD_OPTIONS
argument_list|,
argument|printsub(
literal|'>'
argument|, slcbuf+
literal|2
argument|, len-
literal|2
argument|);
argument_list|)
empty_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end of end_slc */
end_comment

begin_comment
comment|/*  * process_slc  *  * Figure out what to do about the client's slc  */
end_comment

begin_function
name|void
name|process_slc
parameter_list|(
name|func
parameter_list|,
name|flag
parameter_list|,
name|val
parameter_list|)
specifier|register
name|unsigned
name|char
name|func
decl_stmt|,
name|flag
decl_stmt|;
specifier|register
name|cc_t
name|val
decl_stmt|;
block|{
specifier|register
name|int
name|hislevel
decl_stmt|,
name|mylevel
decl_stmt|,
name|ack
decl_stmt|;
comment|/* 	 * Ensure that we know something about this function 	 */
if|if
condition|(
name|func
operator|>
name|NSLC
condition|)
block|{
name|add_slc
argument_list|(
name|func
argument_list|,
name|SLC_NOSUPPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Process the special case requests of 0 SLC_DEFAULT 0 	 * and 0 SLC_VARIABLE 0.  Be a little forgiving here, don't 	 * worry about whether the value is actually 0 or not. 	 */
if|if
condition|(
name|func
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|flag
operator|=
name|flag
operator|&
name|SLC_LEVELBITS
operator|)
operator|==
name|SLC_DEFAULT
condition|)
block|{
name|default_slc
argument_list|()
expr_stmt|;
name|send_slc
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|==
name|SLC_VARIABLE
condition|)
block|{
name|send_slc
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Appears to be a function that we know something about.  So 	 * get on with it and see what we know. 	 */
name|hislevel
operator|=
name|flag
operator|&
name|SLC_LEVELBITS
expr_stmt|;
name|mylevel
operator|=
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|flag
operator|&
name|SLC_LEVELBITS
expr_stmt|;
name|ack
operator|=
name|flag
operator|&
name|SLC_ACK
expr_stmt|;
comment|/* 	 * ignore the command if: 	 * the function value and level are the same as what we already have; 	 * or the level is the same and the ack bit is set 	 */
if|if
condition|(
name|hislevel
operator|==
name|mylevel
operator|&&
operator|(
name|val
operator|==
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|val
operator|||
name|ack
operator|)
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|ack
condition|)
block|{
comment|/* 		 * If we get here, we got an ack, but the levels don't match. 		 * This shouldn't happen.  If it does, it is probably because 		 * we have sent two requests to set a variable without getting 		 * a response between them, and this is the first response. 		 * So, ignore it, and wait for the next response. 		 */
return|return;
block|}
else|else
block|{
name|change_slc
argument_list|(
name|func
argument_list|,
name|flag
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end of process_slc */
end_comment

begin_comment
comment|/*  * change_slc  *  * Process a request to change one of our special characters.  * Compare client's request with what we are capable of supporting.  */
end_comment

begin_function
name|void
name|change_slc
parameter_list|(
name|func
parameter_list|,
name|flag
parameter_list|,
name|val
parameter_list|)
specifier|register
name|char
name|func
decl_stmt|,
name|flag
decl_stmt|;
specifier|register
name|cc_t
name|val
decl_stmt|;
block|{
specifier|register
name|int
name|hislevel
decl_stmt|,
name|mylevel
decl_stmt|;
name|hislevel
operator|=
name|flag
operator|&
name|SLC_LEVELBITS
expr_stmt|;
name|mylevel
operator|=
name|slctab
index|[
name|func
index|]
operator|.
name|defset
operator|.
name|flag
operator|&
name|SLC_LEVELBITS
expr_stmt|;
comment|/* 	 * If client is setting a function to NOSUPPORT 	 * or DEFAULT, then we can easily and directly 	 * accomodate the request. 	 */
if|if
condition|(
name|hislevel
operator|==
name|SLC_NOSUPPORT
condition|)
block|{
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|flag
operator|=
name|flag
expr_stmt|;
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|val
operator|=
operator|(
name|cc_t
operator|)
name|_POSIX_VDISABLE
expr_stmt|;
name|flag
operator||=
name|SLC_ACK
expr_stmt|;
name|add_slc
argument_list|(
name|func
argument_list|,
name|flag
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hislevel
operator|==
name|SLC_DEFAULT
condition|)
block|{
comment|/* 		 * Special case here.  If client tells us to use 		 * the default on a function we don't support, then 		 * return NOSUPPORT instead of what we may have as a 		 * default level of DEFAULT. 		 */
if|if
condition|(
name|mylevel
operator|==
name|SLC_DEFAULT
condition|)
block|{
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|flag
operator|=
name|SLC_NOSUPPORT
expr_stmt|;
block|}
else|else
block|{
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|flag
operator|=
name|slctab
index|[
name|func
index|]
operator|.
name|defset
operator|.
name|flag
expr_stmt|;
block|}
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|val
operator|=
name|slctab
index|[
name|func
index|]
operator|.
name|defset
operator|.
name|val
expr_stmt|;
name|add_slc
argument_list|(
name|func
argument_list|,
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|flag
argument_list|,
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Client wants us to change to a new value or he 	 * is telling us that he can't change to our value. 	 * Some of the slc's we support and can change, 	 * some we do support but can't change, 	 * and others we don't support at all. 	 * If we can change it then we have a pointer to 	 * the place to put the new value, so change it, 	 * otherwise, continue the negotiation. 	 */
if|if
condition|(
name|slctab
index|[
name|func
index|]
operator|.
name|sptr
condition|)
block|{
comment|/* 		 * We can change this one. 		 */
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|val
operator|=
name|val
expr_stmt|;
operator|*
operator|(
name|slctab
index|[
name|func
index|]
operator|.
name|sptr
operator|)
operator|=
name|val
expr_stmt|;
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|flag
operator|=
name|flag
expr_stmt|;
name|flag
operator||=
name|SLC_ACK
expr_stmt|;
name|slcchange
operator|=
literal|1
expr_stmt|;
name|add_slc
argument_list|(
name|func
argument_list|,
name|flag
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		* It is not possible for us to support this 		* request as he asks. 		* 		* If our level is DEFAULT, then just ack whatever was 		* sent.  		* 		* If he can't change and we can't change, 		* then degenerate to NOSUPPORT. 		* 		* Otherwise we send our level back to him, (CANTCHANGE 		* or NOSUPPORT) and if CANTCHANGE, send 		* our value as well. 		*/
if|if
condition|(
name|mylevel
operator|==
name|SLC_DEFAULT
condition|)
block|{
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|flag
operator|=
name|flag
expr_stmt|;
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|flag
operator||=
name|SLC_ACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hislevel
operator|==
name|SLC_CANTCHANGE
operator|&&
name|mylevel
operator|==
name|SLC_CANTCHANGE
condition|)
block|{
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|flag
operator||=
name|SLC_NOSUPPORT
expr_stmt|;
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|flag
operator|=
name|flag
expr_stmt|;
block|}
else|else
block|{
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|flag
operator||=
name|mylevel
expr_stmt|;
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|flag
operator|=
name|flag
expr_stmt|;
if|if
condition|(
name|mylevel
operator|==
name|SLC_CANTCHANGE
condition|)
block|{
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|val
operator|=
name|slctab
index|[
name|func
index|]
operator|.
name|defset
operator|.
name|val
expr_stmt|;
name|val
operator|=
name|slctab
index|[
name|func
index|]
operator|.
name|current
operator|.
name|val
expr_stmt|;
block|}
block|}
name|add_slc
argument_list|(
name|func
argument_list|,
name|flag
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end of change_slc */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_TERMIO
argument_list|)
operator|&&
operator|(
name|VEOF
operator|==
name|VMIN
operator|)
end_if

begin_decl_stmt
name|cc_t
name|oldeofc
init|=
literal|'\004'
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * check_slc  *  * Check the special characters in use and notify the client if any have  * changed.  Only those characters that are capable of being changed are  * likely to have changed.  If a local change occurs, kick the support level  * and flags up to the defaults.  */
end_comment

begin_function
name|void
name|check_slc
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NSLC
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_TERMIO
argument_list|)
operator|&&
operator|(
name|VEOF
operator|==
name|VMIN
operator|)
comment|/* 		 * In a perfect world this would be a neat little 		 * function.  But in this world, we should not notify 		 * client of changes to the VEOF char when 		 * ICANON is off, because it is not representing 		 * a special character. 		 */
if|if
condition|(
name|i
operator|==
name|SLC_EOF
condition|)
block|{
if|if
condition|(
operator|!
name|tty_isediting
argument_list|()
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|slctab
index|[
name|i
index|]
operator|.
name|sptr
condition|)
name|oldeofc
operator|=
operator|*
operator|(
name|slctab
index|[
name|i
index|]
operator|.
name|sptr
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(USE_TERMIO)&& defined(SYSV_TERMIO) */
if|if
condition|(
name|slctab
index|[
name|i
index|]
operator|.
name|sptr
operator|&&
operator|(
operator|*
operator|(
name|slctab
index|[
name|i
index|]
operator|.
name|sptr
operator|)
operator|!=
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|val
operator|)
condition|)
block|{
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|val
operator|=
operator|*
operator|(
name|slctab
index|[
name|i
index|]
operator|.
name|sptr
operator|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|slctab
index|[
name|i
index|]
operator|.
name|sptr
operator|)
operator|==
operator|(
name|cc_t
operator|)
name|_POSIX_VDISABLE
condition|)
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|flag
operator|=
name|SLC_NOSUPPORT
expr_stmt|;
else|else
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|flag
operator|=
name|slctab
index|[
name|i
index|]
operator|.
name|defset
operator|.
name|flag
expr_stmt|;
name|add_slc
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|i
argument_list|,
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|flag
argument_list|,
name|slctab
index|[
name|i
index|]
operator|.
name|current
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* check_slc */
end_comment

begin_comment
comment|/*  * do_opt_slc  *  * Process an slc option buffer.  Defer processing of incoming slc's  * until after the terminal state has been processed.  Save the first slc  * request that comes along, but discard all others.  *  * ptr points to the beginning of the buffer, len is the length.  */
end_comment

begin_function
name|void
name|do_opt_slc
parameter_list|(
name|ptr
parameter_list|,
name|len
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
name|func
decl_stmt|,
name|flag
decl_stmt|;
name|cc_t
name|val
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|end
init|=
name|ptr
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|terminit
argument_list|()
condition|)
block|{
comment|/* go ahead */
while|while
condition|(
name|ptr
operator|<
name|end
condition|)
block|{
name|func
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|ptr
operator|>=
name|end
condition|)
break|break;
name|flag
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|ptr
operator|>=
name|end
condition|)
break|break;
name|val
operator|=
operator|(
name|cc_t
operator|)
operator|*
name|ptr
operator|++
expr_stmt|;
name|process_slc
argument_list|(
name|func
argument_list|,
name|flag
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * save this slc buffer if it is the first, otherwise dump 		 * it. 		 */
if|if
condition|(
name|def_slcbuf
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|def_slclen
operator|=
name|len
expr_stmt|;
name|def_slcbuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_slcbuf
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* too bad */
name|bcopy
argument_list|(
name|ptr
argument_list|,
name|def_slcbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end of do_opt_slc */
end_comment

begin_comment
comment|/*  * deferslc  *  * Do slc stuff that was deferred.  */
end_comment

begin_function
name|void
name|deferslc
parameter_list|()
block|{
if|if
condition|(
name|def_slcbuf
condition|)
block|{
name|start_slc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|do_opt_slc
argument_list|(
name|def_slcbuf
argument_list|,
name|def_slclen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|end_slc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def_slcbuf
argument_list|)
expr_stmt|;
name|def_slcbuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|def_slclen
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end of deferslc */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LINEMODE */
end_comment

end_unit

