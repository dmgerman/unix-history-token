begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)state.c	5.5 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"telnetd.h"
end_include

begin_decl_stmt
name|char
name|doopt
index|[]
init|=
block|{
name|IAC
block|,
name|DO
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dont
index|[]
init|=
block|{
name|IAC
block|,
name|DONT
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|will
index|[]
init|=
block|{
name|IAC
block|,
name|WILL
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|wont
index|[]
init|=
block|{
name|IAC
block|,
name|WONT
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|not42
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Buffer for sub-options, and macros  * for suboptions buffer manipulations  */
end_comment

begin_decl_stmt
name|char
name|subbuffer
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|subpointer
init|=
name|subbuffer
decl_stmt|,
modifier|*
name|subend
init|=
name|subbuffer
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SB_CLEAR
parameter_list|()
value|subpointer = subbuffer;
end_define

begin_define
define|#
directive|define
name|SB_TERM
parameter_list|()
value|{ subend = subpointer; SB_CLEAR(); }
end_define

begin_define
define|#
directive|define
name|SB_ACCUM
parameter_list|(
name|c
parameter_list|)
value|if (subpointer< (subbuffer+sizeof subbuffer)) { \ 				*subpointer++ = (c); \ 			}
end_define

begin_define
define|#
directive|define
name|SB_GET
parameter_list|()
value|((*subpointer++)&0xff)
end_define

begin_define
define|#
directive|define
name|SB_EOF
parameter_list|()
value|(subpointer>= subend)
end_define

begin_comment
comment|/*  * State for recv fsm  */
end_comment

begin_define
define|#
directive|define
name|TS_DATA
value|0
end_define

begin_comment
comment|/* base state */
end_comment

begin_define
define|#
directive|define
name|TS_IAC
value|1
end_define

begin_comment
comment|/* look for double IAC's */
end_comment

begin_define
define|#
directive|define
name|TS_CR
value|2
end_define

begin_comment
comment|/* CR-LF ->'s CR */
end_comment

begin_define
define|#
directive|define
name|TS_SB
value|3
end_define

begin_comment
comment|/* throw away begin's... */
end_comment

begin_define
define|#
directive|define
name|TS_SE
value|4
end_define

begin_comment
comment|/* ...end's (suboption negotiation) */
end_comment

begin_define
define|#
directive|define
name|TS_WILL
value|5
end_define

begin_comment
comment|/* will option negotiation */
end_comment

begin_define
define|#
directive|define
name|TS_WONT
value|6
end_define

begin_comment
comment|/* wont " */
end_comment

begin_define
define|#
directive|define
name|TS_DO
value|7
end_define

begin_comment
comment|/* do " */
end_comment

begin_define
define|#
directive|define
name|TS_DONT
value|8
end_define

begin_comment
comment|/* dont " */
end_comment

begin_macro
name|telrcv
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|state
init|=
name|TS_DATA
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CRAY2
argument_list|)
operator|&&
name|defined
argument_list|(
name|UNICOS5
argument_list|)
name|char
modifier|*
name|opfrontp
init|=
name|pfrontp
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
name|ncc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|&
name|ptyobuf
index|[
name|BUFSIZ
index|]
operator|-
name|pfrontp
operator|)
operator|<
literal|2
condition|)
break|break;
name|c
operator|=
operator|*
name|netip
operator|++
operator|&
literal|0377
operator|,
name|ncc
operator|--
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|TS_CR
case|:
name|state
operator|=
name|TS_DATA
expr_stmt|;
comment|/* Strip off \n or \0 after a \r */
if|if
condition|(
operator|(
name|c
operator|==
literal|0
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|TS_DATA
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|state
operator|=
name|TS_IAC
expr_stmt|;
break|break;
block|}
comment|/* 			 * We now map \r\n ==> \r for pragmatic reasons. 			 * Many client implementations send \r\n when 			 * the user hits the CarriageReturn key. 			 * 			 * We USED to map \r\n ==> \n, since \r\n says 			 * that we want to be in column 1 of the next 			 * printable line, and \n is the standard 			 * unix way of saying that (\r is only good 			 * if CRMOD is set, which it normally is). 			 */
if|if
condition|(
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|&&
operator|(
name|hisopts
index|[
name|TELOPT_BINARY
index|]
operator|==
name|OPT_NO
operator|)
condition|)
block|{
comment|/* 				 * If we are operating in linemode, 				 * convert to local end-of-line. 				 */
if|if
condition|(
operator|(
name|linemode
operator|)
operator|&&
operator|(
name|ncc
operator|>
literal|0
operator|)
operator|&&
operator|(
literal|'\n'
operator|==
operator|*
name|netip
operator|)
condition|)
block|{
name|netip
operator|++
expr_stmt|;
name|ncc
operator|--
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|TS_CR
expr_stmt|;
block|}
block|}
operator|*
name|pfrontp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
name|TS_IAC
case|:
name|gotiac
label|:
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* 			 * Send the process on the pty side an 			 * interrupt.  Do this with a NULL or 			 * interrupt char; depending on the tty mode. 			 */
case|case
name|IP
case|:
name|interrupt
argument_list|()
expr_stmt|;
break|break;
case|case
name|BREAK
case|:
name|sendbrk
argument_list|()
expr_stmt|;
break|break;
comment|/* 			 * Are You There? 			 */
case|case
name|AYT
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nfrontp
argument_list|,
literal|"\r\n[Yes]\r\n"
argument_list|)
expr_stmt|;
name|nfrontp
operator|+=
literal|9
expr_stmt|;
break|break;
comment|/* 			 * Abort Output 			 */
case|case
name|AO
case|:
block|{
name|ptyflush
argument_list|()
expr_stmt|;
comment|/* half-hearted */
name|init_termbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|slctab
index|[
name|SLC_AO
index|]
operator|.
name|sptr
operator|&&
operator|*
name|slctab
index|[
name|SLC_AO
index|]
operator|.
name|sptr
operator|!=
operator|(
name|cc_t
operator|)
operator|-
literal|1
condition|)
block|{
operator|*
name|pfrontp
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|slctab
index|[
name|SLC_AO
index|]
operator|.
name|sptr
expr_stmt|;
block|}
name|netclear
argument_list|()
expr_stmt|;
comment|/* clear buffer back */
operator|*
name|nfrontp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|nfrontp
operator|++
operator|=
name|DM
expr_stmt|;
name|neturg
operator|=
name|nfrontp
operator|-
literal|1
expr_stmt|;
comment|/* off by one XXX */
break|break;
block|}
comment|/* 			 * Erase Character and 			 * Erase Line 			 */
case|case
name|EC
case|:
case|case
name|EL
case|:
block|{
name|cc_t
name|ch
decl_stmt|;
name|ptyflush
argument_list|()
expr_stmt|;
comment|/* half-hearted */
name|init_termbuf
argument_list|()
expr_stmt|;
name|ch
operator|=
operator|(
name|c
operator|==
name|EC
operator|)
condition|?
operator|*
name|slctab
index|[
name|SLC_EC
index|]
operator|.
name|sptr
else|:
operator|*
name|slctab
index|[
name|SLC_EL
index|]
operator|.
name|sptr
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
operator|(
name|cc_t
operator|)
operator|-
literal|1
condition|)
operator|*
name|pfrontp
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|ch
expr_stmt|;
break|break;
block|}
comment|/* 			 * Check for urgent data... 			 */
case|case
name|DM
case|:
name|SYNCHing
operator|=
name|stilloob
argument_list|(
name|net
argument_list|)
expr_stmt|;
name|settimer
argument_list|(
name|gotDM
argument_list|)
expr_stmt|;
break|break;
comment|/* 			 * Begin option subnegotiation... 			 */
case|case
name|SB
case|:
name|state
operator|=
name|TS_SB
expr_stmt|;
name|SB_CLEAR
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|WILL
case|:
name|state
operator|=
name|TS_WILL
expr_stmt|;
continue|continue;
case|case
name|WONT
case|:
name|state
operator|=
name|TS_WONT
expr_stmt|;
continue|continue;
case|case
name|DO
case|:
name|state
operator|=
name|TS_DO
expr_stmt|;
continue|continue;
case|case
name|DONT
case|:
name|state
operator|=
name|TS_DONT
expr_stmt|;
continue|continue;
case|case
name|EOR
case|:
if|if
condition|(
name|hisopts
index|[
name|TELOPT_EOR
index|]
condition|)
name|doeof
argument_list|()
expr_stmt|;
break|break;
comment|/* 			 * Handle RFC 10xx Telnet linemode option additions 			 * to command stream (EOF, SUSP, ABORT). 			 */
case|case
name|xEOF
case|:
name|doeof
argument_list|()
expr_stmt|;
break|break;
case|case
name|SUSP
case|:
name|sendsusp
argument_list|()
expr_stmt|;
break|break;
case|case
name|ABORT
case|:
name|sendbrk
argument_list|()
expr_stmt|;
break|break;
case|case
name|IAC
case|:
operator|*
name|pfrontp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|state
operator|=
name|TS_DATA
expr_stmt|;
break|break;
case|case
name|TS_SB
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|state
operator|=
name|TS_SE
expr_stmt|;
block|}
else|else
block|{
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TS_SE
case|:
if|if
condition|(
name|c
operator|!=
name|SE
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|IAC
condition|)
block|{
comment|/* 					 * bad form of suboption negotiation. 					 * handle it in such a way as to avoid 					 * damage to local state.  Parse 					 * suboption buffer found so far, 					 * then treat remaining stream as 					 * another command sequence. 					 */
name|SB_TERM
argument_list|()
expr_stmt|;
name|suboption
argument_list|()
expr_stmt|;
name|state
operator|=
name|TS_IAC
expr_stmt|;
goto|goto
name|gotiac
goto|;
block|}
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_SB
expr_stmt|;
block|}
else|else
block|{
name|SB_TERM
argument_list|()
expr_stmt|;
name|suboption
argument_list|()
expr_stmt|;
comment|/* handle sub-option */
name|state
operator|=
name|TS_DATA
expr_stmt|;
block|}
break|break;
case|case
name|TS_WILL
case|:
name|willoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_WONT
case|:
name|wontoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DO
case|:
name|dooption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DONT
case|:
name|dontoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
default|default:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"telnetd: panic state=%d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"telnetd: panic state=%d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|CRAY2
argument_list|)
operator|&&
name|defined
argument_list|(
name|UNICOS5
argument_list|)
if|if
condition|(
operator|!
name|linemode
condition|)
block|{
name|char
name|xptyobuf
index|[
name|BUFSIZ
operator|+
name|NETSLOP
index|]
decl_stmt|;
name|char
name|xbuf2
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|n
init|=
name|pfrontp
operator|-
name|opfrontp
decl_stmt|,
name|oc
decl_stmt|;
name|bcopy
argument_list|(
name|opfrontp
argument_list|,
name|xptyobuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|pfrontp
operator|=
name|opfrontp
expr_stmt|;
name|pfrontp
operator|+=
name|term_input
argument_list|(
name|xptyobuf
argument_list|,
name|pfrontp
argument_list|,
name|n
argument_list|,
name|BUFSIZ
operator|+
name|NETSLOP
argument_list|,
name|xbuf2
argument_list|,
operator|&
name|oc
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|xbuf2
init|;
name|oc
operator|>
literal|0
condition|;
operator|--
name|oc
control|)
if|if
condition|(
operator|(
operator|*
name|nfrontp
operator|++
operator|=
operator|*
name|cp
operator|++
operator|)
operator|==
name|IAC
condition|)
operator|*
name|nfrontp
operator|++
operator|=
name|IAC
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(CRAY2)&& defined(UNICOS5) */
block|}
end_block

begin_comment
comment|/* end of telrcv */
end_comment

begin_comment
comment|/*  * The will/wont/do/dont state machines are based on Dave Borman's  * Telnet option processing state machine.  We keep track of the full  * state of the option negotiation with the following state variables  *	myopts, hisopts - The last fully negotiated state for each  *			side of the connection.  *	mywants, hiswants - The state we wish to be in after a completed  *			negotiation.  (hiswants is slightly misleading,  *			this is more precisely the state I want him to  *			be in.  *	resp - We count the number of requests we have sent out.  *  * These correspond to the following states:  *	my_state = the last negotiated state  *	want_state = what I want the state to go to  *	want_resp = how many requests I have sent  * All state defaults are negative, and resp defaults to 0.  *  * When initiating a request to change state to new_state:  *   * if ((want_resp == 0&& new_state == my_state) || want_state == new_state) {  *	do nothing;  * } else {  *	want_state = new_state;  *	send new_state;  *	want_resp++;  * }  *  * When receiving new_state:  *  * if (want_resp) {  *	want_resp--;  *	if (want_resp&& (new_state == my_state))  *		want_resp--;  * }  * if ((want_resp == 0)&& (new_state != want_state)) {  *	if (ok_to_switch_to new_state)  *		want_state = new_state;  *	else  *		want_resp++;  *	send want_state;  * }  * my_state = new_state;  *  * Note that new_state is implied in these functions by the function itself.  * will and do imply positive new_state, wont and dont imply negative.  *  * Finally, there is one catch.  If we send a negative response to a  * positive request, my_state will be the positive while want_state will  * remain negative.  my_state will revert to negative when the negative  * acknowlegment arrives from the peer.  Thus, my_state generally tells  * us not only the last negotiated state, but also tells us what the peer  * wants to be doing as well.  It is important to understand this difference  * as we may wish to be processing data streams based on our desired state  * (want_state) or based on what the peer thinks the state is (my_state).  *  * This all works fine because if the peer sends a positive request, the data  * that we receive prior to negative acknowlegment will probably be affected  * by the positive state, and we can process it as such (if we can; if we  * can't then it really doesn't matter).  If it is that important, then the  * peer probably should be buffering until this option state negotiation  * is complete.  *  */
end_comment

begin_macro
name|send_do
argument_list|(
argument|option
argument_list|,
argument|init
argument_list|)
end_macro

begin_decl_stmt
name|int
name|option
decl_stmt|,
name|init
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|&&
name|hisopts
index|[
name|option
index|]
operator|==
name|OPT_YES
operator|)
operator|||
name|hiswants
index|[
name|option
index|]
operator|==
name|OPT_YES
condition|)
return|return;
comment|/* 		 * Special case for TELOPT_TM:  We send a DO, but pretend 		 * that we sent a DONT, so that we can send more DOs if 		 * we want to. 		 */
if|if
condition|(
name|option
operator|==
name|TELOPT_TM
condition|)
name|hiswants
index|[
name|option
index|]
operator|=
name|OPT_NO
expr_stmt|;
else|else
name|hiswants
index|[
name|option
index|]
operator|=
name|OPT_YES
expr_stmt|;
name|do_dont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|nfrontp
argument_list|,
name|doopt
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|nfrontp
operator|+=
sizeof|sizeof
argument_list|(
name|dont
argument_list|)
operator|-
literal|2
expr_stmt|;
block|}
end_block

begin_macro
name|willoption
argument_list|(
argument|option
argument_list|)
end_macro

begin_decl_stmt
name|int
name|option
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|changeok
init|=
literal|0
decl_stmt|;
comment|/* 	 * process input from peer. 	 */
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
condition|)
block|{
name|do_dont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|&&
name|hisopts
index|[
name|option
index|]
operator|==
name|OPT_YES
condition|)
name|do_dont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hiswants
index|[
name|option
index|]
operator|!=
name|OPT_YES
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_BINARY
case|:
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_binaryin
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_ECHO
case|:
name|not42
operator|=
literal|0
expr_stmt|;
comment|/* looks like a 4.2 system */
ifdef|#
directive|ifdef
name|notdef
comment|/* 			 * Now, in a 4.2 system, to break them out of 			 * ECHOing (to the terminal) mode, we need to 			 * send a WILL ECHO. 			 */
if|if
condition|(
name|myopts
index|[
name|TELOPT_ECHO
index|]
operator|==
name|OPT_YES
condition|)
block|{
name|send_will
argument_list|(
name|TELOPT_ECHO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* 			 * "WILL ECHO".  Kludge upon kludge! 			 * A 4.2 client is now echoing user input at 			 * the tty.  This is probably undesireable and 			 * it should be stopped.  The client will 			 * respond WONT TM to the DO TM that we send to 			 * check for kludge linemode.  When the WONT TM 			 * arrives, linemode will be turned off and a 			 * change propogated to the pty.  This change 			 * will cause us to process the new pty state 			 * in localstat(), which will notice that 			 * linemode is off and send a WILL ECHO 			 * so that we are properly in character mode and 			 * all is well. 			 */
endif|#
directive|endif
comment|/* 			 * Fool the state machine into sending a don't. 			 * This also allows the initial echo sending 			 * code to break out of the loop that it is 			 * in.  (Look in telnet()) 			 */
name|hiswants
index|[
name|TELOPT_ECHO
index|]
operator|=
name|OPT_NO
expr_stmt|;
break|break;
case|case
name|TELOPT_TM
case|:
if|#
directive|if
name|defined
argument_list|(
name|LINEMODE
argument_list|)
operator|&&
name|defined
argument_list|(
name|KLUDGELINEMODE
argument_list|)
comment|/* 			 * This telnetd implementation does not really 			 * support timing marks, it just uses them to 			 * support the kludge linemode stuff.  If we 			 * receive a will or wont TM in response to our 			 * do TM request that may have been sent to 			 * determine kludge linemode support, process 			 * it, otherwise TM should get a negative 			 * response back. 			 */
comment|/* 			 * Handle the linemode kludge stuff. 			 * If we are not currently supporting any 			 * linemode at all, then we assume that this 			 * is the client telling us to use kludge 			 * linemode in response to our query.  Set the 			 * linemode type that is to be supported, note 			 * that the client wishes to use linemode, and 			 * eat the will TM as though it never arrived. 			 */
if|if
condition|(
name|lmodetype
operator|<
name|KLUDGE_LINEMODE
condition|)
block|{
name|lmodetype
operator|=
name|KLUDGE_LINEMODE
expr_stmt|;
name|clientstat
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
name|WILL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_wont
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(LINEMODE)&& defined(KLUDGELINEMODE) */
comment|/* 			 * We never respond to a WILL TM, and 			 * we leave the state OPT_NO. 			 */
return|return;
case|case
name|TELOPT_LFLOW
case|:
comment|/* 			 * If we are going to support flow control 			 * option, then don't worry peer that we can't 			 * change the flow control characters. 			 */
name|slctab
index|[
name|SLC_XON
index|]
operator|.
name|defset
operator|.
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|slctab
index|[
name|SLC_XON
index|]
operator|.
name|defset
operator|.
name|flag
operator||=
name|SLC_DEFAULT
expr_stmt|;
name|slctab
index|[
name|SLC_XOFF
index|]
operator|.
name|defset
operator|.
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|slctab
index|[
name|SLC_XOFF
index|]
operator|.
name|defset
operator|.
name|flag
operator||=
name|SLC_DEFAULT
expr_stmt|;
case|case
name|TELOPT_TTYPE
case|:
case|case
name|TELOPT_SGA
case|:
case|case
name|TELOPT_NAWS
case|:
case|case
name|TELOPT_TSPEED
case|:
name|changeok
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|LINEMODE
case|case
name|TELOPT_LINEMODE
case|:
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
comment|/* 			 * Note client's desire to use linemode. 			 */
name|lmodetype
operator|=
name|REAL_LINEMODE
expr_stmt|;
endif|#
directive|endif
comment|/* KLUDGELINEMODE */
name|clientstat
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
name|WILL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|changeok
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* LINEMODE */
default|default:
break|break;
block|}
if|if
condition|(
name|changeok
condition|)
block|{
name|hiswants
index|[
name|option
index|]
operator|=
name|OPT_YES
expr_stmt|;
name|send_do
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_dont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
name|send_dont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|hisopts
index|[
name|option
index|]
operator|=
name|OPT_YES
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of willoption */
end_comment

begin_macro
name|send_dont
argument_list|(
argument|option
argument_list|,
argument|init
argument_list|)
end_macro

begin_decl_stmt
name|int
name|option
decl_stmt|,
name|init
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|&&
name|hisopts
index|[
name|option
index|]
operator|==
name|OPT_NO
operator|)
operator|||
name|hiswants
index|[
name|option
index|]
operator|==
name|OPT_NO
condition|)
return|return;
name|hiswants
index|[
name|option
index|]
operator|=
name|OPT_NO
expr_stmt|;
name|do_dont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|nfrontp
argument_list|,
name|dont
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|nfrontp
operator|+=
sizeof|sizeof
argument_list|(
name|doopt
argument_list|)
operator|-
literal|2
expr_stmt|;
block|}
end_block

begin_macro
name|wontoption
argument_list|(
argument|option
argument_list|)
end_macro

begin_decl_stmt
name|int
name|option
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|fmt
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* 	 * Process client input. 	 */
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
condition|)
block|{
name|do_dont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|&&
name|hisopts
index|[
name|option
index|]
operator|==
name|OPT_NO
condition|)
name|do_dont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hiswants
index|[
name|option
index|]
operator|!=
name|OPT_NO
condition|)
block|{
comment|/* it is always ok to change to negative state */
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
name|not42
operator|=
literal|1
expr_stmt|;
comment|/* doesn't seem to be a 4.2 system */
break|break;
case|case
name|TELOPT_BINARY
case|:
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_binaryin
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|LINEMODE
case|case
name|TELOPT_LINEMODE
case|:
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
comment|/* 			 * If real linemode is supported, then client is 			 * asking to turn linemode off. 			 */
if|if
condition|(
name|lmodetype
operator|==
name|REAL_LINEMODE
condition|)
endif|#
directive|endif
comment|/* KLUDGELINEMODE */
name|clientstat
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
name|WONT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|LINEMODE
case|case
name|TELOPT_TM
case|:
comment|/* 			 * If we get a WONT TM, and had sent a DO TM, 			 * don't respond with a DONT TM, just leave it 			 * as is.  Short circut the state machine to 			 * achive this. 			 */
name|hiswants
index|[
name|TELOPT_TM
index|]
operator|=
name|OPT_NO
expr_stmt|;
return|return;
case|case
name|TELOPT_LFLOW
case|:
comment|/* 			 * If we are not going to support flow control 			 * option, then let peer know that we can't 			 * change the flow control characters. 			 */
name|slctab
index|[
name|SLC_XON
index|]
operator|.
name|defset
operator|.
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|slctab
index|[
name|SLC_XON
index|]
operator|.
name|defset
operator|.
name|flag
operator||=
name|SLC_CANTCHANGE
expr_stmt|;
name|slctab
index|[
name|SLC_XOFF
index|]
operator|.
name|defset
operator|.
name|flag
operator|&=
operator|~
name|SLC_LEVELBITS
expr_stmt|;
name|slctab
index|[
name|SLC_XOFF
index|]
operator|.
name|defset
operator|.
name|flag
operator||=
name|SLC_CANTCHANGE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|hiswants
index|[
name|option
index|]
operator|=
name|OPT_NO
expr_stmt|;
name|fmt
operator|=
name|dont
expr_stmt|;
name|send_dont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_TM
case|:
if|#
directive|if
name|defined
argument_list|(
name|LINEMODE
argument_list|)
operator|&&
name|defined
argument_list|(
name|KLUDGELINEMODE
argument_list|)
if|if
condition|(
name|lmodetype
operator|<
name|REAL_LINEMODE
condition|)
block|{
name|lmodetype
operator|=
name|NO_LINEMODE
expr_stmt|;
name|clientstat
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
name|WONT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*@*/
name|send_will
argument_list|(
name|TELOPT_ECHO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(LINEMODE)&& defined(KLUDGELINEMODE) */
default|default:
break|break;
block|}
block|}
block|}
name|hisopts
index|[
name|option
index|]
operator|=
name|OPT_NO
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of wontoption */
end_comment

begin_macro
name|send_will
argument_list|(
argument|option
argument_list|,
argument|init
argument_list|)
end_macro

begin_decl_stmt
name|int
name|option
decl_stmt|,
name|init
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|&&
name|myopts
index|[
name|option
index|]
operator|==
name|OPT_YES
operator|)
operator|||
name|mywants
index|[
name|option
index|]
operator|==
name|OPT_YES
condition|)
return|return;
name|mywants
index|[
name|option
index|]
operator|=
name|OPT_YES
expr_stmt|;
name|will_wont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|nfrontp
argument_list|,
name|will
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|nfrontp
operator|+=
sizeof|sizeof
argument_list|(
name|doopt
argument_list|)
operator|-
literal|2
expr_stmt|;
block|}
end_block

begin_macro
name|dooption
argument_list|(
argument|option
argument_list|)
end_macro

begin_decl_stmt
name|int
name|option
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|changeok
init|=
literal|0
decl_stmt|;
comment|/* 	 * Process client input. 	 */
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
condition|)
block|{
name|will_wont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
operator|&&
name|myopts
index|[
name|option
index|]
operator|==
name|OPT_YES
condition|)
name|will_wont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mywants
index|[
name|option
index|]
operator|!=
name|OPT_YES
operator|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
ifdef|#
directive|ifdef
name|LINEMODE
if|if
condition|(
name|lmodetype
operator|==
name|NO_LINEMODE
condition|)
block|{
endif|#
directive|endif
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_setecho
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LINEMODE
block|}
endif|#
directive|endif
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_BINARY
case|:
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_binaryout
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_SGA
case|:
if|#
directive|if
name|defined
argument_list|(
name|LINEMODE
argument_list|)
operator|&&
name|defined
argument_list|(
name|KLUDGELINEMODE
argument_list|)
comment|/* 			 * If kludge linemode is in use, then we must 			 * process an incoming do SGA for linemode 			 * purposes. 			 */
if|if
condition|(
name|lmodetype
operator|==
name|KLUDGE_LINEMODE
condition|)
block|{
comment|/* 				 * Receipt of "do SGA" in kludge 				 * linemode is the peer asking us to 				 * turn off linemode.  Make note of 				 * the request. 				 */
name|clientstat
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
name|WONT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * If linemode did not get turned off 				 * then don't tell peer that we did. 				 * Breaking here forces a wont SGA to 				 * be returned. 				 */
if|if
condition|(
name|linemode
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* defined(LINEMODE)&& defined(KLUDGELINEMODE) */
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_STATUS
case|:
name|changeok
operator|++
expr_stmt|;
break|break;
case|case
name|TELOPT_TM
case|:
comment|/* 			 * Special case for TM.  We send a WILL, but 			 * pretend we sent a WONT. 			 */
name|send_will
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mywants
index|[
name|option
index|]
operator|=
name|OPT_NO
expr_stmt|;
name|myopts
index|[
name|option
index|]
operator|=
name|OPT_NO
expr_stmt|;
return|return;
case|case
name|TELOPT_LINEMODE
case|:
case|case
name|TELOPT_TTYPE
case|:
case|case
name|TELOPT_NAWS
case|:
case|case
name|TELOPT_TSPEED
case|:
case|case
name|TELOPT_LFLOW
case|:
default|default:
break|break;
block|}
if|if
condition|(
name|changeok
condition|)
block|{
name|mywants
index|[
name|option
index|]
operator|=
name|OPT_YES
expr_stmt|;
name|send_will
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|will_wont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
name|send_wont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|myopts
index|[
name|option
index|]
operator|=
name|OPT_YES
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of dooption */
end_comment

begin_macro
name|send_wont
argument_list|(
argument|option
argument_list|,
argument|init
argument_list|)
end_macro

begin_decl_stmt
name|int
name|option
decl_stmt|,
name|init
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|&&
name|myopts
index|[
name|option
index|]
operator|==
name|OPT_NO
operator|)
operator|||
name|mywants
index|[
name|option
index|]
operator|==
name|OPT_NO
condition|)
return|return;
name|mywants
index|[
name|option
index|]
operator|=
name|OPT_NO
expr_stmt|;
name|will_wont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|nfrontp
argument_list|,
name|wont
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|nfrontp
operator|+=
sizeof|sizeof
argument_list|(
name|wont
argument_list|)
operator|-
literal|2
expr_stmt|;
block|}
end_block

begin_macro
name|dontoption
argument_list|(
argument|option
argument_list|)
end_macro

begin_decl_stmt
name|int
name|option
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * Process client input. 	 */
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
condition|)
block|{
name|will_wont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
operator|&&
name|myopts
index|[
name|option
index|]
operator|==
name|OPT_NO
condition|)
name|will_wont_resp
index|[
name|option
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mywants
index|[
name|option
index|]
operator|!=
name|OPT_NO
operator|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_BINARY
case|:
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_binaryout
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
break|break;
case|case
name|TELOPT_ECHO
case|:
comment|/* we should stop echoing */
ifdef|#
directive|ifdef
name|LINEMODE
if|if
condition|(
name|lmodetype
operator|==
name|NO_LINEMODE
condition|)
block|{
endif|#
directive|endif
name|init_termbuf
argument_list|()
expr_stmt|;
name|tty_setecho
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_termbuf
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LINEMODE
block|}
endif|#
directive|endif
break|break;
case|case
name|TELOPT_SGA
case|:
if|#
directive|if
name|defined
argument_list|(
name|LINEMODE
argument_list|)
operator|&&
name|defined
argument_list|(
name|KLUDGELINEMODE
argument_list|)
comment|/* 			 * If kludge linemode is in use, then we 			 * must process an incoming do SGA for 			 * linemode purposes. 			 */
if|if
condition|(
name|lmodetype
operator|==
name|KLUDGE_LINEMODE
condition|)
block|{
comment|/* 				 * The client is asking us to turn 				 * linemode on. 				 */
name|clientstat
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
name|WILL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * If we did not turn line mode on, 				 * then what do we say?  Will SGA? 				 * This violates design of telnet. 				 * Gross.  Very Gross. 				 */
block|}
endif|#
directive|endif
comment|/* defined(LINEMODE)&& defined(KLUDGELINEMODE) */
default|default:
break|break;
block|}
name|mywants
index|[
name|option
index|]
operator|=
name|OPT_NO
expr_stmt|;
name|send_wont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|myopts
index|[
name|option
index|]
operator|=
name|OPT_NO
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of dontoption */
end_comment

begin_comment
comment|/*  * suboption()  *  *	Look at the sub-option buffer, and try to be helpful to the other  * side.  *  *	Currently we recognize:  *  *	Terminal type is  *	Linemode  *	Window size  *	Terminal speed  */
end_comment

begin_macro
name|suboption
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|subchar
decl_stmt|;
name|subchar
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|subchar
condition|)
block|{
case|case
name|TELOPT_TSPEED
case|:
block|{
specifier|register
name|int
name|xspeed
decl_stmt|,
name|rspeed
decl_stmt|;
if|if
condition|(
name|hisopts
index|[
name|TELOPT_TSPEED
index|]
operator|==
name|OPT_NO
condition|)
comment|/* Ignore if option disabled */
break|break;
name|settimer
argument_list|(
name|tspeedsubopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
operator|||
name|SB_GET
argument_list|()
operator|!=
name|TELQUAL_IS
condition|)
return|return;
name|xspeed
operator|=
name|atoi
argument_list|(
name|subpointer
argument_list|)
expr_stmt|;
while|while
condition|(
name|SB_GET
argument_list|()
operator|!=
literal|','
operator|&&
operator|!
name|SB_EOF
argument_list|()
condition|)
empty_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|rspeed
operator|=
name|atoi
argument_list|(
name|subpointer
argument_list|)
expr_stmt|;
name|clientstat
argument_list|(
name|TELOPT_TSPEED
argument_list|,
name|xspeed
argument_list|,
name|rspeed
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end of case TELOPT_TSPEED */
case|case
name|TELOPT_TTYPE
case|:
block|{
comment|/* Yaaaay! */
specifier|static
name|char
name|terminalname
index|[
literal|5
operator|+
literal|41
index|]
init|=
literal|"TERM="
decl_stmt|;
if|if
condition|(
name|hisopts
index|[
name|TELOPT_TTYPE
index|]
operator|==
name|OPT_NO
condition|)
comment|/* Ignore if option disabled */
break|break;
name|settimer
argument_list|(
name|ttypesubopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|SB_GET
argument_list|()
operator|!=
name|TELQUAL_IS
condition|)
block|{
return|return;
comment|/* ??? XXX but, this is the most robust */
block|}
name|terminaltype
operator|=
name|terminalname
operator|+
sizeof|sizeof
argument_list|(
literal|"TERM="
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|terminaltype
operator|<
operator|(
name|terminalname
operator|+
sizeof|sizeof
name|terminalname
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|!
name|SB_EOF
argument_list|()
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
operator|*
name|terminaltype
operator|++
operator|=
name|c
expr_stmt|;
comment|/* accumulate name */
block|}
operator|*
name|terminaltype
operator|=
literal|0
expr_stmt|;
name|terminaltype
operator|=
name|terminalname
expr_stmt|;
break|break;
block|}
comment|/* end of case TELOPT_TTYPE */
case|case
name|TELOPT_NAWS
case|:
block|{
specifier|register
name|int
name|xwinsize
decl_stmt|,
name|ywinsize
decl_stmt|;
if|if
condition|(
name|hisopts
index|[
name|TELOPT_NAWS
index|]
operator|==
name|OPT_NO
condition|)
comment|/* Ignore if option disabled */
break|break;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|xwinsize
operator|=
name|SB_GET
argument_list|()
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|xwinsize
operator||=
name|SB_GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|ywinsize
operator|=
name|SB_GET
argument_list|()
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
return|return;
name|ywinsize
operator||=
name|SB_GET
argument_list|()
expr_stmt|;
name|clientstat
argument_list|(
name|TELOPT_NAWS
argument_list|,
name|xwinsize
argument_list|,
name|ywinsize
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end of case TELOPT_NAWS */
ifdef|#
directive|ifdef
name|LINEMODE
case|case
name|TELOPT_LINEMODE
case|:
block|{
specifier|register
name|int
name|request
decl_stmt|;
if|if
condition|(
name|hisopts
index|[
name|TELOPT_LINEMODE
index|]
operator|==
name|OPT_NO
condition|)
comment|/* Ignore if option disabled */
break|break;
comment|/* 	 * Process linemode suboptions. 	 */
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
break|break;
comment|/* garbage was sent */
name|request
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
comment|/* get will/wont */
if|if
condition|(
name|SB_EOF
argument_list|()
condition|)
break|break;
comment|/* another garbage check */
if|if
condition|(
name|request
operator|==
name|LM_SLC
condition|)
block|{
comment|/* SLC is not preceeded by WILL or WONT */
comment|/* 		 * Process suboption buffer of slc's 		 */
name|start_slc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|do_opt_slc
argument_list|(
name|subpointer
argument_list|,
name|subend
operator|-
name|subpointer
argument_list|)
expr_stmt|;
name|end_slc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|==
name|LM_MODE
condition|)
block|{
name|useeditmode
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
comment|/* get mode flag */
name|clientstat
argument_list|(
name|LM_MODE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|SB_GET
argument_list|()
condition|)
block|{
comment|/* what suboption? */
case|case
name|LM_FORWARDMASK
case|:
comment|/* 		 * According to spec, only server can send request for 		 * forwardmask, and client can only return a positive response. 		 * So don't worry about it. 		 */
default|default:
break|break;
block|}
break|break;
block|}
comment|/* end of case TELOPT_LINEMODE */
endif|#
directive|endif
case|case
name|TELOPT_STATUS
case|:
block|{
name|int
name|mode
decl_stmt|;
name|mode
operator|=
name|SB_GET
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TELQUAL_SEND
case|:
if|if
condition|(
name|myopts
index|[
name|TELOPT_STATUS
index|]
operator|==
name|OPT_YES
condition|)
name|send_status
argument_list|()
expr_stmt|;
break|break;
case|case
name|TELQUAL_IS
case|:
break|break;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* end of case TELOPT_STATUS */
default|default:
break|break;
block|}
comment|/* end of switch */
block|}
end_block

begin_comment
comment|/* end of suboption */
end_comment

begin_define
define|#
directive|define
name|ADD
parameter_list|(
name|c
parameter_list|)
value|*ncp++ = c;
end_define

begin_define
define|#
directive|define
name|ADD_DATA
parameter_list|(
name|c
parameter_list|)
value|{ *ncp++ = c; if (c == SE) *ncp++ = c; }
end_define

begin_macro
name|send_status
argument_list|()
end_macro

begin_block
block|{
name|char
name|statusbuf
index|[
literal|256
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|ncp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|ncp
operator|=
name|statusbuf
expr_stmt|;
name|netflush
argument_list|()
expr_stmt|;
comment|/* get rid of anything waiting to go out */
name|ADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|SB
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELOPT_STATUS
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELQUAL_IS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTELOPTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|myopts
index|[
name|i
index|]
operator|==
name|OPT_YES
condition|)
block|{
name|ADD
argument_list|(
name|WILL
argument_list|)
expr_stmt|;
name|ADD_DATA
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|IAC
condition|)
name|ADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hisopts
index|[
name|i
index|]
operator|==
name|OPT_YES
condition|)
block|{
name|ADD
argument_list|(
name|DO
argument_list|)
expr_stmt|;
name|ADD_DATA
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|IAC
condition|)
name|ADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|LINEMODE
if|if
condition|(
name|hisopts
index|[
name|TELOPT_LINEMODE
index|]
operator|==
name|OPT_YES
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpe
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ADD
argument_list|(
name|SB
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|LM_MODE
argument_list|)
expr_stmt|;
name|ADD_DATA
argument_list|(
name|editmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|editmode
operator|==
name|IAC
condition|)
name|ADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|SE
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|SB
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|LM_SLC
argument_list|)
expr_stmt|;
name|start_slc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|send_slc
argument_list|()
expr_stmt|;
name|len
operator|=
name|end_slc
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|cpe
operator|=
name|cp
operator|+
name|len
init|;
name|cp
operator|<
name|cpe
condition|;
name|cp
operator|++
control|)
name|ADD_DATA
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|SE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LINEMODE */
name|ADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|SE
argument_list|)
expr_stmt|;
name|writenet
argument_list|(
name|statusbuf
argument_list|,
name|ncp
operator|-
name|statusbuf
argument_list|)
expr_stmt|;
name|netflush
argument_list|()
expr_stmt|;
comment|/* Send it on its way */
block|}
end_block

end_unit

