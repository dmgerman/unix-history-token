begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs_extern.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"clean.h"
end_include

begin_comment
comment|/*  * fs_getmntinfo:  *  *    This function will get information on all mounted file systems  * of a given type.  */
end_comment

begin_function
name|int
name|fs_getmntinfo
parameter_list|(
name|buf
parameter_list|,
name|type
parameter_list|)
name|struct
name|statfs
modifier|*
modifier|*
name|buf
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|tcount
decl_stmt|;
name|struct
name|statfs
modifier|*
name|tstatfsp
decl_stmt|;
name|tcount
operator|=
name|getmntinfo
argument_list|(
operator|&
name|tstatfsp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcount
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fs_getmntinfo: getmntinfo failed"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|type
operator|==
literal|0
operator|||
name|tstatfsp
index|[
name|i
index|]
operator|.
name|f_type
operator|==
name|type
condition|)
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
operator|*
name|buf
operator|=
operator|(
expr|struct
name|statfs
operator|*
operator|)
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|statfs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fs_getmntinfo: out of space"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|<
name|tcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|==
literal|0
operator|||
name|tstatfsp
index|[
name|i
index|]
operator|.
name|f_type
operator|==
name|type
condition|)
block|{
operator|(
operator|*
name|buf
operator|)
index|[
name|count
index|]
operator|=
name|tstatfsp
index|[
name|i
index|]
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * get_fs_info:  *  * get all the information available on a file system  */
end_comment

begin_function
name|int
name|get_fs_info
parameter_list|(
name|lstatfsp
parameter_list|,
name|fspp
parameter_list|,
name|count
parameter_list|)
name|struct
name|statfs
modifier|*
name|lstatfsp
decl_stmt|;
comment|/* IN: array of statfs structs */
name|FS_INFO
modifier|*
modifier|*
name|fspp
decl_stmt|;
comment|/* OUT: resulting array of FS_INFOs */
name|int
name|count
decl_stmt|;
comment|/* IN: number of file systems */
block|{
name|int
name|i
decl_stmt|;
name|caddr_t
name|ifp
decl_stmt|;
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
operator|*
name|fspp
operator|=
operator|(
name|FS_INFO
operator|*
operator|)
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|FS_INFO
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|fsp
operator|=
operator|*
name|fspp
operator|+
name|i
expr_stmt|;
name|statfsp
operator|=
name|lstatfsp
operator|+
name|i
expr_stmt|;
name|lfsp
operator|=
operator|(
expr|struct
name|lfs
operator|*
operator|)
name|malloc
argument_list|(
name|LFS_SBPAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_superblock
argument_list|(
name|fsp
argument_list|,
name|lfsp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"get_fs_info: get_superblock failed"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fsp
operator|->
name|fi_daddr_shift
operator|=
name|lfsp
operator|->
name|lfs_bshift
operator|-
name|lfsp
operator|->
name|lfs_fsbtodb
expr_stmt|;
if|if
condition|(
name|get_ifile
argument_list|(
name|fsp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"get_fs_info: get_ifile failed"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* this is needed temporarily, because of the bug in mmap'ed files */
end_comment

begin_function
name|void
name|free_fs_info
parameter_list|(
name|fsp
parameter_list|,
name|count
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* IN: array of fs_infos we will dispose of */
name|int
name|count
decl_stmt|;
comment|/* IN: number of file systems */
block|{
name|int
name|i
decl_stmt|;
name|caddr_t
name|fsp_base
init|=
operator|(
name|caddr_t
operator|)
name|fsp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|fsp
operator|++
control|)
block|{
comment|/* free superblock */
name|free
argument_list|(
name|lfsp
argument_list|)
expr_stmt|;
comment|/* sdp points to the beginning of the ifile area */
ifndef|#
directive|ifndef
name|MMAP_WORKS
name|free
argument_list|(
name|cip
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|munmap
argument_list|(
name|cip
argument_list|,
name|ifile_length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"free_fs_info: munmap failed\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MMAP_WORKS */
block|}
name|free
argument_list|(
name|fsp_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * get_superblock:   *    gets the superblock from disk (possibly in face of errors)   */
end_comment

begin_function
name|int
name|get_superblock
parameter_list|(
name|fsp
parameter_list|,
name|sbp
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* IN: array of fs_infos we will dispose of */
name|struct
name|lfs
modifier|*
name|sbp
decl_stmt|;
block|{
name|int
name|fid
decl_stmt|;
name|char
name|mntfromname
index|[
name|MNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|mntfromname
argument_list|,
literal|"/dev/r"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|mntfromname
argument_list|,
name|statfsp
operator|->
name|f_mntfromname
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fid
operator|=
name|open
argument_list|(
name|mntfromname
argument_list|,
name|O_RDONLY
argument_list|,
operator|(
name|mode_t
operator|)
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"get_superblock: bad open"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fid
argument_list|,
name|LFS_LABELPAD
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|LFS_LABELPAD
condition|)
block|{
name|perror
argument_list|(
literal|"get_superblock: bad seek"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sbp
argument_list|,
name|LFS_SBPAD
argument_list|)
operator|!=
name|LFS_SBPAD
condition|)
block|{
name|perror
argument_list|(
literal|"get_superblock: bad read"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|close
argument_list|(
name|fid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * get_ifile:   *    This function will map the ifile into memory.  It returns  * NULL on failure.  */
end_comment

begin_function
name|int
name|get_ifile
parameter_list|(
name|fsp
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
block|{
name|int
name|fid
decl_stmt|;
name|int
name|count
decl_stmt|;
name|caddr_t
name|ifp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ifile_name
decl_stmt|;
name|struct
name|stat
name|file_stat
decl_stmt|;
name|ifile_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|statfsp
operator|->
name|f_mntonname
argument_list|)
operator|+
name|strlen
argument_list|(
name|IFILE_NAME
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ifile_name
argument_list|,
name|statfsp
operator|->
name|f_mntonname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ifile_name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ifile_name
argument_list|,
name|IFILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fid
operator|=
name|open
argument_list|(
name|ifile_name
argument_list|,
name|O_RDWR
argument_list|,
operator|(
name|mode_t
operator|)
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"get_ifile: bad open"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fid
argument_list|,
operator|&
name|file_stat
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"get_ifile: fstat failed"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ifile_length
operator|=
name|file_stat
operator|.
name|st_size
expr_stmt|;
comment|/* get the ifile */
ifndef|#
directive|ifndef
name|MMAP_WORKS
name|ifp
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|ifile_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"get_ifile: malloc failed, out of memory?"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|count
operator|=
name|read
argument_list|(
name|fid
argument_list|,
name|ifp
argument_list|,
name|ifile_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
name|ifile_length
condition|)
block|{
name|perror
argument_list|(
literal|"get_ifile: bad ifile read"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
comment|/* MMAP_WORKS */
name|ifp
operator|=
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ifile_length
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_FILE
operator||
name|MAP_SHARED
argument_list|,
name|fid
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"get_ifile: mmap failed"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
comment|/* MMAP_WORKS */
name|close
argument_list|(
name|fid
argument_list|)
expr_stmt|;
name|cip
operator|=
operator|(
name|CLEANERINFO
operator|*
operator|)
name|ifp
expr_stmt|;
name|segusep
operator|=
operator|(
name|SEGUSE
operator|*
operator|)
operator|(
name|ifp
operator|+
name|CLEANSIZE
argument_list|(
name|lfsp
argument_list|)
operator|)
expr_stmt|;
name|ifilep
operator|=
operator|(
name|IFILE
operator|*
operator|)
operator|(
name|ifp
operator|+
name|CLEANSIZE
argument_list|(
name|lfsp
argument_list|)
operator|+
name|SEGTABSIZE
argument_list|(
name|lfsp
argument_list|)
operator|)
expr_stmt|;
comment|/* # of bytes in ifile table */
name|ifile_count
operator|=
name|ifile_length
operator|-
operator|(
name|CLEANSIZE
argument_list|(
name|lfsp
argument_list|)
operator|+
name|SEGTABSIZE
argument_list|(
name|lfsp
argument_list|)
operator|)
expr_stmt|;
comment|/* # of ifile entries in ifile table */
name|ifile_count
operator|=
operator|(
name|ifile_count
operator|/
name|lfsp
operator|->
name|lfs_bsize
operator|)
operator|*
name|lfsp
operator|->
name|lfs_ifpb
expr_stmt|;
name|free
argument_list|(
name|ifile_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * segmapv:  *  *   This function will scan a segment and return a list of  *<inode, blocknum> pairs which indicate which blocks were  * contained as live data within the segment at some point  * (it may have "died" since then).  Any given pair will be   * listed at most once.  */
end_comment

begin_function
name|int
name|lfs_segmapv
parameter_list|(
name|fsp
parameter_list|,
name|seg
parameter_list|,
name|seg_buf
parameter_list|,
name|blocks
parameter_list|,
name|bcount
parameter_list|,
name|inodes
parameter_list|,
name|icount
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to super block */
name|int
name|seg
decl_stmt|;
comment|/* the segment id */
name|caddr_t
name|seg_buf
decl_stmt|;
comment|/* the buffer containing the segment's data */
comment|/* OUT: array of block_info for live blocks */
name|BLOCK_INFO
modifier|*
modifier|*
name|blocks
decl_stmt|;
name|int
modifier|*
name|bcount
decl_stmt|;
comment|/* OUT: number of active blocks in segment */
comment|/* OUT: array of inode_info for live inodes */
name|INODE_INFO
modifier|*
modifier|*
name|inodes
decl_stmt|;
name|int
modifier|*
name|icount
decl_stmt|;
comment|/* OUT: number of active inodes in segment */
block|{
name|caddr_t
name|s
decl_stmt|;
name|caddr_t
name|endofseg
decl_stmt|;
name|int
name|nextsum
decl_stmt|;
name|u_long
name|sb_off
decl_stmt|;
name|time_t
name|timestamp
decl_stmt|;
operator|*
name|bcount
operator|=
literal|0
expr_stmt|;
operator|*
name|blocks
operator|=
operator|(
name|BLOCK_INFO
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|icount
operator|=
literal|0
expr_stmt|;
operator|*
name|inodes
operator|=
operator|(
name|INODE_INFO
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INODE_INFO
argument_list|)
argument_list|)
expr_stmt|;
name|sb_off
operator|=
operator|(
name|SEGUSE_ENTRY
argument_list|(
name|lfsp
argument_list|,
name|segusep
argument_list|,
name|seg
argument_list|)
operator|->
name|su_flags
operator|&
name|SEGUSE_SUPERBLOCK
operator|)
condition|?
name|LFS_SBPAD
else|:
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|seg_buf
operator|+
name|sb_off
operator|,
name|endofseg
operator|=
name|seg_buf
operator|+
name|seg_size
argument_list|(
name|lfsp
argument_list|)
operator|,
name|timestamp
operator|=
literal|0
init|;
name|s
operator|<
name|endofseg
condition|;
name|s
operator|+=
name|pseg_size
argument_list|(
name|fsp
argument_list|,
operator|(
name|SEGSUM
operator|*
operator|)
name|s
argument_list|)
control|)
block|{
name|BLOCK_INFO
modifier|*
name|pblocks
decl_stmt|;
name|int
name|pbcount
decl_stmt|;
name|INODE_INFO
modifier|*
name|pinodes
decl_stmt|;
name|int
name|picount
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"lfs_segmapv: seg_buf = 0x%x, pseg_buf = 0x%x, offset = %lu (0x%x), pseg = \n\t"
argument_list|,
operator|(
name|u_int
operator|)
name|seg_buf
argument_list|,
operator|(
name|u_int
operator|)
name|s
argument_list|,
operator|(
name|u_int
operator|)
name|s
operator|-
operator|(
name|u_int
operator|)
name|seg_buf
operator|-
operator|(
name|u_int
operator|)
name|sb_off
argument_list|,
operator|(
name|u_int
operator|)
name|s
operator|-
operator|(
name|u_int
operator|)
name|seg_buf
operator|-
operator|(
name|u_int
operator|)
name|sb_off
argument_list|)
expr_stmt|;
comment|/* this can cause core dumps when printing an invalid segsum  *		print_SEGSUM ((SEGSUM*)s);  *		printf("\n");  *		printf("pseg_size = %lu\n", pseg_size(fsp, (SEGSUM*)s));  */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VERBOSE */
comment|/* we have hit the end of the valid data */
if|if
condition|(
operator|!
name|pseg_valid
argument_list|(
name|fsp
argument_list|,
operator|(
name|SEGSUM
operator|*
operator|)
name|s
argument_list|)
condition|)
break|break;
comment|/* we have gone back in time and hit old data */
if|if
condition|(
name|timestamp
operator|>
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
name|s
operator|)
operator|->
name|ss_create
condition|)
break|break;
name|timestamp
operator|=
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
name|s
operator|)
operator|->
name|ss_create
expr_stmt|;
comment|/* get the block and inode list */
name|pseg_blocks
argument_list|(
name|fsp
argument_list|,
name|seg
argument_list|,
operator|(
name|SEGSUM
operator|*
operator|)
name|s
argument_list|,
name|seg_buf
argument_list|,
operator|&
name|pblocks
argument_list|,
operator|&
name|pbcount
argument_list|)
expr_stmt|;
name|pseg_bjoin
argument_list|(
name|fsp
argument_list|,
name|blocks
argument_list|,
name|bcount
argument_list|,
name|pblocks
argument_list|,
name|pbcount
argument_list|)
expr_stmt|;
name|pseg_inodes
argument_list|(
name|fsp
argument_list|,
name|seg
argument_list|,
operator|(
name|SEGSUM
operator|*
operator|)
name|s
argument_list|,
name|seg_buf
argument_list|,
operator|&
name|pinodes
argument_list|,
operator|&
name|picount
argument_list|)
expr_stmt|;
name|pseg_ijoin
argument_list|(
name|fsp
argument_list|,
name|inodes
argument_list|,
name|icount
argument_list|,
name|pinodes
argument_list|,
name|picount
argument_list|)
expr_stmt|;
comment|/* free the temporary tables */
name|free
argument_list|(
name|pblocks
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pinodes
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * this will parse a partial segment and create a vector of block_info's  * for live data and a vector of inode_info's for live inodes.  It will   * not include blocks or inodes from files with new version numbers.    */
end_comment

begin_function
name|void
name|pseg_blocks
parameter_list|(
name|fsp
parameter_list|,
name|seg
parameter_list|,
name|s
parameter_list|,
name|seg_buf
parameter_list|,
name|blocks
parameter_list|,
name|count
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to super block */
name|int
name|seg
decl_stmt|;
comment|/* the segment id */
name|SEGSUM
modifier|*
name|s
decl_stmt|;
comment|/* (unvalidated) segsum pointer */
name|caddr_t
name|seg_buf
decl_stmt|;
comment|/* the buffer containing the segment's data */
comment|/* OUT: array of block_info for live blocks */
name|BLOCK_INFO
modifier|*
modifier|*
name|blocks
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
comment|/* OUT: number of active blocks in segment */
block|{
name|FINFO
modifier|*
modifier|*
name|finfos
decl_stmt|;
name|int
name|finfoc
decl_stmt|;
name|int
name|blockc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|ninob
decl_stmt|;
comment|/* number of inode blocks passed */
name|daddr_t
name|seg_daddr
decl_stmt|;
name|daddr_t
modifier|*
name|cur_iaddrp
decl_stmt|;
comment|/* pointer to current inode block */
name|u_long
name|offset
decl_stmt|;
comment|/* the offset (in bytes) within the segment */
operator|*
name|count
operator|=
literal|0
expr_stmt|;
operator|*
name|blocks
operator|=
name|NULL
expr_stmt|;
name|pseg_finfos
argument_list|(
name|fsp
argument_list|,
name|s
argument_list|,
operator|&
name|finfos
argument_list|,
operator|&
name|finfoc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|finfoc
condition|;
name|i
operator|++
control|)
block|{
name|print_FINFO
argument_list|(
name|finfos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"pseg_blocks: finfoc = %d\n"
argument_list|,
name|finfoc
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* count how many blocks are held by live FINFO's */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|blockc
operator|=
literal|0
init|;
name|i
operator|<
name|finfoc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|finfos
index|[
name|i
index|]
operator|->
name|fi_version
operator|==
name|IFILE_ENTRY
argument_list|(
name|lfsp
argument_list|,
name|ifilep
argument_list|,
name|finfos
index|[
name|i
index|]
operator|->
name|fi_ino
argument_list|)
operator|->
name|if_version
condition|)
name|blockc
operator|+=
name|finfos
index|[
name|i
index|]
operator|->
name|fi_nblocks
expr_stmt|;
if|if
condition|(
name|finfoc
operator|==
literal|0
operator|||
name|blockc
operator|==
literal|0
condition|)
return|return;
name|ninob
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|LFS_SUMMARY_SIZE
operator|+
operator|(
operator|(
name|u_int
operator|)
name|s
operator|-
operator|(
name|u_int
operator|)
name|seg_buf
operator|)
operator|+
name|s
operator|->
name|ss_next
operator|*
name|datobyte
argument_list|(
name|fsp
argument_list|,
literal|1
operator|<<
name|lfsp
operator|->
name|lfs_bshift
argument_list|)
expr_stmt|;
name|cur_iaddrp
operator|=
operator|(
name|daddr_t
operator|*
operator|)
operator|(
name|s
operator|->
name|ss_ninos
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
name|char
operator|*
operator|)
name|s
operator|+
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|)
expr_stmt|;
name|seg_daddr
operator|=
name|sntoda
argument_list|(
name|lfsp
argument_list|,
name|seg
argument_list|)
expr_stmt|;
operator|*
name|blocks
operator|=
operator|(
name|BLOCK_INFO
operator|*
operator|)
name|malloc
argument_list|(
name|blockc
operator|*
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|finfoc
condition|;
name|i
operator|++
control|)
block|{
name|FINFO
modifier|*
name|f
init|=
name|finfos
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|fi_version
operator|!=
name|IFILE_ENTRY
argument_list|(
name|lfsp
argument_list|,
name|ifilep
argument_list|,
name|f
operator|->
name|fi_ino
argument_list|)
operator|->
name|if_version
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"finfo %d = "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_FINFO
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"IFILE entry for file %d = "
argument_list|,
name|f
operator|->
name|fi_ino
argument_list|)
expr_stmt|;
name|print_IFILE
argument_list|(
name|IFILE_ENTRY
argument_list|(
name|lfsp
argument_list|,
name|ifilep
argument_list|,
name|f
operator|->
name|fi_ino
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|finfos
index|[
name|i
index|]
operator|->
name|fi_nblocks
condition|;
name|j
operator|++
control|)
block|{
name|BLOCK_INFO
modifier|*
name|b
init|=
operator|&
operator|(
operator|*
name|blocks
operator|)
index|[
operator|*
name|count
index|]
decl_stmt|;
comment|/* 			 * XXX:  			 * this changes if we have variable size blocks 			 */
for|for
control|(
init|;
name|cur_iaddrp
operator|&&
name|seg_daddr
operator|+
name|bytetoda
argument_list|(
name|fsp
argument_list|,
name|offset
argument_list|)
operator|==
operator|*
name|cur_iaddrp
condition|;
name|offset
operator|+=
name|datobyte
argument_list|(
name|fsp
argument_list|,
literal|1
operator|<<
name|lfsp
operator|->
name|lfs_bshift
argument_list|)
control|)
block|{
if|if
condition|(
name|ninob
operator|<=
operator|(
name|s
operator|->
name|ss_ninos
operator|+
name|INOPB
argument_list|(
name|lfsp
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|INOPB
argument_list|(
name|lfsp
argument_list|)
condition|)
block|{
operator|++
name|ninob
expr_stmt|;
operator|--
name|cur_iaddrp
expr_stmt|;
block|}
else|else
name|cur_iaddrp
operator|=
name|NULL
expr_stmt|;
block|}
name|b
operator|->
name|bi_inode
operator|=
name|f
operator|->
name|fi_ino
expr_stmt|;
name|b
operator|->
name|bi_lbn
operator|=
name|f
operator|->
name|fi_blocks
index|[
name|j
index|]
expr_stmt|;
name|b
operator|->
name|bi_daddr
operator|=
name|seg_daddr
operator|+
name|bytetoda
argument_list|(
name|fsp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|b
operator|->
name|bi_segcreate
operator|=
name|s
operator|->
name|ss_create
expr_stmt|;
name|b
operator|->
name|bi_bp
operator|=
name|seg_buf
operator|+
name|offset
expr_stmt|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
name|offset
operator|+=
name|blocksize
argument_list|(
name|fsp
argument_list|,
name|b
operator|->
name|bi_lbn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"\tb[%d] = "
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|print_BLOCK_INFO
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|free
argument_list|(
name|finfos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pseg_inodes
parameter_list|(
name|fsp
parameter_list|,
name|seg
parameter_list|,
name|s
parameter_list|,
name|seg_buf
parameter_list|,
name|inodes
parameter_list|,
name|count
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to super block */
name|int
name|seg
decl_stmt|;
comment|/* the segment id */
name|SEGSUM
modifier|*
name|s
decl_stmt|;
comment|/* (unvalidated) segsum pointer */
name|caddr_t
name|seg_buf
decl_stmt|;
comment|/* the buffer containing the segment's data */
comment|/* OUT: array of inode_info for live inodes */
name|INODE_INFO
modifier|*
modifier|*
name|inodes
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
comment|/* OUT: number of active inodes in segment */
block|{
name|int
name|i
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|daddr_t
modifier|*
name|daddrp
decl_stmt|,
name|i_daddr
decl_stmt|,
name|seg_daddr
decl_stmt|;
name|struct
name|dinode
modifier|*
name|di
decl_stmt|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
operator|*
name|inodes
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ss_ninos
operator|<=
literal|0
condition|)
return|return;
operator|*
name|inodes
operator|=
operator|(
name|INODE_INFO
operator|*
operator|)
name|malloc
argument_list|(
name|s
operator|->
name|ss_ninos
operator|*
sizeof|sizeof
argument_list|(
name|INODE_INFO
argument_list|)
argument_list|)
expr_stmt|;
name|seg_daddr
operator|=
name|sntoda
argument_list|(
name|lfsp
argument_list|,
name|seg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"pseg_inodes:\n"
argument_list|)
expr_stmt|;
name|print_SEGSUM
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|daddrp
operator|=
operator|(
name|daddr_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|s
operator|+
name|LFS_SUMMARY_SIZE
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|ss_ninos
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|%
name|INOPB
argument_list|(
name|lfsp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i_daddr
operator|=
operator|*
operator|--
name|daddrp
expr_stmt|;
if|if
condition|(
name|datosn
argument_list|(
name|lfsp
argument_list|,
name|i_daddr
argument_list|)
operator|!=
name|seg
operator|||
name|datobyte
argument_list|(
name|fsp
argument_list|,
name|i_daddr
operator|-
name|seg_daddr
argument_list|)
operator|>
name|seg_size
argument_list|(
name|lfsp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"pseg_inodes: bad i_daddr\n"
argument_list|)
expr_stmt|;
name|print_SEGSUM
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"i_daddr = %d, seg_daddr = %d, offset = %d, pseg_size = %d\n"
argument_list|,
name|i_daddr
argument_list|,
name|seg_daddr
argument_list|,
name|i_daddr
operator|-
name|seg_daddr
argument_list|,
name|pseg_size
argument_list|(
name|fsp
argument_list|,
operator|(
name|SEGSUM
operator|*
operator|)
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|di
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
operator|(
name|seg_buf
operator|+
name|datobyte
argument_list|(
name|fsp
argument_list|,
name|i_daddr
operator|-
name|seg_daddr
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
operator|++
name|di
expr_stmt|;
name|inum
operator|=
name|di
operator|->
name|di_inum
expr_stmt|;
if|if
condition|(
name|IFILE_ENTRY
argument_list|(
name|lfsp
argument_list|,
name|ifilep
argument_list|,
name|inum
argument_list|)
operator|->
name|if_daddr
operator|==
name|i_daddr
condition|)
block|{
operator|(
operator|*
name|inodes
operator|)
index|[
operator|*
name|count
index|]
operator|.
name|ii_inode
operator|=
name|inum
expr_stmt|;
operator|(
operator|*
name|inodes
operator|)
index|[
operator|*
name|count
index|]
operator|.
name|ii_daddr
operator|=
name|i_daddr
expr_stmt|;
operator|(
operator|*
name|inodes
operator|)
index|[
operator|*
name|count
index|]
operator|.
name|ii_segcreate
operator|=
name|s
operator|->
name|ss_create
expr_stmt|;
operator|(
operator|*
name|inodes
operator|)
index|[
operator|*
name|count
index|]
operator|.
name|ii_dinode
operator|=
name|di
expr_stmt|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* return the size of the partial segment in bytes. */
end_comment

begin_function
name|u_long
name|pseg_size
parameter_list|(
name|fsp
parameter_list|,
name|s
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to super block */
name|SEGSUM
modifier|*
name|s
decl_stmt|;
comment|/* segsum pointer */
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|FINFO
modifier|*
modifier|*
name|finfos
decl_stmt|;
name|int
name|finfoc
decl_stmt|;
name|u_long
name|size
init|=
name|LFS_SUMMARY_SIZE
decl_stmt|;
name|pseg_finfos
argument_list|(
name|fsp
argument_list|,
name|s
argument_list|,
operator|&
name|finfos
argument_list|,
operator|&
name|finfoc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|finfoc
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|finfos
index|[
name|i
index|]
operator|->
name|fi_nblocks
condition|;
name|j
operator|++
control|)
name|size
operator|+=
name|blocksize
argument_list|(
name|fsp
argument_list|,
name|finfos
index|[
name|i
index|]
operator|->
name|fi_blocks
index|[
name|j
index|]
argument_list|)
expr_stmt|;
comment|/* inodes are packed INOPB inodes per block */
comment|/* there can be unused space in an inode block */
name|size
operator|+=
name|datobyte
argument_list|(
name|fsp
argument_list|,
name|fsbtodb
argument_list|(
name|lfsp
argument_list|,
literal|1
argument_list|)
operator|*
operator|(
operator|(
name|s
operator|->
name|ss_ninos
operator|+
name|INOPB
argument_list|(
name|lfsp
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|INOPB
argument_list|(
name|lfsp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/*   * join block list b with list a (eliminating duplicates), leaving result  * in list a.  */
end_comment

begin_function
name|void
name|pseg_bjoin
parameter_list|(
name|fsp
parameter_list|,
name|ablocks
parameter_list|,
name|acount
parameter_list|,
name|bblocks
parameter_list|,
name|bcount
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to file system info */
comment|/* INOUT: array of live blocks block_info */
name|BLOCK_INFO
modifier|*
modifier|*
name|ablocks
decl_stmt|;
name|int
modifier|*
name|acount
decl_stmt|;
comment|/* INOUT: number of active blocks */
comment|/* IN: array of live blocks block_info */
name|BLOCK_INFO
modifier|*
name|bblocks
decl_stmt|;
name|int
name|bcount
decl_stmt|;
comment|/* IN: number of active blocks */
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|BLOCK_INFO
modifier|*
name|abp
decl_stmt|;
name|BLOCK_INFO
modifier|*
name|bbp
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"pseg_bjoin: *acount = %d, bcount = %d\n"
argument_list|,
operator|*
name|acount
argument_list|,
name|bcount
argument_list|)
expr_stmt|;
comment|/**/
name|printf
argument_list|(
literal|"ablocks = \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|acount
condition|;
name|i
operator|++
control|)
block|{
name|print_BLOCK_INFO
argument_list|(
operator|(
operator|*
name|ablocks
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/**/
name|printf
argument_list|(
literal|"bblocks = \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bcount
condition|;
name|i
operator|++
control|)
block|{
name|print_BLOCK_INFO
argument_list|(
name|bblocks
operator|+
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/**/
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/**/
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bbp
operator|=
name|bblocks
init|;
name|i
operator|<
name|bcount
condition|;
operator|++
name|i
operator|,
operator|++
name|bbp
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|abp
operator|=
operator|*
name|ablocks
init|;
name|j
operator|<
operator|*
name|acount
condition|;
operator|++
name|j
operator|,
operator|++
name|abp
control|)
block|{
if|if
condition|(
name|abp
operator|->
name|bi_inode
operator|==
name|bbp
operator|->
name|bi_inode
operator|&&
name|abp
operator|->
name|bi_lbn
operator|==
name|bbp
operator|->
name|bi_lbn
condition|)
block|{
comment|/* the data is for the same file and logical block */
if|if
condition|(
name|abp
operator|->
name|bi_segcreate
operator|<
name|bbp
operator|->
name|bi_segcreate
condition|)
operator|*
name|abp
operator|=
operator|*
name|bbp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|==
operator|*
name|acount
condition|)
block|{
comment|/* this is a block we haven't seen before */
operator|*
name|ablocks
operator|=
operator|(
name|BLOCK_INFO
operator|*
operator|)
name|realloc
argument_list|(
operator|*
name|ablocks
argument_list|,
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
operator|*
operator|(
operator|*
name|acount
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ablocks
operator|)
index|[
operator|*
name|acount
index|]
operator|=
operator|*
name|bbp
expr_stmt|;
operator|(
operator|*
name|acount
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   * join block list b with list a (eliminating duplicates), leaving result  * in list a.  */
end_comment

begin_function
name|void
name|pseg_ijoin
parameter_list|(
name|fsp
parameter_list|,
name|ainodes
parameter_list|,
name|acount
parameter_list|,
name|binodes
parameter_list|,
name|bcount
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to file system info */
comment|/* INOUT: array of live inodes inode_info */
name|INODE_INFO
modifier|*
modifier|*
name|ainodes
decl_stmt|;
name|int
modifier|*
name|acount
decl_stmt|;
comment|/* INOUT: number of active inodes */
comment|/* IN: array of live inodes inode_info */
name|INODE_INFO
modifier|*
name|binodes
decl_stmt|;
name|int
name|bcount
decl_stmt|;
comment|/* IN: number of active inodes */
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|daddr_t
name|daddr
decl_stmt|;
name|INODE_INFO
modifier|*
name|aip
decl_stmt|;
name|INODE_INFO
modifier|*
name|bip
decl_stmt|;
comment|/* we assume that we have no duplicate live inodes on "a" and "b" */
comment|/* eliminate dead inodes from "a" */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|aip
operator|=
operator|*
name|ainodes
init|;
name|i
operator|<
operator|*
name|acount
condition|;
operator|++
name|aip
control|)
block|{
name|daddr
operator|=
name|IFILE_ENTRY
argument_list|(
name|lfsp
argument_list|,
name|ifilep
argument_list|,
name|aip
operator|->
name|ii_inode
argument_list|)
operator|->
name|if_daddr
expr_stmt|;
if|if
condition|(
name|daddr
operator|!=
name|aip
operator|->
name|ii_daddr
condition|)
operator|*
name|aip
operator|=
operator|(
operator|*
name|ainodes
operator|)
index|[
operator|--
operator|(
operator|*
name|acount
operator|)
index|]
expr_stmt|;
else|else
name|i
operator|++
expr_stmt|;
block|}
comment|/* eliminate dead inodes from "b" */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bip
operator|=
name|binodes
init|;
name|i
operator|<
name|bcount
condition|;
operator|++
name|bip
control|)
block|{
name|daddr
operator|=
name|IFILE_ENTRY
argument_list|(
name|lfsp
argument_list|,
name|ifilep
argument_list|,
name|bip
operator|->
name|ii_inode
argument_list|)
operator|->
name|if_daddr
expr_stmt|;
if|if
condition|(
name|daddr
operator|!=
name|bip
operator|->
name|ii_daddr
condition|)
block|{
comment|/* don't really need to do this, only we don't want 			   to lose any inodes, just in case */
name|INODE_INFO
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|*
name|bip
expr_stmt|;
operator|*
name|bip
operator|=
name|binodes
index|[
name|bcount
index|]
expr_stmt|;
name|binodes
index|[
name|bcount
index|]
operator|=
name|tmp
expr_stmt|;
name|bcount
operator|--
expr_stmt|;
block|}
else|else
name|i
operator|++
expr_stmt|;
block|}
comment|/* append "b" to "a" */
if|if
condition|(
name|bcount
operator|>
literal|0
condition|)
block|{
operator|*
name|ainodes
operator|=
operator|(
name|INODE_INFO
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|*
name|ainodes
argument_list|,
operator|(
operator|*
name|acount
operator|+
name|bcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INODE_INFO
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bcount
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|ainodes
operator|)
index|[
operator|(
operator|*
name|acount
operator|)
operator|++
index|]
operator|=
name|binodes
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* is the segsum block valid? return TRUE if it is, FALSE otherwise */
end_comment

begin_function
name|int
name|segsum_valid
parameter_list|(
name|fsp
parameter_list|,
name|ssp
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to file system info */
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
comment|/* pointer to segment summary block */
block|{
name|u_long
name|sumsum
decl_stmt|;
comment|/* check segsum block checksum */
name|sumsum
operator|=
name|cksum
argument_list|(
operator|&
name|ssp
operator|->
name|ss_datasum
argument_list|,
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|ssp
operator|->
name|ss_sumsum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sumsum
operator|!=
name|ssp
operator|->
name|ss_sumsum
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * pseg_valid:  *  * returns 1 if the partial segment is valid, and 0 if it is invalid.  * it uses the checksums to verify validity.  */
end_comment

begin_function
name|int
name|pseg_valid
parameter_list|(
name|fsp
parameter_list|,
name|ssp
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to file system info */
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
comment|/* pointer to segment summary block */
block|{
name|u_long
name|datasum
decl_stmt|;
name|u_long
name|size
decl_stmt|;
name|int
name|nblocks
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_long
modifier|*
name|datap
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
comment|/* check segsum block checksum */
if|if
condition|(
name|segsum_valid
argument_list|(
name|fsp
argument_list|,
name|ssp
argument_list|)
operator|==
name|FALSE
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
comment|/* check data/inode block(s) checksum too... */
name|size
operator|=
name|pseg_size
argument_list|(
name|fsp
argument_list|,
name|ssp
argument_list|)
expr_stmt|;
name|nblocks
operator|=
name|size
operator|/
name|fsbtodb
argument_list|(
name|lfsp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|datap
operator|=
operator|(
name|u_long
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|nblocks
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|ssp
operator|+
name|LFS_SUMMARY_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblocks
condition|;
name|i
operator|++
control|)
block|{
name|datap
index|[
name|i
index|]
operator|=
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
name|p
operator|)
expr_stmt|;
name|p
operator|+=
name|lfsp
operator|->
name|lfs_bsize
expr_stmt|;
block|}
name|datasum
operator|=
name|cksum
argument_list|(
operator|(
name|void
operator|*
operator|)
name|datap
argument_list|,
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasum
operator|!=
name|ssp
operator|->
name|ss_datasum
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* get array of FINFO pointers for partial segment */
end_comment

begin_function
name|void
name|pseg_finfos
parameter_list|(
name|fsp
parameter_list|,
name|ssp
parameter_list|,
name|finfos
parameter_list|,
name|count
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to file system info */
name|SEGSUM
modifier|*
name|ssp
decl_stmt|;
comment|/* pointer to segment summary block */
name|FINFO
modifier|*
modifier|*
modifier|*
name|finfos
decl_stmt|;
comment|/* OUT: return an array of FINFO pointers */
name|int
modifier|*
name|count
decl_stmt|;
comment|/* OUT: return size of array */
block|{
name|caddr_t
name|p
init|=
operator|(
name|caddr_t
operator|)
name|ssp
operator|+
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FINFO
modifier|*
name|fip
decl_stmt|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
operator|*
name|finfos
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ssp
operator|->
name|ss_nfinfo
operator|>
literal|0
condition|)
operator|*
name|finfos
operator|=
operator|(
name|FINFO
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|ssp
operator|->
name|ss_nfinfo
operator|*
sizeof|sizeof
argument_list|(
name|FINFO
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ssp
operator|->
name|ss_nfinfo
condition|;
name|i
operator|++
control|)
block|{
name|fip
operator|=
operator|(
name|FINFO
operator|*
operator|)
name|p
expr_stmt|;
operator|(
operator|*
name|finfos
operator|)
index|[
operator|*
name|count
index|]
operator|=
name|fip
expr_stmt|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
name|p
operator|+=
name|finfo_size
argument_list|(
name|fip
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * blocksize:  *  * returns the size (in bytes) of a (logical) block.  * this is used because lfs uses different block sizes, depending  * on the logical # of the block.  Lfs uses various sizes so  * it doesn't need fragments.  */
end_comment

begin_function
name|u_long
name|blocksize
parameter_list|(
name|fsp
parameter_list|,
name|index
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* pointer to file system info */
name|int
name|index
decl_stmt|;
comment|/* logical block # w/in file */
block|{
return|return
name|lfsp
operator|->
name|lfs_bsize
return|;
comment|/* XXX: blocksize might depend on 					the logical block number */
block|}
end_function

begin_comment
comment|/*  * finfo_size  *  * returns the size in bytes of an FINFO structure   */
end_comment

begin_function
name|u_long
name|finfo_size
parameter_list|(
name|finfop
parameter_list|)
name|FINFO
modifier|*
name|finfop
decl_stmt|;
block|{
return|return
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
operator|(
name|finfop
operator|->
name|fi_nblocks
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* #define MMAP_SEGMENT */
end_comment

begin_comment
comment|/*   * read a segment into a memory buffer  */
end_comment

begin_function
name|int
name|mmap_segment
parameter_list|(
name|fsp
parameter_list|,
name|segment
parameter_list|,
name|seg_buf
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* file system information */
name|int
name|segment
decl_stmt|;
comment|/* the index of the segment to be cleaned */
name|caddr_t
modifier|*
name|seg_buf
decl_stmt|;
comment|/* pointer to buffer area */
block|{
name|off_t
name|seg_daddr
decl_stmt|;
comment|/* base disk address of segment */
name|int
name|fid
decl_stmt|;
comment|/* fildes for file system device */
name|char
name|mntfromname
index|[
name|MNAMELEN
operator|+
literal|2
index|]
decl_stmt|;
comment|/* get the disk address of the beginning of the segment */
name|seg_daddr
operator|=
name|sntoda
argument_list|(
name|lfsp
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mntfromname
argument_list|,
literal|"/dev/r"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|mntfromname
argument_list|,
name|statfsp
operator|->
name|f_mntfromname
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fid
operator|=
name|open
argument_list|(
name|mntfromname
argument_list|,
name|O_RDONLY
argument_list|,
operator|(
name|mode_t
operator|)
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"mmap_segment: bad open"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|MMAP_SEGMENT
operator|*
name|seg_buf
operator|=
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|seg_size
argument_list|(
name|lfsp
argument_list|)
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_FILE
argument_list|,
name|fid
argument_list|,
operator|(
name|off_t
operator|)
name|datobyte
argument_list|(
name|fsp
argument_list|,
name|seg_daddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
operator|*
name|seg_buf
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"mmap_segment: mmap failed"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|#
directive|else
comment|/* MMAP_SEGMENT */
name|printf
argument_list|(
literal|"mmap_segment: seg_daddr = %lu, seg_size = %lu, seg_offset = %lu\n"
argument_list|,
name|seg_daddr
argument_list|,
name|seg_size
argument_list|(
name|lfsp
argument_list|)
argument_list|,
name|datobyte
argument_list|(
name|fsp
argument_list|,
name|seg_daddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* malloc the space for the buffer */
operator|*
name|seg_buf
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|seg_size
argument_list|(
name|lfsp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read the segment data into the buffer */
if|if
condition|(
name|datobyte
argument_list|(
name|fsp
argument_list|,
name|seg_daddr
argument_list|)
operator|!=
name|lseek
argument_list|(
name|fid
argument_list|,
name|datobyte
argument_list|(
name|fsp
argument_list|,
name|seg_daddr
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"mmap_segment: bad lseek"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|seg_size
argument_list|(
name|lfsp
argument_list|)
operator|!=
name|read
argument_list|(
name|fid
argument_list|,
operator|*
name|seg_buf
argument_list|,
name|seg_size
argument_list|(
name|lfsp
argument_list|)
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"mmap_segment: bad read"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* MMAP_SEGMENT */
name|close
argument_list|(
name|fid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|munmap_segment
parameter_list|(
name|fsp
parameter_list|,
name|seg_buf
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* file system information */
name|caddr_t
name|seg_buf
decl_stmt|;
comment|/* pointer to buffer area */
block|{
ifdef|#
directive|ifdef
name|MMAP_SEGMENT
name|munmap
argument_list|(
name|seg_buf
argument_list|,
name|seg_size
argument_list|(
name|lfsp
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MMAP_SEGMENT */
name|free
argument_list|(
name|seg_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MMAP_SEGMENT */
block|}
end_function

begin_comment
comment|/*  * USEFUL DEBUGGING TOOLS:  */
end_comment

begin_function
name|void
name|print_IFILE
parameter_list|(
name|p
parameter_list|)
name|IFILE
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|if_daddr
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"{free, if_version=%lu, if_nextfree=%lu}"
argument_list|,
name|p
operator|->
name|if_version
argument_list|,
name|p
operator|->
name|if_nextfree
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"{if_version=%lu, if_daddr=%lu}"
argument_list|,
name|p
operator|->
name|if_version
argument_list|,
name|p
operator|->
name|if_daddr
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"0x0"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_SEGUSE
parameter_list|(
name|p
parameter_list|)
name|SEGUSE
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"{su_nbytes=%lu, su_flags=%c%c%c, su_lastmod="
argument_list|,
name|p
operator|->
name|su_nbytes
argument_list|,
operator|(
operator|(
name|p
operator|->
name|su_flags
operator|&
name|SEGUSE_DIRTY
operator|)
condition|?
literal|'D'
else|:
literal|'C'
operator|)
argument_list|,
operator|(
operator|(
name|p
operator|->
name|su_flags
operator|&
name|SEGUSE_ACTIVE
operator|)
condition|?
literal|'A'
else|:
literal|' '
operator|)
argument_list|,
operator|(
operator|(
name|p
operator|->
name|su_flags
operator|&
name|SEGUSE_SUPERBLOCK
operator|)
condition|?
literal|'S'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
name|print_time_t
argument_list|(
name|p
operator|->
name|su_lastmod
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"0x0"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_CLEANERINFO
parameter_list|(
name|p
parameter_list|)
name|CLEANERINFO
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
condition|)
name|printf
argument_list|(
literal|"{clean=%lu, dirty=%lu}"
argument_list|,
name|p
operator|->
name|clean
argument_list|,
name|p
operator|->
name|dirty
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0x0"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_SEGSUM
parameter_list|(
name|p
parameter_list|)
name|SEGSUM
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"{ss_sumsum=%lu, ss_datasum=%lu, ss_next=%lu, "
argument_list|,
name|p
operator|->
name|ss_sumsum
argument_list|,
name|p
operator|->
name|ss_datasum
argument_list|,
name|p
operator|->
name|ss_next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ss_create=%lu, ss_nfinfo=%lu, ss_ninos=%lu"
argument_list|,
name|p
operator|->
name|ss_create
argument_list|,
name|p
operator|->
name|ss_nfinfo
argument_list|,
name|p
operator|->
name|ss_ninos
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"0x0"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_time_t
parameter_list|(
name|t
parameter_list|)
name|time_t
name|t
decl_stmt|;
block|{
name|char
name|temp
index|[
literal|128
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|temp
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_FINFO
parameter_list|(
name|p
parameter_list|)
name|FINFO
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"{fi_nblocks=%lu, fi_version=%lu, fi_ino=%lu, fi_blocks={"
argument_list|,
name|p
operator|->
name|fi_nblocks
argument_list|,
name|p
operator|->
name|fi_version
argument_list|,
name|p
operator|->
name|fi_ino
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|fi_nblocks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%ld"
argument_list|,
name|p
operator|->
name|fi_blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}}"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"0x0"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_BLOCK_INFO
parameter_list|(
name|p
parameter_list|)
name|BLOCK_INFO
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"{bi_inode=%lu, bi_lbn=%ld, bi_daddr=%lu, bi_segcreate="
argument_list|,
name|p
operator|->
name|bi_inode
argument_list|,
name|p
operator|->
name|bi_lbn
argument_list|,
name|p
operator|->
name|bi_daddr
argument_list|)
expr_stmt|;
name|print_time_t
argument_list|(
name|p
operator|->
name|bi_segcreate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", bi_bp = 0x%x}"
argument_list|,
name|p
operator|->
name|bi_bp
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"0x0"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_INODE_INFO
parameter_list|(
name|p
parameter_list|)
name|INODE_INFO
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"{ii_inode=%lu, ii_daddr=%lu, ii_segcreate="
argument_list|,
name|p
operator|->
name|ii_inode
argument_list|,
name|p
operator|->
name|ii_daddr
argument_list|)
expr_stmt|;
name|print_time_t
argument_list|(
name|p
operator|->
name|ii_segcreate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", ii_dinode=0x%x}"
argument_list|,
name|p
operator|->
name|ii_dinode
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"0x0"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_lfs
parameter_list|(
name|p
parameter_list|)
name|struct
name|lfs
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_magic=0x%x\n"
argument_list|,
name|p
operator|->
name|lfs_magic
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_version=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_size=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_ssize=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_ssize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_dsize=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_dsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_bsize=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_fsize=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_fsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_frag=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_frag
argument_list|)
expr_stmt|;
comment|/* checkpoint region */
name|printf
argument_list|(
literal|"\tlfs_free=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_free
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_bfree=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_bfree
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_nfiles=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_nfiles
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_idaddr=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_idaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_ifile=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_ifile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_lastseg=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_lastseg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_nextseg=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_nextseg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_curseg=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_curseg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_offset=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_tstamp=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_tstamp
argument_list|)
expr_stmt|;
comment|/* configuration parameters */
name|printf
argument_list|(
literal|"\tlfs_minfree=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_minfree
argument_list|)
expr_stmt|;
comment|/* these fields can be computed from the others */
name|printf
argument_list|(
literal|"\tlfs_dbpseg=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_dbpseg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_inopb=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_inopb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_ifpb=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_ifpb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_sepb=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_sepb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_nindir=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_nindir
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_nseg=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_nseg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_nspf=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_nspf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_cleansz=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_cleansz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_segtabsz=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_segtabsz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_segmask=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_segmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_segshift=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_segshift
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_bmask=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_bmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_bshift=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_bshift
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_ffmask=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_ffmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_ffshift=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_ffshift
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_fbmask=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_fbmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_fbshift=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_fbshift
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tlfs_fsbtodb=%lu\n"
argument_list|,
name|p
operator|->
name|lfs_fsbtodb
argument_list|)
expr_stmt|;
comment|/* superblock offsets */
name|printf
argument_list|(
literal|"\tlfs_sboffs={"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LFS_MAXNUMSB
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%lu"
argument_list|,
name|p
operator|->
name|lfs_sboffs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"0x0"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

