begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"clean.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|special
init|=
literal|"cleanerd"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|seglist
block|{
name|int
name|sl_id
decl_stmt|;
comment|/* segment number */
name|int
name|sl_cost
decl_stmt|;
comment|/* cleaning cost */
name|char
name|sl_empty
decl_stmt|;
comment|/* is segment empty */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tossstruct
block|{
name|struct
name|lfs
modifier|*
name|lfs
decl_stmt|;
name|int
name|seg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* function prototypes for system calls; not sure where they should go */
end_comment

begin_decl_stmt
name|int
name|lfs_segwait
name|__P
argument_list|(
operator|(
name|fsid_t
operator|,
expr|struct
name|timeval
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lfs_segclean
name|__P
argument_list|(
operator|(
name|fsid_t
operator|,
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lfs_bmapv
name|__P
argument_list|(
operator|(
name|fsid_t
operator|,
name|BLOCK_INFO
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lfs_markv
name|__P
argument_list|(
operator|(
name|fsid_t
operator|,
name|BLOCK_INFO
operator|*
operator|,
name|int
operator|,
name|INODE_INFO
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function prototypes */
end_comment

begin_decl_stmt
name|int
name|bi_tossold
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|choose_segments
name|__P
argument_list|(
operator|(
name|FS_INFO
operator|*
operator|,
expr|struct
name|seglist
operator|*
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|FS_INFO
operator|*
argument_list|,
name|SEGUSE
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|clean_fs
name|__P
argument_list|(
operator|(
name|FS_INFO
operator|*
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|FS_INFO
operator|*
argument_list|,
name|SEGUSE
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clean_loop
name|__P
argument_list|(
operator|(
name|FS_INFO
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clean_segment
name|__P
argument_list|(
operator|(
name|FS_INFO
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cost_benefit
name|__P
argument_list|(
operator|(
name|FS_INFO
operator|*
operator|,
name|SEGUSE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cost_compare
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Cleaning Cost Functions:  *  * These return the cost of cleaning a segment.  The higher the cost value  * the better it is to clean the segment, so empty segments have the highest  * cost.  (It is probably better to think of this as a priority value  * instead).  *  * This is the cost-benefit policy simulated and described in Rosenblum's  * 1991 SOSP paper.  */
end_comment

begin_function
name|int
name|cost_benefit
parameter_list|(
name|fsp
parameter_list|,
name|su
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* file system information */
name|SEGUSE
modifier|*
name|su
decl_stmt|;
block|{
name|struct
name|lfs
modifier|*
name|lfsp
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|;
name|int
name|age
decl_stmt|;
name|int
name|live
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|live
operator|=
name|su
operator|->
name|su_nbytes
expr_stmt|;
name|age
operator|=
name|t
operator|.
name|tv_sec
operator|-
name|su
operator|->
name|su_lastmod
operator|<
literal|0
condition|?
literal|0
else|:
name|t
operator|.
name|tv_sec
operator|-
name|su
operator|->
name|su_lastmod
expr_stmt|;
name|lfsp
operator|=
operator|&
name|fsp
operator|->
name|fi_lfs
expr_stmt|;
if|if
condition|(
name|live
operator|==
literal|0
condition|)
return|return
operator|(
name|t
operator|.
name|tv_sec
operator|*
name|lblkno
argument_list|(
name|lfsp
argument_list|,
name|seg_size
argument_list|(
name|lfsp
argument_list|)
argument_list|)
operator|)
return|;
else|else
block|{
comment|/*  		 * from lfsSegUsage.c (Mendel's code). 		 * priority calculation is done using INTEGER arithmetic. 		 * sizes are in BLOCKS (that is why we use lblkno below). 		 * age is in seconds. 		 * 		 * priority = ((seg_size - live) * age) / (seg_size + live)  		 */
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|live
operator|<
literal|0
operator|||
name|live
operator|>
name|seg_size
argument_list|(
name|lfsp
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"Bad segusage count: %d"
argument_list|,
name|live
argument_list|)
expr_stmt|;
name|live
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|lblkno
argument_list|(
name|lfsp
argument_list|,
name|seg_size
argument_list|(
name|lfsp
argument_list|)
operator|-
name|live
argument_list|)
operator|*
name|age
operator|)
operator|/
name|lblkno
argument_list|(
name|lfsp
argument_list|,
name|seg_size
argument_list|(
name|lfsp
argument_list|)
operator|+
name|live
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FS_INFO
modifier|*
name|lfp
decl_stmt|,
modifier|*
name|fsp
decl_stmt|;
name|struct
name|statfs
modifier|*
name|lstatfsp
decl_stmt|;
comment|/* file system stats */
name|struct
name|timeval
name|timeout
decl_stmt|;
comment|/* sleep timeout */
name|fsid_t
name|fsid
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* number of file systems */
name|int
name|i
decl_stmt|;
name|count
operator|=
name|fs_getmntinfo
argument_list|(
operator|&
name|lstatfsp
argument_list|,
name|MOUNT_LFS
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|5
operator|*
literal|60
expr_stmt|;
comment|/* five minutes */
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fsp
operator|=
name|get_fs_info
argument_list|(
name|lstatfsp
argument_list|,
name|count
argument_list|)
init|;
condition|;
name|reread_fs_info
argument_list|(
name|fsp
argument_list|,
name|count
argument_list|)
control|)
block|{
for|for
control|(
name|lfp
operator|=
name|fsp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|lfp
operator|,
operator|++
name|i
control|)
name|clean_loop
argument_list|(
name|lfp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Cleaner going to sleep.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lfs_segwait
argument_list|(
name|fsid
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|0
argument_list|,
literal|"lfs_segwait: returned error\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Cleaner waking up.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* return the number of segments cleaned */
end_comment

begin_function
name|int
name|clean_loop
parameter_list|(
name|fsp
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* file system information */
block|{
name|double
name|loadavg
index|[
name|MAXLOADS
index|]
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|u_long
name|max_free_segs
decl_stmt|;
comment|/* 	 * Compute the maximum possible number of free segments, given the 	 * number of free blocks. 	 */
name|max_free_segs
operator|=
name|fsp
operator|->
name|fi_statfsp
operator|->
name|f_bfree
operator|/
name|fsp
operator|->
name|fi_lfs
operator|.
name|lfs_ssize
expr_stmt|;
comment|/*  	 * We will clean if there are not enough free blocks or total clean 	 * space is less than BUSY_LIM % of possible clean space. 	 */
name|now
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsp
operator|->
name|fi_cip
operator|->
name|clean
operator|<=
name|MIN_SEGS
argument_list|(
operator|&
name|fsp
operator|->
name|fi_lfs
argument_list|)
operator|||
name|fsp
operator|->
name|fi_cip
operator|->
name|clean
operator|<
name|max_free_segs
operator|*
name|BUSY_LIM
condition|)
block|{
name|clean_fs
argument_list|(
name|fsp
argument_list|,
name|cost_benefit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Cleaner Running  at %s (need space)\n"
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/*  		 * We will also clean if the system is reasonably idle and 		 * the total clean space is less then IDLE_LIM % of possible 		 * clean space. 		 */
if|if
condition|(
name|getloadavg
argument_list|(
name|loadavg
argument_list|,
name|MAXLOADS
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"getloadavg: failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|loadavg
index|[
name|ONE_MIN
index|]
operator|==
literal|0.0
operator|&&
name|loadavg
index|[
name|FIVE_MIN
index|]
operator|&&
name|fsp
operator|->
name|fi_cip
operator|->
name|clean
operator|<
name|max_free_segs
operator|*
name|IDLE_LIM
condition|)
block|{
name|clean_fs
argument_list|(
name|fsp
argument_list|,
name|cost_benefit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Cleaner Running  at %s (system idle)\n"
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|printf
argument_list|(
literal|"Cleaner Not Running at %s\n"
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
name|void
name|clean_fs
parameter_list|(
name|fsp
parameter_list|,
name|cost_func
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* file system information */
function_decl|int
parameter_list|(
function_decl|*cost_func
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
name|FS_INFO
operator|*
operator|,
name|SEGUSE
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|seglist
modifier|*
name|segs
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|segs
operator|=
name|malloc
argument_list|(
name|fsp
operator|->
name|fi_lfs
operator|.
name|lfs_nseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|seglist
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|choose_segments
argument_list|(
name|fsp
argument_list|,
name|segs
argument_list|,
name|cost_func
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"clean_fs: cleaning %d segments in file system %s\n"
argument_list|,
name|i
argument_list|,
name|fsp
operator|->
name|fi_statfsp
operator|->
name|f_mntonname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
condition|)
for|for
control|(
name|i
operator|=
name|MIN
argument_list|(
name|i
argument_list|,
name|NUM_TO_CLEAN
argument_list|(
name|fsp
argument_list|)
argument_list|)
operator|,
name|sp
operator|=
name|segs
init|;
name|i
operator|--
condition|;
operator|++
name|sp
control|)
if|if
condition|(
name|clean_segment
argument_list|(
name|fsp
argument_list|,
name|sp
operator|->
name|sl_id
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"clean_segment failed"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lfs_segclean
argument_list|(
name|fsp
operator|->
name|fi_statfsp
operator|->
name|f_fsid
argument_list|,
name|sp
operator|->
name|sl_id
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"lfs_segclean failed"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|segs
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Segment with the highest priority get sorted to the beginning of the  * list.  This sort assumes that empty segments always have a higher  * cost/benefit than any utilized segment.  */
end_comment

begin_function
name|int
name|cost_compare
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|void
modifier|*
name|a
decl_stmt|;
specifier|const
name|void
modifier|*
name|b
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
expr|struct
name|seglist
operator|*
operator|)
name|b
operator|)
operator|->
name|sl_cost
operator|-
operator|(
operator|(
expr|struct
name|seglist
operator|*
operator|)
name|a
operator|)
operator|->
name|sl_cost
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the number of segments to be cleaned with the elements of seglist  * filled in.  */
end_comment

begin_function_decl
name|int
name|choose_segments
parameter_list|(
name|fsp
parameter_list|,
name|seglist
parameter_list|,
name|cost_func
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
name|struct
name|seglist
modifier|*
name|seglist
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*cost_func
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
name|FS_INFO
operator|*
operator|,
name|SEGUSE
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|lfs
modifier|*
name|lfsp
decl_stmt|;
name|struct
name|seglist
modifier|*
name|sp
decl_stmt|;
name|SEGUSE
modifier|*
name|sup
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nsegs
decl_stmt|;
name|lfsp
operator|=
operator|&
name|fsp
operator|->
name|fi_lfs
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Entering choose_segments\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dump_super
argument_list|(
name|lfsp
argument_list|)
expr_stmt|;
name|dump_cleaner_info
argument_list|(
name|fsp
operator|->
name|fi_cip
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|seglist
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lfsp
operator|->
name|lfs_nseg
condition|;
operator|++
name|i
control|)
block|{
name|sup
operator|=
name|SEGUSE_ENTRY
argument_list|(
name|lfsp
argument_list|,
name|fsp
operator|->
name|fi_segusep
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PRINT_SEGUSE
argument_list|(
name|sup
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sup
operator|->
name|su_flags
operator|&
name|SEGUSE_DIRTY
operator|)
operator|||
name|sup
operator|->
name|su_flags
operator|&
name|SEGUSE_ACTIVE
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|VERBOSE
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tchoosing segment %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|sl_cost
operator|=
call|(
modifier|*
name|cost_func
call|)
argument_list|(
name|fsp
argument_list|,
name|sup
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sl_id
operator|=
name|i
expr_stmt|;
name|sp
operator|->
name|sl_empty
operator|=
name|sup
operator|->
name|su_nbytes
condition|?
literal|0
else|:
literal|1
expr_stmt|;
operator|++
name|sp
expr_stmt|;
block|}
name|nsegs
operator|=
name|sp
operator|-
name|seglist
expr_stmt|;
name|qsort
argument_list|(
name|seglist
argument_list|,
name|nsegs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|seglist
argument_list|)
argument_list|,
name|cost_compare
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Returning %d segments\n"
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|nsegs
operator|)
return|;
block|}
end_block

begin_function
name|int
name|clean_segment
parameter_list|(
name|fsp
parameter_list|,
name|id
parameter_list|)
name|FS_INFO
modifier|*
name|fsp
decl_stmt|;
comment|/* file system information */
name|int
name|id
decl_stmt|;
comment|/* segment number */
block|{
name|BLOCK_INFO
modifier|*
name|block_array
decl_stmt|;
name|INODE_INFO
modifier|*
name|inode_array
decl_stmt|;
name|SEGUSE
modifier|*
name|sp
decl_stmt|;
name|struct
name|lfs
modifier|*
name|lfsp
decl_stmt|;
name|struct
name|tossstruct
name|t
decl_stmt|;
name|caddr_t
name|seg_buf
decl_stmt|;
name|int
name|num_inodes
decl_stmt|,
name|num_blocks
decl_stmt|;
name|lfsp
operator|=
operator|&
name|fsp
operator|->
name|fi_lfs
expr_stmt|;
name|sp
operator|=
name|SEGUSE_ENTRY
argument_list|(
name|lfsp
argument_list|,
name|fsp
operator|->
name|fi_segusep
argument_list|,
name|id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"cleaning segment %d: contains %lu bytes\n"
argument_list|,
name|id
argument_list|,
name|sp
operator|->
name|su_nbytes
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX could add debugging to verify that segment is really empty */
if|if
condition|(
name|sp
operator|->
name|su_nbytes
operator|==
name|sp
operator|->
name|su_nsums
operator|*
name|LFS_SUMMARY_SIZE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* map the segment into a buffer */
if|if
condition|(
name|mmap_segment
argument_list|(
name|fsp
argument_list|,
name|id
argument_list|,
operator|&
name|seg_buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"mmap_segment failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* get a list of blocks that are contained by the segment */
if|if
condition|(
name|lfs_segmapv
argument_list|(
name|fsp
argument_list|,
name|id
argument_list|,
name|seg_buf
argument_list|,
operator|&
name|block_array
argument_list|,
operator|&
name|num_blocks
argument_list|,
operator|&
name|inode_array
argument_list|,
operator|&
name|num_inodes
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"clean_segment: lfs_segmapv failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|VERBOSE
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"lfs_segmapv returned %d blocks and %d inodes\n"
argument_list|,
name|num_blocks
argument_list|,
name|num_inodes
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* get the current disk address of blocks contained by the segment */
if|if
condition|(
name|lfs_bmapv
argument_list|(
name|fsp
operator|->
name|fi_statfsp
operator|->
name|f_fsid
argument_list|,
name|block_array
argument_list|,
name|num_blocks
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"clean_segment: lfs_bmapv failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Now toss any blocks not in the current segment */
name|t
operator|.
name|lfs
operator|=
name|lfsp
expr_stmt|;
name|t
operator|.
name|seg
operator|=
name|id
expr_stmt|;
name|toss
argument_list|(
name|block_array
argument_list|,
operator|&
name|num_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|BLOCK_INFO
argument_list|)
argument_list|,
name|bi_tossold
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* Check if last element should be tossed */
if|if
condition|(
name|num_blocks
operator|&&
name|bi_tossold
argument_list|(
operator|&
name|t
argument_list|,
name|block_array
operator|+
name|num_blocks
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
operator|--
name|num_blocks
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
block|{
name|BLOCK_INFO
modifier|*
name|_bip
decl_stmt|;
name|INODE_INFO
modifier|*
name|_iip
decl_stmt|;
name|u_long
modifier|*
name|lp
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"after bmapv still have %d blocks\n"
argument_list|,
name|num_blocks
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_blocks
condition|)
name|printf
argument_list|(
literal|"BLOCK INFOS\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|_bip
operator|=
name|block_array
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
operator|++
name|_bip
operator|,
operator|++
name|i
control|)
block|{
name|PRINT_BINFO
argument_list|(
name|_bip
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|(
name|u_long
operator|*
operator|)
name|_bip
operator|->
name|bi_bp
expr_stmt|;
block|}
if|if
condition|(
name|num_inodes
condition|)
name|printf
argument_list|(
literal|"INODE INFOS\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|_iip
operator|=
name|inode_array
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_inodes
condition|;
operator|++
name|_iip
operator|,
operator|++
name|i
control|)
name|PRINT_IINFO
argument_list|(
literal|1
argument_list|,
name|_iip
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* rewrite the live data */
if|if
condition|(
name|num_blocks
operator|>
literal|0
operator|||
name|num_inodes
operator|>
literal|0
condition|)
if|if
condition|(
name|lfs_markv
argument_list|(
name|fsp
operator|->
name|fi_statfsp
operator|->
name|f_fsid
argument_list|,
name|block_array
argument_list|,
name|num_blocks
argument_list|,
name|inode_array
argument_list|,
name|num_inodes
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|0
argument_list|,
literal|"clean_segment: lfs_bmapv failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|block_array
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inode_array
argument_list|)
expr_stmt|;
name|munmap_segment
argument_list|(
name|fsp
argument_list|,
name|seg_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bi_tossold
parameter_list|(
name|client
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|void
modifier|*
name|client
decl_stmt|;
specifier|const
name|void
modifier|*
name|a
decl_stmt|;
specifier|const
name|void
modifier|*
name|b
decl_stmt|;
block|{
specifier|const
name|struct
name|tossstruct
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|(
expr|struct
name|tossstruct
operator|*
operator|)
name|client
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|BLOCK_INFO
operator|*
operator|)
name|a
operator|)
operator|->
name|bi_daddr
operator|==
name|LFS_UNUSED_DADDR
operator|||
name|datosn
argument_list|(
name|t
operator|->
name|lfs
argument_list|,
operator|(
operator|(
name|BLOCK_INFO
operator|*
operator|)
name|a
operator|)
operator|->
name|bi_daddr
argument_list|)
operator|!=
name|t
operator|->
name|seg
operator|)
return|;
block|}
end_function

end_unit

