begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Regents of the University of California.  * Copyright (c) 1988, 1992 The University of Utah and the Center  *	for Software Science (CSS).  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Center for Software Science of the University of Utah Computer  * Science Department.  CSS requests users of this software to return  * to css-dist@cs.utah.edu any improvements that they make and grant  * CSS redistribution rights.  *  * %sccs.include.redist.c%  *  *	@(#)utils.c	5.2 (Berkeley) %G%  *  * Utah $Hdr: utils.c 3.1 92/07/06$  * Author: Jeff Forys, University of Utah CSS  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)utils.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* **  DispPkt -- Display the contents of an RMPCONN packet. ** **	Parameters: **		rconn - packet to be displayed. **		direct - direction packet is going (DIR_*). ** **	Returns: **		Nothing. ** **	Side Effects: **		None. */
end_comment

begin_function
name|void
name|DispPkt
parameter_list|(
name|rconn
parameter_list|,
name|direct
parameter_list|)
name|RMPCONN
modifier|*
name|rconn
decl_stmt|;
name|int
name|direct
decl_stmt|;
block|{
specifier|static
name|char
name|BootFmt
index|[]
init|=
literal|"\t\tRetCode:%u SeqNo:%lx SessID:%x Vers:%u"
decl_stmt|;
specifier|static
name|char
name|ReadFmt
index|[]
init|=
literal|"\t\tRetCode:%u Offset:%lx SessID:%x\n"
decl_stmt|;
name|struct
name|tm
modifier|*
name|tmp
decl_stmt|;
specifier|register
name|struct
name|rmp_packet
modifier|*
name|rmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|omask
decl_stmt|;
name|u_int
name|t
decl_stmt|;
comment|/* 	 *  Since we will be working with RmpConns as well as DbgFp, we 	 *  must block signals that can affect either. 	 */
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGHUP
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGUSR1
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGUSR2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DbgFp
operator|==
name|NULL
condition|)
block|{
comment|/* sanity */
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* display direction packet is going using '>>>' or '<<<' */
name|fputs
argument_list|(
operator|(
name|direct
operator|==
name|DIR_RCVD
operator|)
condition|?
literal|"<<< "
else|:
operator|(
name|direct
operator|==
name|DIR_SENT
operator|)
condition|?
literal|">>> "
else|:
literal|""
argument_list|,
name|DbgFp
argument_list|)
expr_stmt|;
comment|/* display packet timestamp */
name|tmp
operator|=
name|localtime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|rconn
operator|->
name|tstamp
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"%02d:%02d:%02d.%06ld   "
argument_list|,
name|tmp
operator|->
name|tm_hour
argument_list|,
name|tmp
operator|->
name|tm_min
argument_list|,
name|tmp
operator|->
name|tm_sec
argument_list|,
name|rconn
operator|->
name|tstamp
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
comment|/* display src or dst addr and information about network interface */
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"Addr: %s   Intf: %s\n"
argument_list|,
name|EnetStr
argument_list|(
name|rconn
argument_list|)
argument_list|,
name|IntfName
argument_list|)
expr_stmt|;
name|rmp
operator|=
operator|&
name|rconn
operator|->
name|rmp
expr_stmt|;
comment|/* display IEEE 802.2 Logical Link Control header */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"\t802.2 LLC: DSAP:%x SSAP:%x CTRL:%x\n"
argument_list|,
name|rmp
operator|->
name|hp_llc
operator|.
name|dsap
argument_list|,
name|rmp
operator|->
name|hp_llc
operator|.
name|ssap
argument_list|,
name|rmp
operator|->
name|hp_llc
operator|.
name|cntrl
argument_list|)
expr_stmt|;
comment|/* display HP extensions to 802.2 Logical Link Control header */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"\tHP Ext:    DXSAP:%x SXSAP:%x\n"
argument_list|,
name|rmp
operator|->
name|hp_llc
operator|.
name|dxsap
argument_list|,
name|rmp
operator|->
name|hp_llc
operator|.
name|sxsap
argument_list|)
expr_stmt|;
comment|/* 	 *  Display information about RMP packet using type field to 	 *  determine what kind of packet this is. 	 */
switch|switch
condition|(
name|rmp
operator|->
name|r_type
condition|)
block|{
case|case
name|RMP_BOOT_REQ
case|:
comment|/* boot request */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"\tBoot Request:"
argument_list|)
expr_stmt|;
name|GETWORD
argument_list|(
name|rmp
operator|->
name|r_brq
operator|.
name|rmp_seqno
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmp
operator|->
name|r_brq
operator|.
name|rmp_session
operator|==
name|RMP_PROBESID
condition|)
block|{
if|if
condition|(
name|WORDZE
argument_list|(
name|rmp
operator|->
name|r_brq
operator|.
name|rmp_seqno
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" (Send Server ID)"
argument_list|,
name|DbgFp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|" (Send Filename #%u)"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|DbgFp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
name|BootFmt
argument_list|,
name|rmp
operator|->
name|r_brq
operator|.
name|rmp_retcode
argument_list|,
name|t
argument_list|,
name|rmp
operator|->
name|r_brq
operator|.
name|rmp_session
argument_list|,
name|rmp
operator|->
name|r_brq
operator|.
name|rmp_version
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"\n\t\tMachine Type: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RMP_MACHLEN
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fputc
argument_list|(
name|rmp
operator|->
name|r_brq
operator|.
name|rmp_machtype
index|[
name|i
index|]
argument_list|,
name|DbgFp
argument_list|)
expr_stmt|;
name|DspFlnm
argument_list|(
name|rmp
operator|->
name|r_brq
operator|.
name|rmp_flnmsize
argument_list|,
operator|&
name|rmp
operator|->
name|r_brq
operator|.
name|rmp_flnm
argument_list|)
expr_stmt|;
break|break;
case|case
name|RMP_BOOT_REPL
case|:
comment|/* boot reply */
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"\tBoot Reply:\n"
argument_list|)
expr_stmt|;
name|GETWORD
argument_list|(
name|rmp
operator|->
name|r_brpl
operator|.
name|rmp_seqno
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
name|BootFmt
argument_list|,
name|rmp
operator|->
name|r_brpl
operator|.
name|rmp_retcode
argument_list|,
name|t
argument_list|,
name|rmp
operator|->
name|r_brpl
operator|.
name|rmp_session
argument_list|,
name|rmp
operator|->
name|r_brpl
operator|.
name|rmp_version
argument_list|)
expr_stmt|;
name|DspFlnm
argument_list|(
name|rmp
operator|->
name|r_brpl
operator|.
name|rmp_flnmsize
argument_list|,
operator|&
name|rmp
operator|->
name|r_brpl
operator|.
name|rmp_flnm
argument_list|)
expr_stmt|;
break|break;
case|case
name|RMP_READ_REQ
case|:
comment|/* read request */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"\tRead Request:\n"
argument_list|)
expr_stmt|;
name|GETWORD
argument_list|(
name|rmp
operator|->
name|r_rrq
operator|.
name|rmp_offset
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
name|ReadFmt
argument_list|,
name|rmp
operator|->
name|r_rrq
operator|.
name|rmp_retcode
argument_list|,
name|t
argument_list|,
name|rmp
operator|->
name|r_rrq
operator|.
name|rmp_session
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"\t\tNoOfBytes: %u\n"
argument_list|,
name|rmp
operator|->
name|r_rrq
operator|.
name|rmp_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|RMP_READ_REPL
case|:
comment|/* read reply */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"\tRead Reply:\n"
argument_list|)
expr_stmt|;
name|GETWORD
argument_list|(
name|rmp
operator|->
name|r_rrpl
operator|.
name|rmp_offset
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
name|ReadFmt
argument_list|,
name|rmp
operator|->
name|r_rrpl
operator|.
name|rmp_retcode
argument_list|,
name|t
argument_list|,
name|rmp
operator|->
name|r_rrpl
operator|.
name|rmp_session
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"\t\tNoOfBytesSent: %d\n"
argument_list|,
name|rconn
operator|->
name|rmplen
operator|-
name|RMPREADSIZE
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RMP_BOOT_DONE
case|:
comment|/* boot complete */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"\tBoot Complete:\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"\t\tRetCode:%u SessID:%x\n"
argument_list|,
name|rmp
operator|->
name|r_done
operator|.
name|rmp_retcode
argument_list|,
name|rmp
operator|->
name|r_done
operator|.
name|rmp_session
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* ??? */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"\tUnknown Type:(%d)\n"
argument_list|,
name|rmp
operator|->
name|r_type
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|DbgFp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|DbgFp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
comment|/* reset old signal mask */
block|}
end_function

begin_comment
comment|/* **  GetEtherAddr -- convert an RMP (Ethernet) address into a string. ** **	An RMP BOOT packet has been received.  Look at the type field **	and process Boot Requests, Read Requests, and Boot Complete **	packets.  Any other type will be dropped with a warning msg. ** **	Parameters: **		addr - array of RMP_ADDRLEN bytes. ** **	Returns: **		Pointer to static string representation of `addr'. ** **	Side Effects: **		None. ** **	Warnings: **		- The return value points to a static buffer; it must **		  be copied if it's to be saved. **		- For speed, we assume a u_char consists of 8 bits. */
end_comment

begin_function
name|char
modifier|*
name|GetEtherAddr
parameter_list|(
name|addr
parameter_list|)
name|u_char
modifier|*
name|addr
decl_stmt|;
block|{
specifier|static
name|char
name|Hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
specifier|static
name|char
name|etherstr
index|[
name|RMP_ADDRLEN
operator|*
literal|3
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
comment|/* 	 *  For each byte in `addr', convert it to "<hexchar><hexchar>:". 	 *  The last byte does not get a trailing `:' appended. 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|cp1
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
expr_stmt|;
name|cp2
operator|=
name|etherstr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|cp2
operator|++
operator|=
name|Hex
index|[
operator|*
name|cp1
operator|>>
literal|4
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
name|Hex
index|[
operator|*
name|cp1
operator|++
operator|&
literal|0xf
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|RMP_ADDRLEN
condition|)
break|break;
operator|*
name|cp2
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|etherstr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  DispFlnm -- Print a string of bytes to DbgFp (often, a file name). ** **	Parameters: **		size - number of bytes to print. **		flnm - address of first byte. ** **	Returns: **		Nothing. ** **	Side Effects: **		- Characters are sent to `DbgFp'. */
end_comment

begin_function
name|void
name|DspFlnm
parameter_list|(
name|size
parameter_list|,
name|flnm
parameter_list|)
specifier|register
name|u_int
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|flnm
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|DbgFp
argument_list|,
literal|"\n\t\tFile Name (%d):<"
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fputc
argument_list|(
operator|*
name|flnm
operator|++
argument_list|,
name|DbgFp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|">\n"
argument_list|,
name|DbgFp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  NewClient -- allocate memory for a new CLIENT. ** **	Parameters: **		addr - RMP (Ethernet) address of new client. ** **	Returns: **		Ptr to new CLIENT or NULL if we ran out of memory. ** **	Side Effects: **		- Memory will be malloc'd for the new CLIENT. **		- If malloc() fails, a log message will be generated. */
end_comment

begin_function
name|CLIENT
modifier|*
name|NewClient
parameter_list|(
name|addr
parameter_list|)
name|u_char
modifier|*
name|addr
decl_stmt|;
block|{
name|CLIENT
modifier|*
name|ctmp
decl_stmt|;
if|if
condition|(
operator|(
name|ctmp
operator|=
operator|(
name|CLIENT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CLIENT
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"NewClient: out of memory (%s)"
argument_list|,
name|GetEtherAddr
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|ctmp
argument_list|,
sizeof|sizeof
argument_list|(
name|CLIENT
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
operator|&
name|ctmp
operator|->
name|addr
index|[
literal|0
index|]
argument_list|,
name|RMP_ADDRLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  FreeClient -- free linked list of Clients. ** **	Parameters: **		None. ** **	Returns: **		Nothing. ** **	Side Effects: **		- All malloc'd memory associated with the linked list of **		  CLIENTS will be free'd; `Clients' will be set to NULL. ** **	Warnings: **		- This routine must be called with SIGHUP blocked. */
end_comment

begin_function
name|void
name|FreeClients
parameter_list|()
block|{
specifier|register
name|CLIENT
modifier|*
name|ctmp
decl_stmt|;
while|while
condition|(
name|Clients
operator|!=
name|NULL
condition|)
block|{
name|ctmp
operator|=
name|Clients
expr_stmt|;
name|Clients
operator|=
name|Clients
operator|->
name|next
expr_stmt|;
name|FreeClient
argument_list|(
name|ctmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  NewStr -- allocate memory for a character array. ** **	Parameters: **		str - null terminated character array. ** **	Returns: **		Ptr to new character array or NULL if we ran out of memory. ** **	Side Effects: **		- Memory will be malloc'd for the new character array. **		- If malloc() fails, a log message will be generated. */
end_comment

begin_function
name|char
modifier|*
name|NewStr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|stmp
decl_stmt|;
if|if
condition|(
operator|(
name|stmp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"NewStr: out of memory (%s)"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|stmp
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|stmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  To save time, NewConn and FreeConn maintain a cache of one RMPCONN **  in `LastFree' (defined below). */
end_comment

begin_decl_stmt
specifier|static
name|RMPCONN
modifier|*
name|LastFree
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  NewConn -- allocate memory for a new RMPCONN connection. ** **	Parameters: **		rconn - initialization template for new connection. ** **	Returns: **		Ptr to new RMPCONN or NULL if we ran out of memory. ** **	Side Effects: **		- Memory may be malloc'd for the new RMPCONN (if not cached). **		- If malloc() fails, a log message will be generated. */
end_comment

begin_function
name|RMPCONN
modifier|*
name|NewConn
parameter_list|(
name|rconn
parameter_list|)
name|RMPCONN
modifier|*
name|rconn
decl_stmt|;
block|{
name|RMPCONN
modifier|*
name|rtmp
decl_stmt|;
if|if
condition|(
name|LastFree
operator|==
name|NULL
condition|)
block|{
comment|/* nothing cached; make a new one */
if|if
condition|(
operator|(
name|rtmp
operator|=
operator|(
name|RMPCONN
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RMPCONN
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"NewConn: out of memory (%s)"
argument_list|,
name|EnetStr
argument_list|(
name|rconn
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* use the cached RMPCONN */
name|rtmp
operator|=
name|LastFree
expr_stmt|;
name|LastFree
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 *  Copy template into `rtmp', init file descriptor to `-1' and 	 *  set ptr to next elem NULL. 	 */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rconn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rtmp
argument_list|,
sizeof|sizeof
argument_list|(
name|RMPCONN
argument_list|)
argument_list|)
expr_stmt|;
name|rtmp
operator|->
name|bootfd
operator|=
operator|-
literal|1
expr_stmt|;
name|rtmp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rtmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  FreeConn -- Free memory associated with an RMPCONN connection. ** **	Parameters: **		rtmp - ptr to RMPCONN to be free'd. ** **	Returns: **		Nothing. ** **	Side Effects: **		- Memory associated with `rtmp' may be free'd (or cached). **		- File desc associated with `rtmp->bootfd' will be closed. */
end_comment

begin_function
name|void
name|FreeConn
parameter_list|(
name|rtmp
parameter_list|)
specifier|register
name|RMPCONN
modifier|*
name|rtmp
decl_stmt|;
block|{
comment|/* 	 *  If the file descriptor is in use, close the file. 	 */
if|if
condition|(
name|rtmp
operator|->
name|bootfd
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|rtmp
operator|->
name|bootfd
argument_list|)
expr_stmt|;
name|rtmp
operator|->
name|bootfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|LastFree
operator|==
name|NULL
condition|)
comment|/* cache for next time */
name|rtmp
operator|=
name|LastFree
expr_stmt|;
else|else
comment|/* already one cached; free this one */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rtmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  FreeConns -- free linked list of RMPCONN connections. ** **	Parameters: **		None. ** **	Returns: **		Nothing. ** **	Side Effects: **		- All malloc'd memory associated with the linked list of **		  connections will be free'd; `RmpConns' will be set to NULL. **		- If LastFree is != NULL, it too will be free'd& NULL'd. ** **	Warnings: **		- This routine must be called with SIGHUP blocked. */
end_comment

begin_function
name|void
name|FreeConns
parameter_list|()
block|{
specifier|register
name|RMPCONN
modifier|*
name|rtmp
decl_stmt|;
while|while
condition|(
name|RmpConns
operator|!=
name|NULL
condition|)
block|{
name|rtmp
operator|=
name|RmpConns
expr_stmt|;
name|RmpConns
operator|=
name|RmpConns
operator|->
name|next
expr_stmt|;
name|FreeConn
argument_list|(
name|rtmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LastFree
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|LastFree
argument_list|)
expr_stmt|;
name|LastFree
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  AddConn -- Add a connection to the linked list of connections. ** **	Parameters: **		rconn - connection to be added. ** **	Returns: **		Nothing. ** **	Side Effects: **		- RmpConn will point to new connection. ** **	Warnings: **		- This routine must be called with SIGHUP blocked. */
end_comment

begin_function
name|void
name|AddConn
parameter_list|(
name|rconn
parameter_list|)
specifier|register
name|RMPCONN
modifier|*
name|rconn
decl_stmt|;
block|{
if|if
condition|(
name|RmpConns
operator|!=
name|NULL
condition|)
name|rconn
operator|->
name|next
operator|=
name|RmpConns
expr_stmt|;
name|RmpConns
operator|=
name|rconn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  FindConn -- Find a connection in the linked list of connections. ** **	We use the RMP (Ethernet) address as the basis for determining **	if this is the same connection.  According to the Remote Maint **	Protocol, we can only have one connection with any machine. ** **	Parameters: **		rconn - connection to be found. ** **	Returns: **		Matching connection from linked list or NULL if not found. ** **	Side Effects: **		None. ** **	Warnings: **		- This routine must be called with SIGHUP blocked. */
end_comment

begin_function
name|RMPCONN
modifier|*
name|FindConn
parameter_list|(
name|rconn
parameter_list|)
specifier|register
name|RMPCONN
modifier|*
name|rconn
decl_stmt|;
block|{
specifier|register
name|RMPCONN
modifier|*
name|rtmp
decl_stmt|;
for|for
control|(
name|rtmp
operator|=
name|RmpConns
init|;
name|rtmp
operator|!=
name|NULL
condition|;
name|rtmp
operator|=
name|rtmp
operator|->
name|next
control|)
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rconn
operator|->
name|rmp
operator|.
name|hp_hdr
operator|.
name|saddr
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rtmp
operator|->
name|rmp
operator|.
name|hp_hdr
operator|.
name|saddr
index|[
literal|0
index|]
argument_list|,
name|RMP_ADDRLEN
argument_list|)
operator|==
literal|0
condition|)
break|break;
return|return
operator|(
name|rtmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  RemoveConn -- Remove a connection from the linked list of connections. ** **	Parameters: **		rconn - connection to be removed. ** **	Returns: **		Nothing. ** **	Side Effects: **		- If found, an RMPCONN will cease to exist and it will **		  be removed from the linked list. ** **	Warnings: **		- This routine must be called with SIGHUP blocked. */
end_comment

begin_function
name|void
name|RemoveConn
parameter_list|(
name|rconn
parameter_list|)
specifier|register
name|RMPCONN
modifier|*
name|rconn
decl_stmt|;
block|{
specifier|register
name|RMPCONN
modifier|*
name|thisrconn
decl_stmt|,
modifier|*
name|lastrconn
decl_stmt|;
if|if
condition|(
name|RmpConns
operator|==
name|rconn
condition|)
block|{
comment|/* easy case */
name|RmpConns
operator|=
name|RmpConns
operator|->
name|next
expr_stmt|;
name|FreeConn
argument_list|(
name|rconn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* must traverse linked list */
name|lastrconn
operator|=
name|RmpConns
expr_stmt|;
comment|/* set back ptr */
name|thisrconn
operator|=
name|lastrconn
operator|->
name|next
expr_stmt|;
comment|/* set current ptr */
while|while
condition|(
name|thisrconn
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rconn
operator|==
name|thisrconn
condition|)
block|{
comment|/* found it */
name|lastrconn
operator|->
name|next
operator|=
name|thisrconn
operator|->
name|next
expr_stmt|;
name|FreeConn
argument_list|(
name|thisrconn
argument_list|)
expr_stmt|;
break|break;
block|}
name|lastrconn
operator|=
name|thisrconn
expr_stmt|;
name|thisrconn
operator|=
name|thisrconn
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

