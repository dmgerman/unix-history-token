begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)subr.c	4.3 (Berkeley) 84/06/05"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Melbourne getty.  */
end_comment

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|"gettytab.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|sgttyb
name|tmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|tchars
name|tc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ltchars
name|ltc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get a table entry.  */
end_comment

begin_macro
name|gettable
argument_list|(
argument|name
argument_list|,
argument|buf
argument_list|,
argument|area
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|buf
decl_stmt|,
modifier|*
name|area
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|gettystrs
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|gettynums
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|gettyflags
modifier|*
name|fp
decl_stmt|;
specifier|register
name|n
expr_stmt|;
name|hopcount
operator|=
literal|0
expr_stmt|;
comment|/* new lookup, start fresh */
if|if
condition|(
name|getent
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
operator|!=
literal|1
condition|)
return|return;
for|for
control|(
name|sp
operator|=
name|gettystrs
init|;
name|sp
operator|->
name|field
condition|;
name|sp
operator|++
control|)
name|sp
operator|->
name|value
operator|=
name|getstr
argument_list|(
name|sp
operator|->
name|field
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|gettynums
init|;
name|np
operator|->
name|field
condition|;
name|np
operator|++
control|)
block|{
name|n
operator|=
name|getnum
argument_list|(
name|np
operator|->
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|np
operator|->
name|set
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|np
operator|->
name|set
operator|=
literal|1
expr_stmt|;
name|np
operator|->
name|value
operator|=
name|n
expr_stmt|;
block|}
block|}
for|for
control|(
name|fp
operator|=
name|gettyflags
init|;
name|fp
operator|->
name|field
condition|;
name|fp
operator|++
control|)
block|{
name|n
operator|=
name|getflag
argument_list|(
name|fp
operator|->
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|fp
operator|->
name|set
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|fp
operator|->
name|set
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|value
operator|=
name|n
operator|^
name|fp
operator|->
name|invrt
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|gendefaults
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|gettystrs
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|gettynums
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|gettyflags
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|gettystrs
init|;
name|sp
operator|->
name|field
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|value
condition|)
name|sp
operator|->
name|defalt
operator|=
name|sp
operator|->
name|value
expr_stmt|;
for|for
control|(
name|np
operator|=
name|gettynums
init|;
name|np
operator|->
name|field
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|np
operator|->
name|set
condition|)
name|np
operator|->
name|defalt
operator|=
name|np
operator|->
name|value
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|gettyflags
init|;
name|fp
operator|->
name|field
condition|;
name|fp
operator|++
control|)
if|if
condition|(
name|fp
operator|->
name|set
condition|)
name|fp
operator|->
name|defalt
operator|=
name|fp
operator|->
name|value
expr_stmt|;
else|else
name|fp
operator|->
name|defalt
operator|=
name|fp
operator|->
name|invrt
expr_stmt|;
block|}
end_block

begin_macro
name|setdefaults
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|gettystrs
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|gettynums
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|gettyflags
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|gettystrs
init|;
name|sp
operator|->
name|field
condition|;
name|sp
operator|++
control|)
if|if
condition|(
operator|!
name|sp
operator|->
name|value
condition|)
name|sp
operator|->
name|value
operator|=
name|sp
operator|->
name|defalt
expr_stmt|;
for|for
control|(
name|np
operator|=
name|gettynums
init|;
name|np
operator|->
name|field
condition|;
name|np
operator|++
control|)
if|if
condition|(
operator|!
name|np
operator|->
name|set
condition|)
name|np
operator|->
name|value
operator|=
name|np
operator|->
name|defalt
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|gettyflags
init|;
name|fp
operator|->
name|field
condition|;
name|fp
operator|++
control|)
if|if
condition|(
operator|!
name|fp
operator|->
name|set
condition|)
name|fp
operator|->
name|value
operator|=
name|fp
operator|->
name|defalt
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|charnames
index|[]
init|=
block|{
operator|&
name|ER
block|,
operator|&
name|KL
block|,
operator|&
name|IN
block|,
operator|&
name|QU
block|,
operator|&
name|XN
block|,
operator|&
name|XF
block|,
operator|&
name|ET
block|,
operator|&
name|BK
block|,
operator|&
name|SU
block|,
operator|&
name|DS
block|,
operator|&
name|RP
block|,
operator|&
name|FL
block|,
operator|&
name|WE
block|,
operator|&
name|LN
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|charvars
index|[]
init|=
block|{
operator|&
name|tmode
operator|.
name|sg_erase
block|,
operator|&
name|tmode
operator|.
name|sg_kill
block|,
operator|&
name|tc
operator|.
name|t_intrc
block|,
operator|&
name|tc
operator|.
name|t_quitc
block|,
operator|&
name|tc
operator|.
name|t_startc
block|,
operator|&
name|tc
operator|.
name|t_stopc
block|,
operator|&
name|tc
operator|.
name|t_eofc
block|,
operator|&
name|tc
operator|.
name|t_brkc
block|,
operator|&
name|ltc
operator|.
name|t_suspc
block|,
operator|&
name|ltc
operator|.
name|t_dsuspc
block|,
operator|&
name|ltc
operator|.
name|t_rprntc
block|,
operator|&
name|ltc
operator|.
name|t_flushc
block|,
operator|&
name|ltc
operator|.
name|t_werasc
block|,
operator|&
name|ltc
operator|.
name|t_lnextc
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|setchars
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|charnames
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
operator|*
name|charnames
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
operator|*
name|charvars
index|[
name|i
index|]
operator|=
operator|*
name|p
expr_stmt|;
else|else
operator|*
name|charvars
index|[
name|i
index|]
operator|=
literal|'\0377'
expr_stmt|;
block|}
block|}
end_block

begin_function
name|long
name|setflags
parameter_list|(
name|n
parameter_list|)
block|{
specifier|register
name|long
name|f
decl_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|F0set
condition|)
return|return
operator|(
name|F0
operator|)
return|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|F1set
condition|)
return|return
operator|(
name|F1
operator|)
return|;
break|break;
default|default:
if|if
condition|(
name|F2set
condition|)
return|return
operator|(
name|F2
operator|)
return|;
break|break;
block|}
name|f
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|AP
condition|)
name|f
operator||=
name|ANYP
expr_stmt|;
elseif|else
if|if
condition|(
name|OP
condition|)
name|f
operator||=
name|ODDP
expr_stmt|;
elseif|else
if|if
condition|(
name|EP
condition|)
name|f
operator||=
name|EVENP
expr_stmt|;
if|if
condition|(
name|UC
condition|)
name|f
operator||=
name|LCASE
expr_stmt|;
if|if
condition|(
name|NL
condition|)
name|f
operator||=
name|CRMOD
expr_stmt|;
name|f
operator||=
name|delaybits
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
comment|/* read mode flags */
if|if
condition|(
name|RW
condition|)
name|f
operator||=
name|RAW
expr_stmt|;
else|else
name|f
operator||=
name|CBREAK
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|HT
condition|)
name|f
operator||=
name|XTABS
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|f
operator|)
return|;
if|if
condition|(
name|CB
condition|)
name|f
operator||=
name|CRTBS
expr_stmt|;
if|if
condition|(
name|CE
condition|)
name|f
operator||=
name|CRTERA
expr_stmt|;
if|if
condition|(
name|CK
condition|)
name|f
operator||=
name|CRTKIL
expr_stmt|;
if|if
condition|(
name|PE
condition|)
name|f
operator||=
name|PRTERA
expr_stmt|;
if|if
condition|(
name|EC
condition|)
name|f
operator||=
name|ECHO
expr_stmt|;
if|if
condition|(
name|XC
condition|)
name|f
operator||=
name|CTLECH
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|delayval
block|{
name|unsigned
name|delay
decl_stmt|;
comment|/* delay in ms */
name|int
name|bits
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * below are random guesses, I can't be bothered checking  */
end_comment

begin_decl_stmt
name|struct
name|delayval
name|crdelay
index|[]
init|=
block|{
literal|1
block|,
name|CR1
block|,
literal|2
block|,
name|CR2
block|,
literal|3
block|,
name|CR3
block|,
literal|83
block|,
name|CR1
block|,
literal|166
block|,
name|CR2
block|,
literal|0
block|,
name|CR3
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delayval
name|nldelay
index|[]
init|=
block|{
literal|1
block|,
name|NL1
block|,
comment|/* special, calculated */
literal|2
block|,
name|NL2
block|,
literal|3
block|,
name|NL3
block|,
literal|100
block|,
name|NL2
block|,
literal|0
block|,
name|NL3
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delayval
name|bsdelay
index|[]
init|=
block|{
literal|1
block|,
name|BS1
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delayval
name|ffdelay
index|[]
init|=
block|{
literal|1
block|,
name|FF1
block|,
literal|1750
block|,
name|FF1
block|,
literal|0
block|,
name|FF1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delayval
name|tbdelay
index|[]
init|=
block|{
literal|1
block|,
name|TAB1
block|,
literal|2
block|,
name|TAB2
block|,
literal|3
block|,
name|XTABS
block|,
comment|/* this is expand tabs */
literal|100
block|,
name|TAB1
block|,
literal|0
block|,
name|TAB2
block|, }
decl_stmt|;
end_decl_stmt

begin_macro
name|delaybits
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|f
expr_stmt|;
name|f
operator|=
name|adelay
argument_list|(
name|CD
argument_list|,
name|crdelay
argument_list|)
expr_stmt|;
name|f
operator||=
name|adelay
argument_list|(
name|ND
argument_list|,
name|nldelay
argument_list|)
expr_stmt|;
name|f
operator||=
name|adelay
argument_list|(
name|FD
argument_list|,
name|ffdelay
argument_list|)
expr_stmt|;
name|f
operator||=
name|adelay
argument_list|(
name|TD
argument_list|,
name|tbdelay
argument_list|)
expr_stmt|;
name|f
operator||=
name|adelay
argument_list|(
name|BD
argument_list|,
name|bsdelay
argument_list|)
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|adelay
argument_list|(
name|ms
argument_list|,
name|dp
argument_list|)
specifier|register
name|ms
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|delayval
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|ms
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|dp
operator|->
name|delay
operator|&&
name|ms
operator|>
name|dp
operator|->
name|delay
condition|)
name|dp
operator|++
expr_stmt|;
return|return
operator|(
name|dp
operator|->
name|bits
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|editedhost
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|edithost
argument_list|(
name|pat
argument_list|)
specifier|register
name|char
operator|*
name|pat
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|host
init|=
name|HN
decl_stmt|;
specifier|register
name|char
modifier|*
name|res
init|=
name|editedhost
decl_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
name|pat
operator|=
literal|""
expr_stmt|;
while|while
condition|(
operator|*
name|pat
condition|)
block|{
switch|switch
condition|(
operator|*
name|pat
condition|)
block|{
case|case
literal|'#'
case|:
if|if
condition|(
operator|*
name|host
condition|)
name|host
operator|++
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
operator|*
name|host
condition|)
operator|*
name|res
operator|++
operator|=
operator|*
name|host
operator|++
expr_stmt|;
break|break;
default|default:
operator|*
name|res
operator|++
operator|=
operator|*
name|pat
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|res
operator|==
operator|&
name|editedhost
index|[
sizeof|sizeof
name|editedhost
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|res
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|pat
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|host
condition|)
name|strncpy
argument_list|(
name|res
argument_list|,
name|host
argument_list|,
sizeof|sizeof
name|editedhost
operator|-
operator|(
name|res
operator|-
name|editedhost
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|res
operator|=
literal|'\0'
expr_stmt|;
name|editedhost
index|[
sizeof|sizeof
name|editedhost
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|speedtab
block|{
name|int
name|speed
decl_stmt|;
name|int
name|uxname
decl_stmt|;
block|}
name|speedtab
index|[]
init|=
block|{
literal|50
block|,
name|B50
block|,
literal|75
block|,
name|B75
block|,
literal|110
block|,
name|B110
block|,
literal|134
block|,
name|B134
block|,
literal|150
block|,
name|B150
block|,
literal|200
block|,
name|B200
block|,
literal|300
block|,
name|B300
block|,
literal|600
block|,
name|B600
block|,
literal|1200
block|,
name|B1200
block|,
literal|1800
block|,
name|B1800
block|,
literal|2400
block|,
name|B2400
block|,
literal|4800
block|,
name|B4800
block|,
literal|9600
block|,
name|B9600
block|,
literal|19200
block|,
name|EXTA
block|,
literal|19
block|,
name|EXTA
block|,
comment|/* for people who say 19.2K */
literal|38400
block|,
name|EXTB
block|,
literal|38
block|,
name|EXTB
block|,
literal|7200
block|,
name|EXTB
block|,
comment|/* alternative */
literal|0
block|}
struct|;
end_struct

begin_macro
name|speed
argument_list|(
argument|val
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|speedtab
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|val
operator|<=
literal|15
condition|)
return|return
operator|(
name|val
operator|)
return|;
for|for
control|(
name|sp
operator|=
name|speedtab
init|;
name|sp
operator|->
name|speed
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|speed
operator|==
name|val
condition|)
return|return
operator|(
name|sp
operator|->
name|uxname
operator|)
return|;
return|return
operator|(
name|B300
operator|)
return|;
comment|/* default in impossible cases */
block|}
end_block

begin_macro
name|makeenv
argument_list|(
argument|env
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|env
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|termbuf
index|[
literal|128
index|]
init|=
literal|"TERM="
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|ep
operator|=
name|env
expr_stmt|;
if|if
condition|(
name|TT
operator|&&
operator|*
name|TT
condition|)
block|{
name|strcat
argument_list|(
name|termbuf
argument_list|,
name|TT
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|termbuf
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|=
name|EV
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|q
operator|=
name|index
argument_list|(
name|q
argument_list|,
literal|','
argument_list|)
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|ep
operator|++
operator|=
name|p
expr_stmt|;
block|}
operator|*
name|ep
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This speed select mechanism is written for the Develcon DATASWITCH.  * The Develcon sends a string of the form "B{speed}\n" at a predefined  * baud rate. This string indicates the user's actual speed.  * The routine below returns the terminal type mapped from derived speed.  */
end_comment

begin_struct
struct|struct
name|portselect
block|{
name|char
modifier|*
name|ps_baud
decl_stmt|;
name|char
modifier|*
name|ps_type
decl_stmt|;
block|}
name|portspeeds
index|[]
init|=
block|{
block|{
literal|"B110"
block|,
literal|"std.110"
block|}
block|,
block|{
literal|"B134"
block|,
literal|"std.134"
block|}
block|,
block|{
literal|"B150"
block|,
literal|"std.150"
block|}
block|,
block|{
literal|"B300"
block|,
literal|"std.300"
block|}
block|,
block|{
literal|"B600"
block|,
literal|"std.600"
block|}
block|,
block|{
literal|"B1200"
block|,
literal|"std.1200"
block|}
block|,
block|{
literal|"B2400"
block|,
literal|"std.2400"
block|}
block|,
block|{
literal|"B4800"
block|,
literal|"std.4800"
block|}
block|,
block|{
literal|"B9600"
block|,
literal|"std.9600"
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
end_struct

begin_function
name|char
modifier|*
name|portselector
parameter_list|()
block|{
name|char
name|c
decl_stmt|,
name|baud
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|type
init|=
literal|"default"
decl_stmt|;
specifier|register
name|struct
name|portselect
modifier|*
name|ps
decl_stmt|;
name|int
name|len
decl_stmt|;
name|alarm
argument_list|(
literal|5
operator|*
literal|60
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
sizeof|sizeof
argument_list|(
name|baud
argument_list|)
operator|-
literal|1
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|c
operator|&=
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'B'
condition|)
name|len
operator|=
literal|0
expr_stmt|;
comment|/* in case of leading garbage */
name|baud
index|[
name|len
index|]
operator|=
name|c
expr_stmt|;
block|}
name|baud
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ps
operator|=
name|portspeeds
init|;
name|ps
operator|->
name|ps_baud
condition|;
name|ps
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ps
operator|->
name|ps_baud
argument_list|,
name|baud
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|ps
operator|->
name|ps_type
expr_stmt|;
break|break;
block|}
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* wait for connection to complete */
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

end_unit

