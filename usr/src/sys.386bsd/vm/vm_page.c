begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * The Mach Operating System project at Carnegie-Mellon University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)vm_page.c	7.4 (Berkeley) 5/7/91  *  *  * Copyright (c) 1987, 1990 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Avadis Tevanian, Jr., Michael Wayne Young  *   * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND   * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         1       00074  * --------------------         -----   ----------------------  *  * 22 Jan 93	Paul Mackerras		Fixed bug where pages got lost  *  */
end_comment

begin_comment
comment|/*  *	Resident memory management module.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"vm_map.h"
end_include

begin_include
include|#
directive|include
file|"vm_page.h"
end_include

begin_include
include|#
directive|include
file|"vm_pageout.h"
end_include

begin_comment
comment|/*  *	Associated with page of user-allocatable memory is a  *	page structure.  */
end_comment

begin_decl_stmt
name|queue_head_t
modifier|*
name|vm_page_buckets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of buckets */
end_comment

begin_decl_stmt
name|int
name|vm_page_bucket_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How big is array? */
end_comment

begin_decl_stmt
name|int
name|vm_page_hash_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mask for hash function */
end_comment

begin_decl_stmt
name|simple_lock_data_t
name|bucket_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lock for all buckets XXX */
end_comment

begin_decl_stmt
name|vm_size_t
name|page_size
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_size_t
name|page_mask
init|=
literal|4095
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|page_shift
init|=
literal|12
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|queue_head_t
name|vm_page_queue_free
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|queue_head_t
name|vm_page_queue_active
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|queue_head_t
name|vm_page_queue_inactive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|simple_lock_data_t
name|vm_page_queue_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|simple_lock_data_t
name|vm_page_queue_free_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_page_t
name|vm_page_array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|first_page
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|last_page
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|first_phys_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|last_phys_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_free_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_active_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_inactive_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_wire_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_laundry_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_free_target
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_free_min
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_inactive_target
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_free_reserved
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	vm_set_page_size:  *  *	Sets the page size, perhaps based upon the memory  *	size.  Must be called before any use of page-size  *	dependent functions.  *  *	Sets page_shift and page_mask from page_size.  */
end_comment

begin_function
name|void
name|vm_set_page_size
parameter_list|()
block|{
name|page_mask
operator|=
name|page_size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|page_mask
operator|&
name|page_size
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"vm_set_page_size: page size not a power of two"
argument_list|)
expr_stmt|;
for|for
control|(
name|page_shift
operator|=
literal|0
init|;
condition|;
name|page_shift
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|page_shift
operator|)
operator|==
name|page_size
condition|)
break|break;
block|}
end_function

begin_comment
comment|/*  *	vm_page_startup:  *  *	Initializes the resident memory module.  *  *	Allocates memory for the page cells, and  *	for the object/offset-to-page hash table headers.  *	Each page cell is initialized and placed on the free list.  */
end_comment

begin_function
name|vm_offset_t
name|vm_page_startup
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|,
name|vaddr
parameter_list|)
specifier|register
name|vm_offset_t
name|start
decl_stmt|;
name|vm_offset_t
name|end
decl_stmt|;
specifier|register
name|vm_offset_t
name|vaddr
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|mapped
decl_stmt|;
specifier|register
name|vm_page_t
name|m
decl_stmt|;
specifier|register
name|queue_t
name|bucket
decl_stmt|;
name|vm_size_t
name|npages
decl_stmt|;
specifier|register
name|vm_offset_t
name|new_start
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
specifier|extern
name|vm_offset_t
name|kentry_data
decl_stmt|;
specifier|extern
name|vm_size_t
name|kentry_data_size
decl_stmt|;
comment|/* 	 *	Initialize the locks 	 */
name|simple_lock_init
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|simple_lock_init
argument_list|(
operator|&
name|vm_page_queue_lock
argument_list|)
expr_stmt|;
comment|/* 	 *	Initialize the queue headers for the free queue, 	 *	the active queue and the inactive queue. 	 */
name|queue_init
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|)
expr_stmt|;
name|queue_init
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|)
expr_stmt|;
name|queue_init
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|)
expr_stmt|;
comment|/* 	 *	Allocate (and initialize) the hash table buckets. 	 * 	 *	The number of buckets MUST BE a power of 2, and 	 *	the actual value is the next power of 2 greater 	 *	than the number of physical pages in the system. 	 * 	 *	Note: 	 *		This computation can be tweaked if desired. 	 */
name|vm_page_buckets
operator|=
operator|(
name|queue_t
operator|)
name|vaddr
expr_stmt|;
name|bucket
operator|=
name|vm_page_buckets
expr_stmt|;
if|if
condition|(
name|vm_page_bucket_count
operator|==
literal|0
condition|)
block|{
name|vm_page_bucket_count
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|vm_page_bucket_count
operator|<
name|atop
argument_list|(
name|end
operator|-
name|start
argument_list|)
condition|)
name|vm_page_bucket_count
operator|<<=
literal|1
expr_stmt|;
block|}
name|vm_page_hash_mask
operator|=
name|vm_page_bucket_count
operator|-
literal|1
expr_stmt|;
comment|/* 	 *	Validate these addresses. 	 */
name|new_start
operator|=
name|round_page
argument_list|(
operator|(
operator|(
name|queue_t
operator|)
name|start
operator|)
operator|+
name|vm_page_bucket_count
argument_list|)
expr_stmt|;
name|mapped
operator|=
name|vaddr
expr_stmt|;
name|vaddr
operator|=
name|pmap_map
argument_list|(
name|mapped
argument_list|,
name|start
argument_list|,
name|new_start
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|start
operator|=
name|new_start
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mapped
argument_list|,
name|vaddr
operator|-
name|mapped
argument_list|)
expr_stmt|;
name|mapped
operator|=
name|vaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|vm_page_bucket_count
init|;
name|i
operator|--
condition|;
control|)
block|{
name|queue_init
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
name|bucket
operator|++
expr_stmt|;
block|}
name|simple_lock_init
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
comment|/* 	 *	round (or truncate) the addresses to our page size. 	 */
name|end
operator|=
name|trunc_page
argument_list|(
name|end
argument_list|)
expr_stmt|;
comment|/* 	 *	Pre-allocate maps and map entries that cannot be dynamically 	 *	allocated via malloc().  The maps include the kernel_map and 	 *	kmem_map which must be initialized before malloc() will 	 *	work (obviously).  Also could include pager maps which would 	 *	be allocated before kmeminit. 	 * 	 *	Allow some kernel map entries... this should be plenty 	 *	since people shouldn't be cluttering up the kernel 	 *	map (they should use their own maps). 	 */
name|kentry_data_size
operator|=
name|MAX_KMAP
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map
argument_list|)
operator|+
name|MAX_KMAPENT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map_entry
argument_list|)
expr_stmt|;
name|kentry_data_size
operator|=
name|round_page
argument_list|(
name|kentry_data_size
argument_list|)
expr_stmt|;
name|kentry_data
operator|=
operator|(
name|vm_offset_t
operator|)
name|vaddr
expr_stmt|;
name|vaddr
operator|+=
name|kentry_data_size
expr_stmt|;
comment|/* 	 *	Validate these zone addresses. 	 */
name|new_start
operator|=
name|start
operator|+
operator|(
name|vaddr
operator|-
name|mapped
operator|)
expr_stmt|;
name|pmap_map
argument_list|(
name|mapped
argument_list|,
name|start
argument_list|,
name|new_start
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mapped
argument_list|,
operator|(
name|vaddr
operator|-
name|mapped
operator|)
argument_list|)
expr_stmt|;
name|mapped
operator|=
name|vaddr
expr_stmt|;
name|start
operator|=
name|new_start
expr_stmt|;
comment|/*  	 *	Compute the number of pages of memory that will be 	 *	available for use (taking into account the overhead 	 *	of a page structure per page). 	 */
name|vm_page_free_count
operator|=
name|npages
operator|=
operator|(
name|end
operator|-
name|start
operator|)
operator|/
operator|(
name|PAGE_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 *	Initialize the mem entry structures now, and 	 *	put them in the free queue. 	 */
name|m
operator|=
name|vm_page_array
operator|=
operator|(
name|vm_page_t
operator|)
name|vaddr
expr_stmt|;
name|first_page
operator|=
name|start
expr_stmt|;
name|first_page
operator|+=
name|npages
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
expr_stmt|;
name|first_page
operator|=
name|atop
argument_list|(
name|round_page
argument_list|(
name|first_page
argument_list|)
argument_list|)
expr_stmt|;
name|last_page
operator|=
name|first_page
operator|+
name|npages
operator|-
literal|1
expr_stmt|;
name|first_phys_addr
operator|=
name|ptoa
argument_list|(
name|first_page
argument_list|)
expr_stmt|;
name|last_phys_addr
operator|=
name|ptoa
argument_list|(
name|last_page
argument_list|)
operator|+
name|page_mask
expr_stmt|;
comment|/* 	 *	Validate these addresses. 	 */
name|new_start
operator|=
name|start
operator|+
operator|(
name|round_page
argument_list|(
name|m
operator|+
name|npages
argument_list|)
operator|-
name|mapped
operator|)
expr_stmt|;
name|mapped
operator|=
name|pmap_map
argument_list|(
name|mapped
argument_list|,
name|start
argument_list|,
name|new_start
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|start
operator|=
name|new_start
expr_stmt|;
comment|/* 	 *	Clear all of the page structures 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|m
argument_list|,
name|npages
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|pa
operator|=
name|first_phys_addr
expr_stmt|;
while|while
condition|(
name|npages
operator|--
condition|)
block|{
name|m
operator|->
name|copy_on_write
operator|=
name|FALSE
expr_stmt|;
name|m
operator|->
name|wanted
operator|=
name|FALSE
expr_stmt|;
name|m
operator|->
name|inactive
operator|=
name|FALSE
expr_stmt|;
name|m
operator|->
name|active
operator|=
name|FALSE
expr_stmt|;
name|m
operator|->
name|busy
operator|=
name|FALSE
expr_stmt|;
name|m
operator|->
name|object
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|phys_addr
operator|=
name|pa
expr_stmt|;
name|queue_enter
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|,
name|m
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
comment|/* 	 *	Initialize vm_pages_needed lock here - don't wait for pageout 	 *	daemon	XXX 	 */
name|simple_lock_init
argument_list|(
operator|&
name|vm_pages_needed_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|mapped
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_hash:  *  *	Distributes the object/offset key pair among hash buckets.  *  *	NOTE:  This macro depends on vm_page_bucket_count being a power of 2.  */
end_comment

begin_define
define|#
directive|define
name|vm_page_hash
parameter_list|(
name|object
parameter_list|,
name|offset
parameter_list|)
define|\
value|(((unsigned)object+(unsigned)atop(offset))&vm_page_hash_mask)
end_define

begin_comment
comment|/*  *	vm_page_insert:		[ internal use only ]  *  *	Inserts the given mem entry into the object/object-page  *	table and object list.  *  *	The object and page must be locked.  */
end_comment

begin_function
name|void
name|vm_page_insert
parameter_list|(
name|mem
parameter_list|,
name|object
parameter_list|,
name|offset
parameter_list|)
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
specifier|register
name|vm_object_t
name|object
decl_stmt|;
specifier|register
name|vm_offset_t
name|offset
decl_stmt|;
block|{
specifier|register
name|queue_t
name|bucket
decl_stmt|;
name|int
name|spl
decl_stmt|;
name|VM_PAGE_CHECK
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|tabled
condition|)
name|panic
argument_list|(
literal|"vm_page_insert: already inserted"
argument_list|)
expr_stmt|;
comment|/* 	 *	Record the object/offset pair in this page 	 */
name|mem
operator|->
name|object
operator|=
name|object
expr_stmt|;
name|mem
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
comment|/* 	 *	Insert it into the object_object/offset hash table 	 */
name|bucket
operator|=
operator|&
name|vm_page_buckets
index|[
name|vm_page_hash
argument_list|(
name|object
argument_list|,
name|offset
argument_list|)
index|]
expr_stmt|;
name|spl
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
name|queue_enter
argument_list|(
name|bucket
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|hashq
argument_list|)
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
comment|/* 	 *	Now link into the object's list of backed pages. 	 */
name|queue_enter
argument_list|(
operator|&
name|object
operator|->
name|memq
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|listq
argument_list|)
expr_stmt|;
name|mem
operator|->
name|tabled
operator|=
name|TRUE
expr_stmt|;
comment|/* 	 *	And show that the object has one more resident 	 *	page. 	 */
name|object
operator|->
name|resident_page_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_remove:		[ internal use only ]  *  *	Removes the given mem entry from the object/offset-page  *	table and the object page list.  *  *	The object and page must be locked.  */
end_comment

begin_function
name|void
name|vm_page_remove
parameter_list|(
name|mem
parameter_list|)
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
block|{
specifier|register
name|queue_t
name|bucket
decl_stmt|;
name|int
name|spl
decl_stmt|;
name|VM_PAGE_CHECK
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mem
operator|->
name|tabled
condition|)
return|return;
comment|/* 	 *	Remove from the object_object/offset hash table 	 */
name|bucket
operator|=
operator|&
name|vm_page_buckets
index|[
name|vm_page_hash
argument_list|(
name|mem
operator|->
name|object
argument_list|,
name|mem
operator|->
name|offset
argument_list|)
index|]
expr_stmt|;
name|spl
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
name|queue_remove
argument_list|(
name|bucket
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|hashq
argument_list|)
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
comment|/* 	 *	Now remove from the object's list of backed pages. 	 */
name|queue_remove
argument_list|(
operator|&
name|mem
operator|->
name|object
operator|->
name|memq
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|listq
argument_list|)
expr_stmt|;
comment|/* 	 *	And show that the object has one fewer resident 	 *	page. 	 */
name|mem
operator|->
name|object
operator|->
name|resident_page_count
operator|--
expr_stmt|;
name|mem
operator|->
name|tabled
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_lookup:  *  *	Returns the page associated with the object/offset  *	pair specified; if none is found, NULL is returned.  *  *	The object must be locked.  No side effects.  */
end_comment

begin_function
name|vm_page_t
name|vm_page_lookup
parameter_list|(
name|object
parameter_list|,
name|offset
parameter_list|)
specifier|register
name|vm_object_t
name|object
decl_stmt|;
specifier|register
name|vm_offset_t
name|offset
decl_stmt|;
block|{
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
specifier|register
name|queue_t
name|bucket
decl_stmt|;
name|int
name|spl
decl_stmt|;
comment|/* 	 *	Search the hash table for this object/offset pair 	 */
name|bucket
operator|=
operator|&
name|vm_page_buckets
index|[
name|vm_page_hash
argument_list|(
name|object
argument_list|,
name|offset
argument_list|)
index|]
expr_stmt|;
name|spl
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_first
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|queue_end
argument_list|(
name|bucket
argument_list|,
operator|(
name|queue_entry_t
operator|)
name|mem
argument_list|)
condition|)
block|{
name|VM_PAGE_CHECK
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mem
operator|->
name|object
operator|==
name|object
operator|)
operator|&&
operator|(
name|mem
operator|->
name|offset
operator|==
name|offset
operator|)
condition|)
block|{
name|simple_unlock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
return|return
operator|(
name|mem
operator|)
return|;
block|}
name|mem
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_next
argument_list|(
operator|&
name|mem
operator|->
name|hashq
argument_list|)
expr_stmt|;
block|}
name|simple_unlock
argument_list|(
operator|&
name|bucket_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_rename:  *  *	Move the given memory entry from its  *	current object to the specified target object/offset.  *  *	The object must be locked.  */
end_comment

begin_function
name|void
name|vm_page_rename
parameter_list|(
name|mem
parameter_list|,
name|new_object
parameter_list|,
name|new_offset
parameter_list|)
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
specifier|register
name|vm_object_t
name|new_object
decl_stmt|;
name|vm_offset_t
name|new_offset
decl_stmt|;
block|{
if|if
condition|(
name|mem
operator|->
name|object
operator|==
name|new_object
condition|)
return|return;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
comment|/* keep page from moving out from 				   under pageout daemon */
name|vm_page_remove
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|vm_page_insert
argument_list|(
name|mem
argument_list|,
name|new_object
argument_list|,
name|new_offset
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_page_init
parameter_list|(
name|mem
parameter_list|,
name|object
parameter_list|,
name|offset
parameter_list|)
name|vm_page_t
name|mem
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
define|#
directive|define
name|vm_page_init
parameter_list|(
name|mem
parameter_list|,
name|object
parameter_list|,
name|offset
parameter_list|)
value|{\ 		(mem)->busy = TRUE; \ 		(mem)->tabled = FALSE; \ 		vm_page_insert((mem), (object), (offset)); \ 		(mem)->absent = FALSE; \ 		(mem)->fictitious = FALSE; \ 		(mem)->page_lock = VM_PROT_NONE; \ 		(mem)->unlock_request = VM_PROT_NONE; \ 		(mem)->laundry = FALSE; \ 		(mem)->active = FALSE; \ 		(mem)->inactive = FALSE; \ 		(mem)->wire_count = 0; \ 		(mem)->clean = TRUE; \ 		(mem)->copy_on_write = FALSE; \ 		(mem)->fake = TRUE; \ 		(mem)->pagerowned = FALSE; \ 		(mem)->ptpage = FALSE; \ 	}
else|#
directive|else
define|#
directive|define
name|vm_page_init
parameter_list|(
name|mem
parameter_list|,
name|object
parameter_list|,
name|offset
parameter_list|)
value|{\ 		(mem)->busy = TRUE; \ 		(mem)->tabled = FALSE; \ 		vm_page_insert((mem), (object), (offset)); \ 		(mem)->absent = FALSE; \ 		(mem)->fictitious = FALSE; \ 		(mem)->page_lock = VM_PROT_NONE; \ 		(mem)->unlock_request = VM_PROT_NONE; \ 		(mem)->laundry = FALSE; \ 		(mem)->active = FALSE; \ 		(mem)->inactive = FALSE; \ 		(mem)->wire_count = 0; \ 		(mem)->clean = TRUE; \ 		(mem)->copy_on_write = FALSE; \ 		(mem)->fake = TRUE; \ 	}
endif|#
directive|endif
name|vm_page_init
argument_list|(
name|mem
argument_list|,
name|object
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_alloc:  *  *	Allocate and return a memory cell associated  *	with this VM object/offset pair.  *  *	Object must be locked.  */
end_comment

begin_function
name|vm_page_t
name|vm_page_alloc
parameter_list|(
name|object
parameter_list|,
name|offset
parameter_list|)
name|vm_object_t
name|object
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
block|{
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
name|int
name|spl
decl_stmt|;
name|spl
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* XXX */
name|simple_lock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue_empty
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|)
condition|)
block|{
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|queue_remove_first
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|vm_page_free_count
operator|--
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
name|vm_page_init
argument_list|(
name|mem
argument_list|,
name|object
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* 	 *	Decide if we should poke the pageout daemon. 	 *	We do this if the free count is less than the low 	 *	water mark, or if the free count is less than the high 	 *	water mark (but above the low water mark) and the inactive 	 *	count is less than its target. 	 * 	 *	We don't have the counts locked ... if they change a little, 	 *	it doesn't really matter. 	 */
if|if
condition|(
operator|(
name|vm_page_free_count
operator|<
name|vm_page_free_min
operator|)
operator|||
operator|(
operator|(
name|vm_page_free_count
operator|<
name|vm_page_free_target
operator|)
operator|&&
operator|(
name|vm_page_inactive_count
operator|<
name|vm_page_inactive_target
operator|)
operator|)
condition|)
name|thread_wakeup
argument_list|(
operator|&
name|vm_pages_needed
argument_list|)
expr_stmt|;
return|return
operator|(
name|mem
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_free:  *  *	Returns the given page to the free list,  *	disassociating it with any VM object.  *  *	Object and page must be locked prior to entry.  */
end_comment

begin_function
name|void
name|vm_page_free
parameter_list|(
name|mem
parameter_list|)
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
block|{
name|vm_page_remove
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|active
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|mem
operator|->
name|active
operator|=
name|FALSE
expr_stmt|;
name|vm_page_active_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|mem
operator|->
name|inactive
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|mem
operator|->
name|inactive
operator|=
name|FALSE
expr_stmt|;
name|vm_page_inactive_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mem
operator|->
name|fictitious
condition|)
block|{
name|int
name|spl
decl_stmt|;
name|spl
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|queue_enter
argument_list|(
operator|&
name|vm_page_queue_free
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|vm_page_free_count
operator|++
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_page_wire:  *  *	Mark this page as wired down by yet  *	another map, removing it from paging queues  *	as necessary.  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_wire
parameter_list|(
name|mem
parameter_list|)
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
block|{
name|VM_PAGE_CHECK
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mem
operator|->
name|active
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|vm_page_active_count
operator|--
expr_stmt|;
name|mem
operator|->
name|active
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|mem
operator|->
name|inactive
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|vm_page_inactive_count
operator|--
expr_stmt|;
name|mem
operator|->
name|inactive
operator|=
name|FALSE
expr_stmt|;
block|}
name|vm_page_wire_count
operator|++
expr_stmt|;
block|}
name|mem
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_unwire:  *  *	Release one wiring of this page, potentially  *	enabling it to be paged again.  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_unwire
parameter_list|(
name|mem
parameter_list|)
specifier|register
name|vm_page_t
name|mem
decl_stmt|;
block|{
name|VM_PAGE_CHECK
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|mem
operator|->
name|wire_count
operator|--
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
name|queue_enter
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|mem
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|vm_page_active_count
operator|++
expr_stmt|;
name|mem
operator|->
name|active
operator|=
name|TRUE
expr_stmt|;
name|vm_page_wire_count
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_page_deactivate:  *  *	Returns the given page to the inactive list,  *	indicating that no physical maps have access  *	to this page.  [Used by the physical mapping system.]  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_deactivate
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|VM_PAGE_CHECK
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 *	Only move active pages -- ignore locked or already 	 *	inactive ones. 	 * 	 *	XXX: sometimes we get pages which aren't wired down 	 *	or on any queue - we need to put them on the inactive 	 *	queue also, otherwise we lose track of them. 	 *	Paul Mackerras (paulus@cs.anu.edu.au) 9-Jan-93. 	 */
if|if
condition|(
operator|!
name|m
operator|->
name|inactive
operator|&&
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
name|pmap_clear_reference
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|active
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|m
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|m
operator|->
name|active
operator|=
name|FALSE
expr_stmt|;
name|vm_page_active_count
operator|--
expr_stmt|;
block|}
name|queue_enter
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|,
name|m
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|m
operator|->
name|inactive
operator|=
name|TRUE
expr_stmt|;
name|vm_page_inactive_count
operator|++
expr_stmt|;
if|if
condition|(
name|pmap_is_modified
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|m
operator|->
name|clean
operator|=
name|FALSE
expr_stmt|;
name|m
operator|->
name|laundry
operator|=
operator|!
name|m
operator|->
name|clean
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_page_activate:  *  *	Put the specified page on the active list (if appropriate).  *  *	The page queues must be locked.  */
end_comment

begin_function
name|void
name|vm_page_activate
parameter_list|(
name|m
parameter_list|)
specifier|register
name|vm_page_t
name|m
decl_stmt|;
block|{
name|VM_PAGE_CHECK
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|inactive
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|,
name|m
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|vm_page_inactive_count
operator|--
expr_stmt|;
name|m
operator|->
name|inactive
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|active
condition|)
name|panic
argument_list|(
literal|"vm_page_activate: already active"
argument_list|)
expr_stmt|;
name|queue_enter
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|,
name|m
argument_list|,
name|vm_page_t
argument_list|,
name|pageq
argument_list|)
expr_stmt|;
name|m
operator|->
name|active
operator|=
name|TRUE
expr_stmt|;
name|vm_page_active_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_page_zero_fill:  *  *	Zero-fill the specified page.  *	Written as a standard pagein routine, to  *	be used by the zero-fill object.  */
end_comment

begin_function
name|boolean_t
name|vm_page_zero_fill
parameter_list|(
name|m
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
block|{
name|VM_PAGE_CHECK
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_zero_page
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_page_copy:  *  *	Copy one page to another  */
end_comment

begin_function
name|void
name|vm_page_copy
parameter_list|(
name|src_m
parameter_list|,
name|dest_m
parameter_list|)
name|vm_page_t
name|src_m
decl_stmt|;
name|vm_page_t
name|dest_m
decl_stmt|;
block|{
name|VM_PAGE_CHECK
argument_list|(
name|src_m
argument_list|)
expr_stmt|;
name|VM_PAGE_CHECK
argument_list|(
name|dest_m
argument_list|)
expr_stmt|;
name|pmap_copy_page
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|src_m
argument_list|)
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|dest_m
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

