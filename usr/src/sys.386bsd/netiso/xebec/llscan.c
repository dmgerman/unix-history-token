begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: llscan.c,v 2.2 88/09/19 12:55:06 nhall Exp $ */
end_comment

begin_comment
comment|/* $Source: /var/home/tadl/src/argo/xebec/RCS/llscan.c,v $ */
end_comment

begin_comment
comment|/*  * ************************* NOTICE *******************************  * This code is in the public domain.  It cannot be copyrighted.  * This scanner was originally written by Keith Thompson for the   * University of Wisconsin Crystal project.  * It was subsequently modified significantly by Nancy Hall at the   * University of Wisconsin for the ARGO project.  * ****************************************************************  */
end_comment

begin_include
include|#
directive|include
file|"xebec.h"
end_include

begin_include
include|#
directive|include
file|"llparse.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"procs.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_define
define|#
directive|define
name|EOFILE
value|0x01
end_define

begin_define
define|#
directive|define
name|UNUSED
value|0x02
end_define

begin_define
define|#
directive|define
name|IGNORE
value|0x04
end_define

begin_define
define|#
directive|define
name|OPCHAR
value|0x8
end_define

begin_define
define|#
directive|define
name|DIGITS
value|0x10
end_define

begin_define
define|#
directive|define
name|LETTER
value|0x20
end_define

begin_decl_stmt
name|int
name|chtype
index|[
literal|128
index|]
init|=
block|{
comment|/*	null,	soh ^a,	stx ^b	etx ^c	eot ^d	enq ^e	ack ^f	bel ^g	*/
name|EOFILE
block|,
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
comment|/*	bs ^h	ht ^i	lf ^j	vt ^k	ff ^l	cr ^m	so ^n	si ^o	*/
name|UNUSED
block|,
name|IGNORE
block|,
name|IGNORE
block|,
name|UNUSED
block|,
name|IGNORE
block|,
name|IGNORE
block|,
name|UNUSED
block|,
name|UNUSED
block|,
comment|/*	dle ^p	dc1 ^q	dc2 ^r	dc3 ^s	dc4 ^t	nak ^u	syn ^v	etb ^w	*/
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
name|EOFILE
block|,
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
comment|/*	can ^x	em ^y	sub ^z	esc ^]	fs ^\ 	gs ^}	rs ^`	us ^/	*/
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
name|UNUSED
block|,
comment|/*			!		"		#		$		%&		'		*/
name|IGNORE
block|,
name|UNUSED
block|,
name|OPCHAR
block|,
name|UNUSED
block|,
name|OPCHAR
block|,
name|UNUSED
block|,
name|OPCHAR
block|,
name|OPCHAR
block|,
comment|/*	(		)		*		+		,		-		.		/		*/
name|OPCHAR
block|,
name|OPCHAR
block|,
name|OPCHAR
block|,
name|OPCHAR
block|,
name|OPCHAR
block|,
name|OPCHAR
block|,
name|OPCHAR
block|,
name|OPCHAR
block|,
comment|/*	0		1		2		3		4		5		6		7		*/
name|DIGITS
block|,
name|DIGITS
block|,
name|DIGITS
block|,
name|DIGITS
block|,
name|DIGITS
block|,
name|DIGITS
block|,
name|DIGITS
block|,
name|DIGITS
block|,
comment|/*	8		9		:		;<		=>		?		*/
name|DIGITS
block|,
name|DIGITS
block|,
name|OPCHAR
block|,
name|OPCHAR
block|,
name|OPCHAR
block|,
name|OPCHAR
block|,
name|OPCHAR
block|,
name|OPCHAR
block|,
comment|/*	@		A		B		C		D		E		F		G		*/
name|UNUSED
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
comment|/*	H		I		J		K		L		M		N		O		*/
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
comment|/*	P		Q		R		S		T		U		V		W		*/
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
comment|/* 	X		Y		Z		[		\		]		^		_		*/
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|OPCHAR
block|,
name|UNUSED
block|,
name|OPCHAR
block|,
name|OPCHAR
block|,
name|LETTER
block|,
comment|/*	`		a		b		c		d		e		f		g		*/
name|UNUSED
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
comment|/*	h		i		j		k		l		m		n		o		*/
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
comment|/*	p		q		r		s		t		u		v		w		*/
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
comment|/*	x		y		z		{		|		}		~		del		*/
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|OPCHAR
block|,
name|UNUSED
block|,
name|OPCHAR
block|,
name|UNUSED
block|,
name|UNUSED
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|astringfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|buffer
index|[
literal|2
index|]
index|[
name|LINELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|currentbuf
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|addbuf
parameter_list|(
name|x
parameter_list|)
value|*buffptr++ = x
end_define

begin_decl_stmt
specifier|static
name|int
name|ch
init|=
literal|' '
decl_stmt|;
end_decl_stmt

begin_macro
name|skip
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
operator|(
name|chtype
index|[
name|ch
index|]
operator|==
name|IGNORE
operator|)
condition|)
block|{
name|ch
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|llaccept
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|LLtoken
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|t
operator|->
name|llstate
condition|)
block|{
case|case
name|NORMAL
case|:
break|break;
case|case
name|INSERT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Insert %s\n"
argument_list|,
name|llstrings
index|[
name|t
operator|->
name|llterm
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DELETE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Delete %s\n"
argument_list|,
name|llstrings
index|[
name|t
operator|->
name|llterm
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|TVAL
value|(t->llattrib)
end_define

begin_macro
name|dump_buffer
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fputc
argument_list|(
name|buffer
index|[
name|currentbuf
index|]
index|[
name|i
index|]
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|iskey
parameter_list|(
name|c
parameter_list|,
name|buf
parameter_list|)
name|char
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
struct|struct
block|{
name|char
modifier|*
name|key_word
decl_stmt|;
name|int
name|term_type
decl_stmt|;
block|}
name|keys
index|[]
init|=
block|{
block|{
literal|"SAME"
block|,
name|T_SAME
block|}
block|,
block|{
literal|"DEFAULT"
block|,
name|T_DEFAULT
block|}
block|,
block|{
literal|"NULLACTION"
block|,
name|T_NULLACTION
block|}
block|,
block|{
literal|"STRUCT"
block|,
name|T_STRUCT
block|}
block|,
block|{
literal|"SYNONYM"
block|,
name|T_SYNONYM
block|}
block|,
block|{
literal|"TRANSITIONS"
block|,
name|T_TRANSITIONS
block|}
block|,
block|{
literal|"STATES"
block|,
name|T_STATES
block|}
block|,
block|{
literal|"EVENTS"
block|,
name|T_EVENTS
block|}
block|,
block|{
literal|"PCB"
block|,
name|T_PCB
block|}
block|,
block|{
literal|"INCLUDE"
block|,
name|T_INCLUDE
block|}
block|,
block|{
literal|"PROTOCOL"
block|,
name|T_PROTOCOL
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, 	}
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keys
index|[
name|i
index|]
operator|.
name|key_word
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|c
argument_list|,
operator|(
operator|*
name|buf
operator|=
name|keys
index|[
name|i
index|]
operator|.
name|key_word
operator|)
argument_list|)
condition|)
block|{
return|return
operator|(
name|keys
index|[
name|i
index|]
operator|.
name|term_type
operator|)
return|;
block|}
block|}
operator|*
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|getstr
argument_list|(
argument|o
argument_list|,
argument|c
argument_list|)
end_macro

begin_comment
comment|/* c is the string delimiter  	 * allow the delimiter to be escaped  	 * the messy part: translate $ID to 	 *   e->ev_union.ID 	 * where ID is an event with a non-zero obj_struc 	 * need we check for the field??? 	 */
end_comment

begin_decl_stmt
name|char
name|o
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nested
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|allow_nesting
init|=
operator|(
name|o
operator|==
name|c
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|S
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"getstr: ch=%c, delimiters %c %c\n"
argument_list|,
name|ch
argument_list|,
name|o
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"getstr: buffptr 0x%x, currentbuf 0x%x\n"
argument_list|,
name|buffptr
argument_list|,
name|currentbuf
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|ch
operator|==
name|c
condition|)
name|nested
operator|--
expr_stmt|;
while|while
condition|(
name|nested
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Eof inside of a string, delims= %c,%c, nesting %d"
argument_list|,
name|c
argument_list|,
name|o
argument_list|,
name|nested
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* notreached */
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'$'
condition|)
block|{
comment|/* might be an attribute */
name|IFDEBUG
argument_list|(
argument|S
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"getstr: atttribute?\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* assume it's an event */
comment|/* addbuf is a macro so this isn't as bad as 			 * it looks  			 * add "e->ev_union." 			 */
if|if
condition|(
operator|(
name|ch
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|'$'
condition|)
block|{
name|addbuf
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|addbuf
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|addbuf
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|addbuf
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|addbuf
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
name|addbuf
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|addbuf
argument_list|(
literal|'u'
argument_list|)
expr_stmt|;
name|addbuf
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|addbuf
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
name|addbuf
argument_list|(
literal|'o'
argument_list|)
expr_stmt|;
name|addbuf
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|addbuf
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|AddCurrentEventName
argument_list|(
operator|&
name|buffptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|obufp
init|=
name|buffptr
decl_stmt|;
do|do
block|{
name|addbuf
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|chtype
index|[
name|ch
index|]
operator|&
name|LETTER
condition|)
do|;
name|addbuf
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|obufp
argument_list|,
name|synonyms
index|[
name|PCB_SYN
index|]
argument_list|,
name|strlen
argument_list|(
name|synonyms
index|[
name|PCB_SYN
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|buffptr
operator|=
name|obufp
expr_stmt|;
name|addbuf
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|obufp
argument_list|,
name|synonyms
index|[
name|EVENT_SYN
index|]
argument_list|,
name|strlen
argument_list|(
name|synonyms
index|[
name|EVENT_SYN
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|buffptr
operator|=
name|obufp
expr_stmt|;
name|addbuf
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown synonym %s\n"
argument_list|,
name|obufp
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
name|addbuf
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|addbuf
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* needs to be checked for nesting */
goto|goto
name|check
goto|;
block|}
block|}
comment|/* end of attribute handling */
goto|goto
name|skip
goto|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
comment|/* possible escape - this is kludgy beyond belief: 			 * \ is used to escape open and closing delimiters 			 * and '$' 			 * otherwise it's passed through to be compiled by C 			 */
name|ch
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|!=
name|o
operator|)
operator|&&
operator|(
name|ch
operator|!=
name|c
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'$'
operator|)
condition|)
block|{
comment|/* may need to handle case where \ is last char in file... */
comment|/* don't treat is as escape; not open or close so 				 * don't have to worry about nesting either  				 */
name|addbuf
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
block|}
name|addbuf
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|skip
label|:
name|ch
operator|=
name|getch
argument_list|()
expr_stmt|;
name|check
label|:
if|if
condition|(
name|ch
operator|==
name|o
condition|)
name|nested
operator|+=
name|allow_nesting
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|c
condition|)
name|nested
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|buffptr
operator|-
name|buffer
index|[
name|currentbuf
index|]
operator|)
operator|>
name|LINELEN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s too long.\n"
argument_list|,
operator|(
name|o
operator|==
literal|'{'
operator|)
condition|?
literal|"Action"
else|:
literal|"Predicate"
argument_list|)
expr_stmt|;
comment|/*}*/
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffptr, currentbuf 0x%x, 0x%x\n"
argument_list|,
name|buffptr
argument_list|,
name|currentbuf
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|S
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"loop in getstr: ch 0x%x,%c o=%c,c=%c nested=%d\n"
argument_list|,
name|ch
argument_list|,
name|ch
argument_list|,
name|o
argument_list|,
name|c
argument_list|,
name|nested
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
name|addbuf
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|addbuf
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|S
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"exit getstr: got %s\n"
argument_list|,
name|buffer
index|[
name|currentbuf
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"exit getstr: buffptr 0x%x, currentbuf 0x%x\n"
argument_list|,
name|buffptr
argument_list|,
name|currentbuf
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_macro
name|getch
argument_list|()
end_macro

begin_block
block|{
name|char
name|c
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|extern
name|int
name|lineno
decl_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|c
operator|==
name|EOF
condition|)
name|c
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|infile
argument_list|)
condition|)
name|c
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|e
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"getch: 0x%x\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
name|c
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|c
return|;
block|}
end_block

begin_macro
name|llscan
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|LLtoken
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|c
decl_stmt|;
name|t
operator|->
name|llstate
operator|=
name|NORMAL
expr_stmt|;
operator|++
name|currentbuf
expr_stmt|;
name|currentbuf
operator|&=
literal|1
expr_stmt|;
name|again
label|:
name|buffptr
operator|=
operator|&
name|buffer
index|[
name|currentbuf
index|]
index|[
literal|0
index|]
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|chtype
index|[
name|ch
index|]
condition|)
block|{
case|case
name|EOFILE
case|:
name|t
operator|->
name|llterm
operator|=
name|T_ENDMARKER
expr_stmt|;
break|break;
case|case
name|UNUSED
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Illegal character in input - 0x%x ignored."
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getch
argument_list|()
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|OPCHAR
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'/'
case|:
comment|/* possible comment : elide ; kludge */
name|IFDEBUG
argument_list|(
argument|S
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Comment ch=%c\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|c
init|=
name|getch
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'*'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Syntax error : character(0x%x) ignored"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
name|c
expr_stmt|;
goto|goto
name|again
goto|;
block|}
else|else
block|{
specifier|register
name|int
name|state
init|=
literal|2
decl_stmt|,
name|whatchar
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|dfa
index|[
literal|3
index|]
index|[
literal|3
index|]
init|=
block|{
comment|/* 		 	done	seen-star  middle */
comment|/* star */
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* /    */
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/* other */
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|}
block|}
decl_stmt|;
while|while
condition|(
name|state
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
operator|(
name|char
operator|)
literal|0
condition|)
break|break;
name|whatchar
operator|=
operator|(
name|c
operator|==
literal|'*'
operator|)
condition|?
literal|0
else|:
operator|(
name|c
operator|==
literal|'/'
condition|?
literal|1
else|:
literal|2
operator|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|S
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"comment: whatchar = %d, c = 0x%x,%c, oldstate=%d"
argument_list|,
name|whatchar
argument_list|,
name|c
argument_list|,
name|c
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|state
init|=
name|dfa
index|[
name|whatchar
index|]
index|[
name|state
index|]
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|S
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", newstate=%d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
if|if
condition|(
name|state
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Syntax error: end of file inside a comment"
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|ch
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|S
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"end of comment at 0x%x,%c\n"
argument_list|,
name|ch
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ENDDEBUG
goto|goto
name|again
goto|;
case|case
literal|'*'
case|:
name|t
operator|->
name|llterm
operator|=
name|T_STAR
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|t
operator|->
name|llterm
operator|=
name|T_COMMA
expr_stmt|;
break|break;
case|case
literal|';'
case|:
name|t
operator|->
name|llterm
operator|=
name|T_SEMI
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|t
operator|->
name|llterm
operator|=
name|T_LANGLE
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|t
operator|->
name|llterm
operator|=
name|T_EQUAL
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|t
operator|->
name|llterm
operator|=
name|T_LBRACK
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|t
operator|->
name|llterm
operator|=
name|T_RBRACK
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|T_FSTRING
case|case
literal|'"'
case|:
name|t
operator|->
name|llterm
operator|=
name|T_FSTRING
expr_stmt|;
name|addbuf
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getch
argument_list|()
expr_stmt|;
name|getstr
argument_list|(
literal|'"'
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|TVAL
operator|.
name|FSTRING
operator|.
name|address
operator|=
name|stash
argument_list|(
name|buffer
index|[
name|currentbuf
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|T_FSTRING
case|case
literal|'('
case|:
name|t
operator|->
name|llterm
operator|=
name|T_PREDICATE
expr_stmt|;
name|getstr
argument_list|(
name|ch
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|TVAL
operator|.
name|PREDICATE
operator|.
name|address
operator|=
name|buffer
index|[
name|currentbuf
index|]
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|t
operator|->
name|llterm
operator|=
name|T_ACTION
expr_stmt|;
name|getstr
argument_list|(
name|ch
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
name|TVAL
operator|.
name|ACTION
operator|.
name|address
operator|=
name|buffer
index|[
name|currentbuf
index|]
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Syntax error : character(0x%x) ignored"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getch
argument_list|()
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|ch
operator|=
name|getch
argument_list|()
expr_stmt|;
break|break;
case|case
name|LETTER
case|:
do|do
block|{
name|addbuf
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|chtype
index|[
name|ch
index|]
operator|&
operator|(
name|LETTER
operator||
name|DIGITS
operator|)
condition|)
do|;
name|addbuf
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|t
operator|->
name|llterm
operator|=
name|iskey
argument_list|(
name|buffer
index|[
name|currentbuf
index|]
argument_list|,
operator|&
name|TVAL
operator|.
name|ID
operator|.
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|llterm
condition|)
block|{
name|t
operator|->
name|llterm
operator|=
name|T_ID
expr_stmt|;
name|TVAL
operator|.
name|ID
operator|.
name|address
operator|=
name|buffer
index|[
name|currentbuf
index|]
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|S
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"llscan: id or keyword 0x%x, %s\n"
argument_list|,
name|TVAL
operator|.
name|ID
operator|.
name|address
argument_list|,
name|TVAL
operator|.
name|ID
operator|.
name|address
argument_list|)
expr_stmt|;
name|ENDDEBUG
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Snark in llscan: chtype=0x%x, ch=0x%x\n"
argument_list|,
name|chtype
index|[
name|ch
index|]
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

