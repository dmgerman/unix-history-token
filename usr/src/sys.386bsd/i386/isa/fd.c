begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Don Ahn.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)fd.c	7.4 (Berkeley) 5/25/91  */
end_comment

begin_include
include|#
directive|include
file|"fd.h"
end_include

begin_if
if|#
directive|if
name|NFD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"dkbad.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/fdreg.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/icu.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/rtc.h"
end_include

begin_undef
undef|#
directive|undef
name|NFD
end_undef

begin_define
define|#
directive|define
name|NFD
value|2
end_define

begin_define
define|#
directive|define
name|FDUNIT
parameter_list|(
name|s
parameter_list|)
value|((s>>3)&1)
end_define

begin_define
define|#
directive|define
name|FDTYPE
parameter_list|(
name|s
parameter_list|)
value|((s)&7)
end_define

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_define
define|#
directive|define
name|b_step
value|b_resid
end_define

begin_define
define|#
directive|define
name|FDBLK
value|512
end_define

begin_define
define|#
directive|define
name|NUMTYPES
value|4
end_define

begin_struct
struct|struct
name|fd_type
block|{
name|int
name|sectrac
decl_stmt|;
comment|/* sectors per track         */
name|int
name|secsize
decl_stmt|;
comment|/* size code for sectors     */
name|int
name|datalen
decl_stmt|;
comment|/* data len when secsize = 0 */
name|int
name|gap
decl_stmt|;
comment|/* gap len between sectors   */
name|int
name|tracks
decl_stmt|;
comment|/* total num of tracks       */
name|int
name|size
decl_stmt|;
comment|/* size of disk in sectors   */
name|int
name|steptrac
decl_stmt|;
comment|/* steps per cylinder        */
name|int
name|trans
decl_stmt|;
comment|/* transfer speed code       */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|fd_type
name|fd_types
index|[
name|NUMTYPES
index|]
init|=
block|{
block|{
literal|18
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2880
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* 1.44 meg HD 3.5in floppy    */
block|{
literal|15
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2400
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* 1.2 meg HD floppy           */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x23
block|,
literal|40
block|,
literal|720
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 360k floppy in 1.2meg drive */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x2A
block|,
literal|40
block|,
literal|720
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 360k floppy in DD drive     */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|fd_u
block|{
name|int
name|type
decl_stmt|;
comment|/* Drive type (HD, DD     */
name|int
name|active
decl_stmt|;
comment|/* Drive activity boolean */
name|int
name|motor
decl_stmt|;
comment|/* Motor on flag          */
name|struct
name|buf
name|head
decl_stmt|;
comment|/* Head of buf chain      */
name|struct
name|buf
name|rhead
decl_stmt|;
comment|/* Raw head of buf chain  */
name|int
name|reset
decl_stmt|;
block|}
name|fd_unit
index|[
name|NFD
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|buf
name|fdtab
decl_stmt|,
name|fdutab
index|[
name|NFD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* controller activity */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state needed for current transfer */
end_comment

begin_expr_stmt
specifier|static
name|fdc
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* floppy disk controller io base register */
end_comment

begin_decl_stmt
name|int
name|fd_dmachan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_skip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_retry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_drive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_hddrv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_track
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_status
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                      autoconfiguration stuff                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_decl_stmt
name|int
name|fdprobe
argument_list|()
decl_stmt|,
name|fdattach
argument_list|()
decl_stmt|,
name|fd_turnoff
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|fddriver
init|=
block|{
name|fdprobe
block|,
name|fdattach
block|,
literal|"fd"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * probe for existance of controller  */
end_comment

begin_macro
name|fdprobe
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fdc
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
comment|/* see if it can handle a command */
if|if
condition|(
name|out_fdc
argument_list|(
name|NE7CMD_SPECIFY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fdc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|out_fdc
argument_list|(
literal|0xDF
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * wire controller into system, look for floppy units  */
end_comment

begin_macro
name|fdattach
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|hdr
decl_stmt|;
name|unsigned
name|fdt
decl_stmt|,
name|st0
decl_stmt|,
name|cyl
decl_stmt|;
name|fd_dmachan
operator|=
name|dev
operator|->
name|id_drq
expr_stmt|;
name|fdt
operator|=
name|rtcin
argument_list|(
name|RTC_FDISKETTE
argument_list|)
expr_stmt|;
name|hdr
operator|=
literal|0
expr_stmt|;
comment|/* check for each floppy drive */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFD
condition|;
name|i
operator|++
control|)
block|{
comment|/* is there a unit? */
if|if
condition|(
operator|(
name|fdt
operator|&
literal|0xf0
operator|)
operator|==
name|RTCFDT_NONE
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|notyet
comment|/* select it */
name|fd_turnon
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|NE7CMD_RECAL
argument_list|)
expr_stmt|;
comment|/* Recalibrate Function */
name|out_fdc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* anything responding */
name|out_fdc
argument_list|(
name|NE7CMD_SENSEI
argument_list|)
expr_stmt|;
name|st0
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|cyl
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
if|if
condition|(
name|st0
operator|&
literal|0xd0
condition|)
continue|continue;
endif|#
directive|endif
comment|/* yes, announce it */
if|if
condition|(
operator|!
name|hdr
condition|)
name|printf
argument_list|(
literal|" drives "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdt
operator|&
literal|0xf0
operator|)
operator|==
name|RTCFDT_12M
condition|)
block|{
name|printf
argument_list|(
literal|"1.2M"
argument_list|)
expr_stmt|;
name|fd_unit
index|[
name|i
index|]
operator|.
name|type
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fdt
operator|&
literal|0xf0
operator|)
operator|==
name|RTCFDT_144M
condition|)
block|{
name|printf
argument_list|(
literal|"1.44M"
argument_list|)
expr_stmt|;
name|fd_unit
index|[
name|i
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
block|}
name|fdt
operator|<<=
literal|4
expr_stmt|;
name|fd_turnoff
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|hdr
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set transfer to 500kbps */
name|outb
argument_list|(
name|fdc
operator|+
name|fdctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fd_turnoff
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|fdsize
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                               fdstrategy                                 */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
name|fdstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* IO operation to perform */
end_comment

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dp0
decl_stmt|,
modifier|*
name|dp1
decl_stmt|;
name|long
name|nblocks
decl_stmt|,
name|blknum
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|type
decl_stmt|,
name|s
decl_stmt|;
name|unit
operator|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/*type = FDTYPE(minor(bp->b_dev));*/
name|type
operator|=
name|fd_unit
index|[
name|unit
index|]
operator|.
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|FDTEST
name|printf
argument_list|(
literal|"fdstrat%d, blk = %d, bcount = %d, addr = %x|"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|unit
operator|>=
name|NFD
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"fdstrat: unit = %d, blkno = %d, bcount = %d\n"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|pg
argument_list|(
literal|"fd:error in fdstrategy"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Set up block calculations. 	 */
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|FDBLK
expr_stmt|;
name|nblocks
operator|=
name|fd_types
index|[
name|type
index|]
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|blknum
operator|+
operator|(
name|bp
operator|->
name|b_bcount
operator|/
name|FDBLK
operator|)
operator|>
name|nblocks
condition|)
block|{
if|if
condition|(
name|blknum
operator|==
name|nblocks
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENOSPC
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
goto|goto
name|bad
goto|;
block|}
name|bp
operator|->
name|b_cylin
operator|=
name|blknum
operator|/
operator|(
name|fd_types
index|[
name|type
index|]
operator|.
name|sectrac
operator|*
literal|2
operator|)
expr_stmt|;
name|dp
operator|=
operator|&
name|fd_unit
index|[
name|unit
index|]
operator|.
name|head
expr_stmt|;
name|dp
operator|->
name|b_step
operator|=
operator|(
name|fd_types
index|[
name|fd_unit
index|[
name|unit
index|]
operator|.
name|type
index|]
operator|.
name|steptrac
operator|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|FDDEBUG
name|printf
argument_list|(
literal|"T|"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
name|fd_drive
operator|=
name|unit
expr_stmt|;
name|fd_track
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* force seek on first xfer */
name|untimeout
argument_list|(
name|fd_turnoff
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* start drive if idle */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                            motor control stuff                           */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
name|set_motor
argument_list|(
argument|unit
argument_list|,
argument|reset
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|reset
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|m0
decl_stmt|,
name|m1
decl_stmt|;
name|m0
operator|=
name|fd_unit
index|[
literal|0
index|]
operator|.
name|motor
expr_stmt|;
name|m1
operator|=
name|fd_unit
index|[
literal|1
index|]
operator|.
name|motor
expr_stmt|;
name|outb
argument_list|(
name|fdc
operator|+
name|fdout
argument_list|,
operator|(
name|unit
operator|&
name|FDO_FDSEL
operator|)
operator||
operator|(
name|reset
condition|?
literal|0
else|:
operator|(
name|FDO_FRST
operator||
name|FDO_FDMAEN
operator|)
operator|)
operator||
operator|(
name|m0
condition|?
name|FDO_MOEN0
else|:
literal|0
operator|)
operator||
operator|(
name|m1
condition|?
name|FDO_MOEN1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fd_turnoff
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fd_unit
index|[
name|unit
index|]
operator|.
name|motor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unit
condition|)
name|set_motor
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|set_motor
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fd_turnon
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fd_unit
index|[
name|unit
index|]
operator|.
name|motor
operator|=
literal|1
expr_stmt|;
name|set_motor
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                             fdc in/out                                   */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
name|int
name|in_fdc
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
literal|100000
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|inb
argument_list|(
name|fdc
operator|+
name|fdsts
argument_list|)
operator|&
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|)
operator|!=
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|&&
name|j
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
name|i
operator|==
name|NE7_RQM
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|j
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
name|inb
argument_list|(
name|fdc
operator|+
name|fddata
argument_list|)
return|;
block|}
end_function

begin_macro
name|out_fdc
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
init|=
literal|100000
decl_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|fdc
operator|+
name|fdsts
argument_list|)
operator|&
name|NE7_DIO
operator|)
operator|&&
name|i
operator|--
operator|>
literal|0
condition|)
empty_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|fdc
operator|+
name|fdsts
argument_list|)
operator|&
name|NE7_RQM
operator|)
operator|==
literal|0
operator|&&
name|i
operator|--
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|outb
argument_list|(
name|fdc
operator|+
name|fddata
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|fdopenf
expr_stmt|;
end_expr_stmt

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                           fdopen/fdclose                                 */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
name|Fdopen
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
comment|/*int type = FDTYPE(minor(dev));*/
name|int
name|s
decl_stmt|;
name|fdopenf
operator|=
literal|1
expr_stmt|;
comment|/* check bounds */
if|if
condition|(
name|unit
operator|>=
name|NFD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*if (type>= NUMTYPES) return(ENXIO);*/
comment|/* Set proper disk type, only allow one type */
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|fdclose
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                                 fdstart                                  */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
name|fdstart
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|FDTEST
name|printf
argument_list|(
literal|"st%d|"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
operator|&
name|fd_unit
index|[
name|unit
index|]
operator|.
name|head
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fd_unit
index|[
name|unit
index|]
operator|.
name|motor
condition|)
block|{
name|fd_turnon
argument_list|(
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Wait for 1 sec */
endif|#
directive|endif
name|timeout
argument_list|(
name|fdstart
argument_list|,
name|unit
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/*}*/
block|}
else|else
block|{
comment|/* make sure drive is selected as well as on */
name|fd_retry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fd_unit
index|[
name|unit
index|]
operator|.
name|reset
condition|)
name|fd_state
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* DO a RESET */
name|fd_unit
index|[
name|unit
index|]
operator|.
name|reset
operator|=
literal|1
expr_stmt|;
name|fd_state
operator|=
literal|5
expr_stmt|;
block|}
name|fd_skip
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FDDEBUG
name|printf
argument_list|(
literal|"Seek %d %d\n"
argument_list|,
name|bp
operator|->
name|b_cylin
argument_list|,
name|dp
operator|->
name|b_step
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bp
operator|->
name|b_cylin
operator|!=
name|fd_track
condition|)
block|{
comment|/* Seek necessary, never quite sure where head is at! */
name|out_fdc
argument_list|(
name|NE7CMD_SEEK
argument_list|)
expr_stmt|;
comment|/* Seek function */
name|out_fdc
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* Drive number */
name|out_fdc
argument_list|(
name|bp
operator|->
name|b_cylin
operator|*
name|dp
operator|->
name|b_step
argument_list|)
expr_stmt|;
name|fd_state
operator|=
literal|6
expr_stmt|;
block|}
else|else
block|{
name|fd_state
operator|=
literal|1
expr_stmt|;
name|fdintr
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|fd_timeout
argument_list|(
argument|x
argument_list|)
name|int
name|x
decl_stmt|;
block|{
name|int
name|st0
decl_stmt|,
name|st3
decl_stmt|,
name|cyl
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|dp
operator|=
operator|&
name|fd_unit
index|[
name|fd_drive
index|]
operator|.
name|head
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|out_fdc
argument_list|(
name|NE7CMD_SENSED
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fd_hddrv
argument_list|)
expr_stmt|;
name|st3
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|out_fdc
argument_list|(
name|NE7CMD_SENSEI
argument_list|)
expr_stmt|;
name|st0
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|cyl
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"fd%d: Operation timeout ST0 %b cyl %d ST3 %b\n"
argument_list|,
name|fd_drive
argument_list|,
name|st0
argument_list|,
name|NE7_ST0BITS
argument_list|,
name|cyl
argument_list|,
name|st3
argument_list|,
name|NE7_ST3BITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
block|{
name|fd_state
operator|=
literal|4
expr_stmt|;
name|fdintr
argument_list|(
name|fd_drive
argument_list|)
expr_stmt|;
block|}
block|}
comment|/****************************************************************************/
comment|/*                                 fdintr                                   */
comment|/****************************************************************************/
name|fdintr
argument_list|(
argument|unit
argument_list|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|struct
name|buf
modifier|*
name|dpother
decl_stmt|;
name|int
name|read
decl_stmt|,
name|head
decl_stmt|,
name|trac
decl_stmt|,
name|sec
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|,
name|sectrac
decl_stmt|,
name|cyl
decl_stmt|,
name|st0
decl_stmt|;
name|unsigned
name|long
name|blknum
decl_stmt|;
name|struct
name|fd_type
modifier|*
name|ft
decl_stmt|;
ifdef|#
directive|ifdef
name|FDTEST
name|printf
argument_list|(
literal|"state %d, unit %d, dr %d|"
argument_list|,
name|fd_state
argument_list|,
name|unit
argument_list|,
name|fd_drive
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fdopenf
condition|)
return|return;
name|dp
operator|=
operator|&
name|fd_unit
index|[
name|fd_drive
index|]
operator|.
name|head
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|read
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
expr_stmt|;
comment|/*ft =&fd_types[FDTYPE(bp->b_dev)];*/
name|ft
operator|=
operator|&
name|fd_types
index|[
name|fd_unit
index|[
name|fd_drive
index|]
operator|.
name|type
index|]
expr_stmt|;
switch|switch
condition|(
name|fd_state
condition|)
block|{
case|case
literal|1
case|:
comment|/* SEEK DONE, START DMA */
comment|/* Make sure seek really happened*/
if|if
condition|(
name|unit
operator|!=
literal|0xff
condition|)
block|{
name|int
name|descyl
init|=
name|bp
operator|->
name|b_cylin
operator|*
name|dp
operator|->
name|b_step
decl_stmt|;
name|out_fdc
argument_list|(
name|NE7CMD_SENSEI
argument_list|)
expr_stmt|;
name|i
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|cyl
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
if|if
condition|(
name|cyl
operator|!=
name|descyl
condition|)
block|{
name|printf
argument_list|(
literal|"fd%d: Seek to cyl %d failed; am at cyl %d (ST0 = %b)\n"
argument_list|,
name|fd_drive
argument_list|,
name|descyl
argument_list|,
name|cyl
argument_list|,
name|i
argument_list|,
name|NE7_ST0BITS
argument_list|)
expr_stmt|;
name|fd_state
operator|=
literal|4
expr_stmt|;
return|return;
block|}
block|}
name|fd_track
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|isa_dmastart
argument_list|(
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|fd_skip
argument_list|,
name|FDBLK
argument_list|,
name|fd_dmachan
argument_list|)
expr_stmt|;
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|FDBLK
operator|+
name|fd_skip
operator|/
name|FDBLK
expr_stmt|;
name|sectrac
operator|=
name|ft
operator|->
name|sectrac
expr_stmt|;
name|sec
operator|=
name|blknum
operator|%
operator|(
name|sectrac
operator|*
literal|2
operator|)
expr_stmt|;
name|head
operator|=
name|sec
operator|/
name|sectrac
expr_stmt|;
name|sec
operator|=
name|sec
operator|%
name|sectrac
operator|+
literal|1
expr_stmt|;
name|fd_hddrv
operator|=
operator|(
operator|(
name|head
operator|&
literal|1
operator|)
operator|<<
literal|2
operator|)
operator|+
name|fd_drive
expr_stmt|;
if|if
condition|(
name|read
condition|)
name|out_fdc
argument_list|(
name|NE7CMD_READ
argument_list|)
expr_stmt|;
comment|/* READ */
else|else
name|out_fdc
argument_list|(
name|NE7CMD_WRITE
argument_list|)
expr_stmt|;
comment|/* WRITE */
name|out_fdc
argument_list|(
name|head
operator|<<
literal|2
operator||
name|fd_drive
argument_list|)
expr_stmt|;
comment|/* head& unit */
name|out_fdc
argument_list|(
name|fd_track
argument_list|)
expr_stmt|;
comment|/* track */
name|out_fdc
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|sec
argument_list|)
expr_stmt|;
comment|/* sector XXX +1? */
name|out_fdc
argument_list|(
name|ft
operator|->
name|secsize
argument_list|)
expr_stmt|;
comment|/* sector size */
name|out_fdc
argument_list|(
name|sectrac
argument_list|)
expr_stmt|;
comment|/* sectors/track */
name|out_fdc
argument_list|(
name|ft
operator|->
name|gap
argument_list|)
expr_stmt|;
comment|/* gap size */
name|out_fdc
argument_list|(
name|ft
operator|->
name|datalen
argument_list|)
expr_stmt|;
comment|/* data length */
name|fd_state
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* IO DONE, post-analyze */
name|untimeout
argument_list|(
name|fd_timeout
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|fd_status
index|[
name|i
index|]
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fd_status
index|[
literal|0
index|]
operator|&
literal|0xF8
condition|)
block|{
ifdef|#
directive|ifdef
name|FDOTHER
name|printf
argument_list|(
literal|"status0 err %d:"
argument_list|,
name|fd_status
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|retry
goto|;
block|}
comment|/* All OK */
name|isa_dmadone
argument_list|(
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|fd_skip
argument_list|,
name|FDBLK
argument_list|,
name|fd_dmachan
argument_list|)
expr_stmt|;
name|fd_skip
operator|+=
name|FDBLK
expr_stmt|;
if|if
condition|(
name|fd_skip
operator|>=
name|bp
operator|->
name|b_bcount
condition|)
block|{
ifdef|#
directive|ifdef
name|FDTEST
name|printf
argument_list|(
literal|"DONE %d|"
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ALL DONE */
name|fd_skip
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|nextstate
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|FDDEBUG
name|printf
argument_list|(
literal|"next|"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set up next transfer */
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|FDBLK
operator|+
name|fd_skip
operator|/
name|FDBLK
expr_stmt|;
name|fd_state
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|b_cylin
operator|=
operator|(
name|blknum
operator|/
operator|(
name|ft
operator|->
name|sectrac
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_cylin
operator|!=
name|fd_track
condition|)
block|{
ifdef|#
directive|ifdef
name|FDTEST
name|printf
argument_list|(
literal|"Seek|"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SEEK Necessary */
name|out_fdc
argument_list|(
name|NE7CMD_SEEK
argument_list|)
expr_stmt|;
comment|/* Seek function */
name|out_fdc
argument_list|(
name|fd_drive
argument_list|)
expr_stmt|;
comment|/* Drive number */
name|out_fdc
argument_list|(
name|bp
operator|->
name|b_cylin
operator|*
name|dp
operator|->
name|b_step
argument_list|)
expr_stmt|;
name|fd_state
operator|=
literal|6
expr_stmt|;
break|break;
block|}
else|else
name|fdintr
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
name|out_fdc
argument_list|(
name|NE7CMD_SENSEI
argument_list|)
expr_stmt|;
name|st0
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|cyl
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
if|if
condition|(
name|cyl
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"fd%d: recal failed ST0 %b cyl %d\n"
argument_list|,
name|fd_drive
argument_list|,
name|st0
argument_list|,
name|NE7_ST0BITS
argument_list|,
name|cyl
argument_list|)
expr_stmt|;
comment|/* Seek necessary */
name|out_fdc
argument_list|(
name|NE7CMD_SEEK
argument_list|)
expr_stmt|;
comment|/* Seek function */
name|out_fdc
argument_list|(
name|fd_drive
argument_list|)
expr_stmt|;
comment|/* Drive number */
name|out_fdc
argument_list|(
name|bp
operator|->
name|b_cylin
operator|*
name|dp
operator|->
name|b_step
argument_list|)
expr_stmt|;
name|fd_state
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|out_fdc
argument_list|(
name|NE7CMD_SPECIFY
argument_list|)
expr_stmt|;
comment|/* specify command */
name|out_fdc
argument_list|(
literal|0xDF
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|NE7CMD_RECAL
argument_list|)
expr_stmt|;
comment|/* Recalibrate Function */
name|out_fdc
argument_list|(
name|fd_drive
argument_list|)
expr_stmt|;
name|fd_state
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|5
case|:
ifdef|#
directive|ifdef
name|FDOTHER
name|printf
argument_list|(
literal|"**RESET**\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Try a reset, keep motor on */
name|set_motor
argument_list|(
name|fd_drive
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|set_motor
argument_list|(
name|fd_drive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|fdc
operator|+
name|fdctl
argument_list|,
name|ft
operator|->
name|trans
argument_list|)
expr_stmt|;
name|fd_retry
operator|++
expr_stmt|;
name|fd_state
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* allow heads to settle */
name|timeout
argument_list|(
name|fdintr
argument_list|,
name|fd_drive
argument_list|,
name|hz
operator|/
literal|30
argument_list|)
expr_stmt|;
name|fd_state
operator|=
literal|1
expr_stmt|;
return|return;
break|break;
case|case
literal|7
case|:
comment|/* allow heads to settle */
name|timeout
argument_list|(
name|fdintr
argument_list|,
name|fd_drive
argument_list|,
name|hz
operator|/
literal|3
argument_list|)
expr_stmt|;
name|fd_state
operator|=
literal|3
expr_stmt|;
return|return;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unexpected FD int->"
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|NE7CMD_SENSEI
argument_list|)
expr_stmt|;
name|st0
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|cyl
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"ST0 = %lx, PCN = %lx\n"
argument_list|,
name|i
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
literal|0x4A
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fd_drive
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|fd_status
index|[
name|i
index|]
operator|=
name|in_fdc
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"intr status :%lx %lx %lx %lx %lx %lx %lx "
argument_list|,
name|fd_status
index|[
literal|0
index|]
argument_list|,
name|fd_status
index|[
literal|1
index|]
argument_list|,
name|fd_status
index|[
literal|2
index|]
argument_list|,
name|fd_status
index|[
literal|3
index|]
argument_list|,
name|fd_status
index|[
literal|4
index|]
argument_list|,
name|fd_status
index|[
literal|5
index|]
argument_list|,
name|fd_status
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
name|retry
label|:
switch|switch
condition|(
name|fd_retry
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
name|fd_retry
operator|++
expr_stmt|;
name|fd_state
operator|=
literal|4
expr_stmt|;
name|fdintr
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|6
case|:
name|fd_retry
operator|++
expr_stmt|;
name|fd_state
operator|=
literal|5
expr_stmt|;
name|fdintr
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|7
case|:
break|break;
default|default:
comment|/*printf("fd%d: hard error (ST0 %b ST1 %b ST2 %b ST3 %b cyl %d hd %d sec %d)\n", 		fd_drive, fd_status[0], NE7_ST0BITS, fd_status[1], NE7_ST1BITS, 		fd_status[2], NE7_ST2BITS,  fd_status[3], NE7_ST3BITS,  		fd_status[4], fd_status[5], fd_status[6]);*/
name|printf
argument_list|(
literal|"fd%d: hard error (ST0 %b "
argument_list|,
name|fd_drive
argument_list|,
name|fd_status
index|[
literal|0
index|]
argument_list|,
name|NE7_ST0BITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ST1 %b "
argument_list|,
name|fd_status
index|[
literal|1
index|]
argument_list|,
name|NE7_ST1BITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ST2 %b "
argument_list|,
name|fd_status
index|[
literal|2
index|]
argument_list|,
name|NE7_ST2BITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ST3 %b "
argument_list|,
name|fd_status
index|[
literal|3
index|]
argument_list|,
name|NE7_ST3BITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cyl %d hd %d sec %d)\n"
argument_list|,
name|fd_status
index|[
literal|4
index|]
argument_list|,
name|fd_status
index|[
literal|5
index|]
argument_list|,
name|fd_status
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|badtrans
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|fd_state
operator|=
literal|1
expr_stmt|;
name|fd_retry
operator|++
expr_stmt|;
name|fdintr
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|badtrans
argument_list|(
argument|dp
argument_list|,
argument|bp
argument_list|)
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|fd_skip
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|fd_skip
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|nextstate
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
comment|/* 	nextstate : After a transfer is done, continue processing 	requests on the current drive queue.  If empty, go to 	the other drives queue.  If that is empty too, timeout 	to turn off the current drive in 5 seconds, and go 	to state 0 (not expecting any interrupts). */
name|nextstate
argument_list|(
argument|dp
argument_list|)
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|dpother
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
name|fdstart
argument_list|(
name|fd_drive
argument_list|)
expr_stmt|;
else|else
block|{
name|untimeout
argument_list|(
name|fd_turnoff
argument_list|,
name|fd_drive
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|fd_turnoff
argument_list|,
name|fd_drive
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|fd_state
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

