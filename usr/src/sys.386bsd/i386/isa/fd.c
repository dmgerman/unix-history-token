begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*#define DEBUG 1*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Don Ahn.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)fd.c	7.4 (Berkeley) 5/25/91  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         1       00153  * --------------------         -----   ----------------------  *  * 20 Apr 93	Julian Elischer		Heavily re worked, see notes below  *   * Largely rewritten to handle multiple controllers and drives  * By Julian Elischer, Sun Apr  4 16:34:33 WST 1993  */
end_comment

begin_decl_stmt
name|char
name|rev
index|[]
init|=
literal|"$Revision: 1.10 $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * $Header: /usr/src/sys.386bsd/i386/isa/RCS/fd.c,v 1.10 93/04/13 16:53:29 root Exp $  */
end_comment

begin_comment
comment|/*  * $Log:	fd.c,v $  * Revision 1.10  93/04/13  16:53:29  root  * make sure turning off a drive motor doesn't deselect another  * drive active at the time.  * Also added a pointer from the fd_data to it's fd_type.  *   * Revision 1.9  93/04/13  15:31:02  root  * make all seeks go through DOSEEK state so are sure of being done right.  *   * Revision 1.8  93/04/12  21:20:13  root  * only check if old fd is the one we are working on if there IS  * an old fd pointer. (in fdstate())  *   * Revision 1.7  93/04/11  17:05:35  root  * cleanup timeouts etc.  * also fix bug to select teh correct drive when running> 1 drive  * at a time.  *   * Revision 1.6  93/04/05  00:48:45  root  * change a timeout and add version to banner message  *   * Revision 1.5  93/04/04  16:39:08  root  * first working version.. some floppy controllers don't seem to  * like 2 int. status inquiries in a row.  *   */
end_comment

begin_include
include|#
directive|include
file|"fd.h"
end_include

begin_if
if|#
directive|if
name|NFD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"dkbad.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/fdreg.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/icu.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/rtc.h"
end_include

begin_undef
undef|#
directive|undef
name|NFD
end_undef

begin_define
define|#
directive|define
name|NFD
value|2
end_define

begin_define
define|#
directive|define
name|FDUNIT
parameter_list|(
name|s
parameter_list|)
value|((s>>3)&1)
end_define

begin_define
define|#
directive|define
name|FDTYPE
parameter_list|(
name|s
parameter_list|)
value|((s)&7)
end_define

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_define
define|#
directive|define
name|FDBLK
value|512
end_define

begin_define
define|#
directive|define
name|NUMTYPES
value|4
end_define

begin_struct
struct|struct
name|fd_type
block|{
name|int
name|sectrac
decl_stmt|;
comment|/* sectors per track         */
name|int
name|secsize
decl_stmt|;
comment|/* size code for sectors     */
name|int
name|datalen
decl_stmt|;
comment|/* data len when secsize = 0 */
name|int
name|gap
decl_stmt|;
comment|/* gap len between sectors   */
name|int
name|tracks
decl_stmt|;
comment|/* total num of tracks       */
name|int
name|size
decl_stmt|;
comment|/* size of disk in sectors   */
name|int
name|steptrac
decl_stmt|;
comment|/* steps per cylinder        */
name|int
name|trans
decl_stmt|;
comment|/* transfer speed code       */
name|int
name|heads
decl_stmt|;
comment|/* number of heads	     */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|fd_type
name|fd_types
index|[
name|NUMTYPES
index|]
init|=
block|{
block|{
literal|18
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2880
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/* 1.44 meg HD 3.5in floppy    */
block|{
literal|15
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2400
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/* 1.2 meg HD floppy           */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x23
block|,
literal|40
block|,
literal|720
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|}
block|,
comment|/* 360k floppy in 1.2meg drive */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x2A
block|,
literal|40
block|,
literal|720
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|}
block|,
comment|/* 360k floppy in DD drive     */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DRVS_PER_CTLR
value|2
end_define

begin_comment
comment|/***********************************************************************\ * Per controller structure.						* \***********************************************************************/
end_comment

begin_struct
struct|struct
name|fdc_data
block|{
name|int
name|fdcu
decl_stmt|;
comment|/* our unit number */
name|int
name|baseport
decl_stmt|;
name|int
name|dmachan
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|FDC_ATTACHED
value|0x01
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|int
name|fdu
decl_stmt|;
comment|/* the active drive	*/
name|struct
name|buf
name|head
decl_stmt|;
comment|/* Head of buf chain      */
name|struct
name|buf
name|rhead
decl_stmt|;
comment|/* Raw head of buf chain  */
name|int
name|state
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|int
name|status
index|[
literal|7
index|]
decl_stmt|;
comment|/* copy of the registers */
block|}
name|fdc_data
index|[
operator|(
name|NFD
operator|+
literal|1
operator|)
operator|/
name|DRVS_PER_CTLR
index|]
struct|;
end_struct

begin_comment
comment|/***********************************************************************\ * Per drive structure.							* * N per controller (presently 2) (DRVS_PER_CTLR)			* \***********************************************************************/
end_comment

begin_struct
struct|struct
name|fd_data
block|{
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
name|int
name|fdu
decl_stmt|;
comment|/* this unit number */
name|int
name|fdsu
decl_stmt|;
comment|/* this units number on this controller */
name|int
name|type
decl_stmt|;
comment|/* Drive type (HD, DD     */
name|struct
name|fd_type
modifier|*
name|ft
decl_stmt|;
comment|/* pointer to the type descriptor */
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|FD_OPEN
value|0x01
comment|/* it's open		*/
define|#
directive|define
name|FD_ACTIVE
value|0x02
comment|/* it's active		*/
define|#
directive|define
name|FD_MOTOR
value|0x04
comment|/* motor should be on	*/
define|#
directive|define
name|FD_MOTOR_WAIT
value|0x08
comment|/* motor coming up	*/
name|int
name|skip
decl_stmt|;
name|int
name|hddrv
decl_stmt|;
name|int
name|track
decl_stmt|;
comment|/* where we think the head is */
block|}
name|fd_data
index|[
name|NFD
index|]
struct|;
end_struct

begin_comment
comment|/***********************************************************************\ * Throughout this file the following conventions will be used:		* * fd is a pointer to the fd_data struct for the drive in question	* * fdc is a pointer to the fdc_data struct for the controller		* * fdu is the floppy drive unit number					* * fdcu is the floppy controller unit number				* * fdsu is the floppy drive unit number on that controller. (sub-unit)	* \***********************************************************************/
end_comment

begin_typedef
typedef|typedef
name|int
name|fdu_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|fdcu_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|fdsu_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|fd_data
modifier|*
name|fd_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|fdc_data
modifier|*
name|fdc_p
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DEVIDLE
value|0
end_define

begin_define
define|#
directive|define
name|FINDWORK
value|1
end_define

begin_define
define|#
directive|define
name|DOSEEK
value|2
end_define

begin_define
define|#
directive|define
name|SEEKCOMPLETE
value|3
end_define

begin_define
define|#
directive|define
name|IOCOMPLETE
value|4
end_define

begin_define
define|#
directive|define
name|RECALCOMPLETE
value|5
end_define

begin_define
define|#
directive|define
name|STARTRECAL
value|6
end_define

begin_define
define|#
directive|define
name|RESETCTLR
value|7
end_define

begin_define
define|#
directive|define
name|SEEKWAIT
value|8
end_define

begin_define
define|#
directive|define
name|RECALWAIT
value|9
end_define

begin_define
define|#
directive|define
name|MOTORWAIT
value|10
end_define

begin_define
define|#
directive|define
name|IOTIMEDOUT
value|11
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|fdstates
index|[]
init|=
block|{
literal|"DEVIDLE"
block|,
literal|"FINDWORK"
block|,
literal|"DOSEEK"
block|,
literal|"SEEKCOMPLETE"
block|,
literal|"IOCOMPLETE"
block|,
literal|"RECALCOMPLETE"
block|,
literal|"STARTRECAL"
block|,
literal|"RESETCTLR"
block|,
literal|"SEEKWAIT"
block|,
literal|"RECALWAIT"
block|,
literal|"MOTORWAIT"
block|,
literal|"IOTIMEDOUT"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fd_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRACE0
parameter_list|(
name|arg
parameter_list|)
value|if(fd_debug) printf(arg)
end_define

begin_define
define|#
directive|define
name|TRACE1
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
value|if(fd_debug) printf(arg1,arg2)
end_define

begin_else
else|#
directive|else
else|DEBUG
end_else

begin_define
define|#
directive|define
name|TRACE0
parameter_list|(
name|arg
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TRACE1
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state needed for current transfer */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                      autoconfiguration stuff                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_decl_stmt
name|int
name|fdprobe
argument_list|()
decl_stmt|,
name|fdattach
argument_list|()
decl_stmt|,
name|fd_turnoff
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|fddriver
init|=
block|{
name|fdprobe
block|,
name|fdattach
block|,
literal|"fd"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * probe for existance of controller  */
end_comment

begin_macro
name|fdprobe
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fdcu_t
name|fdcu
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
if|if
condition|(
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|flags
operator|&
name|FDC_ATTACHED
condition|)
block|{
name|printf
argument_list|(
literal|"fdc: same unit (%d) used multiple times\n"
argument_list|,
name|fdcu
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|baseport
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
comment|/* see if it can handle a command */
if|if
condition|(
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SPECIFY
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0xDF
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|IO_FDCSIZE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * wire controller into system, look for floppy units  */
end_comment

begin_macro
name|fdattach
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|fdt
decl_stmt|,
name|st0
decl_stmt|,
name|cyl
decl_stmt|;
name|int
name|hdr
decl_stmt|;
name|fdu_t
name|fdu
decl_stmt|;
name|fdcu_t
name|fdcu
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|fdc_p
name|fdc
init|=
name|fdc_data
operator|+
name|fdcu
decl_stmt|;
name|fd_p
name|fd
decl_stmt|;
name|int
name|fdsu
decl_stmt|;
name|fdc
operator|->
name|fdcu
operator|=
name|fdcu
expr_stmt|;
name|fdc
operator|->
name|flags
operator||=
name|FDC_ATTACHED
expr_stmt|;
name|fdc
operator|->
name|dmachan
operator|=
name|dev
operator|->
name|id_drq
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|DEVIDLE
expr_stmt|;
name|fdt
operator|=
name|rtcin
argument_list|(
name|RTC_FDISKETTE
argument_list|)
expr_stmt|;
name|hdr
operator|=
literal|0
expr_stmt|;
comment|/* check for each floppy drive */
for|for
control|(
name|fdu
operator|=
operator|(
name|fdcu
operator|*
name|DRVS_PER_CTLR
operator|)
operator|,
name|fdsu
operator|=
literal|0
init|;
operator|(
operator|(
name|fdu
operator|<
name|NFD
operator|)
operator|&&
operator|(
name|fdsu
operator|<
name|DRVS_PER_CTLR
operator|)
operator|)
condition|;
name|fdu
operator|++
operator|,
name|fdsu
operator|++
control|)
block|{
comment|/* is there a unit? */
if|if
condition|(
operator|(
name|fdt
operator|&
literal|0xf0
operator|)
operator|==
name|RTCFDT_NONE
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|notyet
comment|/* select it */
name|fd_turnon1
argument_list|(
name|fdu
argument_list|)
expr_stmt|;
name|spinwait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 1 sec */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_RECAL
argument_list|)
expr_stmt|;
comment|/* Recalibrate Function */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|fdsu
argument_list|)
expr_stmt|;
name|spinwait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 1 sec */
comment|/* anything responding */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SENSEI
argument_list|)
expr_stmt|;
name|st0
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|cyl
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
if|if
condition|(
name|st0
operator|&
literal|0xd0
condition|)
continue|continue;
endif|#
directive|endif
name|fd_data
index|[
name|fdu
index|]
operator|.
name|track
operator|=
operator|-
literal|2
expr_stmt|;
name|fd_data
index|[
name|fdu
index|]
operator|.
name|fdc
operator|=
name|fdc
expr_stmt|;
name|fd_data
index|[
name|fdu
index|]
operator|.
name|fdsu
operator|=
name|fdsu
expr_stmt|;
comment|/* yes, announce it */
if|if
condition|(
operator|!
name|hdr
condition|)
name|printf
argument_list|(
literal|" drives "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d: "
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdt
operator|&
literal|0xf0
operator|)
operator|==
name|RTCFDT_12M
condition|)
block|{
name|printf
argument_list|(
literal|"1.2M"
argument_list|)
expr_stmt|;
name|fd_data
index|[
name|fdu
index|]
operator|.
name|type
operator|=
literal|1
expr_stmt|;
name|fd_data
index|[
name|fdu
index|]
operator|.
name|ft
operator|=
name|fd_types
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fdt
operator|&
literal|0xf0
operator|)
operator|==
name|RTCFDT_144M
condition|)
block|{
name|printf
argument_list|(
literal|"1.44M"
argument_list|)
expr_stmt|;
name|fd_data
index|[
name|fdu
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|fd_data
index|[
name|fdu
index|]
operator|.
name|ft
operator|=
name|fd_types
operator|+
literal|0
expr_stmt|;
block|}
name|fdt
operator|<<=
literal|4
expr_stmt|;
name|fd_turnoff
argument_list|(
name|fdu
argument_list|)
expr_stmt|;
name|hdr
operator|=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %s "
argument_list|,
name|rev
argument_list|)
expr_stmt|;
comment|/* Set transfer to 500kbps */
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|fdctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*XXX*/
block|}
end_block

begin_function
name|int
name|fdsize
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                               fdstrategy                                 */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_expr_stmt
name|fdstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* IO operation to perform */
end_comment

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dp0
decl_stmt|,
modifier|*
name|dp1
decl_stmt|;
name|long
name|nblocks
decl_stmt|,
name|blknum
decl_stmt|;
name|int
name|s
decl_stmt|;
name|fdcu_t
name|fdcu
decl_stmt|;
name|fdu_t
name|fdu
decl_stmt|;
name|fdc_p
name|fdc
decl_stmt|;
name|fd_p
name|fd
decl_stmt|;
name|fdu
operator|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|&
name|fd_data
index|[
name|fdu
index|]
expr_stmt|;
name|fdc
operator|=
name|fd
operator|->
name|fdc
expr_stmt|;
name|fdcu
operator|=
name|fdc
operator|->
name|fdcu
expr_stmt|;
comment|/*type = FDTYPE(minor(bp->b_dev));*/
if|if
condition|(
operator|(
name|fdu
operator|>=
name|NFD
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"fdstrat: fdu = %d, blkno = %d, bcount = %d\n"
argument_list|,
name|fdu
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|pg
argument_list|(
literal|"fd:error in fdstrategy"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Set up block calculations. 	 */
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|FDBLK
expr_stmt|;
name|nblocks
operator|=
name|fd
operator|->
name|ft
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|blknum
operator|+
operator|(
name|bp
operator|->
name|b_bcount
operator|/
name|FDBLK
operator|)
operator|>
name|nblocks
condition|)
block|{
if|if
condition|(
name|blknum
operator|==
name|nblocks
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENOSPC
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
goto|goto
name|bad
goto|;
block|}
name|bp
operator|->
name|b_cylin
operator|=
name|blknum
operator|/
operator|(
name|fd
operator|->
name|ft
operator|->
name|sectrac
operator|*
name|fd
operator|->
name|ft
operator|->
name|heads
operator|)
expr_stmt|;
name|dp
operator|=
operator|&
operator|(
name|fdc
operator|->
name|head
operator|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|fd_turnoff
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
comment|/* a good idea */
name|fdstart
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                            motor control stuff                           */
end_comment

begin_comment
comment|/*		remember to not deselect the drive we're working on         */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
name|set_motor
argument_list|(
argument|fdcu_t fdcu
argument_list|,
argument|fdu_t fdu
argument_list|,
argument|int reset
argument_list|)
end_macro

begin_block
block|{
name|int
name|m0
decl_stmt|,
name|m1
decl_stmt|;
name|int
name|selunit
decl_stmt|;
name|fd_p
name|fd
decl_stmt|;
if|if
condition|(
name|fd
operator|=
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|fd
condition|)
comment|/* yes an assign! */
block|{
name|selunit
operator|=
name|fd
operator|->
name|fdsu
expr_stmt|;
block|}
else|else
block|{
name|selunit
operator|=
literal|0
expr_stmt|;
block|}
name|m0
operator|=
name|fd_data
index|[
name|fdcu
operator|*
name|DRVS_PER_CTLR
operator|+
literal|0
index|]
operator|.
name|flags
operator|&
name|FD_MOTOR
expr_stmt|;
name|m1
operator|=
name|fd_data
index|[
name|fdcu
operator|*
name|DRVS_PER_CTLR
operator|+
literal|1
index|]
operator|.
name|flags
operator|&
name|FD_MOTOR
expr_stmt|;
name|outb
argument_list|(
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|baseport
operator|+
name|fdout
argument_list|,
name|selunit
operator||
operator|(
name|reset
condition|?
literal|0
else|:
operator|(
name|FDO_FRST
operator||
name|FDO_FDMAEN
operator|)
operator|)
operator||
operator|(
name|m0
condition|?
name|FDO_MOEN0
else|:
literal|0
operator|)
operator||
operator|(
name|m1
condition|?
name|FDO_MOEN1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[0x%x->fdout]"
argument_list|,
operator|(
name|selunit
operator||
operator|(
name|reset
condition|?
literal|0
else|:
operator|(
name|FDO_FRST
operator||
name|FDO_FDMAEN
operator|)
operator|)
operator||
operator|(
name|m0
condition|?
name|FDO_MOEN0
else|:
literal|0
operator|)
operator||
operator|(
name|m1
condition|?
name|FDO_MOEN1
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fd_turnoff
argument_list|(
argument|fdu_t fdu
argument_list|)
end_macro

begin_block
block|{
name|fd_p
name|fd
init|=
name|fd_data
operator|+
name|fdu
decl_stmt|;
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_MOTOR
expr_stmt|;
name|set_motor
argument_list|(
name|fd
operator|->
name|fdc
operator|->
name|fdcu
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fd_motor_on
argument_list|(
argument|fdu_t fdu
argument_list|)
end_macro

begin_block
block|{
name|fd_p
name|fd
init|=
name|fd_data
operator|+
name|fdu
decl_stmt|;
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_MOTOR_WAIT
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|->
name|fdc
operator|->
name|fd
operator|==
name|fd
operator|)
operator|&&
operator|(
name|fd
operator|->
name|fdc
operator|->
name|state
operator|==
name|MOTORWAIT
operator|)
condition|)
block|{
name|fd_pseudointr
argument_list|(
name|fd
operator|->
name|fdc
operator|->
name|fdcu
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|fd_turnon
argument_list|(
argument|fdu_t fdu
argument_list|)
end_macro

begin_block
block|{
name|fd_p
name|fd
init|=
name|fd_data
operator|+
name|fdu
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTOR
operator|)
condition|)
block|{
name|fd_turnon1
argument_list|(
name|fdu
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator||=
name|FD_MOTOR_WAIT
expr_stmt|;
name|timeout
argument_list|(
name|fd_motor_on
argument_list|,
name|fdu
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* in 1 sec its ok */
block|}
block|}
end_block

begin_macro
name|fd_turnon1
argument_list|(
argument|fdu_t fdu
argument_list|)
end_macro

begin_block
block|{
name|fd_p
name|fd
init|=
name|fd_data
operator|+
name|fdu
decl_stmt|;
name|fd
operator|->
name|flags
operator||=
name|FD_MOTOR
expr_stmt|;
name|set_motor
argument_list|(
name|fd
operator|->
name|fdc
operator|->
name|fdcu
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                             fdc in/out                                   */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
name|int
name|in_fdc
parameter_list|(
name|fdcu_t
name|fdcu
parameter_list|)
block|{
name|int
name|baseport
init|=
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|baseport
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
init|=
literal|100000
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|inb
argument_list|(
name|baseport
operator|+
name|fdsts
argument_list|)
operator|&
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|)
operator|!=
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|&&
name|j
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
name|i
operator|==
name|NE7_RQM
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|j
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|i
operator|=
name|inb
argument_list|(
name|baseport
operator|+
name|fddata
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[fddata->0x%x]"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
else|#
directive|else
return|return
name|inb
argument_list|(
name|baseport
operator|+
name|fddata
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_macro
name|out_fdc
argument_list|(
argument|fdcu_t fdcu
argument_list|,
argument|int x
argument_list|)
end_macro

begin_block
block|{
name|int
name|baseport
init|=
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|baseport
decl_stmt|;
name|int
name|i
init|=
literal|100000
decl_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|baseport
operator|+
name|fdsts
argument_list|)
operator|&
name|NE7_DIO
operator|)
operator|&&
name|i
operator|--
operator|>
literal|0
condition|)
empty_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|baseport
operator|+
name|fdsts
argument_list|)
operator|&
name|NE7_RQM
operator|)
operator|==
literal|0
operator|&&
name|i
operator|--
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|outb
argument_list|(
name|baseport
operator|+
name|fddata
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[0x%x->fddata]"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|fdopenf
expr_stmt|;
end_expr_stmt

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                           fdopen/fdclose                                 */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_macro
name|Fdopen
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fdu_t
name|fdu
init|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
comment|/*int type = FDTYPE(minor(dev));*/
name|int
name|s
decl_stmt|;
comment|/* check bounds */
if|if
condition|(
name|fdu
operator|>=
name|NFD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*if (type>= NUMTYPES) return(ENXIO);*/
name|fd_data
index|[
name|fdu
index|]
operator|.
name|flags
operator||=
name|FD_OPEN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|fdclose
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fdu_t
name|fdu
init|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|fd_data
index|[
name|fdu
index|]
operator|.
name|flags
operator|&=
operator|~
name|FD_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/***************************************************************\ *				fdstart				* * We have just queued something.. if the controller is not busy	* * then simulate the case where it has just finished a command	* * So that it (the interrupt routine) looks on the queue for more* * work to do and picks up what we just added.			* * If the controller is already busy, we need do nothing, as it	* * will pick up our work when the present work completes		* \***************************************************************/
end_comment

begin_macro
name|fdstart
argument_list|(
argument|fdcu_t fdcu
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|fdu_t
name|fdu
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|state
operator|==
name|DEVIDLE
condition|)
block|{
name|fdintr
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fd_timeout
argument_list|(
argument|fdcu_t fdcu
argument_list|)
end_macro

begin_block
block|{
name|fdu_t
name|fdu
init|=
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|fdu
decl_stmt|;
name|int
name|st0
decl_stmt|,
name|st3
decl_stmt|,
name|cyl
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|dp
operator|=
operator|&
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|head
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SENSED
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|fd_data
index|[
name|fdu
index|]
operator|.
name|hddrv
argument_list|)
expr_stmt|;
name|st3
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SENSEI
argument_list|)
expr_stmt|;
name|st0
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|cyl
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fd%d: Operation timeout ST0 %b cyl %d ST3 %b\n"
argument_list|,
name|fdu
argument_list|,
name|st0
argument_list|,
name|NE7_ST0BITS
argument_list|,
name|cyl
argument_list|,
name|st3
argument_list|,
name|NE7_ST3BITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
block|{
name|retrier
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|status
index|[
literal|0
index|]
operator|=
literal|0xc0
expr_stmt|;
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|state
operator|=
name|IOTIMEDOUT
expr_stmt|;
if|if
condition|(
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|retry
operator|<
literal|6
condition|)
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|retry
operator|=
literal|6
expr_stmt|;
block|}
else|else
block|{
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|fd
operator|=
operator|(
name|fd_p
operator|)
literal|0
expr_stmt|;
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|fdu
operator|=
operator|-
literal|1
expr_stmt|;
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|state
operator|=
name|DEVIDLE
expr_stmt|;
block|}
name|fd_pseudointr
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* just ensure it has the right spl */
end_comment

begin_macro
name|fd_pseudointr
argument_list|(
argument|fdcu_t fdcu
argument_list|)
end_macro

begin_block
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|fdintr
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***********************************************************************\ *                                 fdintr				* * keep calling the state machine until it returns a 0			* * ALWAYS called at SPLBIO 						* \***********************************************************************/
end_comment

begin_macro
name|fdintr
argument_list|(
argument|fdcu_t fdcu
argument_list|)
end_macro

begin_block
block|{
name|fdc_p
name|fdc
init|=
name|fdc_data
operator|+
name|fdcu
decl_stmt|;
while|while
condition|(
name|fdstate
argument_list|(
name|fdcu
argument_list|,
name|fdc
argument_list|)
condition|)
empty_stmt|;
block|}
end_block

begin_comment
comment|/***********************************************************************\ * The controller state machine.						* * if it returns a non zero value, it should be called again immediatly	* \***********************************************************************/
end_comment

begin_function
name|int
name|fdstate
parameter_list|(
name|fdcu_t
name|fdcu
parameter_list|,
name|fdc_p
name|fdc
parameter_list|)
block|{
name|int
name|read
decl_stmt|,
name|head
decl_stmt|,
name|trac
decl_stmt|,
name|sec
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|,
name|sectrac
decl_stmt|,
name|cyl
decl_stmt|,
name|st0
decl_stmt|;
name|unsigned
name|long
name|blknum
decl_stmt|;
name|fdu_t
name|fdu
init|=
name|fdc
operator|->
name|fdu
decl_stmt|;
name|fd_p
name|fd
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|dp
operator|=
operator|&
operator|(
name|fdc
operator|->
name|head
operator|)
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
block|{
comment|/***********************************************\ 		* nothing left for this controller to do	* 		* Force into the IDLE state,			* 		\***********************************************/
name|fdc
operator|->
name|state
operator|=
name|DEVIDLE
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|fd
condition|)
block|{
name|printf
argument_list|(
literal|"unexpected valid fd pointer (fdu = %d)\n"
argument_list|,
name|fdc
operator|->
name|fdu
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fd
operator|=
operator|(
name|fd_p
operator|)
literal|0
expr_stmt|;
name|fdc
operator|->
name|fdu
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|TRACE1
argument_list|(
literal|"[fdc%d IDLE]"
argument_list|,
name|fdcu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fdu
operator|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fd_data
operator|+
name|fdu
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|fd
operator|&&
operator|(
name|fd
operator|!=
name|fdc
operator|->
name|fd
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"confused fd pointers\n"
argument_list|)
expr_stmt|;
block|}
name|read
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
expr_stmt|;
name|TRACE1
argument_list|(
literal|"fd%d"
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[%s]"
argument_list|,
name|fdstates
index|[
name|fdc
operator|->
name|state
index|]
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"(0x%x)"
argument_list|,
name|fd
operator|->
name|flags
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|fd_turnoff
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|fd_turnoff
argument_list|,
name|fdu
argument_list|,
literal|4
operator|*
name|hz
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fdc
operator|->
name|state
condition|)
block|{
case|case
name|DEVIDLE
case|:
case|case
name|FINDWORK
case|:
comment|/* we have found new work */
name|fdc
operator|->
name|retry
operator|=
literal|0
expr_stmt|;
name|fd
operator|->
name|skip
operator|=
literal|0
expr_stmt|;
name|fdc
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|fdc
operator|->
name|fdu
operator|=
name|fdu
expr_stmt|;
comment|/*******************************************************\ 		* If the next drive has a motor startup pending, then	* 		* it will start up in it's own good time		* 		\*******************************************************/
if|if
condition|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTOR_WAIT
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|MOTORWAIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* come back later */
block|}
comment|/*******************************************************\ 		* Maybe if it's not starting, it SHOULD be starting	* 		\*******************************************************/
if|if
condition|(
operator|!
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTOR
operator|)
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|MOTORWAIT
expr_stmt|;
name|fd_turnon
argument_list|(
name|fdu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
comment|/* at least make sure we are selected */
block|{
name|set_motor
argument_list|(
name|fdcu
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fdc
operator|->
name|state
operator|=
name|DOSEEK
expr_stmt|;
break|break;
case|case
name|DOSEEK
case|:
if|if
condition|(
name|bp
operator|->
name|b_cylin
operator|==
name|fd
operator|->
name|track
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|SEEKCOMPLETE
expr_stmt|;
break|break;
block|}
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SEEK
argument_list|)
expr_stmt|;
comment|/* Seek function */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|)
expr_stmt|;
comment|/* Drive number */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|bp
operator|->
name|b_cylin
operator|*
name|fd
operator|->
name|ft
operator|->
name|steptrac
argument_list|)
expr_stmt|;
name|fd
operator|->
name|track
operator|=
operator|-
literal|2
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|SEEKWAIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
case|case
name|SEEKWAIT
case|:
comment|/* allow heads to settle */
name|timeout
argument_list|(
name|fd_pseudointr
argument_list|,
name|fdcu
argument_list|,
name|hz
operator|/
literal|50
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|SEEKCOMPLETE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
break|break;
case|case
name|SEEKCOMPLETE
case|:
comment|/* SEEK DONE, START DMA */
comment|/* Make sure seek really happened*/
if|if
condition|(
name|fd
operator|->
name|track
operator|==
operator|-
literal|2
condition|)
block|{
name|int
name|descyl
init|=
name|bp
operator|->
name|b_cylin
operator|*
name|fd
operator|->
name|ft
operator|->
name|steptrac
decl_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SENSEI
argument_list|)
expr_stmt|;
name|i
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|cyl
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
if|if
condition|(
name|cyl
operator|!=
name|descyl
condition|)
block|{
name|printf
argument_list|(
literal|"fd%d: Seek to cyl %d failed; am at cyl %d (ST0 = 0x%x)\n"
argument_list|,
name|fdu
argument_list|,
name|descyl
argument_list|,
name|cyl
argument_list|,
name|i
argument_list|,
name|NE7_ST0BITS
argument_list|)
expr_stmt|;
return|return
operator|(
name|retrier
argument_list|(
name|fdcu
argument_list|)
operator|)
return|;
block|}
block|}
name|fd
operator|->
name|track
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|isa_dmastart
argument_list|(
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|fd
operator|->
name|skip
argument_list|,
name|FDBLK
argument_list|,
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|FDBLK
operator|+
name|fd
operator|->
name|skip
operator|/
name|FDBLK
expr_stmt|;
name|sectrac
operator|=
name|fd
operator|->
name|ft
operator|->
name|sectrac
expr_stmt|;
name|sec
operator|=
name|blknum
operator|%
operator|(
name|sectrac
operator|*
name|fd
operator|->
name|ft
operator|->
name|heads
operator|)
expr_stmt|;
name|head
operator|=
name|sec
operator|/
name|sectrac
expr_stmt|;
name|sec
operator|=
name|sec
operator|%
name|sectrac
operator|+
literal|1
expr_stmt|;
comment|/*XXX*/
name|fd
operator|->
name|hddrv
operator|=
operator|(
operator|(
name|head
operator|&
literal|1
operator|)
operator|<<
literal|2
operator|)
operator|+
name|fdu
expr_stmt|;
if|if
condition|(
name|read
condition|)
block|{
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_READ
argument_list|)
expr_stmt|;
comment|/* READ */
block|}
else|else
block|{
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_WRITE
argument_list|)
expr_stmt|;
comment|/* WRITE */
block|}
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|head
operator|<<
literal|2
operator||
name|fdu
argument_list|)
expr_stmt|;
comment|/* head& unit */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|fd
operator|->
name|track
argument_list|)
expr_stmt|;
comment|/* track */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* sector XXX +1? */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|secsize
argument_list|)
expr_stmt|;
comment|/* sector size */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|sectrac
argument_list|)
expr_stmt|;
comment|/* sectors/track */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|gap
argument_list|)
expr_stmt|;
comment|/* gap size */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|datalen
argument_list|)
expr_stmt|;
comment|/* data length */
name|fdc
operator|->
name|state
operator|=
name|IOCOMPLETE
expr_stmt|;
name|timeout
argument_list|(
name|fd_timeout
argument_list|,
name|fdcu
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
case|case
name|IOCOMPLETE
case|:
comment|/* IO DONE, post-analyze */
name|untimeout
argument_list|(
name|fd_timeout
argument_list|,
name|fdcu
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|fdc
operator|->
name|status
index|[
name|i
index|]
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
block|}
case|case
name|IOTIMEDOUT
case|:
comment|/*XXX*/
name|isa_dmadone
argument_list|(
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|fd
operator|->
name|skip
argument_list|,
name|FDBLK
argument_list|,
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|status
index|[
literal|0
index|]
operator|&
literal|0xF8
condition|)
block|{
return|return
operator|(
name|retrier
argument_list|(
name|fdcu
argument_list|)
operator|)
return|;
block|}
comment|/* All OK */
name|fd
operator|->
name|skip
operator|+=
name|FDBLK
expr_stmt|;
if|if
condition|(
name|fd
operator|->
name|skip
operator|<
name|bp
operator|->
name|b_bcount
condition|)
block|{
comment|/* set up next transfer */
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|FDBLK
operator|+
name|fd
operator|->
name|skip
operator|/
name|FDBLK
expr_stmt|;
name|bp
operator|->
name|b_cylin
operator|=
operator|(
name|blknum
operator|/
operator|(
name|fd
operator|->
name|ft
operator|->
name|sectrac
operator|*
name|fd
operator|->
name|ft
operator|->
name|heads
operator|)
operator|)
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|DOSEEK
expr_stmt|;
block|}
else|else
block|{
comment|/* ALL DONE */
name|fd
operator|->
name|skip
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fd
operator|=
operator|(
name|fd_p
operator|)
literal|0
expr_stmt|;
name|fdc
operator|->
name|fdu
operator|=
operator|-
literal|1
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|FINDWORK
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|RESETCTLR
case|:
comment|/* Try a reset, keep motor on */
name|set_motor
argument_list|(
name|fdcu
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|set_motor
argument_list|(
name|fdcu
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|fdctl
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|trans
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[0x%x->fdctl]"
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|trans
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|retry
operator|++
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|STARTRECAL
expr_stmt|;
break|break;
case|case
name|STARTRECAL
case|:
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SPECIFY
argument_list|)
expr_stmt|;
comment|/* specify command */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0xDF
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_RECAL
argument_list|)
expr_stmt|;
comment|/* Recalibrate Function */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|RECALWAIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
case|case
name|RECALWAIT
case|:
comment|/* allow heads to settle */
name|timeout
argument_list|(
name|fd_pseudointr
argument_list|,
name|fdcu
argument_list|,
name|hz
operator|/
literal|30
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|RECALCOMPLETE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
case|case
name|RECALCOMPLETE
case|:
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SENSEI
argument_list|)
expr_stmt|;
name|st0
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|cyl
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
if|if
condition|(
name|cyl
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"fd%d: recal failed ST0 %b cyl %d\n"
argument_list|,
name|fdu
argument_list|,
name|st0
argument_list|,
name|NE7_ST0BITS
argument_list|,
name|cyl
argument_list|)
expr_stmt|;
return|return
operator|(
name|retrier
argument_list|(
name|fdcu
argument_list|)
operator|)
return|;
block|}
name|fd
operator|->
name|track
operator|=
literal|0
expr_stmt|;
comment|/* Seek (probably) necessary */
name|fdc
operator|->
name|state
operator|=
name|DOSEEK
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* will return immediatly */
case|case
name|MOTORWAIT
case|:
if|if
condition|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTOR_WAIT
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* time's not up yet */
block|}
name|fdc
operator|->
name|state
operator|=
name|DOSEEK
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* will return immediatly */
default|default:
name|printf
argument_list|(
literal|"Unexpected FD int->"
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SENSEI
argument_list|)
expr_stmt|;
name|st0
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|cyl
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ST0 = %lx, PCN = %lx\n"
argument_list|,
name|i
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0x4A
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|fdc
operator|->
name|status
index|[
name|i
index|]
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"intr status :%lx %lx %lx %lx %lx %lx %lx "
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|0
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|1
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|2
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|3
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|4
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|5
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Come back immediatly to new state */
block|}
end_function

begin_macro
name|retrier
argument_list|(
argument|fdcu_t fdcu
argument_list|)
end_macro

begin_block
block|{
name|fdc_p
name|fdc
init|=
name|fdc_data
operator|+
name|fdcu
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|dp
operator|=
operator|&
operator|(
name|fdc
operator|->
name|head
operator|)
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
switch|switch
condition|(
name|fdc
operator|->
name|retry
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
name|fdc
operator|->
name|state
operator|=
name|SEEKCOMPLETE
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
name|fdc
operator|->
name|state
operator|=
name|STARTRECAL
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|fdc
operator|->
name|state
operator|=
name|RESETCTLR
expr_stmt|;
break|break;
case|case
literal|7
case|:
break|break;
default|default:
block|{
name|printf
argument_list|(
literal|"fd%d: hard error (ST0 %b "
argument_list|,
name|fdc
operator|->
name|fdu
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|0
index|]
argument_list|,
name|NE7_ST0BITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ST1 %b "
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|1
index|]
argument_list|,
name|NE7_ST1BITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ST2 %b "
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|2
index|]
argument_list|,
name|NE7_ST2BITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ST3 %b "
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|3
index|]
argument_list|,
name|NE7_ST3BITS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cyl %d hd %d sec %d)\n"
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|4
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|5
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|fdc
operator|->
name|fd
operator|->
name|skip
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|fdc
operator|->
name|fd
operator|->
name|skip
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|FINDWORK
expr_stmt|;
name|fdc
operator|->
name|fd
operator|=
operator|(
name|fd_p
operator|)
literal|0
expr_stmt|;
name|fdc
operator|->
name|fdu
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fdc
operator|->
name|retry
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

