begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz and Don Ahn.  * Many improvements based on this source are made by Holger Veit.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#) $RCSfile: co_vga.c,v $	$Revision: 1.11 $ (Berkeley) $Date: 93/01/23 23:14:55 $  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/src/sys.386bsd/i386/isa/codrv/RCS/co_vga.c,v 1.11 93/01/23 23:14:55 root Exp Locker: root $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * History: see CO_HISTORY  */
end_comment

begin_include
include|#
directive|include
file|"co.h"
end_include

begin_include
include|#
directive|include
file|"pc.h"
end_include

begin_if
if|#
directive|if
name|NCO
operator|==
literal|1
end_if

begin_if
if|#
directive|if
name|NPC
operator|==
literal|0
end_if

begin_include
include|#
directive|include
file|"co_hdr.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|isinitialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* =1: console/vtys initialized */
end_comment

begin_decl_stmt
name|u_short
modifier|*
name|Crtat
init|=
operator|(
name|u_short
operator|*
operator|)
name|MONO_BUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The only absolute location that is 					 * known from video memory, everything 					 * else derived from it, 					 * modified by device probe */
end_comment

begin_decl_stmt
specifier|static
name|int
name|scrblanksave
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* save position cursor */
end_comment

begin_decl_stmt
specifier|static
name|u_short
modifier|*
name|scrbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for screen saver */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|card2name
parameter_list|(
name|int
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* find video config */
end_comment

begin_function
specifier|static
name|void
name|probe_video
parameter_list|()
block|{
name|vga_whoami
argument_list|()
expr_stmt|;
if|if
condition|(
name|vds
operator|.
name|color
condition|)
block|{
name|Crtat
operator|+=
operator|(
name|CGA_BUF
operator|-
name|MONO_BUF
operator|)
operator|/
name|CHR
expr_stmt|;
name|vds
operator|.
name|iobase
operator|=
literal|0x3D0
expr_stmt|;
comment|/* color */
block|}
else|else
name|vds
operator|.
name|iobase
operator|=
literal|0x3B0
expr_stmt|;
comment|/* mono */
name|vds
operator|.
name|encoding
index|[
literal|0
index|]
operator|=
name|XLAT2PC8
expr_stmt|;
name|vds
operator|.
name|encoding
index|[
literal|1
index|]
operator|=
name|NOFONT
expr_stmt|;
name|vds
operator|.
name|f89bit
operator|=
name|vds
operator|.
name|cardtype
operator|>=
name|VG_EGA
condition|?
literal|9
else|:
literal|8
expr_stmt|;
block|}
end_function

begin_function
name|int
name|coattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|cursorshape
name|cs
decl_stmt|;
name|struct
name|kbd_hotkey
name|spec
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* re-initialize ALL vtys */
name|vty_init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* initialize the ioctl subsystem */
name|coioctl_init
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|card2name
argument_list|(
name|vds
operator|.
name|cardtype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vds
operator|.
name|cardsubtype
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"/0x%02x"
argument_list|,
name|vds
operator|.
name|cardsubtype
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ram %dk io 0x%x kbd 0x%x"
argument_list|,
name|vds
operator|.
name|ram
argument_list|,
name|vds
operator|.
name|iobase
argument_list|,
name|kbs
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvty
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|" vtys %d"
argument_list|,
name|nvty
argument_list|)
expr_stmt|;
comment|/* create a save buffer for screen saver */
if|if
condition|(
operator|!
name|scrbuf
condition|)
comment|/* XXX modify with different screen sizes */
name|scrbuf
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|vtys
index|[
literal|0
index|]
operator|.
name|size
operator|*
name|CHR
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scrbuf
condition|)
name|panic
argument_list|(
literal|"coattach: no screen buffer"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FAT_CURSOR
name|cs
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|cs
operator|.
name|end
operator|=
literal|18
expr_stmt|;
name|vga_setcshape
argument_list|(
operator|&
name|cs
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FAT_CURSOR
name|vds
operator|.
name|blanking
operator|=
literal|0
expr_stmt|;
name|vds
operator|.
name|scrtimeout
operator|=
name|BLANKTIMEOUT
expr_stmt|;
name|vga_doblanking
argument_list|(
name|BLANKSTART
argument_list|)
expr_stmt|;
name|vga_cursor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* define the basic special function keys 	 * CTRL-ALT-DEL (Reset) 	 * CTRL-ALT-ESC (Debugger) 	 * CTRL-ALT-F1  (VTY-1) 	 * CTRL-ALT-F2	(VTY-2) 	 * CTRL-ALT-F3  (VTY-3) 	 * CTRL-ALT-F4	(VTY-4) 	 * CTRL-ALT-F5  (VTY-5) 	 * CTRL-ALT-F6	(VTY-6) 	 * CTRL-ALT-F7  (VTY-7) 	 * CTRL-ALT-F8	(VTY-8) 	 * CTRL-ALT-F9  (VTY-9) 	 * CTRL-ALT-F10	(VTY-10) 	 * CTRL-ALT-F11	(VTY-11) 	 * CTRL-ALT-F12	(VTY-12) 	 */
name|spec
operator|.
name|key
operator|=
literal|104
expr_stmt|;
comment|/*DEL*/
name|spec
operator|.
name|modifier
operator|=
name|KBD_EXT_CA
expr_stmt|;
comment|/*CTRL-ALT*/
name|spec
operator|.
name|function
operator|=
name|KBD_RESETKEY
expr_stmt|;
name|kbd_sethotkey
argument_list|(
operator|&
name|spec
argument_list|)
expr_stmt|;
if|#
directive|if
name|NDDB
operator|>
literal|0
name|spec
operator|.
name|key
operator|=
literal|110
expr_stmt|;
comment|/*ESC*/
name|spec
operator|.
name|function
operator|=
name|KBD_DEBUGKEY
expr_stmt|;
name|kbd_sethotkey
argument_list|(
operator|&
name|spec
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
name|spec
operator|.
name|key
operator|=
literal|112
operator|+
name|i
expr_stmt|;
name|spec
operator|.
name|function
operator|=
name|i
expr_stmt|;
name|kbd_sethotkey
argument_list|(
operator|&
name|spec
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * vga_cursor():  *   reassigns cursor position, updated by the rescheduling clock  *   which is a index (0-1999) into the text area. Note that the  *   cursor is a "foreground" character, it's color determined by  *   the fg_at attribute. Thus if fg_at is left as 0, (FG_BLACK),  *   as when a portion of screen memory is 0, the cursor may dissappear.  */
end_comment

begin_function
name|void
name|vga_setcursorpos
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|outb
argument_list|(
name|vds
operator|.
name|iobase
operator|+
literal|4
argument_list|,
name|M6845_CURSORH
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|vds
operator|.
name|iobase
operator|+
literal|5
argument_list|,
name|pos
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|vds
operator|.
name|iobase
operator|+
literal|4
argument_list|,
name|M6845_CURSORL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|vds
operator|.
name|iobase
operator|+
literal|5
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vga_cursor
parameter_list|(
name|int
name|a
parameter_list|)
block|{
name|vga_setcursorpos
argument_list|(
name|actvty
operator|->
name|crtat
operator|-
name|actvty
operator|->
name|Crtat
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
operator|&&
name|actvty
operator|->
name|visible
operator|==
literal|1
condition|)
name|timeout
argument_list|(
name|vga_cursor
argument_list|,
literal|0
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MINITERM
end_ifndef

begin_comment
comment|/* Screen saver function:   * XXX to be changed for graphics console  *  * if screenblanking is enabled, the display is switched off after delay  * given in scrtimeout (in sec.)   * Any key hit restarts display again and restarts the timer.  * scrtimeout = 0 disables blanking.  * Also, blanking is suspended if console_x_mode is active, because it  * is supposed that X11 has its own facilities to turn off display.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cursorshape
name|playsave
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|SCRSAVER
operator|==
literal|1
end_if

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|display_off
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|ctime
parameter_list|)
block|{
specifier|static
name|int
name|play1
decl_stmt|,
name|play2
decl_stmt|,
name|play3
decl_stmt|,
name|play4
decl_stmt|;
name|int
name|dir
index|[]
init|=
block|{
operator|-
literal|79
block|,
operator|-
literal|81
block|,
literal|79
block|,
literal|81
block|}
decl_stmt|;
specifier|register
name|s
expr_stmt|;
name|int
name|size
init|=
name|actvty
operator|->
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|actvty
operator|->
name|visible
condition|)
return|return;
comment|/* no show on invisible screen */
if|if
condition|(
name|vds
operator|.
name|blanking
operator|==
literal|1
condition|)
block|{
comment|/* This idea was in parts borrowed from Linux, since I  	 * was too lazy to play around with the video registers  	 * (although there are suited bits to switch) 	 * screenplay originally by me (holgi) 	 */
name|bcopy
argument_list|(
name|actvty
operator|->
name|Crtat
argument_list|,
name|scrbuf
argument_list|,
name|size
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
literal|0x0820
argument_list|,
name|actvty
operator|->
name|Crtat
argument_list|,
name|actvty
operator|->
name|size
argument_list|)
expr_stmt|;
name|scrblanksave
operator|=
name|actvty
operator|->
name|crtat
operator|-
name|actvty
operator|->
name|Crtat
expr_stmt|;
name|vds
operator|.
name|blanking
operator|=
literal|2
expr_stmt|;
name|play1
operator|=
name|actvty
operator|->
name|crtat
operator|-
name|actvty
operator|->
name|Crtat
expr_stmt|;
name|play2
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|play3
operator|=
literal|7
expr_stmt|;
name|play4
operator|=
literal|1
expr_stmt|;
name|untimeout
argument_list|(
name|vga_cursor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* some animation */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|vga_setcursorpos
argument_list|(
name|play1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|play3
condition|)
block|{
name|play2
operator|=
operator|(
name|play2
operator|%
literal|1237
operator|)
operator|+
literal|997
expr_stmt|;
name|play3
operator|=
literal|4
operator|+
operator|(
name|play2
operator|%
literal|9
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|play2
operator|>>
literal|3
operator|)
operator|&
literal|3
operator|)
operator|==
name|play4
condition|)
name|play4
operator|=
operator|(
name|play4
operator|+
literal|1
operator|)
operator|%
literal|4
expr_stmt|;
else|else
name|play4
operator|=
operator|(
name|play2
operator|>>
literal|3
operator|)
operator|&
literal|3
expr_stmt|;
block|}
else|else
name|play3
operator|--
expr_stmt|;
name|play1
operator|+=
name|dir
index|[
name|play4
index|]
expr_stmt|;
if|if
condition|(
name|play1
operator|<
literal|0
condition|)
name|play1
operator|+=
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|play1
operator|>=
name|size
condition|)
name|play1
operator|-=
name|size
expr_stmt|;
name|timeout
argument_list|(
name|display_off
argument_list|,
literal|0
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|SCRSAVER
operator|==
literal|2
end_if

begin_comment
comment|/* moving snake by Chr. Robitschko */
end_comment

begin_comment
comment|/* XXX This code could be merged with the standard saver, because there are    not many modifications, but I need things to do for the next version */
end_comment

begin_function
specifier|static
name|void
name|display_off
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|ctime
parameter_list|)
block|{
name|int
name|dir
index|[]
init|=
block|{
operator|-
literal|79
block|,
operator|-
literal|81
block|,
literal|79
block|,
literal|81
block|}
decl_stmt|;
specifier|register
name|s
operator|,
name|f
expr_stmt|;
ifdef|#
directive|ifdef
name|NETBSD
specifier|const
name|char
name|snake
index|[]
init|=
block|{
literal|"NetBSD"
block|}
decl_stmt|;
else|#
directive|else
specifier|const
name|char
name|snake
index|[]
init|=
block|{
literal|"386BSD"
block|}
decl_stmt|;
endif|#
directive|endif
specifier|const
name|int
name|snlen
init|=
sizeof|sizeof
argument_list|(
name|snake
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|static
name|char
modifier|*
name|snpos
index|[
name|snlen
index|]
decl_stmt|;
specifier|static
name|int
name|play1
decl_stmt|,
name|play2
decl_stmt|,
name|play3
decl_stmt|,
name|play4
decl_stmt|;
name|struct
name|cursorshape
name|cs
decl_stmt|;
name|int
name|size
init|=
name|actvty
operator|->
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|actvty
operator|->
name|visible
condition|)
return|return;
comment|/* no show on invisible screen */
if|if
condition|(
name|vds
operator|.
name|blanking
operator|==
literal|1
condition|)
block|{
comment|/* disable cursor -hv- */
name|vga_getcshape
argument_list|(
operator|&
name|playsave
argument_list|)
expr_stmt|;
name|cs
operator|.
name|start
operator|=
literal|31
expr_stmt|;
name|cs
operator|.
name|end
operator|=
literal|30
expr_stmt|;
name|vga_setcshape
argument_list|(
operator|&
name|cs
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|actvty
operator|->
name|Crtat
argument_list|,
name|scrbuf
argument_list|,
name|size
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
literal|0x0820
argument_list|,
name|actvty
operator|->
name|Crtat
argument_list|,
name|actvty
operator|->
name|size
argument_list|)
expr_stmt|;
name|scrblanksave
operator|=
name|actvty
operator|->
name|crtat
operator|-
name|actvty
operator|->
name|Crtat
expr_stmt|;
name|vds
operator|.
name|blanking
operator|=
literal|2
expr_stmt|;
name|play1
operator|=
name|actvty
operator|->
name|crtat
operator|-
name|actvty
operator|->
name|Crtat
expr_stmt|;
name|play2
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|play3
operator|=
literal|7
expr_stmt|;
name|play4
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|snlen
condition|;
name|f
operator|++
control|)
name|snpos
index|[
name|f
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|untimeout
argument_list|(
name|vga_cursor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* some animation */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|snpos
index|[
name|snlen
operator|-
literal|1
index|]
condition|)
operator|*
name|snpos
index|[
name|snlen
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|f
operator|=
name|snlen
operator|-
literal|1
init|;
name|f
operator|>
literal|0
condition|;
name|f
operator|--
control|)
name|snpos
index|[
name|f
index|]
operator|=
name|snpos
index|[
name|f
operator|-
literal|1
index|]
expr_stmt|;
name|snpos
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|Crtat
operator|+
name|play1
operator|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|snlen
operator|-
literal|1
init|;
name|f
operator|>=
literal|0
condition|;
name|f
operator|--
control|)
if|if
condition|(
name|snpos
index|[
name|f
index|]
condition|)
operator|*
name|snpos
index|[
name|f
index|]
operator|=
name|snake
index|[
name|f
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|play3
condition|)
block|{
name|play2
operator|=
operator|(
name|play2
operator|%
literal|1237
operator|)
operator|+
literal|997
expr_stmt|;
name|play3
operator|=
literal|4
operator|+
operator|(
name|play2
operator|%
literal|9
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|play2
operator|>>
literal|3
operator|)
operator|&
literal|1
operator|)
operator|==
name|play4
operator|%
literal|2
condition|)
name|play4
operator|=
operator|(
name|play4
operator|+
literal|1
operator|)
operator|%
literal|4
expr_stmt|;
else|else
name|play4
operator|=
operator|(
name|play2
operator|>>
literal|3
operator|)
operator|&
literal|3
expr_stmt|;
block|}
else|else
name|play3
operator|--
expr_stmt|;
name|play1
operator|+=
name|dir
index|[
name|play4
index|]
expr_stmt|;
if|if
condition|(
name|play1
operator|<
literal|0
condition|)
name|play1
operator|+=
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|play1
operator|>=
name|size
condition|)
name|play1
operator|-=
name|size
expr_stmt|;
name|timeout
argument_list|(
name|display_off
argument_list|,
literal|0
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|ERROR
operator|!
name|NEED
name|SCRSAVER
operator|=
literal|1
name|OR
literal|2
endif|#
directive|endif
comment|/* SCRSAVER=2 */
endif|#
directive|endif
comment|/* SCRSAVER=1 */
comment|/* XXX graphics */
specifier|static
name|void
name|display_on
argument_list|()
block|{
comment|/* reload old content */
if|if
condition|(
name|vds
operator|.
name|blanking
operator|==
literal|2
condition|)
block|{
name|bcopy
argument_list|(
name|scrbuf
argument_list|,
name|actvty
operator|->
name|Crtat
argument_list|,
name|actvty
operator|->
name|size
operator|*
name|CHR
argument_list|)
expr_stmt|;
if|if
condition|(
name|playsave
operator|.
name|start
operator|!=
operator|-
literal|1
condition|)
name|vga_setcshape
argument_list|(
operator|&
name|playsave
argument_list|)
expr_stmt|;
name|vga_setcursorpos
argument_list|(
name|scrblanksave
argument_list|)
expr_stmt|;
name|vga_cursor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|/* XXX graphics */
end_comment

begin_macro
unit|void
name|vga_doblanking
argument_list|(
argument|int fct
argument_list|)
end_macro

begin_block
block|{
comment|/* restore display, just in case */
name|display_on
argument_list|()
expr_stmt|;
comment|/* timer was started, stop */
if|if
condition|(
name|vds
operator|.
name|blanking
operator|<
literal|3
condition|)
name|untimeout
argument_list|(
name|display_off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vds
operator|.
name|blanking
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fct
operator|==
name|BLANKSTART
condition|)
block|{
if|if
condition|(
name|vds
operator|.
name|scrtimeout
condition|)
block|{
comment|/* start it */
name|timeout
argument_list|(
name|display_off
argument_list|,
literal|0
argument_list|,
name|vds
operator|.
name|scrtimeout
operator|*
name|hz
argument_list|)
expr_stmt|;
name|vds
operator|.
name|blanking
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/*else if(fct==BLANKSTOP) vds.blanking = 0;*/
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MINITERM */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|display_off
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|ctime
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|display_on
parameter_list|()
block|{}
end_function

begin_function
name|void
name|vga_doblanking
parameter_list|(
name|int
name|fct
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* normally called by init_main to do local initialisation */
end_comment

begin_comment
comment|/* called by sput, if anyone is faster than init_main, e.g. ddb */
end_comment

begin_function
name|void
name|consinit
parameter_list|()
block|{
if|if
condition|(
name|isinitialized
operator|==
literal|0
condition|)
block|{
comment|/* find out video card */
name|probe_video
argument_list|()
expr_stmt|;
comment|/* initialize video device */
name|emul_initvideo
argument_list|()
expr_stmt|;
comment|/* disable screensaver */
name|vds
operator|.
name|blanking
operator|=
literal|3
expr_stmt|;
comment|/* initialize a single terminal */
name|vty_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|isinitialized
operator|=
literal|1
expr_stmt|;
comment|/* NetBSD would like to have this,  		 * and for 386bsd it doesn't make problems */
name|cons_normal
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *   sput calls vtemul_exec for terminal emulation  *   if ka, use kernel attributes.  */
end_comment

begin_function
name|void
name|sput
parameter_list|(
name|int
name|vtynum
parameter_list|,
name|XCHAR
name|c
parameter_list|,
name|int
name|ka
parameter_list|)
block|{
specifier|register
name|struct
name|vty
modifier|*
name|act
decl_stmt|;
if|if
condition|(
operator|!
name|isinitialized
condition|)
name|consinit
argument_list|()
expr_stmt|;
comment|/* necessary: turn on display again */
if|if
condition|(
name|vds
operator|.
name|blanking
operator|==
literal|2
condition|)
name|vga_doblanking
argument_list|(
name|BLANKSTART
argument_list|)
expr_stmt|;
comment|/* select vty */
name|act
operator|=
operator|&
name|vtys
index|[
name|vtynum
index|]
expr_stmt|;
comment|/* select attribute set */
name|act
operator|->
name|op
operator|=
name|ka
condition|?
operator|&
name|act
operator|->
name|om
index|[
literal|1
index|]
else|:
operator|&
name|act
operator|->
name|om
index|[
literal|0
index|]
expr_stmt|;
comment|/* process input */
name|vtemul_exec
argument_list|(
name|act
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* re-set cursor position */
if|if
condition|(
name|ka
condition|)
name|vga_cursor
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* both routines used by init_main for more portability */
end_comment

begin_function
name|void
name|cons_highlight
parameter_list|()
block|{
specifier|register
name|struct
name|vty
modifier|*
name|p
init|=
operator|&
name|vtys
index|[
literal|0
index|]
decl_stmt|;
name|p
operator|->
name|op
operator|=
operator|&
name|p
operator|->
name|om
index|[
literal|1
index|]
expr_stmt|;
name|emul_setattributes
argument_list|(
name|p
argument_list|,
literal|3
argument_list|,
literal|15
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cons_normal
parameter_list|()
block|{
specifier|register
name|struct
name|vty
modifier|*
name|p
init|=
operator|&
name|vtys
index|[
literal|0
index|]
decl_stmt|;
name|p
operator|->
name|op
operator|=
operator|&
name|p
operator|->
name|om
index|[
literal|1
index|]
expr_stmt|;
name|emul_setattributes
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * vga_whoami: try to detect whether a SVGA is present  * see Ferraro, Programmer's guide to the EGA/VGA cards for more info  */
end_comment

begin_comment
comment|/*  * Try to identify, which video card is in the system  */
end_comment

begin_function
name|void
name|vga_whoami
parameter_list|()
block|{
specifier|register
name|int
name|iobase
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_char
modifier|*
name|videobios
decl_stmt|;
name|u_short
modifier|*
name|vp
decl_stmt|;
name|u_short
name|vsave
decl_stmt|;
specifier|volatile
name|u_char
name|lock
decl_stmt|,
name|save1
decl_stmt|,
name|save2
decl_stmt|,
name|save3
decl_stmt|,
name|save4
decl_stmt|;
name|vds
operator|.
name|color
operator|=
literal|1
expr_stmt|;
comment|/* default */
name|vds
operator|.
name|cardtype
operator|=
name|VG_UNKNOWN
expr_stmt|;
name|vds
operator|.
name|cardsubtype
operator|=
operator|-
literal|1
expr_stmt|;
name|vds
operator|.
name|ram
operator|=
literal|64
expr_stmt|;
comment|/* first look whether there is RAM in the COLOR region, if this is 	 * a mono card, there is none 	 */
name|vp
operator|=
name|Crtat
operator|+
operator|(
name|CGA_BUF
operator|-
name|MONO_BUF
operator|)
operator|/
name|CHR
expr_stmt|;
name|vsave
operator|=
operator|*
name|vp
expr_stmt|;
operator|*
name|vp
operator|=
literal|0xCC33
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* wait 100 us, doesn't help if you buffer your isa  		     * bus lines with large capacitors  :-) 	             */
if|if
condition|(
operator|*
name|vp
operator|==
literal|0xCC33
condition|)
goto|goto
name|not_a_mono
goto|;
else|else
block|{
comment|/* we are paranoid */
operator|*
name|vp
operator|=
literal|0xA55A
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|vp
operator|==
literal|0xA55A
condition|)
goto|goto
name|not_a_mono
goto|;
block|}
comment|/* oh, that poor owner has only a MDA/Hercules card :-) */
operator|*
name|vp
operator|=
name|vsave
expr_stmt|;
name|vds
operator|.
name|ram
operator|=
literal|16
expr_stmt|;
name|vds
operator|.
name|color
operator|=
literal|0
expr_stmt|;
name|vds
operator|.
name|cardtype
operator|=
name|VG_MONO
expr_stmt|;
return|return;
name|not_a_mono
label|:
operator|*
name|vp
operator|=
name|vsave
expr_stmt|;
comment|/* there is RAM in the ???B8000 region, look which color card we have 	 * Hmmm... the ancient CGA was supported by the ROMBIOS, and had no ROM 	 * on board, but the EGA's and VGA's have 	 */
name|videobios
operator|=
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|Crtat
operator|+
operator|(
name|EGA_BIOS
operator|-
name|MONO_BUF
operator|)
expr_stmt|;
comment|/* Some machines map video BIOS to e0000 instead of c0000. 	 * Check it now. 	 */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|0x55
operator|||
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|!=
literal|0xAA
condition|)
name|videobios
operator|=
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|Crtat
operator|+
operator|(
name|ALTEGA_BIOS
operator|-
name|MONO_BUF
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|0x55
operator|||
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|!=
literal|0xAA
condition|)
block|{
comment|/* There is no ROM ID. 		 * you do not plan to run X11 with this card, do you? 		 */
name|vds
operator|.
name|ram
operator|=
literal|16
expr_stmt|;
name|vds
operator|.
name|cardtype
operator|=
name|VG_CGA
expr_stmt|;
return|return;
block|}
comment|/* this is an EGA or a VGA or a SVGA or something else quite strange 	 * so lets look whether this is a VGA. We know that several EGA  	 * registers are readonly, which is really a design fault. 	 * so just look, whether we can write and read something into  	 * such a register: this will hold for the CRT address register at 	 * iobase+4 and the graphics control address 	 */
if|if
condition|(
name|inb
argument_list|(
literal|0x3cc
argument_list|)
operator|&
literal|1
condition|)
block|{
name|iobase
operator|=
name|vds
operator|.
name|iobase
operator|=
literal|0x3D0
expr_stmt|;
block|}
else|else
block|{
name|iobase
operator|=
name|vds
operator|.
name|iobase
operator|=
literal|0x3B0
expr_stmt|;
name|vds
operator|.
name|color
operator|=
literal|0
expr_stmt|;
block|}
name|outb
argument_list|(
name|iobase
operator|+
literal|4
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|iobase
operator|+
literal|4
argument_list|)
operator|!=
literal|7
condition|)
name|vds
operator|.
name|cardtype
operator|=
name|VG_EGA
expr_stmt|;
else|else
block|{
name|outb
argument_list|(
literal|0x3ce
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
literal|0x3ce
argument_list|)
operator|!=
literal|2
condition|)
name|vds
operator|.
name|cardtype
operator|=
name|VG_EGA
expr_stmt|;
block|}
if|if
condition|(
name|vds
operator|.
name|cardtype
operator|==
name|VG_EGA
condition|)
block|{
name|vds
operator|.
name|ram
operator|=
literal|64
expr_stmt|;
comment|/* for simplicity assume the worst */
return|return;
block|}
comment|/* There is a problem now: 8514/A adapters also have ROM, unfortunately 	 * I don't have sufficient information about the 8514/A and the XGA, 	 * so just don't try 386BSD with it ! 	 */
comment|/* I don't know whether this already qualifies for a VGA, so 	 * someone may add some code here, but for now I am persuaded that I 	 * have a VGA at this point. This might be a SVGA, however, so let's  	 * look if this assumption is true. Hard stuff follows... 	 * refer to Ferraro: Programmer's Guide to the EGA and VGA Cards 	 * 2nd ed, Addison-Wesley, 1990 	 */
name|vds
operator|.
name|cardtype
operator|=
name|VG_VGA
expr_stmt|;
comment|/* unlock paradise registers */
name|outb
argument_list|(
name|iobase
operator|+
literal|4
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
name|lock
operator|=
name|inb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|,
name|lock
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
comment|/* now check for a PVGA1 */
name|cp
operator|=
name|videobios
operator|+
literal|0x007d
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'V'
operator|&&
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|==
literal|'G'
operator|&&
operator|*
operator|(
name|cp
operator|+
literal|2
operator|)
operator|==
literal|'A'
operator|&&
operator|*
operator|(
name|cp
operator|+
literal|3
operator|)
operator|==
literal|'='
condition|)
block|{
comment|/* this is a paradise, now check which one */
name|vds
operator|.
name|cardtype
operator|=
name|VG_PARADISE
expr_stmt|;
name|outw
argument_list|(
literal|0x3CE
argument_list|,
literal|0x050F
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|iobase
operator|+
literal|4
argument_list|,
literal|0x8529
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|4
argument_list|,
literal|0x2b
argument_list|)
expr_stmt|;
name|save1
operator|=
name|inb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|save2
operator|=
name|inb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|,
name|save1
argument_list|)
expr_stmt|;
if|if
condition|(
name|save2
operator|!=
literal|0xaa
condition|)
block|{
name|vds
operator|.
name|cardsubtype
operator|=
literal|0x01
expr_stmt|;
goto|goto
name|foundp2
goto|;
block|}
name|outb
argument_list|(
literal|0x3c4
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
name|save1
operator|=
name|inb
argument_list|(
literal|0x3c5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3c5
argument_list|,
name|save1
operator|&
literal|0xbf
argument_list|)
expr_stmt|;
name|save2
operator|=
name|inb
argument_list|(
literal|0x3c5
argument_list|)
operator|&
literal|0x40
expr_stmt|;
if|if
condition|(
name|save2
condition|)
block|{
name|vds
operator|.
name|cardsubtype
operator|=
literal|0x01
expr_stmt|;
goto|goto
name|foundp2
goto|;
block|}
name|outb
argument_list|(
literal|0x3c5
argument_list|,
name|save1
operator||
literal|0x40
argument_list|)
expr_stmt|;
name|save2
operator|=
name|inb
argument_list|(
literal|0x3c5
argument_list|)
operator|&
literal|0x40
expr_stmt|;
if|if
condition|(
operator|!
name|save2
condition|)
block|{
name|vds
operator|.
name|cardsubtype
operator|=
literal|0x02
expr_stmt|;
goto|goto
name|foundp
goto|;
block|}
name|outb
argument_list|(
literal|0x3c5
argument_list|,
name|save1
argument_list|)
expr_stmt|;
name|save3
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
literal|0x3c4
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|save1
operator|=
name|inb
argument_list|(
literal|0x3c5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3c5
argument_list|,
name|save1
operator|&
literal|0xfb
argument_list|)
expr_stmt|;
name|save2
operator|=
name|inb
argument_list|(
literal|0x3c5
argument_list|)
operator|&
literal|0x04
expr_stmt|;
if|if
condition|(
name|save2
condition|)
name|save3
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
literal|0x3c5
argument_list|,
name|save1
operator||
literal|0x04
argument_list|)
expr_stmt|;
name|save2
operator|=
name|inb
argument_list|(
literal|0x3c5
argument_list|)
operator|&
literal|0x04
expr_stmt|;
if|if
condition|(
operator|!
name|save2
condition|)
name|save3
operator|=
literal|1
expr_stmt|;
name|vds
operator|.
name|cardsubtype
operator|=
name|save3
condition|?
literal|0x03
else|:
literal|0x04
expr_stmt|;
name|foundp
label|:
name|outb
argument_list|(
literal|0x3c5
argument_list|,
name|save1
argument_list|)
expr_stmt|;
name|foundp2
label|:
if|if
condition|(
name|vds
operator|.
name|cardsubtype
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* find ram */
name|outb
argument_list|(
literal|0x3ce
argument_list|,
literal|0x0b
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inb
argument_list|(
literal|0x3cf
argument_list|)
operator|&
literal|0xc0
condition|)
block|{
case|case
literal|0x80
case|:
name|vds
operator|.
name|ram
operator|=
literal|512
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
name|vds
operator|.
name|ram
operator|=
literal|1024
expr_stmt|;
break|break;
default|default:
name|vds
operator|.
name|ram
operator|=
literal|256
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* Strategy: The ET4000 uses the reg 3x5/33, the ET3000 uses the 3x5/23  * uniquely, the WD paradises also use 3x5/33. So check for Paradise  * first, and if it's not, check for 3000/4000 with these registers  */
comment|/* Is this a TSENG? */
name|outb
argument_list|(
literal|0x3bf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|8
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
name|save1
operator|=
name|inb
argument_list|(
name|iobase
operator|+
literal|0x0A
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3C0
argument_list|,
literal|0x20
operator||
literal|0x16
argument_list|)
expr_stmt|;
name|save2
operator|=
name|inb
argument_list|(
literal|0x3C1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3C0
argument_list|,
name|save2
operator|^
literal|0x10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3C0
argument_list|,
literal|0x20
operator||
literal|0x16
argument_list|)
expr_stmt|;
name|save3
operator|=
name|inb
argument_list|(
literal|0x3C1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3C0
argument_list|,
name|save2
argument_list|)
expr_stmt|;
if|if
condition|(
name|save3
operator|==
operator|(
name|save2
operator|^
literal|0x10
operator|)
condition|)
block|{
comment|/* assume it is a Tseng, but which one */
name|outb
argument_list|(
name|iobase
operator|+
literal|4
argument_list|,
literal|0x23
argument_list|)
expr_stmt|;
name|save2
operator|=
name|inb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|,
name|save2
operator|^
literal|0x07
argument_list|)
expr_stmt|;
name|save3
operator|=
name|inb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|,
name|save2
argument_list|)
expr_stmt|;
if|if
condition|(
name|save3
operator|==
operator|(
name|save2
operator|^
literal|0x07
operator|)
condition|)
block|{
name|vds
operator|.
name|ram
operator|=
literal|512
expr_stmt|;
name|vds
operator|.
name|cardtype
operator|=
name|VG_ET3000
expr_stmt|;
block|}
else|else
block|{
comment|/* same experiment for reg 33 */
name|outb
argument_list|(
name|iobase
operator|+
literal|4
argument_list|,
literal|0x33
argument_list|)
expr_stmt|;
name|save2
operator|=
name|inb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|,
name|save2
operator|^
literal|0x0f
argument_list|)
expr_stmt|;
name|save3
operator|=
name|inb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|,
name|save2
argument_list|)
expr_stmt|;
if|if
condition|(
name|save3
operator|==
operator|(
name|save2
operator|^
literal|0x0f
operator|)
condition|)
block|{
name|vds
operator|.
name|cardtype
operator|=
name|VG_ET4000
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|4
argument_list|,
literal|0x37
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|)
operator|&
literal|03
condition|)
block|{
case|case
literal|1
case|:
name|vds
operator|.
name|ram
operator|=
literal|256
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|vds
operator|.
name|ram
operator|=
literal|512
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|vds
operator|.
name|ram
operator|=
literal|1024
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* cleanup for TSENG */
name|outb
argument_list|(
literal|0x3bf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|8
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vds
operator|.
name|cardtype
operator|!=
name|VG_VGA
condition|)
return|return;
comment|/* now look for the GENOAs */
name|cp
operator|=
name|videobios
operator|+
literal|0x37
expr_stmt|;
name|cp
operator|+=
operator|(
name|u_char
operator|)
operator|*
name|cp
expr_stmt|;
comment|/* at 0x37 is the offset to the real signature */
if|if
condition|(
operator|*
name|cp
operator|==
literal|0x77
operator|&&
operator|*
operator|(
name|cp
operator|+
literal|2
operator|)
operator|==
literal|0x66
operator|&&
operator|*
operator|(
name|cp
operator|+
literal|3
operator|)
operator|==
literal|0x99
condition|)
block|{
comment|/* this is a GENOA. Note that the GENOAs 5xxx are  		 * really TSENG ET3000, so they should have fallen  		 * through the sieve above already, if not, something's  		 * quite strange here, so I don't believe its a GENOA 		 */
name|vds
operator|.
name|cardtype
operator|=
name|VG_GENOA
expr_stmt|;
name|vds
operator|.
name|cardsubtype
operator|=
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|vds
operator|.
name|cardsubtype
condition|)
block|{
default|default:
case|case
literal|0x33
case|:
comment|/* shouldn't reach this */
case|case
literal|0x55
case|:
name|vds
operator|.
name|cardtype
operator|=
name|VG_VGA
expr_stmt|;
return|return;
case|case
literal|0x22
case|:
case|case
literal|0x00
case|:
name|vds
operator|.
name|ram
operator|=
literal|256
expr_stmt|;
return|return;
case|case
literal|0x11
case|:
name|vds
operator|.
name|ram
operator|=
literal|512
expr_stmt|;
return|return;
block|}
comment|/*NOTREACHED*/
block|}
comment|/* 	 * Look for the Tridents 	 */
name|outb
argument_list|(
literal|0x3c4
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
name|save1
operator|=
name|inb
argument_list|(
literal|0x3c5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3c5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|save2
operator|=
name|inb
argument_list|(
literal|0x3c5
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
name|outb
argument_list|(
literal|0x3c5
argument_list|,
name|save1
operator|^
literal|0x02
argument_list|)
expr_stmt|;
if|if
condition|(
name|save2
operator|==
literal|0x02
condition|)
block|{
comment|/* is a Trident */
name|vds
operator|.
name|cardtype
operator|=
name|VG_TVGA
expr_stmt|;
name|outb
argument_list|(
literal|0x3c4
argument_list|,
literal|0x0b
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3c5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|save1
operator|=
name|inb
argument_list|(
literal|0x3c5
argument_list|)
expr_stmt|;
comment|/* restore "old mode", recommended by  		 * chmr@edvz.tu-graz.ac.at (Christoph Robitschko)  		 */
name|outb
argument_list|(
literal|0x3c5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vds
operator|.
name|cardsubtype
operator|=
name|save1
expr_stmt|;
if|if
condition|(
name|save1
operator|==
literal|0xfd
condition|)
comment|/*TVGA 9000*/
name|vds
operator|.
name|ram
operator|=
literal|1024
expr_stmt|;
else|else
name|vds
operator|.
name|ram
operator|=
literal|512
expr_stmt|;
comment|/* There is 3c4/1f, but I don't know the encoding */
return|return;
block|}
comment|/* for the moment X11 does not know any more chips, but 	 * I found some more in Ferraro's book 	 * 	 * Video 7  	 */
name|outw
argument_list|(
literal|0x3c4
argument_list|,
literal|0xea06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|4
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
name|save1
operator|=
name|inb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
name|save2
operator|=
name|inb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|4
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
name|save3
operator|=
name|inb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|4
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
literal|5
argument_list|,
name|save1
argument_list|)
expr_stmt|;
if|if
condition|(
name|save3
operator|==
operator|(
literal|0x55
operator|^
literal|0xea
operator|)
condition|)
block|{
comment|/* this is a video 7 */
name|vds
operator|.
name|cardtype
operator|=
name|VG_VIDEO7
expr_stmt|;
name|outb
argument_list|(
literal|0x3c4
argument_list|,
literal|0x8e
argument_list|)
expr_stmt|;
name|vds
operator|.
name|cardsubtype
operator|=
name|inb
argument_list|(
literal|0x3c5
argument_list|)
expr_stmt|;
if|if
condition|(
name|vds
operator|.
name|cardsubtype
operator|>
literal|0x40
operator|&&
name|vds
operator|.
name|cardsubtype
operator|<
literal|0x4a
condition|)
name|vds
operator|.
name|ram
operator|=
literal|1024
expr_stmt|;
comment|/* 1024i */
else|else
name|vds
operator|.
name|ram
operator|=
literal|512
expr_stmt|;
return|return;
block|}
comment|/* C&T Chips, I'm not sure about that, in particular the 	 * strange 46E8 port, I somewhere  heard that I/O space is  	 * 0000-03FF only, but I don't know whether any chipset 	 * clips this range. Anyway... 	 */
name|outb
argument_list|(
literal|0x46e8
argument_list|,
literal|0x1e
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
literal|0x104
argument_list|)
operator|==
literal|0xa5
condition|)
block|{
name|outb
argument_list|(
literal|0x103
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x46e8
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3d6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vds
operator|.
name|cardtype
operator|=
name|VG_CHIPS
expr_stmt|;
name|vds
operator|.
name|cardsubtype
operator|=
name|inb
argument_list|(
literal|0x3d7
argument_list|)
operator|&
literal|0xf0
expr_stmt|;
switch|switch
condition|(
name|vds
operator|.
name|cardsubtype
condition|)
block|{
case|case
literal|0x10
case|:
name|outb
argument_list|(
literal|0x3d6
argument_list|,
literal|0x3a
argument_list|)
expr_stmt|;
name|save1
operator|=
name|inb
argument_list|(
literal|0x3d7
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3d7
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|save2
operator|=
name|inb
argument_list|(
literal|0x3d7
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3d7
argument_list|,
name|save1
argument_list|)
expr_stmt|;
if|if
condition|(
name|save2
operator|==
literal|0xaa
condition|)
block|{
name|vds
operator|.
name|cardsubtype
operator|=
literal|0x11
expr_stmt|;
name|vds
operator|.
name|ram
operator|=
literal|1024
expr_stmt|;
block|}
else|else
name|vds
operator|.
name|ram
operator|=
literal|256
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
name|vds
operator|.
name|ram
operator|=
literal|256
expr_stmt|;
break|break;
case|case
literal|0x30
case|:
name|vds
operator|.
name|ram
operator|=
literal|1024
expr_stmt|;
break|break;
case|case
literal|0x50
case|:
name|vds
operator|.
name|ram
operator|=
literal|256
expr_stmt|;
block|}
name|outb
argument_list|(
literal|0x46e8
argument_list|,
literal|0x1e
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x103
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
literal|0x46e8
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
comment|/* the two ATI's */
name|cp
operator|=
name|videobios
operator|+
literal|0x0031
expr_stmt|;
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|cp
argument_list|,
literal|"761295520"
argument_list|,
literal|9
argument_list|)
condition|)
block|{
comment|/* is an ATI, also unsure about the numbers */
name|vds
operator|.
name|cardtype
operator|=
name|VG_ATI
expr_stmt|;
name|cp
operator|=
name|videobios
operator|+
literal|0x0042
expr_stmt|;
name|vds
operator|.
name|cardsubtype
operator|=
operator|*
name|cp
operator||
operator|(
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|vp
operator|=
operator|(
name|u_short
operator|*
operator|)
name|videobios
operator|+
literal|0010
expr_stmt|;
name|vds
operator|.
name|_atiext
operator|=
operator|*
name|vp
expr_stmt|;
name|outb
argument_list|(
operator|*
name|vp
argument_list|,
literal|0xbb
argument_list|)
expr_stmt|;
name|save1
operator|=
name|inb
argument_list|(
operator|(
operator|*
name|vp
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|vds
operator|.
name|ram
operator|=
operator|(
name|save1
operator|&
literal|0x20
operator|)
condition|?
literal|512
else|:
literal|256
expr_stmt|;
return|return;
block|}
comment|/* I don't know more types, so assume  	 * it is a VGA (at least looks as if)  	 */
name|vds
operator|.
name|ram
operator|=
literal|256
expr_stmt|;
name|vds
operator|.
name|cardtype
operator|=
name|VG_VGA
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|card2name
parameter_list|(
name|int
name|id
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|nametable
index|[]
init|=
block|{
comment|/* 0 */
literal|"UNKNOWN"
block|,
comment|/* 1 */
literal|"MDA/Hercules"
block|,
comment|/* 2 */
literal|"CGA"
block|,
comment|/* 3 */
literal|"EGA"
block|,
comment|/* 4 */
literal|"VGA"
block|,
comment|/* 5 */
literal|"C&T"
block|,
comment|/* 6 */
literal|"Genoa VGA"
block|,
comment|/* 7 */
literal|"Paradise VGA"
block|,
comment|/* 8 */
literal|"Trident VGA"
block|,
comment|/* 9 */
literal|"Tseng ET3000"
block|,
comment|/* 10 */
literal|"Tseng ET4000"
block|,
comment|/* 11 */
literal|"Video7 VGA"
block|,
comment|/* 12 */
literal|"ATI VGA"
block|,
literal|0
block|, 	}
decl_stmt|;
return|return
name|nametable
index|[
name|id
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * set cursor shape  */
end_comment

begin_function
name|int
name|vga_setcshape
parameter_list|(
name|struct
name|cursorshape
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|s
operator|,
name|e
expr_stmt|;
name|s
operator|=
name|data
operator|->
name|start
expr_stmt|;
name|e
operator|=
name|data
operator|->
name|end
expr_stmt|;
comment|/* I don't do error correction here, the user should pass  	 * correct and checked data! Note: The registers allow 5 Bits == 31 	 */
if|if
condition|(
name|s
operator|<
literal|0
operator|||
name|s
operator|>
literal|31
operator|||
name|e
operator|<
literal|0
operator|||
name|e
operator|>
literal|31
condition|)
return|return
name|EINVAL
return|;
comment|/* the Tridents seem to have the feature to switch off 	 * cursor when start is 0 (not verified) 	 */
if|if
condition|(
name|vds
operator|.
name|cardtype
operator|==
name|VG_TVGA
operator|&&
name|s
operator|==
literal|0
condition|)
name|s
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|vds
operator|.
name|iobase
operator|+
literal|4
argument_list|,
name|M6845_CURSTART
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|vds
operator|.
name|iobase
operator|+
literal|5
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|vds
operator|.
name|iobase
operator|+
literal|4
argument_list|,
name|M6845_CUREND
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|vds
operator|.
name|iobase
operator|+
literal|5
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MINITERM
end_ifndef

begin_function
name|int
name|vga_getcshape
parameter_list|(
name|struct
name|cursorshape
modifier|*
name|data
parameter_list|)
block|{
comment|/* update from registers */
name|outb
argument_list|(
name|vds
operator|.
name|iobase
operator|+
literal|4
argument_list|,
name|M6845_CURSTART
argument_list|)
expr_stmt|;
name|data
operator|->
name|start
operator|=
name|inb
argument_list|(
name|vds
operator|.
name|iobase
operator|+
literal|5
argument_list|)
operator|&
literal|0x1F
expr_stmt|;
name|outb
argument_list|(
name|vds
operator|.
name|iobase
operator|+
literal|4
argument_list|,
name|M6845_CUREND
argument_list|)
expr_stmt|;
name|data
operator|->
name|end
operator|=
name|inb
argument_list|(
name|vds
operator|.
name|iobase
operator|+
literal|5
argument_list|)
operator|&
literal|0x1F
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|vga_getvideoinfo
parameter_list|(
name|struct
name|videoinfo
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bcopy
argument_list|(
name|card2name
argument_list|(
name|vds
operator|.
name|cardtype
argument_list|)
argument_list|,
name|data
operator|->
name|name
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|data
operator|->
name|type
operator|=
name|vds
operator|.
name|cardtype
expr_stmt|;
name|data
operator|->
name|subtype
operator|=
name|vds
operator|.
name|cardsubtype
expr_stmt|;
name|data
operator|->
name|ram
operator|=
name|vds
operator|.
name|ram
expr_stmt|;
name|data
operator|->
name|iobase
operator|=
name|vds
operator|.
name|iobase
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|modesave
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|vga_enablecg
parameter_list|()
block|{
specifier|register
name|iobase
operator|=
name|vds
operator|.
name|iobase
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|iobase
operator|+
literal|10
argument_list|)
operator|&
literal|0x08
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* wait for vertical blanking */
name|inb
argument_list|(
name|iobase
operator|+
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3C0
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|modesave
operator|=
name|inb
argument_list|(
literal|0x3C1
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|iobase
operator|+
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3C0
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3C0
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* graphics mode */
comment|/*	outw(0x3c4,0x0100);*/
comment|/* hold sequencer synch reset */
name|outw
argument_list|(
literal|0x3c4
argument_list|,
literal|0x0402
argument_list|)
expr_stmt|;
comment|/* write enable map "page" */
name|outw
argument_list|(
literal|0x3c4
argument_list|,
literal|0x0604
argument_list|)
expr_stmt|;
comment|/* set sequential addressing */
comment|/*	outw(0x3c4,0x0300);*/
comment|/* release sequencer synch reset */
name|outw
argument_list|(
literal|0x3ce
argument_list|,
literal|0x0204
argument_list|)
expr_stmt|;
comment|/* select map "page" for cpu reading */
name|outw
argument_list|(
literal|0x3ce
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
comment|/* RM=0,O/E=0,WM=00 */
name|outw
argument_list|(
literal|0x3ce
argument_list|,
literal|0x0d06
argument_list|)
expr_stmt|;
comment|/* map at "B8000" */
block|}
end_function

begin_function
name|void
name|vga_disablecg
parameter_list|()
block|{
specifier|register
name|iobase10
operator|=
name|vds
operator|.
name|iobase
operator|+
literal|10
expr_stmt|;
name|char
name|seq
decl_stmt|;
name|inb
argument_list|(
name|iobase10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3C0
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3C0
argument_list|,
name|modesave
argument_list|)
expr_stmt|;
comment|/* alpha mode */
comment|/*	outw(0x3c4,0x0100);*/
comment|/* hold sequencer synch reset */
name|outw
argument_list|(
literal|0x3c4
argument_list|,
literal|0x0302
argument_list|)
expr_stmt|;
comment|/* write enable text pages */
name|outw
argument_list|(
literal|0x3c4
argument_list|,
literal|0x0304
argument_list|)
expr_stmt|;
comment|/* set O/E addressing */
comment|/*	outw(0x3c4,0x0300);*/
comment|/* release sequencer synch reset */
name|outw
argument_list|(
literal|0x3ce
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
comment|/* select map 0 for cpu reading */
name|outw
argument_list|(
literal|0x3ce
argument_list|,
literal|0x1005
argument_list|)
expr_stmt|;
comment|/* RM=0,O/E=0,WM=00 */
name|outw
argument_list|(
literal|0x3ce
argument_list|,
literal|0x0e06
argument_list|)
expr_stmt|;
comment|/* map at "B8000", Chain O/E */
comment|/* set the 8/9 bit according to the state of vds.f89  	 * The little problem is that with a EGA we have to guess 	 * the old value (but it is usually 0x03) 	 */
if|if
condition|(
name|vds
operator|.
name|cardtype
operator|!=
name|VG_EGA
condition|)
block|{
name|inb
argument_list|(
name|iobase10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3c0
argument_list|,
literal|0x20
operator||
literal|0x10
argument_list|)
expr_stmt|;
name|seq
operator|=
name|inb
argument_list|(
literal|0x3c1
argument_list|)
expr_stmt|;
block|}
else|else
name|seq
operator|=
literal|0x03
expr_stmt|;
name|inb
argument_list|(
name|iobase10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3c0
argument_list|,
literal|0x20
operator||
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|vds
operator|.
name|f89bit
operator|==
literal|9
condition|)
name|outb
argument_list|(
literal|0x3c0
argument_list|,
name|seq
operator||
literal|0x04
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
literal|0x3c0
argument_list|,
name|seq
operator|&
operator|~
literal|0x04
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|iobase10
argument_list|)
operator|&
literal|0x08
condition|)
empty_stmt|;
comment|/* wait for end of vertical blanking */
block|}
end_function

begin_decl_stmt
specifier|static
name|u_char
name|iso2pc8
index|[]
init|=
block|{
comment|/*A0*/
literal|0xff
block|,
literal|0xad
block|,
literal|0x9b
block|,
literal|0x9c
block|,
literal|0xfe
block|,
literal|0x9d
block|,
literal|0x7c
block|,
literal|0x15
block|,
comment|/*A8*/
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xa6
block|,
literal|0xae
block|,
literal|0xaa
block|,
literal|0x2d
block|,
literal|0xfe
block|,
literal|0xfe
block|,
comment|/*B0*/
literal|0xf8
block|,
literal|0xf1
block|,
literal|0xfd
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xe6
block|,
literal|0x14
block|,
literal|0xf9
block|,
comment|/*B8*/
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xa7
block|,
literal|0xaf
block|,
literal|0xac
block|,
literal|0xfd
block|,
literal|0xfe
block|,
literal|0xa8
block|,
comment|/*C0*/
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0x8e
block|,
literal|0x8f
block|,
literal|0x92
block|,
literal|0x80
block|,
comment|/*C8*/
literal|0xfe
block|,
literal|0x90
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xfe
block|,
comment|/*D0*/
literal|0xfe
block|,
literal|0xa5
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0x99
block|,
literal|0xfe
block|,
comment|/*D8*/
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0x9a
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xe1
block|,
comment|/*E0*/
literal|0x85
block|,
literal|0xa0
block|,
literal|0x83
block|,
literal|0xfe
block|,
literal|0x84
block|,
literal|0x86
block|,
literal|0x91
block|,
literal|0x87
block|,
comment|/*E8*/
literal|0x8a
block|,
literal|0x82
block|,
literal|0x88
block|,
literal|0x89
block|,
literal|0x8d
block|,
literal|0xa1
block|,
literal|0x8c
block|,
literal|0x8b
block|,
comment|/*F0*/
literal|0xfe
block|,
literal|0xa4
block|,
literal|0x95
block|,
literal|0xa2
block|,
literal|0x93
block|,
literal|0xfe
block|,
literal|0x94
block|,
literal|0xf6
block|,
comment|/*F8*/
literal|0xfe
block|,
literal|0x97
block|,
literal|0xa3
block|,
literal|0x96
block|,
literal|0x81
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0x98
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* needs attribute byte to select font */
end_comment

begin_function
name|int
name|vga_xlatiso646
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|u_short
modifier|*
name|at
parameter_list|,
name|u_short
modifier|*
name|sat
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|int
name|f2flag
init|=
name|vp
operator|->
name|op
operator|->
name|f2
decl_stmt|;
if|if
condition|(
name|vds
operator|.
name|encoding
index|[
literal|1
index|]
operator|!=
name|NOFONT
condition|)
block|{
comment|/* second font loaded? */
if|if
condition|(
name|f2flag
condition|)
block|{
operator|*
name|at
operator||=
literal|0x08
expr_stmt|;
comment|/* select font 2 */
operator|*
name|sat
operator||=
literal|0x08
expr_stmt|;
block|}
else|else
block|{
operator|*
name|at
operator|&=
literal|0xF7
expr_stmt|;
operator|*
name|sat
operator|&=
literal|0xF7
expr_stmt|;
block|}
block|}
else|else
name|f2flag
operator|=
literal|0
expr_stmt|;
comment|/* ignore font switch */
comment|/* need to translate character? */
if|if
condition|(
name|f2flag
operator|==
literal|0
operator|&&
name|vds
operator|.
name|encoding
index|[
literal|0
index|]
operator|==
name|XLAT2PC8
condition|)
return|return
operator|(
name|c
operator|<
literal|0xa0
operator|)
condition|?
name|c
else|:
name|iso2pc8
index|[
name|c
operator|-
literal|0xa0
index|]
return|;
else|else
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************  * Support functions for the terminal emulator  **********************************************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GFX_CONSOLE
end_ifndef

begin_comment
comment|/*  *	moves the cursor up  n  lines  */
end_comment

begin_function
name|void
name|vga_cursorup
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|register
name|pos
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|pos
operator|=
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
expr_stmt|;
name|pos
operator|-=
name|vp
operator|->
name|ncol
operator|*
name|n
expr_stmt|;
name|vp
operator|->
name|row
operator|--
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|pos
operator|+=
name|vp
operator|->
name|size
expr_stmt|;
name|vp
operator|->
name|row
operator|=
name|vp
operator|->
name|nrow
operator|-
literal|1
expr_stmt|;
block|}
name|vp
operator|->
name|crtat
operator|=
name|vp
operator|->
name|Crtat
operator|+
name|pos
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	moves the cursor down  n  lines  */
end_comment

begin_function
name|void
name|vga_cursordown
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|register
name|pos
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|pos
operator|=
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
expr_stmt|;
name|pos
operator|+=
name|vp
operator|->
name|ncol
operator|*
name|n
expr_stmt|;
name|vp
operator|->
name|row
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|vp
operator|->
name|size
condition|)
block|{
name|pos
operator|-=
name|vp
operator|->
name|size
expr_stmt|;
name|vp
operator|->
name|row
operator|=
literal|0
expr_stmt|;
block|}
name|vp
operator|->
name|crtat
operator|=
name|vp
operator|->
name|Crtat
operator|+
name|pos
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * moves the cursor left  n  columns  */
end_comment

begin_function
name|void
name|vga_cursorleft
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|register
name|pos
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|pos
operator|=
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
expr_stmt|;
name|pos
operator|-=
name|n
expr_stmt|;
name|vp
operator|->
name|col
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|col
operator|<
literal|0
condition|)
block|{
name|vp
operator|->
name|col
operator|+=
name|vp
operator|->
name|ncol
expr_stmt|;
name|pos
operator|+=
name|vp
operator|->
name|ncol
expr_stmt|;
comment|/* cursor stays on same line */
block|}
name|vp
operator|->
name|crtat
operator|=
name|vp
operator|->
name|Crtat
operator|+
name|pos
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * moves the cursor right  n  columns  * wrap=1: cursor stays on same line  */
end_comment

begin_function
name|void
name|vga_cursorright
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|wrap
parameter_list|)
block|{
specifier|register
name|pos
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|pos
operator|=
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
expr_stmt|;
name|pos
operator|+=
name|n
expr_stmt|;
name|vp
operator|->
name|col
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|wrap
operator|&&
name|vp
operator|->
name|col
operator|>=
name|vp
operator|->
name|ncol
condition|)
block|{
name|vp
operator|->
name|col
operator|-=
name|vp
operator|->
name|ncol
expr_stmt|;
name|pos
operator|-=
name|vp
operator|->
name|ncol
expr_stmt|;
comment|/* cursor stays on same line */
block|}
name|vp
operator|->
name|crtat
operator|=
name|vp
operator|->
name|Crtat
operator|+
operator|(
name|pos
operator|%
name|vp
operator|->
name|size
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * scrollup n lines and fill free space with default attribute  * cm = 1: also move cursor  */
end_comment

begin_function
name|void
name|vga_scrollup
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|cm
parameter_list|)
block|{
name|u_short
name|attr
init|=
name|vp
operator|->
name|op
operator|->
name|def_at
decl_stmt|;
name|int
name|blkx
decl_stmt|,
name|blky
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|blkx
operator|=
name|vp
operator|->
name|ncol
operator|*
name|n
expr_stmt|;
name|blky
operator|=
name|vp
operator|->
name|size
operator|-
name|blkx
expr_stmt|;
name|bcopy
argument_list|(
name|vp
operator|->
name|Crtat
operator|+
name|blkx
argument_list|,
name|vp
operator|->
name|Crtat
argument_list|,
name|blky
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
operator|(
name|attr
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|vp
operator|->
name|Crtat
operator|+
name|blky
argument_list|,
name|blkx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
condition|)
block|{
name|vp
operator|->
name|crtat
operator|-=
name|blkx
expr_stmt|;
name|vp
operator|->
name|row
operator|-=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MINITERM
end_ifndef

begin_comment
comment|/*   * scroll down n lines and fill free space with default attribute  */
end_comment

begin_function
name|void
name|vga_scrolldown
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|u_short
name|attr
init|=
name|vp
operator|->
name|op
operator|->
name|def_at
decl_stmt|;
name|int
name|blkx
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|blkx
operator|=
name|vp
operator|->
name|ncol
operator|*
name|n
expr_stmt|;
name|bcopy
argument_list|(
name|vp
operator|->
name|Crtat
argument_list|,
name|vp
operator|->
name|Crtat
operator|+
name|blkx
argument_list|,
operator|(
name|vp
operator|->
name|size
operator|-
name|blkx
operator|)
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
operator|(
name|attr
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|vp
operator|->
name|Crtat
argument_list|,
name|blkx
argument_list|)
expr_stmt|;
comment|/* XXX vp->crtat += blkx; */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!MINITERM*/
end_comment

begin_comment
comment|/*  * set the absolute cursor position (row,col = 0..max)  */
end_comment

begin_function
name|void
name|vga_cursormove
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|col
parameter_list|)
block|{
if|if
condition|(
name|row
operator|==
literal|0
operator|||
name|col
operator|==
literal|0
condition|)
block|{
name|vp
operator|->
name|crtat
operator|=
name|vp
operator|->
name|Crtat
expr_stmt|;
name|vp
operator|->
name|row
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|col
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|col
operator|<=
name|vp
operator|->
name|ncol
operator|&&
name|row
operator|<=
name|vp
operator|->
name|nrow
condition|)
block|{
name|vp
operator|->
name|crtat
operator|=
name|vp
operator|->
name|Crtat
operator|+
operator|(
name|row
operator|-
literal|1
operator|)
operator|*
name|vp
operator|->
name|ncol
operator|+
name|col
operator|-
literal|1
expr_stmt|;
name|vp
operator|->
name|col
operator|=
name|col
operator|-
literal|1
expr_stmt|;
name|vp
operator|->
name|row
operator|=
name|row
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * cursorrelative: move cursor relative, don't check for outside of screen  */
end_comment

begin_function
name|void
name|vga_cursorrelative
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
name|int
name|incr
init|=
name|dy
operator|*
name|vp
operator|->
name|ncol
operator|+
name|dx
decl_stmt|;
name|int
name|pos
init|=
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
decl_stmt|;
comment|/*	if ((pos+incr)< 0 || (pos+incr)>= vp->size)  		return; */
name|vp
operator|->
name|crtat
operator|+=
name|incr
expr_stmt|;
name|vp
operator|->
name|col
operator|=
operator|(
name|vp
operator|->
name|col
operator|+
name|dx
operator|)
operator|%
name|vp
operator|->
name|ncol
expr_stmt|;
name|vp
operator|->
name|row
operator|=
operator|(
name|vp
operator|->
name|row
operator|+
name|dy
operator|)
operator|%
name|vp
operator|->
name|nrow
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear screen with default attr  * mode = 0: from cursor to end of screen  *      = 1: cursor position only  *	= 2: whole display  */
end_comment

begin_function
name|void
name|vga_clearcursor
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|u_short
name|attr
init|=
operator|(
name|vp
operator|->
name|op
operator|->
name|def_at
operator|<<
literal|8
operator|)
operator||
literal|' '
decl_stmt|;
comment|/* clear ... */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* ... to end of display */
name|fillw
argument_list|(
name|attr
argument_list|,
name|vp
operator|->
name|crtat
argument_list|,
name|vp
operator|->
name|Crtat
operator|+
name|vp
operator|->
name|size
operator|-
name|vp
operator|->
name|crtat
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* ... to next location */
name|fillw
argument_list|(
name|attr
argument_list|,
name|vp
operator|->
name|Crtat
argument_list|,
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* ... whole display */
name|fillw
argument_list|(
name|attr
argument_list|,
name|vp
operator|->
name|Crtat
argument_list|,
name|vp
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clear line and fill with default attr  * mode = 0: from cursor to end of line  * 	= 1: from beginning to cursor  *	= 2: whole line  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MINITERM
end_ifndef

begin_function
name|void
name|vga_clearline
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|u_short
name|attr
init|=
operator|(
name|vp
operator|->
name|op
operator|->
name|def_at
operator|<<
literal|8
operator|)
operator||
literal|' '
decl_stmt|;
comment|/* clear ... */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* ... current to EOL */
name|fillw
argument_list|(
name|attr
argument_list|,
name|vp
operator|->
name|crtat
argument_list|,
name|vp
operator|->
name|ncol
operator|-
operator|(
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
operator|)
operator|%
name|vp
operator|->
name|ncol
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* ... beginning to next */
name|fillw
argument_list|(
name|attr
argument_list|,
name|vp
operator|->
name|crtat
operator|-
operator|(
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
operator|)
operator|%
name|vp
operator|->
name|ncol
argument_list|,
operator|(
operator|(
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
operator|)
operator|%
name|vp
operator|->
name|ncol
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* ... entire line */
name|fillw
argument_list|(
name|attr
argument_list|,
name|vp
operator|->
name|crtat
operator|-
operator|(
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
operator|)
operator|%
name|vp
operator|->
name|ncol
argument_list|,
name|vp
operator|->
name|ncol
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * delete n lines from cursor position to end, pull up lines with default attr  */
end_comment

begin_function
name|void
name|vga_deleteline
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|u_short
modifier|*
name|crtend
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|u_short
name|attr
init|=
operator|(
name|vp
operator|->
name|op
operator|->
name|def_at
operator|<<
literal|8
operator|)
operator||
literal|' '
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
comment|/* Work from beginning of line */
name|vp
operator|->
name|crtat
operator|-=
operator|(
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
operator|)
operator|%
name|vp
operator|->
name|ncol
expr_stmt|;
name|vp
operator|->
name|col
operator|=
literal|0
expr_stmt|;
name|crtend
operator|=
name|vp
operator|->
name|Crtat
operator|+
name|vp
operator|->
name|size
expr_stmt|;
comment|/* Cap affected area at bottom of screen */
if|if
condition|(
operator|(
name|pp
operator|=
operator|(
name|vp
operator|->
name|crtat
operator|+
name|n
operator|*
name|vp
operator|->
name|ncol
operator|)
operator|)
operator|>
name|crtend
condition|)
block|{
name|n
operator|=
operator|(
name|crtend
operator|-
name|vp
operator|->
name|crtat
operator|)
operator|/
name|vp
operator|->
name|ncol
expr_stmt|;
name|pp
operator|=
name|crtend
expr_stmt|;
block|}
comment|/* If there's visible lines left, move them up */
if|if
condition|(
name|pp
operator|<
name|crtend
condition|)
block|{
name|bcopy
argument_list|(
name|pp
argument_list|,
name|vp
operator|->
name|crtat
argument_list|,
operator|(
name|crtend
operator|-
name|pp
operator|)
operator|*
name|CHR
argument_list|)
expr_stmt|;
block|}
name|fillw
argument_list|(
name|attr
argument_list|,
name|crtend
operator|-
name|n
operator|*
name|vp
operator|->
name|ncol
argument_list|,
name|n
operator|*
name|vp
operator|->
name|ncol
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * insert n lines from cursor position to end, fill with default attr  */
end_comment

begin_function
name|void
name|vga_insertline
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|u_short
modifier|*
name|crtend
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|u_short
name|attr
init|=
operator|(
name|vp
operator|->
name|op
operator|->
name|def_at
operator|<<
literal|8
operator|)
operator||
literal|' '
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
comment|/* Work from beginning of line */
name|vp
operator|->
name|crtat
operator|-=
operator|(
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
operator|)
operator|%
name|vp
operator|->
name|ncol
expr_stmt|;
name|vp
operator|->
name|col
operator|=
literal|0
expr_stmt|;
name|crtend
operator|=
name|vp
operator|->
name|Crtat
operator|+
name|vp
operator|->
name|size
expr_stmt|;
comment|/* Cap affected area at bottom of screen */
if|if
condition|(
operator|(
name|pp
operator|=
operator|(
name|vp
operator|->
name|crtat
operator|+
name|n
operator|*
name|vp
operator|->
name|ncol
operator|)
operator|)
operator|>
name|crtend
condition|)
block|{
name|n
operator|=
operator|(
name|crtend
operator|-
name|vp
operator|->
name|crtat
operator|)
operator|/
name|vp
operator|->
name|ncol
expr_stmt|;
name|pp
operator|=
name|crtend
expr_stmt|;
block|}
comment|/* If there's visible lines left, move them down */
if|if
condition|(
name|pp
operator|<
name|crtend
condition|)
block|{
name|bcopy
argument_list|(
name|vp
operator|->
name|crtat
argument_list|,
name|pp
argument_list|,
operator|(
name|crtend
operator|-
name|pp
operator|)
operator|*
name|CHR
argument_list|)
expr_stmt|;
block|}
name|fillw
argument_list|(
name|attr
argument_list|,
name|vp
operator|->
name|crtat
argument_list|,
name|n
operator|*
name|vp
operator|->
name|ncol
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete n chars in line, fill free space with default attr  */
end_comment

begin_function
name|void
name|vga_deletechars
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|u_short
modifier|*
name|crtend
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|u_short
name|attr
init|=
operator|(
name|vp
operator|->
name|op
operator|->
name|def_at
operator|<<
literal|8
operator|)
operator||
literal|' '
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
comment|/* Point to end of current line */
name|pp
operator|=
name|vp
operator|->
name|crtat
operator|+
operator|(
name|vp
operator|->
name|ncol
operator|-
operator|(
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
operator|)
operator|%
name|vp
operator|->
name|ncol
operator|)
expr_stmt|;
comment|/* Cap delete to end of current line */
if|if
condition|(
operator|(
name|vp
operator|->
name|crtat
operator|+
name|n
operator|)
operator|>
name|pp
condition|)
name|n
operator|=
name|pp
operator|-
name|vp
operator|->
name|crtat
expr_stmt|;
comment|/* If visible characters, move in */
if|if
condition|(
operator|(
name|vp
operator|->
name|crtat
operator|+
name|n
operator|)
operator|<
name|pp
condition|)
name|bcopy
argument_list|(
name|vp
operator|->
name|crtat
operator|+
name|n
argument_list|,
name|vp
operator|->
name|crtat
argument_list|,
operator|(
operator|(
name|pp
operator|-
name|vp
operator|->
name|crtat
operator|)
operator|-
name|n
operator|)
operator|*
name|CHR
argument_list|)
expr_stmt|;
comment|/* Blank out space at end of line */
name|fillw
argument_list|(
name|attr
argument_list|,
name|pp
operator|-
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete n chars in line, fill free space with default attr  */
end_comment

begin_function
name|void
name|vga_insertchars
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|u_short
modifier|*
name|crtend
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|u_short
name|attr
init|=
operator|(
name|vp
operator|->
name|op
operator|->
name|def_at
operator|<<
literal|8
operator|)
operator||
literal|' '
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
comment|/* Point to end of current line */
name|pp
operator|=
name|vp
operator|->
name|crtat
operator|+
operator|(
name|vp
operator|->
name|ncol
operator|-
operator|(
name|vp
operator|->
name|crtat
operator|-
name|vp
operator|->
name|Crtat
operator|)
operator|%
name|vp
operator|->
name|ncol
operator|)
expr_stmt|;
comment|/* Cap insert to end of current line */
if|if
condition|(
operator|(
name|vp
operator|->
name|crtat
operator|+
name|n
operator|)
operator|>
name|pp
condition|)
name|n
operator|=
name|pp
operator|-
name|vp
operator|->
name|crtat
expr_stmt|;
comment|/* If visible characters, move out */
if|if
condition|(
operator|(
name|vp
operator|->
name|crtat
operator|)
operator|<
name|pp
condition|)
name|bcopy
argument_list|(
name|vp
operator|->
name|crtat
argument_list|,
name|vp
operator|->
name|crtat
operator|+
name|n
argument_list|,
operator|(
operator|(
name|pp
operator|-
name|vp
operator|->
name|crtat
operator|)
operator|-
name|n
operator|)
operator|*
name|CHR
argument_list|)
expr_stmt|;
comment|/* Blank out space at new positions */
name|fillw
argument_list|(
name|attr
argument_list|,
name|vp
operator|->
name|crtat
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!MINITERM*/
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|fgansitopc
index|[]
init|=
block|{
name|FG_BLACK
block|,
name|FG_RED
block|,
name|FG_GREEN
block|,
name|FG_BROWN
block|,
name|FG_BLUE
block|,
name|FG_MAGENTA
block|,
name|FG_CYAN
block|,
name|FG_LIGHTGREY
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|bgansitopc
index|[]
init|=
block|{
name|BG_BLACK
block|,
name|BG_RED
block|,
name|BG_GREEN
block|,
name|BG_BROWN
block|,
name|BG_BLUE
block|,
name|BG_MAGENTA
block|,
name|BG_CYAN
block|,
name|BG_LIGHTGREY
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * set attributes  * mode = 0: reset normal attributes, attr=0: std, attr=1: kernel  * mode = 1: set ansi color background  * mode = 2: set ansi color foreground  * mode = 3: set PC attribute  * mode = 4: reset standout attributes (extension!)  */
end_comment

begin_function
name|void
name|vga_setattributes
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|attr
parameter_list|)
block|{
name|struct
name|outmode
modifier|*
name|o
init|=
name|vp
operator|->
name|op
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* reset to normal attributes */
if|if
condition|(
name|o
operator|==
operator|&
name|vp
operator|->
name|om
index|[
literal|0
index|]
condition|)
block|{
comment|/* std */
name|o
operator|->
name|fg_at
operator|=
name|vds
operator|.
name|color
condition|?
name|DEF_STD_C_FGAT
else|:
name|DEF_STD_M_FGAT
expr_stmt|;
name|o
operator|->
name|bg_at
operator|=
name|DEF_STD_BGAT
expr_stmt|;
block|}
else|else
block|{
comment|/* kernel */
name|o
operator|->
name|fg_at
operator|=
name|vds
operator|.
name|color
condition|?
name|DEF_KERN_C_FGAT
else|:
name|DEF_KERN_M_FGAT
expr_stmt|;
name|o
operator|->
name|bg_at
operator|=
name|DEF_KERN_BGAT
expr_stmt|;
block|}
comment|/* asa@kiae.su: fix to allow non-black background */
comment|/*o->def_at = o->fg_at | o->bg_at;*/
break|break;
case|case
literal|1
case|:
comment|/* ansi background */
if|if
condition|(
name|vds
operator|.
name|color
condition|)
name|o
operator|->
name|bg_at
operator|=
name|bgansitopc
index|[
name|attr
operator|&
literal|7
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* ansi foreground */
if|if
condition|(
name|vds
operator|.
name|color
condition|)
name|o
operator|->
name|fg_at
operator|=
name|fgansitopc
index|[
name|attr
operator|&
literal|7
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* pc text attribute */
name|o
operator|->
name|fg_at
operator|=
name|attr
operator|&
literal|0x8f
expr_stmt|;
name|o
operator|->
name|bg_at
operator|=
name|attr
operator|&
literal|0x70
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* set so attribute to default */
name|vp
operator|->
name|so_at
operator|=
name|vds
operator|.
name|color
condition|?
name|DEF_SO_C_AT
else|:
name|DEF_SO_M_AT
expr_stmt|;
block|}
name|o
operator|->
name|def_at
operator|=
name|o
operator|->
name|fg_at
operator||
name|o
operator|->
name|bg_at
expr_stmt|;
comment|/* asa@kiae.su */
block|}
end_function

begin_function
name|void
name|vga_selectfont
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|fontnr
parameter_list|)
block|{
name|vp
operator|->
name|op
operator|->
name|f2
operator|=
operator|(
name|fontnr
operator|==
literal|2
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vga_wrtchar
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|u_int
name|c
parameter_list|,
name|u_int
name|at
parameter_list|)
block|{
operator|*
operator|(
name|vp
operator|->
name|crtat
operator|++
operator|)
operator|=
call|(
name|u_short
call|)
argument_list|(
name|at
operator|<<
literal|8
argument_list|)
operator||
name|c
expr_stmt|;
name|vp
operator|->
name|col
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	check whether crtat points to outside the screen  *	= 0: no, = -1: less than top of screen, =1: below bottom of screen  */
end_comment

begin_function
name|int
name|vga_checkcursor
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|->
name|crtat
operator|<
name|vp
operator|->
name|Crtat
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|vp
operator|->
name|crtat
operator|>=
name|vp
operator|->
name|Crtat
operator|+
name|vp
operator|->
name|size
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * return a char to the vty, i.e. simulate an (ASCII) keypress,  * used to return status messages (not for pc3)  */
end_comment

begin_function
name|void
name|vga_sendchar
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|XCHAR
name|c
parameter_list|)
block|{
comment|/* XXX modify for real (=char) XCHAR type */
comment|/* is it opened? */
if|if
condition|(
name|vp
operator|->
name|ttycnt
condition|)
operator|(
operator|*
name|linesw
index|[
name|vp
operator|->
name|ttyp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|&
literal|0xFF
operator|,
name|vp
operator|->
name|ttyp
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vga_initvideo
parameter_list|()
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPC=0 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCO=1 */
end_comment

end_unit

