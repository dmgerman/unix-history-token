begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  *      Copyright 1992,1993 by Holger Veit  *	Some parts of this code may still resemble code  *	derived from software contributed to Berkeley by William Jolitz   *	and Don Ahn.  *	May be freely used with Bill Jolitz's port of   *	386bsd and may be included in a 386bsd collection  *	as long as binary and source are available and reproduce the above  *	copyright.  *  *	You may freely modify this code and contribute improvements based  *	on this code as long as you don't claim to be the original author.  *	Commercial use of this source requires permittance of the copyright   *	holder. A general license for 386bsd will override this restriction.  *  *	Use at your own risk. The copyright holder or any person who makes  *	this code available for the public (administrators of public archives  *	for instance) are not responsible for any harm to hardware or software  *	that might happen due to wrong application or program faults.  *  *  *	@(#) $RCSfile: co_kbd.c,v $	$Revision: 1.12 $ (Contributed to 386bsd) $Date: 93/01/23 23:14:42 $  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/src/sys.386bsd/i386/isa/codrv/RCS/co_kbd.c,v 1.12 93/01/23 23:14:42 root Exp Locker: root $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * History: see CO_HISTORY  */
end_comment

begin_comment
comment|/*  * code to work keyboard& display for PC-style console  */
end_comment

begin_include
include|#
directive|include
file|"co.h"
end_include

begin_include
include|#
directive|include
file|"pc.h"
end_include

begin_if
if|#
directive|if
name|NCO
operator|==
literal|1
end_if

begin_if
if|#
directive|if
name|NPC
operator|==
literal|0
end_if

begin_include
include|#
directive|include
file|"vty.h"
end_include

begin_define
define|#
directive|define
name|GLOBAL
end_define

begin_include
include|#
directive|include
file|"co_hdr.h"
end_include

begin_undef
undef|#
directive|undef
name|GLOBAL
end_undef

begin_decl_stmt
name|struct
name|consinfo
name|cons_capabilities
init|=
block|{
name|CONS_ISCO
operator||
name|CONS_HASKBD
operator||
name|CONS_HASKEYNUM
operator||
name|CONS_USEPC8
operator||
name|CONS_HASKCAP
operator||
name|CONS_HASFNT
operator||
name|CONS_HASPX386
if|#
directive|if
name|NVTY
operator|>
literal|1
operator||
name|CONS_HASVTY
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PC3
operator||
name|CONS_HASPC3
endif|#
directive|endif
block|,
literal|0l
block|,
literal|0l
block|,
literal|0l
block|,
comment|/* dont write this as a "string", this is XCHAR data! */
block|{
literal|'c'
block|,
literal|'o'
block|,
literal|'d'
block|,
literal|'r'
block|,
literal|'v'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* filled in by vtemul_init */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* reserved */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  static variables for co_kbd  */
end_comment

begin_decl_stmt
specifier|static
name|XCHAR
modifier|*
name|more_chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|lastkey
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* save for last key */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|extended
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* extended scan code */
end_comment

begin_decl_stmt
specifier|static
name|char
name|resetdone
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reset flag */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|altkpflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in ALT-KP mode */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|altkpval
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated value of ALT-KP */
end_comment

begin_function_decl
specifier|static
name|XCHAR
modifier|*
name|kbd_xlatkey2ascii
parameter_list|(
name|u_int
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|kbd_sgetk
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* CO device support */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|codriver
init|=
block|{
name|coprobe
block|,
name|coattach
block|,
literal|"co"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CO_RDPRI
value|(PZERO+1)
end_define

begin_function
name|void
name|reset_kbd_flags
parameter_list|()
block|{
comment|/* when closing pccons, it may be that a ctrl key is still pending */
name|kbs
operator|.
name|shift_down
operator|=
name|kbs
operator|.
name|ctrl_down
operator|=
name|kbs
operator|.
name|meta_down
operator|=
name|kbs
operator|.
name|altgr_down
operator|=
name|extended
operator|=
name|altkpflag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CO is the raw keyboard device == /dev/kbd  * PC is the TTY-type keyboard device == /dev/console  * CO has precedence over PC, so if the XSERVER opens /dev/kbd,  * no word will ever be heard from /dev/console, until X closes it again  *  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|coopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|consoftc
operator|.
name|cs_mymajor
operator|=
name|major
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* minor 128 is /dev/vga */
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
literal|0x80
condition|)
return|return
literal|0
return|;
comment|/* exclusive open only */
if|if
condition|(
name|consoftc
operator|.
name|cs_flags
operator|&
name|CO_OPENRAW
condition|)
return|return
name|EBUSY
return|;
comment|/* someone wants to write to the keyboard? */
if|if
condition|(
name|flag
operator|&
operator|(
name|FWRITE
operator||
name|FAPPEND
operator|)
condition|)
return|return
name|ENODEV
return|;
name|consoftc
operator|.
name|cs_flags
operator||=
name|CO_OPENRAW
expr_stmt|;
comment|/* save constty for later */
name|consoftc
operator|.
name|cs_constty
operator|=
name|constty
expr_stmt|;
comment|/* save active vty */
name|consoftc
operator|.
name|cs_actvty
operator|=
name|actvty
expr_stmt|;
comment|/* initialize the buffer */
name|consoftc
operator|.
name|cs_flags
operator||=
name|CO_INITRB
expr_stmt|;
name|initrb
argument_list|(
operator|&
name|co_buf
argument_list|)
expr_stmt|;
comment|/* signal opening process only */
ifdef|#
directive|ifdef
name|OLDPATCHKIT
name|consoftc
operator|.
name|cs_selp
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|consoftc
operator|.
name|cs_rsel
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|consoftc
operator|.
name|cs_pgid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
comment|/* lex xserver */
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
literal|1
condition|)
block|{
name|kbd_setxserveriopl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vty_setactive
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|coclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
name|actvty
operator|->
name|ttyp
decl_stmt|;
comment|/* minor 128 is /dev/vga */
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
literal|0x80
condition|)
return|return
literal|0
return|;
name|consoftc
operator|.
name|cs_flags
operator|&=
operator|~
operator|(
name|CO_OPENRAW
operator||
name|CO_ASYNC
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OLDPATCHKIT
name|consoftc
operator|.
name|cs_selp
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|consoftc
operator|.
name|cs_rsel
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|consoftc
operator|.
name|cs_pgid
operator|=
literal|0
expr_stmt|;
comment|/* do we need to restore console? 	 * check whether we had a console and now have no longer one: 	 * then someone grabbed it (xterm -C) and died, 	 * of course the old constty must still be open 	 */
if|if
condition|(
name|consoftc
operator|.
name|cs_constty
operator|&&
operator|!
name|constty
operator|&&
name|consoftc
operator|.
name|cs_constty
operator|->
name|t_state
condition|)
block|{
name|constty
operator|=
name|consoftc
operator|.
name|cs_constty
expr_stmt|;
name|constty
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
name|ttwakeup
argument_list|(
name|constty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* usually console hangs in ttopen (hack) */
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
literal|1
condition|)
block|{
name|kbd_setxserveriopl
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vty_setactive
argument_list|(
name|actvty
operator|->
name|vtynum
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|coread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|c
operator|,
name|n
operator|=
literal|0
expr_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
comment|/* minor 128 is /dev/vga */
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
literal|0x80
condition|)
return|return
name|ENXIO
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|RB_LEN
argument_list|(
operator|&
name|co_buf
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|IO_NDELAY
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EWOULDBLOCK
return|;
block|}
name|consoftc
operator|.
name|cs_flags
operator||=
name|CO_RDWAIT
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|co_buf
argument_list|,
name|CO_RDPRI
operator||
name|PCATCH
argument_list|,
literal|"kbd"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|consoftc
operator|.
name|cs_flags
operator|&=
operator|~
name|CO_RDWAIT
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
operator|&
name|co_buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|ureadc
argument_list|(
name|c
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Got a console receive interrupt -  * the console processor wants to give us a character.  * Catch the character in a buffer  */
end_comment

begin_function
name|void
name|cointr
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|irq
parameter_list|,
name|int
name|cpl
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|error
decl_stmt|;
name|XCHAR
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
comment|/* open buffer ? */
if|if
condition|(
operator|(
name|consoftc
operator|.
name|cs_flags
operator|&
name|CO_INITRB
operator|)
operator|==
literal|0
condition|)
block|{
name|initrb
argument_list|(
operator|&
name|co_buf
argument_list|)
expr_stmt|;
name|consoftc
operator|.
name|cs_flags
operator||=
name|CO_INITRB
expr_stmt|;
block|}
comment|/* vt switch in progress? */
if|if
condition|(
name|vtswsema
condition|)
return|return;
comment|/* get a keynum */
name|c
operator|=
name|kbd_sgetk
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* spurious? */
if|if
condition|(
operator|(
name|c
operator|&
literal|0x7F
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* must restore display? */
if|if
condition|(
name|vds
operator|.
name|blanking
condition|)
name|vga_doblanking
argument_list|(
name|BLANKSTART
argument_list|)
expr_stmt|;
comment|/* in poll mode ? */
if|if
condition|(
name|consoftc
operator|.
name|cs_flags
operator|&
name|CO_POLLING
condition|)
return|return;
comment|/* no open device */
if|if
condition|(
operator|(
name|consoftc
operator|.
name|cs_flags
operator|&
operator|(
name|CO_OPEN
operator||
name|CO_OPENRAW
operator|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|consoftc
operator|.
name|cs_flags
operator|&
name|CO_OPENRAW
condition|)
block|{
comment|/* has the vty, which was active when /dev/kbd was opened 		 * still control? If yes, move data to /dev/kbd, else 		 * to the active vty 		 */
if|if
condition|(
name|actvty
operator|==
name|consoftc
operator|.
name|cs_actvty
condition|)
block|{
comment|/* save byte */
name|error
operator|=
name|putc
argument_list|(
name|c
argument_list|,
operator|&
name|co_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* buffer full */
name|printf
argument_list|(
literal|"Keyboard buffer overflow"
argument_list|)
expr_stmt|;
name|initrb
argument_list|(
operator|&
name|co_buf
argument_list|)
expr_stmt|;
comment|/* flushing all */
name|consoftc
operator|.
name|cs_ovfl
operator|++
expr_stmt|;
block|}
comment|/* if anyone is interested, tell it that there is data */
name|cowakeup
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* convert to ASCII and give to tty driver */
name|cp
operator|=
name|kbd_xlatkey2ascii
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return;
name|tp
operator|=
name|actvty
operator|->
name|ttyp
expr_stmt|;
if|if
condition|(
name|actvty
operator|->
name|ttycnt
operator|==
literal|0
condition|)
return|return;
comment|/* ignore if not open */
comment|/* notice: a \000 Byte is an ASCIZ string \000\000 actually */
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
operator|&&
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|(
operator|*
name|cp
operator|++
operator|&
literal|0xff
operator|)
operator|,
name|tp
operator|)
expr_stmt|;
else|else
while|while
condition|(
operator|*
name|cp
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|(
operator|*
name|cp
operator|++
operator|&
literal|0xff
operator|)
operator|,
name|tp
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|cowakeup
parameter_list|()
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|consoftc
operator|.
name|cs_flags
operator|&
name|CO_OPENRAW
operator|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|OLDPATCHKIT
if|if
condition|(
name|consoftc
operator|.
name|cs_selp
condition|)
block|{
name|selwakeup
argument_list|(
name|consoftc
operator|.
name|cs_selp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|consoftc
operator|.
name|cs_selp
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|consoftc
operator|.
name|cs_rsel
condition|)
block|{
name|selwakeup
argument_list|(
name|consoftc
operator|.
name|cs_rsel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|consoftc
operator|.
name|cs_rsel
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|consoftc
operator|.
name|cs_flags
operator|&
name|CO_ASYNC
condition|)
block|{
if|if
condition|(
name|consoftc
operator|.
name|cs_pgid
operator|<
literal|0
condition|)
name|gsignal
argument_list|(
operator|-
name|consoftc
operator|.
name|cs_pgid
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|=
name|pfind
argument_list|(
name|consoftc
operator|.
name|cs_pgid
argument_list|)
condition|)
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|consoftc
operator|.
name|cs_flags
operator|&
name|CO_RDWAIT
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|co_buf
argument_list|)
expr_stmt|;
name|consoftc
operator|.
name|cs_flags
operator|&=
operator|~
name|CO_RDWAIT
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|coselect
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|rw
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|nread
expr_stmt|;
name|int
name|s
init|=
name|spltty
argument_list|()
decl_stmt|;
if|if
condition|(
name|rw
operator|==
name|FREAD
condition|)
block|{
name|nread
operator|=
name|RB_LEN
argument_list|(
operator|&
name|co_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|>
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|OLDPATCHKIT
name|consoftc
operator|.
name|cs_selp
operator|=
name|p
expr_stmt|;
else|#
directive|else
name|consoftc
operator|.
name|cs_rsel
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|coioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|error
expr_stmt|;
switch|switch
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
comment|/* /dev/kbd */
return|return
name|kbdioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
return|;
case|case
literal|128
case|:
comment|/* /dev/vga */
return|return
name|vgaioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
return|;
default|default:
return|return
name|ENOTTY
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* might be put into vga.c, because it is its memory */
end_comment

begin_function
name|int
name|comap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|>
literal|0x20000
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i386_btop
argument_list|(
operator|(
literal|0xa0000
operator|+
name|offset
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|kbd_wait_ibf
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KBDTIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|KBSTATP
argument_list|)
operator|&
name|KBS_IBF
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
comment|/* keyboard controller seems to hang */
comment|/* may consider reset ? */
block|}
end_function

begin_function
name|void
name|kbd_wait_obf
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KBDTIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|KBSTATP
argument_list|)
operator|&
name|KBS_DIB
condition|)
return|return;
block|}
comment|/* timeout, expected answer did not arrive in time */
comment|/* data read now may be void ? */
block|}
end_function

begin_define
define|#
directive|define
name|kbd_ctrlcmd
parameter_list|(
name|cmd
parameter_list|)
value|kbc_8042cmd(cmd)
end_define

begin_define
define|#
directive|define
name|kbd_flush
parameter_list|()
value|if (inb(KBSTATP)& KBS_DIB) (void)inb(KBDATAP)
end_define

begin_function
specifier|static
name|unsigned
name|kbd_cmd
parameter_list|(
name|cmd
parameter_list|)
block|{
name|kbd_wait_ibf
argument_list|()
expr_stmt|;
comment|/* wait until buffer is free for data */
if|if
condition|(
name|cmd
condition|)
name|outb
argument_list|(
name|KBOUTP
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* output the data */
name|kbd_wait_ibf
argument_list|()
expr_stmt|;
comment|/* wait until buffer is available again */
return|return
name|inb
argument_list|(
name|KBDATAP
argument_list|)
return|;
comment|/* read something (!) from the data port */
block|}
end_function

begin_function
name|void
name|kbd_warmreset
parameter_list|()
block|{
comment|/* flush the keyboard buffer */
name|kbd_flush
argument_list|()
expr_stmt|;
comment|/* set the cntrl command byte */
ifdef|#
directive|ifdef
name|XTKBDMODE
define|#
directive|define
name|KC8_CTRL
value|(KC8_TRANS|KC8_IGNSEC|KC8_CPU|KC8_IEN)
else|#
directive|else
define|#
directive|define
name|KC8_CTRL
value|(KC8_IGNSEC|KC8_CPU|KC8_IEN)
endif|#
directive|endif
comment|/* Enable interrupts and keyboard controller */
name|kbd_wait_ibf
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|KBCMDP
argument_list|,
name|KBC_CMDWRITE
argument_list|)
expr_stmt|;
name|kbd_wait_ibf
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|KBOUTP
argument_list|,
name|KC8_CTRL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kbd_coldreset
parameter_list|()
block|{
name|u_char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|again
init|=
literal|0
decl_stmt|;
comment|/* flush the input buffer and set the mode */
name|kbd_warmreset
argument_list|()
expr_stmt|;
comment|/* Start keyboard stuff RESET */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 11 Sep 92 : !!CROCK!!*/
name|kbd_cmd
argument_list|(
name|KBC_RESET
argument_list|)
expr_stmt|;
name|i
operator|=
name|KBDRETRIES
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|&&
operator|(
name|c
operator|=
name|inb
argument_list|(
name|KBDATAP
argument_list|)
operator|)
operator|!=
name|KBR_ACK
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
name|KBR_RESEND
operator|)
operator|||
operator|(
name|c
operator|==
name|KBR_OVERRUN
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|again
condition|)
name|printf
argument_list|(
literal|"KEYBOARD disconnected: RECONNECT \n"
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 11 Sep 92 : !!CROCK!!*/
name|kbd_cmd
argument_list|(
name|KBC_RESET
argument_list|)
expr_stmt|;
name|again
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|i
operator|=
name|KBDTIMEOUT
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|&&
operator|(
name|c
operator|=
name|inb
argument_list|(
name|KBDATAP
argument_list|)
operator|)
operator|!=
name|KBR_RSTDONE
condition|)
empty_stmt|;
comment|/* get keyboard type */
name|kbd_wait_ibf
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|KBCMDP
argument_list|,
name|KBC_RDID
argument_list|)
expr_stmt|;
name|i
operator|=
name|KBDTIMEOUT
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
operator|&&
operator|(
name|kbs
operator|.
name|id
operator|=
name|inb
argument_list|(
name|KBDATAP
argument_list|)
operator|)
operator|==
name|KBR_RSTDONE
condition|)
empty_stmt|;
comment|/*	kbd_wait_obf();*/
if|if
condition|(
operator|!
name|i
condition|)
name|kbs
operator|.
name|id
operator|=
literal|0xFF
expr_stmt|;
comment|/*	kbs.id = inb(KBDATAP);*/
name|resetdone
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set the LEDs */
end_comment

begin_function
name|void
name|kbd_setleds
parameter_list|(
name|int
name|ledval
parameter_list|)
block|{
name|kbs
operator|.
name|ledstate
operator|=
name|ledval
expr_stmt|;
name|kbd_cmd
argument_list|(
name|KBC_STSIND
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|KBOUTP
argument_list|,
name|ledval
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MINITERM
end_ifndef

begin_comment
comment|/* set the typematic rate */
end_comment

begin_function
name|void
name|kbd_settpmrate
parameter_list|(
name|int
name|rate
parameter_list|)
block|{
name|kbs
operator|.
name|tpmrate
operator|=
name|rate
operator|&
literal|0x7f
expr_stmt|;
name|kbd_cmd
argument_list|(
name|KBC_SETTPM
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|KBOUTP
argument_list|,
name|kbs
operator|.
name|tpmrate
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!MINITERM*/
end_comment

begin_function
name|int
name|coprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
specifier|register
name|struct
name|consoftc
modifier|*
name|p
init|=
operator|&
name|consoftc
decl_stmt|;
specifier|register
name|struct
name|kbdstate
modifier|*
name|k
init|=
operator|&
name|kbs
decl_stmt|;
comment|/* reset consoftc structure */
name|p
operator|->
name|cs_flags
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|cs_timo
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|cs_wedgecnt
operator|=
literal|0l
expr_stmt|;
name|p
operator|->
name|cs_ovfl
operator|=
literal|0l
expr_stmt|;
name|p
operator|->
name|cs_opencnt
operator|=
literal|0
expr_stmt|;
name|k
operator|->
name|pitch
operator|=
literal|0x31b
expr_stmt|;
name|k
operator|->
name|duration
operator|=
name|hz
operator|/
literal|4
expr_stmt|;
name|k
operator|->
name|ledstate
operator|=
literal|0
expr_stmt|;
name|k
operator|->
name|repeat
operator|=
literal|1
expr_stmt|;
name|extended
operator|=
name|vds
operator|.
name|blanking
operator|=
literal|0
expr_stmt|;
comment|/* VT switch semaphore */
name|vtswsema
operator|=
literal|0
expr_stmt|;
comment|/* init keyboard ring buffer */
name|p
operator|->
name|cs_flags
operator||=
name|CO_INITRB
expr_stmt|;
name|initrb
argument_list|(
operator|&
name|co_buf
argument_list|)
expr_stmt|;
comment|/* reset keyboard */
name|kbd_coldreset
argument_list|()
expr_stmt|;
name|kbd_setleds
argument_list|(
name|leds
argument_list|(
name|actvty
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MINITERM
name|k
operator|->
name|tpmrate
operator|=
comment|/*KBD_TPD500|KBD_TPM100*/
literal|0x20
operator||
literal|0x0c
expr_stmt|;
name|kbd_settpmrate
argument_list|(
name|k
operator|->
name|tpmrate
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* clear the overlay table */
name|kbd_ovlinit
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXKEYNUM
value|127
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|XTKBDMODE
end_ifndef

begin_define
define|#
directive|define
name|KMASK
value|0xFF
end_define

begin_define
define|#
directive|define
name|BREAKKEY
value|0x80
end_define

begin_define
define|#
directive|define
name|PRINTKEY
value|0x7C
end_define

begin_comment
comment|/* This one is for AT scan codes (preferred) */
end_comment

begin_decl_stmt
specifier|static
name|char
name|scantokey
index|[]
init|=
block|{
comment|/*      -0-  -1-  -2-  -3-  -4-  -5-  -6-  -7-    This layout is valid for US only */
comment|/*00*/
literal|0
block|,
literal|120
block|,
literal|0
block|,
literal|116
block|,
literal|114
block|,
literal|112
block|,
literal|113
block|,
literal|123
block|,
comment|/* ??  F9  ??  F5  F3  F1  F2  F12 */
comment|/*08*/
literal|0
block|,
literal|121
block|,
literal|119
block|,
literal|117
block|,
literal|115
block|,
literal|16
block|,
literal|1
block|,
literal|0
block|,
comment|/* ??  F10 F8  F6  F4  TAB `   ??  */
comment|/*10*/
literal|0
block|,
literal|60
block|,
literal|44
block|,
literal|0
block|,
literal|58
block|,
literal|17
block|,
literal|2
block|,
literal|0
block|,
comment|/* ??  ALl SHl ??  CTl Q   1   ??  */
comment|/*18*/
literal|0
block|,
literal|0
block|,
literal|46
block|,
literal|32
block|,
literal|31
block|,
literal|18
block|,
literal|3
block|,
literal|0
block|,
comment|/* ??  Z   S   A   W   2   ??  ??  */
comment|/*20*/
literal|0
block|,
literal|48
block|,
literal|47
block|,
literal|33
block|,
literal|19
block|,
literal|5
block|,
literal|4
block|,
literal|0
block|,
comment|/* ??  C   X   D   E   4   3   ??  */
comment|/*28*/
literal|0
block|,
literal|61
block|,
literal|49
block|,
literal|34
block|,
literal|21
block|,
literal|20
block|,
literal|6
block|,
literal|0
block|,
comment|/* ??  SP  V   F   T   R   5   ??  */
comment|/*30*/
literal|0
block|,
literal|51
block|,
literal|50
block|,
literal|36
block|,
literal|35
block|,
literal|22
block|,
literal|7
block|,
literal|0
block|,
comment|/* ??  N   B   H   G   Y   6   ??  */
comment|/*38*/
literal|0
block|,
literal|0
block|,
literal|52
block|,
literal|37
block|,
literal|23
block|,
literal|8
block|,
literal|9
block|,
literal|0
block|,
comment|/* ??  ??  M   J   U   7   8   ??  */
comment|/*40*/
literal|0
block|,
literal|53
block|,
literal|38
block|,
literal|24
block|,
literal|25
block|,
literal|11
block|,
literal|10
block|,
literal|0
block|,
comment|/* ??  ,   K   I   O   0   9   ??  */
comment|/*48*/
literal|0
block|,
literal|54
block|,
literal|55
block|,
literal|39
block|,
literal|40
block|,
literal|26
block|,
literal|12
block|,
literal|0
block|,
comment|/* ??  .   /   L   ;   P   -   ??  */
comment|/*50*/
literal|0
block|,
literal|0
block|,
literal|41
block|,
literal|0
block|,
literal|27
block|,
literal|13
block|,
literal|0
block|,
literal|0
block|,
comment|/* ??  ??  "   ??  [   =   ??  ??  */
comment|/*58*/
literal|30
block|,
literal|57
block|,
literal|43
block|,
literal|28
block|,
literal|0
block|,
literal|29
block|,
literal|0
block|,
literal|0
block|,
comment|/* CAP SHr ENT ]   ??  \   ??  ??  */
comment|/*60*/
literal|0
block|,
literal|45
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|15
block|,
literal|0
block|,
comment|/* ??  NL1 ??  ??  ??  ??  BS  ??  */
comment|/*68*/
literal|0
block|,
literal|93
block|,
literal|0
block|,
literal|92
block|,
literal|91
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* ??  KP1 ??  KP4 KP7 ??  ??  ??  */
comment|/*70*/
literal|99
block|,
literal|104
block|,
literal|98
block|,
literal|97
block|,
literal|102
block|,
literal|96
block|,
literal|110
block|,
literal|90
block|,
comment|/* KP0 KP. KP2 KP5 KP6 KP8 ESC NUM */
comment|/*78*/
literal|122
block|,
literal|106
block|,
literal|103
block|,
literal|105
block|,
literal|100
block|,
literal|101
block|,
literal|125
block|,
literal|0
block|,
comment|/* F11 KP+ KP3 KP- KP* KP9 LOC ??  */
comment|/*80*/
literal|126
block|,
literal|0
block|,
literal|0
block|,
literal|118
block|,
comment|/* BREAK  ??  ??  F7 */
comment|/*     ^^^  * -hv- we use 0x80 for a pseudo scan code for this shit break key  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|extscantokey
index|[]
init|=
block|{
comment|/*      -0-  -1-  -2-  -3-  -4-  -5-  -6-  -7-     This layout is valid for US only */
comment|/*00*/
literal|0
block|,
literal|120
block|,
literal|0
block|,
literal|116
block|,
literal|114
block|,
literal|112
block|,
literal|113
block|,
literal|123
block|,
comment|/* ??  F9  ??  F5  F3  F1  F2  F12 */
comment|/*08*/
literal|0
block|,
literal|121
block|,
literal|119
block|,
literal|117
block|,
literal|115
block|,
literal|16
block|,
literal|1
block|,
literal|0
block|,
comment|/* ??  F10 F8  F6  F4  TAB `   ??  */
comment|/*10*/
literal|0
block|,
literal|62
block|,
literal|124
block|,
literal|0
block|,
literal|64
block|,
literal|17
block|,
literal|2
block|,
literal|0
block|,
comment|/* ??  ALr PSc ??  CTr Q   1   ??  */
comment|/*18*/
literal|0
block|,
literal|0
block|,
literal|46
block|,
literal|32
block|,
literal|31
block|,
literal|18
block|,
literal|3
block|,
literal|0
block|,
comment|/* ??  Z   S   A   W   2   ??  ??  */
comment|/*20*/
literal|0
block|,
literal|48
block|,
literal|47
block|,
literal|33
block|,
literal|19
block|,
literal|5
block|,
literal|4
block|,
literal|0
block|,
comment|/* ??  C   X   D   E   4   3   ??  */
comment|/*28*/
literal|0
block|,
literal|61
block|,
literal|49
block|,
literal|34
block|,
literal|21
block|,
literal|20
block|,
literal|6
block|,
literal|0
block|,
comment|/* ??  SP  V   F   T   R   5   ??  */
comment|/*30*/
literal|0
block|,
literal|51
block|,
literal|50
block|,
literal|36
block|,
literal|35
block|,
literal|22
block|,
literal|7
block|,
literal|0
block|,
comment|/* ??  N   B   H   G   Y   6   ??  */
comment|/*38*/
literal|0
block|,
literal|0
block|,
literal|52
block|,
literal|37
block|,
literal|23
block|,
literal|8
block|,
literal|9
block|,
literal|0
block|,
comment|/* ??  ??  M   J   U   7   8   ??  */
comment|/*40*/
literal|0
block|,
literal|53
block|,
literal|38
block|,
literal|24
block|,
literal|25
block|,
literal|11
block|,
literal|10
block|,
literal|0
block|,
comment|/* ??  ,   K   I   O   0   9   ??  */
comment|/*48*/
literal|0
block|,
literal|54
block|,
literal|95
block|,
literal|39
block|,
literal|40
block|,
literal|26
block|,
literal|12
block|,
literal|0
block|,
comment|/* ??  .   KP/ L   ;   P   -   ??  */
comment|/*50*/
literal|0
block|,
literal|0
block|,
literal|41
block|,
literal|0
block|,
literal|27
block|,
literal|13
block|,
literal|0
block|,
literal|0
block|,
comment|/* ??  ??  "   ??  [   =   ??  ??  */
comment|/*58*/
literal|30
block|,
literal|57
block|,
literal|108
block|,
literal|28
block|,
literal|0
block|,
literal|29
block|,
literal|0
block|,
literal|0
block|,
comment|/* CAP  SHr KPE ]   ??  \  ??  ??  */
comment|/*60*/
literal|0
block|,
literal|45
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|15
block|,
literal|0
block|,
comment|/* ??  NL1 ??  ??  ??  ??  BS  ??  */
comment|/*68*/
literal|0
block|,
literal|81
block|,
literal|0
block|,
literal|79
block|,
literal|80
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* ??  END ??  LA  HOM ??  ??  ??  */
comment|/*70*/
literal|75
block|,
literal|76
block|,
literal|84
block|,
literal|97
block|,
literal|89
block|,
literal|83
block|,
literal|110
block|,
literal|90
block|,
comment|/* INS DEL DA  KP5 RA  UA  ESC NUM */
comment|/*78*/
literal|122
block|,
literal|106
block|,
literal|86
block|,
literal|105
block|,
literal|124
block|,
literal|85
block|,
literal|125
block|,
literal|0
block|,
comment|/* F11 KP+ PD  KP- PSc PU  LOC ??  */
comment|/*80*/
literal|126
block|,
literal|0
block|,
literal|0
block|,
literal|118
block|,
comment|/* BREAK  ??  ??  F7 */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* in SNAFU mode, try this ones (XTKBDMODE) */
end_comment

begin_define
define|#
directive|define
name|KMASK
value|0x7F
end_define

begin_define
define|#
directive|define
name|BREAKKEY
value|0x7F
end_define

begin_define
define|#
directive|define
name|PRINTKEY
value|0x7E
end_define

begin_decl_stmt
specifier|static
name|char
name|scantokey
index|[]
init|=
block|{
comment|/*      -0-  -1-  -2-  -3-  -4-  -5-  -6-  -7-    This layout is valid for US only */
comment|/*00*/
literal|0
block|,
literal|110
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
comment|/* ??  F9  1   2   3   4   5   6   */
comment|/*08*/
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|15
block|,
literal|16
block|,
comment|/* 7   8   9   0   -   =   BS  TAB */
comment|/*10*/
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
comment|/* Q   W   E   R   T   Y   U   I   */
comment|/*18*/
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|43
block|,
literal|58
block|,
literal|31
block|,
literal|32
block|,
comment|/* O   P   [   ]   ENT CTl A   S   */
comment|/*20*/
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
comment|/* D   F   G   H   J   K   L   ;   */
comment|/*28*/
literal|41
block|,
literal|1
block|,
literal|44
block|,
literal|29
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
comment|/* '   '   SHl NL1 Z   X   C   V   */
comment|/*30*/
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|57
block|,
literal|100
block|,
comment|/* B   N   M   ,   .   /   SHr KP* */
comment|/*38*/
literal|60
block|,
literal|61
block|,
literal|30
block|,
literal|112
block|,
literal|113
block|,
literal|114
block|,
literal|115
block|,
literal|116
block|,
comment|/* ALl SP  CAP F1  F2  F3  F4  F5  */
comment|/*40*/
literal|117
block|,
literal|118
block|,
literal|119
block|,
literal|120
block|,
literal|121
block|,
literal|90
block|,
literal|125
block|,
literal|91
block|,
comment|/* F6  F7  F8  F9  F10 NUM LOC KP7 */
comment|/*48*/
literal|96
block|,
literal|101
block|,
literal|105
block|,
literal|92
block|,
literal|97
block|,
literal|102
block|,
literal|106
block|,
literal|93
block|,
comment|/* KP8 KP9 KP- KP4 KP5 KP6 KP+ KP1 */
comment|/*50*/
literal|98
block|,
literal|103
block|,
literal|99
block|,
literal|104
block|,
literal|0
block|,
literal|0
block|,
literal|56
block|,
literal|122
block|,
comment|/* KP2 KP3 KP0 KP. ??  ??  NL2 F11 */
comment|/*58*/
literal|123
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* F12 ??  ??  ??  ??  ??  ??  ??  */
comment|/*60*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* ??  ??  ??  ??  ??  ??  ??  ??  */
comment|/*68*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* ??  ??  ??  ??  ??  ??  ??  ??  */
comment|/*70*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* ??  ??  ??  ??  ??  ??  ??  ??  */
comment|/*78*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|124
block|,
literal|126
block|,
comment|/* ??  ??  ??  ??  ??  ??  ??  ??  */
comment|/*                                    ^^^  ^^^  * -hv- we use 0x7E for a pseudo scan code for the printscreen kludge  * -hv- we use 0x7f for a pseudo scan code for this shit break key  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|extscantokey
index|[]
init|=
block|{
comment|/*      -0-  -1-  -2-  -3-  -4-  -5-  -6-  -7-    This layout is valid for US only */
comment|/*00*/
literal|0
block|,
literal|110
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
comment|/* ??  F9  1   2   3   4   5   6   */
comment|/*08*/
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|15
block|,
literal|16
block|,
comment|/* 7   8   9   0   -   =   BS  TAB */
comment|/*10*/
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
comment|/* Q   W   E   R   T   Y   U   I   */
comment|/*18*/
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|108
block|,
literal|64
block|,
literal|31
block|,
literal|32
block|,
comment|/* O   P   [   ]   KPE CTr A   S   */
comment|/*20*/
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
comment|/* D   F   G   H   J   K   L   ;   */
comment|/*28*/
literal|41
block|,
literal|1
block|,
literal|44
block|,
literal|29
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
comment|/* '   '   SHl NL1 Z   X   C   V   */
comment|/*30*/
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|95
block|,
literal|57
block|,
literal|100
block|,
comment|/* B   N   M   ,   .   KP/ SHr KP* */
comment|/*38*/
literal|62
block|,
literal|61
block|,
literal|30
block|,
literal|112
block|,
literal|113
block|,
literal|114
block|,
literal|115
block|,
literal|116
block|,
comment|/* ALr SP  CAP F1  F2  F3  F4  F5  */
comment|/*40*/
literal|117
block|,
literal|118
block|,
literal|119
block|,
literal|120
block|,
literal|121
block|,
literal|90
block|,
literal|125
block|,
literal|80
block|,
comment|/* F6  F7  F8  F9  F10 NUM LOC HOM */
comment|/*48*/
literal|83
block|,
literal|85
block|,
literal|105
block|,
literal|79
block|,
literal|97
block|,
literal|89
block|,
literal|106
block|,
literal|81
block|,
comment|/* UA  PU  KP- LA  KP5 RA  KP+ END */
comment|/*50*/
literal|84
block|,
literal|86
block|,
literal|75
block|,
literal|76
block|,
literal|0
block|,
literal|0
block|,
literal|56
block|,
literal|122
block|,
comment|/* DA  PD  INS DEL ??  ??  NL2 F11 */
comment|/*58*/
literal|123
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* F12 ??  ??  ??  ??  ??  ??  ??  */
comment|/*60*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* ??  ??  ??  ??  ??  ??  ??  ??  */
comment|/*68*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* ??  ??  ??  ??  ??  ??  ??  ??  */
comment|/*70*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* ??  ??  ??  ??  ??  ??  ??  ??  */
comment|/*78*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|124
block|,
literal|126
block|,
comment|/* ??  ??  ??  ??  ??  ??  ??  ??  */
comment|/*                                    ^^^  ^^^  * -hv- we use 0x7E for a pseudo scan code for the printscreen kludge  * -hv- we use 0x7f for a pseudo scan code for this shit break key  */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|key2scan
parameter_list|(
name|int
name|keynum
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<=
name|MAXKEYNUM
operator|&&
name|keynum
operator|!=
name|scantokey
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
operator|==
name|MAXKEYNUM
condition|?
operator|-
literal|1
else|:
name|i
return|;
block|}
end_function

begin_define
define|#
directive|define
name|KBD_ALPHA
value|KBD_ASCII|KBD_DOCAPS
end_define

begin_decl_stmt
name|Keycap_def
name|kbd_keytab
index|[]
init|=
block|{
comment|/*      type       ptr unshift   	shift     	ctrl    */
comment|/* DONT EVER OVERLOAD KEY 0, THIS IS A KEY THAT MUSTN'T EXIST */
comment|/*  0*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC2
argument_list|(
literal|'d'
argument_list|,
literal|'f'
argument_list|)
block|,
name|XC0
block|,
name|XC0
block|,
comment|/*  1*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'`'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'~'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'`'
argument_list|)
block|,
comment|/*  2*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'1'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'!'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'!'
argument_list|)
block|,
comment|/*  3*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'2'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'@'
argument_list|)
block|,
name|XC1
argument_list|(
literal|0
argument_list|)
block|,
comment|/*  4*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'3'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'#'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'#'
argument_list|)
block|,
comment|/*  5*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'4'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'$'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'$'
argument_list|)
block|,
comment|/*  6*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'5'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'%'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'%'
argument_list|)
block|,
comment|/*  7*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'6'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'^'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\036'
argument_list|)
block|,
comment|/*  8*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'7'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'&'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'&'
argument_list|)
block|,
comment|/*  9*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'8'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'*'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\010'
argument_list|)
block|,
comment|/* 10*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'9'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'('
argument_list|)
block|,
name|XC1
argument_list|(
literal|'('
argument_list|)
block|,
comment|/* 11*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'0'
argument_list|)
block|,
name|XC1
argument_list|(
literal|')'
argument_list|)
block|,
name|XC1
argument_list|(
literal|')'
argument_list|)
block|,
comment|/* 12*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'-'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'_'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\037'
argument_list|)
block|,
comment|/* 13*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'='
argument_list|)
block|,
name|XC1
argument_list|(
literal|'+'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'+'
argument_list|)
block|,
comment|/* 14*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 15*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'\177'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\177'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\010'
argument_list|)
block|,
comment|/* 16*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'\t'
argument_list|)
block|,
name|XC2
argument_list|(
literal|'\177'
argument_list|,
literal|'\t'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\t'
argument_list|)
block|,
comment|/* 17*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'q'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'Q'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\021'
argument_list|)
block|,
comment|/* 18*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'w'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'W'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\027'
argument_list|)
block|,
comment|/* 19*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'e'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'E'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\005'
argument_list|)
block|,
comment|/* 20*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'r'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'R'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\022'
argument_list|)
block|,
comment|/* 21*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'t'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'T'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\024'
argument_list|)
block|,
comment|/* 22*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'y'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'Y'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\031'
argument_list|)
block|,
comment|/* 23*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'u'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'U'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\025'
argument_list|)
block|,
comment|/* 24*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'i'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'I'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\011'
argument_list|)
block|,
comment|/* 25*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'o'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'O'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\017'
argument_list|)
block|,
comment|/* 26*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'p'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'P'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\020'
argument_list|)
block|,
comment|/* 27*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'['
argument_list|)
block|,
name|XC1
argument_list|(
literal|'{'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\033'
argument_list|)
block|,
comment|/* 28*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|']'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'}'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\035'
argument_list|)
block|,
comment|/* 29*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'\\'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'|'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\034'
argument_list|)
block|,
comment|/* 30*/
name|KBD_CAPS
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 31*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'a'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'A'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\001'
argument_list|)
block|,
comment|/* 32*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'s'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'S'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\023'
argument_list|)
block|,
comment|/* 33*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'d'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'D'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\004'
argument_list|)
block|,
comment|/* 34*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'f'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'F'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\006'
argument_list|)
block|,
comment|/* 35*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'g'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'G'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\007'
argument_list|)
block|,
comment|/* 36*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'h'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'H'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\010'
argument_list|)
block|,
comment|/* 37*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'j'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'J'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\n'
argument_list|)
block|,
comment|/* 38*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'k'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'K'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\013'
argument_list|)
block|,
comment|/* 39*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'l'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'L'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\014'
argument_list|)
block|,
comment|/* 40*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|';'
argument_list|)
block|,
name|XC1
argument_list|(
literal|':'
argument_list|)
block|,
name|XC1
argument_list|(
literal|';'
argument_list|)
block|,
comment|/* 41*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'\''
argument_list|)
block|,
name|XC1
argument_list|(
literal|'"'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\''
argument_list|)
block|,
comment|/* 42*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'\\'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'|'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\034'
argument_list|)
block|,
comment|/* special */
comment|/* 43*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'\r'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\r'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\n'
argument_list|)
block|,
comment|/* RETURN */
comment|/* 44*/
name|KBD_SHIFT
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* SHIFT left */
comment|/* 45*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 46*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'z'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'Z'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\032'
argument_list|)
block|,
comment|/* 47*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'x'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'X'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\030'
argument_list|)
block|,
comment|/* 48*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'c'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'C'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\003'
argument_list|)
block|,
comment|/* 49*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'v'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'V'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\026'
argument_list|)
block|,
comment|/* 50*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'b'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'B'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\002'
argument_list|)
block|,
comment|/* 51*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'n'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'N'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\016'
argument_list|)
block|,
comment|/* 52*/
name|KBD_ALPHA
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'m'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'M'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\r'
argument_list|)
block|,
comment|/* 53*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|','
argument_list|)
block|,
name|XC1
argument_list|(
literal|'<'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'<'
argument_list|)
block|,
comment|/* 54*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'.'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'>'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'>'
argument_list|)
block|,
comment|/* 55*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'/'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'?'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\177'
argument_list|)
block|,
comment|/* 56*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 57*/
name|KBD_SHIFT
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* SHIFT right */
comment|/* 58*/
name|KBD_CTL
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* CTL left */
comment|/* 59*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 60*/
name|KBD_META
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* ALT left */
comment|/* 61*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|' '
argument_list|)
block|,
name|XC1
argument_list|(
literal|' '
argument_list|)
block|,
name|XC1
argument_list|(
literal|' '
argument_list|)
block|,
comment|/* SPACE */
comment|/* 62*/
name|KBD_META
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* ALT right */
comment|/* 63*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 64*/
name|KBD_CTL
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* CTL right */
comment|/* 65*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 66*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 67*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 68*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 69*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 70*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 71*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 72*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 73*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 74*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 75*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'L'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'a'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'b'
argument_list|)
block|,
comment|/* INS */
comment|/* 76*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'\177'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'c'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'d'
argument_list|)
block|,
comment|/* DEL */
comment|/* 77*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 78*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 79*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'D'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'e'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'f'
argument_list|)
block|,
comment|/* CU<- */
comment|/* 80*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'H'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'g'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'h'
argument_list|)
block|,
comment|/* HOME */
comment|/* 81*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'F'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'i'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'j'
argument_list|)
block|,
comment|/* END */
comment|/* 82*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 83*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'A'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'k'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'l'
argument_list|)
block|,
comment|/* CU ^ */
comment|/* 84*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'B'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'m'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'n'
argument_list|)
block|,
comment|/* CU v */
comment|/* 85*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'I'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'o'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'p'
argument_list|)
block|,
comment|/* PG UP */
comment|/* 86*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'G'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'q'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'r'
argument_list|)
block|,
comment|/* PG DN */
comment|/* 87*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 88*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 89*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'C'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'s'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'|'
argument_list|,
literal|'t'
argument_list|)
block|,
comment|/* CU -> */
comment|/* 90*/
name|KBD_NUM
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 91*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'7'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'H'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'7'
argument_list|)
block|,
comment|/* 92*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'4'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'D'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'4'
argument_list|)
block|,
comment|/* 93*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'1'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'F'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'1'
argument_list|)
block|,
comment|/* 94*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/* 95*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'/'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'/'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'/'
argument_list|)
block|,
comment|/* 96*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'8'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'A'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'8'
argument_list|)
block|,
comment|/* 97*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'5'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'E'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'5'
argument_list|)
block|,
comment|/* 98*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'2'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'B'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'2'
argument_list|)
block|,
comment|/* 99*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'0'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'L'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'0'
argument_list|)
block|,
comment|/*100*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'*'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'*'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'*'
argument_list|)
block|,
comment|/*101*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'9'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'I'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'9'
argument_list|)
block|,
comment|/*102*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'6'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'C'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'6'
argument_list|)
block|,
comment|/*103*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'3'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'G'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'3'
argument_list|)
block|,
comment|/*104*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'.'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\177'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'.'
argument_list|)
block|,
comment|/*105*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'-'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'-'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'-'
argument_list|)
block|,
comment|/*106*/
name|KBD_KP
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'+'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'+'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'+'
argument_list|)
block|,
comment|/*107*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/*108*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'\r'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\r'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\n'
argument_list|)
block|,
comment|/* RETURN */
comment|/*109*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/*110*/
name|KBD_ASCII
block|,
literal|0
block|,
name|XC1
argument_list|(
literal|'\033'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\033'
argument_list|)
block|,
name|XC1
argument_list|(
literal|'\033'
argument_list|)
block|,
comment|/*111*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/*112*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'M'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'Y'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'k'
argument_list|)
block|,
comment|/* F1 */
comment|/*113*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'N'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'Z'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'l'
argument_list|)
block|,
comment|/* F2 */
comment|/*114*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'O'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'a'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'m'
argument_list|)
block|,
comment|/* F3 */
comment|/*115*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'P'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'b'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'n'
argument_list|)
block|,
comment|/* F4 */
comment|/*116*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'Q'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'c'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'o'
argument_list|)
block|,
comment|/* F5 */
comment|/*117*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'R'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'d'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'p'
argument_list|)
block|,
comment|/* F6 */
comment|/*118*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'S'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'e'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'q'
argument_list|)
block|,
comment|/* F7 */
comment|/*119*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'T'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'f'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'r'
argument_list|)
block|,
comment|/* F8 */
comment|/*120*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'U'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'g'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'s'
argument_list|)
block|,
comment|/* F9 */
comment|/*121*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'V'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'h'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'t'
argument_list|)
block|,
comment|/* F10 */
comment|/*122*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'W'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'i'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'u'
argument_list|)
block|,
comment|/* F11 */
comment|/*123*/
name|KBD_FUNC
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'X'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'j'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'v'
argument_list|)
block|,
comment|/* F12 */
comment|/*124*/
name|KBD_KP
block|,
literal|0
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'w'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'x'
argument_list|)
block|,
name|XE3
argument_list|(
literal|'['
argument_list|,
literal|'y'
argument_list|)
block|,
comment|/*125*/
name|KBD_SCROLL
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/*126*/
name|KBD_BREAK
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|,
comment|/*127*/
name|KBD_NONE
block|,
literal|0
block|,
name|XC0
block|,
name|XC0
block|,
name|XC0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|keypad2num
index|[]
init|=
block|{
literal|7
block|,
literal|4
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|8
block|,
literal|5
block|,
literal|2
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|9
block|,
literal|6
block|,
literal|3
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Overloaded definitions are stored in Ovl_tbl structure,  * allocated via malloc() and pointed by kbd_keytab[].ovlptr. -vak-  * A table entry consists of  * a short, holding the new type attribute and 4 entries for a new   * keydef.   * Note that as long there is enough space, you may overload any key:  * You may assign "rm -rf /\n" to the ENTER key, so you have it directly,  * when you need it, but you can also make a big SHIFT key by overloading  * the SPACE bar. But these are the more uncommon cases.  */
end_comment

begin_function
name|void
name|kbd_ovlinit
parameter_list|()
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAXKEYNUM
condition|;
name|i
operator|++
control|)
name|kbd_keytab
index|[
name|i
index|]
operator|.
name|type
operator|&=
operator|(
name|KBD_MASK
operator||
name|KBD_DOCAPS
operator|)
expr_stmt|;
name|kbs
operator|.
name|m0flag
operator|=
name|kbs
operator|.
name|c0flag
operator|=
name|kbs
operator|.
name|a0flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get original key def */
end_comment

begin_function
name|int
name|kbd_getokeydef
parameter_list|(
name|u_int
name|key
parameter_list|,
name|Ovl_tbl
modifier|*
name|thisdef
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|0
operator|||
name|key
operator|>
name|MAXKEYNUM
condition|)
return|return
name|EINVAL
return|;
name|thisdef
operator|->
name|keynum
operator|=
name|key
expr_stmt|;
name|thisdef
operator|->
name|type
operator|=
name|kbd_keytab
index|[
name|key
index|]
operator|.
name|type
expr_stmt|;
define|#
directive|define
name|copydef
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
define|\
value|xc_bcopy(src,dst,KBDDEFOVLKEYSIZE)
name|copydef
argument_list|(
name|kbd_keytab
index|[
name|key
index|]
operator|.
name|unshift
argument_list|,
name|thisdef
operator|->
name|unshift
argument_list|)
expr_stmt|;
name|copydef
argument_list|(
name|kbd_keytab
index|[
name|key
index|]
operator|.
name|shift
argument_list|,
name|thisdef
operator|->
name|shift
argument_list|)
expr_stmt|;
name|copydef
argument_list|(
name|kbd_keytab
index|[
name|key
index|]
operator|.
name|ctrl
argument_list|,
name|thisdef
operator|->
name|ctrl
argument_list|)
expr_stmt|;
name|copydef
argument_list|(
name|kbd_keytab
index|[
name|key
index|]
operator|.
name|unshift
argument_list|,
name|thisdef
operator|->
name|altgr
argument_list|)
expr_stmt|;
comment|/* deliver at least anything */
name|copydef
argument_list|(
name|kbd_keytab
index|[
name|key
index|]
operator|.
name|shift
argument_list|,
name|thisdef
operator|->
name|shiftaltgr
argument_list|)
expr_stmt|;
name|copydef
argument_list|(
name|kbd_keytab
index|[
name|key
index|]
operator|.
name|unshift
argument_list|,
name|thisdef
operator|->
name|meta
argument_list|)
expr_stmt|;
comment|/* this defeated EMACS META-SPACE */
comment|/*	if (thisdef->meta [0]) */
name|thisdef
operator|->
name|meta
index|[
literal|0
index|]
operator|^=
literal|0x80
expr_stmt|;
undef|#
directive|undef
name|copydef
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* get current key def */
end_comment

begin_function
name|int
name|kbd_getckeydef
parameter_list|(
name|u_int
name|key
parameter_list|,
name|Ovl_tbl
modifier|*
name|thisdef
parameter_list|)
block|{
if|if
condition|(
name|key
operator|>
name|MAXKEYNUM
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|kbd_keytab
index|[
name|key
index|]
operator|.
name|type
operator|&
name|KBD_OVERLOAD
condition|)
operator|*
name|thisdef
operator|=
operator|*
name|kbd_keytab
index|[
name|key
index|]
operator|.
name|ovlptr
expr_stmt|;
else|else
name|kbd_getokeydef
argument_list|(
name|key
argument_list|,
name|thisdef
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|Spec_tbl
modifier|*
name|spec_tbl
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kbd_nrspec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SPECINVALID
value|((Spec_tbl*)0xFFFFFFFF)
end_define

begin_function
specifier|static
name|Spec_tbl
modifier|*
name|kbd_findspec
parameter_list|(
name|u_short
name|key
parameter_list|,
name|u_short
name|modifier
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|spec_tbl
condition|)
name|spec_tbl
operator|=
name|malloc
argument_list|(
name|MAXNROFSPEC
operator|*
sizeof|sizeof
argument_list|(
name|Spec_tbl
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* hv must check whether space is really there */
if|if
condition|(
operator|!
name|spec_tbl
condition|)
return|return
name|SPECINVALID
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kbd_nrspec
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|key
operator|==
name|spec_tbl
index|[
name|i
index|]
operator|.
name|key
condition|)
if|if
condition|(
name|modifier
operator|==
literal|0
operator|||
name|modifier
operator|==
name|spec_tbl
index|[
name|i
index|]
operator|.
name|modifier
condition|)
return|return
operator|&
name|spec_tbl
index|[
name|i
index|]
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|kbd_gethotkey
parameter_list|(
name|struct
name|kbd_hotkey
modifier|*
name|data
parameter_list|)
block|{
name|Spec_tbl
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|key
operator|==
literal|0
operator|||
name|data
operator|->
name|key
operator|>
name|MAXKEYNUM
condition|)
return|return
name|EINVAL
return|;
name|p
operator|=
name|kbd_findspec
argument_list|(
name|data
operator|->
name|key
argument_list|,
name|data
operator|->
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|SPECINVALID
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
name|p
condition|)
block|{
name|data
operator|->
name|key
operator|=
name|p
operator|->
name|key
expr_stmt|;
name|data
operator|->
name|modifier
operator|=
name|p
operator|->
name|modifier
expr_stmt|;
name|data
operator|->
name|function
operator|=
name|p
operator|->
name|function
expr_stmt|;
block|}
else|else
comment|/* not found, clear all */
name|data
operator|->
name|key
operator|=
name|data
operator|->
name|modifier
operator|=
name|data
operator|->
name|function
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|kbd_sethotkey
parameter_list|(
name|struct
name|kbd_hotkey
modifier|*
name|data
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|Spec_tbl
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|key
operator|>
name|MAXKEYNUM
condition|)
return|return
name|EINVAL
return|;
name|p
operator|=
name|kbd_findspec
argument_list|(
name|data
operator|->
name|key
argument_list|,
name|data
operator|->
name|modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|SPECINVALID
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
comment|/* not found: enter. Find empty slot */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|kbd_nrspec
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|spec_tbl
index|[
name|k
index|]
operator|.
name|key
operator|==
literal|0
operator|&&
name|spec_tbl
index|[
name|k
index|]
operator|.
name|modifier
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|k
operator|>=
name|MAXNROFSPEC
condition|)
return|return
name|ENOMEM
return|;
name|p
operator|=
operator|&
name|spec_tbl
index|[
name|k
index|]
expr_stmt|;
block|}
else|else
name|k
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|modifier
operator|==
name|KBD_HOTKEYDELETE
condition|)
block|{
name|p
operator|->
name|key
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|modifier
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|function
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|scan
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|key
operator|=
name|data
operator|->
name|key
expr_stmt|;
name|p
operator|->
name|modifier
operator|=
name|data
operator|->
name|modifier
expr_stmt|;
name|p
operator|->
name|function
operator|=
name|data
operator|->
name|function
expr_stmt|;
name|p
operator|->
name|scan
operator|=
name|key2scan
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|kbd_nrspec
condition|)
name|kbd_nrspec
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MINITERM
end_ifndef

begin_comment
comment|/*  * management of diacritical characters  * in the future this table will be editable  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|diacriticals
index|[]
init|=
block|{
literal|0
block|,
literal|"` ```A\300a\340E\310e\350I\314i\354O\322o\362U\331u\371"
block|,
literal|"' '''A\301a\341E\311e\351I\315i\355O\323o\363U\332u\372Y\335"
block|,
literal|"^ ^^^A\302a\342E\312e\312I\316i\356O\324o\364U\333u\373"
block|,
literal|"~ ~~~A\303a\343N\321n\361O\325o\365"
block|,
literal|"\250A\304a\344\E\313e\353I\316i\357O\326o\366U\334u\374y\377"
block|,
literal|"\270C\307c\347"
block|,
literal|"\260\260\260A\305a\345"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|diacflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|XCHAR
modifier|*
name|kbd_xlatdiac
parameter_list|(
name|u_short
name|type
parameter_list|,
name|XCHAR
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
comment|/* may by NULL pointer, a rich source for crashes */
if|if
condition|(
operator|!
name|ch
condition|)
return|return
name|ch
return|;
if|if
condition|(
name|diacflag
condition|)
block|{
for|for
control|(
name|s
operator|=
name|diacriticals
index|[
name|diacflag
index|]
operator|+
literal|1
operator|,
name|diacflag
operator|=
literal|0
init|;
operator|*
name|s
condition|;
name|s
operator|+=
literal|2
control|)
if|if
condition|(
operator|*
name|s
operator|==
operator|(
name|char
operator|)
operator|*
name|ch
condition|)
block|{
operator|*
name|ch
operator|=
operator|(
name|XCHAR
operator|)
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|ch
return|;
block|}
return|return
name|ch
return|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|&
name|KBD_DIACPFX
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|diacriticals
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|ch
operator|==
operator|*
operator|(
name|diacriticals
index|[
name|i
index|]
operator|)
condition|)
block|{
name|diacflag
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|ch
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!MINITERM*/
end_comment

begin_comment
comment|/*  * kbd_xlatkey2ascii: takes a keynum and the current shift/ctrl/etc. state and  * delivers an appropriate ASCII string  */
end_comment

begin_function
specifier|static
name|XCHAR
modifier|*
name|kbd_xlatkey2ascii
parameter_list|(
name|u_int
name|key
parameter_list|)
block|{
name|struct
name|vty
modifier|*
name|vp
init|=
name|actvty
decl_stmt|;
name|struct
name|consoftc
modifier|*
name|cs
init|=
operator|&
name|consoftc
decl_stmt|;
specifier|static
name|XCHAR
name|metachar
index|[
literal|2
index|]
decl_stmt|;
specifier|static
name|Ovl_tbl
name|thisdef
decl_stmt|;
name|u_short
name|n
decl_stmt|,
name|type
decl_stmt|;
name|char
name|isreleased
init|=
name|key
operator|&
literal|0x80
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|keycode
init|=
name|key
operator|&
literal|0x7f
decl_stmt|;
comment|/* ignore the NON-KEY */
if|if
condition|(
name|keycode
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* get the current ASCII value */
name|kbd_getckeydef
argument_list|(
name|keycode
argument_list|,
operator|&
name|thisdef
argument_list|)
expr_stmt|;
name|type
operator|=
name|thisdef
operator|.
name|type
operator|&
name|KBD_MASK
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|KBD_SHFTLOCK
case|:
if|if
condition|(
operator|!
name|isreleased
condition|)
block|{
name|vp
operator|->
name|shiftlock
operator|^=
literal|1
expr_stmt|;
name|kbd_setleds
argument_list|(
name|leds
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|KBD_ALTGRLOCK
case|:
if|if
condition|(
operator|!
name|isreleased
condition|)
block|{
name|vp
operator|->
name|altgrlock
operator|^=
literal|1
expr_stmt|;
name|kbd_setleds
argument_list|(
name|leds
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|KBD_NUM
case|:
if|if
condition|(
operator|!
name|isreleased
condition|)
block|{
name|vp
operator|->
name|num
operator|^=
literal|1
expr_stmt|;
name|kbd_setleds
argument_list|(
name|leds
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|KBD_CAPS
case|:
if|if
condition|(
operator|!
name|isreleased
condition|)
block|{
name|vp
operator|->
name|caps
operator|^=
literal|1
expr_stmt|;
name|kbd_setleds
argument_list|(
name|leds
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|KBD_SCROLL
case|:
if|if
condition|(
operator|!
name|isreleased
condition|)
block|{
name|vp
operator|->
name|scroll
operator|^=
literal|1
expr_stmt|;
name|kbd_setleds
argument_list|(
name|leds
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|KBD_SHIFT
case|:
name|kbs
operator|.
name|shift_down
operator|=
name|isreleased
condition|?
literal|0
else|:
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBD_META
case|:
name|kbs
operator|.
name|meta_down
operator|=
name|isreleased
condition|?
literal|0
else|:
literal|0x80
expr_stmt|;
goto|goto
name|altnumpad
goto|;
case|case
name|KBD_ALTGR
case|:
name|kbs
operator|.
name|altgr_down
operator|=
name|isreleased
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|altnumpad
label|:
comment|/* special handling of ALT-KEYPAD */
comment|/* have we been in altkp mode? */
if|if
condition|(
name|isreleased
condition|)
block|{
if|if
condition|(
name|altkpflag
condition|)
block|{
name|metachar
index|[
literal|0
index|]
operator|=
name|altkpval
expr_stmt|;
name|metachar
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|altkpflag
operator|=
literal|0
expr_stmt|;
name|altkpval
operator|=
literal|0
expr_stmt|;
name|kbs
operator|.
name|altgr_down
operator|=
literal|0
expr_stmt|;
comment|/* -hv- was: hang in ALT-KP */
return|return
name|metachar
return|;
block|}
block|}
return|return
literal|0
return|;
case|case
name|KBD_CTL
case|:
name|kbs
operator|.
name|ctrl_down
operator|=
name|isreleased
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/*fall thru*/
default|default:
case|case
name|KBD_NONE
case|:
return|return
literal|0
return|;
case|case
name|KBD_BREAK
case|:
case|case
name|KBD_ASCII
case|:
case|case
name|KBD_FUNC
case|:
if|if
condition|(
name|isreleased
condition|)
return|return
literal|0
return|;
name|more_chars
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kbs
operator|.
name|ctrl_down
condition|)
block|{
if|if
condition|(
operator|!
name|kbs
operator|.
name|c0flag
operator|||
name|thisdef
operator|.
name|type
operator|&
name|KBD_OVERLOAD
condition|)
name|more_chars
operator|=
name|thisdef
operator|.
name|ctrl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kbs
operator|.
name|meta_down
condition|)
block|{
if|if
condition|(
name|thisdef
operator|.
name|type
operator|&
name|KBD_OVERLOAD
condition|)
name|more_chars
operator|=
name|thisdef
operator|.
name|meta
expr_stmt|;
else|else
block|{
name|metachar
index|[
literal|0
index|]
operator|=
name|thisdef
operator|.
name|unshift
index|[
literal|0
index|]
operator|^
literal|0x80
expr_stmt|;
name|metachar
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|more_chars
operator|=
name|metachar
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|kbs
operator|.
name|altgr_down
operator|||
name|vp
operator|->
name|altgrlock
condition|)
block|{
if|if
condition|(
operator|!
name|kbs
operator|.
name|a0flag
operator|||
name|thisdef
operator|.
name|type
operator|&
name|KBD_OVERLOAD
condition|)
if|if
condition|(
name|kbs
operator|.
name|shift_down
operator|||
name|vp
operator|->
name|shiftlock
operator|||
name|vp
operator|->
name|caps
operator|&&
operator|(
name|thisdef
operator|.
name|type
operator|&
name|KBD_DOALTCAPS
operator|)
condition|)
name|more_chars
operator|=
name|thisdef
operator|.
name|shiftaltgr
expr_stmt|;
else|else
name|more_chars
operator|=
name|thisdef
operator|.
name|altgr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kbs
operator|.
name|shift_down
operator|||
name|vp
operator|->
name|shiftlock
operator|||
name|vp
operator|->
name|caps
operator|&&
operator|(
name|thisdef
operator|.
name|type
operator|&
name|KBD_DOCAPS
operator|)
condition|)
name|more_chars
operator|=
name|thisdef
operator|.
name|shift
expr_stmt|;
else|else
name|more_chars
operator|=
name|thisdef
operator|.
name|unshift
expr_stmt|;
ifndef|#
directive|ifndef
name|MINITERM
return|return
name|kbd_xlatdiac
argument_list|(
name|thisdef
operator|.
name|type
argument_list|,
name|more_chars
argument_list|)
return|;
else|#
directive|else
return|return
name|more_chars
return|;
endif|#
directive|endif
case|case
name|KBD_KP
case|:
if|if
condition|(
name|isreleased
condition|)
return|return
literal|0
return|;
name|more_chars
operator|=
name|NULL
expr_stmt|;
comment|/* there is special if used with keypad */
if|if
condition|(
name|kbs
operator|.
name|meta_down
operator|||
name|kbs
operator|.
name|altgr_down
condition|)
block|{
name|n
operator|=
name|keypad2num
index|[
name|keycode
operator|-
literal|91
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|altkpflag
condition|)
block|{
comment|/* start ALT-KP mode */
name|altkpflag
operator|=
literal|1
expr_stmt|;
name|altkpval
operator|=
literal|0
expr_stmt|;
block|}
name|altkpval
operator|*=
literal|10
expr_stmt|;
name|altkpval
operator|+=
name|n
expr_stmt|;
comment|/* discard ALT-keypad mode if over 255 */
if|if
condition|(
name|altkpval
operator|>
literal|255
condition|)
block|{
name|altkpflag
operator|=
literal|0
expr_stmt|;
name|altkpval
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|altkpflag
operator|=
literal|0
expr_stmt|;
comment|/* will be emitted when ALT released */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|kbs
operator|.
name|shift_down
operator|||
name|vp
operator|->
name|shiftlock
operator|||
name|kbs
operator|.
name|ctrl_down
operator|||
operator|!
name|vp
operator|->
name|num
condition|)
name|more_chars
operator|=
operator|(
name|kbs
operator|.
name|altgr_down
operator|||
name|vp
operator|->
name|altgrlock
operator|)
condition|?
name|thisdef
operator|.
name|shiftaltgr
else|:
name|thisdef
operator|.
name|shift
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|kbs
operator|.
name|altgr_down
operator|||
name|vp
operator|->
name|altgrlock
operator|)
condition|?
name|thisdef
operator|.
name|altgr
else|:
name|thisdef
operator|.
name|unshift
expr_stmt|;
return|return
operator|(
name|more_chars
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  *   kbd_sgetc (noblock):  get ASCII strings from  the  keyboard.  If  *   noblock  ==  0  wait  until a key is gotten. Otherwise return a NULL  *   if no characters are present.  *  */
end_comment

begin_function
name|XCHAR
modifier|*
name|kbd_sgetc
parameter_list|(
name|int
name|noblock
parameter_list|)
block|{
name|u_int
name|key
decl_stmt|;
if|if
condition|(
operator|!
name|resetdone
condition|)
name|kbd_warmreset
argument_list|()
expr_stmt|;
comment|/* allows proper operation of ddb when  					 * kernel dies before probing pc0 					 */
name|key
operator|=
name|kbd_sgetk
argument_list|(
name|noblock
argument_list|)
expr_stmt|;
return|return
name|kbd_xlatkey2ascii
argument_list|(
name|key
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* compatibility */
end_comment

begin_function
name|int
name|sgetc
parameter_list|(
name|int
name|noblock
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
operator|*
name|kbd_sgetc
argument_list|(
name|noblock
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   * kbd_sgetk: does most of the work and returns keynums  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|breakseen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|breakshit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -hv- for the polite one:  				   read as "break's hit" :-) 				   Why couldn't IBM use the normal 				   convention for the break key? */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|altseen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|ctrlseen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|shiftseen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|syskeyseen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|resetcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|in_Debugger
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|lockhotkey
init|=
literal|0xff
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|XTKBDMODE
end_ifdef

begin_decl_stmt
specifier|static
name|u_char
name|lsh
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|Spec_tbl
modifier|*
name|kbd_ishotkey
parameter_list|(
name|int
name|scan
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kbd_nrspec
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|spec_tbl
index|[
name|i
index|]
operator|.
name|scan
operator|==
name|scan
condition|)
return|return
operator|&
name|spec_tbl
index|[
name|i
index|]
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kbd_dohotkey
parameter_list|(
name|Spec_tbl
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|func
decl_stmt|;
comment|/* bit0=shift,bit1=ctrl,bit2=alt,bit3=syskey */
specifier|static
name|u_char
name|masktbl
index|[]
init|=
block|{
name|KBD_EXT_N
block|,
name|KBD_EXT_S
block|,
name|KBD_EXT_C
block|,
name|KBD_EXT_C
block|,
name|KBD_EXT_A
block|,
name|KBD_EXT_A
block|,
name|KBD_EXT_CA
block|,
name|KBD_EXT_CA
block|,
name|KBD_EXT_SK
block|,
name|KBD_EXT_SK
block|,
name|KBD_EXT_SK
block|,
name|KBD_EXT_SK
block|,
name|KBD_EXT_SK
block|,
name|KBD_EXT_SK
block|,
name|KBD_EXT_CA
block|,
name|KBD_EXT_CA
block|}
decl_stmt|;
define|#
directive|define
name|MASK
value|masktbl[shiftseen|(ctrlseen<<1)|(altseen<<2)|(syskeyseen<<3)]
if|if
condition|(
name|ptr
operator|->
name|modifier
operator|&
name|MASK
condition|)
block|{
comment|/* has triggered a hotkey function, now which */
comment|/* block function if repeated */
if|if
condition|(
name|lockhotkey
operator|==
operator|(
name|func
operator|=
name|ptr
operator|->
name|function
operator|)
condition|)
return|return
literal|0
return|;
comment|/* now perform the function */
switch|switch
condition|(
name|func
condition|)
block|{
default|default:
ifndef|#
directive|ifndef
name|MINITERM
if|if
condition|(
name|func
operator|>=
name|KBD_VTY0
operator|&&
name|func
operator|<
name|nvty
condition|)
name|vty_setactive
argument_list|(
name|func
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|KBD_VTYUP
case|:
if|if
condition|(
operator|!
name|vtswsema
operator|&&
operator|(
name|consoftc
operator|.
name|cs_flags
operator|&
name|CO_OPENRAW
operator|)
operator|==
literal|0
condition|)
name|vty_next
argument_list|()
expr_stmt|;
break|break;
case|case
name|KBD_VTYDOWN
case|:
if|if
condition|(
operator|!
name|vtswsema
operator|&&
operator|(
name|consoftc
operator|.
name|cs_flags
operator|&
name|CO_OPENRAW
operator|)
operator|==
literal|0
condition|)
name|vty_previous
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*!MINITERM*/
break|break;
case|case
name|KBD_RESETKEY
case|:
if|if
condition|(
name|resetcnt
operator|==
literal|1
condition|)
name|cpu_reset
argument_list|()
expr_stmt|;
else|else
block|{
name|vty_broadcast
argument_list|(
literal|"WARNING: RESET WITHOUT SYNC. TO EXECUTE PRESS ctrl-alt-del AGAIN\n"
argument_list|)
expr_stmt|;
name|resetcnt
operator|=
literal|1
expr_stmt|;
block|}
return|return;
case|case
name|KBD_DEBUGKEY
case|:
if|#
directive|if
name|NDDB
operator|>
literal|0
if|if
condition|(
operator|!
name|in_Debugger
condition|)
block|{
name|in_Debugger
operator|=
literal|1
expr_stmt|;
name|Debugger
argument_list|()
expr_stmt|;
name|in_Debugger
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
break|break;
block|}
name|lockhotkey
operator|=
name|func
expr_stmt|;
return|return
literal|1
return|;
comment|/* hotkey was done */
block|}
return|return
literal|0
return|;
comment|/* was not done */
block|}
end_function

begin_function
specifier|static
name|u_int
name|kbd_sgetk
parameter_list|(
name|int
name|noblock
parameter_list|)
block|{
name|u_char
name|dt
decl_stmt|;
name|u_int
name|key
decl_stmt|;
name|u_short
name|type
decl_stmt|;
name|int
name|delay
decl_stmt|;
name|Spec_tbl
modifier|*
name|sp
decl_stmt|;
specifier|static
name|char
name|keybuf
index|[
literal|2
index|]
decl_stmt|;
name|loop
label|:
comment|/* 	 *   First see if there is something in the keyboard port 	 *   Some keyboards may raise interrupt before putting characters 	 *   in the buffer (cf. Mach kd.c), so allow a little delay 	 *   and don't time out immediately 	 *   (sgetk is called from cointr!) 	 */
name|delay
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|KBSTATP
argument_list|)
operator|&
name|KBS_DIB
operator|)
condition|)
block|{
if|if
condition|(
name|noblock
operator|&&
name|delay
operator|--
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* get the byte */
name|dt
operator|=
name|inb
argument_list|(
name|KBDATAP
argument_list|)
expr_stmt|;
comment|/* look what we got */
switch|switch
condition|(
name|dt
condition|)
block|{
case|case
name|KBR_DIAGFAIL
case|:
name|printf
argument_list|(
literal|"Keyboard irq: keyboard sent DIAGNOSTIC FAILURE\n"
argument_list|)
expr_stmt|;
name|kbd_coldreset
argument_list|()
expr_stmt|;
break|break;
case|case
name|KBR_RESEND
case|:
case|case
name|KBR_ACK
case|:
case|case
name|KBR_RSTDONE
case|:
case|case
name|KBR_OVERRUN
case|:
case|case
name|KBR_ECHO
case|:
comment|/* this is junk we do not want to see */
break|break;
case|case
name|KBR_E0
case|:
comment|/* extended code? */
name|extended
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KBR_F0
case|:
comment|/* break code? */
name|breakseen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|breakshit
condition|)
comment|/* =5: wait for 14 */
name|breakshit
operator|++
expr_stmt|;
comment|/* =7: wait for 77 */
break|break;
case|case
name|KBR_E1
case|:
comment|/* -hv- this shit BREAK key */
comment|/* we have to collect a sequence E1 14 77 E1 for make 		   and F0 14 F0 77 for break */
name|breakshit
operator|++
expr_stmt|;
comment|/* state=1: wait for 14, state=4: have make */
if|if
condition|(
name|breakshit
operator|==
literal|4
condition|)
block|{
name|dt
operator|=
literal|0x80
expr_stmt|;
comment|/* build replacement code */
goto|goto
name|regular
goto|;
block|}
break|break;
comment|/* I don't know why the keyboard sends additional E0 F0 12 (make!) 		 * and E0 12 (break!), when an extended key is used with  		 * shift, but this is certainly junk, which we avoid here 		 */
case|case
literal|0x12
case|:
if|if
condition|(
name|extended
condition|)
block|{
name|extended
operator|=
literal|0
expr_stmt|;
name|breakseen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|regular
goto|;
case|case
literal|0x14
case|:
if|if
condition|(
name|breakshit
condition|)
name|breakshit
operator|++
expr_stmt|;
comment|/* =2: wait for 77 */
else|else
comment|/* =6: needs second break; */
goto|goto
name|regular
goto|;
break|break;
case|case
literal|0x77
case|:
if|if
condition|(
name|breakshit
condition|)
name|breakshit
operator|++
expr_stmt|;
comment|/* =3: wait for E1 */
else|else
comment|/* =7: needs second break; */
goto|goto
name|regular
goto|;
if|if
condition|(
name|breakshit
operator|==
literal|8
condition|)
block|{
name|dt
operator|=
name|BREAKKEY
expr_stmt|;
comment|/* build replacement code */
name|breakshit
operator|=
literal|0
expr_stmt|;
goto|goto
name|regular
goto|;
block|}
break|break;
default|default:
goto|goto
name|regular
goto|;
comment|/* regular key */
block|}
name|rescan
label|:
if|if
condition|(
name|noblock
condition|)
return|return
literal|0
return|;
else|else
goto|goto
name|loop
goto|;
comment|/* got a normal scan key */
name|regular
label|:
comment|/* process special non-movable key combinations */
switch|switch
condition|(
name|dt
condition|)
block|{
case|case
literal|0x14
case|:
comment|/* SCAN LEFT CTRL */
name|ctrlseen
operator|=
name|breakseen
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
comment|/* SCAN LEFT ALT */
name|altseen
operator|=
name|breakseen
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
case|case
literal|0x12
case|:
comment|/* SCAN LEFT SHIFT */
name|shiftseen
operator|=
name|breakseen
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
case|case
literal|0x7C
case|:
comment|/* Print/SysRq */
if|if
condition|(
name|breakseen
condition|)
name|syskeyseen
operator|^=
literal|1
expr_stmt|;
name|resetcnt
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* check and process hotkey functions */
if|if
condition|(
operator|(
name|sp
operator|=
name|kbd_ishotkey
argument_list|(
name|dt
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|kbd_dohotkey
argument_list|(
name|sp
argument_list|)
condition|)
goto|goto
name|rescan
goto|;
block|}
else|else
name|lockhotkey
operator|=
literal|0xff
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|breakseen
condition|)
name|resetcnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 *   make a keycode from scan code  	 */
name|key
operator|=
name|extended
condition|?
name|extscantokey
index|[
name|dt
operator|&
name|KMASK
index|]
else|:
name|scantokey
index|[
name|dt
operator|&
name|KMASK
index|]
expr_stmt|;
name|extended
operator|=
literal|0
expr_stmt|;
comment|/* in NOREPEAT MODE ignore the key if it was the same as before */
if|if
condition|(
operator|!
name|kbs
operator|.
name|repeat
operator|&&
name|key
operator|==
name|lastkey
operator|&&
operator|!
name|breakseen
condition|)
block|{
if|if
condition|(
name|noblock
condition|)
return|return
literal|0
return|;
else|else
goto|goto
name|loop
goto|;
block|}
comment|/* -hv- processing of special keys moved to kbd_xlatkey2ascii */
if|if
condition|(
name|breakseen
condition|)
block|{
name|key
operator||=
literal|0x80
expr_stmt|;
name|breakseen
operator|=
literal|0
expr_stmt|;
name|lastkey
operator|=
literal|0
expr_stmt|;
comment|/* -hv- I know this is a bug with */
block|}
else|else
comment|/* N-Key-Rollover, but I ignore that */
block|{
comment|/* because avoidance is too complicated */
name|lastkey
operator|=
name|key
expr_stmt|;
block|}
comment|/* have a key */
return|return
name|key
return|;
block|}
end_function

begin_comment
comment|/*  *   Utility functions for IOCTL  */
end_comment

begin_function
name|int
name|kbd_rmkeydef
parameter_list|(
name|u_int
name|key
parameter_list|)
block|{
specifier|register
name|Ovl_tbl
modifier|*
name|ref
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|0
operator|||
name|key
operator|>
name|MAXKEYNUM
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|kbd_keytab
index|[
name|key
index|]
operator|.
name|type
operator|&
name|KBD_OVERLOAD
condition|)
name|kbd_keytab
index|[
name|key
index|]
operator|.
name|type
operator|&=
operator|(
name|KBD_MASK
operator||
name|KBD_DOCAPS
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|kbd_setkeydef
parameter_list|(
name|Ovl_tbl
modifier|*
name|data
parameter_list|)
block|{
comment|/* valid */
if|if
condition|(
name|data
operator|->
name|keynum
operator|>
name|MAXKEYNUM
operator|||
operator|(
name|data
operator|->
name|type
operator|&
name|KBD_MASK
operator|)
operator|==
name|KBD_BREAK
operator|||
operator|(
name|data
operator|->
name|type
operator|&
name|KBD_MASK
operator|)
operator|>
name|KBD_ALTGRLOCK
condition|)
return|return
name|EINVAL
return|;
comment|/* limit junk */
name|data
operator|->
name|unshift
index|[
name|KBDMAXOVLKEYSIZE
index|]
operator|=
name|data
operator|->
name|shift
index|[
name|KBDMAXOVLKEYSIZE
index|]
operator|=
name|data
operator|->
name|ctrl
index|[
name|KBDMAXOVLKEYSIZE
index|]
operator|=
name|data
operator|->
name|meta
index|[
name|KBDMAXOVLKEYSIZE
index|]
operator|=
name|data
operator|->
name|shiftaltgr
index|[
name|KBDMAXOVLKEYSIZE
index|]
operator|=
name|data
operator|->
name|altgr
index|[
name|KBDMAXOVLKEYSIZE
index|]
operator|=
literal|0
expr_stmt|;
comment|/* mark overload */
name|data
operator|->
name|type
operator||=
name|KBD_OVERLOAD
expr_stmt|;
comment|/* if key already overloaded, use this slot */
if|if
condition|(
operator|!
name|kbd_keytab
index|[
name|data
operator|->
name|keynum
index|]
operator|.
name|ovlptr
condition|)
block|{
comment|/* allocate new slot */
name|kbd_keytab
index|[
name|data
operator|->
name|keynum
index|]
operator|.
name|ovlptr
operator|=
operator|(
name|Ovl_tbl
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Ovl_tbl
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kbd_keytab
index|[
name|data
operator|->
name|keynum
index|]
operator|.
name|ovlptr
condition|)
return|return
name|ENOSPC
return|;
comment|/* no space, abuse of ENOSPC(!) */
block|}
comment|/* copy */
operator|*
name|kbd_keytab
index|[
name|data
operator|->
name|keynum
index|]
operator|.
name|ovlptr
operator|=
operator|*
name|data
expr_stmt|;
comment|/* mark key */
name|kbd_keytab
index|[
name|data
operator|->
name|keynum
index|]
operator|.
name|type
operator||=
name|KBD_OVERLOAD
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|kbd_cvtsound
parameter_list|(
name|int
name|ipitch
parameter_list|,
name|int
modifier|*
name|opitch
parameter_list|,
name|int
name|idur
parameter_list|,
name|int
modifier|*
name|odur
parameter_list|)
block|{
if|if
condition|(
name|ipitch
operator|<=
literal|0
condition|)
name|ipitch
operator|=
literal|1500
operator|,
name|idur
operator|=
literal|250
expr_stmt|;
elseif|else
if|if
condition|(
name|idur
operator|<=
literal|0
operator|||
name|idur
operator|>=
literal|10000
condition|)
name|idur
operator|=
literal|250
expr_stmt|;
operator|*
name|opitch
operator|=
literal|1193180
operator|/
name|ipitch
expr_stmt|;
operator|*
name|odur
operator|=
name|idur
operator|*
name|hz
operator|/
literal|1000
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|int
name|pc_xmode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* someone looks for this in the symbol table */
end_comment

begin_function
name|int
name|kbd_setxserveriopl
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|struct
name|syscframe
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* do we have the necessary privilege? */
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|curproc
operator|->
name|p_ucred
argument_list|,
operator|&
name|curproc
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* we have it, caller knows what he does :-) */
name|fp
operator|=
operator|(
expr|struct
name|syscframe
operator|*
operator|)
name|curproc
operator|->
name|p_regs
expr_stmt|;
if|if
condition|(
name|mode
condition|)
block|{
comment|/* switch on */
if|if
condition|(
name|pc_xmode
condition|)
return|return
literal|0
return|;
name|pc_xmode
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|sf_eflags
operator||=
name|PSL_IOPL
expr_stmt|;
name|vga_doblanking
argument_list|(
name|BLANKSTOP
argument_list|)
expr_stmt|;
comment|/* does not really belong here */
block|}
else|else
block|{
comment|/* switch off */
if|if
condition|(
operator|!
name|pc_xmode
condition|)
return|return
literal|0
return|;
name|pc_xmode
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|sf_eflags
operator|&=
operator|~
name|PSL_IOPL
expr_stmt|;
name|vga_doblanking
argument_list|(
name|BLANKSTART
argument_list|)
expr_stmt|;
comment|/* does not really belong here */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPC=0 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCO=1 */
end_comment

end_unit

