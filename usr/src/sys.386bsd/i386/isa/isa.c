begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)isa.c	7.2 (Berkeley) 5/13/91  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         2       00117  * --------------------         -----   ----------------------  *  * 18 Aug 92	Frank Maclachlan	*See comments below  * 25 Mar 93	Rodney W. Grimes	Added counter for stray interrupt,  *					turned on logging of stray interrupts,  *					Now prints maddr, msize, and flags  *					after finding a device.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/src/sys.386bsd/i386/isa/RCS/isa.c,v 1.2 92/01/21 14:34:23 william Exp Locker: root $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * code to manage AT bus  *  * 92/08/18  Frank P. MacLachlan (fpm@crash.cts.com):  * Fixed uninitialized variable problem and added code to deal  * with DMA page boundaries in isa_dmarangecheck().  Fixed word  * mode DMA count compution and reorganized DMA setup code in  * isa_dmastart()  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"rlist.h"
end_include

begin_include
include|#
directive|include
file|"machine/segments.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/icu.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/ic/i8237.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/ic/i8042.h"
end_include

begin_comment
comment|/* **  Register definitions for DMA controller 1 (channels 0..3): */
end_comment

begin_define
define|#
directive|define
name|DMA1_CHN
parameter_list|(
name|c
parameter_list|)
value|(IO_DMA1 + 1*(2*(c)))
end_define

begin_comment
comment|/* addr reg for channel c */
end_comment

begin_define
define|#
directive|define
name|DMA1_SMSK
value|(IO_DMA1 + 1*10)
end_define

begin_comment
comment|/* single mask register */
end_comment

begin_define
define|#
directive|define
name|DMA1_MODE
value|(IO_DMA1 + 1*11)
end_define

begin_comment
comment|/* mode register */
end_comment

begin_define
define|#
directive|define
name|DMA1_FFC
value|(IO_DMA1 + 1*12)
end_define

begin_comment
comment|/* clear first/last FF */
end_comment

begin_comment
comment|/* **  Register definitions for DMA controller 2 (channels 4..7): */
end_comment

begin_define
define|#
directive|define
name|DMA2_CHN
parameter_list|(
name|c
parameter_list|)
value|(IO_DMA1 + 2*(2*(c)))
end_define

begin_comment
comment|/* addr reg for channel c */
end_comment

begin_define
define|#
directive|define
name|DMA2_SMSK
value|(IO_DMA2 + 2*10)
end_define

begin_comment
comment|/* single mask register */
end_comment

begin_define
define|#
directive|define
name|DMA2_MODE
value|(IO_DMA2 + 2*11)
end_define

begin_comment
comment|/* mode register */
end_comment

begin_define
define|#
directive|define
name|DMA2_FFC
value|(IO_DMA2 + 2*12)
end_define

begin_comment
comment|/* clear first/last FF */
end_comment

begin_function_decl
name|int
name|config_isadev
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|u_short
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_decl_stmt
name|struct
name|rlist
modifier|*
name|isa_iomem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Configure all ISA devices  */
end_comment

begin_macro
name|isa_configure
argument_list|()
end_macro

begin_block
block|{
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
name|struct
name|isa_driver
modifier|*
name|dp
decl_stmt|;
name|splhigh
argument_list|()
expr_stmt|;
name|INTREN
argument_list|(
name|IRQ_SLAVE
argument_list|)
expr_stmt|;
comment|/*rlist_free(&isa_iomem, 0xa0000, 0xfffff);*/
for|for
control|(
name|dvp
operator|=
name|isa_devtab_tty
init|;
name|dvp
condition|;
name|dvp
operator|++
control|)
operator|(
name|void
operator|)
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|&
name|ttymask
argument_list|)
expr_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_bio
init|;
name|dvp
condition|;
name|dvp
operator|++
control|)
operator|(
name|void
operator|)
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|&
name|biomask
argument_list|)
expr_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_net
init|;
name|dvp
condition|;
name|dvp
operator|++
control|)
operator|(
name|void
operator|)
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|&
name|netmask
argument_list|)
expr_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_null
init|;
name|dvp
condition|;
name|dvp
operator|++
control|)
operator|(
name|void
operator|)
name|config_isadev
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
include|#
directive|include
file|"sl.h"
if|#
directive|if
name|NSL
operator|>
literal|0
name|netmask
operator||=
name|ttymask
expr_stmt|;
name|ttymask
operator||=
name|netmask
expr_stmt|;
endif|#
directive|endif
comment|/* printf("biomask %x ttymask %x netmask %x\n", biomask, ttymask, netmask); */
name|splnone
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Configure an ISA device.  */
end_comment

begin_macro
name|config_isadev
argument_list|(
argument|isdp
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|isdp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|isa_driver
modifier|*
name|dp
decl_stmt|;
specifier|static
name|short
name|drqseen
decl_stmt|,
name|irqseen
decl_stmt|;
if|if
condition|(
name|dp
operator|=
name|isdp
operator|->
name|id_driver
condition|)
block|{
comment|/* if a device with i/o memory, convert to virtual address */
if|if
condition|(
name|isdp
operator|->
name|id_maddr
condition|)
block|{
specifier|extern
name|unsigned
name|int
name|atdevbase
decl_stmt|;
name|isdp
operator|->
name|id_maddr
operator|-=
name|IOM_BEGIN
expr_stmt|;
name|isdp
operator|->
name|id_maddr
operator|+=
name|atdevbase
expr_stmt|;
block|}
name|isdp
operator|->
name|id_alive
operator|=
call|(
modifier|*
name|dp
operator|->
name|probe
call|)
argument_list|(
name|isdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_alive
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d at port 0x%x "
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|isdp
operator|->
name|id_unit
argument_list|,
name|isdp
operator|->
name|id_iobase
argument_list|)
expr_stmt|;
comment|/* check for conflicts */
if|if
condition|(
name|irqseen
operator|&
name|isdp
operator|->
name|id_irq
condition|)
block|{
name|printf
argument_list|(
literal|"INTERRUPT CONFLICT - irq%d\n"
argument_list|,
name|ffs
argument_list|(
name|isdp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|isdp
operator|->
name|id_drq
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|drqseen
operator|&
operator|(
literal|1
operator|<<
name|isdp
operator|->
name|id_drq
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"DMA CONFLICT - drq%d\n"
argument_list|,
name|isdp
operator|->
name|id_drq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* NEED TO CHECK IOMEM CONFLICT HERE */
comment|/* allocate and wire in device */
if|if
condition|(
name|isdp
operator|->
name|id_irq
condition|)
block|{
name|int
name|intrno
decl_stmt|;
name|intrno
operator|=
name|ffs
argument_list|(
name|isdp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"irq %d "
argument_list|,
name|intrno
argument_list|)
expr_stmt|;
name|INTREN
argument_list|(
name|isdp
operator|->
name|id_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
name|INTRMASK
argument_list|(
operator|*
name|mp
argument_list|,
name|isdp
operator|->
name|id_irq
argument_list|)
expr_stmt|;
name|setidt
argument_list|(
name|NRSVIDT
operator|+
name|intrno
argument_list|,
name|isdp
operator|->
name|id_intr
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|irqseen
operator||=
name|isdp
operator|->
name|id_irq
expr_stmt|;
block|}
if|if
condition|(
name|isdp
operator|->
name|id_drq
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"drq %d "
argument_list|,
name|isdp
operator|->
name|id_drq
argument_list|)
expr_stmt|;
name|drqseen
operator||=
literal|1
operator|<<
name|isdp
operator|->
name|id_drq
expr_stmt|;
block|}
call|(
modifier|*
name|dp
operator|->
name|attach
call|)
argument_list|(
name|isdp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"on isa\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* notyet */
end_comment

begin_comment
comment|/*  * Configure all ISA devices  */
end_comment

begin_macro
name|isa_configure
argument_list|()
end_macro

begin_block
block|{
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
name|struct
name|isa_driver
modifier|*
name|dp
decl_stmt|;
name|splhigh
argument_list|()
expr_stmt|;
name|INTREN
argument_list|(
name|IRQ_SLAVE
argument_list|)
expr_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_tty
init|;
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|&
name|ttymask
argument_list|)
condition|;
name|dvp
operator|++
control|)
empty_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_bio
init|;
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|&
name|biomask
argument_list|)
condition|;
name|dvp
operator|++
control|)
empty_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_net
init|;
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|&
name|netmask
argument_list|)
condition|;
name|dvp
operator|++
control|)
empty_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_null
init|;
name|config_isadev
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|)
condition|;
name|dvp
operator|++
control|)
empty_stmt|;
include|#
directive|include
file|"sl.h"
if|#
directive|if
name|NSL
operator|>
literal|0
name|netmask
operator||=
name|ttymask
expr_stmt|;
name|ttymask
operator||=
name|netmask
expr_stmt|;
endif|#
directive|endif
comment|/* biomask |= ttymask ;  can some tty devices use buffers? */
comment|/* printf("biomask %x ttymask %x netmask %x\n", biomask, ttymask, netmask); */
name|splnone
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Configure an ISA device.  */
end_comment

begin_macro
name|config_isadev
argument_list|(
argument|isdp
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|isdp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|isa_driver
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|dp
operator|=
name|isdp
operator|->
name|id_driver
condition|)
block|{
if|if
condition|(
name|isdp
operator|->
name|id_maddr
condition|)
block|{
specifier|extern
name|u_int
name|atdevbase
decl_stmt|;
name|isdp
operator|->
name|id_maddr
operator|-=
literal|0xa0000
expr_stmt|;
name|isdp
operator|->
name|id_maddr
operator|+=
name|atdevbase
expr_stmt|;
block|}
name|isdp
operator|->
name|id_alive
operator|=
call|(
modifier|*
name|dp
operator|->
name|probe
call|)
argument_list|(
name|isdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_alive
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d"
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|isdp
operator|->
name|id_unit
argument_list|)
expr_stmt|;
comment|/* 			 * The attach should really be after all the printf's 			 * but until all the drivers are fixed do it here. 			 * There is a comment below that shows where this 			 * really belongs.  Rod Grimes 04/10/93 			 */
call|(
modifier|*
name|dp
operator|->
name|attach
call|)
argument_list|(
name|isdp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" at 0x%x"
argument_list|,
name|isdp
operator|->
name|id_iobase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isdp
operator|->
name|id_iobase
operator|+
name|isdp
operator|->
name|id_alive
operator|-
literal|1
operator|)
operator|!=
name|isdp
operator|->
name|id_iobase
condition|)
name|printf
argument_list|(
literal|"-0x%x"
argument_list|,
name|isdp
operator|->
name|id_iobase
operator|+
name|isdp
operator|->
name|id_alive
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_irq
condition|)
name|printf
argument_list|(
literal|"irq %d "
argument_list|,
name|ffs
argument_list|(
name|isdp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_drq
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"drq %d "
argument_list|,
name|isdp
operator|->
name|id_drq
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_maddr
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"maddr 0x%x "
argument_list|,
name|kvtop
argument_list|(
name|isdp
operator|->
name|id_maddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_msize
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"msize %d "
argument_list|,
name|isdp
operator|->
name|id_msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_flags
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"flags 0x%x "
argument_list|,
name|isdp
operator|->
name|id_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"on isa\n"
argument_list|)
expr_stmt|;
comment|/* This is the place the attach should be done! */
if|if
condition|(
name|isdp
operator|->
name|id_irq
condition|)
block|{
name|int
name|intrno
decl_stmt|;
name|intrno
operator|=
name|ffs
argument_list|(
name|isdp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
expr_stmt|;
name|INTREN
argument_list|(
name|isdp
operator|->
name|id_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
name|INTRMASK
argument_list|(
operator|*
name|mp
argument_list|,
name|isdp
operator|->
name|id_irq
argument_list|)
expr_stmt|;
name|setidt
argument_list|(
name|ICU_OFFSET
operator|+
name|intrno
argument_list|,
name|isdp
operator|->
name|id_intr
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (!) notyet */
end_comment

begin_define
define|#
directive|define
name|IDTVEC
parameter_list|(
name|name
parameter_list|)
value|__CONCAT(X,name)
end_define

begin_comment
comment|/* default interrupt vector table entries */
end_comment

begin_extern
extern|extern	IDTVEC(intr0
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|IDTVEC
argument_list|(
name|intr1
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr2
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr3
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr4
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr5
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr6
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr7
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr8
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr9
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr10
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr11
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr12
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr13
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr14
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr15
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
operator|*
name|defvec
index|[
literal|16
index|]
operator|=
block|{
operator|&
name|IDTVEC
argument_list|(
name|intr0
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr1
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr2
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr3
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr4
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr5
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr6
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr7
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr8
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr9
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr10
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr11
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr12
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr13
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr14
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
argument|intr15
argument_list|)
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* out of range default interrupt vector gate entry */
end_comment

begin_extern
extern|extern	IDTVEC(intrdefault
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * Fill in default interrupt table (in case of spuruious interrupt  * during configuration of kernel, setup interrupt control unit  */
end_comment

begin_macro
name|isa_defaultirq
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* icu vectors */
for|for
control|(
name|i
operator|=
name|NRSVIDT
init|;
name|i
operator|<
name|NRSVIDT
operator|+
name|ICU_LEN
condition|;
name|i
operator|++
control|)
name|setidt
argument_list|(
name|i
argument_list|,
name|defvec
index|[
name|i
index|]
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
comment|/* out of range vectors */
for|for
control|(
name|i
operator|=
name|NRSVIDT
init|;
name|i
operator|<
name|NIDT
condition|;
name|i
operator|++
control|)
name|setidt
argument_list|(
name|i
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intrdefault
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
comment|/* clear npx intr latch */
name|outb
argument_list|(
literal|0xf1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* initialize 8259's */
name|outb
argument_list|(
name|IO_ICU1
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
comment|/* reset; program device, four bytes */
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|,
name|NRSVIDT
argument_list|)
expr_stmt|;
comment|/* starting at this vector index */
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|,
literal|1
operator|<<
literal|2
argument_list|)
expr_stmt|;
comment|/* slave on line 2 */
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 8086 mode */
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* leave interrupts masked */
name|outb
argument_list|(
name|IO_ICU1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* default to ISR on read */
name|outb
argument_list|(
name|IO_ICU2
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
comment|/* reset; program device, four bytes */
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|,
name|NRSVIDT
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* staring at this vector index */
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* my slave id is 2 */
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 8086 mode */
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* leave interrupts masked */
name|outb
argument_list|(
name|IO_ICU2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* default to ISR on read */
block|}
end_block

begin_comment
comment|/* region of physical memory known to be contiguous */
end_comment

begin_decl_stmt
name|vm_offset_t
name|isaphysmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|caddr_t
name|dma_bounce
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|static
name|char
name|bounced
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|MAXDMASZ
value|512
end_define

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/* high byte of address is stored in this port for i-th dma channel */
end_comment

begin_decl_stmt
specifier|static
name|short
name|dmapageport
index|[
literal|8
index|]
init|=
block|{
literal|0x87
block|,
literal|0x83
block|,
literal|0x81
block|,
literal|0x82
block|,
literal|0x8f
block|,
literal|0x8b
block|,
literal|0x89
block|,
literal|0x8a
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * isa_dmacascade(): program 8237 DMA controller channel to accept  * external dma control by a board.  */
end_comment

begin_function
name|void
name|isa_dmacascade
parameter_list|(
name|unsigned
name|chan
parameter_list|)
block|{
if|if
condition|(
name|chan
operator|>
literal|7
condition|)
name|panic
argument_list|(
literal|"isa_dmacascade: impossible request"
argument_list|)
expr_stmt|;
comment|/* set dma channel mode, and set dma channel mode */
if|if
condition|(
operator|(
name|chan
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
name|DMA1_MODE
argument_list|,
name|DMA37MD_CASCADE
operator||
name|chan
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMA1_SMSK
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|DMA2_MODE
argument_list|,
name|DMA37MD_CASCADE
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMA2_SMSK
argument_list|,
name|chan
operator|&
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * isa_dmastart(): program 8237 DMA controller channel, avoid page alignment  * problems by using a bounce buffer.  */
end_comment

begin_function
name|void
name|isa_dmastart
parameter_list|(
name|int
name|flags
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|unsigned
name|nbytes
parameter_list|,
name|unsigned
name|chan
parameter_list|)
block|{
name|vm_offset_t
name|phys
decl_stmt|;
name|int
name|waport
decl_stmt|;
name|caddr_t
name|newaddr
decl_stmt|;
if|if
condition|(
name|chan
operator|>
literal|7
operator|||
operator|(
name|chan
operator|<
literal|4
operator|&&
name|nbytes
operator|>
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|)
operator|||
operator|(
name|chan
operator|>=
literal|4
operator|&&
operator|(
name|nbytes
operator|>
operator|(
literal|1
operator|<<
literal|17
operator|)
operator|||
operator|(
name|u_int
operator|)
name|addr
operator|&
literal|1
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"isa_dmastart: impossible request"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isa_dmarangecheck
argument_list|(
name|addr
argument_list|,
name|nbytes
argument_list|,
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|dma_bounce
index|[
name|chan
index|]
operator|==
literal|0
condition|)
name|dma_bounce
index|[
name|chan
index|]
operator|=
comment|/*(caddr_t)malloc(MAXDMASZ, M_TEMP, M_WAITOK);*/
operator|(
name|caddr_t
operator|)
name|isaphysmem
operator|+
name|NBPG
operator|*
name|chan
expr_stmt|;
name|bounced
index|[
name|chan
index|]
operator|=
literal|1
expr_stmt|;
name|newaddr
operator|=
name|dma_bounce
index|[
name|chan
index|]
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|newaddr
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
comment|/* copy bounce buffer on write */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|B_READ
operator|)
condition|)
name|bcopy
argument_list|(
name|addr
argument_list|,
name|newaddr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|addr
operator|=
name|newaddr
expr_stmt|;
block|}
comment|/* translate to physical */
name|phys
operator|=
name|pmap_extract
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chan
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Program one of DMA channels 0..3.  These are 		 * byte mode channels. 		 */
comment|/* set dma channel mode, and reset address ff */
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
name|outb
argument_list|(
name|DMA1_MODE
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_WRITE
operator||
name|chan
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|DMA1_MODE
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_READ
operator||
name|chan
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMA1_FFC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send start address */
name|waport
operator|=
name|DMA1_CHN
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|dmapageport
index|[
name|chan
index|]
argument_list|,
name|phys
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* send count */
name|outb
argument_list|(
name|waport
operator|+
literal|1
argument_list|,
operator|--
name|nbytes
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
operator|+
literal|1
argument_list|,
name|nbytes
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* unmask channel */
name|outb
argument_list|(
name|DMA1_SMSK
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Program one of DMA channels 4..7.  These are 		 * word mode channels. 		 */
comment|/* set dma channel mode, and reset address ff */
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
name|outb
argument_list|(
name|DMA2_MODE
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_WRITE
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|DMA2_MODE
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_READ
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMA2_FFC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send start address */
name|waport
operator|=
name|DMA2_CHN
argument_list|(
name|chan
operator|-
literal|4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
operator|>>
literal|9
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|dmapageport
index|[
name|chan
index|]
argument_list|,
name|phys
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* send count */
name|nbytes
operator|>>=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|waport
operator|+
literal|2
argument_list|,
operator|--
name|nbytes
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
operator|+
literal|2
argument_list|,
name|nbytes
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* unmask channel */
name|outb
argument_list|(
name|DMA2_SMSK
argument_list|,
name|chan
operator|&
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|isa_dmadone
parameter_list|(
name|int
name|flags
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
comment|/* copy bounce buffer on read */
comment|/*if ((flags& (B_PHYS|B_READ)) == (B_PHYS|B_READ))*/
if|if
condition|(
name|bounced
index|[
name|chan
index|]
condition|)
block|{
name|bcopy
argument_list|(
name|dma_bounce
index|[
name|chan
index|]
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|bounced
index|[
name|chan
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check for problems with the address range of a DMA transfer  * (non-contiguous physical pages, outside of bus address space,  * crossing DMA page boundaries).  * Return true if special handling needed.  */
end_comment

begin_macro
name|isa_dmarangecheck
argument_list|(
argument|caddr_t va
argument_list|,
argument|unsigned length
argument_list|,
argument|unsigned chan
argument_list|)
end_macro

begin_block
block|{
name|vm_offset_t
name|phys
decl_stmt|,
name|priorpage
init|=
literal|0
decl_stmt|,
name|endva
decl_stmt|;
name|u_int
name|dma_pgmsk
init|=
operator|(
name|chan
operator|&
literal|4
operator|)
condition|?
operator|~
operator|(
literal|128
operator|*
literal|1024
operator|-
literal|1
operator|)
else|:
operator|~
operator|(
literal|64
operator|*
literal|1024
operator|-
literal|1
operator|)
decl_stmt|;
name|endva
operator|=
operator|(
name|vm_offset_t
operator|)
name|round_page
argument_list|(
name|va
operator|+
name|length
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|va
operator|<
operator|(
name|caddr_t
operator|)
name|endva
condition|;
name|va
operator|+=
name|NBPG
control|)
block|{
name|phys
operator|=
name|trunc_page
argument_list|(
name|pmap_extract
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|ISARAM_END
value|RAM_END
if|if
condition|(
name|phys
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"isa_dmacheck: no physical page present"
argument_list|)
expr_stmt|;
if|if
condition|(
name|phys
operator|>
name|ISARAM_END
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|priorpage
condition|)
block|{
if|if
condition|(
name|priorpage
operator|+
name|NBPG
operator|!=
name|phys
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* check if crossing a DMA page boundary */
if|if
condition|(
operator|(
operator|(
name|u_int
operator|)
name|priorpage
operator|^
operator|(
name|u_int
operator|)
name|phys
operator|)
operator|&
name|dma_pgmsk
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|priorpage
operator|=
name|phys
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* head of queue waiting for physmem to become available */
end_comment

begin_decl_stmt
name|struct
name|buf
name|isa_physmemq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* blocked waiting for resource to become free for exclusive use */
end_comment

begin_expr_stmt
specifier|static
name|isaphysmemflag
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* if waited for and call requested when free (B_CALL) */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|isaphysmemunblock
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* needs to be a list */
end_comment

begin_comment
comment|/*  * Allocate contiguous physical memory for transfer, returning  * a *virtual* address to region. May block waiting for resource.  * (assumed to be called at splbio())  */
end_comment

begin_function
name|caddr_t
name|isa_allocphysmem
parameter_list|(
name|caddr_t
name|va
parameter_list|,
name|unsigned
name|length
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
parameter_list|)
block|{
name|isaphysmemunblock
operator|=
name|func
expr_stmt|;
while|while
condition|(
name|isaphysmemflag
operator|&
name|B_BUSY
condition|)
block|{
name|isaphysmemflag
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|&
name|isaphysmemflag
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|isaphysmemflag
operator||=
name|B_BUSY
expr_stmt|;
return|return
operator|(
operator|(
name|caddr_t
operator|)
name|isaphysmem
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free contiguous physical memory used for transfer.  * (assumed to be called at splbio())  */
end_comment

begin_function
name|void
name|isa_freephysmem
parameter_list|(
name|caddr_t
name|va
parameter_list|,
name|unsigned
name|length
parameter_list|)
block|{
name|isaphysmemflag
operator|&=
operator|~
name|B_BUSY
expr_stmt|;
if|if
condition|(
name|isaphysmemflag
operator|&
name|B_WANTED
condition|)
block|{
name|isaphysmemflag
operator|&=
name|B_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|isaphysmemflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|isaphysmemunblock
condition|)
call|(
modifier|*
name|isaphysmemunblock
call|)
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle a NMI, possibly a machine check.  * return true to panic system, false to ignore.  */
end_comment

begin_macro
name|isa_nmi
argument_list|(
argument|cd
argument_list|)
end_macro

begin_block
block|{
name|log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"\nNMI port 61 %x, port 70 %x\n"
argument_list|,
name|inb
argument_list|(
literal|0x61
argument_list|)
argument_list|,
name|inb
argument_list|(
literal|0x70
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Caught a stray interrupt, notify  */
end_comment

begin_macro
name|isa_strayintr
argument_list|(
argument|d
argument_list|)
end_macro

begin_block
block|{
comment|/* DON'T BOTHER FOR NOW! */
comment|/* for some reason, we get bursts of intr #7, even if not enabled! */
comment|/* 	 * Well the reason you got bursts of intr #7 is because someone 	 * raised an interrupt line and dropped it before the 8259 could 	 * prioritize it.  This is documented in the intel data book.  This 	 * means you have BAD hardware!  I have changed this so that only 	 * the first 5 get logged, then it quits logging them, and puts 	 * out a special message. rgrimes 3/25/1993 	 */
specifier|extern
name|u_long
name|isa_stray_intrcnt
decl_stmt|;
name|isa_stray_intrcnt
operator|++
expr_stmt|;
if|if
condition|(
name|isa_stray_intrcnt
operator|<=
literal|5
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ISA strayintr %x\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|isa_stray_intrcnt
operator|==
literal|5
condition|)
name|log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"Too many ISA strayintr not logging any more\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Wait "n" microseconds. Relies on timer 0 to have 1Mhz clock, regardless  * of processor board speed. Note: timer had better have been programmed  * before this is first used!  */
end_comment

begin_macro
name|DELAY
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|int
name|tick
init|=
name|getit
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|&
literal|1
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
comment|/* wait approximately 1 micro second */
while|while
condition|(
name|tick
operator|==
name|getit
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|&
literal|1
condition|)
empty_stmt|;
name|tick
operator|=
name|getit
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|&
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|getit
argument_list|(
argument|unit
argument_list|,
argument|timer
argument_list|)
end_macro

begin_block
block|{
name|int
name|port
init|=
operator|(
name|unit
condition|?
name|IO_TIMER2
else|:
name|IO_TIMER1
operator|)
operator|+
name|timer
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|inb
argument_list|(
name|port
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|val
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|beeping
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|sysbeepstop
argument_list|(
argument|f
argument_list|)
block|{
comment|/* disable counter 2 */
name|outb
argument_list|(
literal|0x61
argument_list|,
name|inb
argument_list|(
literal|0x61
argument_list|)
operator|&
literal|0xFC
argument_list|)
block|;
if|if
condition|(
name|f
condition|)
name|timeout
argument_list|(
name|sysbeepstop
argument_list|,
literal|0
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|else
name|beeping
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_function
name|void
name|sysbeep
parameter_list|(
name|int
name|pitch
parameter_list|,
name|int
name|period
parameter_list|)
block|{
name|outb
argument_list|(
literal|0x61
argument_list|,
name|inb
argument_list|(
literal|0x61
argument_list|)
operator||
literal|3
argument_list|)
expr_stmt|;
comment|/* enable counter 2 */
name|outb
argument_list|(
literal|0x43
argument_list|,
literal|0xb6
argument_list|)
expr_stmt|;
comment|/* set command for counter 2, 2 byte write */
name|outb
argument_list|(
literal|0x42
argument_list|,
name|pitch
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x42
argument_list|,
operator|(
name|pitch
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|beeping
condition|)
block|{
name|beeping
operator|=
name|period
expr_stmt|;
name|timeout
argument_list|(
name|sysbeepstop
argument_list|,
name|period
operator|/
literal|2
argument_list|,
name|period
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Pass command to keyboard controller (8042)  */
end_comment

begin_function
name|unsigned
name|kbc_8042cmd
parameter_list|(
name|val
parameter_list|)
block|{
while|while
condition|(
name|inb
argument_list|(
name|KBSTATP
argument_list|)
operator|&
name|KBS_IBF
condition|)
empty_stmt|;
if|if
condition|(
name|val
condition|)
name|outb
argument_list|(
name|KBCMDP
argument_list|,
name|val
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|KBSTATP
argument_list|)
operator|&
name|KBS_IBF
condition|)
empty_stmt|;
return|return
operator|(
name|inb
argument_list|(
name|KBDATAP
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

