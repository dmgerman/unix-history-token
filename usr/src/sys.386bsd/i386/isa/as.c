begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Adaptech 1542 SCSI driver for 386bsd  *  * Pace Willisson     pace@blitz.com    March 28, 1992  *  * Placed in the public domain with NO WARRANTIES, not even the  * implied warranties for MERCHANTABILITY or FITNESS FOR A   * PARTICULAR PURPOSE.  *  *  * This is a very early version - use with care.  *  * Here is the config info:  *  * controller	as0	at isa? port 0x330 bio irq 11 drq 5 vector asintr  * disk		dk6	at as0 drive 0   *  * Also, don't forget to update sys/i386/conf/files.i386.  *  * So far, used with:  *  *   CDC WREN 5 600 Megabyte magnetic disk  *   EXABYTE EXB-8200 8mm tape drive  *   SONY CDU-541 cdrom  *  * The the tape stuff still needs a lot of working concerning  * file marks, end of tape handling and rewinding, but I have  * extracted tar tapes to a file system mounted on the CDC disk.  *  * minor number bits:  *  *      7  6  5  4  3  2  1  0  *                     +-----+  partition number  *            +-----+           scsi target number  *      +--+                    unused (should be 0)  *  * For tape drives, set the partition number to 0 for regular,  * 1 for no rewind.  *  * Only supports LUN 0.  *  * To use with a read-write disk, first use diskpart to create  * a disktab entry, then use disklabel.  Since I don't have  * the boot programs done yet, I faked it with:  *  *		# cd /usr/mdec  *		# cp wdboot asboot  *		# cp bootwd bootas  *  * Now you can run disklabel, newfs, etc.  *  * Please send patches and names other perpherials that work to  * pace@blitz.com.  If you have trouble that you can't fix, please  * wait for the next release before contacting me.  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         1       00088  * --------------------         -----   ----------------------  *  * 23 Oct 92	Joerg Lohse		changed ccb opcode for compatibility  *					with Adaptec AHA-1542A  * 27 Feb 93	James da Silva		Tapedrive fixes.   */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_if
if|#
directive|if
name|NAS
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"dkbad.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"disklabel.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/icu.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"asreg.h"
end_include

begin_function_decl
name|int
name|asstrategy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|asabort
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|asverbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target id 7 is the controller itself */
end_comment

begin_define
define|#
directive|define
name|NTARGETS
value|7
end_define

begin_decl_stmt
name|struct
name|mailbox_entry
name|mailboxes
index|[
name|NTARGETS
operator|*
literal|2
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_comment
comment|/* fake cylinder number for disksort */
end_comment

begin_comment
comment|/* maximum scatter list size for Adaptech controller */
end_comment

begin_define
define|#
directive|define
name|NSCATTER
value|17
end_define

begin_comment
comment|/* this array must reside in contiguous physical memory */
end_comment

begin_struct
struct|struct
name|asinfo
block|{
name|dev_t
name|dev
decl_stmt|;
name|struct
name|buf
name|requests
decl_stmt|;
name|struct
name|mailbox_entry
modifier|*
name|mailbox
decl_stmt|;
name|int
name|active
decl_stmt|;
name|struct
name|ccb
name|ccb
decl_stmt|;
name|unsigned
name|int
name|ccb_phys
decl_stmt|;
name|char
name|scatter_list
index|[
name|NSCATTER
operator|*
literal|6
index|]
decl_stmt|;
name|struct
name|disklabel
name|label
decl_stmt|;
name|struct
name|dos_partition
name|dospart
index|[
name|NDOSPART
index|]
decl_stmt|;
name|int
name|have_label
decl_stmt|;
name|int
name|scsi_lock
decl_stmt|;
name|struct
name|buf
modifier|*
name|scsi_bp
decl_stmt|;
name|int
name|scsi_cdb_len
decl_stmt|;
name|unsigned
name|char
name|scsi_cdb
index|[
name|MAXCDB
index|]
decl_stmt|;
name|int
name|tape
decl_stmt|;
comment|/* sequential */
name|int
name|disk
decl_stmt|;
comment|/* nonsequential */
name|int
name|read_only
decl_stmt|;
comment|/* CDROM */
name|int
name|removable
decl_stmt|;
comment|/* unsupported and tested */
name|char
name|vendor
index|[
literal|9
index|]
decl_stmt|;
name|char
name|model
index|[
literal|17
index|]
decl_stmt|;
name|char
name|revision
index|[
literal|5
index|]
decl_stmt|;
name|int
name|bs
decl_stmt|;
comment|/* device block size */
name|int
name|open_lock
decl_stmt|;
name|int
name|open
decl_stmt|;
name|int
name|units_open
decl_stmt|;
name|int
name|wlabel
decl_stmt|;
name|int
name|retry_count
decl_stmt|;
name|int
name|start_time
decl_stmt|;
name|int
name|restart_pending
decl_stmt|;
block|}
name|asinfo
index|[
name|NTARGETS
index|]
init|=
block|{
literal|0
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|dev_part
parameter_list|(
name|dev
parameter_list|)
value|(minor (dev)& 7)
end_define

begin_define
define|#
directive|define
name|dev_target
parameter_list|(
name|dev
parameter_list|)
value|((minor (dev)>> 3)& 7)
end_define

begin_define
define|#
directive|define
name|dev_rewind
parameter_list|(
name|dev
parameter_list|)
value|((minor (dev)& 1) == 0)
end_define

begin_define
define|#
directive|define
name|makeasdev
parameter_list|(
name|major
parameter_list|,
name|target
parameter_list|,
name|part
parameter_list|)
define|\
value|makedev ((major), ((target)<< 3) | (part))
end_define

begin_decl_stmt
name|int
name|as_port
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|asprobe
argument_list|(
expr|struct
name|isa_device
operator|*
argument_list|)
decl_stmt|,
name|asattach
argument_list|(
expr|struct
name|isa_device
operator|*
argument_list|)
decl_stmt|,
name|asintr
argument_list|(
name|dev_t
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|asdriver
init|=
block|{
name|asprobe
block|,
name|asattach
block|,
literal|"as"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|asprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|as_port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|outb
argument_list|(
name|as_port
operator|+
name|AS_CONTROL
argument_list|,
name|AS_CONTROL_SRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30000
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|as_port
operator|+
name|AS_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|(
name|AS_STATUS_INIT
operator||
name|AS_STATUS_IDLE
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|as_port
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|asattach
argument_list|(
argument|struct isa_device *dvp
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|physaddr
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTARGETS
condition|;
name|i
operator|++
control|)
block|{
name|asinfo
index|[
name|i
index|]
operator|.
name|mailbox
operator|=
operator|&
name|mailboxes
index|[
name|i
index|]
expr_stmt|;
name|asinfo
index|[
name|i
index|]
operator|.
name|ccb_phys
operator|=
name|vtophys
argument_list|(
operator|&
name|asinfo
index|[
name|i
index|]
operator|.
name|ccb
argument_list|)
expr_stmt|;
block|}
name|isa_dmacascade
argument_list|(
name|dvp
operator|->
name|id_drq
argument_list|)
expr_stmt|;
name|physaddr
operator|=
name|vtophys
argument_list|(
name|mailboxes
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|as_put_byte
argument_list|(
name|AS_CMD_MAILBOX_INIT
argument_list|)
operator|<
literal|0
operator|||
name|as_put_byte
argument_list|(
name|NTARGETS
argument_list|)
operator|<
literal|0
operator|||
name|as_put_byte
argument_list|(
name|physaddr
operator|>>
literal|16
argument_list|)
operator|<
literal|0
operator|||
name|as_put_byte
argument_list|(
name|physaddr
operator|>>
literal|8
argument_list|)
operator|<
literal|0
operator|||
name|as_put_byte
argument_list|(
name|physaddr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|as_port
operator|+
name|AS_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|AS_STATUS_INIT
condition|)
name|printf
argument_list|(
literal|"as: mailbox init error: 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|ascmd
parameter_list|(
name|as
parameter_list|,
name|bp
parameter_list|,
name|direction
parameter_list|,
name|count
parameter_list|,
name|retrycount
parameter_list|)
name|struct
name|asinfo
modifier|*
name|as
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|direction
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|retrycount
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
do|do
block|{
if|if
condition|(
name|asverbose
condition|)
name|printf
argument_list|(
literal|"ascmd "
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|count
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_READ
operator||
name|B_ERROR
operator||
name|B_DONE
operator|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|B_READ
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_READ
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|as
operator|->
name|dev
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
literal|0
expr_stmt|;
name|as
operator|->
name|scsi_bp
operator|=
name|bp
expr_stmt|;
comment|/* scsi_cdb, scsi_cdb_len set up by caller */
name|asstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|err
operator|=
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|as
operator|->
name|scsi_bp
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|err
operator|&&
operator|--
name|retrycount
condition|)
do|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_macro
name|asstring
argument_list|(
argument|dest
argument_list|,
argument|src
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|src
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|size
operator|--
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
operator|&&
name|dest
index|[
name|size
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|size
operator|--
expr_stmt|;
name|dest
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|asopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|asinfo
modifier|*
name|as
decl_stmt|;
name|unsigned
name|int
name|physaddr
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cdb
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|vendor
index|[
literal|9
index|]
decl_stmt|;
name|char
name|model
index|[
literal|17
index|]
decl_stmt|;
name|int
name|disksize
decl_stmt|;
if|if
condition|(
name|as_port
operator|==
literal|0
operator|||
name|dev_target
argument_list|(
name|dev
argument_list|)
operator|>=
name|NTARGETS
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|as
operator|=
operator|&
name|asinfo
index|[
name|dev_target
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|as
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
while|while
condition|(
name|as
operator|->
name|open_lock
condition|)
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|as
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"scsiopen"
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|as
operator|->
name|open
condition|)
block|{
if|if
condition|(
name|as
operator|->
name|tape
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|as
operator|->
name|have_label
operator|==
literal|0
operator|&&
name|dev_part
argument_list|(
name|dev
argument_list|)
operator|!=
literal|3
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|as
operator|->
name|units_open
operator||=
literal|1
operator|<<
name|dev_part
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|as
operator|->
name|open_lock
operator|=
literal|1
expr_stmt|;
comment|/* it seems like we might have to block here in case someone 	 * opens the device just after someone else closes 	 */
while|while
condition|(
name|as
operator|->
name|scsi_lock
condition|)
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|as
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"scsicmd"
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|as
operator|->
name|scsi_lock
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
name|as
operator|->
name|have_label
operator|=
literal|0
expr_stmt|;
name|as
operator|->
name|tape
operator|=
literal|0
expr_stmt|;
name|as
operator|->
name|disk
operator|=
literal|0
expr_stmt|;
name|as
operator|->
name|read_only
operator|=
literal|0
expr_stmt|;
name|as
operator|->
name|removable
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|as
operator|->
name|vendor
argument_list|,
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|as
operator|->
name|model
argument_list|,
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|as
operator|->
name|vendor
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|as
operator|->
name|model
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|as
operator|->
name|revision
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|geteblk
argument_list|(
name|DEV_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|asverbose
condition|)
block|{
name|printf
argument_list|(
literal|"openbuf = 0x%x phys 0x%x\n"
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|vtophys
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mailboxes = 0x%x\n"
argument_list|,
name|mailboxes
argument_list|)
expr_stmt|;
block|}
comment|/* first, find out if a device is present, and just what it is */
name|as
operator|->
name|scsi_cdb_len
operator|=
literal|6
expr_stmt|;
name|cdb
operator|=
name|as
operator|->
name|scsi_cdb
expr_stmt|;
name|bzero
argument_list|(
name|cdb
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
literal|0x12
expr_stmt|;
comment|/* INQUIRY */
name|cdb
index|[
literal|4
index|]
operator|=
literal|255
expr_stmt|;
comment|/* allocation length */
if|if
condition|(
name|error
operator|=
name|ascmd
argument_list|(
name|as
argument_list|,
name|bp
argument_list|,
name|B_READ
argument_list|,
name|DEV_BSIZE
argument_list|,
literal|2
argument_list|)
condition|)
comment|/* does not respond to inquiry, obviously not CCS, give up */
goto|goto
name|done
goto|;
comment|/* blather on console about it */
name|p
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
if|if
condition|(
name|asverbose
condition|)
block|{
name|printf
argument_list|(
literal|"inquiry: "
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|20
condition|;
name|n
operator|++
control|)
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|p
index|[
name|n
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|40
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|n
index|]
operator|>=
literal|' '
operator|&&
name|p
index|[
name|n
index|]
operator|<
literal|0177
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|p
index|[
name|n
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal disk */
case|case
literal|4
case|:
comment|/* write once disk */
name|as
operator|->
name|disk
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* read only disk */
name|as
operator|->
name|read_only
operator|=
literal|1
expr_stmt|;
name|as
operator|->
name|disk
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* tape */
name|as
operator|->
name|tape
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x7f
case|:
name|printf
argument_list|(
literal|"logical unit not present\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
name|printf
argument_list|(
literal|"unknown peripheral device type: 0x%x\n"
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|as
operator|->
name|removable
operator|=
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0x80
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|n
operator|=
name|p
index|[
literal|4
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|31
condition|)
block|{
name|asstring
argument_list|(
name|as
operator|->
name|vendor
argument_list|,
name|p
operator|+
literal|8
argument_list|,
sizeof|sizeof
name|as
operator|->
name|vendor
argument_list|)
expr_stmt|;
name|asstring
argument_list|(
name|as
operator|->
name|model
argument_list|,
name|p
operator|+
literal|16
argument_list|,
sizeof|sizeof
name|as
operator|->
name|model
argument_list|)
expr_stmt|;
name|asstring
argument_list|(
name|as
operator|->
name|revision
argument_list|,
name|p
operator|+
literal|32
argument_list|,
sizeof|sizeof
name|as
operator|->
name|revision
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
name|as
operator|->
name|vendor
argument_list|,
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|bcmp
argument_list|(
name|as
operator|->
name|model
argument_list|,
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|model
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"as%d: attached tgt %d<%s %s %s> "
argument_list|,
literal|0
argument_list|,
name|dev_target
argument_list|(
name|dev
argument_list|)
argument_list|,
name|as
operator|->
name|vendor
argument_list|,
name|as
operator|->
name|model
argument_list|,
name|as
operator|->
name|revision
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|read_only
condition|)
name|printf
argument_list|(
literal|"readonly "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|as
operator|->
name|removable
condition|)
name|printf
argument_list|(
literal|"winchester "
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|tape
condition|)
name|printf
argument_list|(
literal|"tape "
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|disk
condition|)
name|printf
argument_list|(
literal|"disk "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* probe for desired block size */
comment|/* assume default of 512, except if CDROM (2048) */
if|if
condition|(
name|as
operator|->
name|read_only
condition|)
name|as
operator|->
name|bs
operator|=
literal|2048
expr_stmt|;
else|else
name|as
operator|->
name|bs
operator|=
literal|512
expr_stmt|;
name|bzero
argument_list|(
name|cdb
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
literal|0x1A
expr_stmt|;
comment|/* SCSI_MDSENSE */
name|cdb
index|[
literal|4
index|]
operator|=
literal|255
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|tape
operator|&&
name|ascmd
argument_list|(
name|as
argument_list|,
name|bp
argument_list|,
name|B_READ
argument_list|,
literal|12
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|minblk
decl_stmt|,
name|maxblk
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* blather about device more */
if|if
condition|(
name|bcmp
argument_list|(
name|as
operator|->
name|vendor
argument_list|,
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|bcmp
argument_list|(
name|as
operator|->
name|model
argument_list|,
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|model
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|printf
argument_list|(
literal|"as%d: data len %d medium %d speed/bufmode 0x%x desc len %d\n"
argument_list|,
name|dev_target
argument_list|(
name|dev
argument_list|)
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"as%d: density %d nblocks %d block len %d\n"
argument_list|,
name|dev_target
argument_list|(
name|dev
argument_list|)
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|,
operator|(
name|long
operator|)
name|p
index|[
literal|5
index|]
operator|*
literal|65536
operator|+
name|p
index|[
literal|6
index|]
operator|*
literal|256
operator|+
name|p
index|[
literal|7
index|]
argument_list|,
operator|(
name|long
operator|)
name|p
index|[
literal|9
index|]
operator|*
literal|65536
operator|+
name|p
index|[
literal|10
index|]
operator|*
literal|256
operator|+
name|p
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* obtain possible block sizes */
name|bzero
argument_list|(
name|cdb
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
literal|0x05
expr_stmt|;
comment|/* SCSI_RDLIMITS; */
if|if
condition|(
name|ascmd
argument_list|(
name|as
argument_list|,
name|bp
argument_list|,
name|B_READ
argument_list|,
literal|12
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|minblk
operator|=
name|p
index|[
literal|4
index|]
operator|*
literal|256
operator|+
name|p
index|[
literal|5
index|]
expr_stmt|;
name|maxblk
operator|=
name|p
index|[
literal|1
index|]
operator|*
literal|65536
operator|+
name|p
index|[
literal|2
index|]
operator|*
literal|256
operator|+
name|p
index|[
literal|3
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|bcmp
argument_list|(
name|as
operator|->
name|vendor
argument_list|,
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|bcmp
argument_list|(
name|as
operator|->
name|model
argument_list|,
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|model
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"as%d: limits: min block len %ld  max block len %ld\n"
argument_list|,
name|dev_target
argument_list|(
name|dev
argument_list|)
argument_list|,
name|minblk
argument_list|,
name|maxblk
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|minblk
operator|==
name|maxblk
condition|)
name|as
operator|->
name|bs
operator|=
name|minblk
expr_stmt|;
elseif|else
if|if
condition|(
name|as
operator|->
name|tape
condition|)
name|as
operator|->
name|bs
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|as
operator|->
name|scsi_cdb_len
operator|=
literal|10
expr_stmt|;
name|bzero
argument_list|(
name|cdb
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
literal|0x25
expr_stmt|;
comment|/* SCSI_READCAPACITY */
name|disksize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|disk
operator|&&
name|ascmd
argument_list|(
name|as
argument_list|,
name|bp
argument_list|,
name|B_READ
argument_list|,
literal|12
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|disksize
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|long
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|as
operator|->
name|bs
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|p
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asverbose
condition|)
name|printf
argument_list|(
literal|"block size %d disksize %d "
argument_list|,
name|as
operator|->
name|bs
argument_list|,
name|disksize
argument_list|)
expr_stmt|;
comment|/* for standard disk, negotiate block size */
if|if
condition|(
name|as
operator|->
name|read_only
operator|==
literal|0
operator|&&
name|as
operator|->
name|disk
condition|)
block|{
comment|/* do mode select to set the logical block size */
name|as
operator|->
name|scsi_cdb_len
operator|=
literal|6
expr_stmt|;
name|cdb
operator|=
name|as
operator|->
name|scsi_cdb
expr_stmt|;
name|bzero
argument_list|(
name|cdb
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
literal|0x15
expr_stmt|;
comment|/* MODE SELECT */
name|cdb
index|[
literal|4
index|]
operator|=
literal|12
expr_stmt|;
comment|/* parameter list length */
name|p
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|8
expr_stmt|;
comment|/* block descriptor length */
name|n
operator|=
name|as
operator|->
name|bs
operator|==
literal|1
condition|?
literal|0
else|:
name|as
operator|->
name|bs
expr_stmt|;
name|p
index|[
literal|9
index|]
operator|=
name|n
operator|>>
literal|16
expr_stmt|;
name|p
index|[
literal|10
index|]
operator|=
name|n
operator|>>
literal|8
expr_stmt|;
name|p
index|[
literal|11
index|]
operator|=
name|n
expr_stmt|;
operator|(
name|void
operator|)
name|ascmd
argument_list|(
name|as
argument_list|,
name|bp
argument_list|,
name|B_WRITE
argument_list|,
literal|12
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* device online and ready? */
name|as
operator|->
name|scsi_cdb_len
operator|=
literal|6
expr_stmt|;
name|bzero
argument_list|(
name|cdb
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
comment|/* SCSI_UNITRDY */
if|if
condition|(
name|error
operator|=
name|ascmd
argument_list|(
name|as
argument_list|,
name|bp
argument_list|,
name|B_READ
argument_list|,
literal|12
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"as%d: drive not online\n"
argument_list|,
name|dev_target
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|as
operator|->
name|disk
operator|&&
name|as
operator|->
name|read_only
operator|==
literal|0
condition|)
block|{
comment|/* read disk label */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|as
operator|->
name|label
argument_list|,
sizeof|sizeof
name|as
operator|->
name|label
argument_list|)
expr_stmt|;
name|as
operator|->
name|label
operator|.
name|d_secsize
operator|=
name|as
operator|->
name|bs
expr_stmt|;
name|as
operator|->
name|label
operator|.
name|d_secpercyl
operator|=
literal|64
operator|*
literal|32
expr_stmt|;
name|as
operator|->
name|label
operator|.
name|d_type
operator|=
name|DTYPE_SCSI
expr_stmt|;
comment|/* read label using "d" partition */
if|if
condition|(
operator|(
name|p
operator|=
name|readdisklabel
argument_list|(
name|makeasdev
argument_list|(
name|major
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev_target
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|3
argument_list|)
argument_list|,
name|asstrategy
argument_list|,
operator|&
name|as
operator|->
name|label
argument_list|,
name|as
operator|->
name|dospart
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as
operator|->
name|have_label
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|disksize
condition|)
block|{
name|as
operator|->
name|label
operator|.
name|d_subtype
operator|=
name|DSTYPE_GEOMETRY
expr_stmt|;
name|as
operator|->
name|label
operator|.
name|d_npartitions
operator|=
literal|3
expr_stmt|;
comment|/* partition 0  holds bios, partition 1 ESDI */
name|as
operator|->
name|label
operator|.
name|d_partitions
index|[
literal|2
index|]
operator|.
name|p_size
operator|=
name|disksize
expr_stmt|;
name|as
operator|->
name|label
operator|.
name|d_partitions
index|[
literal|2
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asverbose
operator|||
name|dev_part
argument_list|(
name|dev
argument_list|)
operator|!=
literal|3
condition|)
name|printf
argument_list|(
literal|"error reading label: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_part
argument_list|(
name|dev
argument_list|)
operator|!=
literal|3
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
comment|/* may want to set logical block size here ? */
name|error
operator|=
literal|0
expr_stmt|;
name|done
label|:
if|if
condition|(
name|bp
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|as
operator|->
name|open
operator|=
literal|1
expr_stmt|;
name|as
operator|->
name|open_lock
operator|=
literal|0
expr_stmt|;
name|as
operator|->
name|scsi_lock
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
name|as
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|asclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|asinfo
modifier|*
name|as
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cdb
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|as
operator|=
operator|&
name|asinfo
index|[
name|dev_target
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|as
operator|->
name|open_lock
condition|)
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|as
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"scsiclose"
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|as
operator|->
name|open_lock
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|tape
condition|)
block|{
while|while
condition|(
name|as
operator|->
name|scsi_lock
condition|)
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|as
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"scsicmd"
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|as
operator|->
name|scsi_lock
operator|=
literal|1
expr_stmt|;
name|bp
operator|=
name|geteblk
argument_list|(
name|DEV_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* presume user will use tape again */
name|as
operator|->
name|scsi_cdb_len
operator|=
literal|6
expr_stmt|;
name|cdb
operator|=
name|as
operator|->
name|scsi_cdb
expr_stmt|;
name|bzero
argument_list|(
name|cdb
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
literal|0x10
expr_stmt|;
comment|/* write filemarks */
name|cdb
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* one of them */
name|error
operator|=
name|ascmd
argument_list|(
name|as
argument_list|,
name|bp
argument_list|,
name|B_READ
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev_rewind
argument_list|(
name|dev
argument_list|)
operator|||
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* presumption error correction */
name|as
operator|->
name|scsi_cdb_len
operator|=
literal|6
expr_stmt|;
name|cdb
operator|=
name|as
operator|->
name|scsi_cdb
expr_stmt|;
name|bzero
argument_list|(
name|cdb
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
literal|0x10
expr_stmt|;
comment|/* write filemarks */
name|cdb
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* one of them */
name|error
operator||=
name|ascmd
argument_list|(
name|as
argument_list|,
name|bp
argument_list|,
name|B_READ
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|as
operator|->
name|scsi_cdb_len
operator|=
literal|6
expr_stmt|;
name|cdb
operator|=
name|as
operator|->
name|scsi_cdb
expr_stmt|;
name|bzero
argument_list|(
name|cdb
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
literal|0x1
expr_stmt|;
comment|/* rewind */
name|cdb
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* don't wait until done */
name|error
operator||=
name|ascmd
argument_list|(
name|as
argument_list|,
name|bp
argument_list|,
name|B_READ
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
block|}
else|else
block|{
name|cdb
index|[
literal|0
index|]
operator|=
literal|0x11
expr_stmt|;
comment|/* backspace */
name|cdb
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* look at filemarks (instead of blocks) */
name|n
operator|=
operator|-
literal|1
expr_stmt|;
name|cdb
index|[
literal|2
index|]
operator|=
name|n
operator|>>
literal|16
expr_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
name|n
operator|>>
literal|8
expr_stmt|;
name|cdb
index|[
literal|4
index|]
operator|=
name|n
expr_stmt|;
name|error
operator|=
name|ascmd
argument_list|(
name|as
argument_list|,
name|bp
argument_list|,
name|B_READ
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|as
operator|->
name|scsi_lock
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|as
operator|->
name|units_open
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|dev_part
argument_list|(
name|dev
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|as
operator|->
name|units_open
operator|==
literal|0
condition|)
name|as
operator|->
name|open
operator|=
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|as
operator|->
name|open_lock
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wakeup
argument_list|(
name|as
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|error
operator|)
return|;
end_return

begin_macro
unit|}  int
name|asioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|addr
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsicmd
modifier|*
name|cmdp
decl_stmt|;
name|struct
name|asinfo
modifier|*
name|as
decl_stmt|;
name|int
name|ccblen
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|direction
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
decl_stmt|;
name|int
name|old_wlabel
decl_stmt|;
name|as
operator|=
operator|&
name|asinfo
index|[
name|dev_target
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
operator|=
name|as
operator|->
name|label
expr_stmt|;
break|break;
case|case
name|DIOCSDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|dl
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|setdisklabel
argument_list|(
operator|&
name|as
operator|->
name|label
argument_list|,
name|dl
argument_list|,
literal|0
argument_list|,
name|as
operator|->
name|dospart
argument_list|)
condition|)
break|break;
name|as
operator|->
name|have_label
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DIOCWLABEL
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|as
operator|->
name|wlabel
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|DIOCWDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|dl
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|setdisklabel
argument_list|(
operator|&
name|as
operator|->
name|label
argument_list|,
name|dl
argument_list|,
literal|0
argument_list|,
name|as
operator|->
name|dospart
argument_list|)
condition|)
break|break;
name|as
operator|->
name|have_label
operator|=
literal|1
expr_stmt|;
name|old_wlabel
operator|=
name|as
operator|->
name|wlabel
expr_stmt|;
name|as
operator|->
name|wlabel
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|writedisklabel
argument_list|(
name|dev
argument_list|,
name|asstrategy
argument_list|,
operator|&
name|as
operator|->
name|label
argument_list|,
name|as
operator|->
name|dospart
argument_list|)
expr_stmt|;
name|as
operator|->
name|wlabel
operator|=
name|old_wlabel
expr_stmt|;
break|break;
case|case
name|SCSICMD
case|:
name|cmdp
operator|=
operator|(
expr|struct
name|scsicmd
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* limited by max sizeof of geteblk */
if|if
condition|(
name|cmdp
operator|->
name|datalen
operator|>=
literal|8192
operator|||
name|cmdp
operator|->
name|cdblen
operator|>=
name|MAXCDB
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ccblen
operator|=
name|cmdp
operator|->
name|ccblen
expr_stmt|;
if|if
condition|(
name|ccblen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ccb
argument_list|)
condition|)
name|ccblen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ccb
argument_list|)
expr_stmt|;
while|while
condition|(
name|as
operator|->
name|scsi_lock
condition|)
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|as
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"scsicmd"
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|as
operator|->
name|scsi_lock
operator|=
literal|1
expr_stmt|;
name|bp
operator|=
name|geteblk
argument_list|(
name|cmdp
operator|->
name|datalen
argument_list|)
expr_stmt|;
name|as
operator|->
name|scsi_cdb_len
operator|=
name|cmdp
operator|->
name|cdblen
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|cmdp
operator|->
name|cdb
argument_list|,
name|as
operator|->
name|scsi_cdb
argument_list|,
name|cmdp
operator|->
name|cdblen
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|direction
operator|=
name|cmdp
operator|->
name|readflag
condition|?
name|B_READ
else|:
name|B_WRITE
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|B_WRITE
condition|)
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|cmdp
operator|->
name|data
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|cmdp
operator|->
name|datalen
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|ascmd
argument_list|(
name|as
argument_list|,
name|bp
argument_list|,
name|direction
argument_list|,
name|cmdp
operator|->
name|datalen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|as
operator|->
name|ccb
argument_list|,
name|cmdp
operator|->
name|ccb
argument_list|,
name|ccblen
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|B_READ
condition|)
name|copyout
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|cmdp
operator|->
name|data
argument_list|,
name|cmdp
operator|->
name|datalen
argument_list|)
expr_stmt|;
name|done
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|as
operator|->
name|scsi_lock
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
name|as
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_function
name|int
name|asstrategy
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|asinfo
modifier|*
name|as
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|asverbose
condition|)
name|printf
argument_list|(
literal|"asstrategy %d %d "
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|as
operator|=
operator|&
name|asinfo
index|[
name|dev_target
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|tape
condition|)
block|{
name|bp
operator|->
name|av_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|requests
operator|.
name|b_actf
condition|)
name|as
operator|->
name|requests
operator|.
name|b_actl
operator|->
name|av_forw
operator|=
name|bp
expr_stmt|;
else|else
name|as
operator|->
name|requests
operator|.
name|b_actf
operator|=
name|bp
expr_stmt|;
name|as
operator|->
name|requests
operator|.
name|b_actl
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bp
operator|!=
name|as
operator|->
name|scsi_bp
operator|&&
name|as
operator|->
name|have_label
operator|==
literal|0
operator|&&
name|dev_part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|!=
literal|3
condition|)
goto|goto
name|bad
goto|;
name|bp
operator|->
name|b_cylin
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|disksort
argument_list|(
operator|&
name|as
operator|->
name|requests
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|as
operator|->
name|active
operator|==
literal|0
condition|)
name|asstart
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|asrestart
argument_list|(
argument|as
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|asinfo
modifier|*
name|as
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|as
operator|->
name|restart_pending
operator|=
literal|0
expr_stmt|;
name|as
operator|->
name|retry_count
operator|++
expr_stmt|;
name|asstart
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|asstart
argument_list|(
argument|as
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|asinfo
modifier|*
name|as
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|blknum
decl_stmt|;
name|unsigned
name|int
name|physaddr
decl_stmt|;
name|struct
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cdb
decl_stmt|;
name|int
name|target
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
name|int
name|nscatter
decl_stmt|;
name|int
name|thistime
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|struct
name|partition
modifier|*
name|part
decl_stmt|;
name|int
name|blkno
decl_stmt|;
name|int
name|nblocks
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|bs
init|=
name|as
operator|->
name|bs
decl_stmt|;
if|if
condition|(
name|as
operator|->
name|restart_pending
condition|)
block|{
name|as
operator|->
name|restart_pending
operator|=
literal|0
expr_stmt|;
name|untimeout
argument_list|(
name|asrestart
argument_list|,
name|as
argument_list|)
expr_stmt|;
block|}
name|again
label|:
if|if
condition|(
operator|(
name|bp
operator|=
name|as
operator|->
name|requests
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|asverbose
condition|)
name|printf
argument_list|(
literal|"asstart %x "
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|mailbox
operator|->
name|cmd
operator|!=
literal|0
condition|)
block|{
comment|/* this can't happen, unless the card flakes */
name|printf
argument_list|(
literal|"asstart: mailbox not available\n"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|as
operator|->
name|retry_count
operator|==
literal|0
condition|)
block|{
name|as
operator|->
name|start_time
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|time
operator|.
name|tv_sec
operator|-
name|as
operator|->
name|start_time
operator|>
literal|60
condition|)
block|{
name|printf
argument_list|(
literal|"as: command timed out\n"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|bp
operator|!=
name|as
operator|->
name|scsi_bp
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_bcount
operator|%
name|bs
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"as: partial block read\n"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|bp
operator|!=
name|as
operator|->
name|scsi_bp
condition|)
block|{
name|blkno
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|nblocks
operator|=
name|bp
operator|->
name|b_bcount
operator|/
name|bs
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|have_label
operator|&&
name|dev_part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|!=
literal|3
condition|)
block|{
name|part
operator|=
operator|&
name|as
operator|->
name|label
operator|.
name|d_partitions
index|[
name|dev_part
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|blkno
operator|>
name|part
operator|->
name|p_size
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|blkno
operator|==
name|part
operator|->
name|p_size
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|blkno
operator|+
name|nblocks
operator|>=
name|part
operator|->
name|p_size
condition|)
name|nblocks
operator|=
name|part
operator|->
name|p_size
operator|-
name|blkno
expr_stmt|;
name|blkno
operator|+=
name|part
operator|->
name|p_offset
expr_stmt|;
block|}
else|else
name|blkno
operator|=
operator|(
name|blkno
operator|*
name|DEV_BSIZE
operator|)
operator|/
name|bs
expr_stmt|;
if|if
condition|(
name|asverbose
condition|)
name|printf
argument_list|(
literal|"trans %d "
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|nblocks
operator|>
literal|255
condition|)
name|nblocks
operator|=
literal|255
expr_stmt|;
name|total
operator|=
name|nblocks
operator|*
name|bs
expr_stmt|;
if|if
condition|(
name|asverbose
condition|)
name|printf
argument_list|(
literal|"total %d nblocks %d "
argument_list|,
name|total
argument_list|,
name|nblocks
argument_list|)
expr_stmt|;
comment|/*bp->b_bcount = total;	/* XXX partial tape block read - wrong */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|nomore
if|if
condition|(
name|as
operator|->
name|fixed
operator|==
literal|0
condition|)
block|{
name|total
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
else|else
block|{
name|total
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|blkno
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|nblocks
operator|=
name|bp
operator|->
name|b_bcount
operator|/
name|as
operator|->
name|fixed
expr_stmt|;
block|}
else|#
directive|else
name|total
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
endif|#
directive|endif
block|}
name|p
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|as
operator|->
name|scatter_list
expr_stmt|;
name|nscatter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|tape
operator|&&
name|as
operator|->
name|bs
operator|==
literal|1
condition|)
name|total
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|total
operator|&&
name|nscatter
operator|<
name|NSCATTER
condition|)
block|{
name|thistime
operator|=
name|page_size
operator|-
operator|(
operator|(
name|vm_offset_t
operator|)
name|p
operator|-
name|trunc_page
argument_list|(
name|p
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|+
name|thistime
operator|>
name|total
condition|)
name|thistime
operator|=
name|total
operator|-
name|n
expr_stmt|;
name|physaddr
operator|=
name|vtophys
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|asverbose
condition|)
name|printf
argument_list|(
literal|"%d bytes to %x (%x)\n"
argument_list|,
name|thistime
argument_list|,
name|p
argument_list|,
name|physaddr
argument_list|)
expr_stmt|;
name|sp
index|[
literal|0
index|]
operator|=
name|thistime
operator|>>
literal|16
expr_stmt|;
name|sp
index|[
literal|1
index|]
operator|=
name|thistime
operator|>>
literal|8
expr_stmt|;
name|sp
index|[
literal|2
index|]
operator|=
name|thistime
expr_stmt|;
name|sp
index|[
literal|3
index|]
operator|=
name|physaddr
operator|>>
literal|16
expr_stmt|;
name|sp
index|[
literal|4
index|]
operator|=
name|physaddr
operator|>>
literal|8
expr_stmt|;
name|sp
index|[
literal|5
index|]
operator|=
name|physaddr
expr_stmt|;
name|p
operator|+=
name|thistime
expr_stmt|;
name|n
operator|+=
name|thistime
expr_stmt|;
name|sp
operator|+=
literal|6
expr_stmt|;
name|nscatter
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nscatter
operator|==
name|NSCATTER
condition|)
block|{
name|printf
argument_list|(
literal|"out of range, cannot happen?"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ccb
operator|=
operator|&
name|as
operator|->
name|ccb
expr_stmt|;
comment|/* this only needed to make debugging easier */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
sizeof|sizeof
expr|*
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|nscatter
condition|)
name|ccb
operator|->
name|ccb_opcode
operator|=
literal|2
expr_stmt|;
comment|/* scatter cmd, return resid */
else|else
name|ccb
operator|->
name|ccb_opcode
operator|=
literal|0
expr_stmt|;
name|target
operator|=
name|dev_target
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_addr_and_control
operator|=
name|target
operator|<<
literal|5
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_addr_and_control
operator||=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|8
else|:
literal|0x10
expr_stmt|;
else|else
name|ccb
operator|->
name|ccb_addr_and_control
operator||=
literal|0x18
expr_stmt|;
name|nbytes
operator|=
name|nscatter
operator|*
literal|6
expr_stmt|;
name|ccb
operator|->
name|ccb_data_len_msb
operator|=
name|nbytes
operator|>>
literal|16
expr_stmt|;
name|ccb
operator|->
name|ccb_data_len_mid
operator|=
name|nbytes
operator|>>
literal|8
expr_stmt|;
name|ccb
operator|->
name|ccb_data_len_lsb
operator|=
name|nbytes
expr_stmt|;
name|ccb
operator|->
name|ccb_requst_sense_allocation_len
operator|=
name|MAXSENSE
expr_stmt|;
name|physaddr
operator|=
name|vtophys
argument_list|(
name|as
operator|->
name|scatter_list
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_data_ptr_msb
operator|=
name|physaddr
operator|>>
literal|16
expr_stmt|;
name|ccb
operator|->
name|ccb_data_ptr_mid
operator|=
name|physaddr
operator|>>
literal|8
expr_stmt|;
name|ccb
operator|->
name|ccb_data_ptr_lsb
operator|=
name|physaddr
expr_stmt|;
name|ccb
operator|->
name|ccb_link_msb
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_link_mid
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_link_lsb
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_link_id
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_host_status
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_target_status
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_zero1
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_zero2
operator|=
literal|0
expr_stmt|;
name|cdb
operator|=
name|ccb
operator|->
name|ccb_cdb
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|as
operator|->
name|scsi_bp
condition|)
block|{
name|ccb
operator|->
name|ccb_scsi_command_len
operator|=
name|as
operator|->
name|scsi_cdb_len
expr_stmt|;
name|bcopy
argument_list|(
name|as
operator|->
name|scsi_cdb
argument_list|,
name|cdb
argument_list|,
name|as
operator|->
name|scsi_cdb_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|as
operator|->
name|tape
condition|)
block|{
name|ccb
operator|->
name|ccb_scsi_command_len
operator|=
literal|6
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|8
else|:
literal|0xa
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|bs
operator|==
literal|1
condition|)
block|{
name|cdb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* logical unit 0, variable block size */
name|cdb
index|[
literal|2
index|]
operator|=
name|bp
operator|->
name|b_bcount
operator|>>
literal|16
expr_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
name|bp
operator|->
name|b_bcount
operator|>>
literal|8
expr_stmt|;
name|cdb
index|[
literal|4
index|]
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
else|else
block|{
name|cdb
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* fixed block size */
name|cdb
index|[
literal|2
index|]
operator|=
name|nblocks
operator|>>
literal|16
expr_stmt|;
name|cdb
index|[
literal|3
index|]
operator|=
name|nblocks
operator|>>
literal|8
expr_stmt|;
name|cdb
index|[
literal|4
index|]
operator|=
name|nblocks
expr_stmt|;
block|}
name|cdb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* control byte (used in linking) */
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_scsi_command_len
operator|=
literal|10
expr_stmt|;
name|cdb
index|[
literal|0
index|]
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|0x28
else|:
literal|0x2a
expr_stmt|;
name|cdb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|cdb
operator|+
literal|2
operator|)
operator|=
name|htonl
argument_list|(
name|blkno
argument_list|)
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|cdb
operator|+
literal|7
operator|)
operator|=
name|htons
argument_list|(
name|nblocks
argument_list|)
expr_stmt|;
name|cdb
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
comment|/* control byte (used in linking) */
block|}
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|asverbose
condition|)
block|{
name|printf
argument_list|(
literal|"ccb: "
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|48
condition|;
name|n
operator|++
control|)
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ccb
operator|)
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|physaddr
operator|=
name|vtophys
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|as
operator|->
name|mailbox
operator|->
name|msb
operator|=
name|physaddr
operator|>>
literal|16
expr_stmt|;
name|as
operator|->
name|mailbox
operator|->
name|mid
operator|=
name|physaddr
operator|>>
literal|8
expr_stmt|;
name|as
operator|->
name|mailbox
operator|->
name|lsb
operator|=
name|physaddr
expr_stmt|;
name|as
operator|->
name|mailbox
operator|->
name|cmd
operator|=
literal|1
expr_stmt|;
comment|/* tell controller to look in its mailbox */
name|as_put_byte
argument_list|(
name|AS_CMD_START_SCSI_COMMAND
argument_list|)
expr_stmt|;
name|as
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|asabort
argument_list|,
name|as
argument_list|,
name|hz
operator|*
literal|60
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
name|asdone
argument_list|(
name|as
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_block

begin_macro
name|asabort
argument_list|(
argument|as
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|asinfo
modifier|*
name|as
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
name|int
name|physaddr
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|active
condition|)
block|{
name|printf
argument_list|(
literal|"asabort %d\n"
argument_list|,
name|as
operator|-
name|asinfo
argument_list|)
expr_stmt|;
name|physaddr
operator|=
name|vtophys
argument_list|(
operator|&
name|as
operator|->
name|ccb
argument_list|)
expr_stmt|;
name|as
operator|->
name|mailbox
operator|->
name|msb
operator|=
name|physaddr
operator|>>
literal|16
expr_stmt|;
name|as
operator|->
name|mailbox
operator|->
name|mid
operator|=
name|physaddr
operator|>>
literal|8
expr_stmt|;
name|as
operator|->
name|mailbox
operator|->
name|lsb
operator|=
name|physaddr
expr_stmt|;
name|as
operator|->
name|mailbox
operator|->
name|cmd
operator|=
literal|2
expr_stmt|;
name|as_put_byte
argument_list|(
name|AS_CMD_START_SCSI_COMMAND
argument_list|)
expr_stmt|;
name|as
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|as
operator|->
name|requests
operator|.
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|asdone
argument_list|(
name|as
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|asintr
argument_list|(
argument|dev_t dev
argument_list|)
end_macro

begin_block
block|{
name|int
name|didwork
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|mailbox_entry
modifier|*
name|mp
decl_stmt|;
name|unsigned
name|int
name|physaddr
decl_stmt|;
name|int
name|val
decl_stmt|;
name|outb
argument_list|(
name|as_port
operator|+
name|AS_CONTROL
argument_list|,
name|AS_CONTROL_IRST
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|asverbose
condition|)
name|printf
argument_list|(
literal|"asintr %x "
argument_list|,
name|cpl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|again
label|:
name|didwork
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NTARGETS
init|;
name|i
operator|<
name|NTARGETS
operator|*
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|mp
operator|=
operator|&
name|mailboxes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|mp
operator|->
name|cmd
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|didwork
operator|=
literal|1
expr_stmt|;
name|physaddr
operator|=
operator|(
name|mp
operator|->
name|msb
operator|<<
literal|16
operator|)
operator||
operator|(
name|mp
operator|->
name|mid
operator|<<
literal|8
operator|)
operator||
name|mp
operator|->
name|lsb
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NTARGETS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|asinfo
index|[
name|j
index|]
operator|.
name|ccb_phys
operator|==
name|physaddr
condition|)
block|{
name|mp
operator|->
name|cmd
operator|=
literal|0
expr_stmt|;
name|asintr1
argument_list|(
operator|&
name|asinfo
index|[
name|j
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|==
name|NTARGETS
condition|)
block|{
name|printf
argument_list|(
literal|"as: unknown mailbox paddr 0x%x\n"
argument_list|,
name|physaddr
argument_list|)
expr_stmt|;
name|mp
operator|->
name|cmd
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|didwork
condition|)
goto|goto
name|again
goto|;
block|}
end_block

begin_macro
name|asintr1
argument_list|(
argument|as
argument_list|,
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|asinfo
modifier|*
name|as
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|bad
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|char
name|msgbuf
index|[
literal|100
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|key
decl_stmt|;
if|if
condition|(
name|asverbose
condition|)
name|printf
argument_list|(
literal|"asintr1 %x "
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|active
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"as: stray intr 0x%x\n"
argument_list|,
name|as
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
name|as
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|untimeout
argument_list|(
name|asabort
argument_list|,
name|as
argument_list|)
expr_stmt|;
name|bp
operator|=
name|as
operator|->
name|requests
operator|.
name|b_actf
expr_stmt|;
name|ccb
operator|=
operator|&
name|as
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|as
operator|->
name|scsi_bp
condition|)
block|{
comment|/* no fancy error recovery in this case */
if|if
condition|(
name|asverbose
condition|)
name|printf
argument_list|(
literal|"asintr1:scsicmd "
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (val != 1) 			bp->b_flags |= B_ERROR; 		goto next;
endif|#
directive|endif
block|}
name|bad
operator|=
literal|0
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
operator|&&
name|val
operator|!=
literal|4
condition|)
block|{
name|bad
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"funny mailbox message 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|msg
operator|=
name|msgbuf
expr_stmt|;
goto|goto
name|wrapup
goto|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_host_status
operator|!=
literal|0
condition|)
block|{
name|bad
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"controller error 0x%x"
argument_list|,
name|ccb
operator|->
name|ccb_host_status
argument_list|)
expr_stmt|;
name|msg
operator|=
name|msgbuf
expr_stmt|;
goto|goto
name|wrapup
goto|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_target_status
operator|==
literal|0
condition|)
comment|/* good transfer */
goto|goto
name|wrapup
goto|;
if|if
condition|(
name|ccb
operator|->
name|ccb_target_status
operator|==
literal|8
condition|)
block|{
comment|/* target rejected command because it is busy 		 * and wants us to try again later.  We'll wait 1 second 		 */
name|as
operator|->
name|restart_pending
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|asrestart
argument_list|,
name|as
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_target_status
operator|!=
literal|2
condition|)
block|{
name|bad
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"target error 0x%x"
argument_list|,
name|ccb
operator|->
name|ccb_target_status
argument_list|)
expr_stmt|;
name|msg
operator|=
name|msgbuf
expr_stmt|;
goto|goto
name|wrapup
goto|;
block|}
comment|/* normal path for errors */
name|sp
operator|=
name|ccb_sense
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* check for extended sense information */
if|if
condition|(
operator|(
name|sp
index|[
literal|0
index|]
operator|&
literal|0x7f
operator|)
operator|!=
literal|0x70
condition|)
block|{
comment|/* none */
name|bad
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"scsi error 0x%x"
argument_list|,
name|sp
index|[
literal|0
index|]
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
name|msg
operator|=
name|msgbuf
expr_stmt|;
goto|goto
name|wrapup
goto|;
block|}
if|if
condition|(
name|as
operator|->
name|tape
operator|&&
operator|(
name|sp
index|[
literal|2
index|]
operator|&
literal|0xf
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sp
index|[
literal|2
index|]
operator|&
literal|0xe0
condition|)
block|{
comment|/* either we read a file mark, the early warning EOT, 			 * or the block size did not match.  In any case, the 			 * normal residue handling will work (I think) 			 */
goto|goto
name|wrapup
goto|;
block|}
block|}
name|bad
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|key
operator|=
name|sp
index|[
literal|2
index|]
operator|&
literal|0xf
condition|)
block|{
case|case
literal|1
case|:
name|msg
operator|=
literal|"soft error"
expr_stmt|;
name|bad
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|msg
operator|=
literal|"not ready"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|msg
operator|=
literal|"hard error"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|msg
operator|=
literal|"target hardware error"
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|msg
operator|=
literal|"illegal request"
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|msg
operator|=
literal|"unit attention error"
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|msg
operator|=
literal|"write protect error"
expr_stmt|;
break|break;
case|case
literal|0xd
case|:
name|msg
operator|=
literal|"volume overflow"
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"scsi extended error 0x%x"
argument_list|,
name|sp
index|[
literal|2
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|msg
operator|=
name|msgbuf
expr_stmt|;
break|break;
block|}
name|wrapup
label|:
if|if
condition|(
name|bad
operator|&&
name|msg
operator|==
name|NULL
condition|)
name|msg
operator|=
literal|"unknown error"
expr_stmt|;
if|if
condition|(
name|msg
operator|&&
name|key
operator|!=
literal|6
condition|)
block|{
name|diskerr
argument_list|(
name|bp
argument_list|,
literal|"as"
argument_list|,
name|msg
argument_list|,
name|LOG_PRINTF
argument_list|,
operator|-
literal|1
argument_list|,
comment|/* number of successful blks */
name|as
operator|->
name|have_label
condition|?
operator|&
name|as
operator|->
name|label
else|:
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bad
operator|&&
name|key
operator|!=
literal|6
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|printf
argument_list|(
literal|"scsi sense: "
argument_list|)
expr_stmt|;
name|sp
operator|=
name|ccb_sense
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|sp
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* this assignment mixed sizes of controller commands            and data to read/write.  	bp->b_resid = (ccb->ccb_data_len_msb<< 16)  		| (ccb->ccb_data_len_mid<< 8)  			| ccb->ccb_data_len_lsb;         */
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|next
label|:
name|asdone
argument_list|(
name|as
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|asdone
argument_list|(
argument|as
argument_list|,
argument|restart
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|asinfo
modifier|*
name|as
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|restart
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|as
operator|->
name|requests
operator|.
name|b_actf
expr_stmt|;
name|as
operator|->
name|requests
operator|.
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|as
operator|->
name|retry_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|restart
operator|&&
name|as
operator|->
name|requests
operator|.
name|b_actf
condition|)
name|asstart
argument_list|(
name|as
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|assize
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
name|struct
name|asinfo
modifier|*
name|as
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|as_port
operator|==
literal|0
operator|||
name|dev_target
argument_list|(
name|dev
argument_list|)
operator|>=
name|NTARGETS
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|as
operator|=
operator|&
name|asinfo
index|[
name|dev_target
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|open
operator|==
literal|0
operator|&&
name|asopen
argument_list|(
name|dev
argument_list|,
name|FREAD
argument_list|,
name|S_IFBLK
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|as
operator|->
name|have_label
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lp
operator|=
operator|&
name|as
operator|->
name|label
expr_stmt|;
name|val
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|dev_part
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
operator|*
name|lp
operator|->
name|d_secsize
operator|/
name|DEV_BSIZE
expr_stmt|;
operator|(
name|void
operator|)
name|asclose
argument_list|(
name|dev
argument_list|,
name|FREAD
argument_list|,
name|S_IFBLK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|int
name|as_put_byte
parameter_list|(
name|val
parameter_list|)
name|int
name|val
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|100
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|as_port
operator|+
name|AS_STATUS
argument_list|)
operator|&
name|AS_STATUS_CDF
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"as: put byte timed out\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|outb
argument_list|(
name|as_port
operator|+
name|AS_DATA_OUT
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|as_get_byte
parameter_list|(
name|as
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|100
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|as_port
operator|+
name|AS_STATUS
argument_list|)
operator|&
name|AS_STATUS_DF
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"as_get_byte timed out\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|inb
argument_list|(
name|as_port
operator|+
name|AS_DATA_OUT
argument_list|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAS */
end_comment

end_unit

