begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 William Jolitz. All rights reserved.  * Written by William Jolitz 1/92  *  * Redistribution and use in source and binary forms are freely permitted  * provided that the above copyright notice and attribution and date of work  * and this paragraph are duplicated in all such forms.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * This procedure implements a minimal program execution facility for  * 386BSD. It interfaces to the BSD kernel as the execve system call.  * Significant limitations and lack of compatiblity with POSIX are  * present with this version, to make its basic operation more clear.  *  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"namei.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"exec.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"signalvar.h"
end_include

begin_include
include|#
directive|include
file|"mman.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_param.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_map.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_kern.h"
end_include

begin_include
include|#
directive|include
file|"machine/reg.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/bill/working/sys/kern/RCS/kern_execve.c,v 1.3 92/01/21 21:29:13 william Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Bill's first-cut execve() system call. Puts hair on your chest.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|execve
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
specifier|register
struct|struct
name|args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|amt
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|exec
name|hdr
decl_stmt|;
name|char
modifier|*
modifier|*
name|kargbuf
decl_stmt|,
modifier|*
modifier|*
name|kargbufp
decl_stmt|,
modifier|*
name|kstringbuf
decl_stmt|,
modifier|*
name|kstringbufp
decl_stmt|;
name|char
modifier|*
modifier|*
name|org
decl_stmt|,
modifier|*
modifier|*
name|vectp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|u_int
name|needsenv
decl_stmt|,
name|limitonargs
decl_stmt|,
name|stringlen
decl_stmt|;
name|int
name|addr
decl_stmt|,
name|size
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vs
decl_stmt|;
name|int
name|tsize
decl_stmt|,
name|dsize
decl_stmt|,
name|bsize
decl_stmt|,
name|cnt
decl_stmt|,
name|foff
decl_stmt|;
comment|/* 	 * Step 1. Lookup filename to see if we have something to execute. 	 */
name|ndp
operator|=
operator|&
name|nd
expr_stmt|;
name|ndp
operator|->
name|ni_nameiop
operator|=
name|LOOKUP
operator||
name|LOCKLEAF
operator||
name|FOLLOW
expr_stmt|;
name|ndp
operator|->
name|ni_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|ndp
operator|->
name|ni_dirp
operator|=
name|uap
operator|->
name|fname
expr_stmt|;
comment|/* is it there? */
if|if
condition|(
name|rv
operator|=
name|namei
argument_list|(
name|ndp
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
name|rv
operator|)
return|;
comment|/* is it a regular file? */
if|if
condition|(
name|ndp
operator|->
name|ni_vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
block|{
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOEXEC
operator|)
return|;
block|}
comment|/* is it executable? */
name|rv
operator|=
name|VOP_ACCESS
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|,
name|VEXEC
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_fail
goto|;
name|rv
operator|=
name|vn_stat
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|statb
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_fail
goto|;
comment|/* 	 * Step 2. Does the file contain a format we can 	 * understand and execute 	 */
name|rv
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|amt
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* big enough to hold a header? */
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_fail
goto|;
comment|/* that we recognize? */
name|rv
operator|=
name|ENOEXEC
expr_stmt|;
if|if
condition|(
name|hdr
operator|.
name|a_magic
operator|!=
name|ZMAGIC
condition|)
goto|goto
name|exec_fail
goto|;
comment|/* sanity check  "ain't not such thing as a sanity clause" -groucho */
if|if
condition|(
comment|/*hdr.a_text == 0 || */
name|hdr
operator|.
name|a_text
operator|>
name|MAXTSIZ
operator|||
name|hdr
operator|.
name|a_text
operator|%
name|NBPG
operator|||
name|hdr
operator|.
name|a_text
operator|>
name|statb
operator|.
name|st_size
condition|)
goto|goto
name|exec_fail
goto|;
if|if
condition|(
name|hdr
operator|.
name|a_data
operator|==
literal|0
operator|||
name|hdr
operator|.
name|a_data
operator|>
name|DFLDSIZ
operator|||
name|hdr
operator|.
name|a_data
operator|>
name|statb
operator|.
name|st_size
operator|||
name|hdr
operator|.
name|a_data
operator|+
name|hdr
operator|.
name|a_text
operator|>
name|statb
operator|.
name|st_size
condition|)
goto|goto
name|exec_fail
goto|;
if|if
condition|(
name|hdr
operator|.
name|a_bss
operator|>
name|MAXDSIZ
condition|)
goto|goto
name|exec_fail
goto|;
if|if
condition|(
name|hdr
operator|.
name|a_text
operator|+
name|hdr
operator|.
name|a_data
operator|+
name|hdr
operator|.
name|a_bss
operator|>
name|MAXTSIZ
operator|+
name|MAXDSIZ
condition|)
goto|goto
name|exec_fail
goto|;
comment|/* 	 * Step 3.  File and header are valid. Now, dig out the strings 	 * out of the old process image. 	 */
comment|/* assumption: most execve's have less than 256 arguments, with a 	 * total of string storage space not exceeding 2K. It is more 	 * frequent that when this fails, string space falls short first 	 * (e.g. as when a large termcap environment variable is present). 	 * It is infrequent when more than 256 arguments are used that take 	 * up less than 2K of space (e.g. args average more than 8 chars). 	 * 	 * What we give up in this implementation is a dense encoding of 	 * the data structure in the receiving program's address space. 	 * This means that there is plenty of wasted space (up to 6KB) 	 * as the price we pay for a fast, single pass algorithm. 	 * 	 * Our alternative would be to accumulate strings and pointers 	 * in the first pass, then, knowing the sizes and number of the 	 * strings, pack them neatly and tightly togeither in the second 	 * pass. This means two copies of the strings, and string copying 	 * is much of the cost of exec. 	 */
comment|/* allocate string buffer and arg buffer */
name|org
operator|=
name|kargbuf
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|kmem_alloc_wait
argument_list|(
name|exec_map
argument_list|,
operator|(
name|NCARGS
operator|+
name|PAGE_SIZE
operator|)
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|kstringbuf
operator|=
name|kstringbufp
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|kargbuf
operator|)
operator|+
name|NBPG
operator|/
literal|2
expr_stmt|;
name|kargbuf
operator|+=
name|NBPG
operator|/
operator|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
name|kargbufp
operator|=
name|kargbuf
expr_stmt|;
comment|/* first, do args */
name|needsenv
operator|=
literal|1
expr_stmt|;
name|vectp
operator|=
name|uap
operator|->
name|argp
expr_stmt|;
name|do_env_as_well
label|:
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* for each envp, copy in string */
name|limitonargs
operator|=
name|NCARGS
expr_stmt|;
if|if
condition|(
name|vectp
operator|==
literal|0
condition|)
goto|goto
name|dont_bother
goto|;
do|do
block|{
comment|/* did we outgrow initial argbuf, if so, die */
if|if
condition|(
name|kargbufp
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
name|kstringbuf
condition|)
goto|goto
name|exec_fail
goto|;
comment|/* get an string pointer */
name|ep
operator|=
operator|(
name|char
operator|*
operator|)
name|fuword
argument_list|(
name|vectp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|rv
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|exec_fail
goto|;
block|}
comment|/* if not null pointer, copy in string */
if|if
condition|(
name|ep
condition|)
block|{
if|if
condition|(
name|rv
operator|=
name|copyinstr
argument_list|(
name|ep
argument_list|,
name|kstringbufp
argument_list|,
name|limitonargs
argument_list|,
operator|&
name|stringlen
argument_list|)
condition|)
goto|goto
name|exec_fail
goto|;
comment|/* assume that strings usually all fit in last page */
operator|*
name|kargbufp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|kstringbufp
operator|-
name|kstringbuf
operator|+
name|USRSTACK
operator|-
name|NBPG
operator|+
name|NBPG
operator|/
literal|2
operator|)
expr_stmt|;
name|kargbufp
operator|++
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|kstringbufp
operator|+=
name|stringlen
expr_stmt|;
name|limitonargs
operator|-=
name|stringlen
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|kargbufp
operator|++
operator|=
literal|0
expr_stmt|;
name|limitonargs
operator|-=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|limitonargs
operator|>
literal|0
condition|)
do|;
name|dont_bother
label|:
if|if
condition|(
name|limitonargs
operator|<=
literal|0
condition|)
block|{
name|rv
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|exec_fail
goto|;
block|}
if|if
condition|(
name|needsenv
condition|)
block|{
name|argc
operator|=
name|cnt
expr_stmt|;
name|vectp
operator|=
name|uap
operator|->
name|envp
expr_stmt|;
name|needsenv
operator|=
literal|0
expr_stmt|;
goto|goto
name|do_env_as_well
goto|;
block|}
name|kargbuf
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|argc
expr_stmt|;
comment|/* 	 * Step 4. Build the new processes image. 	 */
comment|/* At this point, we are committed -- destroy old executable */
name|vs
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|USRSTACK
operator|-
name|addr
expr_stmt|;
comment|/* blow away all address space */
name|rv
operator|=
name|vm_deallocate
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_abort
goto|;
comment|/* build a new address space */
name|addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdr
operator|.
name|a_text
operator|==
literal|0
condition|)
block|{
comment|/* screwball mode */
name|foff
operator|=
name|tsize
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|a_data
operator|+=
name|hdr
operator|.
name|a_text
expr_stmt|;
block|}
else|else
block|{
name|tsize
operator|=
name|roundup
argument_list|(
name|hdr
operator|.
name|a_text
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
name|foff
operator|=
name|NBPG
expr_stmt|;
block|}
name|dsize
operator|=
name|roundup
argument_list|(
name|hdr
operator|.
name|a_data
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
name|bsize
operator|=
name|roundup
argument_list|(
name|hdr
operator|.
name|a_bss
operator|+
name|dsize
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
name|bsize
operator|-=
name|dsize
expr_stmt|;
comment|/* map text& data*/
name|rv
operator|=
name|vm_mmap
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
operator|&
name|addr
argument_list|,
name|tsize
operator|+
name|dsize
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_FILE
operator||
name|MAP_COPY
operator||
name|MAP_FIXED
argument_list|,
operator|(
name|caddr_t
operator|)
name|ndp
operator|->
name|ni_vp
argument_list|,
name|foff
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_abort
goto|;
comment|/* r/w data, ro text */
if|if
condition|(
name|tsize
condition|)
block|{
name|addr
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|vm_protect
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
name|addr
argument_list|,
name|tsize
argument_list|,
name|FALSE
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_abort
goto|;
block|}
comment|/* create anonymous memory region for bss */
name|addr
operator|=
name|dsize
operator|+
name|tsize
expr_stmt|;
name|rv
operator|=
name|vm_allocate
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
operator|&
name|addr
argument_list|,
name|bsize
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_abort
goto|;
comment|/* create anonymous memory region for stack */
name|addr
operator|=
name|USRSTACK
operator|-
name|MAXSSIZ
expr_stmt|;
name|rv
operator|=
name|vm_allocate
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
operator|&
name|addr
argument_list|,
name|MAXSSIZ
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_abort
goto|;
comment|/* 	 * Step 5. Prepare process for execution. 	 */
comment|/* touchup process information */
name|vs
operator|->
name|vm_tsize
operator|=
name|tsize
operator|/
name|NBPG
expr_stmt|;
comment|/* text size (pages) XXX */
name|vs
operator|->
name|vm_dsize
operator|=
operator|(
name|dsize
operator|+
name|bsize
operator|)
operator|/
name|NBPG
expr_stmt|;
comment|/* data size (pages) XXX */
name|vs
operator|->
name|vm_ssize
operator|=
name|MAXSSIZ
operator|/
name|NBPG
expr_stmt|;
comment|/* stack size (pages) */
name|vs
operator|->
name|vm_taddr
operator|=
literal|0
expr_stmt|;
comment|/* user virtual address of text XXX */
name|vs
operator|->
name|vm_daddr
operator|=
operator|(
name|caddr_t
operator|)
name|tsize
expr_stmt|;
comment|/* user virtual address of data XXX */
comment|/* user VA at max stack growth */
name|vs
operator|->
name|vm_maxsaddr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|USRSTACK
operator|-
name|MAXSSIZ
argument_list|)
expr_stmt|;
comment|/* everything fits in a single page, no fixups, no more work */
comment|/* (groan) due to bug in vm_map_copy, can't remap. copy for now. */
name|rv
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|org
argument_list|,
operator|(
name|caddr_t
operator|)
name|USRSTACK
operator|-
name|NBPG
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_abort
goto|;
comment|/* close files on exec, fixup signals */
name|fdcloseexec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|execsigs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_regs
index|[
name|SP
index|]
operator|=
name|USRSTACK
operator|-
name|NBPG
operator|+
name|NBPG
operator|/
literal|4
operator|-
literal|4
expr_stmt|;
name|vs
operator|->
name|vm_ssize
operator|=
literal|1
expr_stmt|;
comment|/* stack size (pages) */
name|setregs
argument_list|(
name|p
argument_list|,
name|hdr
operator|.
name|a_entry
argument_list|)
expr_stmt|;
name|kmem_free_wakeup
argument_list|(
name|exec_map
argument_list|,
name|org
argument_list|,
operator|(
name|NCARGS
operator|+
name|PAGE_SIZE
operator|)
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|exec_fail
label|:
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
name|exec_abort
label|:
comment|/* untested and probably bogus */
name|kmem_free_wakeup
argument_list|(
name|exec_map
argument_list|,
name|org
argument_list|,
operator|(
name|NCARGS
operator|+
name|PAGE_SIZE
operator|)
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|p
argument_list|,
name|W_EXITCODE
argument_list|(
literal|0
argument_list|,
name|SIGABRT
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

