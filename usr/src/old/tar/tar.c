begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)tar.c	5.15 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Tape Archival Program  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_define
define|#
directive|define
name|TBLOCK
value|512
end_define

begin_define
define|#
directive|define
name|NBLOCK
value|20
end_define

begin_define
define|#
directive|define
name|NAMSIZ
value|100
end_define

begin_define
define|#
directive|define
name|writetape
parameter_list|(
name|b
parameter_list|)
value|writetbuf(b, 1)
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_union
union|union
name|hblock
block|{
name|char
name|dummy
index|[
name|TBLOCK
index|]
decl_stmt|;
struct|struct
name|header
block|{
name|char
name|name
index|[
name|NAMSIZ
index|]
decl_stmt|;
name|char
name|mode
index|[
literal|8
index|]
decl_stmt|;
name|char
name|uid
index|[
literal|8
index|]
decl_stmt|;
name|char
name|gid
index|[
literal|8
index|]
decl_stmt|;
name|char
name|size
index|[
literal|12
index|]
decl_stmt|;
name|char
name|mtime
index|[
literal|12
index|]
decl_stmt|;
name|char
name|chksum
index|[
literal|8
index|]
decl_stmt|;
name|char
name|linkflag
decl_stmt|;
name|char
name|linkname
index|[
name|NAMSIZ
index|]
decl_stmt|;
block|}
name|dbuf
struct|;
block|}
union|;
end_union

begin_struct
struct|struct
name|linkbuf
block|{
name|ino_t
name|inum
decl_stmt|;
name|dev_t
name|devnum
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
name|pathname
index|[
name|NAMSIZ
index|]
decl_stmt|;
name|struct
name|linkbuf
modifier|*
name|nextp
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|union
name|hblock
name|dblock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|hblock
modifier|*
name|tbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|linkbuf
modifier|*
name|ihead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stat
name|stbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|iflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|oflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Bflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Fflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|chksum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|recno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|first
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prtlinkerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|freemem
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nblock
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|onintr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|onquit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|onhup
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_function_decl
name|int
name|onterm
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|daddr_t
name|low
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|high
decl_stmt|;
end_decl_stmt

begin_function_decl
name|daddr_t
name|bsrch
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|FILE
modifier|*
name|vfile
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|tfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|tname
index|[]
init|=
name|_PATH_TMP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|usefile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|magtape
index|[]
init|=
name|_PATH_MAGTAPE
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getcwd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getwd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getmem
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
name|tfile
operator|=
name|NULL
expr_stmt|;
name|usefile
operator|=
name|magtape
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
name|argv
operator|++
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|*
name|argv
operator|++
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
operator|*
name|argv
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: tapefile must be specified with 'f' option\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|usefile
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|fflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cflag
operator|++
expr_stmt|;
name|rflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|oflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tfile
operator|=
name|fopen
argument_list|(
name|tname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: cannot create temporary file (%s)\n"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|tfile
argument_list|,
literal|"!!!!!/!/!/!/!/!/!/! 000\n"
argument_list|)
expr_stmt|;
comment|/*FALL THRU*/
case|case
literal|'r'
case|:
name|rflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|vflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
name|magtape
index|[
literal|8
index|]
operator|=
operator|*
name|cp
expr_stmt|;
name|usefile
operator|=
name|magtape
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
operator|*
name|argv
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: blocksize must be specified with 'b' option\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|nblock
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|nblock
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: invalid blocksize \"%s\"\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|prtlinkerr
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|hflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|iflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|Bflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|Fflag
operator|++
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %c: unknown option\n"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rflag
operator|&&
operator|!
name|xflag
operator|&&
operator|!
name|tflag
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
if|if
condition|(
name|cflag
operator|&&
name|tfile
operator|!=
name|NULL
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|onhup
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|onterm
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mt
operator|=
name|openmt
argument_list|(
name|usefile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dorep
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|mt
operator|=
name|openmt
argument_list|(
name|usefile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xflag
condition|)
name|doxtract
argument_list|(
name|argv
argument_list|)
expr_stmt|;
else|else
name|dotable
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: usage: tar -{txru}[cvfblmhopwBi] [tapefile] [blocksize] file1 file2...\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|openmt
parameter_list|(
name|tape
parameter_list|,
name|writing
parameter_list|)
name|char
modifier|*
name|tape
decl_stmt|;
name|int
name|writing
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tape
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Read from standard input or write to standard output. 		 */
if|if
condition|(
name|writing
condition|)
block|{
if|if
condition|(
name|cflag
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: can only create standard output archives\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|vfile
operator|=
name|stderr
expr_stmt|;
name|setlinebuf
argument_list|(
name|vfile
argument_list|)
expr_stmt|;
name|mt
operator|=
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mt
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Bflag
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Use file or tape on local machine. 		 */
if|if
condition|(
name|writing
condition|)
block|{
if|if
condition|(
name|cflag
condition|)
name|mt
operator|=
name|open
argument_list|(
name|tape
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
else|else
name|mt
operator|=
name|open
argument_list|(
name|tape
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
block|}
else|else
name|mt
operator|=
name|open
argument_list|(
name|tape
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %s: %s\n"
argument_list|,
name|tape
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mt
operator|)
return|;
block|}
end_function

begin_macro
name|dorep
argument_list|(
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|char
name|wdir
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|tempdir
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
block|{
name|getdir
argument_list|()
expr_stmt|;
do|do
block|{
name|passtape
argument_list|()
expr_stmt|;
if|if
condition|(
name|term
condition|)
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|getdir
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|endtape
argument_list|()
condition|)
do|;
name|backtape
argument_list|()
expr_stmt|;
if|if
condition|(
name|tfile
operator|!=
name|NULL
condition|)
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"sort +0 -1 +1nr %s -o %s; awk '$1 != prev {print; prev=$1}' %s>%sX; mv %sX %s"
argument_list|,
name|tname
argument_list|,
name|tname
argument_list|,
name|tname
argument_list|,
name|tname
argument_list|,
name|tname
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|freopen
argument_list|(
name|tname
argument_list|,
literal|"r"
argument_list|,
name|tfile
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|fileno
argument_list|(
name|tfile
argument_list|)
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|high
operator|=
name|stbuf
operator|.
name|st_size
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|getcwd
argument_list|(
name|wdir
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|argv
operator|&&
operator|!
name|term
condition|)
block|{
name|cp2
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp2
argument_list|,
literal|"-C"
argument_list|)
operator|&&
name|argv
index|[
literal|1
index|]
condition|)
block|{
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
operator|*
name|argv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: can't change directories to %s: %s\n"
argument_list|,
operator|*
name|argv
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|getcwd
argument_list|(
name|wdir
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
name|parent
operator|=
name|wdir
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|*
name|argv
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|cp2
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp2
operator|!=
operator|*
name|argv
condition|)
block|{
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
operator|*
name|argv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: can't change directories to %s: %s\n"
argument_list|,
operator|*
name|argv
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|parent
operator|=
name|getcwd
argument_list|(
name|tempdir
argument_list|)
expr_stmt|;
operator|*
name|cp2
operator|=
literal|'/'
expr_stmt|;
name|cp2
operator|++
expr_stmt|;
block|}
name|putfile
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
name|cp2
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|wdir
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: cannot change back?: %s: %s\n"
argument_list|,
name|wdir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putempty
argument_list|()
expr_stmt|;
name|putempty
argument_list|()
expr_stmt|;
name|flushtape
argument_list|()
expr_stmt|;
if|if
condition|(
name|prtlinkerr
operator|==
literal|0
condition|)
return|return;
for|for
control|(
init|;
name|ihead
operator|!=
name|NULL
condition|;
name|ihead
operator|=
name|ihead
operator|->
name|nextp
control|)
block|{
if|if
condition|(
name|ihead
operator|->
name|count
operator|==
literal|0
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: missing links to %s\n"
argument_list|,
name|ihead
operator|->
name|pathname
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|endtape
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
return|;
block|}
end_block

begin_macro
name|getdir
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|stat
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|top
label|:
name|readtape
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return;
name|sp
operator|=
operator|&
name|stbuf
expr_stmt|;
name|sscanf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|mode
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|sp
operator|->
name|st_mode
operator|=
name|i
expr_stmt|;
name|sscanf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|uid
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|sp
operator|->
name|st_uid
operator|=
name|i
expr_stmt|;
name|sscanf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|gid
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|sp
operator|->
name|st_gid
operator|=
name|i
expr_stmt|;
name|sscanf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|size
argument_list|,
literal|"%lo"
argument_list|,
operator|&
name|sp
operator|->
name|st_size
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|mtime
argument_list|,
literal|"%lo"
argument_list|,
operator|&
name|sp
operator|->
name|st_mtime
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|chksum
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|chksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|chksum
operator|!=
operator|(
name|i
operator|=
name|checksum
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: directory checksum error (%d != %d)\n"
argument_list|,
name|chksum
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|iflag
condition|)
goto|goto
name|top
goto|;
name|done
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* strip off leading "/" if present */
if|if
condition|(
name|sflag
operator|&&
name|dblock
operator|.
name|dbuf
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
for|for
control|(
name|cp1
operator|=
name|cp2
operator|=
name|dblock
operator|.
name|dbuf
operator|.
name|name
init|;
operator|*
name|cp2
operator|&&
operator|*
name|cp2
operator|==
literal|'/'
condition|;
operator|++
name|cp2
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp2
condition|)
goto|goto
name|top
goto|;
while|while
condition|(
operator|*
name|cp1
operator|++
operator|=
operator|*
name|cp2
operator|++
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|tfile
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfile
argument_list|,
literal|"%s %s\n"
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|mtime
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|passtape
argument_list|()
end_macro

begin_block
block|{
name|long
name|blocks
decl_stmt|;
name|char
modifier|*
name|bufp
decl_stmt|;
if|if
condition|(
name|dblock
operator|.
name|dbuf
operator|.
name|linkflag
operator|==
literal|'1'
condition|)
return|return;
name|blocks
operator|=
name|stbuf
operator|.
name|st_size
expr_stmt|;
name|blocks
operator|+=
name|TBLOCK
operator|-
literal|1
expr_stmt|;
name|blocks
operator|/=
name|TBLOCK
expr_stmt|;
while|while
condition|(
name|blocks
operator|--
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|readtbuf
argument_list|(
operator|&
name|bufp
argument_list|,
name|TBLOCK
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putfile
argument_list|(
argument|longname
argument_list|,
argument|shortname
argument_list|,
argument|parent
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|longname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|shortname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|parent
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|infile
init|=
literal|0
decl_stmt|;
name|long
name|blocks
decl_stmt|;
name|char
name|buf
index|[
name|TBLOCK
index|]
decl_stmt|;
name|char
modifier|*
name|bigbuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|long
name|l
decl_stmt|;
name|char
name|newparent
index|[
name|NAMSIZ
operator|+
literal|64
index|]
decl_stmt|;
name|int
name|maxread
decl_stmt|;
name|int
name|hint
decl_stmt|;
comment|/* amount to write to get "in sync" */
if|if
condition|(
operator|!
name|hflag
condition|)
name|i
operator|=
name|lstat
argument_list|(
name|shortname
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|stat
argument_list|(
name|shortname
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %s: %s\n"
argument_list|,
name|longname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tfile
operator|!=
name|NULL
operator|&&
name|checkupdate
argument_list|(
name|longname
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|checkw
argument_list|(
literal|'r'
argument_list|,
name|longname
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|Fflag
operator|&&
name|checkf
argument_list|(
name|shortname
argument_list|,
name|stbuf
operator|.
name|st_mode
argument_list|,
name|Fflag
argument_list|)
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFDIR
case|:
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
operator|++
operator|=
name|longname
index|[
name|i
operator|++
index|]
condition|;
control|)
empty_stmt|;
operator|*
operator|--
name|cp
operator|=
literal|'/'
expr_stmt|;
operator|*
operator|++
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|oflag
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|-
name|buf
operator|)
operator|>=
name|NAMSIZ
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %s: file name too long\n"
argument_list|,
name|longname
argument_list|)
expr_stmt|;
return|return;
block|}
name|stbuf
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|tomodes
argument_list|(
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|chksum
argument_list|,
literal|"%6o"
argument_list|,
name|checksum
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|writetape
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dblock
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|newparent
argument_list|,
literal|"%s/%s"
argument_list|,
name|parent
argument_list|,
name|shortname
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|shortname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: chdir %s: %s\n"
argument_list|,
name|shortname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %s: directory read error\n"
argument_list|,
name|longname
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|parent
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: cannot change back?: %s: %s\n"
argument_list|,
name|parent
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|!
name|term
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"."
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|".."
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|l
operator|=
name|telldir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|putfile
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|,
name|newparent
argument_list|)
expr_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|seekdir
argument_list|(
name|dirp
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|parent
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: cannot change back?: %s: %s\n"
argument_list|,
name|parent
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|S_IFLNK
case|:
name|tomodes
argument_list|(
operator|&
name|stbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|longname
argument_list|)
operator|>=
name|NAMSIZ
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %s: file name too long\n"
argument_list|,
name|longname
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|longname
argument_list|)
expr_stmt|;
if|if
condition|(
name|stbuf
operator|.
name|st_size
operator|+
literal|1
operator|>=
name|NAMSIZ
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %s: symbolic link too long\n"
argument_list|,
name|longname
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|readlink
argument_list|(
name|shortname
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|linkname
argument_list|,
name|NAMSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: can't read symbolic link %s: %s\n"
argument_list|,
name|longname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|dblock
operator|.
name|dbuf
operator|.
name|linkname
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dblock
operator|.
name|dbuf
operator|.
name|linkflag
operator|=
literal|'2'
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|fprintf
argument_list|(
name|vfile
argument_list|,
literal|"a %s symbolic link to %s\n"
argument_list|,
name|longname
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|linkname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|size
argument_list|,
literal|"%11lo"
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|chksum
argument_list|,
literal|"%6o"
argument_list|,
name|checksum
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|writetape
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dblock
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFREG
case|:
if|if
condition|(
operator|(
name|infile
operator|=
name|open
argument_list|(
name|shortname
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %s: %s\n"
argument_list|,
name|longname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|tomodes
argument_list|(
operator|&
name|stbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|longname
argument_list|)
operator|>=
name|NAMSIZ
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %s: file name too long\n"
argument_list|,
name|longname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|longname
argument_list|)
expr_stmt|;
if|if
condition|(
name|stbuf
operator|.
name|st_nlink
operator|>
literal|1
condition|)
block|{
name|struct
name|linkbuf
modifier|*
name|lp
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|ihead
init|;
name|lp
operator|!=
name|NULL
condition|;
name|lp
operator|=
name|lp
operator|->
name|nextp
control|)
if|if
condition|(
name|lp
operator|->
name|inum
operator|==
name|stbuf
operator|.
name|st_ino
operator|&&
name|lp
operator|->
name|devnum
operator|==
name|stbuf
operator|.
name|st_dev
condition|)
block|{
name|found
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
condition|)
block|{
name|strcpy
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|linkname
argument_list|,
name|lp
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|dblock
operator|.
name|dbuf
operator|.
name|linkflag
operator|=
literal|'1'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|chksum
argument_list|,
literal|"%6o"
argument_list|,
name|checksum
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|writetape
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|fprintf
argument_list|(
name|vfile
argument_list|,
literal|"a %s link to %s\n"
argument_list|,
name|longname
argument_list|,
name|lp
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|lp
operator|->
name|count
operator|--
expr_stmt|;
name|close
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return;
block|}
name|lp
operator|=
operator|(
expr|struct
name|linkbuf
operator|*
operator|)
name|getmem
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
block|{
name|lp
operator|->
name|nextp
operator|=
name|ihead
expr_stmt|;
name|ihead
operator|=
name|lp
expr_stmt|;
name|lp
operator|->
name|inum
operator|=
name|stbuf
operator|.
name|st_ino
expr_stmt|;
name|lp
operator|->
name|devnum
operator|=
name|stbuf
operator|.
name|st_dev
expr_stmt|;
name|lp
operator|->
name|count
operator|=
name|stbuf
operator|.
name|st_nlink
operator|-
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|lp
operator|->
name|pathname
argument_list|,
name|longname
argument_list|)
expr_stmt|;
block|}
block|}
name|blocks
operator|=
operator|(
name|stbuf
operator|.
name|st_size
operator|+
operator|(
name|TBLOCK
operator|-
literal|1
operator|)
operator|)
operator|/
name|TBLOCK
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|fprintf
argument_list|(
name|vfile
argument_list|,
literal|"a %s %ld blocks\n"
argument_list|,
name|longname
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|chksum
argument_list|,
literal|"%6o"
argument_list|,
name|checksum
argument_list|()
argument_list|)
expr_stmt|;
name|hint
operator|=
name|writetape
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dblock
argument_list|)
expr_stmt|;
name|maxread
operator|=
name|max
argument_list|(
name|stbuf
operator|.
name|st_blksize
argument_list|,
operator|(
name|nblock
operator|*
name|TBLOCK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bigbuf
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|maxread
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|maxread
operator|=
name|TBLOCK
expr_stmt|;
name|bigbuf
operator|=
name|buf
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|infile
argument_list|,
name|bigbuf
argument_list|,
name|min
argument_list|(
operator|(
name|hint
operator|*
name|TBLOCK
operator|)
argument_list|,
name|maxread
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|blocks
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|nblks
decl_stmt|;
name|nblks
operator|=
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|/
name|TBLOCK
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nblks
operator|>
name|blocks
condition|)
name|nblks
operator|=
name|blocks
expr_stmt|;
name|hint
operator|=
name|writetbuf
argument_list|(
name|bigbuf
argument_list|,
name|nblks
argument_list|)
expr_stmt|;
name|blocks
operator|-=
name|nblks
expr_stmt|;
block|}
name|close
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|bigbuf
operator|!=
name|buf
condition|)
name|free
argument_list|(
name|bigbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: Read error on %s: %s\n"
argument_list|,
name|longname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blocks
operator|!=
literal|0
operator|||
name|i
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %s: file changed size\n"
argument_list|,
name|longname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|blocks
operator|>=
literal|0
condition|)
name|putempty
argument_list|()
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %s is not a file. Not dumped\n"
argument_list|,
name|longname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|doxtract
argument_list|(
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|blocks
decl_stmt|,
name|bytes
decl_stmt|;
name|int
name|ofile
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|wantit
argument_list|(
name|argv
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* end of tape */
if|if
condition|(
name|checkw
argument_list|(
literal|'x'
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|passtape
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|Fflag
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|rindex
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|s
operator|=
name|dblock
operator|.
name|dbuf
operator|.
name|name
expr_stmt|;
else|else
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|checkf
argument_list|(
name|s
argument_list|,
name|stbuf
operator|.
name|st_mode
argument_list|,
name|Fflag
argument_list|)
operator|==
literal|0
condition|)
block|{
name|passtape
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|checkdir
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|)
condition|)
block|{
comment|/* have a directory */
if|if
condition|(
name|mflag
operator|==
literal|0
condition|)
name|dodirtimes
argument_list|(
operator|&
name|dblock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dblock
operator|.
name|dbuf
operator|.
name|linkflag
operator|==
literal|'2'
condition|)
block|{
comment|/* symlink */
comment|/* 			 * only unlink non directories or empty 			 * directories 			 */
if|if
condition|(
name|rmdir
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOTDIR
condition|)
name|unlink
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symlink
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|linkname
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %s: symbolic link failed: %s\n"
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vflag
condition|)
name|fprintf
argument_list|(
name|vfile
argument_list|,
literal|"x %s symbolic link to %s\n"
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|linkname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* ignore alien orders */
name|chown
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|stbuf
operator|.
name|st_uid
argument_list|,
name|stbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mflag
operator|==
literal|0
condition|)
name|setimes
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|stbuf
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflag
condition|)
name|chmod
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|stbuf
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|dblock
operator|.
name|dbuf
operator|.
name|linkflag
operator|==
literal|'1'
condition|)
block|{
comment|/* regular link */
comment|/* 			 * only unlink non directories or empty 			 * directories 			 */
if|if
condition|(
name|rmdir
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOTDIR
condition|)
name|unlink
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|link
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|linkname
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: can't link %s to %s: %s\n"
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|linkname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vflag
condition|)
name|fprintf
argument_list|(
name|vfile
argument_list|,
literal|"%s linked to %s\n"
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|linkname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ofile
operator|=
name|creat
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|stbuf
operator|.
name|st_mode
operator|&
literal|0xfff
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: can't create %s: %s\n"
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|passtape
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|chown
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|stbuf
operator|.
name|st_uid
argument_list|,
name|stbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
name|blocks
operator|=
operator|(
operator|(
name|bytes
operator|=
name|stbuf
operator|.
name|st_size
operator|)
operator|+
name|TBLOCK
operator|-
literal|1
operator|)
operator|/
name|TBLOCK
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|fprintf
argument_list|(
name|vfile
argument_list|,
literal|"x %s, %ld bytes, %ld tape blocks\n"
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|bytes
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|blocks
operator|>
literal|0
condition|;
control|)
block|{
specifier|register
name|int
name|nread
decl_stmt|;
name|char
modifier|*
name|bufp
decl_stmt|;
specifier|register
name|int
name|nwant
decl_stmt|;
name|nwant
operator|=
name|NBLOCK
operator|*
name|TBLOCK
expr_stmt|;
if|if
condition|(
name|nwant
operator|>
operator|(
name|blocks
operator|*
name|TBLOCK
operator|)
condition|)
name|nwant
operator|=
operator|(
name|blocks
operator|*
name|TBLOCK
operator|)
expr_stmt|;
name|nread
operator|=
name|readtbuf
argument_list|(
operator|&
name|bufp
argument_list|,
name|nwant
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|ofile
argument_list|,
name|bufp
argument_list|,
operator|(
name|int
operator|)
name|min
argument_list|(
name|nread
argument_list|,
name|bytes
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %s: HELP - extract write error: %s\n"
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|bytes
operator|-=
name|nread
expr_stmt|;
name|blocks
operator|-=
operator|(
operator|(
operator|(
name|nread
operator|-
literal|1
operator|)
operator|/
name|TBLOCK
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|close
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
if|if
condition|(
name|mflag
operator|==
literal|0
condition|)
name|setimes
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|stbuf
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflag
condition|)
name|chmod
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|,
name|stbuf
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mflag
operator|==
literal|0
condition|)
block|{
name|dblock
operator|.
name|dbuf
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* process the whole stack */
name|dodirtimes
argument_list|(
operator|&
name|dblock
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|dotable
argument_list|(
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|wantit
argument_list|(
name|argv
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* end of tape */
if|if
condition|(
name|vflag
condition|)
name|longt
argument_list|(
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dblock
operator|.
name|dbuf
operator|.
name|linkflag
operator|==
literal|'1'
condition|)
name|printf
argument_list|(
literal|" linked to %s"
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|linkname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dblock
operator|.
name|dbuf
operator|.
name|linkflag
operator|==
literal|'2'
condition|)
name|printf
argument_list|(
literal|" symbolic link to %s"
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|linkname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|passtape
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|putempty
argument_list|()
end_macro

begin_block
block|{
name|char
name|buf
index|[
name|TBLOCK
index|]
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|writetape
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|longt
argument_list|(
name|st
argument_list|)
specifier|register
expr|struct
name|stat
operator|*
name|st
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
name|pmode
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%3u/%1u"
argument_list|,
name|st
operator|->
name|st_uid
argument_list|,
name|st
operator|->
name|st_gid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%7ld"
argument_list|,
name|st
operator|->
name|st_size
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ctime
argument_list|(
operator|&
name|st
operator|->
name|st_mtime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-12.12s %-4.4s "
argument_list|,
name|cp
operator|+
literal|4
argument_list|,
name|cp
operator|+
literal|20
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|SUID
value|04000
end_define

begin_define
define|#
directive|define
name|SGID
value|02000
end_define

begin_define
define|#
directive|define
name|ROWN
value|0400
end_define

begin_define
define|#
directive|define
name|WOWN
value|0200
end_define

begin_define
define|#
directive|define
name|XOWN
value|0100
end_define

begin_define
define|#
directive|define
name|RGRP
value|040
end_define

begin_define
define|#
directive|define
name|WGRP
value|020
end_define

begin_define
define|#
directive|define
name|XGRP
value|010
end_define

begin_define
define|#
directive|define
name|ROTH
value|04
end_define

begin_define
define|#
directive|define
name|WOTH
value|02
end_define

begin_define
define|#
directive|define
name|XOTH
value|01
end_define

begin_define
define|#
directive|define
name|STXT
value|01000
end_define

begin_decl_stmt
name|int
name|m1
index|[]
init|=
block|{
literal|1
block|,
name|ROWN
block|,
literal|'r'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m2
index|[]
init|=
block|{
literal|1
block|,
name|WOWN
block|,
literal|'w'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m3
index|[]
init|=
block|{
literal|2
block|,
name|SUID
block|,
literal|'s'
block|,
name|XOWN
block|,
literal|'x'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m4
index|[]
init|=
block|{
literal|1
block|,
name|RGRP
block|,
literal|'r'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m5
index|[]
init|=
block|{
literal|1
block|,
name|WGRP
block|,
literal|'w'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m6
index|[]
init|=
block|{
literal|2
block|,
name|SGID
block|,
literal|'s'
block|,
name|XGRP
block|,
literal|'x'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m7
index|[]
init|=
block|{
literal|1
block|,
name|ROTH
block|,
literal|'r'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m8
index|[]
init|=
block|{
literal|1
block|,
name|WOTH
block|,
literal|'w'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m9
index|[]
init|=
block|{
literal|2
block|,
name|STXT
block|,
literal|'t'
block|,
name|XOTH
block|,
literal|'x'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|m
index|[]
init|=
block|{
name|m1
block|,
name|m2
block|,
name|m3
block|,
name|m4
block|,
name|m5
block|,
name|m6
block|,
name|m7
block|,
name|m8
block|,
name|m9
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|pmode
argument_list|(
name|st
argument_list|)
specifier|register
expr|struct
name|stat
operator|*
name|st
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
modifier|*
name|mp
decl_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|m
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|m
index|[
literal|9
index|]
condition|;
control|)
name|selectbits
argument_list|(
operator|*
name|mp
operator|++
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|selectbits
argument_list|(
argument|pairp
argument_list|,
argument|st
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|pairp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
name|pairp
expr_stmt|;
name|n
operator|=
operator|*
name|ap
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
operator|&&
operator|(
name|st
operator|->
name|st_mode
operator|&
operator|*
name|ap
operator|++
operator|)
operator|==
literal|0
condition|)
name|ap
operator|++
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Make all directories needed by `name'.  If `name' is itself  * a directory on the tar tape (indicated by a trailing '/'),  * return 1; else 0.  */
end_comment

begin_expr_stmt
name|checkdir
argument_list|(
name|name
argument_list|)
specifier|register
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * Quick check for existence of directory. 	 */
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* already exists */
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
return|return
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
return|;
comment|/* return (lastchar == '/') */
block|}
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
comment|/* 	 * No luck, try to make all directories in path. 	 */
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'/'
condition|)
continue|continue;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|F_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: mkdir: %s: %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|chown
argument_list|(
name|name
argument_list|,
name|stbuf
operator|.
name|st_uid
argument_list|,
name|stbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflag
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
comment|/* dir on the tape */
name|chmod
argument_list|(
name|name
argument_list|,
name|stbuf
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
return|return
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
return|;
block|}
end_block

begin_macro
name|onintr
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|term
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|onquit
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|term
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|onhup
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|term
operator|++
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_macro
name|onterm
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|term
operator|++
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|tomodes
argument_list|(
name|sp
argument_list|)
specifier|register
expr|struct
name|stat
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|dblock
operator|.
name|dummy
init|;
name|cp
operator|<
operator|&
name|dblock
operator|.
name|dummy
index|[
name|TBLOCK
index|]
condition|;
name|cp
operator|++
control|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|mode
argument_list|,
literal|"%6o "
argument_list|,
name|sp
operator|->
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|uid
argument_list|,
literal|"%6o "
argument_list|,
name|sp
operator|->
name|st_uid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|gid
argument_list|,
literal|"%6o "
argument_list|,
name|sp
operator|->
name|st_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|size
argument_list|,
literal|"%11lo "
argument_list|,
name|sp
operator|->
name|st_size
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|mtime
argument_list|,
literal|"%11lo "
argument_list|,
name|sp
operator|->
name|st_mtime
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|checksum
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|dblock
operator|.
name|dbuf
operator|.
name|chksum
init|;
name|cp
operator|<
operator|&
name|dblock
operator|.
name|dbuf
operator|.
name|chksum
index|[
sizeof|sizeof
argument_list|(
name|dblock
operator|.
name|dbuf
operator|.
name|chksum
argument_list|)
index|]
condition|;
name|cp
operator|++
control|)
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|dblock
operator|.
name|dummy
init|;
name|cp
operator|<
operator|&
name|dblock
operator|.
name|dummy
index|[
name|TBLOCK
index|]
condition|;
name|cp
operator|++
control|)
name|i
operator|+=
operator|*
name|cp
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|checkw
argument_list|(
argument|c
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|wflag
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|printf
argument_list|(
literal|"%c "
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|longt
argument_list|(
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|response
argument_list|()
operator|==
literal|'y'
operator|)
return|;
block|}
end_block

begin_macro
name|response
argument_list|()
end_macro

begin_block
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
while|while
condition|(
name|getchar
argument_list|()
operator|!=
literal|'\n'
condition|)
empty_stmt|;
else|else
name|c
operator|=
literal|'n'
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_macro
name|checkf
argument_list|(
argument|name
argument_list|,
argument|mode
argument_list|,
argument|howmuch
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|,
name|howmuch
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|l
decl_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SCCS"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"RCS"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|l
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|)
operator|<
literal|3
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|howmuch
operator|>
literal|1
operator|&&
name|name
index|[
name|l
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'o'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"core"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"errs"
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|howmuch
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"a.out"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* SHOULD CHECK IF IT IS EXECUTABLE */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Is the current file a new file, or the newest one of the same name? */
end_comment

begin_macro
name|checkupdate
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
name|long
name|mtime
decl_stmt|;
name|daddr_t
name|seekp
decl_stmt|;
name|daddr_t
name|lookup
parameter_list|()
function_decl|;
name|rewind
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|seekp
operator|=
name|lookup
argument_list|(
name|arg
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|fseek
argument_list|(
name|tfile
argument_list|,
name|seekp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fscanf
argument_list|(
name|tfile
argument_list|,
literal|"%s %lo"
argument_list|,
name|name
argument_list|,
operator|&
name|mtime
argument_list|)
expr_stmt|;
return|return
operator|(
name|stbuf
operator|.
name|st_mtime
operator|>
name|mtime
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|done
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * Do we want the next entry on the tape, i.e. is it selected?  If  * not, skip over the entire entry.  Return -1 if reached end of tape.  */
end_comment

begin_macro
name|wantit
argument_list|(
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
name|getdir
argument_list|()
expr_stmt|;
if|if
condition|(
name|endtape
argument_list|()
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|argv
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|cp
operator|=
name|argv
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|prefix
argument_list|(
operator|*
name|cp
argument_list|,
name|dblock
operator|.
name|dbuf
operator|.
name|name
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|passtape
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Does s2 begin with the string s1, on a directory boundary?  */
end_comment

begin_expr_stmt
name|prefix
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s1
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|!=
operator|*
name|s2
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|s2
condition|)
return|return
operator|(
operator|*
name|s2
operator|==
literal|'/'
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|N
value|200
end_define

begin_decl_stmt
name|int
name|njab
decl_stmt|;
end_decl_stmt

begin_function
name|daddr_t
name|lookup
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
name|daddr_t
name|a
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|' '
condition|)
break|break;
name|a
operator|=
name|bsrch
argument_list|(
name|s
argument_list|,
name|i
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_function
name|daddr_t
name|bsrch
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|,
name|l
parameter_list|,
name|h
parameter_list|)
name|daddr_t
name|l
decl_stmt|,
name|h
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|char
name|b
index|[
name|N
index|]
decl_stmt|;
name|daddr_t
name|m
decl_stmt|,
name|m1
decl_stmt|;
name|njab
operator|=
literal|0
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|l
operator|>=
name|h
condition|)
return|return
operator|(
operator|(
name|daddr_t
operator|)
operator|-
literal|1
operator|)
return|;
name|m
operator|=
name|l
operator|+
operator|(
name|h
operator|-
name|l
operator|)
operator|/
literal|2
operator|-
name|N
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|m
operator|<
name|l
condition|)
name|m
operator|=
name|l
expr_stmt|;
name|fseek
argument_list|(
name|tfile
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|b
argument_list|,
literal|1
argument_list|,
name|N
argument_list|,
name|tfile
argument_list|)
expr_stmt|;
name|njab
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|b
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
break|break;
name|m
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|>=
name|h
condition|)
return|return
operator|(
operator|(
name|daddr_t
operator|)
operator|-
literal|1
operator|)
return|;
name|m1
operator|=
name|m
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|N
condition|;
name|i
operator|++
control|)
block|{
name|m1
operator|++
expr_stmt|;
if|if
condition|(
name|b
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
break|break;
block|}
name|i
operator|=
name|cmp
argument_list|(
name|b
operator|+
name|j
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|h
operator|=
name|m
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|l
operator|=
name|m1
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_macro
name|cmp
argument_list|(
argument|b
argument_list|,
argument|s
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|b
index|[
name|i
operator|+
literal|1
index|]
operator|>
name|s
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|b
index|[
name|i
operator|+
literal|1
index|]
operator|<
name|s
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|b
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|' '
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|readtape
argument_list|(
argument|buffer
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|bufp
decl_stmt|;
if|if
condition|(
name|first
operator|==
literal|0
condition|)
name|getbuf
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|readtbuf
argument_list|(
operator|&
name|bufp
argument_list|,
name|TBLOCK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bufp
argument_list|,
name|buffer
argument_list|,
name|TBLOCK
argument_list|)
expr_stmt|;
return|return
operator|(
name|TBLOCK
operator|)
return|;
block|}
end_block

begin_macro
name|readtbuf
argument_list|(
argument|bufpp
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|bufpp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|recno
operator|>=
name|nblock
operator|||
name|first
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|bread
argument_list|(
name|mt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|,
name|TBLOCK
operator|*
name|nblock
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|mterr
argument_list|(
literal|"read"
argument_list|,
name|i
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
name|TBLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: tape blocksize error\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|i
operator|/=
name|TBLOCK
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|nblock
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: blocksize = %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|nblock
operator|=
name|i
expr_stmt|;
block|}
name|first
operator|=
literal|1
expr_stmt|;
block|}
name|recno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
operator|(
operator|(
name|nblock
operator|-
name|recno
operator|)
operator|*
name|TBLOCK
operator|)
condition|)
name|size
operator|=
operator|(
name|nblock
operator|-
name|recno
operator|)
operator|*
name|TBLOCK
expr_stmt|;
operator|*
name|bufpp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|tbuf
index|[
name|recno
index|]
expr_stmt|;
name|recno
operator|+=
operator|(
name|size
operator|/
name|TBLOCK
operator|)
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|writetbuf
argument_list|(
name|buffer
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|buffer
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|first
operator|==
literal|0
condition|)
block|{
name|getbuf
argument_list|()
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|recno
operator|>=
name|nblock
condition|)
block|{
name|i
operator|=
name|write
argument_list|(
name|mt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|,
name|TBLOCK
operator|*
name|nblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|TBLOCK
operator|*
name|nblock
condition|)
name|mterr
argument_list|(
literal|"write"
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|recno
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *  Special case:  We have an empty tape buffer, and the 	 *  users data size is>= the tape block size:  Avoid 	 *  the bcopy and dma direct to tape.  BIG WIN.  Add the 	 *  residual to the tape buffer. 	 */
while|while
condition|(
name|recno
operator|==
literal|0
operator|&&
name|n
operator|>=
name|nblock
condition|)
block|{
name|i
operator|=
name|write
argument_list|(
name|mt
argument_list|,
name|buffer
argument_list|,
name|TBLOCK
operator|*
name|nblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|TBLOCK
operator|*
name|nblock
condition|)
name|mterr
argument_list|(
literal|"write"
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|n
operator|-=
name|nblock
expr_stmt|;
name|buffer
operator|+=
operator|(
name|nblock
operator|*
name|TBLOCK
operator|)
expr_stmt|;
block|}
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|buffer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tbuf
index|[
name|recno
operator|++
index|]
argument_list|,
name|TBLOCK
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|TBLOCK
expr_stmt|;
if|if
condition|(
name|recno
operator|>=
name|nblock
condition|)
block|{
name|i
operator|=
name|write
argument_list|(
name|mt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|,
name|TBLOCK
operator|*
name|nblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|TBLOCK
operator|*
name|nblock
condition|)
name|mterr
argument_list|(
literal|"write"
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|recno
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Tell the user how much to write to get in sync */
return|return
operator|(
name|nblock
operator|-
name|recno
operator|)
return|;
block|}
end_block

begin_macro
name|backtape
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|mtdev
init|=
literal|1
decl_stmt|;
specifier|static
name|struct
name|mtop
name|mtop
init|=
block|{
name|MTBSR
block|,
literal|1
block|}
decl_stmt|;
name|struct
name|mtget
name|mtget
decl_stmt|;
if|if
condition|(
name|mtdev
operator|==
literal|1
condition|)
name|mtdev
operator|=
name|ioctl
argument_list|(
name|mt
argument_list|,
name|MTIOCGET
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mtget
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtdev
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|mt
argument_list|,
name|MTIOCTOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mtop
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: tape backspace error: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|mt
argument_list|,
operator|(
name|daddr_t
operator|)
operator|-
name|TBLOCK
operator|*
name|nblock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|recno
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|flushtape
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|write
argument_list|(
name|mt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|,
name|TBLOCK
operator|*
name|nblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|TBLOCK
operator|*
name|nblock
condition|)
name|mterr
argument_list|(
literal|"write"
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|mterr
argument_list|(
argument|operation
argument_list|,
argument|i
argument_list|,
argument|exitcode
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|operation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: tape %s error: %s\n"
argument_list|,
name|operation
argument_list|,
name|i
operator|<
literal|0
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"unexpected EOF"
argument_list|)
expr_stmt|;
name|done
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bread
argument_list|(
argument|fd
argument_list|,
argument|buf
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
decl_stmt|;
specifier|static
name|int
name|lastread
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|Bflag
condition|)
return|return
operator|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|)
return|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|size
condition|;
name|count
operator|+=
name|lastread
control|)
block|{
name|lastread
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
operator|-
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastread
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|0
condition|)
return|return
operator|(
name|count
operator|)
return|;
return|return
operator|(
name|lastread
operator|)
return|;
block|}
name|buf
operator|+=
name|lastread
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|getcwd
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
name|getwd
argument_list|(
name|buf
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_macro
name|getbuf
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|nblock
operator|==
literal|0
condition|)
block|{
name|fstat
argument_list|(
name|mt
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
condition|)
name|nblock
operator|=
name|NBLOCK
expr_stmt|;
else|else
block|{
name|nblock
operator|=
name|stbuf
operator|.
name|st_blksize
operator|/
name|TBLOCK
expr_stmt|;
if|if
condition|(
name|nblock
operator|==
literal|0
condition|)
name|nblock
operator|=
name|NBLOCK
expr_stmt|;
block|}
block|}
name|tbuf
operator|=
operator|(
expr|union
name|hblock
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|nblock
operator|*
name|TBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbuf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: blocksize %d too big, can't get memory\n"
argument_list|,
name|nblock
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Save this directory and its mtime on the stack, popping and setting  * the mtimes of any stacked dirs which aren't parents of this one.  * A null directory causes the entire stack to be unwound and set.  *  * Since all the elements of the directory "stack" share a common  * prefix, we can make do with one string.  We keep only the current  * directory path, with an associated array of mtime's, one for each  * '/' in the path.  A negative mtime means no mtime.  The mtime's are  * offset by one (first index 1, not 0) because calling this with a null  * directory causes mtime[0] to be set.  *   * This stack algorithm is not guaranteed to work for tapes created  * with the 'r' option, but the vast majority of tapes with  * directories are not.  This avoids saving every directory record on  * the tape and setting all the times at the end.  */
end_comment

begin_decl_stmt
name|char
name|dirstack
index|[
name|NAMSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NTIM
value|(NAMSIZ/2+1)
end_define

begin_comment
comment|/* a/b/c/d/... */
end_comment

begin_decl_stmt
name|time_t
name|mtime
index|[
name|NTIM
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|dodirtimes
argument_list|(
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|union
name|hblock
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|dirstack
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
init|=
name|hp
operator|->
name|dbuf
operator|.
name|name
decl_stmt|;
specifier|register
name|int
name|ndir
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|savp
decl_stmt|;
name|int
name|savndir
decl_stmt|;
comment|/* Find common prefix */
while|while
condition|(
operator|*
name|p
operator|==
operator|*
name|q
operator|&&
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'/'
condition|)
operator|++
name|ndir
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
name|savp
operator|=
name|p
expr_stmt|;
name|savndir
operator|=
name|ndir
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
comment|/* 		 * Not a child: unwind the stack, setting the times. 		 * The order we do this doesn't matter, so we go "forward." 		 */
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'/'
condition|)
if|if
condition|(
name|mtime
index|[
operator|++
name|ndir
index|]
operator|>=
literal|0
condition|)
block|{
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* zap the slash */
name|setimes
argument_list|(
name|dirstack
argument_list|,
name|mtime
index|[
name|ndir
index|]
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
name|p
operator|=
name|savp
expr_stmt|;
name|ndir
operator|=
name|savndir
expr_stmt|;
comment|/* Push this one on the "stack" */
while|while
condition|(
operator|*
name|p
operator|=
operator|*
name|q
operator|++
condition|)
comment|/* append the rest of the new dir */
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'/'
condition|)
name|mtime
index|[
operator|++
name|ndir
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|mtime
index|[
name|ndir
index|]
operator|=
name|stbuf
operator|.
name|st_mtime
expr_stmt|;
comment|/* overwrite the last one */
block|}
end_block

begin_macro
name|setimes
argument_list|(
argument|path
argument_list|,
argument|mt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|mt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|mt
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|utimes
argument_list|(
name|path
argument_list|,
name|tv
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: can't set time on %s: %s\n"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|getmem
parameter_list|(
name|size
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|freemem
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tar: out of memory, link and directory modtime info lost\n"
argument_list|)
expr_stmt|;
name|freemem
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

end_unit

