begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1980 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)asscan.c 4.4 %G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"asscan.h"
end_include

begin_comment
comment|/*  *	NOTE:  *		This version of the assembler does not use fread and fwrite  *	for the token buffering.  The token buffers are integrals of BUFSIZ  *	at all times, so we use direct read and write.  fread and fwrite  *	as supplied from BTL in stdio are HORRENDOUSLY inefficient,  *	as they use putchar for each character, nested two deep in loops.  */
end_comment

begin_define
define|#
directive|define
name|writeTEST
parameter_list|(
name|pointer
parameter_list|,
name|size
parameter_list|,
name|nelements
parameter_list|,
name|ioptr
parameter_list|)
define|\
value|write(ioptr->_file, pointer, nelements * size) != nelements * size
end_define

begin_define
define|#
directive|define
name|readTEST
parameter_list|(
name|pointer
parameter_list|,
name|size
parameter_list|,
name|nelements
parameter_list|,
name|ioptr
parameter_list|)
define|\
value|read(ioptr->_file, pointer, nelements * size) != nelements * size
end_define

begin_comment
comment|/*  *	Variables to manage the token buffering.  *	We scan (lexically analyze) a large number of tokens, and  *	then parse all of the tokens in the scan buffer.  *	This reduces procedure call overhead when the parser  *	demands a token, allows for an efficient reread during  *	the second pass, and confuses the line number reporting  *	for errors encountered in the scanner and in the parser.  */
end_comment

begin_define
define|#
directive|define
name|TOKDALLOP
value|8
end_define

begin_decl_stmt
name|struct
name|tokbufdesc
modifier|*
name|bufstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*where the buffer list begins*/
end_comment

begin_decl_stmt
name|struct
name|tokbufdesc
modifier|*
name|buftail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*last one on the list*/
end_comment

begin_decl_stmt
name|struct
name|tokbufdesc
modifier|*
name|emptybuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the one being filled*/
end_comment

begin_comment
comment|/*  *	If we are using VM, during the second pass we reclaim the used  *	token buffers for saving the relocation information  */
end_comment

begin_decl_stmt
name|struct
name|tokbufdesc
modifier|*
name|tok_free
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free pool */
end_comment

begin_decl_stmt
name|struct
name|tokbufdesc
modifier|*
name|tok_temp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary for doing list manipulation */
end_comment

begin_comment
comment|/*  *	Other token buffer managers  */
end_comment

begin_decl_stmt
name|int
name|bufno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*which buffer number: 0,1 for tmp file*/
end_comment

begin_decl_stmt
name|struct
name|tokbufdesc
name|tokbuf
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*our initial increment of buffers*/
end_comment

begin_decl_stmt
name|ptrall
name|tokptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*where the current token comes from*/
end_comment

begin_decl_stmt
name|ptrall
name|tokub
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the last token in the current token buffer*/
end_comment

begin_comment
comment|/*  *	Variables to manage the string buffering  *	declared in asscan.h.  */
end_comment

begin_decl_stmt
name|int
name|strno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the current string being filled*/
end_comment

begin_decl_stmt
name|struct
name|strdesc
name|strbuf
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the string buffers; the first for nulls*/
end_comment

begin_decl_stmt
name|struct
name|strdesc
modifier|*
name|strptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*current string buffer being filled*/
end_comment

begin_macro
name|inittmpfile
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|useVM
condition|)
block|{
name|bufstart
operator|=
operator|&
name|tokbuf
index|[
literal|0
index|]
expr_stmt|;
name|buftail
operator|=
operator|&
name|tokbuf
index|[
literal|1
index|]
expr_stmt|;
name|bufstart
operator|->
name|tok_next
operator|=
name|buftail
expr_stmt|;
name|buftail
operator|->
name|tok_next
operator|=
literal|0
expr_stmt|;
block|}
name|tokbuf
index|[
literal|0
index|]
operator|.
name|tok_count
operator|=
operator|-
literal|1
expr_stmt|;
name|tokbuf
index|[
literal|1
index|]
operator|.
name|tok_count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|tok_temp
operator|=
literal|0
expr_stmt|;
name|tok_free
operator|=
literal|0
expr_stmt|;
name|bufno
operator|=
literal|0
expr_stmt|;
name|emptybuf
operator|=
operator|&
name|tokbuf
index|[
name|bufno
index|]
expr_stmt|;
name|tokptr
operator|=
literal|0
expr_stmt|;
name|tokub
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|closetmpfile
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|useVM
condition|)
block|{
name|emptybuf
operator|->
name|toks
index|[
name|emptybuf
operator|->
name|tok_count
operator|++
index|]
operator|=
name|PARSEEOF
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 *	Clean up the buffers that haven't been 			 *	written out yet 			 */
if|if
condition|(
name|tokbuf
index|[
name|bufno
operator|^
literal|1
index|]
operator|.
name|tok_count
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|writeTEST
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tokbuf
index|[
name|bufno
operator|^
literal|1
index|]
argument_list|,
sizeof|sizeof
expr|*
name|emptybuf
argument_list|,
literal|1
argument_list|,
name|tmpfil
argument_list|)
condition|)
block|{
name|badwrite
label|:
name|yyerror
argument_list|(
literal|"Unexpected end of file writing the interpass tmp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 *	Ensure that we will read an End of file, 			 *	if there are more than one file names 			 *	in the argument list 			 */
name|tokbuf
index|[
name|bufno
index|]
operator|.
name|toks
index|[
name|tokbuf
index|[
name|bufno
index|]
operator|.
name|tok_count
operator|++
index|]
operator|=
name|PARSEEOF
expr_stmt|;
if|if
condition|(
name|writeTEST
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tokbuf
index|[
name|bufno
index|]
argument_list|,
sizeof|sizeof
expr|*
name|emptybuf
argument_list|,
literal|1
argument_list|,
name|tmpfil
argument_list|)
condition|)
goto|goto
name|badwrite
goto|;
block|}
block|}
comment|/*end of being pass 1*/
block|}
end_block

begin_define
define|#
directive|define
name|bstrlg
parameter_list|(
name|from
parameter_list|,
name|length
parameter_list|)
define|\
value|*(lgtype *)from = length; \ 	(char *)from += sizeof(lgtype) + length
end_define

begin_define
define|#
directive|define
name|bstrfromto
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
define|\
value|*(lgtype *)from = (char *)to - (char *)from - sizeof(lgtype); \ 	(char *)from += sizeof(lgtype) + (char *)to - (char *)from
end_define

begin_define
define|#
directive|define
name|eatstrlg
parameter_list|(
name|from
parameter_list|)
define|\
value|(char *)from +=  sizeof(lgtype) + *(lgtype *)from
end_define

begin_define
define|#
directive|define
name|bskiplg
parameter_list|(
name|from
parameter_list|,
name|length
parameter_list|)
define|\
value|*(lgtype *)from = length; \ 	(char *)from += sizeof(lgtype) + length
end_define

begin_define
define|#
directive|define
name|bskipfromto
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
define|\
value|*(lgtype *)from = (toktype *)to - (toktype *)from - sizeof(lgtype); \ 	(char *)from += sizeof (lgtype) + (toktype *)to - (toktype *)from
end_define

begin_define
define|#
directive|define
name|eatskiplg
parameter_list|(
name|from
parameter_list|)
define|\
value|(toktype *)from += sizeof(lgtype) + *(lgtype *)from
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|ptrall
name|firsttoken
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_decl_stmt
specifier|extern
name|int
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*global communication with parser*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|Lastjxxx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*this ONLY shuts up cc; see below*/
end_comment

begin_function
name|toktype
name|yylex
parameter_list|()
block|{
specifier|register
name|ptrall
name|bufptr
decl_stmt|;
specifier|register
name|toktype
name|val
decl_stmt|;
specifier|register
name|struct
name|exp
modifier|*
name|locxp
decl_stmt|;
name|bufptr
operator|=
name|tokptr
expr_stmt|;
comment|/*copy in the global value*/
name|top
label|:
if|if
condition|(
name|bufptr
operator|<
name|tokub
condition|)
block|{
name|gtoken
argument_list|(
name|val
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yylval
operator|=
name|val
condition|)
block|{
case|case
name|PARSEEOF
case|:
name|yylval
operator|=
name|val
operator|=
name|PARSEEOF
expr_stmt|;
break|break;
case|case
name|BFINT
case|:
case|case
name|INT
case|:
if|if
condition|(
name|xp
operator|>=
operator|&
name|explist
index|[
name|NEXP
index|]
condition|)
name|yyerror
argument_list|(
literal|"Too many expressions; try simplyfing"
argument_list|)
expr_stmt|;
else|else
name|locxp
operator|=
name|xp
operator|++
expr_stmt|;
name|glong
argument_list|(
name|locxp
operator|->
name|e_xvalue
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|locxp
operator|->
name|e_yvalue
operator|=
literal|0
expr_stmt|;
name|makevalue
label|:
name|locxp
operator|->
name|e_xtype
operator|=
name|XABS
expr_stmt|;
name|locxp
operator|->
name|e_xloc
operator|=
literal|0
expr_stmt|;
name|locxp
operator|->
name|e_xname
operator|=
name|NULL
expr_stmt|;
name|yylval
operator|=
operator|(
name|int
operator|)
name|locxp
expr_stmt|;
break|break;
case|case
name|FLTNUM
case|:
if|if
condition|(
name|xp
operator|>=
operator|&
name|explist
index|[
name|NEXP
index|]
condition|)
name|yyerror
argument_list|(
literal|"Too many expressions; try simplyfing"
argument_list|)
expr_stmt|;
else|else
name|locxp
operator|=
name|xp
operator|++
expr_stmt|;
name|gdouble
argument_list|(
operator|(
operator|(
expr|union
name|Double
operator|*
operator|)
name|locxp
operator|)
operator|->
name|dvalue
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
goto|goto
name|makevalue
goto|;
case|case
name|QUAD
case|:
if|if
condition|(
name|xp
operator|>=
operator|&
name|explist
index|[
name|NEXP
index|]
condition|)
name|yyerror
argument_list|(
literal|"Too many expressions; try simplyfing"
argument_list|)
expr_stmt|;
else|else
name|locxp
operator|=
name|xp
operator|++
expr_stmt|;
name|glong
argument_list|(
name|locxp
operator|->
name|e_xvalue
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|glong
argument_list|(
name|locxp
operator|->
name|e_yvalue
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|yylval
operator|=
name|val
operator|=
name|INT
expr_stmt|;
goto|goto
name|makevalue
goto|;
case|case
name|NAME
case|:
name|gptr
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|lastnam
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
break|break;
case|case
name|SIZESPEC
case|:
case|case
name|REG
case|:
case|case
name|INSTn
case|:
case|case
name|INST0
case|:
name|gchar
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IJXXX
case|:
name|gchar
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
comment|/* We can't cast Lastjxxx into (int *) here.. */
name|gptr
argument_list|(
name|Lastjxxx
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|lastjxxx
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|Lastjxxx
expr_stmt|;
break|break;
case|case
name|ILINESKIP
case|:
name|gint
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|lineno
operator|+=
name|yylval
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|SKIP
case|:
name|eatskiplg
argument_list|(
name|bufptr
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|VOID
case|:
goto|goto
name|top
goto|;
case|case
name|STRING
case|:
name|strptr
operator|=
operator|&
name|strbuf
index|[
name|strno
operator|^=
literal|1
index|]
expr_stmt|;
name|strptr
operator|->
name|str_lg
operator|=
operator|*
operator|(
operator|(
name|lgtype
operator|*
operator|)
name|bufptr
operator|)
expr_stmt|;
name|movestr
argument_list|(
operator|&
name|strptr
operator|->
name|str
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bufptr
operator|+
sizeof|sizeof
argument_list|(
name|lgtype
argument_list|)
argument_list|,
name|strptr
operator|->
name|str_lg
argument_list|)
expr_stmt|;
name|eatstrlg
argument_list|(
name|bufptr
argument_list|)
expr_stmt|;
name|yylval
operator|=
operator|(
name|int
operator|)
name|strptr
expr_stmt|;
break|break;
case|case
name|ISTAB
case|:
case|case
name|ISTABSTR
case|:
case|case
name|ISTABNONE
case|:
case|case
name|ISTABDOT
case|:
case|case
name|IALIGN
case|:
name|gptr
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|toktrace
condition|)
block|{
name|char
modifier|*
name|tok_to_name
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"P: %d T#: %4d, %s "
argument_list|,
name|passno
argument_list|,
name|bufptr
operator|-
name|firsttoken
argument_list|,
name|tok_to_name
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|INT
case|:
name|printf
argument_list|(
literal|"val %d"
argument_list|,
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
operator|)
operator|->
name|e_xvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFINT
case|:
name|printf
argument_list|(
literal|"val %d"
argument_list|,
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
operator|)
operator|->
name|e_xvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUAD
case|:
name|printf
argument_list|(
literal|"val[msd] = 0x%x, val[lsd] = 0x%x."
argument_list|,
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
operator|)
operator|->
name|e_xvalue
argument_list|,
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
operator|)
operator|->
name|e_yvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLTNUM
case|:
name|printf
argument_list|(
literal|"value %20.17f"
argument_list|,
operator|(
operator|(
expr|union
name|Double
operator|*
operator|)
name|yylval
operator|)
operator|->
name|dvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME
case|:
name|printf
argument_list|(
literal|"\"%.8s\""
argument_list|,
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
operator|)
operator|->
name|s_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|printf
argument_list|(
literal|" r%d"
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|IJXXX
case|:
case|case
name|INST0
case|:
case|case
name|INSTn
case|:
name|printf
argument_list|(
literal|"%.8s"
argument_list|,
name|itab
index|[
literal|0xFF
operator|&
name|yylval
index|]
operator|->
name|s_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|printf
argument_list|(
literal|"length %d "
argument_list|,
operator|(
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
operator|)
operator|->
name|str_lg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"value\"%s\""
argument_list|,
operator|(
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
operator|)
operator|->
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*end of the debug switch*/
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
block|}
else|else
block|{
comment|/* start a new buffer */
if|if
condition|(
name|useVM
condition|)
block|{
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
block|{
name|tok_temp
operator|=
name|emptybuf
operator|->
name|tok_next
expr_stmt|;
name|emptybuf
operator|->
name|tok_next
operator|=
name|tok_free
expr_stmt|;
name|tok_free
operator|=
name|emptybuf
expr_stmt|;
name|emptybuf
operator|=
name|tok_temp
expr_stmt|;
block|}
else|else
block|{
name|emptybuf
operator|=
name|emptybuf
operator|->
name|tok_next
expr_stmt|;
block|}
name|bufno
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|emptybuf
operator|==
literal|0
condition|)
block|{
name|struct
name|tokbufdesc
modifier|*
name|newdallop
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
goto|goto
name|badread
goto|;
name|emptybuf
operator|=
name|newdallop
operator|=
operator|(
expr|struct
name|tokbufdesc
operator|*
operator|)
name|Calloc
argument_list|(
name|TOKDALLOP
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tokbufdesc
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOKDALLOP
condition|;
name|i
operator|++
control|)
block|{
name|buftail
operator|->
name|tok_next
operator|=
name|newdallop
expr_stmt|;
name|buftail
operator|=
name|newdallop
expr_stmt|;
name|newdallop
operator|+=
literal|1
expr_stmt|;
block|}
name|buftail
operator|->
name|tok_next
operator|=
literal|0
expr_stmt|;
block|}
comment|/*end of need to get more buffers*/
operator|(
name|toktype
operator|*
operator|)
name|bufptr
operator|=
operator|&
operator|(
name|emptybuf
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
name|scan_dot_s
argument_list|(
name|emptybuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*don't use VM*/
name|bufno
operator|^=
literal|1
expr_stmt|;
name|emptybuf
operator|=
operator|&
name|tokbuf
index|[
name|bufno
index|]
expr_stmt|;
operator|(
operator|(
name|toktype
operator|*
operator|)
name|bufptr
operator|)
operator|=
operator|&
operator|(
name|emptybuf
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
comment|/* 			 *	First check if there are things to write 			 *	out at all 			 */
if|if
condition|(
name|emptybuf
operator|->
name|tok_count
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|writeTEST
argument_list|(
operator|(
name|char
operator|*
operator|)
name|emptybuf
argument_list|,
sizeof|sizeof
expr|*
name|emptybuf
argument_list|,
literal|1
argument_list|,
name|tmpfil
argument_list|)
condition|)
block|{
name|badwrite
label|:
name|yyerror
argument_list|(
literal|"Unexpected end of file writing the interpass tmp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|scan_dot_s
argument_list|(
name|emptybuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*pass 2*/
if|if
condition|(
name|readTEST
argument_list|(
operator|(
name|char
operator|*
operator|)
name|emptybuf
argument_list|,
sizeof|sizeof
expr|*
name|emptybuf
argument_list|,
literal|1
argument_list|,
name|tmpfil
argument_list|)
condition|)
block|{
name|badread
label|:
name|yyerror
argument_list|(
literal|"Unexpected end of file while reading the interpass tmp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*end of using a real live file*/
operator|(
name|char
operator|*
operator|)
name|tokub
operator|=
operator|(
name|char
operator|*
operator|)
name|bufptr
operator|+
name|emptybuf
operator|->
name|tok_count
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|firsttoken
operator|=
name|bufptr
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"created buffernumber %d with %d tokens\n"
argument_list|,
name|bufno
argument_list|,
name|emptybuf
operator|->
name|tok_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
goto|goto
name|top
goto|;
block|}
comment|/*end of reading/creating a new buffer*/
name|tokptr
operator|=
name|bufptr
expr_stmt|;
comment|/*copy back the global value*/
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*end of yylex*/
end_comment

begin_expr_stmt
name|buildskip
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
specifier|register
name|ptrall
name|from
operator|,
name|to
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|diff
decl_stmt|;
specifier|register
name|int
name|frombufno
decl_stmt|;
specifier|register
name|struct
name|tokbufdesc
modifier|*
name|middlebuf
decl_stmt|;
comment|/* 	 *	check if from and to are in the same buffer 	 *	from and to DIFFER BY AT MOST 1 buffer and to is 	 *	always ahead of from, with to being in the buffer emptybuf 	 *	points to. 	 *	The hard part here is accounting for the case where the 	 *	skip is to cross a buffer boundary; we must construct 	 *	two skips. 	 * 	 *	Figure out where the buffer boundary between from and to is 	 *	It's easy in VM, as buffers increase to high memory, but 	 *	w/o VM, we alternate between two buffers, and want 	 *	to look at the exact middle of the contiguous buffer region. 	 */
name|middlebuf
operator|=
name|useVM
condition|?
name|emptybuf
else|:
operator|&
name|tokbuf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|toktype
operator|*
operator|)
name|from
operator|>
operator|(
name|toktype
operator|*
operator|)
name|middlebuf
operator|)
operator|^
operator|(
operator|(
name|toktype
operator|*
operator|)
name|to
operator|>
operator|(
name|toktype
operator|*
operator|)
name|middlebuf
operator|)
condition|)
block|{
comment|/*split across a buffer boundary*/
name|ptoken
argument_list|(
name|from
argument_list|,
name|SKIP
argument_list|)
expr_stmt|;
comment|/* 		 *	Set the skip so it lands someplace beyond 		 *	the end of this buffer. 		 *	When we pull this skip out in the second pass, 		 *	we will temporarily move the current pointer 		 *	out beyond the end of the buffer, but immediately 		 *	do a compare and fail the compare, and then reset 		 *	all the pointers correctly to point into the next buffer. 		 */
name|bskiplg
argument_list|(
name|from
argument_list|,
name|TOKBUFLG
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 *	Now, force from to be in the same buffer as to 		 */
operator|(
name|toktype
operator|*
operator|)
name|from
operator|=
operator|(
name|toktype
operator|*
operator|)
operator|&
operator|(
name|emptybuf
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
comment|/* 	 *	Now, to and from are in the same buffer 	 */
if|if
condition|(
name|from
operator|>
name|to
condition|)
name|yyerror
argument_list|(
literal|"Internal error: bad skip construction"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|diff
operator|=
operator|(
name|toktype
operator|*
operator|)
name|to
operator|-
operator|(
name|toktype
operator|*
operator|)
name|from
operator|)
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|toktype
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|lgtype
argument_list|)
operator|+
literal|1
operator|)
condition|)
block|{
name|ptoken
argument_list|(
name|from
argument_list|,
name|SKIP
argument_list|)
expr_stmt|;
name|bskipfromto
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|diff
operator|>
literal|0
condition|;
operator|--
name|diff
control|)
name|ptoken
argument_list|(
name|from
argument_list|,
name|VOID
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|movestr
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|lg
argument_list|)
specifier|register
name|char
operator|*
name|to
operator|,
operator|*
name|from
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|lg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|lg
operator|<=
literal|0
condition|)
return|return;
do|do
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|lg
condition|)
do|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|newfflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|newfname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scanlineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the scanner's linenumber*/
end_comment

begin_macro
name|new_dot_s
argument_list|(
argument|namep
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|namep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|newfflag
operator|=
literal|1
expr_stmt|;
name|newfname
operator|=
name|namep
expr_stmt|;
name|dotsname
operator|=
name|namep
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|scanlineno
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Maps characters to their use in assembly language  */
end_comment

begin_define
define|#
directive|define
name|EOFCHAR
value|(-1)
end_define

begin_define
define|#
directive|define
name|NEEDCHAR
value|(-2)
end_define

begin_decl_stmt
name|readonly
name|short
name|type
index|[]
init|=
block|{
name|NEEDSBUF
block|,
comment|/*fill up the input buffer*/
name|SCANEOF
block|,
comment|/*hit the hard end of file*/
name|SP
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
comment|/*\0..^G*/
name|BADCHAR
block|,
name|SP
block|,
name|NL
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|SP
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
comment|/*BS..SI*/
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
comment|/*DLE..ETB*/
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
comment|/*CAN..US*/
name|SP
block|,
name|ORNOT
block|,
name|DQ
block|,
name|SH
block|,
name|LITOP
block|,
name|REGOP
block|,
name|AND
block|,
name|SQ
block|,
comment|/*sp .. '*/
name|LP
block|,
name|RP
block|,
name|MUL
block|,
name|PLUS
block|,
name|CM
block|,
name|MINUS
block|,
name|ALPH
block|,
name|DIV
block|,
comment|/*( .. /*/
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
comment|/*0 .. 7*/
name|DIG
block|,
name|DIG
block|,
name|COLON
block|,
name|SEMI
block|,
name|LSH
block|,
name|BADCHAR
block|,
name|RSH
block|,
name|BADCHAR
block|,
comment|/*8 .. ?*/
name|BADCHAR
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
comment|/*@ .. G*/
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
comment|/*H .. BADCHAR*/
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
comment|/*P .. V*/
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|LB
block|,
name|BADCHAR
block|,
name|RB
block|,
name|XOR
block|,
name|ALPH
block|,
comment|/*W .. _*/
name|SIZEQUOTE
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
comment|/*` .. g*/
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
comment|/*h .. o*/
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
comment|/*p .. v*/
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|BADCHAR
block|,
name|IOR
block|,
name|BADCHAR
block|,
name|TILDE
block|,
name|BADCHAR
block|,
comment|/*x .. del*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	The table of possible uses for each character to test set inclusion.  *	Different than the above table, which knows about tokens yylex  *	is to return.  */
end_comment

begin_define
define|#
directive|define
name|HEXFLAG
value|01
end_define

begin_comment
comment|/* 'x' or 'X' */
end_comment

begin_define
define|#
directive|define
name|HEXLDIGIT
value|02
end_define

begin_comment
comment|/* 'a' .. 'f' */
end_comment

begin_define
define|#
directive|define
name|HEXUDIGIT
value|04
end_define

begin_comment
comment|/* 'A' .. 'F' */
end_comment

begin_define
define|#
directive|define
name|ALPHA
value|010
end_define

begin_comment
comment|/* 'A' .. 'Z', 'a' .. 'z', '_'*/
end_comment

begin_define
define|#
directive|define
name|DIGIT
value|020
end_define

begin_comment
comment|/* '0' .. '9' */
end_comment

begin_define
define|#
directive|define
name|FLOATEXP
value|040
end_define

begin_comment
comment|/* 'd' 'e' 'D' 'E' */
end_comment

begin_define
define|#
directive|define
name|SIGN
value|0100
end_define

begin_comment
comment|/* '+' .. '-'*/
end_comment

begin_define
define|#
directive|define
name|REGDIGIT
value|0200
end_define

begin_comment
comment|/* '0' .. '5' */
end_comment

begin_define
define|#
directive|define
name|SZSPECBEGIN
value|0400
end_define

begin_comment
comment|/* 'b', 'B', 'l', 'L', 'w', 'W' */
end_comment

begin_define
define|#
directive|define
name|POINT
value|01000
end_define

begin_comment
comment|/* '.' */
end_comment

begin_define
define|#
directive|define
name|SPACE
value|02000
end_define

begin_comment
comment|/* '\t' or ' ' */
end_comment

begin_define
define|#
directive|define
name|BSESCAPE
value|04000
end_define

begin_comment
comment|/* bnrtf */
end_comment

begin_define
define|#
directive|define
name|STRESCAPE
value|010000
end_define

begin_comment
comment|/* '"', '\\', '\n' */
end_comment

begin_define
define|#
directive|define
name|OCTDIGIT
value|020000
end_define

begin_comment
comment|/* '0' .. '7' */
end_comment

begin_define
define|#
directive|define
name|FLOATFLAG
value|040000
end_define

begin_comment
comment|/* 'd', 'D', 'f', 'F' */
end_comment

begin_comment
comment|/*after leading 0*/
end_comment

begin_decl_stmt
name|readonly
name|short
name|charsets
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*\0..^G*/
literal|0
block|,
name|SPACE
block|,
name|STRESCAPE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*BS..SI*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*DLE..ETB*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*CAN..US*/
comment|/* dollar is an alpha character */
name|SPACE
block|,
literal|0
block|,
name|STRESCAPE
block|,
literal|0
block|,
name|ALPHA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*sp.. '*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SIGN
block|,
literal|0
block|,
name|SIGN
block|,
name|POINT
operator|+
name|ALPHA
block|,
literal|0
block|,
comment|/*( .. /*/
name|DIGIT
operator|+
name|REGDIGIT
operator|+
name|OCTDIGIT
block|,
name|DIGIT
operator|+
name|REGDIGIT
operator|+
name|OCTDIGIT
block|,
comment|/*0..1*/
name|DIGIT
operator|+
name|REGDIGIT
operator|+
name|OCTDIGIT
block|,
name|DIGIT
operator|+
name|REGDIGIT
operator|+
name|OCTDIGIT
block|,
comment|/*2..3*/
name|DIGIT
operator|+
name|REGDIGIT
operator|+
name|OCTDIGIT
block|,
name|DIGIT
operator|+
name|REGDIGIT
operator|+
name|OCTDIGIT
block|,
comment|/*4..5*/
name|DIGIT
operator|+
name|OCTDIGIT
block|,
name|DIGIT
operator|+
name|OCTDIGIT
block|,
comment|/*6..7*/
name|DIGIT
block|,
name|DIGIT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*8..?*/
literal|0
block|,
comment|/*@*/
name|ALPHA
operator|+
name|HEXUDIGIT
block|,
name|ALPHA
operator|+
name|HEXUDIGIT
operator|+
name|SZSPECBEGIN
block|,
comment|/*A..B*/
name|ALPHA
operator|+
name|HEXUDIGIT
block|,
name|ALPHA
operator|+
name|HEXUDIGIT
operator|+
name|FLOATEXP
operator|+
name|FLOATFLAG
block|,
comment|/*C..D*/
name|ALPHA
operator|+
name|HEXUDIGIT
operator|+
name|FLOATEXP
block|,
name|ALPHA
operator|+
name|HEXUDIGIT
operator|+
name|FLOATFLAG
block|,
comment|/*E..F*/
name|ALPHA
block|,
comment|/*G*/
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
comment|/*H..K*/
name|ALPHA
operator|+
name|SZSPECBEGIN
block|,
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
comment|/*L..O*/
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
comment|/*P..S*/
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
operator|+
name|SZSPECBEGIN
block|,
comment|/*T..W*/
name|ALPHA
operator|+
name|HEXFLAG
block|,
name|ALPHA
block|,
name|ALPHA
block|,
literal|0
block|,
name|STRESCAPE
block|,
literal|0
block|,
literal|0
block|,
name|ALPHA
block|,
comment|/*X.._*/
literal|0
block|,
name|ALPHA
operator|+
name|HEXLDIGIT
block|,
name|ALPHA
operator|+
name|HEXLDIGIT
operator|+
name|BSESCAPE
operator|+
name|SZSPECBEGIN
block|,
comment|/*a..b*/
name|ALPHA
operator|+
name|HEXLDIGIT
block|,
name|ALPHA
operator|+
name|HEXLDIGIT
operator|+
name|FLOATEXP
operator|+
name|FLOATFLAG
block|,
comment|/*c..d*/
name|ALPHA
operator|+
name|HEXLDIGIT
operator|+
name|FLOATEXP
block|,
name|ALPHA
operator|+
name|HEXLDIGIT
operator|+
name|BSESCAPE
operator|+
name|FLOATFLAG
block|,
comment|/*e..f*/
name|ALPHA
block|,
comment|/*g*/
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
comment|/*h..k*/
name|ALPHA
operator|+
name|SZSPECBEGIN
block|,
name|ALPHA
block|,
name|ALPHA
operator|+
name|BSESCAPE
block|,
name|ALPHA
block|,
comment|/*l..o*/
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
operator|+
name|BSESCAPE
block|,
name|ALPHA
block|,
comment|/*p..s*/
name|ALPHA
operator|+
name|BSESCAPE
block|,
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
operator|+
name|SZSPECBEGIN
block|,
comment|/*t..w*/
name|ALPHA
operator|+
name|HEXFLAG
block|,
name|ALPHA
block|,
name|ALPHA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*x..del*/
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INCHARSET
parameter_list|(
name|val
parameter_list|,
name|kind
parameter_list|)
value|(charsets[val]& (kind) )
end_define

begin_decl_stmt
specifier|static
name|toktype
name|oval
init|=
name|NL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NINBUFFERS
value|2
end_define

begin_define
define|#
directive|define
name|INBUFLG
value|NINBUFFERS*BUFSIZ + 2
end_define

begin_comment
comment|/* 	 *	We have two input buffers; the first one is reserved 	 *	for catching the tail of a line split across a buffer 	 *	boundary; the other one are used for snarfing a buffer 	 *	worth of .s source. 	 */
end_comment

begin_decl_stmt
specifier|static
name|char
name|inbuffer
index|[
name|INBUFLG
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|InBufPtr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|getchar
end_ifdef

begin_undef
undef|#
directive|undef
name|getchar
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|getchar
parameter_list|()
value|*inbufptr++
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ungetc
end_ifdef

begin_undef
undef|#
directive|undef
name|ungetc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ungetc
parameter_list|(
name|char
parameter_list|)
value|*--inbufptr = char
end_define

begin_comment
comment|/*  *	fill the inbuffer from the standard input.  *	Assert: there are always n COMPLETE! lines in the buffer area.  *	Assert: there is always a \n terminating the last line  *		in the buffer area.  *	Assert: after the \n, there is an EOFCHAR (hard end of file)  *		or a NEEDCHAR (end of buffer)  *	Assert:	fgets always null pads the string it reads.  *	Assert:	no ungetc's are done at the end of a line or at the  *		beginning of a line.  *	  *	We read a complete buffer of characters in one single read.  *	We then back scan within this buffer to find the end of the  *	last complete line, and force the assertions, and save a pointer  *	to the incomplete line.  *	The next call to fillinbuffer will move the unread characters  *	to the end of the first buffer, and then read another two buffers,  *	completing the cycle.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|p_swapped
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_start
init|=
operator|&
name|inbuffer
index|[
name|NINBUFFERS
operator|*
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_stop
init|=
operator|&
name|inbuffer
index|[
name|NINBUFFERS
operator|*
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|fillinbuffer
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|inbufptr
decl_stmt|;
name|int
name|nread
decl_stmt|;
operator|*
name|p_start
operator|=
name|p_swapped
expr_stmt|;
name|inbufptr
operator|=
operator|&
name|inbuffer
index|[
literal|1
operator|*
name|BUFSIZ
index|]
operator|-
operator|(
name|p_stop
operator|-
name|p_start
operator|)
expr_stmt|;
for|for
control|(
name|to
operator|=
name|inbufptr
operator|,
name|from
operator|=
name|p_start
init|;
name|from
operator|<
name|p_stop
condition|;
control|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
comment|/* 	 *	Now, go read two full buffers (hopefully) 	 */
name|nread
operator|=
name|read
argument_list|(
name|stdin
operator|->
name|_file
argument_list|,
operator|&
name|inbuffer
index|[
literal|1
operator|*
name|BUFSIZ
index|]
argument_list|,
operator|(
name|NINBUFFERS
operator|-
literal|1
operator|)
operator|*
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p_stop
operator|=
name|from
operator|=
operator|&
name|inbuffer
index|[
literal|1
operator|*
name|BUFSIZ
operator|+
name|nread
index|]
expr_stmt|;
operator|*
name|from
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|from
operator|!=
literal|'\n'
condition|)
comment|/* back over the partial line */
continue|continue;
name|from
operator|++
expr_stmt|;
comment|/* first char of partial line */
name|p_start
operator|=
name|from
expr_stmt|;
name|p_swapped
operator|=
operator|*
name|p_start
expr_stmt|;
operator|*
name|p_start
operator|=
name|NEEDCHAR
expr_stmt|;
comment|/* force assertion */
return|return
operator|(
name|inbufptr
operator|)
return|;
block|}
end_function

begin_macro
name|scan_dot_s
argument_list|(
argument|bufferbox
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tokbufdesc
modifier|*
name|bufferbox
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|yylval
decl_stmt|;
comment|/*lexical value*/
specifier|register
name|toktype
name|val
decl_stmt|;
comment|/*the value returned; the character read*/
specifier|register
name|int
name|base
decl_stmt|;
comment|/*the base of the number also counter*/
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|inbufptr
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|op
decl_stmt|;
specifier|register
name|unsigned
name|char
name|tag
decl_stmt|;
name|int
name|forb
decl_stmt|;
specifier|register
name|ptrall
name|bufptr
decl_stmt|;
comment|/*where to stuff tokens*/
name|ptrall
name|lgbackpatch
decl_stmt|;
comment|/*where to stuff a string length*/
name|ptrall
name|bufub
decl_stmt|;
comment|/*where not to stuff tokens*/
specifier|register
name|int
name|maxstrlg
decl_stmt|;
comment|/*how long a string can be*/
name|long
name|intval
decl_stmt|;
comment|/*value of int*/
name|char
name|fltchr
index|[
literal|64
index|]
decl_stmt|;
comment|/*buffer for floating values*/
name|union
name|Double
name|fltval
decl_stmt|;
comment|/*floating value returned*/
name|struct
name|Quad
name|quadval
decl_stmt|;
comment|/*quad returned from immediate constant */
name|int
name|linescrossed
decl_stmt|;
comment|/*when doing strings and comments*/
operator|(
name|toktype
operator|*
operator|)
name|bufptr
operator|=
operator|(
name|toktype
operator|*
operator|)
operator|&
operator|(
name|bufferbox
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
operator|(
name|toktype
operator|*
operator|)
name|bufub
operator|=
operator|&
operator|(
name|bufferbox
operator|->
name|toks
index|[
name|AVAILTOKS
index|]
operator|)
expr_stmt|;
name|inbufptr
operator|=
name|InBufPtr
expr_stmt|;
if|if
condition|(
name|inbufptr
operator|==
literal|0
condition|)
block|{
name|inbufptr
operator|=
name|fillinbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|inbufptr
operator|==
literal|0
condition|)
block|{
comment|/*end of file*/
name|endoffile
label|:
name|inbufptr
operator|=
literal|0
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|PARSEEOF
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|newfflag
condition|)
block|{
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|IFILE
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|STRING
argument_list|)
expr_stmt|;
name|val
operator|=
name|strlen
argument_list|(
name|newfname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|movestr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
operator|(
name|lgtype
operator|*
operator|)
name|bufptr
operator|)
index|[
literal|1
index|]
operator|)
argument_list|,
name|newfname
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bstrlg
argument_list|(
name|bufptr
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|ILINENO
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|pint
argument_list|(
name|bufptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newfflag
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|bufptr
operator|<
name|bufub
condition|)
block|{
name|loop
label|:
switch|switch
condition|(
name|yylval
operator|=
operator|(
name|type
operator|+
literal|2
operator|)
index|[
name|val
operator|=
name|getchar
argument_list|()
index|]
condition|)
block|{
case|case
name|SCANEOF
case|:
name|inbufptr
operator|=
literal|0
expr_stmt|;
goto|goto
name|endoffile
goto|;
case|case
name|NEEDSBUF
case|:
name|inbufptr
operator|=
name|fillinbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|inbufptr
operator|==
literal|0
condition|)
goto|goto
name|endoffile
goto|;
goto|goto
name|loop
goto|;
case|case
name|DIV
case|:
comment|/*process C style comments*/
if|if
condition|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'*'
condition|)
block|{
comment|/*comment prelude*/
name|int
name|incomment
decl_stmt|;
name|linescrossed
operator|=
literal|0
expr_stmt|;
name|incomment
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip over the * */
do|do
block|{
while|while
condition|(
operator|(
name|val
operator|!=
literal|'*'
operator|)
operator|&&
operator|(
name|val
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|val
operator|!=
name|EOFCHAR
operator|)
operator|&&
operator|(
name|val
operator|!=
name|NEEDCHAR
operator|)
condition|)
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|'\n'
condition|)
block|{
name|scanlineno
operator|++
expr_stmt|;
name|linescrossed
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
name|EOFCHAR
condition|)
goto|goto
name|endoffile
goto|;
if|if
condition|(
name|val
operator|==
name|NEEDCHAR
condition|)
block|{
name|inbufptr
operator|=
name|fillinbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|inbufptr
operator|==
literal|0
condition|)
goto|goto
name|endoffile
goto|;
name|lineno
operator|++
expr_stmt|;
name|incomment
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*pull in the new char*/
block|}
else|else
block|{
comment|/*its a star */
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|incomment
operator|=
name|val
operator|!=
literal|'/'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|incomment
condition|)
do|;
name|val
operator|=
name|ILINESKIP
expr_stmt|;
name|yylval
operator|=
name|linescrossed
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
comment|/*just an ordinary DIV*/
name|ungetc
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|yylval
operator|=
name|DIV
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
case|case
name|SH
case|:
if|if
condition|(
name|oval
operator|==
name|NL
condition|)
block|{
comment|/* 			 *	Attempt to recognize a C preprocessor 			 *	style comment '^#[ \t]*[0-9]*[ \t]*".*" 			 */
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*bump the #*/
while|while
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|SPACE
argument_list|)
condition|)
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*bump white */
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
name|intval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
name|intval
operator|=
name|intval
operator|*
literal|10
operator|+
name|val
operator|-
literal|'0'
expr_stmt|;
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|SPACE
argument_list|)
condition|)
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|'"'
condition|)
block|{
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|ILINENO
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|pint
argument_list|(
name|bufptr
argument_list|,
name|intval
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|IFILE
argument_list|)
expr_stmt|;
comment|/* 					 *	The '"' has already been 					 *	munched 					 *	 					 *	eatstr will not eat 					 *	the trailing \n, so 					 *	it is given to the parser 					 *	and counted. 					 */
goto|goto
name|eatstr
goto|;
block|}
block|}
block|}
comment|/* 		 *	Well, its just an ordinary decadent comment 		 */
while|while
condition|(
operator|(
name|val
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|val
operator|!=
name|EOFCHAR
operator|)
condition|)
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|EOFCHAR
condition|)
goto|goto
name|endoffile
goto|;
name|val
operator|=
name|yylval
operator|=
name|oval
operator|=
name|NL
expr_stmt|;
name|scanlineno
operator|++
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|NL
case|:
name|scanlineno
operator|++
expr_stmt|;
name|val
operator|=
name|yylval
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|SP
case|:
name|oval
operator|=
name|SP
expr_stmt|;
comment|/*invalidate ^# meta comments*/
goto|goto
name|loop
goto|;
case|case
name|REGOP
case|:
comment|/* % , could be used as modulo, or register*/
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|val
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|INCHARSET
argument_list|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|REGDIGIT
argument_list|)
condition|)
name|yylval
operator|=
literal|10
operator|+
name|val
operator|-
literal|'0'
expr_stmt|;
else|else
name|ungetc
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* 			 *	God only knows what the original author 			 *	wanted this undocumented feature to 			 *	do. 			 *		%5++ is really  r7 			 */
while|while
condition|(
name|INCHARSET
argument_list|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|SIGN
argument_list|)
condition|)
block|{
if|if
condition|(
name|val
operator|==
literal|'+'
condition|)
name|yylval
operator|++
expr_stmt|;
else|else
name|yylval
operator|--
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG
expr_stmt|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|REGOP
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
case|case
name|ALPH
case|:
name|yylval
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|SZSPECBEGIN
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'`'
operator|||
name|val
operator|==
literal|'^'
condition|)
block|{
name|yylval
operator||=
literal|0100
expr_stmt|;
comment|/*convert to lower*/
if|if
condition|(
name|yylval
operator|==
literal|'b'
condition|)
name|yylval
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|==
literal|'w'
condition|)
name|yylval
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|==
literal|'l'
condition|)
name|yylval
operator|=
literal|4
expr_stmt|;
else|else
name|yylval
operator|=
name|d124
expr_stmt|;
name|val
operator|=
name|SIZESPEC
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|yylval
expr_stmt|;
comment|/*restore first character*/
block|}
block|}
name|cp
operator|=
name|yytext
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cp
operator|<
operator|&
name|yytext
index|[
name|NCPS
index|]
condition|)
operator|*
name|cp
operator|++
operator|=
name|val
expr_stmt|;
block|}
do|while
condition|(
name|INCHARSET
argument_list|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|ALPHA
operator||
name|DIGIT
argument_list|)
condition|)
do|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|SPACE
argument_list|)
condition|)
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|ungetc
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|doit
label|:
name|tag
operator|=
operator|(
name|op
operator|=
operator|*
name|lookup
argument_list|(
literal|1
argument_list|)
operator|)
operator|->
name|s_tag
expr_stmt|;
if|if
condition|(
name|tag
operator|&&
name|tag
operator|!=
name|LABELID
condition|)
block|{
name|yylval
operator|=
operator|(
operator|(
expr|struct
name|instab
operator|*
operator|)
name|op
operator|)
operator|->
name|i_opcode
expr_stmt|;
name|val
operator|=
name|op
operator|->
name|s_tag
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
comment|/* 			 *	Its a name... (Labels are subsets ofname) 			 */
name|yylval
operator|=
operator|(
name|int
operator|)
name|op
expr_stmt|;
name|val
operator|=
name|NAME
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
case|case
name|DIG
case|:
name|base
operator|=
literal|10
expr_stmt|;
name|cp
operator|=
name|fltchr
expr_stmt|;
name|intval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|'0'
condition|)
block|{
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|'b'
condition|)
block|{
name|yylval
operator|=
operator|-
literal|1
expr_stmt|;
name|val
operator|=
name|BFINT
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|val
operator|==
literal|'f'
condition|)
block|{
name|yylval
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|BFINT
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|HEXFLAG
argument_list|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|FLOATFLAG
argument_list|)
condition|)
block|{
name|double
name|atof
parameter_list|()
function_decl|;
while|while
condition|(
operator|(
name|cp
operator|<
operator|&
name|fltchr
index|[
literal|63
index|]
operator|)
operator|&&
name|INCHARSET
argument_list|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
operator|(
name|DIGIT
operator||
name|SIGN
operator||
name|FLOATEXP
operator||
name|POINT
operator|)
argument_list|)
condition|)
operator|*
name|cp
operator|++
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|fltchr
condition|)
block|{
name|yylval
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|BFINT
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|ungetc
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|fltval
operator|.
name|dvalue
operator|=
name|atof
argument_list|(
name|fltchr
argument_list|)
expr_stmt|;
name|val
operator|=
name|FLTNUM
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|base
operator|=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
name|forb
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|forb
operator|==
literal|'f'
operator|||
name|forb
operator|==
literal|'b'
condition|)
block|{
name|yylval
operator|=
name|val
operator|-
literal|'0'
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|forb
operator|==
literal|'b'
condition|)
name|yylval
operator|=
operator|-
name|yylval
expr_stmt|;
name|val
operator|=
name|BFINT
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|ungetc
argument_list|(
name|forb
argument_list|)
expr_stmt|;
comment|/* put back non zero */
goto|goto
name|middle
goto|;
block|}
while|while
condition|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'0'
condition|)
continue|continue;
name|ungetc
argument_list|(
name|val
argument_list|)
expr_stmt|;
while|while
condition|(
name|INCHARSET
argument_list|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|DIGIT
argument_list|)
operator|||
operator|(
name|base
operator|==
literal|16
operator|&&
operator|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|HEXLDIGIT
operator||
name|HEXUDIGIT
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|8
condition|)
name|intval
operator|<<=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
literal|10
condition|)
name|intval
operator|*=
literal|10
expr_stmt|;
else|else
block|{
name|intval
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|HEXLDIGIT
argument_list|)
condition|)
name|val
operator|-=
literal|'a'
operator|-
literal|10
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|HEXUDIGIT
argument_list|)
condition|)
name|val
operator|-=
literal|'A'
operator|-
literal|10
operator|-
literal|'0'
expr_stmt|;
block|}
name|middle
label|:
operator|*
name|cp
operator|++
operator|=
operator|(
name|val
operator|-=
literal|'0'
operator|)
expr_stmt|;
name|intval
operator|+=
name|val
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|maxstrlg
operator|=
name|cp
operator|-
name|fltchr
expr_stmt|;
if|if
condition|(
operator|(
name|maxstrlg
operator|>
literal|8
operator|)
operator|&&
operator|(
operator|(
operator|(
name|base
operator|==
literal|8
operator|)
operator|&&
operator|(
operator|(
name|maxstrlg
operator|>
literal|11
operator|)
operator|||
operator|(
operator|(
name|maxstrlg
operator|==
literal|11
operator|)
operator|&&
operator|(
operator|*
name|fltchr
operator|>
literal|3
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|base
operator|==
literal|16
operator|)
operator|&&
operator|(
name|maxstrlg
operator|>
literal|8
operator|)
operator|)
operator|||
operator|(
operator|(
name|base
operator|==
literal|10
operator|)
operator|&&
operator|(
name|maxstrlg
operator|>=
literal|10
operator|)
operator|)
operator|)
condition|)
block|{
name|val
operator|=
name|QUAD
expr_stmt|;
name|get_quad
argument_list|(
name|base
argument_list|,
name|fltchr
argument_list|,
name|cp
argument_list|,
operator|&
name|quadval
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|INT
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|LSH
case|:
case|case
name|RSH
case|:
comment|/* 		 *	We allow the C style operators 		 *<< and>>, as well as< and> 		 */
if|if
condition|(
operator|(
name|base
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|val
condition|)
name|ungetc
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|val
operator|=
name|yylval
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|MINUS
case|:
if|if
condition|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'('
condition|)
name|yylval
operator|=
name|val
operator|=
name|MP
expr_stmt|;
else|else
block|{
name|ungetc
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|MINUS
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
case|case
name|SQ
case|:
if|if
condition|(
operator|(
name|yylval
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
name|scanlineno
operator|++
expr_stmt|;
comment|/*not entirely correct*/
name|intval
operator|=
name|yylval
expr_stmt|;
name|val
operator|=
name|INT
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|DQ
case|:
name|eatstr
label|:
name|linescrossed
operator|=
literal|0
expr_stmt|;
name|maxstrlg
operator|=
operator|(
name|char
operator|*
operator|)
name|bufub
operator|-
operator|(
name|char
operator|*
operator|)
name|bufptr
expr_stmt|;
if|if
condition|(
name|maxstrlg
operator|<
name|MAXSTRLG
condition|)
block|{
name|ungetc
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
operator|*
operator|(
name|toktype
operator|*
operator|)
name|bufptr
operator|=
name|VOID
expr_stmt|;
name|bufub
operator|=
name|bufptr
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|maxstrlg
operator|>
name|MAXSTRLG
condition|)
name|maxstrlg
operator|=
name|MAXSTRLG
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|STRING
argument_list|)
expr_stmt|;
name|lgbackpatch
operator|=
name|bufptr
expr_stmt|;
comment|/*this is where the size goes*/
name|bufptr
operator|+=
sizeof|sizeof
argument_list|(
name|lgtype
argument_list|)
expr_stmt|;
comment|/* 		 *	bufptr is now set to 		 *	be stuffed with characters from 		 *	the input 		 */
while|while
condition|(
operator|(
name|maxstrlg
operator|>
literal|0
operator|)
operator|&&
operator|!
operator|(
name|INCHARSET
argument_list|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|STRESCAPE
argument_list|)
operator|)
condition|)
block|{
name|stuff
label|:
name|maxstrlg
operator|-=
literal|1
expr_stmt|;
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxstrlg
operator|<=
literal|0
condition|)
block|{
comment|/*enough characters to fill a string buffer*/
name|ungetc
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
comment|/*will read it next*/
block|}
elseif|else
if|if
condition|(
name|val
operator|==
literal|'"'
condition|)
empty_stmt|;
comment|/*done*/
elseif|else
if|if
condition|(
name|val
operator|==
literal|'\n'
condition|)
block|{
name|scanlineno
operator|++
expr_stmt|;
name|linescrossed
operator|++
expr_stmt|;
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|EOFCHAR
condition|)
block|{
name|do_eof
label|:
name|pchar
argument_list|(
name|bufptr
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|EOFCHAR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
name|NEEDCHAR
condition|)
block|{
if|if
condition|(
operator|(
name|inbufptr
operator|=
name|fillinbuffer
argument_list|()
operator|)
operator|==
literal|0
condition|)
goto|goto
name|do_eof
goto|;
name|val
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
else|else
block|{
comment|/* simple case */
name|ungetc
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
block|}
else|else
block|{
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip the '\\'*/
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|BSESCAPE
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|'b'
case|:
name|val
operator|=
literal|'\b'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'f'
case|:
name|val
operator|=
literal|'\f'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'n'
case|:
name|val
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'r'
case|:
name|val
operator|=
literal|'\r'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'t'
case|:
name|val
operator|=
literal|'\t'
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|OCTDIGIT
argument_list|)
operator|)
condition|)
goto|goto
name|stuff
goto|;
name|base
operator|=
literal|0
expr_stmt|;
name|intval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|base
operator|<
literal|3
operator|)
operator|&&
operator|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|OCTDIGIT
argument_list|)
operator|)
condition|)
block|{
name|base
operator|++
expr_stmt|;
name|intval
operator|<<=
literal|3
expr_stmt|;
name|intval
operator|+=
name|val
operator|-
literal|'0'
expr_stmt|;
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|)
name|intval
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
comment|/* 		 *	bufptr now points at the next free slot 		 */
name|bstrfromto
argument_list|(
name|lgbackpatch
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|linescrossed
condition|)
block|{
name|val
operator|=
name|ILINESKIP
expr_stmt|;
name|yylval
operator|=
name|linescrossed
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
goto|goto
name|builtval
goto|;
case|case
name|BADCHAR
case|:
name|linescrossed
operator|=
name|lineno
expr_stmt|;
name|lineno
operator|=
name|scanlineno
expr_stmt|;
name|yyerror
argument_list|(
literal|"Illegal character mapped: %d, char read:(octal) %o"
argument_list|,
name|yylval
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|linescrossed
expr_stmt|;
name|val
operator|=
name|BADCHAR
expr_stmt|;
goto|goto
name|ret
goto|;
default|default:
name|val
operator|=
name|yylval
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/*end of the switch*/
comment|/* 	 *	here with one token, so stuff it 	 */
name|ret
label|:
name|oval
operator|=
name|val
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|ILINESKIP
case|:
name|pint
argument_list|(
name|bufptr
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIZESPEC
case|:
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFINT
case|:
name|plong
argument_list|(
name|bufptr
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|plong
argument_list|(
name|bufptr
argument_list|,
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUAD
case|:
name|plong
argument_list|(
name|bufptr
argument_list|,
name|quadval
operator|.
name|quad_low_long
argument_list|)
expr_stmt|;
name|plong
argument_list|(
name|bufptr
argument_list|,
name|quadval
operator|.
name|quad_high_long
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLTNUM
case|:
name|pdouble
argument_list|(
name|bufptr
argument_list|,
name|fltval
operator|.
name|dvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME
case|:
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|INST0
case|:
case|case
name|INSTn
case|:
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|IJXXX
case|:
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|symalloc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISTAB
case|:
case|case
name|ISTABSTR
case|:
case|case
name|ISTABNONE
case|:
case|case
name|ISTABDOT
case|:
case|case
name|IALIGN
case|:
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|symalloc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *	default: 	 */
block|}
name|builtval
label|:
empty_stmt|;
block|}
comment|/*end of the while to stuff the buffer*/
name|done
label|:
name|bufferbox
operator|->
name|tok_count
operator|=
operator|(
name|toktype
operator|*
operator|)
name|bufptr
operator|-
operator|&
operator|(
name|bufferbox
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* 	 *	This is a real kludge: 	 * 	 *	We put the last token in the buffer to be  a MINUS 	 *	symbol.  This last token will never be picked up 	 *	in the normal way, but can be looked at during 	 *	a peekahead look that the short circuit expression 	 *	evaluator uses to see if an expression is complicated. 	 * 	 *	Consider the following situation: 	 * 	 *	.word	45		+	47 	 *        buffer 1      |  buffer 0 	 *	the peekahead would want to look across the buffer, 	 *	but will look in the buffer end zone, see the minus, and 	 *	fail. 	 */
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|MINUS
argument_list|)
expr_stmt|;
name|InBufPtr
operator|=
name|inbufptr
expr_stmt|;
comment|/*copy this back*/
block|}
end_block

begin_decl_stmt
name|struct
name|Quad
name|_quadtemp
decl_stmt|;
end_decl_stmt

begin_macro
name|get_quad
argument_list|(
argument|radix
argument_list|,
argument|cp_start
argument_list|,
argument|cp_end
argument_list|,
argument|quadptr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|radix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cp_start
decl_stmt|,
modifier|*
name|cp_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Quad
modifier|*
name|quadptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|cp_start
decl_stmt|;
comment|/* r11 */
specifier|register
name|struct
name|Quad
modifier|*
name|qp
init|=
name|quadptr
decl_stmt|;
comment|/* r10 */
specifier|register
name|long
name|temp
decl_stmt|;
comment|/* r9 */
asm|asm("clrq (r10)");
for|for
control|(
init|;
name|cp
operator|<
name|cp_end
condition|;
name|cp
operator|++
control|)
block|{
switch|switch
condition|(
name|radix
condition|)
block|{
case|case
literal|8
case|:
asm|asm ("ashq $3, (r10), (r10)");
break|break;
case|case
literal|16
case|:
asm|asm ("ashq $4, (r10), (r10)");
break|break;
case|case
literal|10
case|:
asm|asm ("ashq	$1, (r10), __quadtemp");
asm|asm ("ashq	$3, (r10), (r10)");
asm|asm ("addl2	__quadtemp, (r10)");
asm|asm ("adwc	__quadtemp+4, 4(r10)");
break|break;
block|}
asm|asm ("cvtbl	(r11), r9");
asm|asm ("addl2	r9, (r10)");
asm|asm ("adwc	$0, 4(r10)");
block|}
block|}
end_block

end_unit

