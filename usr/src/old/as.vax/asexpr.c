begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1980 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)asexpr.c 4.1 %G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"asexpr.h"
end_include

begin_comment
comment|/*  * Tables for combination of operands.  */
end_comment

begin_define
define|#
directive|define
name|XTXRN
value|5<<1
end_define

begin_comment
comment|/* indexes last row/column when right shifted */
end_comment

begin_comment
comment|/*  *	table for +  */
end_comment

begin_decl_stmt
name|readonly
name|char
name|pltab
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*		UND	ABS	TXT	DAT	BSS	EXT */
comment|/*UND*/
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
comment|/*ABS*/
name|XUNDEF
block|,
name|XABS
block|,
name|XTEXT
block|,
name|XDATA
block|,
name|XBSS
block|,
name|XXTRN
block|,
comment|/*TXT*/
name|XUNDEF
block|,
name|XTEXT
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*DAT*/
name|XUNDEF
block|,
name|XDATA
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*BSS*/
name|XUNDEF
block|,
name|XBSS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*EXT*/
name|XUNDEF
block|,
name|XXTRN
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	table for -  */
end_comment

begin_decl_stmt
name|readonly
name|char
name|mintab
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*		UND	ABS	TXT	DAT	BSS	EXT */
comment|/*UND*/
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
comment|/*ABS*/
name|XUNDEF
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*TXT*/
name|XUNDEF
block|,
name|XTEXT
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*DAT*/
name|XUNDEF
block|,
name|XDATA
block|,
name|ERR
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*BSS*/
name|XUNDEF
block|,
name|XBSS
block|,
name|ERR
block|,
name|ERR
block|,
name|XABS
block|,
name|ERR
block|,
comment|/*EXT*/
name|XUNDEF
block|,
name|XXTRN
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   *	table for other operators  */
end_comment

begin_decl_stmt
name|readonly
name|char
name|othtab
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*		UND	ABS	TXT	DAT	BSS	EXT */
comment|/*UND*/
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
comment|/*ABS*/
name|XUNDEF
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*TXT*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*DAT*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*BSS*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*EXT*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|exp
modifier|*
name|combine
parameter_list|(
name|op
parameter_list|,
name|exp1
parameter_list|,
name|exp2
parameter_list|)
specifier|register
name|struct
name|exp
modifier|*
name|exp1
decl_stmt|,
decl|*
name|exp2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|e1_type
operator|,
name|e2_type
expr_stmt|;
specifier|register
name|type
expr_stmt|;
name|lastnam
operator|=
literal|0
expr_stmt|;
comment|/* kludge for jxxx instructions */
name|e1_type
operator|=
name|exp1
operator|->
name|xtype
operator|&
name|XTYPE
expr_stmt|;
name|e2_type
operator|=
name|exp2
operator|->
name|xtype
operator|&
name|XTYPE
expr_stmt|;
if|if
condition|(
name|exp1
operator|->
name|xtype
operator|==
name|XXTRN
operator|+
name|XUNDEF
condition|)
name|e1_type
operator|=
name|XTXRN
expr_stmt|;
if|if
condition|(
name|exp2
operator|->
name|xtype
operator|==
name|XXTRN
operator|+
name|XUNDEF
condition|)
name|e2_type
operator|=
name|XTXRN
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
if|if
condition|(
name|exp1
operator|->
name|xloc
operator|!=
name|exp2
operator|->
name|xloc
operator|&&
name|e1_type
operator|==
name|e2_type
condition|)
name|e1_type
operator|=
name|e2_type
operator|=
name|XTXRN
expr_stmt|;
comment|/* error on != loc ctrs */
name|e1_type
operator|>>=
literal|1
expr_stmt|;
comment|/*dispose of the external (XXTRN) bit*/
name|e2_type
operator|>>=
literal|1
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|PLUS
case|:
name|exp1
operator|->
name|xvalue
operator|+=
name|exp2
operator|->
name|xvalue
expr_stmt|;
name|type
operator|=
name|pltab
index|[
name|e1_type
index|]
index|[
name|e2_type
index|]
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|exp1
operator|->
name|xvalue
operator|-=
name|exp2
operator|->
name|xvalue
expr_stmt|;
name|type
operator|=
name|mintab
index|[
name|e1_type
index|]
index|[
name|e2_type
index|]
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|exp1
operator|->
name|xvalue
operator||=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|XOR
case|:
name|exp1
operator|->
name|xvalue
operator|^=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|AND
case|:
name|exp1
operator|->
name|xvalue
operator|&=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|ORNOT
case|:
name|exp1
operator|->
name|xvalue
operator||=
operator|~
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|LSH
case|:
name|exp1
operator|->
name|xvalue
operator|<<=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|RSH
case|:
name|exp1
operator|->
name|xvalue
operator|>>=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|TILDE
case|:
name|exp1
operator|->
name|xvalue
operator||=
operator|~
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|MUL
case|:
name|exp1
operator|->
name|xvalue
operator|*=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|DIV
case|:
if|if
condition|(
name|exp2
operator|->
name|xvalue
operator|==
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Divide check"
argument_list|)
expr_stmt|;
else|else
name|exp1
operator|->
name|xvalue
operator|/=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|REGOP
case|:
if|if
condition|(
name|exp2
operator|->
name|xvalue
operator|==
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Divide check (modulo)"
argument_list|)
expr_stmt|;
else|else
name|exp1
operator|->
name|xvalue
operator|%=
name|exp2
operator|->
name|xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
name|comm
label|:
name|type
operator|=
name|othtab
index|[
name|e1_type
index|]
index|[
name|e2_type
index|]
expr_stmt|;
break|break;
default|default:
name|yyerror
argument_list|(
literal|"Internal error: unknown operator"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e2_type
operator|==
operator|(
name|XTXRN
operator|>>
literal|1
operator|)
condition|)
name|exp1
operator|->
name|xname
operator|=
name|exp2
operator|->
name|xname
expr_stmt|;
name|exp1
operator|->
name|xtype
operator|=
name|type
operator||
operator|(
operator|(
name|exp1
operator|->
name|xtype
operator||
name|exp2
operator|->
name|xtype
operator|)
operator|&
operator|(
name|XFORW
operator||
name|XXTRN
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ERR
condition|)
name|yyerror
argument_list|(
literal|"Relocation error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|exp1
operator|)
return|;
block|}
end_block

begin_macro
name|buildtokensets
argument_list|()
end_macro

begin_block
block|{
define|#
directive|define
name|clobber
parameter_list|(
name|val
parameter_list|,
name|set
parameter_list|)
value|tokensets[(val)] |= (set)
name|clobber
argument_list|(
name|SEMI
argument_list|,
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|NL
argument_list|,
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INT
argument_list|,
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|NAME
argument_list|,
name|YUKKYEXPRBEG
operator|+
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INSTn
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INST0
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|REG
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|BFINT
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INT
argument_list|,
name|SAFEEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|FLTNUM
argument_list|,
name|SAFEEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|PLUS
argument_list|,
name|ADDOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|MINUS
argument_list|,
name|ADDOPS
operator|+
name|EBEGOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|LP
argument_list|,
name|EBEGOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|IOR
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|XOR
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|AND
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|ORNOT
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|TILDE
argument_list|,
name|MULOPS
operator|+
name|EBEGOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|LSH
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|RSH
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|MUL
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|DIV
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|REGOP
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
comment|/* % */
block|}
end_block

begin_comment
comment|/*  *	We keep the current token class in this global variable, so   *	the recursive descent expression analyzers can talk amongst  *	themselves, and so that we may use the macros shift and shift over  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the value of the lexical value*/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|exp
modifier|*
name|xp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the next free expression slot*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|val
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|exprparse
parameter_list|(
name|inval
parameter_list|,
name|backexpr
parameter_list|)
comment|/*return the value the read head is sitting on*/
name|int
name|inval
decl_stmt|;
name|struct
name|exp
modifier|*
modifier|*
name|backexpr
decl_stmt|;
block|{
specifier|register
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|int
name|op
decl_stmt|;
name|val
operator|=
name|inval
expr_stmt|;
name|lexpr
operator|=
name|boolterm
argument_list|()
expr_stmt|;
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|ADDOPS
argument_list|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|boolterm
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|*
name|backexpr
operator|=
name|lexpr
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|boolterm
parameter_list|()
block|{
specifier|register
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|int
name|op
decl_stmt|;
name|lexpr
operator|=
name|term
argument_list|()
expr_stmt|;
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|BOOLOPS
argument_list|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|term
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lexpr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|term
parameter_list|()
block|{
specifier|register
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|int
name|op
decl_stmt|;
name|lexpr
operator|=
name|factor
argument_list|()
expr_stmt|;
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|MULOPS
argument_list|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|factor
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lexpr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|factor
parameter_list|()
block|{
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|int
name|op
decl_stmt|;
specifier|extern
name|int
name|droppedLP
decl_stmt|;
comment|/*called exprparse after consuming an LP*/
if|if
condition|(
name|val
operator|==
name|LP
operator|||
name|droppedLP
condition|)
block|{
if|if
condition|(
name|droppedLP
condition|)
name|droppedLP
operator|=
literal|0
expr_stmt|;
else|else
name|shift
expr_stmt|;
comment|/*the LP*/
name|val
operator|=
name|exprparse
argument_list|(
name|val
argument_list|,
operator|&
name|lexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|RP
condition|)
name|yyerror
argument_list|(
literal|"right parenthesis expected"
argument_list|)
expr_stmt|;
else|else
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
condition|)
block|{
name|lexpr
operator|=
name|yukkyexpr
argument_list|(
name|val
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|SAFEEXPRBEG
argument_list|)
condition|)
block|{
name|lexpr
operator|=
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
expr_stmt|;
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|==
name|TILDE
operator|)
operator|||
operator|(
name|val
operator|==
name|MINUS
operator|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|xp
operator|++
expr_stmt|;
name|lexpr
operator|->
name|xtype
operator|=
name|XABS
expr_stmt|;
name|lexpr
operator|->
name|xvalue
operator|=
literal|0
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|factor
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yyerror
argument_list|(
literal|"Bad expression syntax"
argument_list|)
expr_stmt|;
name|lexpr
operator|=
name|xp
operator|++
expr_stmt|;
name|lexpr
operator|->
name|xtype
operator|=
name|XABS
expr_stmt|;
name|lexpr
operator|->
name|xvalue
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|lexpr
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|exp
modifier|*
name|yukkyexpr
argument_list|(
name|val
argument_list|,
name|np
argument_list|)
name|int
name|val
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|np
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|exp
modifier|*
name|locxp
decl_stmt|;
specifier|extern
name|int
name|exprisname
decl_stmt|;
comment|/*last factor is a name*/
name|exprisname
operator|=
literal|0
expr_stmt|;
name|locxp
operator|=
name|xp
operator|++
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NAME
operator|||
name|val
operator|==
name|BFINT
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|BFINT
condition|)
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
name|yylval
operator|=
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|np
operator|)
operator|->
name|xvalue
expr_stmt|;
if|if
condition|(
name|yylval
operator|<
literal|0
condition|)
block|{
name|yylval
operator|=
operator|-
name|yylval
expr_stmt|;
name|yylval
operator|--
expr_stmt|;
name|off
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lgensym
index|[
name|yylval
index|]
operator|==
literal|1
condition|)
name|yyerror
argument_list|(
literal|"Reference to undefined local label %db"
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|--
expr_stmt|;
name|genref
index|[
name|yylval
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|yytext
argument_list|,
literal|"L%d\001%d"
argument_list|,
name|yylval
argument_list|,
name|lgensym
index|[
name|yylval
index|]
operator|+
name|off
argument_list|)
expr_stmt|;
name|yylval
operator|=
name|np
operator|=
operator|(
name|int
operator|)
operator|*
name|lookup
argument_list|(
name|passno
operator|==
literal|1
argument_list|)
expr_stmt|;
name|lastnam
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
expr_stmt|;
block|}
name|exprisname
operator|++
expr_stmt|;
name|locxp
operator|->
name|xtype
operator|=
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|type
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|type
operator|&
name|XTYPE
operator|)
operator|==
name|XUNDEF
condition|)
block|{
comment|/*forward*/
name|locxp
operator|->
name|xname
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
expr_stmt|;
name|locxp
operator|->
name|xvalue
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|type
operator||=
name|XFORW
expr_stmt|;
block|}
else|else
block|{
comment|/*otherwise, just get the value*/
name|locxp
operator|->
name|xvalue
operator|=
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|value
expr_stmt|;
name|locxp
operator|->
name|xname
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*INSTn or INST0 or REG*/
name|locxp
operator|->
name|xtype
operator|=
name|XABS
expr_stmt|;
name|locxp
operator|->
name|xvalue
operator|=
operator|(
operator|(
name|int
operator|)
name|np
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|locxp
operator|->
name|xloc
operator|=
literal|0
expr_stmt|;
name|locxp
operator|->
name|xname
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|locxp
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|tok_name
index|[
name|LASTTOKEN
operator|-
name|FIRSTTOKEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|Tok_Desc
block|{
name|int
name|tok_which
decl_stmt|;
name|char
modifier|*
name|tok_name
decl_stmt|;
block|}
name|tok_desc
index|[]
init|=
block|{
name|FIRSTTOKEN
block|,
literal|"firsttoken"
block|,
comment|/* 0 */
name|ISPACE
block|,
literal|"ispace"
block|,
comment|/* 1 */
name|IBYTE
block|,
literal|"ibyte"
block|,
comment|/* 2 */
name|IWORD
block|,
literal|"iword"
block|,
comment|/* 3 */
name|IINT
block|,
literal|"iint"
block|,
comment|/* 4 */
name|ILONG
block|,
literal|"ilong"
block|,
comment|/* 5 */
name|IDATA
block|,
literal|"idata"
block|,
comment|/* 6 */
name|IGLOBAL
block|,
literal|"iglobal"
block|,
comment|/* 7 */
name|ISET
block|,
literal|"iset"
block|,
comment|/* 8 */
name|ITEXT
block|,
literal|"itext"
block|,
comment|/* 9 */
name|ICOMM
block|,
literal|"icomm"
block|,
comment|/* 10 */
name|ILCOMM
block|,
literal|"ilcomm"
block|,
comment|/* 11 */
name|IFLOAT
block|,
literal|"ifloat"
block|,
comment|/* 12 */
name|IDOUBLE
block|,
literal|"idouble"
block|,
comment|/* 13 */
name|IORG
block|,
literal|"iorg"
block|,
comment|/* 14 */
name|IASCII
block|,
literal|"iascii"
block|,
comment|/* 15 */
name|IASCIZ
block|,
literal|"iasciz"
block|,
comment|/* 16 */
name|ILSYM
block|,
literal|"ilsym"
block|,
comment|/* 17 */
name|IFILE
block|,
literal|"ifile"
block|,
comment|/* 18 */
name|ILINENO
block|,
literal|"ilineno"
block|,
comment|/* 19 */
name|IABORT
block|,
literal|"iabort"
block|,
comment|/* 20 */
name|ISTAB
block|,
literal|"istab"
block|,
comment|/* 23 */
name|ISTABSTR
block|,
literal|"istabstr"
block|,
comment|/* 24 */
name|ISTABNONE
block|,
literal|"istabnone"
block|,
comment|/* 25 */
name|ISTABDOT
block|,
literal|"istabdot"
block|,
comment|/* 26 */
name|IJXXX
block|,
literal|"ijxxx"
block|,
comment|/* 27 */
name|IALIGN
block|,
literal|"ialign"
block|,
comment|/* 28 */
name|INST0
block|,
literal|"inst0"
block|,
comment|/* 29 */
name|INSTn
block|,
literal|"instn"
block|,
comment|/* 30 */
name|BFINT
block|,
literal|"bfint"
block|,
comment|/* 31 */
name|PARSEEOF
block|,
literal|"parseeof"
block|,
comment|/* 32 */
name|ILINESKIP
block|,
literal|"ilineskip"
block|,
comment|/* 33 */
name|VOID
block|,
literal|"void"
block|,
comment|/* 34 */
name|SKIP
block|,
literal|"skip"
block|,
comment|/* 35 */
name|INT
block|,
literal|"int"
block|,
comment|/* 36 */
name|FLTNUM
block|,
literal|"fltnum"
block|,
comment|/* 37 */
name|NAME
block|,
literal|"name"
block|,
comment|/* 38 */
name|STRING
block|,
literal|"string"
block|,
comment|/* 39 */
name|QUAD
block|,
literal|"quad"
block|,
comment|/* 40 */
name|SIZESPEC
block|,
literal|"sizespec"
block|,
comment|/* 41 */
name|REG
block|,
literal|"reg"
block|,
comment|/* 42 */
name|MUL
block|,
literal|"mul"
block|,
comment|/* 43 */
name|LITOP
block|,
literal|"litop"
block|,
comment|/* 44 */
name|LP
block|,
literal|"lp"
block|,
comment|/* 45 */
name|MP
block|,
literal|"mp"
block|,
comment|/* 46 */
name|NEEDSBUF
block|,
literal|"needsbuf"
block|,
comment|/* 48 */
name|REGOP
block|,
literal|"regop"
block|,
comment|/* 49 */
name|NL
block|,
literal|"nl"
block|,
comment|/* 50 */
name|SCANEOF
block|,
literal|"scaneof"
block|,
comment|/* 51 */
name|BADCHAR
block|,
literal|"badchar"
block|,
comment|/* 52 */
name|SP
block|,
literal|"sp"
block|,
comment|/* 53 */
name|ALPH
block|,
literal|"alph"
block|,
comment|/* 54 */
name|DIG
block|,
literal|"dig"
block|,
comment|/* 55 */
name|SQ
block|,
literal|"sq"
block|,
comment|/* 56 */
name|DQ
block|,
literal|"dq"
block|,
comment|/* 57 */
name|SH
block|,
literal|"sh"
block|,
comment|/* 58 */
name|LSH
block|,
literal|"lsh"
block|,
comment|/* 59 */
name|RSH
block|,
literal|"rsh"
block|,
comment|/* 60 */
name|MINUS
block|,
literal|"minus"
block|,
comment|/* 61 */
name|SIZEQUOTE
block|,
literal|"sizequote"
block|,
comment|/* 62 */
name|XOR
block|,
literal|"xor"
block|,
comment|/* 64 */
name|DIV
block|,
literal|"div"
block|,
comment|/* 65 */
name|SEMI
block|,
literal|"semi"
block|,
comment|/* 66 */
name|COLON
block|,
literal|"colon"
block|,
comment|/* 67 */
name|PLUS
block|,
literal|"plus"
block|,
comment|/* 68 */
name|IOR
block|,
literal|"ior"
block|,
comment|/* 69 */
name|AND
block|,
literal|"and"
block|,
comment|/* 70 */
name|TILDE
block|,
literal|"tilde"
block|,
comment|/* 71 */
name|ORNOT
block|,
literal|"ornot"
block|,
comment|/* 72 */
name|CM
block|,
literal|"cm"
block|,
comment|/* 73 */
name|LB
block|,
literal|"lb"
block|,
comment|/* 74 */
name|RB
block|,
literal|"rb"
block|,
comment|/* 75 */
name|RP
block|,
literal|"rp"
block|,
comment|/* 76 */
name|LASTTOKEN
block|,
literal|"lasttoken"
comment|/* 80 */
block|}
struct|;
end_struct

begin_comment
comment|/*  *	turn a token type into a string  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fixed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|tok_to_name
parameter_list|(
name|token
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fixed
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRSTTOKEN
init|;
name|i
operator|<=
name|LASTTOKEN
condition|;
name|i
operator|++
control|)
name|tok_name
index|[
name|i
index|]
operator|=
literal|"NOT ASSIGNED"
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRSTTOKEN
init|;
name|i
operator|<=
sizeof|sizeof
argument_list|(
name|tok_desc
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|Tok_Desc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tok_name
index|[
name|tok_desc
index|[
name|i
index|]
operator|.
name|tok_which
index|]
operator|=
name|tok_desc
index|[
name|i
index|]
operator|.
name|tok_name
expr_stmt|;
block|}
name|fixed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|FIRSTTOKEN
operator|<=
name|token
operator|&&
name|token
operator|<=
name|LASTTOKEN
condition|)
return|return
operator|(
name|tok_name
index|[
name|token
index|]
operator|)
return|;
else|else
name|panic
argument_list|(
literal|"Unknown token number, %d\n"
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

end_unit

