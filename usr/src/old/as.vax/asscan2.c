begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright (c) 1982 Regents of the University of California  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)asscan2.c 4.10 %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"asscanl.h"
end_include

begin_decl_stmt
specifier|static
name|inttoktype
name|oval
init|=
name|NL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|inbufunget
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|inbuffer
index|[
name|ASINBUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Ginbufptr
init|=
name|inbuffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Ginbufcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|fillinbuffer
argument_list|()
end_macro

begin_block
block|{
name|int
name|nread
decl_stmt|;
specifier|static
name|int
name|hadeof
decl_stmt|;
name|int
name|goal
decl_stmt|;
name|int
name|got
decl_stmt|;
name|nread
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hadeof
operator|==
literal|0
condition|)
block|{
name|goal
operator|=
sizeof|sizeof
argument_list|(
name|inbuffer
argument_list|)
expr_stmt|;
do|do
block|{
name|got
operator|=
name|read
argument_list|(
name|stdin
operator|->
name|_file
argument_list|,
name|inbuffer
operator|+
name|nread
argument_list|,
name|goal
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|==
literal|0
condition|)
name|hadeof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|got
operator|<=
literal|0
condition|)
break|break;
name|nread
operator|+=
name|got
expr_stmt|;
name|goal
operator|-=
name|got
expr_stmt|;
block|}
do|while
condition|(
name|goal
condition|)
do|;
block|}
comment|/* 	 *	getchar assumes that Ginbufcnt and Ginbufptr 	 *	are adjusted as if one character has been removed 	 *	from the input. 	 */
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
block|{
name|inbuffer
index|[
literal|0
index|]
operator|=
name|EOFCHAR
expr_stmt|;
name|nread
operator|=
literal|1
expr_stmt|;
block|}
name|Ginbufcnt
operator|=
name|nread
operator|-
literal|1
expr_stmt|;
name|Ginbufptr
operator|=
name|inbuffer
operator|+
literal|1
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|FLEXNAMES
end_ifndef

begin_decl_stmt
name|char
name|strtext
index|[
name|NCPString
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
else|FLEXNAMES
end_else

begin_if
if|#
directive|if
name|NCPName
operator|<
name|NCPString
end_if

begin_decl_stmt
name|char
name|strtext
index|[
name|NCPString
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|strtext
value|yytext
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
endif|FLEXNAMES
end_endif

begin_macro
name|scan_dot_s
argument_list|(
argument|bufferbox
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tokbufdesc
modifier|*
name|bufferbox
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|char
modifier|*
name|inbufptr
decl_stmt|;
name|reg
name|int
name|inbufcnt
decl_stmt|;
name|reg
name|int
name|ryylval
decl_stmt|;
comment|/* local copy of lexical value */
specifier|extern
name|int
name|yylval
decl_stmt|;
comment|/* global copy of lexical value */
name|reg
name|int
name|val
decl_stmt|;
comment|/* the value returned */
name|int
name|i
decl_stmt|;
comment|/* simple counter */
name|reg
name|char
modifier|*
name|rcp
decl_stmt|;
name|int
name|ch
decl_stmt|;
comment|/* treated as a character */
name|int
name|ch1
decl_stmt|;
comment|/* shadow value */
name|struct
name|symtab
modifier|*
name|op
decl_stmt|;
name|ptrall
name|lgbackpatch
decl_stmt|;
comment|/* where to stuff a string length */
name|reg
name|ptrall
name|bufptr
decl_stmt|;
comment|/* where to stuff tokens */
name|ptrall
name|bufub
decl_stmt|;
comment|/* where not to stuff tokens */
name|reg
name|int
name|strlg
decl_stmt|;
comment|/* the length of a string */
name|long
name|intval
decl_stmt|;
comment|/* value of int */
name|int
name|linescrossed
decl_stmt|;
comment|/* when doing strings and comments */
name|struct
name|Opcode
name|opstruct
decl_stmt|;
name|struct
name|strdesc
name|strd
decl_stmt|;
comment|/* for building DQ strings */
operator|(
name|bytetoktype
operator|*
operator|)
name|bufptr
operator|=
operator|(
name|bytetoktype
operator|*
operator|)
operator|&
operator|(
name|bufferbox
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
operator|(
name|bytetoktype
operator|*
operator|)
name|bufub
operator|=
operator|&
operator|(
name|bufferbox
operator|->
name|toks
index|[
name|AVAILTOKS
index|]
operator|)
expr_stmt|;
name|MEMTOREGBUF
expr_stmt|;
if|if
condition|(
name|newfflag
condition|)
block|{
name|newfflag
operator|=
literal|0
expr_stmt|;
name|strd
operator|.
name|sd_stroff
operator|=
name|strfilepos
expr_stmt|;
name|strd
operator|.
name|sd_place
operator|=
name|STR_BOTH
expr_stmt|;
name|strd
operator|.
name|sd_strlen
operator|=
name|strlen
argument_list|(
name|newfname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fputs
argument_list|(
name|newfname
argument_list|,
name|strfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0
argument_list|,
name|strfile
argument_list|)
expr_stmt|;
name|strfilepos
operator|+=
name|strd
operator|.
name|sd_strlen
expr_stmt|;
name|ryylval
operator|=
operator|(
name|int
operator|)
name|savestr
argument_list|(
name|newfname
argument_list|,
operator|&
name|strd
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|IFILE
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|STRING
argument_list|)
expr_stmt|;
name|pptr
argument_list|(
name|bufptr
argument_list|,
name|ryylval
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|ILINENO
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|pint
argument_list|(
name|bufptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|bufptr
operator|<
name|bufub
condition|)
block|{
name|loop
label|:
switch|switch
condition|(
name|ryylval
operator|=
operator|(
name|type
operator|+
literal|1
operator|)
index|[
name|ch
operator|=
name|getchar
argument_list|()
index|]
condition|)
block|{
case|case
name|SCANEOF
case|:
name|endoffile
label|:
empty_stmt|;
name|inbufptr
operator|=
literal|0
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|PARSEEOF
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|DIV
case|:
comment|/*process C style comments*/
if|if
condition|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'*'
condition|)
block|{
comment|/*comment prelude*/
name|int
name|incomment
decl_stmt|;
name|linescrossed
operator|=
literal|0
expr_stmt|;
name|incomment
operator|=
literal|1
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip over the * */
while|while
condition|(
name|incomment
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'*'
case|:
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|incomment
operator|=
operator|(
name|ch
operator|!=
literal|'/'
operator|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|scanlineno
operator|++
expr_stmt|;
name|linescrossed
operator|++
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOFCHAR
case|:
goto|goto
name|endoffile
goto|;
default|default:
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|val
operator|=
name|ILINESKIP
expr_stmt|;
name|ryylval
operator|=
name|linescrossed
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
comment|/*just an ordinary DIV*/
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|val
operator|=
name|ryylval
operator|=
name|DIV
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
case|case
name|SH
case|:
if|if
condition|(
name|oval
operator|==
name|NL
condition|)
block|{
comment|/* 			 *	Attempt to recognize a C preprocessor 			 *	style comment '^#[ \t]*[0-9]*[ \t]*".*" 			 */
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*bump the #*/
while|while
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|SPACE
argument_list|)
condition|)
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*bump white */
if|if
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
name|intval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
name|intval
operator|=
name|intval
operator|*
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|SPACE
argument_list|)
condition|)
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
block|{
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|ILINENO
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|pint
argument_list|(
name|bufptr
argument_list|,
name|intval
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|IFILE
argument_list|)
expr_stmt|;
comment|/* 					 *	The '"' has already been 					 *	munched 					 *	 					 *	eatstr will not eat 					 *	the trailing \n, so 					 *	it is given to the parser 					 *	and counted. 					 */
goto|goto
name|eatstr
goto|;
block|}
block|}
block|}
comment|/* 		 *	Well, its just an ordinary decadent comment 		 */
while|while
condition|(
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|ch
operator|!=
name|EOFCHAR
operator|)
condition|)
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOFCHAR
condition|)
goto|goto
name|endoffile
goto|;
name|val
operator|=
name|ryylval
operator|=
name|oval
operator|=
name|NL
expr_stmt|;
name|scanlineno
operator|++
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|NL
case|:
name|scanlineno
operator|++
expr_stmt|;
name|val
operator|=
name|ryylval
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|SP
case|:
name|oval
operator|=
name|SP
expr_stmt|;
comment|/*invalidate ^# meta comments*/
goto|goto
name|loop
goto|;
case|case
name|REGOP
case|:
comment|/* % , could be used as modulo, or register*/
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
name|ryylval
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|INCHARSET
argument_list|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|REGDIGIT
argument_list|)
condition|)
name|ryylval
operator|=
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
else|else
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
comment|/* 			 *	God only knows what the original author 			 *	wanted this undocumented feature to 			 *	do. 			 *		%5++ is really  r7 			 */
while|while
condition|(
name|INCHARSET
argument_list|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|SIGN
argument_list|)
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
name|ryylval
operator|++
expr_stmt|;
else|else
name|ryylval
operator|--
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG
expr_stmt|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|val
operator|=
name|REGOP
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
case|case
name|ALPH
case|:
name|ch1
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|SZSPECBEGIN
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'`'
operator|||
name|ch
operator|==
literal|'^'
condition|)
block|{
name|ch1
operator||=
literal|0100
expr_stmt|;
comment|/*convert to lower*/
switch|switch
condition|(
name|ch1
condition|)
block|{
case|case
literal|'b'
case|:
name|ryylval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|ryylval
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|ryylval
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|ryylval
operator|=
name|d124
expr_stmt|;
break|break;
block|}
name|val
operator|=
name|SIZESPEC
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
name|ch1
expr_stmt|;
comment|/*restore first character*/
block|}
block|}
name|rcp
operator|=
name|yytext
expr_stmt|;
do|do
block|{
if|if
condition|(
name|rcp
operator|<
operator|&
name|yytext
index|[
name|NCPName
index|]
condition|)
operator|*
name|rcp
operator|++
operator|=
name|ch
expr_stmt|;
block|}
do|while
condition|(
name|INCHARSET
argument_list|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|ALPHA
operator||
name|DIGIT
argument_list|)
condition|)
do|;
operator|*
name|rcp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|SPACE
argument_list|)
condition|)
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|op
operator|=
operator|*
name|lookup
argument_list|(
literal|1
argument_list|)
operator|)
operator|->
name|s_tag
condition|)
block|{
case|case
literal|0
case|:
case|case
name|LABELID
case|:
comment|/* 			 *	Its a name... (Labels are subsets of name) 			 */
name|ryylval
operator|=
operator|(
name|int
operator|)
name|op
expr_stmt|;
name|val
operator|=
name|NAME
expr_stmt|;
break|break;
case|case
name|INST0
case|:
case|case
name|INSTn
case|:
case|case
name|IJXXX
case|:
name|opstruct
operator|.
name|Op_popcode
operator|=
operator|(
operator|(
expr|struct
name|instab
operator|*
operator|)
name|op
operator|)
operator|->
name|i_popcode
expr_stmt|;
name|opstruct
operator|.
name|Op_eopcode
operator|=
operator|(
operator|(
expr|struct
name|instab
operator|*
operator|)
name|op
operator|)
operator|->
name|i_eopcode
expr_stmt|;
name|val
operator|=
name|op
operator|->
name|s_tag
expr_stmt|;
break|break;
default|default:
name|ryylval
operator|=
operator|(
operator|(
expr|struct
name|instab
operator|*
operator|)
name|op
operator|)
operator|->
name|i_popcode
expr_stmt|;
name|val
operator|=
name|op
operator|->
name|s_tag
expr_stmt|;
break|break;
block|}
goto|goto
name|ret
goto|;
case|case
name|DIG
case|:
comment|/* 		 *	restore local inbufptr and inbufcnt 		 */
name|REGTOMEMBUF
expr_stmt|;
name|val
operator|=
name|number
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|MEMTOREGBUF
expr_stmt|;
comment|/* 		 *	yylval or yybignum has been stuffed as a side 		 *	effect to number(); get the global yylval 		 *	into our fast local copy in case it was an INT. 		 */
name|ryylval
operator|=
name|yylval
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|LSH
case|:
case|case
name|RSH
case|:
comment|/* 		 *	We allow the C style operators 		 *<< and>>, as well as< and> 		 */
if|if
condition|(
operator|(
name|ch1
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|ch
condition|)
name|ungetc
argument_list|(
name|ch1
argument_list|)
expr_stmt|;
name|val
operator|=
name|ryylval
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|MINUS
case|:
if|if
condition|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'('
condition|)
name|ryylval
operator|=
name|val
operator|=
name|MP
expr_stmt|;
else|else
block|{
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|val
operator|=
name|MINUS
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
case|case
name|SQ
case|:
if|if
condition|(
operator|(
name|ryylval
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
name|scanlineno
operator|++
expr_stmt|;
comment|/*not entirely correct*/
name|val
operator|=
name|INT
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|DQ
case|:
name|eatstr
label|:
name|linescrossed
operator|=
literal|0
expr_stmt|;
name|strd
operator|.
name|sd_stroff
operator|=
name|strfilepos
expr_stmt|;
name|strd
operator|.
name|sd_place
operator|=
name|STR_FILE
expr_stmt|;
for|for
control|(
name|strd
operator|.
name|sd_strlen
operator|=
literal|0
init|;
comment|/*VOID*/
condition|;
name|strd
operator|.
name|sd_strlen
operator|++
control|)
block|{
switch|switch
condition|(
name|ch
operator|=
name|getchar
argument_list|()
condition|)
block|{
case|case
literal|'"'
case|:
goto|goto
name|tailDQ
goto|;
default|default:
name|stuff
label|:
name|putc
argument_list|(
name|ch
argument_list|,
name|strfile
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|yywarning
argument_list|(
literal|"New line in a string constant"
argument_list|)
expr_stmt|;
name|scanlineno
operator|++
expr_stmt|;
name|linescrossed
operator|++
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|EOFCHAR
case|:
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|strfile
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|EOFCHAR
argument_list|)
expr_stmt|;
goto|goto
name|tailDQ
goto|;
default|default:
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
break|break;
case|case
literal|'\\'
case|:
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip the '\\'*/
if|if
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|BSESCAPE
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'b'
case|:
name|ch
operator|=
literal|'\b'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'f'
case|:
name|ch
operator|=
literal|'\f'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'n'
case|:
name|ch
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'r'
case|:
name|ch
operator|=
literal|'\r'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'t'
case|:
name|ch
operator|=
literal|'\t'
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|OCTDIGIT
argument_list|)
operator|)
condition|)
goto|goto
name|stuff
goto|;
name|i
operator|=
literal|0
expr_stmt|;
name|intval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
literal|3
operator|)
operator|&&
operator|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|OCTDIGIT
argument_list|)
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|intval
operator|<<=
literal|3
expr_stmt|;
name|intval
operator|+=
name|ch
operator|-
literal|'0'
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
name|char
operator|)
name|intval
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
block|}
name|tailDQ
label|:
empty_stmt|;
comment|/* 		 *	account for any lines that were crossed 		 */
if|if
condition|(
name|linescrossed
condition|)
block|{
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|ILINESKIP
argument_list|)
expr_stmt|;
name|pint
argument_list|(
name|bufptr
argument_list|,
name|linescrossed
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *	put the string in strtext into the string pool 		 * 		 *	Cheat: append a trailing null to the string 		 *	and then adjust the string length to ignore 		 *	the trailing null.  If any STRING client requires 		 *	the trailing null, the client can just change STRLEN 		 */
name|val
operator|=
name|STRING
expr_stmt|;
name|putc
argument_list|(
literal|0
argument_list|,
name|strfile
argument_list|)
expr_stmt|;
name|strd
operator|.
name|sd_strlen
operator|+=
literal|1
expr_stmt|;
name|strfilepos
operator|+=
name|strd
operator|.
name|sd_strlen
expr_stmt|;
name|ryylval
operator|=
operator|(
name|int
operator|)
name|savestr
argument_list|(
name|strtext
argument_list|,
operator|&
name|strd
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|ryylval
operator|)
operator|->
name|sd_strlen
operator|-=
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|BADCHAR
case|:
name|linescrossed
operator|=
name|lineno
expr_stmt|;
name|lineno
operator|=
name|scanlineno
expr_stmt|;
name|yyerror
argument_list|(
literal|"Illegal character mapped: %d, char read:(octal) %o"
argument_list|,
name|ryylval
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|linescrossed
expr_stmt|;
name|val
operator|=
name|BADCHAR
expr_stmt|;
goto|goto
name|ret
goto|;
default|default:
name|val
operator|=
name|ryylval
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/*end of the switch*/
comment|/* 	 *	here with one token, so stuff it 	 */
name|ret
label|:
name|oval
operator|=
name|val
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|ILINESKIP
case|:
name|pint
argument_list|(
name|bufptr
argument_list|,
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIZESPEC
case|:
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFINT
case|:
name|plong
argument_list|(
name|bufptr
argument_list|,
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|plong
argument_list|(
name|bufptr
argument_list|,
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIGNUM
case|:
name|pnumber
argument_list|(
name|bufptr
argument_list|,
name|yybignum
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
name|char
operator|*
operator|)
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME
case|:
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|INST0
case|:
case|case
name|INSTn
case|:
name|popcode
argument_list|(
name|bufptr
argument_list|,
name|opstruct
argument_list|)
expr_stmt|;
break|break;
case|case
name|IJXXX
case|:
name|popcode
argument_list|(
name|bufptr
argument_list|,
name|opstruct
argument_list|)
expr_stmt|;
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|symalloc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISTAB
case|:
case|case
name|ISTABSTR
case|:
case|case
name|ISTABNONE
case|:
case|case
name|ISTABDOT
case|:
case|case
name|IALIGN
case|:
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|symalloc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *	default: 	 */
block|}
name|builtval
label|:
empty_stmt|;
block|}
comment|/*end of the while to stuff the buffer*/
name|done
label|:
name|bufferbox
operator|->
name|tok_count
operator|=
operator|(
name|bytetoktype
operator|*
operator|)
name|bufptr
operator|-
operator|&
operator|(
name|bufferbox
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* 	 *	This is a real kludge: 	 * 	 *	We put the last token in the buffer to be  a MINUS 	 *	symbol.  This last token will never be picked up 	 *	in the normal way, but can be looked at during 	 *	a peekahead look that the short circuit expression 	 *	evaluator uses to see if an expression is complicated. 	 * 	 *	Consider the following situation: 	 * 	 *	.word	45		+	47 	 *        buffer 1      |  buffer 0 	 *	the peekahead would want to look across the buffer, 	 *	but will look in the buffer end zone, see the minus, and 	 *	fail. 	 */
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|MINUS
argument_list|)
expr_stmt|;
name|REGTOMEMBUF
expr_stmt|;
block|}
end_block

end_unit

