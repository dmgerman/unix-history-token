begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright (c) 1982 Regents of the University of California  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)asscan2.c 4.8 %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"asscanl.h"
end_include

begin_decl_stmt
specifier|static
name|inttoktype
name|oval
init|=
name|NL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NINBUFFERS
value|2
end_define

begin_define
define|#
directive|define
name|INBUFLG
value|NINBUFFERS*ASINBUFSIZ + 2
end_define

begin_comment
comment|/* 	 *	We have NINBUFFERS input buffers; the first one is reserved 	 *	for catching the tail of a line split across a buffer 	 *	boundary; the other ones are used for snarfing a buffer 	 *	worth of assembly language source. 	 */
end_comment

begin_decl_stmt
specifier|static
name|char
name|inbuffer
index|[
name|INBUFLG
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|InBufPtr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|FLEXNAMES
end_ifndef

begin_decl_stmt
name|char
name|strtext
index|[
name|NCPString
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
else|FLEXNAMES
end_else

begin_if
if|#
directive|if
name|NCPName
operator|<
name|NCPString
end_if

begin_decl_stmt
name|char
name|strtext
index|[
name|NCPString
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|strtext
value|yytext
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
endif|FLEXNAMES
end_endif

begin_comment
comment|/*  *	fill the inbuffer from the standard input.  *	Assert: there are always n COMPLETE! lines in the buffer area.  *	Assert: there is always a \n terminating the last line  *		in the buffer area.  *	Assert: after the \n, there is an EOFCHAR (hard end of file)  *		or a NEEDCHAR (end of buffer)  *	Assert:	fgets always null pads the string it reads.  *	Assert:	no ungetc's are done at the end of a line or at the  *		beginning of a line.  *	  *	We read a complete buffer of characters in one single read.  *	We then back scan within this buffer to find the end of the  *	last complete line, and force the assertions, and save a pointer  *	to the incomplete line.  *	The next call to fillinbuffer will move the unread characters  *	to the end of the first buffer, and then read another two buffers,  *	completing the cycle.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|p_swapped
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_start
init|=
operator|&
name|inbuffer
index|[
name|NINBUFFERS
operator|*
name|ASINBUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_stop
init|=
operator|&
name|inbuffer
index|[
name|NINBUFFERS
operator|*
name|ASINBUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MIDDLE
value|&inbuffer[ASINBUFSIZ]
end_define

begin_function
name|char
modifier|*
name|fillinbuffer
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|inbufptr
decl_stmt|;
name|int
name|nread
decl_stmt|;
specifier|static
name|int
name|hadeof
decl_stmt|;
name|int
name|goal
decl_stmt|;
name|int
name|got
decl_stmt|;
operator|*
name|p_start
operator|=
name|p_swapped
expr_stmt|;
name|inbufptr
operator|=
name|MIDDLE
operator|-
operator|(
name|p_stop
operator|-
name|p_start
operator|)
expr_stmt|;
name|movestr
argument_list|(
name|inbufptr
argument_list|,
name|p_start
argument_list|,
name|p_stop
operator|-
name|p_start
argument_list|)
expr_stmt|;
comment|/* 	 *	Now, go read up to NINBUFFERS - 1 full buffers 	 */
if|if
condition|(
name|hadeof
condition|)
block|{
name|hadeof
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|goal
operator|=
operator|(
name|NINBUFFERS
operator|-
literal|1
operator|)
operator|*
name|ASINBUFSIZ
expr_stmt|;
name|nread
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|got
operator|=
name|read
argument_list|(
name|stdin
operator|->
name|_file
argument_list|,
name|MIDDLE
operator|+
name|nread
argument_list|,
name|goal
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|==
literal|0
condition|)
name|hadeof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|got
operator|<=
literal|0
condition|)
break|break;
name|nread
operator|+=
name|got
expr_stmt|;
name|goal
operator|-=
name|got
expr_stmt|;
block|}
do|while
condition|(
name|goal
condition|)
do|;
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|from
operator|=
name|MIDDLE
operator|+
name|nread
expr_stmt|;
name|p_stop
operator|=
name|from
expr_stmt|;
operator|*
name|from
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|from
operator|!=
literal|'\n'
condition|)
block|{
comment|/* 		 *	back over the partial line 		 */
if|if
condition|(
name|from
operator|==
name|MIDDLE
condition|)
block|{
name|from
operator|=
name|p_stop
expr_stmt|;
operator|*
name|p_stop
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
block|}
else|else
block|{
continue|continue;
block|}
block|}
name|from
operator|++
expr_stmt|;
comment|/* first char of partial line */
name|p_start
operator|=
name|from
expr_stmt|;
name|p_swapped
operator|=
operator|*
name|p_start
expr_stmt|;
operator|*
name|p_start
operator|=
name|NEEDCHAR
expr_stmt|;
comment|/* force assertion */
return|return
operator|(
name|inbufptr
operator|)
return|;
block|}
end_function

begin_macro
name|scan_dot_s
argument_list|(
argument|bufferbox
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tokbufdesc
modifier|*
name|bufferbox
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|int
name|ryylval
decl_stmt|;
comment|/* local copy of lexical value */
specifier|extern
name|int
name|yylval
decl_stmt|;
comment|/* global copy of lexical value */
name|reg
name|int
name|val
decl_stmt|;
comment|/* the value returned */
name|int
name|i
decl_stmt|;
comment|/* simple counter */
name|reg
name|char
modifier|*
name|rcp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* can have address taken */
name|reg
name|int
name|ch
decl_stmt|;
comment|/* treated as a character */
name|int
name|ch1
decl_stmt|;
comment|/* shadow value */
name|reg
name|char
modifier|*
name|inbufptr
decl_stmt|;
name|struct
name|symtab
modifier|*
name|op
decl_stmt|;
name|reg
name|ptrall
name|bufptr
decl_stmt|;
comment|/* where to stuff tokens */
name|ptrall
name|lgbackpatch
decl_stmt|;
comment|/* where to stuff a string length */
name|ptrall
name|bufub
decl_stmt|;
comment|/* where not to stuff tokens */
name|reg
name|int
name|maxstrlg
decl_stmt|;
comment|/* how long a string can be */
name|long
name|intval
decl_stmt|;
comment|/* value of int */
name|int
name|linescrossed
decl_stmt|;
comment|/* when doing strings and comments */
name|struct
name|Opcode
name|opstruct
decl_stmt|;
operator|(
name|bytetoktype
operator|*
operator|)
name|bufptr
operator|=
operator|(
name|bytetoktype
operator|*
operator|)
operator|&
operator|(
name|bufferbox
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
operator|(
name|bytetoktype
operator|*
operator|)
name|bufub
operator|=
operator|&
operator|(
name|bufferbox
operator|->
name|toks
index|[
name|AVAILTOKS
index|]
operator|)
expr_stmt|;
name|inbufptr
operator|=
name|InBufPtr
expr_stmt|;
if|if
condition|(
name|inbufptr
operator|==
literal|0
condition|)
block|{
name|inbufptr
operator|=
name|fillinbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|inbufptr
operator|==
literal|0
condition|)
block|{
comment|/*end of file*/
name|endoffile
label|:
name|inbufptr
operator|=
literal|0
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|PARSEEOF
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|newfflag
condition|)
block|{
name|newfflag
operator|=
literal|0
expr_stmt|;
name|ryylval
operator|=
operator|(
name|int
operator|)
name|savestr
argument_list|(
name|newfname
argument_list|,
name|strlen
argument_list|(
name|newfname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|IFILE
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|STRING
argument_list|)
expr_stmt|;
name|pptr
argument_list|(
name|bufptr
argument_list|,
name|ryylval
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|ILINENO
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|pint
argument_list|(
name|bufptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|bufptr
operator|<
name|bufub
condition|)
block|{
name|loop
label|:
switch|switch
condition|(
name|ryylval
operator|=
operator|(
name|type
operator|+
literal|2
operator|)
index|[
name|ch
operator|=
name|getchar
argument_list|()
index|]
condition|)
block|{
case|case
name|SCANEOF
case|:
name|inbufptr
operator|=
literal|0
expr_stmt|;
goto|goto
name|endoffile
goto|;
case|case
name|NEEDSBUF
case|:
name|inbufptr
operator|=
name|fillinbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|inbufptr
operator|==
literal|0
condition|)
goto|goto
name|endoffile
goto|;
goto|goto
name|loop
goto|;
case|case
name|DIV
case|:
comment|/*process C style comments*/
if|if
condition|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'*'
condition|)
block|{
comment|/*comment prelude*/
name|int
name|incomment
decl_stmt|;
name|linescrossed
operator|=
literal|0
expr_stmt|;
name|incomment
operator|=
literal|1
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip over the * */
while|while
condition|(
name|incomment
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'*'
case|:
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|incomment
operator|=
operator|(
name|ch
operator|!=
literal|'/'
operator|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|scanlineno
operator|++
expr_stmt|;
name|linescrossed
operator|++
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOFCHAR
case|:
goto|goto
name|endoffile
goto|;
case|case
name|NEEDCHAR
case|:
name|inbufptr
operator|=
name|fillinbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|inbufptr
operator|==
literal|0
condition|)
goto|goto
name|endoffile
goto|;
name|lineno
operator|++
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|val
operator|=
name|ILINESKIP
expr_stmt|;
name|ryylval
operator|=
name|linescrossed
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
comment|/*just an ordinary DIV*/
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|val
operator|=
name|ryylval
operator|=
name|DIV
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
case|case
name|SH
case|:
if|if
condition|(
name|oval
operator|==
name|NL
condition|)
block|{
comment|/* 			 *	Attempt to recognize a C preprocessor 			 *	style comment '^#[ \t]*[0-9]*[ \t]*".*" 			 */
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*bump the #*/
while|while
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|SPACE
argument_list|)
condition|)
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*bump white */
if|if
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
name|intval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
name|intval
operator|=
name|intval
operator|*
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|SPACE
argument_list|)
condition|)
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
block|{
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|ILINENO
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|pint
argument_list|(
name|bufptr
argument_list|,
name|intval
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|IFILE
argument_list|)
expr_stmt|;
comment|/* 					 *	The '"' has already been 					 *	munched 					 *	 					 *	eatstr will not eat 					 *	the trailing \n, so 					 *	it is given to the parser 					 *	and counted. 					 */
goto|goto
name|eatstr
goto|;
block|}
block|}
block|}
comment|/* 		 *	Well, its just an ordinary decadent comment 		 */
while|while
condition|(
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|ch
operator|!=
name|EOFCHAR
operator|)
condition|)
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOFCHAR
condition|)
goto|goto
name|endoffile
goto|;
name|val
operator|=
name|ryylval
operator|=
name|oval
operator|=
name|NL
expr_stmt|;
name|scanlineno
operator|++
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|NL
case|:
name|scanlineno
operator|++
expr_stmt|;
name|val
operator|=
name|ryylval
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|SP
case|:
name|oval
operator|=
name|SP
expr_stmt|;
comment|/*invalidate ^# meta comments*/
goto|goto
name|loop
goto|;
case|case
name|REGOP
case|:
comment|/* % , could be used as modulo, or register*/
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
name|ryylval
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|INCHARSET
argument_list|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|REGDIGIT
argument_list|)
condition|)
name|ryylval
operator|=
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
else|else
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
comment|/* 			 *	God only knows what the original author 			 *	wanted this undocumented feature to 			 *	do. 			 *		%5++ is really  r7 			 */
while|while
condition|(
name|INCHARSET
argument_list|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|SIGN
argument_list|)
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
name|ryylval
operator|++
expr_stmt|;
else|else
name|ryylval
operator|--
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG
expr_stmt|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|val
operator|=
name|REGOP
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
case|case
name|ALPH
case|:
name|ch1
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|SZSPECBEGIN
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'`'
operator|||
name|ch
operator|==
literal|'^'
condition|)
block|{
name|ch1
operator||=
literal|0100
expr_stmt|;
comment|/*convert to lower*/
switch|switch
condition|(
name|ch1
condition|)
block|{
case|case
literal|'b'
case|:
name|ryylval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|ryylval
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|ryylval
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|ryylval
operator|=
name|d124
expr_stmt|;
break|break;
block|}
name|val
operator|=
name|SIZESPEC
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
name|ch1
expr_stmt|;
comment|/*restore first character*/
block|}
block|}
name|rcp
operator|=
name|yytext
expr_stmt|;
do|do
block|{
if|if
condition|(
name|rcp
operator|<
operator|&
name|yytext
index|[
name|NCPName
index|]
condition|)
operator|*
name|rcp
operator|++
operator|=
name|ch
expr_stmt|;
block|}
do|while
condition|(
name|INCHARSET
argument_list|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|ALPHA
operator||
name|DIGIT
argument_list|)
condition|)
do|;
operator|*
name|rcp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|SPACE
argument_list|)
condition|)
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|op
operator|=
operator|*
name|lookup
argument_list|(
literal|1
argument_list|)
operator|)
operator|->
name|s_tag
condition|)
block|{
case|case
literal|0
case|:
case|case
name|LABELID
case|:
comment|/* 			 *	Its a name... (Labels are subsets ofname) 			 */
name|ryylval
operator|=
operator|(
name|int
operator|)
name|op
expr_stmt|;
name|val
operator|=
name|NAME
expr_stmt|;
break|break;
case|case
name|INST0
case|:
case|case
name|INSTn
case|:
case|case
name|IJXXX
case|:
name|opstruct
operator|.
name|Op_popcode
operator|=
operator|(
operator|(
expr|struct
name|instab
operator|*
operator|)
name|op
operator|)
operator|->
name|i_popcode
expr_stmt|;
name|opstruct
operator|.
name|Op_eopcode
operator|=
operator|(
operator|(
expr|struct
name|instab
operator|*
operator|)
name|op
operator|)
operator|->
name|i_eopcode
expr_stmt|;
name|val
operator|=
name|op
operator|->
name|s_tag
expr_stmt|;
break|break;
default|default:
name|ryylval
operator|=
operator|(
operator|(
expr|struct
name|instab
operator|*
operator|)
name|op
operator|)
operator|->
name|i_popcode
expr_stmt|;
name|val
operator|=
name|op
operator|->
name|s_tag
expr_stmt|;
break|break;
block|}
goto|goto
name|ret
goto|;
case|case
name|DIG
case|:
comment|/* 		 *	Implement call by reference on a reg variable 		 */
name|cp
operator|=
name|inbufptr
expr_stmt|;
name|val
operator|=
name|number
argument_list|(
name|ch
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
comment|/* 		 *	yylval or yybignum has been stuffed as a side 		 *	effect to number(); get the global yylval 		 *	into our fast local copy in case it was an INT. 		 */
name|ryylval
operator|=
name|yylval
expr_stmt|;
name|inbufptr
operator|=
name|cp
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|LSH
case|:
case|case
name|RSH
case|:
comment|/* 		 *	We allow the C style operators 		 *<< and>>, as well as< and> 		 */
if|if
condition|(
operator|(
name|ch1
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|ch
condition|)
name|ungetc
argument_list|(
name|ch1
argument_list|)
expr_stmt|;
name|val
operator|=
name|ryylval
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|MINUS
case|:
if|if
condition|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'('
condition|)
name|ryylval
operator|=
name|val
operator|=
name|MP
expr_stmt|;
else|else
block|{
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|val
operator|=
name|MINUS
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
case|case
name|SQ
case|:
if|if
condition|(
operator|(
name|ryylval
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
name|scanlineno
operator|++
expr_stmt|;
comment|/*not entirely correct*/
name|val
operator|=
name|INT
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|DQ
case|:
name|eatstr
label|:
name|linescrossed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rcp
operator|=
name|strtext
operator|,
name|maxstrlg
operator|=
name|NCPString
init|;
name|maxstrlg
operator|>
literal|0
condition|;
operator|--
name|maxstrlg
control|)
block|{
switch|switch
condition|(
name|ch
operator|=
name|getchar
argument_list|()
condition|)
block|{
case|case
literal|'"'
case|:
goto|goto
name|tailDQ
goto|;
default|default:
name|stuff
label|:
name|pchar
argument_list|(
name|rcp
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|yywarning
argument_list|(
literal|"New line in a string constant"
argument_list|)
expr_stmt|;
name|scanlineno
operator|++
expr_stmt|;
name|linescrossed
operator|++
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|NEEDCHAR
case|:
if|if
condition|(
operator|(
name|inbufptr
operator|=
name|fillinbuffer
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|ch
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
comment|/*FALLTHROUGH*/
case|case
name|EOFCHAR
case|:
name|pchar
argument_list|(
name|rcp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|EOFCHAR
argument_list|)
expr_stmt|;
goto|goto
name|tailDQ
goto|;
default|default:
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
break|break;
case|case
literal|'\\'
case|:
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip the '\\'*/
if|if
condition|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|BSESCAPE
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'b'
case|:
name|ch
operator|=
literal|'\b'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'f'
case|:
name|ch
operator|=
literal|'\f'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'n'
case|:
name|ch
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'r'
case|:
name|ch
operator|=
literal|'\r'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'t'
case|:
name|ch
operator|=
literal|'\t'
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|OCTDIGIT
argument_list|)
operator|)
condition|)
goto|goto
name|stuff
goto|;
name|i
operator|=
literal|0
expr_stmt|;
name|intval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
literal|3
operator|)
operator|&&
operator|(
name|INCHARSET
argument_list|(
name|ch
argument_list|,
name|OCTDIGIT
argument_list|)
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|intval
operator|<<=
literal|3
expr_stmt|;
name|intval
operator|+=
name|ch
operator|-
literal|'0'
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
name|char
operator|)
name|intval
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
block|}
name|tailDQ
label|:
empty_stmt|;
comment|/* 		 *	account for any lines that were crossed 		 */
if|if
condition|(
name|linescrossed
condition|)
block|{
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|ILINESKIP
argument_list|)
expr_stmt|;
name|pint
argument_list|(
name|bufptr
argument_list|,
name|linescrossed
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *	put the string in strtext into the string pool 		 * 		 *	The value in ryylval points to the string; 		 *	the previous 2 bytes is the length of the string 		 * 		 *	Cheat: append a trailing null to the string 		 *	and then adjust the string length to ignore 		 *	the trailing null.  If any STRING client requires 		 *	the trailing null, the client can just change STRLEN 		 */
name|val
operator|=
name|STRING
expr_stmt|;
operator|*
name|rcp
operator|++
operator|=
literal|0
expr_stmt|;
name|ryylval
operator|=
operator|(
name|int
operator|)
name|savestr
argument_list|(
name|strtext
argument_list|,
name|rcp
operator|-
name|strtext
argument_list|)
expr_stmt|;
name|STRLEN
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ryylval
operator|)
argument_list|)
operator|-=
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|BADCHAR
case|:
name|linescrossed
operator|=
name|lineno
expr_stmt|;
name|lineno
operator|=
name|scanlineno
expr_stmt|;
name|yyerror
argument_list|(
literal|"Illegal character mapped: %d, char read:(octal) %o"
argument_list|,
name|ryylval
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|linescrossed
expr_stmt|;
name|val
operator|=
name|BADCHAR
expr_stmt|;
goto|goto
name|ret
goto|;
default|default:
name|val
operator|=
name|ryylval
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/*end of the switch*/
comment|/* 	 *	here with one token, so stuff it 	 */
name|ret
label|:
name|oval
operator|=
name|val
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|ILINESKIP
case|:
name|pint
argument_list|(
name|bufptr
argument_list|,
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIZESPEC
case|:
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFINT
case|:
name|plong
argument_list|(
name|bufptr
argument_list|,
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|plong
argument_list|(
name|bufptr
argument_list|,
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIGNUM
case|:
name|pnumber
argument_list|(
name|bufptr
argument_list|,
name|yybignum
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
name|char
operator|*
operator|)
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME
case|:
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|ryylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|INST0
case|:
case|case
name|INSTn
case|:
name|popcode
argument_list|(
name|bufptr
argument_list|,
name|opstruct
argument_list|)
expr_stmt|;
break|break;
case|case
name|IJXXX
case|:
name|popcode
argument_list|(
name|bufptr
argument_list|,
name|opstruct
argument_list|)
expr_stmt|;
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|symalloc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISTAB
case|:
case|case
name|ISTABSTR
case|:
case|case
name|ISTABNONE
case|:
case|case
name|ISTABDOT
case|:
case|case
name|IALIGN
case|:
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|symalloc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *	default: 	 */
block|}
name|builtval
label|:
empty_stmt|;
block|}
comment|/*end of the while to stuff the buffer*/
name|done
label|:
name|bufferbox
operator|->
name|tok_count
operator|=
operator|(
name|bytetoktype
operator|*
operator|)
name|bufptr
operator|-
operator|&
operator|(
name|bufferbox
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* 	 *	This is a real kludge: 	 * 	 *	We put the last token in the buffer to be  a MINUS 	 *	symbol.  This last token will never be picked up 	 *	in the normal way, but can be looked at during 	 *	a peekahead look that the short circuit expression 	 *	evaluator uses to see if an expression is complicated. 	 * 	 *	Consider the following situation: 	 * 	 *	.word	45		+	47 	 *        buffer 1      |  buffer 0 	 *	the peekahead would want to look across the buffer, 	 *	but will look in the buffer end zone, see the minus, and 	 *	fail. 	 */
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|MINUS
argument_list|)
expr_stmt|;
name|InBufPtr
operator|=
name|inbufptr
expr_stmt|;
comment|/*copy this back*/
block|}
end_block

end_unit

