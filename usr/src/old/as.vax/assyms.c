begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright (c) 1982 Regents of the University of California  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)assyms.c 4.7 %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"asscan.h"
end_include

begin_include
include|#
directive|include
file|"assyms.h"
end_include

begin_comment
comment|/*  *	Managers for chunks of symbols allocated from calloc()  *	We maintain a linked list of such chunks.  *  */
end_comment

begin_decl_stmt
name|struct
name|allocbox
modifier|*
name|allochead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*head of chunk list*/
end_comment

begin_decl_stmt
name|struct
name|allocbox
modifier|*
name|alloctail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*tail*/
end_comment

begin_decl_stmt
name|struct
name|allocbox
modifier|*
name|newbox
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*for creating a new chunk*/
end_comment

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|nextsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*next symbol free*/
end_comment

begin_decl_stmt
name|int
name|symsleft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*slots left in current chunk*/
end_comment

begin_decl_stmt
name|struct
name|symtab
modifier|*
modifier|*
name|symptrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
modifier|*
name|symdelim
index|[
name|NLOC
operator|+
name|NLOC
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
modifier|*
name|symptrub
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Managers for the dynamically extendable hash table  */
end_comment

begin_decl_stmt
name|struct
name|hashdallop
modifier|*
name|htab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Iptr
modifier|*
name|itab
index|[
name|NINST
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*maps opcodes to instructions*/
end_comment

begin_comment
comment|/*  *	Counts what went into the symbol table, so that the  *	size of the symbol table can be computed.  */
end_comment

begin_decl_stmt
name|int
name|nsyms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number in the symbol table */
end_comment

begin_decl_stmt
name|int
name|njxxx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of jxxx entrys */
end_comment

begin_decl_stmt
name|int
name|nforgotten
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of symbols erroneously entered */
end_comment

begin_decl_stmt
name|int
name|nlabels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of label entries */
end_comment

begin_comment
comment|/*  *	Managers of the symbol literal storage.  *	If we have flexible names, then we allocate BUFSIZ long  *	string, and pack strings into that.  Otherwise, we allocate  *	symbol storage in fixed hunks NCPS long when we allocate space  *	for other symbol attributes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FLEXNAMES
end_ifdef

begin_decl_stmt
name|struct
name|strpool
modifier|*
name|strplhead
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|FLEXNAMES
end_endif

begin_macro
name|symtabinit
argument_list|()
end_macro

begin_block
block|{
name|allochead
operator|=
literal|0
expr_stmt|;
name|alloctail
operator|=
literal|0
expr_stmt|;
name|nextsym
operator|=
literal|0
expr_stmt|;
name|symsleft
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|strpoolalloc
argument_list|()
expr_stmt|;
comment|/* get the first strpool storage area */
endif|#
directive|endif
endif|FLEXNAMES
name|htab
operator|=
literal|0
expr_stmt|;
name|htaballoc
argument_list|()
expr_stmt|;
comment|/* get the first part of the hash table */
block|}
end_block

begin_comment
comment|/*  *	Install all known instructions in the symbol table  */
end_comment

begin_macro
name|syminstall
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Iptr
name|ip
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NINST
condition|;
name|i
operator|++
control|)
name|itab
index|[
name|i
index|]
operator|=
operator|(
name|Iptr
operator|*
operator|)
name|BADPOINT
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
for|for
control|(
name|ip
operator|=
operator|(
name|Iptr
operator|)
name|instab
init|;
name|ip
operator|->
name|s_name
operator|!=
literal|0
condition|;
name|ip
operator|++
control|)
block|{
else|#
directive|else
else|not FLEXNAMES
for|for
control|(
name|ip
operator|=
operator|(
name|Iptr
operator|)
name|instab
init|;
name|ip
operator|->
name|s_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|;
name|ip
operator|++
control|)
block|{
endif|#
directive|endif
endif|not FLEXNAMES
name|p1
operator|=
name|ip
operator|->
name|s_name
expr_stmt|;
name|p2
operator|=
name|yytext
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
name|hp
operator|=
name|lookup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 0 => don't install this*/
if|if
condition|(
operator|*
name|hp
operator|==
name|NULL
condition|)
block|{
operator|*
name|hp
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|ip
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|s_tag
operator|!=
name|INSTn
operator|)
operator|&&
operator|(
name|ip
operator|->
name|s_tag
operator|!=
name|INST0
operator|)
operator|&&
operator|(
name|ip
operator|->
name|s_tag
operator|!=
literal|0
operator|)
condition|)
continue|continue;
comment|/* was pseudo-op */
if|if
condition|(
name|itab
index|[
name|ip
operator|->
name|i_eopcode
index|]
operator|==
operator|(
name|Iptr
operator|*
operator|)
name|BADPOINT
condition|)
block|{
name|itab
index|[
name|ip
operator|->
name|i_eopcode
index|]
operator|=
operator|(
name|Iptr
operator|*
operator|)
name|ClearCalloc
argument_list|(
literal|256
argument_list|,
sizeof|sizeof
argument_list|(
name|Iptr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|itab
index|[
name|ip
operator|->
name|i_eopcode
index|]
index|[
name|i
index|]
operator|=
operator|(
name|Iptr
operator|)
name|BADPOINT
expr_stmt|;
block|}
name|itab
index|[
name|ip
operator|->
name|i_eopcode
index|]
index|[
name|ip
operator|->
name|i_popcode
index|]
operator|=
name|ip
expr_stmt|;
block|}
block|}
block|}
comment|/*end of syminstall*/
comment|/*  *	Assign final values to symbols,  *	and overwrite the index field with its relative position in  *	the symbol table we give to the loader.  */
specifier|extern
name|struct
name|exec
name|hdr
decl_stmt|;
name|freezesymtab
argument_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
name|long
name|bs
decl_stmt|;
specifier|register
name|int
name|relpos
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|ubsp
decl_stmt|;
specifier|register
name|struct
name|allocbox
modifier|*
name|allocwalk
decl_stmt|;
name|DECLITERATE
argument_list|(
argument|allocwalk
argument_list|,
argument|sp
argument_list|,
argument|ubsp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_tag
operator|>=
name|IGNOREBOUND
condition|)
continue|continue;
comment|/*totally ignore jxxx entries */
comment|/* 		 *	Ignore stabs, but give them a symbol table index 		 */
if|if
condition|(
name|sp
operator|->
name|s_type
operator|&
name|STABFLAG
condition|)
goto|goto
name|assignindex
goto|;
if|if
condition|(
operator|(
name|sp
operator|->
name|s_type
operator|&
name|XTYPE
operator|)
operator|==
name|XUNDEF
condition|)
name|sp
operator|->
name|s_type
operator|=
name|XXTRN
operator|+
name|XUNDEF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|s_type
operator|&
name|XTYPE
operator|)
operator|==
name|XDATA
condition|)
name|sp
operator|->
name|s_value
operator|+=
name|usedot
index|[
name|sp
operator|->
name|s_index
index|]
operator|.
name|e_xvalue
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|s_type
operator|&
name|XTYPE
operator|)
operator|==
name|XTEXT
condition|)
name|sp
operator|->
name|s_value
operator|+=
name|usedot
index|[
name|sp
operator|->
name|s_index
index|]
operator|.
name|e_xvalue
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|s_type
operator|&
name|XTYPE
operator|)
operator|==
name|XBSS
condition|)
block|{
name|bs
operator|=
name|sp
operator|->
name|s_value
expr_stmt|;
name|sp
operator|->
name|s_value
operator|=
name|hdr
operator|.
name|a_bss
operator|+
name|datbase
expr_stmt|;
name|hdr
operator|.
name|a_bss
operator|+=
name|bs
expr_stmt|;
block|}
name|assignindex
label|:
if|if
condition|(
operator|(
name|sp
operator|->
name|s_name
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|)
operator|||
operator|(
name|sp
operator|->
name|s_tag
operator|!=
name|LABELID
operator|)
operator|||
name|savelabels
condition|)
comment|/*then, we will write it later on*/
name|sp
operator|->
name|s_index
operator|=
name|relpos
operator|++
expr_stmt|;
block|}
block|}
comment|/*  *	For all of the stabs that had their final value undefined during pass 1  *	and during pass 2 assign a final value.  *	We have already given stab entrys a initial approximation  *	when we constsructed the sorted symbol table.  *	Iteration order doesn't matter.  */
name|stabfix
argument_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|,
modifier|*
modifier|*
name|cosp
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
name|SYMITERATE
argument_list|(
argument|cosp
argument_list|,
argument|sp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_ptype
operator|&&
operator|(
name|sp
operator|->
name|s_type
operator|&
name|STABFLAG
operator|)
condition|)
block|{
name|p
operator|=
name|sp
operator|->
name|s_dest
expr_stmt|;
name|sp
operator|->
name|s_value
operator|=
name|p
operator|->
name|s_value
expr_stmt|;
name|sp
operator|->
name|s_index
operator|=
name|p
operator|->
name|s_index
expr_stmt|;
name|sp
operator|->
name|s_type
operator|=
name|p
operator|->
name|s_type
expr_stmt|;
block|}
block|}
block|}
name|char
modifier|*
name|Calloc
parameter_list|(
name|number
parameter_list|,
name|size
parameter_list|)
name|int
name|number
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|newstuff
decl_stmt|;
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
name|newstuff
operator|=
name|sbrk
argument_list|(
name|number
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|newstuff
operator|==
operator|-
literal|1
condition|)
block|{
name|yyerror
argument_list|(
literal|"Ran out of Memory"
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|newstuff
operator|)
return|;
block|}
name|char
modifier|*
name|ClearCalloc
parameter_list|(
name|number
parameter_list|,
name|size
parameter_list|)
name|int
name|number
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|newstuff
decl_stmt|;
comment|/* r11 */
specifier|register
name|int
name|length
init|=
name|number
operator|*
name|size
decl_stmt|;
comment|/* r10 */
ifdef|#
directive|ifdef
name|lint
name|length
operator|=
name|length
expr_stmt|;
endif|#
directive|endif
endif|length
name|newstuff
operator|=
name|Calloc
argument_list|(
name|number
argument_list|,
name|size
argument_list|)
expr_stmt|;
asm|asm("movc5 $0, (r0), $0, r10, (r11)");
return|return
operator|(
name|newstuff
operator|)
return|;
block|}
name|struct
name|symtab
modifier|*
name|symalloc
parameter_list|()
block|{
if|if
condition|(
name|symsleft
operator|==
literal|0
condition|)
block|{
name|newbox
operator|=
operator|(
expr|struct
name|allocbox
operator|*
operator|)
name|ClearCalloc
argument_list|(
literal|1
argument_list|,
name|ALLOCQTY
argument_list|)
expr_stmt|;
name|symsleft
operator|=
name|SYMDALLOP
expr_stmt|;
name|nextsym
operator|=
operator|&
name|newbox
operator|->
name|symslots
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|alloctail
operator|==
literal|0
condition|)
block|{
name|allochead
operator|=
name|alloctail
operator|=
name|newbox
expr_stmt|;
block|}
else|else
block|{
name|alloctail
operator|->
name|nextalloc
operator|=
name|newbox
expr_stmt|;
name|alloctail
operator|=
name|newbox
expr_stmt|;
block|}
block|}
operator|--
name|symsleft
expr_stmt|;
operator|++
name|nsyms
expr_stmt|;
return|return
operator|(
name|nextsym
operator|++
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|FLEXNAMES
name|strpoolalloc
argument_list|()
block|{
specifier|register
name|struct
name|strpool
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|strpool
operator|*
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|strpool
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|str_nalloc
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|str_next
operator|=
name|strplhead
expr_stmt|;
name|strplhead
operator|=
name|new
expr_stmt|;
block|}
endif|#
directive|endif
endif|FLEXNAMES
name|symcmp
argument_list|(
argument|Pptr
argument_list|,
argument|Qptr
argument_list|)
name|struct
name|symtab
modifier|*
modifier|*
name|Pptr
decl_stmt|,
modifier|*
modifier|*
name|Qptr
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|p
init|=
operator|*
name|Pptr
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|q
init|=
operator|*
name|Qptr
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|s_index
operator|<
name|q
operator|->
name|s_index
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|s_index
operator|>
name|q
operator|->
name|s_index
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|s_value
operator|<
name|q
operator|->
name|s_value
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|s_value
operator|>
name|q
operator|->
name|s_value
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 *	Force jxxx entries to virtually preceed labels defined 	 *	to follow the jxxxx instruction, so that bumping the 	 *	jxxx instruction correctly fixes up the following labels 	 */
if|if
condition|(
name|p
operator|->
name|s_tag
operator|>=
name|IGNOREBOUND
condition|)
comment|/*p points to a jxxx*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|q
operator|->
name|s_tag
operator|>=
name|IGNOREBOUND
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 *	both are now just plain labels; the relative order doesn't 	 *	matter.  Both can't be jxxxes, as they would have different 	 *	values. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*end of symcmp*/
comment|/*  *	We construct the auxiliary table of pointers, symptrs and  *	symdelim  *	We also assign preliminary values to stab entries that did not yet  *	have an absolute value (because they initially referred to  *	forward references). We don't worry about .stabds, as they  *	already have an estimated final value  */
name|sortsymtab
argument_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|cowalk
decl_stmt|;
specifier|register
name|struct
name|allocbox
modifier|*
name|allocwalk
decl_stmt|;
name|struct
name|symtab
modifier|*
name|ubsp
decl_stmt|;
name|int
name|segno
decl_stmt|;
name|int
name|slotno
decl_stmt|;
name|int
name|symsin
decl_stmt|;
comment|/*number put into symptrs*/
name|symptrs
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|Calloc
argument_list|(
name|nsyms
operator|+
literal|2
argument_list|,
sizeof|sizeof
expr|*
name|symptrs
argument_list|)
expr_stmt|;
comment|/* 	 *	Allocate one word at the beginning of the symptr array 	 *	so that backwards scans through the symptr array will 	 *	work correctly while scanning through the zeroth segment 	 */
operator|*
name|symptrs
operator|++
operator|=
literal|0
expr_stmt|;
name|cowalk
operator|=
name|symptrs
expr_stmt|;
name|symsin
operator|=
literal|0
expr_stmt|;
name|DECLITERATE
argument_list|(
argument|allocwalk
argument_list|,
argument|sp
argument_list|,
argument|ubsp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_ptype
operator|&&
operator|(
name|sp
operator|->
name|s_type
operator|&
name|STABFLAG
operator|)
condition|)
block|{
name|sp
operator|->
name|s_value
operator|=
name|sp
operator|->
name|s_dest
operator|->
name|s_value
expr_stmt|;
name|sp
operator|->
name|s_index
operator|=
name|sp
operator|->
name|s_dest
operator|->
name|s_index
expr_stmt|;
block|}
if|if
condition|(
name|symsin
operator|>=
name|nsyms
condition|)
name|yyerror
argument_list|(
literal|"INTERNAL ERROR: overfilled symbol table indirection table"
argument_list|)
expr_stmt|;
operator|*
name|cowalk
operator|++
operator|=
name|sp
expr_stmt|;
name|symsin
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|symsin
operator|!=
name|nsyms
condition|)
name|yyerror
argument_list|(
literal|"INTERNAL ERROR: installed %d syms, should have installed %d"
argument_list|,
name|symsin
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|symptrub
operator|=
operator|&
name|symptrs
index|[
name|nsyms
index|]
expr_stmt|;
name|qsort
argument_list|(
name|symptrs
argument_list|,
name|nsyms
argument_list|,
sizeof|sizeof
expr|*
name|symptrs
argument_list|,
name|symcmp
argument_list|)
expr_stmt|;
name|symdelim
index|[
literal|0
index|]
operator|=
name|symptrs
expr_stmt|;
for|for
control|(
name|cowalk
operator|=
name|symptrs
operator|,
name|sp
operator|=
operator|*
name|cowalk
operator|,
name|segno
operator|=
literal|0
operator|,
name|slotno
operator|=
literal|1
init|;
name|segno
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|segno
operator|++
operator|,
name|slotno
operator|++
control|)
block|{
for|for
control|(
init|;
name|sp
operator|&&
name|sp
operator|->
name|s_index
operator|==
name|segno
condition|;
name|sp
operator|=
operator|*
operator|++
name|cowalk
control|)
empty_stmt|;
name|symdelim
index|[
name|slotno
index|]
operator|=
name|cowalk
expr_stmt|;
comment|/*forms the ub delimeter*/
block|}
block|}
comment|/*end of sortsymtab*/
ifdef|#
directive|ifdef
name|DEBUG
name|dumpsymtab
argument_list|()
block|{
specifier|register
name|int
name|segno
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|,
modifier|*
modifier|*
name|cosp
decl_stmt|,
modifier|*
name|ub
decl_stmt|;
name|char
modifier|*
name|tagstring
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"Symbol Table dump:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|segno
operator|=
literal|0
init|;
name|segno
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|segno
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"Segment number: %d\n"
argument_list|,
name|segno
argument_list|)
expr_stmt|;
name|SEGITERATE
argument_list|(
argument|segno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|cosp
argument_list|,
argument|sp
argument_list|,
argument|ub
argument_list|,
argument|++
argument_list|)
block|{
ifdef|#
directive|ifdef
name|FLEXNAMES
name|printf
argument_list|(
literal|"\tSeg: %d \"%s\" value: %d index: %d tag %s\n"
argument_list|,
name|segno
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|sp
operator|->
name|s_value
argument_list|,
name|sp
operator|->
name|s_index
argument_list|,
name|tagstring
argument_list|(
name|sp
operator|->
name|s_tag
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
else|not FLEXNAMES
name|printf
argument_list|(
literal|"\tSeg: %d \"%*.*s\" value: %d index: %d tag %s\n"
argument_list|,
name|segno
argument_list|,
name|NCPS
argument_list|,
name|NCPS
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|sp
operator|->
name|s_value
argument_list|,
name|sp
operator|->
name|s_index
argument_list|,
name|tagstring
argument_list|(
name|sp
operator|->
name|s_tag
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|not FLEXNAMES
name|printf
argument_list|(
literal|"\t\ttype: %d jxbump %d jxfear: %d\n"
argument_list|,
name|sp
operator|->
name|s_type
argument_list|,
name|sp
operator|->
name|s_jxbump
argument_list|,
name|sp
operator|->
name|s_jxfear
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|char
name|tagbuff
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|tagstring
parameter_list|(
name|tag
parameter_list|)
name|unsigned
name|char
name|tag
decl_stmt|;
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|JXACTIVE
case|:
return|return
operator|(
literal|"active"
operator|)
return|;
case|case
name|JXNOTYET
case|:
return|return
operator|(
literal|"notyet"
operator|)
return|;
case|case
name|JXALIGN
case|:
return|return
operator|(
literal|"align"
operator|)
return|;
case|case
name|JXQUESTIONABLE
case|:
return|return
operator|(
literal|"jxquestionable"
operator|)
return|;
case|case
name|JXINACTIVE
case|:
return|return
operator|(
literal|"inactive"
operator|)
return|;
case|case
name|JXTUNNEL
case|:
return|return
operator|(
literal|"tunnel"
operator|)
return|;
case|case
name|OBSOLETE
case|:
return|return
operator|(
literal|"obsolete"
operator|)
return|;
case|case
name|IGNOREBOUND
case|:
return|return
operator|(
literal|"ignorebound"
operator|)
return|;
case|case
name|STABFLOATING
case|:
return|return
operator|(
literal|"stabfloating"
operator|)
return|;
case|case
name|STABFIXED
case|:
return|return
operator|(
literal|"stabfixed"
operator|)
return|;
case|case
name|LABELID
case|:
return|return
operator|(
literal|"labelid"
operator|)
return|;
case|case
name|OKTOBUMP
case|:
return|return
operator|(
literal|"oktobump"
operator|)
return|;
case|case
name|ISET
case|:
return|return
operator|(
literal|"iset"
operator|)
return|;
case|case
name|ILSYM
case|:
return|return
operator|(
literal|"ilsym"
operator|)
return|;
default|default:
name|sprintf
argument_list|(
name|tagbuff
argument_list|,
literal|"%d"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|tagbuff
operator|)
return|;
block|}
block|}
endif|#
directive|endif
endif|DEBUG
name|htaballoc
argument_list|()
block|{
specifier|register
name|struct
name|hashdallop
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|hashdallop
operator|*
operator|)
name|ClearCalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hashdallop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|==
literal|0
condition|)
name|htab
operator|=
name|new
expr_stmt|;
else|else
block|{
comment|/* add AFTER the 1st slot */
name|new
operator|->
name|h_next
operator|=
name|htab
operator|->
name|h_next
expr_stmt|;
name|htab
operator|->
name|h_next
operator|=
name|new
expr_stmt|;
block|}
block|}
define|#
directive|define
name|HASHCLOGGED
value|(NHASH / 2)
comment|/*  *	Lookup a symbol stored in extern yytext.  *	All strings passed in via extern yytext had better have  *	a trailing null.  Strings are placed in yytext for hashing by  *	syminstall() and by yylex();  *  *	We take pains to avoid function calls; this functdion  *	is called quite frequently, and the calls overhead  *	in the vax contributes significantly to the overall  *	execution speed of as.  */
name|struct
name|symtab
modifier|*
modifier|*
name|lookup
parameter_list|(
name|instflg
parameter_list|)
name|int
name|instflg
decl_stmt|;
comment|/* 0: don't install */
block|{
specifier|static
name|int
name|initialprobe
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|nprobes
decl_stmt|;
specifier|static
name|struct
name|hashdallop
modifier|*
name|hdallop
decl_stmt|;
specifier|static
name|struct
name|symtab
modifier|*
modifier|*
name|emptyslot
decl_stmt|;
specifier|static
name|struct
name|hashdallop
modifier|*
name|emptyhd
decl_stmt|;
specifier|static
name|struct
name|symtab
modifier|*
modifier|*
name|hp_ub
decl_stmt|;
name|emptyslot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nprobes
operator|=
literal|0
operator|,
name|from
operator|=
name|yytext
init|;
operator|*
name|from
condition|;
name|nprobes
operator|<<=
literal|2
operator|,
name|nprobes
operator|+=
operator|*
name|from
operator|++
control|)
continue|continue;
name|nprobes
operator|+=
name|from
index|[
operator|-
literal|1
index|]
operator|<<
literal|5
expr_stmt|;
name|nprobes
operator|%=
name|NHASH
expr_stmt|;
if|if
condition|(
name|nprobes
operator|<
literal|0
condition|)
name|nprobes
operator|+=
name|NHASH
expr_stmt|;
name|initialprobe
operator|=
name|nprobes
expr_stmt|;
for|for
control|(
name|hdallop
operator|=
name|htab
init|;
name|hdallop
operator|!=
literal|0
condition|;
name|hdallop
operator|=
name|hdallop
operator|->
name|h_next
control|)
block|{
for|for
control|(
name|hp
operator|=
operator|&
operator|(
name|hdallop
operator|->
name|h_htab
index|[
name|initialprobe
index|]
operator|)
operator|,
name|nprobes
operator|=
literal|1
operator|,
name|hp_ub
operator|=
operator|&
operator|(
name|hdallop
operator|->
name|h_htab
index|[
name|NHASH
index|]
operator|)
init|;
operator|(
operator|*
name|hp
operator|)
operator|&&
operator|(
name|nprobes
operator|<
name|NHASH
operator|)
condition|;
name|hp
operator|+=
name|nprobes
operator|,
name|hp
operator|-=
operator|(
name|hp
operator|>=
name|hp_ub
operator|)
condition|?
name|NHASH
else|:
literal|0
operator|,
name|nprobes
operator|+=
literal|2
control|)
block|{
name|from
operator|=
name|yytext
expr_stmt|;
name|to
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|s_name
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
for|for
control|(
name|len
operator|=
literal|0
init|;
operator|(
name|len
operator|<
name|NCPS
operator|)
operator|&&
operator|*
name|from
condition|;
name|len
operator|++
control|)
if|if
condition|(
operator|*
name|from
operator|++
operator|!=
operator|*
name|to
operator|++
condition|)
goto|goto
name|nextprobe
goto|;
if|if
condition|(
name|len
operator|>=
name|NCPS
condition|)
comment|/*both are maximal length*/
return|return
operator|(
name|hp
operator|)
return|;
if|if
condition|(
operator|*
name|to
operator|==
literal|0
condition|)
comment|/*assert *from == 0*/
return|return
operator|(
name|hp
operator|)
return|;
else|#
directive|else
else|FLEXNAMES
while|while
condition|(
operator|*
name|from
operator|&&
operator|*
name|to
condition|)
if|if
condition|(
operator|*
name|from
operator|++
operator|!=
operator|*
name|to
operator|++
condition|)
goto|goto
name|nextprobe
goto|;
if|if
condition|(
operator|*
name|to
operator|==
operator|*
name|from
condition|)
comment|/*assert both are == 0*/
return|return
operator|(
name|hp
operator|)
return|;
endif|#
directive|endif
endif|FLEXNAMES
name|nextprobe
label|:
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|hp
operator|==
literal|0
operator|&&
name|emptyslot
operator|==
literal|0
operator|&&
name|hdallop
operator|->
name|h_nused
operator|<
name|HASHCLOGGED
condition|)
block|{
name|emptyslot
operator|=
name|hp
expr_stmt|;
name|emptyhd
operator|=
name|hdallop
expr_stmt|;
block|}
block|}
if|if
condition|(
name|emptyslot
operator|==
literal|0
condition|)
block|{
name|htaballoc
argument_list|()
expr_stmt|;
name|hdallop
operator|=
name|htab
operator|->
name|h_next
expr_stmt|;
comment|/* aren't we smart! */
name|hp
operator|=
operator|&
name|hdallop
operator|->
name|h_htab
index|[
name|initialprobe
index|]
expr_stmt|;
block|}
else|else
block|{
name|hdallop
operator|=
name|emptyhd
expr_stmt|;
name|hp
operator|=
name|emptyslot
expr_stmt|;
block|}
if|if
condition|(
name|instflg
condition|)
block|{
operator|*
name|hp
operator|=
name|symalloc
argument_list|()
expr_stmt|;
name|hdallop
operator|->
name|h_nused
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|from
operator|=
name|yytext
operator|,
name|to
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|s_name
init|;
operator|(
name|len
operator|<
name|NCPS
operator|)
condition|;
name|len
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
operator|)
operator|==
literal|'\0'
condition|)
break|break;
else|#
directive|else
else|FLEXNAMES
for|for
control|(
name|from
operator|=
name|yytext
operator|,
name|len
operator|=
literal|1
init|;
operator|*
name|from
operator|++
condition|;
name|len
operator|++
control|)
continue|continue;
if|if
condition|(
name|len
operator|>=
operator|(
name|STRPOOLDALLOP
operator|-
name|strplhead
operator|->
name|str_nalloc
operator|)
condition|)
name|strpoolalloc
argument_list|()
expr_stmt|;
for|for
control|(
operator|(
operator|*
name|hp
operator|)
operator|->
name|s_name
operator|=
name|to
operator|=
name|strplhead
operator|->
name|str_names
operator|+
name|strplhead
operator|->
name|str_nalloc
operator|,
name|from
operator|=
name|yytext
init|;
operator|(
operator|(
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
operator|)
operator|!=
literal|'\0'
operator|)
condition|;
control|)
continue|continue;
name|strplhead
operator|->
name|str_nalloc
operator|+=
name|len
expr_stmt|;
endif|#
directive|endif
endif|FLEXNAMES
block|}
return|return
operator|(
name|hp
operator|)
return|;
block|}
comment|/*end of lookup*/
ifdef|#
directive|ifdef
name|FLEXNAMES
name|char
modifier|*
name|savestr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|char
modifier|*
name|res
decl_stmt|;
for|for
control|(
name|from
operator|=
name|str
operator|,
name|len
operator|=
literal|1
init|;
operator|*
name|from
operator|++
condition|;
name|len
operator|++
control|)
continue|continue;
if|if
condition|(
name|len
operator|>=
operator|(
name|STRPOOLDALLOP
operator|-
name|strplhead
operator|->
name|str_nalloc
operator|)
condition|)
name|strpoolalloc
argument_list|()
expr_stmt|;
for|for
control|(
name|res
operator|=
name|to
operator|=
name|strplhead
operator|->
name|str_names
operator|+
name|strplhead
operator|->
name|str_nalloc
operator|,
name|from
operator|=
name|str
init|;
operator|(
operator|(
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
operator|)
operator|!=
literal|'\0'
operator|)
condition|;
control|)
continue|continue;
name|strplhead
operator|->
name|str_nalloc
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
endif|#
directive|endif
endif|FLEXNAMES
comment|/*  *	The relocation information is saved internally in an array of  *	lists of relocation buffers.  The relocation buffers are  *	exactly the same size as a token buffer; if we use VM for the  *	temporary file we reclaim this storage, otherwise we create  *	them by mallocing.  */
define|#
directive|define
name|RELBUFLG
value|TOKBUFLG
define|#
directive|define
name|NRELOC
value|((TOKBUFLG - \ 			  (sizeof (int) + sizeof (struct relbufdesc *)) \ 			) / (sizeof (struct relocation_info)))
struct|struct
name|relbufdesc
block|{
name|int
name|rel_count
decl_stmt|;
name|struct
name|relbufdesc
modifier|*
name|rel_next
decl_stmt|;
name|struct
name|relocation_info
name|rel_reloc
index|[
name|NRELOC
index|]
decl_stmt|;
block|}
struct|;
specifier|extern
name|struct
name|relbufdesc
modifier|*
name|tok_free
decl_stmt|;
define|#
directive|define
name|rel_free
value|tok_free
specifier|static
name|struct
name|relbufdesc
modifier|*
name|rel_temp
decl_stmt|;
name|struct
name|relocation_info
name|r_can_1PC
decl_stmt|;
name|struct
name|relocation_info
name|r_can_0PC
decl_stmt|;
name|initoutrel
argument_list|()
block|{
name|r_can_0PC
operator|.
name|r_address
operator|=
literal|0
expr_stmt|;
name|r_can_0PC
operator|.
name|r_symbolnum
operator|=
literal|0
expr_stmt|;
name|r_can_0PC
operator|.
name|r_pcrel
operator|=
literal|0
expr_stmt|;
name|r_can_0PC
operator|.
name|r_length
operator|=
literal|0
expr_stmt|;
name|r_can_0PC
operator|.
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_can_1PC
operator|=
name|r_can_0PC
expr_stmt|;
name|r_can_1PC
operator|.
name|r_pcrel
operator|=
literal|1
expr_stmt|;
block|}
name|outrel
argument_list|(
name|xp
argument_list|,
name|reloc_how
argument_list|)
specifier|register
expr|struct
name|exp
operator|*
name|xp
expr_stmt|;
name|int
name|reloc_how
decl_stmt|;
comment|/* TYPB..TYPH + (possibly)RELOC_PCREL */
block|{
name|struct
name|relocation_info
name|reloc
decl_stmt|;
specifier|register
name|int
name|x_type_mask
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|x_type_mask
operator|=
name|xp
operator|->
name|e_xtype
operator|&
operator|~
name|XFORW
expr_stmt|;
name|pcrel
operator|=
name|reloc_how
operator|&
name|RELOC_PCREL
expr_stmt|;
name|reloc_how
operator|&=
operator|~
name|RELOC_PCREL
expr_stmt|;
if|if
condition|(
name|bitoff
operator|&
literal|07
condition|)
name|yyerror
argument_list|(
literal|"Padding error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_type_mask
operator|==
name|XUNDEF
condition|)
name|yyerror
argument_list|(
literal|"Undefined reference"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x_type_mask
operator|!=
name|XABS
operator|)
operator|||
name|pcrel
condition|)
block|{
if|if
condition|(
name|ty_NORELOC
index|[
name|reloc_how
index|]
condition|)
name|yyerror
argument_list|(
literal|"Illegal Relocation of floating or large int number."
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|pcrel
condition|?
name|r_can_1PC
else|:
name|r_can_0PC
expr_stmt|;
name|reloc
operator|.
name|r_address
operator|=
name|dotp
operator|->
name|e_xvalue
operator|-
operator|(
operator|(
name|dotp
operator|<
operator|&
name|usedot
index|[
name|NLOC
index|]
operator|||
name|readonlydata
operator|)
condition|?
literal|0
else|:
name|datbase
operator|)
expr_stmt|;
name|reloc
operator|.
name|r_length
operator|=
name|ty_nlg
index|[
name|reloc_how
index|]
expr_stmt|;
switch|switch
condition|(
name|x_type_mask
condition|)
block|{
case|case
name|XXTRN
operator||
name|XUNDEF
case|:
name|reloc
operator|.
name|r_symbolnum
operator|=
name|xp
operator|->
name|e_xname
operator|->
name|s_index
expr_stmt|;
name|reloc
operator|.
name|r_extern
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|readonlydata
operator|&&
operator|(
name|x_type_mask
operator|&
operator|~
name|XXTRN
operator|)
operator|==
name|XDATA
condition|)
name|x_type_mask
operator|=
name|XTEXT
operator||
operator|(
name|x_type_mask
operator|&
name|XXTRN
operator|)
expr_stmt|;
name|reloc
operator|.
name|r_symbolnum
operator|=
name|x_type_mask
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|relfil
operator|==
literal|0
operator|)
operator|||
operator|(
name|relfil
operator|->
name|rel_count
operator|>=
name|NRELOC
operator|)
condition|)
block|{
if|if
condition|(
name|rel_free
condition|)
block|{
name|rel_temp
operator|=
name|rel_free
expr_stmt|;
name|rel_free
operator|=
name|rel_temp
operator|->
name|rel_next
expr_stmt|;
block|}
else|else
block|{
name|rel_temp
operator|=
operator|(
expr|struct
name|relbufdesc
operator|*
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|relbufdesc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rel_temp
operator|->
name|rel_count
operator|=
literal|0
expr_stmt|;
name|rel_temp
operator|->
name|rel_next
operator|=
name|relfil
expr_stmt|;
name|relfil
operator|=
name|rusefile
index|[
name|dotp
operator|-
operator|&
name|usedot
index|[
literal|0
index|]
index|]
operator|=
name|rel_temp
expr_stmt|;
block|}
name|relfil
operator|->
name|rel_reloc
index|[
name|relfil
operator|->
name|rel_count
operator|++
index|]
operator|=
name|reloc
expr_stmt|;
block|}
comment|/* 	 *	write the unrelocated value to the text file 	 */
name|dotp
operator|->
name|e_xvalue
operator|+=
name|ty_nbyte
index|[
name|reloc_how
index|]
expr_stmt|;
if|if
condition|(
name|pcrel
condition|)
name|xp
operator|->
name|e_xvalue
operator|-=
name|dotp
operator|->
name|e_xvalue
expr_stmt|;
switch|switch
condition|(
name|reloc_how
condition|)
block|{
case|case
name|TYPO
case|:
case|case
name|TYPQ
case|:
case|case
name|TYPF
case|:
case|case
name|TYPD
case|:
case|case
name|TYPG
case|:
case|case
name|TYPH
case|:
name|bignumwrite
argument_list|(
name|xp
operator|->
name|e_number
argument_list|,
name|reloc_how
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|xp
operator|->
name|e_xvalue
operator|)
argument_list|,
name|ty_nbyte
index|[
name|reloc_how
index|]
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*  *	Flush out all of the relocation information.  *	Note that the individual lists of buffers are in  *	reverse order, so we must reverse them  */
name|off_t
name|closeoutrel
parameter_list|(
name|relocfile
parameter_list|)
name|BFILE
modifier|*
name|relocfile
decl_stmt|;
block|{
name|int
name|locindex
decl_stmt|;
name|u_long
name|Closeoutrel
parameter_list|()
function_decl|;
name|trsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
name|trsize
operator|+=
name|Closeoutrel
argument_list|(
name|rusefile
index|[
name|locindex
index|]
argument_list|,
name|relocfile
argument_list|)
expr_stmt|;
block|}
name|drsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
name|drsize
operator|+=
name|Closeoutrel
argument_list|(
name|rusefile
index|[
name|NLOC
operator|+
name|locindex
index|]
argument_list|,
name|relocfile
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|trsize
operator|+
name|drsize
operator|)
return|;
block|}
name|u_long
name|Closeoutrel
parameter_list|(
name|relfil
parameter_list|,
name|relocfile
parameter_list|)
name|struct
name|relbufdesc
modifier|*
name|relfil
decl_stmt|;
name|BFILE
modifier|*
name|relocfile
decl_stmt|;
block|{
name|u_long
name|tail
decl_stmt|;
if|if
condition|(
name|relfil
operator|==
literal|0
condition|)
return|return
operator|(
literal|0L
operator|)
return|;
name|tail
operator|=
name|Closeoutrel
argument_list|(
name|relfil
operator|->
name|rel_next
argument_list|,
name|relocfile
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|relfil
operator|->
name|rel_reloc
index|[
literal|0
index|]
argument_list|,
name|relfil
operator|->
name|rel_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
argument_list|,
name|relocfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|tail
operator|+
name|relfil
operator|->
name|rel_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
operator|)
return|;
block|}
define|#
directive|define
name|NOUTSYMS
value|(nsyms - njxxx - nforgotten - (savelabels ? 0 : nlabels))
name|int
name|sizesymtab
parameter_list|()
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|*
name|NOUTSYMS
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|FLEXNAMES
comment|/*  *	We write out the flexible length character strings for  names  *	in two stages.  *	1)	We have always! maintain a fixed sized name list entry;  *	the string is indexed by a four byte quantity from the beginning  *	of the string pool area.  Index 0 is reserved, and indicates  *	that there is no associated string. The first valid index is 4.  *	2)	 We concatenate together and write all of the strings  *	in the string pool at the end of the name list. The first   *	four bytes in the string pool are indexed only by 0 (see above);  *	they contain the total number of bytes in the string pool.  */
endif|#
directive|endif
endif|FLEXNAMES
comment|/*  *	Write out n symbols to file f, beginning at p  *	ignoring symbols that are obsolete, jxxx instructions, and  *	possibly, labels  */
name|int
name|symwrite
parameter_list|(
name|symfile
parameter_list|)
name|BFILE
modifier|*
name|symfile
decl_stmt|;
block|{
name|int
name|symsout
decl_stmt|;
comment|/*those actually written*/
name|int
name|symsdesired
init|=
name|NOUTSYMS
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ub
decl_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|char
modifier|*
name|name
decl_stmt|;
comment|/* temp to save the name */
name|long
name|stroff
init|=
sizeof|sizeof
argument_list|(
name|stroff
argument_list|)
decl_stmt|;
comment|/* 	 *	We use sp->s_index to hold the length of the 	 *	name; it isn't used for anything else 	 */
endif|#
directive|endif
endif|FLEXNAMES
specifier|register
name|struct
name|allocbox
modifier|*
name|allocwalk
decl_stmt|;
name|symsout
operator|=
literal|0
expr_stmt|;
name|DECLITERATE
argument_list|(
argument|allocwalk
argument_list|,
argument|sp
argument_list|,
argument|ub
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_tag
operator|>=
name|IGNOREBOUND
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|->
name|s_name
index|[
literal|0
index|]
operator|==
literal|'L'
operator|)
operator|&&
operator|(
name|sp
operator|->
name|s_tag
operator|==
name|LABELID
operator|)
operator|&&
operator|!
name|savelabels
condition|)
continue|continue;
name|symsout
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|name
operator|=
name|sp
operator|->
name|s_name
expr_stmt|;
comment|/* save pointer */
if|if
condition|(
operator|(
name|sp
operator|->
name|s_index
operator|=
name|strlen
argument_list|(
name|sp
operator|->
name|s_name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sp
operator|->
name|s_nmx
operator|=
name|stroff
expr_stmt|;
comment|/* clobber pointer */
name|stroff
operator|+=
name|sp
operator|->
name|s_index
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|s_nmx
operator|=
literal|0
expr_stmt|;
comment|/* clobber pointer */
block|}
endif|#
directive|endif
name|sp
operator|->
name|s_type
operator|=
operator|(
name|sp
operator|->
name|s_ptype
operator|!=
literal|0
operator|)
condition|?
name|sp
operator|->
name|s_ptype
else|:
operator|(
name|sp
operator|->
name|s_type
operator|&
operator|(
operator|~
name|XFORW
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|readonlydata
operator|&&
operator|(
name|sp
operator|->
name|s_type
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_DATA
condition|)
name|sp
operator|->
name|s_type
operator|=
name|N_TEXT
operator||
operator|(
name|sp
operator|->
name|s_type
operator|&
name|N_EXT
operator|)
expr_stmt|;
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sp
operator|->
name|s_nm
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|sp
operator|->
name|s_name
operator|=
name|name
expr_stmt|;
comment|/* restore pointer */
endif|#
directive|endif
endif|FLEXNAMES
block|}
if|if
condition|(
name|symsout
operator|!=
name|symsdesired
condition|)
name|yyerror
argument_list|(
literal|"INTERNAL ERROR: Wrote %d symbols, wanted to write %d symbols\n"
argument_list|,
name|symsout
argument_list|,
name|symsdesired
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
comment|/* 	 *	Pass 2 through the string pool 	 */
name|symsout
operator|=
literal|0
expr_stmt|;
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|stroff
argument_list|,
sizeof|sizeof
argument_list|(
name|stroff
argument_list|)
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
name|stroff
operator|=
sizeof|sizeof
argument_list|(
name|stroff
argument_list|)
expr_stmt|;
name|symsout
operator|=
literal|0
expr_stmt|;
name|DECLITERATE
argument_list|(
argument|allocwalk
argument_list|,
argument|sp
argument_list|,
argument|ub
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_tag
operator|>=
name|IGNOREBOUND
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|->
name|s_name
index|[
literal|0
index|]
operator|==
literal|'L'
operator|)
operator|&&
operator|(
name|sp
operator|->
name|s_tag
operator|==
name|LABELID
operator|)
operator|&&
operator|!
name|savelabels
condition|)
continue|continue;
name|sp
operator|->
name|s_index
operator|=
name|strlen
argument_list|(
name|sp
operator|->
name|s_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_index
condition|)
name|bwrite
argument_list|(
name|sp
operator|->
name|s_name
argument_list|,
name|sp
operator|->
name|s_index
operator|+
literal|1
argument_list|,
name|symfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|FLEXNAMES
block|}
end_block

end_unit

