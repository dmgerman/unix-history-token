begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)bignum1.c	5.1 (Berkeley) 4/30/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_comment
comment|/*  *	Construct a floating point number  */
end_comment

begin_function
name|Bignum
name|as_atof
parameter_list|(
name|numbuf
parameter_list|,
name|radix
parameter_list|,
name|ovfp
parameter_list|)
name|char
modifier|*
name|numbuf
decl_stmt|;
name|int
name|radix
decl_stmt|;
name|Ovf
modifier|*
name|ovfp
decl_stmt|;
block|{
name|Bignum
name|number
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|double
name|atof
parameter_list|()
function_decl|;
name|number
operator|=
name|Znumber
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|radix
condition|)
block|{
case|case
name|TYPF
case|:
case|case
name|TYPD
case|:
name|number
operator|.
name|num_tag
operator|=
name|TYPD
expr_stmt|;
operator|*
name|ovfp
operator|=
literal|0
expr_stmt|;
name|number
operator|.
name|num_num
operator|.
name|numFd_float
operator|.
name|Fd_value
operator|=
name|atof
argument_list|(
name|numbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPG
case|:
case|case
name|TYPH
case|:
name|number
operator|=
name|bigatof
argument_list|(
name|numbuf
argument_list|,
name|radix
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|errno
operator|==
name|ERANGE
operator|&&
name|passno
operator|==
literal|2
condition|)
block|{
name|yywarning
argument_list|(
literal|"Floating conversion over/underflowed\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|number
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Construct an integer.  */
end_comment

begin_function
name|Bignum
name|as_atoi
parameter_list|(
name|ccp
parameter_list|,
name|radix
parameter_list|,
name|ovfp
parameter_list|)
name|reg
name|char
modifier|*
name|ccp
decl_stmt|;
comment|/* character cp */
name|int
name|radix
decl_stmt|;
name|Ovf
modifier|*
name|ovfp
decl_stmt|;
block|{
name|reg
name|chptr
name|bcp
decl_stmt|;
name|chptr
name|tcp
decl_stmt|;
name|reg
name|int
name|i
decl_stmt|;
name|int
name|val
decl_stmt|;
name|Bignum
name|n_n
decl_stmt|;
name|Bignum
name|t_n
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|Ovf
name|ovf
decl_stmt|;
name|ovf
operator|=
literal|0
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|ccp
condition|;
name|ccp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|ccp
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'+'
case|:
continue|continue;
case|case
literal|'-'
case|:
name|sign
operator|^=
literal|1
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|n_n
operator|=
name|Znumber
expr_stmt|;
name|t_n
operator|=
name|Znumber
expr_stmt|;
name|bcp
operator|=
name|CH_FIELD
argument_list|(
name|n_n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|numclear
argument_list|(
name|bcp
argument_list|)
expr_stmt|;
name|tcp
operator|=
name|CH_FIELD
argument_list|(
name|t_n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|numclear
argument_list|(
name|tcp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|ccp
condition|;
name|ccp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|ccp
condition|)
block|{
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|radix
operator|<
literal|10
condition|)
goto|goto
name|done
goto|;
comment|/*FALLTHROUGH*/
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|val
operator|=
operator|*
name|ccp
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|radix
operator|<
literal|16
condition|)
goto|goto
name|done
goto|;
name|val
operator|=
operator|*
name|ccp
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
if|if
condition|(
name|radix
operator|<
literal|16
condition|)
goto|goto
name|done
goto|;
name|val
operator|=
operator|*
name|ccp
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|radix
condition|)
block|{
case|case
literal|8
case|:
name|ovf
operator||=
name|numshift
argument_list|(
literal|3
argument_list|,
name|bcp
argument_list|,
name|bcp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|ovf
operator||=
name|numshift
argument_list|(
literal|4
argument_list|,
name|bcp
argument_list|,
name|bcp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|ovf
operator||=
name|numshift
argument_list|(
literal|1
argument_list|,
name|tcp
argument_list|,
name|bcp
argument_list|)
expr_stmt|;
name|ovf
operator||=
name|numshift
argument_list|(
literal|3
argument_list|,
name|bcp
argument_list|,
name|bcp
argument_list|)
expr_stmt|;
name|ovf
operator||=
name|numaddv
argument_list|(
name|bcp
argument_list|,
name|tcp
argument_list|,
name|bcp
argument_list|)
expr_stmt|;
break|break;
block|}
name|ovf
operator||=
name|numaddd
argument_list|(
name|bcp
argument_list|,
name|bcp
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|done
label|:
empty_stmt|;
name|ovf
operator||=
name|posovf
argument_list|(
name|bcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
condition|)
block|{
if|if
condition|(
name|ovf
operator|&
name|OVF_MAXINT
condition|)
block|{
name|ovf
operator|&=
operator|~
operator|(
name|OVF_MAXINT
operator||
name|OVF_POSOVF
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ovf
operator||=
name|numnegate
argument_list|(
name|bcp
argument_list|,
name|bcp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 *	find the highest set unit of the number 	 */
name|val
operator|=
name|sign
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CH_N
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bcp
index|[
name|i
index|]
operator|==
name|val
condition|)
break|break;
block|}
block|{
specifier|static
name|u_char
name|tagtab
index|[
literal|4
index|]
index|[
literal|16
index|]
init|=
block|{
block|{
name|TYPB
block|,
name|TYPW
block|,
name|TYPL
block|,
name|TYPL
block|,
name|TYPQ
block|,
name|TYPQ
block|,
name|TYPQ
block|,
name|TYPQ
block|,
name|TYPO
block|,
name|TYPO
block|,
name|TYPO
block|,
name|TYPO
block|,
name|TYPO
block|,
name|TYPO
block|,
name|TYPO
block|,
name|TYPO
block|}
block|,
block|{
name|TYPW
block|,
name|TYPL
block|,
name|TYPQ
block|,
name|TYPQ
block|,
name|TYPO
block|,
name|TYPO
block|,
name|TYPO
block|,
name|TYPO
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
name|TYPL
block|,
name|TYPQ
block|,
name|TYPO
block|,
name|TYPO
block|}
block|}
decl_stmt|;
comment|/* 		 *	i indexes to the null chunk; make it point to the 		 *	last non null chunk 		 */
name|i
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|n_n
operator|.
name|num_tag
operator|=
name|tagtab
index|[
name|HOC
index|]
index|[
name|i
index|]
expr_stmt|;
name|assert
argument_list|(
name|n_n
operator|.
name|num_tag
operator|!=
literal|0
argument_list|,
literal|"Botch width computation"
argument_list|)
expr_stmt|;
block|}
operator|*
name|ovfp
operator|=
name|ovf
expr_stmt|;
return|return
operator|(
name|n_n
operator|)
return|;
block|}
end_function

begin_function
name|Ovf
name|posovf
parameter_list|(
name|src
parameter_list|)
name|reg
name|chptr
name|src
decl_stmt|;
block|{
name|reg
name|int
name|i
decl_stmt|;
name|Ovf
name|overflow
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|src
index|[
name|HOC
index|]
operator|&
name|SIGNBIT
condition|)
name|overflow
operator|=
name|OVF_POSOVF
expr_stmt|;
if|if
condition|(
name|src
index|[
name|HOC
index|]
operator|==
name|SIGNBIT
condition|)
block|{
for|for
control|(
name|i
operator|=
name|HOC
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|src
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
name|overflow
operator|)
return|;
block|}
name|overflow
operator||=
name|OVF_MAXINT
expr_stmt|;
block|}
return|return
operator|(
name|overflow
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	check if the number is clear  */
end_comment

begin_function
name|int
name|isclear
parameter_list|(
name|dst
parameter_list|)
name|reg
name|chptr
name|dst
decl_stmt|;
block|{
return|return
operator|(
operator|!
name|isunequal
argument_list|(
name|dst
argument_list|,
name|CH_FIELD
argument_list|(
name|Znumber
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|isunequal
parameter_list|(
name|src1
parameter_list|,
name|src2
parameter_list|)
name|reg
name|chptr
name|src1
decl_stmt|,
name|src2
decl_stmt|;
block|{
name|reg
name|int
name|i
decl_stmt|;
name|i
operator|=
name|CH_N
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|src1
operator|++
operator|!=
operator|*
name|src2
operator|++
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|Ovf
name|numclear
parameter_list|(
name|dst
parameter_list|)
name|reg
name|chptr
name|dst
decl_stmt|;
block|{
name|reg
name|int
name|i
decl_stmt|;
name|i
operator|=
name|CH_N
expr_stmt|;
do|do
block|{
operator|*
name|dst
operator|++
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|Ovf
name|numshift
parameter_list|(
name|n
parameter_list|,
name|dst
parameter_list|,
name|src
parameter_list|)
name|int
name|n
decl_stmt|;
name|reg
name|chptr
name|dst
decl_stmt|,
name|src
decl_stmt|;
block|{
name|reg
name|int
name|i
decl_stmt|;
name|reg
name|u_int
name|carryi
decl_stmt|,
name|carryo
decl_stmt|;
name|reg
name|u_int
name|mask
decl_stmt|;
name|reg
name|u_int
name|value
decl_stmt|;
name|i
operator|=
name|CH_N
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
do|do
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|carryi
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
name|ONES
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
do|do
block|{
name|value
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|carryo
operator|=
operator|(
name|value
operator|>>
operator|(
name|CH_BITS
operator|-
name|n
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
name|value
operator|<<=
name|n
expr_stmt|;
name|value
operator|&=
operator|~
name|mask
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|value
operator||
name|carryi
expr_stmt|;
name|carryi
operator|=
name|carryo
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
return|return
operator|(
name|carryi
condition|?
name|OVF_LSHIFT
else|:
literal|0
operator|)
return|;
block|}
else|else
block|{
name|n
operator|=
operator|-
name|n
expr_stmt|;
name|src
operator|+=
name|CH_N
expr_stmt|;
name|dst
operator|+=
name|CH_N
expr_stmt|;
do|do
block|{
name|value
operator|=
operator|*
operator|--
name|src
expr_stmt|;
name|carryo
operator|=
name|value
operator|&
name|mask
expr_stmt|;
name|value
operator|>>=
name|n
expr_stmt|;
name|value
operator|&=
name|ONES
argument_list|(
name|CH_BITS
operator|-
name|n
argument_list|)
expr_stmt|;
operator|*
operator|--
name|dst
operator|=
name|value
operator||
name|carryi
expr_stmt|;
name|carryi
operator|=
name|carryo
operator|<<
operator|(
name|CH_BITS
operator|-
name|n
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
return|return
operator|(
name|carryi
condition|?
name|OVF_LSHIFT
else|:
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|Ovf
name|numaddd
parameter_list|(
name|dst
parameter_list|,
name|src1
parameter_list|,
name|val
parameter_list|)
name|chptr
name|dst
decl_stmt|,
name|src1
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
specifier|static
name|Bignum
name|work
decl_stmt|;
name|work
operator|.
name|num_uchar
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
return|return
operator|(
name|numaddv
argument_list|(
name|dst
argument_list|,
name|src1
argument_list|,
name|CH_FIELD
argument_list|(
name|work
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Ovf
name|numaddv
parameter_list|(
name|dst
parameter_list|,
name|src1
parameter_list|,
name|src2
parameter_list|)
name|reg
name|chptr
name|dst
decl_stmt|,
name|src1
decl_stmt|,
name|src2
decl_stmt|;
block|{
name|reg
name|int
name|i
decl_stmt|;
name|reg
name|int
name|carry
decl_stmt|;
name|reg
name|u_int
name|A
decl_stmt|,
name|B
decl_stmt|,
name|value
decl_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|CH_N
expr_stmt|;
do|do
block|{
name|A
operator|=
operator|*
name|src1
operator|++
expr_stmt|;
name|B
operator|=
operator|*
name|src2
operator|++
expr_stmt|;
name|value
operator|=
name|A
operator|+
name|B
operator|+
name|carry
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|value
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|<
name|A
operator|||
name|value
operator|<
name|B
condition|)
name|carry
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
return|return
operator|(
name|carry
condition|?
name|OVF_ADDV
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|Ovf
name|numnegate
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|chptr
name|dst
decl_stmt|,
name|src
decl_stmt|;
block|{
name|Ovf
name|ovf
decl_stmt|;
name|ovf
operator|=
name|num1comp
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|ovf
operator||=
name|numaddd
argument_list|(
name|dst
argument_list|,
name|dst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ovf
operator|)
return|;
block|}
end_function

begin_function
name|Ovf
name|num1comp
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|reg
name|chptr
name|dst
decl_stmt|,
name|src
decl_stmt|;
block|{
name|reg
name|int
name|i
decl_stmt|;
name|i
operator|=
name|CH_N
expr_stmt|;
do|do
block|{
operator|*
name|dst
operator|++
operator|=
operator|~
operator|*
name|src
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Determine if floating point numbers are  *	capable of being represented as a one byte immediate literal constant  *	If it is, then stuff the value into *valuep.  *	argtype is how the instruction will interpret the number.  */
end_comment

begin_function
name|int
name|slitflt
parameter_list|(
name|number
parameter_list|,
name|argtype
parameter_list|,
name|valuep
parameter_list|)
name|Bignum
name|number
decl_stmt|;
comment|/* number presented */
name|int
name|argtype
decl_stmt|;
comment|/* what the instruction expects */
name|int
modifier|*
name|valuep
decl_stmt|;
block|{
define|#
directive|define
name|EXPPREC
value|3
define|#
directive|define
name|MANTPREC
value|3
name|int
name|mask
decl_stmt|;
name|reg
name|int
name|i
decl_stmt|;
name|Bignum
name|unpacked
decl_stmt|;
name|Ovf
name|ovf
decl_stmt|;
operator|*
name|valuep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ty_float
index|[
name|argtype
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|unpacked
operator|=
name|bignumunpack
argument_list|(
name|number
argument_list|,
operator|&
name|ovf
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ovf
operator|==
literal|0
argument_list|,
literal|"overflow in unpacking floating #!?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpacked
operator|.
name|num_sign
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|unpacked
operator|.
name|num_exponent
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|unpacked
operator|.
name|num_exponent
operator|>
name|ONES
argument_list|(
name|EXPPREC
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CH_FIELD
argument_list|(
name|unpacked
argument_list|)
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|CH_FIELD
argument_list|(
name|unpacked
argument_list|)
index|[
name|HOC
index|]
operator|)
operator|&
name|ONES
argument_list|(
name|CH_BITS
operator|-
name|MANTPREC
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|valuep
operator|=
operator|(
name|unpacked
operator|.
name|num_exponent
operator|&
name|ONES
argument_list|(
name|EXPPREC
argument_list|)
operator|)
operator|<<
name|MANTPREC
expr_stmt|;
name|mask
operator|=
operator|(
name|CH_FIELD
argument_list|(
name|unpacked
argument_list|)
index|[
name|HOC
index|]
operator|)
operator|>>
operator|(
name|CH_BITS
operator|-
name|MANTPREC
operator|)
expr_stmt|;
name|mask
operator|&=
name|ONES
argument_list|(
name|MANTPREC
argument_list|)
expr_stmt|;
operator|*
name|valuep
operator||=
name|mask
expr_stmt|;
operator|*
name|valuep
operator|&=
name|ONES
argument_list|(
name|MANTPREC
operator|+
name|EXPPREC
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|STANDALONE
end_ifndef

begin_comment
comment|/*  *	Output a big number to txtfil  *	Called only when passno == 2  *  *	The conversion specifies the width of the number to be written out.  *	The width is supplied from either an initialized data directive  *	(for example .float, .double), or from the operand size  *	defined by an operator.  *	If the number is of type quad or octal,  *	we just write it out; this allows one to specify bit  *	patterns for floating point numbers.  *	If the number is one of the floating types and the conversion  *	is not the same type, then we complain, but do the conversion anyway.  *	The conversion is strict.  */
end_comment

begin_macro
name|bignumwrite
argument_list|(
argument|number
argument_list|,
argument|toconv
argument_list|)
end_macro

begin_decl_stmt
name|Bignum
name|number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|toconv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one of TYP[QO FDGH] */
end_comment

begin_block
block|{
name|reg
name|u_int
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|passno
operator|!=
literal|2
condition|)
return|return;
name|bp
operator|=
operator|&
name|number
operator|.
name|num_uint
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|number
operator|.
name|num_tag
condition|)
block|{
case|case
name|TYPB
case|:
case|case
name|TYPW
case|:
case|case
name|TYPL
case|:
case|case
name|TYPQ
case|:
case|case
name|TYPO
case|:
name|number
operator|=
name|intconvert
argument_list|(
name|number
argument_list|,
name|toconv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|number
operator|=
name|floatconvert
argument_list|(
name|number
argument_list|,
name|toconv
argument_list|)
expr_stmt|;
break|break;
block|}
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|,
name|ty_nbyte
index|[
name|toconv
index|]
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|STANDALONE
end_endif

end_unit

