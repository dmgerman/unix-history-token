begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright (c) 1982 Regents of the University of California  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)natof.c 4.1 %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_function
name|Bignum
name|bigatof
parameter_list|(
name|str
parameter_list|,
name|radix
parameter_list|)
name|reg
name|char
modifier|*
name|str
decl_stmt|;
comment|/* r11 */
name|int
name|radix
decl_stmt|;
comment|/* TYPF ... TYPH */
block|{
name|int
name|msign
decl_stmt|;
name|int
name|esign
decl_stmt|;
name|int
name|decpt
decl_stmt|;
name|reg
name|chptr
name|temp
decl_stmt|;
comment|/* r10 */
name|reg
name|u_int
name|quotient
decl_stmt|;
comment|/* r9 */
comment|/* must be here */
name|reg
name|u_int
name|remainder
decl_stmt|;
comment|/* r8 */
comment|/* must be here */
name|reg
name|chptr
name|acc
decl_stmt|;
name|reg
name|int
name|dividend
decl_stmt|;
comment|/* for doing division */
name|reg
name|u_int
name|i
decl_stmt|;
name|short
modifier|*
name|sptr
decl_stmt|;
comment|/* for doing division */
name|int
name|ch
decl_stmt|;
name|int
name|dexponent
decl_stmt|;
comment|/* decimal exponent */
name|int
name|bexponent
decl_stmt|;
comment|/* binary exponent */
name|Bignum
name|Acc
decl_stmt|;
name|Bignum
name|Temp
decl_stmt|;
specifier|static
name|Bignum
name|znumber
decl_stmt|;
name|Ovf
name|ovf
decl_stmt|;
name|u_int
name|j
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|u_int
name|ediv
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|lint
name|quotient
operator|=
literal|0
expr_stmt|;
name|remainder
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|lint
name|msign
operator|=
literal|0
expr_stmt|;
name|esign
operator|=
literal|0
expr_stmt|;
name|decpt
operator|=
literal|0
expr_stmt|;
name|dexponent
operator|=
literal|0
expr_stmt|;
name|Acc
operator|=
name|znumber
expr_stmt|;
name|Acc
operator|.
name|num_tag
operator|=
name|radix
expr_stmt|;
name|acc
operator|=
name|CH_FIELD
argument_list|(
name|Acc
argument_list|)
expr_stmt|;
name|temp
operator|=
name|CH_FIELD
argument_list|(
name|Temp
argument_list|)
expr_stmt|;
do|do
block|{
name|ch
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
do|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'-'
case|:
name|msign
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'+'
case|:
name|ch
operator|=
operator|*
name|str
operator|++
expr_stmt|;
break|break;
block|}
name|dofract
label|:
for|for
control|(
init|;
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|;
name|ch
operator|=
operator|*
name|str
operator|++
control|)
block|{
name|assert
argument_list|(
operator|(
operator|(
name|acc
index|[
name|HOC
index|]
operator|&
name|SIGNBIT
operator|)
operator|==
literal|0
operator|)
argument_list|,
literal|"Negative HOC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|acc
index|[
name|HOC
index|]
operator|<
name|MAXINT_10
condition|)
block|{
name|ovf
operator|=
name|numshift
argument_list|(
literal|3
argument_list|,
name|temp
argument_list|,
name|acc
argument_list|)
expr_stmt|;
name|ovf
operator||=
name|numshift
argument_list|(
literal|1
argument_list|,
name|acc
argument_list|,
name|acc
argument_list|)
expr_stmt|;
name|ovf
operator||=
name|numaddv
argument_list|(
name|acc
argument_list|,
name|temp
argument_list|,
name|acc
argument_list|)
expr_stmt|;
name|ovf
operator||=
name|numaddd
argument_list|(
name|acc
argument_list|,
name|acc
argument_list|,
name|ch
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ovf
operator|==
literal|0
argument_list|,
literal|"Overflow building mantissa"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 *	Then, the number is too large anyway 			 */
name|dexponent
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|decpt
condition|)
name|dexponent
operator|--
expr_stmt|;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'.'
case|:
if|if
condition|(
name|decpt
operator|==
literal|0
condition|)
block|{
name|decpt
operator|++
expr_stmt|;
name|ch
operator|=
operator|*
name|str
operator|++
expr_stmt|;
goto|goto
name|dofract
goto|;
block|}
break|break;
comment|/* 	 *	only 'e' and 'E' are recognized by atof() 	 */
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
comment|/* 	 *	we include the remainder for compatability with as formats 	 *	in as, the radix actual paramater agrees with the character 	 *	we expect; consequently, no checking is done. 	 */
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|j
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
operator|*
name|str
operator|++
expr_stmt|;
name|esign
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'-'
case|:
name|esign
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'+'
case|:
name|ch
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|;
name|ch
operator|=
operator|*
name|str
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
name|MAXINT_10
condition|)
block|{
name|j
operator|*=
literal|10
expr_stmt|;
name|j
operator|+=
name|ch
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 *	outrageously large exponent 				 */
comment|/*VOID*/
block|}
block|}
if|if
condition|(
name|esign
condition|)
name|dexponent
operator|-=
name|j
expr_stmt|;
else|else
name|dexponent
operator|+=
name|j
expr_stmt|;
comment|/* 		 *	There should be a range check on dexponent here 		 */
block|}
comment|/* 	 *	The number has now been reduced to a mantissa 	 *	and an exponent. 	 *	The mantissa is an n bit number (to the precision 	 *	of the extended words) in the acc. 	 *	The exponent is a signed power of 10 in dexponent. 	 *	msign is on if the resulting number will eventually 	 *	be negative. 	 * 	 *	We now must convert the number to standard format floating 	 *	number, which will be done by accumulating 	 *	a binary exponent in bexponent, as we gradually 	 *	drive dexponent towards zero, one count at a time. 	 */
if|if
condition|(
name|isclear
argument_list|(
name|acc
argument_list|)
condition|)
block|{
return|return
operator|(
name|Acc
operator|)
return|;
block|}
name|bexponent
operator|=
literal|0
expr_stmt|;
comment|/* 	 *	Scale the number down. 	 *	We must divide acc by 10 as many times as needed. 	 */
for|for
control|(
init|;
name|dexponent
operator|<
literal|0
condition|;
name|dexponent
operator|++
control|)
block|{
comment|/* 		 *	Align the number so that the most significant 		 *	bits are aligned in the most significant 		 *	bits of the accumulator, adjusting the 		 *	binary exponent as we shift. 		 *	The goal is to get the high order bit (NOT the 		 *	sign bit) set. 		 */
name|assert
argument_list|(
operator|(
operator|(
name|acc
index|[
name|HOC
index|]
operator|&
name|SIGNBIT
operator|)
operator|==
literal|0
operator|)
argument_list|,
literal|"Negative HOC"
argument_list|)
expr_stmt|;
name|ovf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|5
init|;
name|j
operator|>=
literal|1
condition|;
operator|--
name|j
control|)
block|{
name|i
operator|=
literal|1
operator|<<
operator|(
name|j
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 16, 8, 4, 2, 1 */
name|quotient
operator|=
name|ONES
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|quotient
operator|<<=
operator|(
name|CH_BITS
operator|-
literal|1
operator|)
operator|-
name|i
expr_stmt|;
while|while
condition|(
operator|(
name|acc
index|[
name|HOC
index|]
operator|&
name|quotient
operator|)
operator|==
literal|0
condition|)
block|{
name|ovf
operator||=
name|numshift
argument_list|(
operator|(
name|int
operator|)
name|i
argument_list|,
name|acc
argument_list|,
name|acc
argument_list|)
expr_stmt|;
name|bexponent
operator|-=
name|i
expr_stmt|;
block|}
block|}
comment|/* 		 *	Add 2 to the accumulator to effect rounding, 		 *	and get set up to divide by 5. 		 */
name|ovf
operator|=
name|numaddd
argument_list|(
name|acc
argument_list|,
name|acc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ovf
operator|==
literal|0
argument_list|,
literal|"Carry out of left rounding up by 2"
argument_list|)
expr_stmt|;
comment|/* 		 *	Divide the high order chunks by 5; 		 *	The last chunk will be divided by 10, 		 *	(to see what the remainder is, also to effect rounding) 		 *	and then multipiled by 2 to effect division by 5. 		 */
name|remainder
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|DEBUGNATOF
name|printf
argument_list|(
literal|"Dividing: "
argument_list|)
expr_stmt|;
name|bignumprint
argument_list|(
name|Acc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUGNATOF
name|sptr
operator|=
operator|(
name|short
operator|*
operator|)
name|acc
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|CH_N
operator|*
literal|2
operator|-
literal|1
operator|)
init|;
name|i
operator|>=
literal|1
condition|;
operator|--
name|i
control|)
block|{
comment|/* 			 *	Divide (remainder:16).(acc[i]:16) 			 *	by 5, putting the quotient back 			 *	into acc[i]:16, and save the remainder 			 *	for the next iteration. 			 */
name|dividend
operator|=
operator|(
name|remainder
operator|<<
literal|16
operator|)
operator||
operator|(
name|sptr
index|[
name|i
index|]
operator|&
name|ONES
argument_list|(
literal|16
argument_list|)
operator|)
expr_stmt|;
name|assert
argument_list|(
name|dividend
operator|>=
literal|0
argument_list|,
literal|"dividend< 0"
argument_list|)
expr_stmt|;
name|quotient
operator|=
name|dividend
operator|/
literal|5
expr_stmt|;
name|remainder
operator|=
name|dividend
operator|-
operator|(
name|quotient
operator|*
literal|5
operator|)
expr_stmt|;
name|sptr
index|[
name|i
index|]
operator|=
name|quotient
expr_stmt|;
name|remainder
operator|=
name|remainder
expr_stmt|;
block|}
comment|/* 		 *	Divide the lowest order chunk by 10, 		 *	saving the remainder to decide how to round. 		 *	Then, multiply by 2, making it look as 		 *	if we divided by 10. 		 *	This multiply fills in a 0 on the least sig bit. 		 */
name|dividend
operator|=
operator|(
name|remainder
operator|<<
literal|16
operator|)
operator||
operator|(
name|sptr
index|[
literal|0
index|]
operator|&
name|ONES
argument_list|(
literal|16
argument_list|)
operator|)
expr_stmt|;
name|assert
argument_list|(
name|dividend
operator|>=
literal|0
argument_list|,
literal|"dividend< 0"
argument_list|)
expr_stmt|;
name|quotient
operator|=
name|dividend
operator|/
literal|10
expr_stmt|;
name|remainder
operator|=
name|dividend
operator|-
operator|(
name|quotient
operator|*
literal|10
operator|)
expr_stmt|;
name|sptr
index|[
literal|0
index|]
operator|=
name|quotient
operator|+
name|quotient
expr_stmt|;
if|if
condition|(
name|remainder
operator|>=
literal|5
condition|)
name|ovf
operator|=
name|numaddd
argument_list|(
name|acc
argument_list|,
name|acc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 *	Now, divide by 2, effecting division by 10, 		 *	merely by adjusting the binary exponent. 		 */
name|bexponent
operator|--
expr_stmt|;
block|}
comment|/* 	 *	Scale the number up by multiplying by 10 as  	 *	many times as necessary 	 */
for|for
control|(
init|;
name|dexponent
operator|>
literal|0
condition|;
name|dexponent
operator|--
control|)
block|{
comment|/* 		 *	Compare high word to (2**31)/5, 		 *	and scale accordingly 		 */
while|while
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|acc
index|[
name|HOC
index|]
operator|)
operator|>
name|MAXINT_5
condition|)
block|{
operator|(
name|void
operator|)
name|numshift
argument_list|(
operator|-
literal|1
argument_list|,
name|acc
argument_list|,
name|acc
argument_list|)
expr_stmt|;
name|bexponent
operator|++
expr_stmt|;
block|}
comment|/* 		 *	multiply the mantissa by 5, 		 *	and scale the binary exponent by 2 		 */
name|ovf
operator|=
name|numshift
argument_list|(
literal|2
argument_list|,
name|temp
argument_list|,
name|acc
argument_list|)
expr_stmt|;
name|ovf
operator||=
name|numaddv
argument_list|(
name|acc
argument_list|,
name|acc
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ovf
operator|==
literal|0
argument_list|,
literal|"Scaling * 10 of manitissa"
argument_list|)
expr_stmt|;
name|bexponent
operator|++
expr_stmt|;
block|}
comment|/* 	 *	We now have: 	 *	a CH_N chunk length binary integer, right 	 *		justified (in native format). 	 *	a binary exponent. 	 * 	 *	Now, we treat this large integer as an octa word 	 *	number, and unpack it into standard unpacked 	 *	format.  That unpacking will give us yet 	 *	another binary exponent, which we adjust with 	 *	the accumulated binary exponent. 	 */
name|Acc
operator|.
name|num_tag
operator|=
name|TYPO
expr_stmt|;
if|#
directive|if
name|DEBUGNATOF
name|printf
argument_list|(
literal|"Octal number: "
argument_list|)
expr_stmt|;
name|bignumprint
argument_list|(
name|Acc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUGNATOF
name|Acc
operator|=
name|bignumunpack
argument_list|(
name|Acc
argument_list|,
operator|&
name|ovf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ovf
condition|)
name|errno
operator|=
name|ERANGE
expr_stmt|;
if|#
directive|if
name|DEBUGNATOF
name|printf
argument_list|(
literal|"Unpacked octal number: "
argument_list|)
expr_stmt|;
name|bignumprint
argument_list|(
name|Acc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bexponent == %d\n"
argument_list|,
name|bexponent
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUGNATOF
name|Acc
operator|.
name|num_exponent
operator|+=
name|bexponent
expr_stmt|;
name|assert
argument_list|(
name|Acc
operator|.
name|num_sign
operator|==
literal|0
argument_list|,
literal|"unpacked integer is< 0"
argument_list|)
expr_stmt|;
name|Acc
operator|.
name|num_sign
operator|=
name|msign
expr_stmt|;
comment|/* 	 *	We now pack the number back into a radix format number. 	 *	This checks for overflow, underflow, 	 *	and rounds by 1/2 ulp. 	 */
name|ovf
operator|=
literal|0
expr_stmt|;
name|Acc
operator|=
name|bignumpack
argument_list|(
name|Acc
argument_list|,
name|radix
argument_list|,
operator|&
name|ovf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ovf
condition|)
name|errno
operator|=
name|ERANGE
expr_stmt|;
if|#
directive|if
name|DEBUGNATOF
name|printf
argument_list|(
literal|"packed number: "
argument_list|)
expr_stmt|;
name|bignumprint
argument_list|(
name|Acc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUGNATOF
return|return
operator|(
name|Acc
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  *	Unfortunately, one can't use the ediv instruction to do  *	division on numbers with> 64 bits.  *	This is because ediv returns signed quantities;  *	if the quotient is an unsigned number> 2^31,  *	ediv sets integer overflow.  */
end_comment

begin_comment
unit|unsigned int ediv(high, low, divisor, qp, i) 	register	unsigned int	high;
comment|/* r11 */
end_comment

begin_comment
unit|register	unsigned int	low;
comment|/* r10 */
end_comment

begin_comment
unit|register	unsigned int	divisor;
comment|/* r9 */
end_comment

begin_comment
unit|unsigned int	*qp; { 	register	unsigned int	remainder;
comment|/* r8 */
end_comment

begin_comment
unit|register	unsigned int	quotient;
comment|/* r7 */
end_comment

begin_endif
unit|asm("ediv r9, r10, r7, r8	# Divide.  q->r7, r->r8 (discarded)"); 	*qp = quotient; 	return(remainder); }
endif|#
directive|endif
endif|0
end_endif

end_unit

