begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1982 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)asmain.c	5.5 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"assyms.h"
end_include

begin_include
include|#
directive|include
file|"asscan.h"
end_include

begin_include
include|#
directive|include
file|"asexpr.h"
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|unix_lang_name
value|"VAX/UNIX Assembler V%G% 5.5"
end_define

begin_comment
comment|/*  *	variables to manage reading the assembly source files  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dotsname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the current file name; managed by the parser*/
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*current line number; managed by the parser*/
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|innames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*names of the files being assembled*/
end_comment

begin_decl_stmt
name|int
name|ninfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*how many interesting files there are*/
end_comment

begin_comment
comment|/*  *	Flags settable from the argv process argument list  */
end_comment

begin_decl_stmt
name|int
name|silent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*don't complain about any errors*/
end_comment

begin_decl_stmt
name|int
name|savelabels
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*write the labels to the a.out file*/
end_comment

begin_decl_stmt
name|int
name|d124
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*default allocate 4 bytes for unknown pointers*/
end_comment

begin_decl_stmt
name|int
name|maxalign
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*default .align maximum*/
end_comment

begin_decl_stmt
name|int
name|anyerrs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*no errors yet*/
end_comment

begin_decl_stmt
name|int
name|anywarnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*no warnings yet*/
end_comment

begin_decl_stmt
name|int
name|orgwarn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Bad origins*/
end_comment

begin_decl_stmt
name|int
name|passno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current pass*/
end_comment

begin_decl_stmt
name|int
name|jxxxJUMP
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in jxxxes that branch too far, use jmp instead of brw */
end_comment

begin_decl_stmt
name|int
name|readonlydata
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initialzed data -> text space */
end_comment

begin_decl_stmt
name|int
name|nGHnumbers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GH numbers used */
end_comment

begin_decl_stmt
name|int
name|nGHopcodes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GH opcodes used */
end_comment

begin_decl_stmt
name|int
name|nnewopcodes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new opcodes used */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|toktrace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|useVM
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|endcore
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*where to get more symbol space*/
end_comment

begin_comment
comment|/*  *	Managers of the a.out file.  */
end_comment

begin_decl_stmt
name|struct
name|exec
name|hdr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAGIC
value|0407
end_define

begin_decl_stmt
name|u_long
name|tsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total text size */
end_comment

begin_decl_stmt
name|u_long
name|dsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total data size */
end_comment

begin_decl_stmt
name|u_long
name|datbase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base of the data segment */
end_comment

begin_decl_stmt
name|u_long
name|trsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total text relocation size */
end_comment

begin_decl_stmt
name|u_long
name|drsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total data relocation size */
end_comment

begin_comment
comment|/*  *	Information about the current segment is accumulated in  *	usedot; the most important information stored is the  *	accumulated size of each of the text and data segments  *  *	dotp points to the correct usedot expression for the current segment  */
end_comment

begin_decl_stmt
name|struct
name|exp
name|usedot
index|[
name|NLOC
operator|+
name|NLOC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* info about all segments */
end_comment

begin_decl_stmt
name|struct
name|exp
modifier|*
name|dotp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data/text location pointer */
end_comment

begin_comment
comment|/*  *	The inter pass temporary token file is opened and closed by stdio, but  *	is written to using direct read/write, as the temporary file  *	is composed of buffers exactly BUFSIZ long.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|tokfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interpass communication file */
end_comment

begin_decl_stmt
name|char
name|tokfilename
index|[
name|TNAMESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	The string file is the string table  *	cat'ed to the end of the built up a.out file  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|strfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interpass string file */
end_comment

begin_decl_stmt
name|char
name|strfilename
index|[
name|TNAMESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strfilepos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* position within the string file */
end_comment

begin_comment
comment|/*  *	a.out is created during the second pass.  *	It is opened by stdio, but is filled with the parallel  *	block I/O library  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|a_out_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|off_t
name|a_out_off
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cumulative offsets for segments */
end_comment

begin_comment
comment|/*  *	The logical files containing the assembled data for each of  *	the text and data segments are  *	managed by the parallel block I/O library.  *	a.out is logically opened in many places at once to  *	receive the assembled data from the various segments as  *	it all trickles in, but is physically opened only once  *	to minimize file overhead.  */
end_comment

begin_decl_stmt
name|BFILE
modifier|*
name|usefile
index|[
name|NLOC
operator|+
name|NLOC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* text/data files */
end_comment

begin_decl_stmt
name|BFILE
modifier|*
name|txtfil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current text/data file */
end_comment

begin_comment
comment|/*  *	Relocation information is accumulated seperately for each  *	segment.  This is required by the old loader (from BTL),  *	but not by the new loader (Bill Joy).    *  *	However, the size of the relocation information can not be computed  *	during or after the 1st pass because the ''absoluteness' of values  *	is unknown until all locally declared symbols have been seen.  *	Thus, the size of the relocation information is only  *	known after the second pass is finished.  *	This obviates the use of the block I/O  *	library, which requires knowing the exact offsets in a.out.  *  *	So, we save the relocation information internally (we don't  *	go to internal files to minimize overhead).  *  *	Empirically, we studied 259 files composing the system,  *	two compilers and a compiler generator: (all of which have  *	fairly large source files)  *	  *	Number of files = 259  *		Number of non zero text reloc files: 233  *		Number of non zero data reloc files: 53  *	Average text relocation = 889  *	Average data relocation = 346  *	Number of files> BUFSIZ text relocation = 71  *	Number of files> BUFSIZ data relocation = 6  *	  *	For compiled C code, there is usually one text segment and two  *	data segments; we see that allocating our own buffers and  *	doing our internal handling of relocation information will,  *	on the average, not use more memory than taken up by the buffers  *	allocated for doing file I/O in parallel to a number of file.  *	  *	If we are assembling with the -V option, we  *	use the left over token buffers from the 2nd pass,  *	otherwise, we create our own.  *  *	When the 2nd pass is complete, closeoutrel flushes the token  *	buffers out to a BFILE.  *  *	The internals to relbufdesc are known only in assyms.c  *  *	outrel constructs the relocation information.  *	closeoutrel flushes the relocation information to relfil.  */
end_comment

begin_decl_stmt
name|struct
name|relbufdesc
modifier|*
name|rusefile
index|[
name|NLOC
operator|+
name|NLOC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|relbufdesc
modifier|*
name|relfil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* un concatnated relocation info */
end_comment

begin_decl_stmt
name|BFILE
modifier|*
name|relocfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* concatnated relocation info */
end_comment

begin_comment
comment|/*  *	Once the relocation information has been written,  *	we can write out the symbol table using the Block I/O  *	mechanisms, as we once again know the offsets into  *	the a.out file.  *  *	We use relfil to output the symbol table information.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tmpdirprefix
init|=
literal|"/tmp/"
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|delexit
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
name|tokfilename
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strfilename
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|endcore
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|argprocess
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* process argument lists */
if|if
condition|(
name|anyerrs
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|initialize
argument_list|()
expr_stmt|;
name|zeroorigins
argument_list|()
expr_stmt|;
comment|/* set origins to zero */
name|zerolocals
argument_list|()
expr_stmt|;
comment|/* fix local label counters */
name|i_pass1
argument_list|()
expr_stmt|;
comment|/* open temp files, etc */
name|pass1
argument_list|()
expr_stmt|;
comment|/* first pass through .s files */
name|testlocals
argument_list|()
expr_stmt|;
comment|/* check for undefined locals */
if|if
condition|(
name|anyerrs
condition|)
name|delexit
argument_list|()
expr_stmt|;
name|pass1_5
argument_list|()
expr_stmt|;
comment|/* resolve jxxx */
if|if
condition|(
name|anyerrs
condition|)
name|delexit
argument_list|()
expr_stmt|;
name|open_a_out
argument_list|()
expr_stmt|;
comment|/* open a.out */
name|roundsegments
argument_list|()
expr_stmt|;
comment|/* round segments to FW */
name|build_hdr
argument_list|()
expr_stmt|;
comment|/* build initial header, and output */
name|i_pass2
argument_list|()
expr_stmt|;
comment|/* reopen temporary file, etc */
name|pass2
argument_list|()
expr_stmt|;
comment|/* second pass through the virtual .s */
if|if
condition|(
name|anyerrs
condition|)
name|delexit
argument_list|()
expr_stmt|;
name|fillsegments
argument_list|()
expr_stmt|;
comment|/* fill segments with 0 to FW */
name|reloc_syms
argument_list|()
expr_stmt|;
comment|/* dump relocation and symbol table */
name|delete
argument_list|()
expr_stmt|;
comment|/* remove tmp file */
name|bflush
argument_list|()
expr_stmt|;
comment|/* close off block I/O view of a.out */
name|fix_a_out
argument_list|()
expr_stmt|;
comment|/* add in text and data reloc counts */
if|if
condition|(
name|anyerrs
operator|==
literal|0
operator|&&
name|orgwarn
condition|)
name|yyerror
argument_list|(
literal|"Caution: absolute origins.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nGHnumbers
condition|)
name|yywarning
argument_list|(
literal|"Caution: G or H format floating point numbers"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nGHopcodes
condition|)
name|yywarning
argument_list|(
literal|"Caution: G or H format floating point operators"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nnewopcodes
condition|)
name|yywarning
argument_list|(
literal|"Caution: New Opcodes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nGHnumbers
operator|||
name|nGHopcodes
operator|||
name|nnewopcodes
condition|)
name|yywarning
argument_list|(
literal|"These are not defined for all implementations of the VAX architecture.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|anyerrs
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|argprocess
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|ninfiles
operator|=
literal|0
expr_stmt|;
name|silent
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|outfile
operator|=
operator|(
name|char
operator|*
operator|)
name|genbuildname
argument_list|(
literal|"a.out"
argument_list|)
expr_stmt|;
name|innames
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ClearCalloc
argument_list|(
name|argc
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|innames
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dotsname
operator|=
literal|"<argv error>"
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
name|innames
index|[
name|ninfiles
operator|++
index|]
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
else|else
block|{
name|cp
operator|=
name|argv
index|[
literal|1
index|]
operator|+
literal|1
expr_stmt|;
comment|/* 			 *	We can throw away single minus signs, so 			 *	that make scripts for the PDP 11 assembler work 			 *	on this assembler too 			 */
while|while
condition|(
operator|*
name|cp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
default|default:
name|yyerror
argument_list|(
literal|"Unknown flag: %c"
argument_list|,
operator|*
operator|--
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|selfwhat
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|'d'
case|:
name|d124
operator|=
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
name|d124
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|d124
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|d124
operator|!=
literal|4
operator|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"-d[124] only"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
name|maxalign
operator|=
name|atoi
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|++
init|;
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
comment|/*VOID*/
empty_stmt|;
if|if
condition|(
operator|(
name|maxalign
operator|>
literal|16
operator|)
operator|||
operator|(
name|maxalign
operator|<
literal|0
operator|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"-a: 0<=align<=16"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|yyerror
argument_list|(
literal|"-o what???"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|outfile
operator|=
operator|(
name|char
operator|*
operator|)
name|genbuildname
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|bumpone
label|:
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
goto|goto
name|nextarg
goto|;
case|case
literal|'t'
case|:
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|yyerror
argument_list|(
literal|"-t what???"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tmpdirprefix
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
goto|goto
name|bumpone
goto|;
case|case
literal|'V'
case|:
name|useVM
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|silent
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|savelabels
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|jxxxJUMP
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'D'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|toktrace
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'R'
case|:
name|readonlydata
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/*end of the switch*/
block|}
comment|/*end of pulling out all arguments*/
block|}
comment|/*end of a flag argument*/
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
name|nextarg
label|:
empty_stmt|;
block|}
comment|/* innames[ninfiles] = 0; */
block|}
end_block

begin_comment
comment|/*  *	poke through the data space and find all sccs identifiers.  *	We assume:  *	a) that extern char **environ; is the first thing in the bss  *	segment (true, if one is using the new version of cmgt.crt0.c)  *	b) that the sccsid's have not been put into text space.  */
end_comment

begin_macro
name|selfwhat
argument_list|(
argument|place
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|place
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
specifier|register
name|char
modifier|*
name|ub
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
for|for
control|(
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|environ
operator|,
name|ub
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
init|;
name|cp
operator|<
name|ub
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
continue|continue;
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|!=
literal|'('
condition|)
continue|continue;
if|if
condition|(
name|cp
index|[
literal|2
index|]
operator|!=
literal|'#'
condition|)
continue|continue;
if|if
condition|(
name|cp
index|[
literal|3
index|]
operator|!=
literal|')'
condition|)
continue|continue;
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|place
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|+=
literal|4
init|;
name|cp
operator|<
name|ub
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'>'
condition|)
break|break;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
break|break;
name|fputc
argument_list|(
operator|*
name|cp
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|initialize
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|delexit
argument_list|)
expr_stmt|;
comment|/* 	 *	Install symbols in the table 	 */
name|symtabinit
argument_list|()
expr_stmt|;
name|syminstall
argument_list|()
expr_stmt|;
comment|/* 	 *	Build the expression parser accelerator token sets 	 */
name|buildtokensets
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|zeroorigins
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|locindex
decl_stmt|;
comment|/* 	 *	Mark usedot: the first NLOC slots are for named text segments, 	 *	the next for named data segments. 	 */
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
name|usedot
index|[
name|locindex
index|]
operator|.
name|e_xtype
operator|=
name|XTEXT
expr_stmt|;
name|usedot
index|[
name|NLOC
operator|+
name|locindex
index|]
operator|.
name|e_xtype
operator|=
name|XDATA
expr_stmt|;
name|usedot
index|[
name|locindex
index|]
operator|.
name|e_xvalue
operator|=
literal|0
expr_stmt|;
name|usedot
index|[
name|NLOC
operator|+
name|locindex
index|]
operator|.
name|e_xvalue
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|zerolocals
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|lgensym
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|genref
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|i_pass1
argument_list|()
end_macro

begin_block
block|{
name|FILE
modifier|*
name|tempopen
parameter_list|()
function_decl|;
if|if
condition|(
name|useVM
operator|==
literal|0
condition|)
name|tokfile
operator|=
name|tempopen
argument_list|(
name|tokfilename
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
name|strfile
operator|=
name|tempopen
argument_list|(
name|strfilename
argument_list|,
literal|"S"
argument_list|)
expr_stmt|;
comment|/* 	 *	write out the string length. 	 *	This will be overwritten when the 	 *	strings are tacked onto the growing a.out file 	 */
name|strfilepos
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|strfilepos
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|strfile
argument_list|)
expr_stmt|;
name|inittokfile
argument_list|()
expr_stmt|;
name|initijxxx
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|FILE
modifier|*
name|tempopen
parameter_list|(
name|tname
parameter_list|,
name|part
parameter_list|)
name|char
modifier|*
name|tname
decl_stmt|;
name|char
modifier|*
name|part
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"%s%sas%s%05d"
argument_list|,
name|tmpdirprefix
argument_list|,
operator|(
name|tmpdirprefix
index|[
name|strlen
argument_list|(
name|tmpdirprefix
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|?
literal|"/"
else|:
literal|""
argument_list|,
name|part
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|tname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"Bad pass 1 temporary file for writing %s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_macro
name|pass1
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|passno
operator|=
literal|1
expr_stmt|;
name|dotp
operator|=
operator|&
name|usedot
index|[
literal|0
index|]
expr_stmt|;
name|txtfil
operator|=
operator|(
name|BFILE
operator|*
operator|)
literal|0
expr_stmt|;
name|relfil
operator|=
operator|(
expr|struct
name|relbufdesc
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|ninfiles
operator|==
literal|0
condition|)
block|{
comment|/*take the input from stdin directly*/
name|lineno
operator|=
literal|1
expr_stmt|;
name|dotsname
operator|=
literal|"<stdin>"
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/*we have the names tanked*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninfiles
condition|;
name|i
operator|++
control|)
block|{
name|new_dot_s
argument_list|(
name|innames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|innames
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"Can't open source file %s\n"
argument_list|,
name|innames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* stdio is NOT used to read the input characters */
comment|/* we use read directly, into our own buffers */
name|yyparse
argument_list|()
expr_stmt|;
block|}
block|}
name|closetokfile
argument_list|()
expr_stmt|;
comment|/*kick out the last buffered intermediate text*/
block|}
end_block

begin_macro
name|testlocals
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|9
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|genref
index|[
name|i
index|]
condition|)
name|yyerror
argument_list|(
literal|"Reference to undefined local label %df"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lgensym
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|genref
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|pass1_5
argument_list|()
end_macro

begin_block
block|{
name|sortsymtab
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|dumpsymtab
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|jxxxfix
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|dumpsymtab
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|open_a_out
argument_list|()
end_macro

begin_block
block|{
name|struct
name|stat
name|stb
decl_stmt|;
comment|/* 	 *	Open up the a.out file now, and get set to build 	 *	up offsets into it for all of the various text,data 	 *	text relocation and data relocation segments. 	 */
name|a_out_file
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_out_file
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"Cannot create %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
name|biofd
operator|=
name|a_out_file
operator|->
name|_file
expr_stmt|;
name|fstat
argument_list|(
name|biofd
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
name|biobufsize
operator|=
name|stb
operator|.
name|st_blksize
expr_stmt|;
name|a_out_off
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|roundsegments
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|locindex
decl_stmt|;
specifier|register
name|long
name|v
decl_stmt|;
comment|/* 	 *	round and assign text segment origins 	 *	the exec header always goes in usefile[0] 	 */
name|tsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
name|v
operator|=
name|round
argument_list|(
name|usedot
index|[
name|locindex
index|]
operator|.
name|e_xvalue
argument_list|,
name|FW
argument_list|)
expr_stmt|;
name|usedot
index|[
name|locindex
index|]
operator|.
name|e_xvalue
operator|=
name|tsize
expr_stmt|;
if|if
condition|(
operator|(
name|locindex
operator|==
literal|0
operator|)
operator|||
operator|(
name|v
operator|!=
literal|0
operator|)
condition|)
block|{
name|usefile
index|[
name|locindex
index|]
operator|=
operator|(
name|BFILE
operator|*
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|BFILE
argument_list|)
argument_list|)
expr_stmt|;
name|bopen
argument_list|(
name|usefile
index|[
name|locindex
index|]
argument_list|,
name|a_out_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|locindex
operator|==
literal|0
condition|)
name|a_out_off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usefile
index|[
name|locindex
index|]
operator|=
operator|(
name|BFILE
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|tsize
operator|+=
name|v
expr_stmt|;
name|a_out_off
operator|+=
name|v
expr_stmt|;
block|}
comment|/* 	 *		Round and assign data segment origins. 	 */
name|datbase
operator|=
name|round
argument_list|(
name|tsize
argument_list|,
name|FW
argument_list|)
expr_stmt|;
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
name|v
operator|=
name|round
argument_list|(
name|usedot
index|[
name|NLOC
operator|+
name|locindex
index|]
operator|.
name|e_xvalue
argument_list|,
name|FW
argument_list|)
expr_stmt|;
name|usedot
index|[
name|NLOC
operator|+
name|locindex
index|]
operator|.
name|e_xvalue
operator|=
name|datbase
operator|+
name|dsize
expr_stmt|;
if|if
condition|(
name|v
operator|!=
literal|0
condition|)
block|{
name|usefile
index|[
name|NLOC
operator|+
name|locindex
index|]
operator|=
operator|(
name|BFILE
operator|*
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|BFILE
argument_list|)
argument_list|)
expr_stmt|;
name|bopen
argument_list|(
name|usefile
index|[
name|NLOC
operator|+
name|locindex
index|]
argument_list|,
name|a_out_off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usefile
index|[
name|NLOC
operator|+
name|locindex
index|]
operator|=
operator|(
name|BFILE
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|dsize
operator|+=
name|v
expr_stmt|;
name|a_out_off
operator|+=
name|v
expr_stmt|;
block|}
comment|/* 	 *	Assign final values to symbols 	 */
name|hdr
operator|.
name|a_bss
operator|=
name|dsize
expr_stmt|;
name|freezesymtab
argument_list|()
expr_stmt|;
comment|/* this touches hdr.a_bss */
name|stabfix
argument_list|()
expr_stmt|;
comment|/* 	 *	Set up the relocation information "files" to 	 *	be zero; outrel takes care of the rest 	 */
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
name|rusefile
index|[
name|locindex
index|]
operator|=
operator|(
expr|struct
name|relbufdesc
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|build_hdr
argument_list|()
end_macro

begin_block
block|{
comment|/* 	 *	Except for the text and data relocation sizes, 	 *	calculate the final values for the header 	 *	 	 *	Write out the initial copy; we to come  	 *	back later and patch up a_trsize and a_drsize, 	 *	and overwrite this first version of the header. 	 */
name|hdr
operator|.
name|a_magic
operator|=
name|MAGIC
expr_stmt|;
name|hdr
operator|.
name|a_text
operator|=
name|tsize
expr_stmt|;
name|hdr
operator|.
name|a_data
operator|=
name|dsize
expr_stmt|;
name|hdr
operator|.
name|a_bss
operator|-=
name|dsize
expr_stmt|;
name|hdr
operator|.
name|a_syms
operator|=
name|sizesymtab
argument_list|()
expr_stmt|;
comment|/* Does not include string pool length */
name|hdr
operator|.
name|a_entry
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|a_trsize
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|a_drsize
operator|=
literal|0
expr_stmt|;
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
name|usefile
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|i_pass2
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|useVM
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|tokfile
argument_list|)
expr_stmt|;
name|tokfile
operator|=
name|fopen
argument_list|(
name|tokfilename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokfile
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"Bad pass 2 temporary file for reading %s"
argument_list|,
name|tokfilename
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|strfile
argument_list|)
expr_stmt|;
name|strfile
operator|=
name|fopen
argument_list|(
name|strfilename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pass2
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"\n\n\n\t\tPASS 2\n\n\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|passno
operator|=
literal|2
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|dotp
operator|=
operator|&
name|usedot
index|[
literal|0
index|]
expr_stmt|;
name|txtfil
operator|=
name|usefile
index|[
literal|0
index|]
expr_stmt|;
comment|/* already opened (always!) */
name|relfil
operator|=
literal|0
expr_stmt|;
comment|/* outrel takes care of the rest */
name|initoutrel
argument_list|()
expr_stmt|;
name|inittokfile
argument_list|()
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|closetokfile
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|fillsegments
argument_list|()
end_macro

begin_block
block|{
name|int
name|locindex
decl_stmt|;
comment|/* 	 *	Round text and data segments to FW by appending zeros 	 */
for|for
control|(
name|locindex
operator|=
literal|0
init|;
name|locindex
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|locindex
operator|++
control|)
block|{
if|if
condition|(
name|usefile
index|[
name|locindex
index|]
condition|)
block|{
name|txtfil
operator|=
name|usefile
index|[
name|locindex
index|]
expr_stmt|;
name|dotp
operator|=
operator|&
name|usedot
index|[
name|locindex
index|]
expr_stmt|;
while|while
condition|(
name|usedot
index|[
name|locindex
index|]
operator|.
name|e_xvalue
operator|&
name|FW
condition|)
name|outb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|reloc_syms
argument_list|()
end_macro

begin_block
block|{
name|u_long
name|closerelfil
parameter_list|()
function_decl|;
comment|/* 	 *	Move the relocation information to a.out 	 *	a_out_off is the offset so far: 	 *	exec + text segments + data segments 	 */
name|relocfile
operator|=
operator|(
name|BFILE
operator|*
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|BFILE
argument_list|)
argument_list|)
expr_stmt|;
name|bopen
argument_list|(
name|relocfile
argument_list|,
name|a_out_off
argument_list|)
expr_stmt|;
name|a_out_off
operator|+=
name|closeoutrel
argument_list|(
name|relocfile
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|a_trsize
operator|=
name|trsize
expr_stmt|;
name|hdr
operator|.
name|a_drsize
operator|=
name|drsize
expr_stmt|;
if|if
condition|(
name|readonlydata
condition|)
block|{
name|hdr
operator|.
name|a_text
operator|+=
name|hdr
operator|.
name|a_data
expr_stmt|;
name|hdr
operator|.
name|a_data
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|a_trsize
operator|+=
name|hdr
operator|.
name|a_drsize
expr_stmt|;
name|hdr
operator|.
name|a_drsize
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *	Output the symbol table and the string pool 	 * 	 *	We must first rewind the string pool file to its beginning, 	 *	in case it was seek'ed into for fetching ascii and asciz 	 *	strings. 	 */
name|fseek
argument_list|(
name|strfile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symwrite
argument_list|(
name|relocfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fix_a_out
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|lseek
argument_list|(
name|a_out_file
operator|->
name|_file
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
operator|<
literal|0L
condition|)
name|yyerror
argument_list|(
literal|"Reposition for header rewrite fails"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|a_out_file
operator|->
name|_file
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Rewrite of header fails"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|delexit
argument_list|()
end_macro

begin_block
block|{
name|delete
argument_list|()
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
block|{
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|delete
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|useVM
operator|==
literal|0
operator|||
name|tokfilename
index|[
literal|0
index|]
condition|)
name|unlink
argument_list|(
name|tokfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|strfilename
index|[
literal|0
index|]
condition|)
name|unlink
argument_list|(
name|strfilename
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sawabort
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|fillinbuffer
parameter_list|()
function_decl|;
while|while
condition|(
name|fillinbuffer
argument_list|()
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
continue|continue;
name|delete
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*although the previous pass will also exit non zero*/
block|}
end_block

begin_macro
name|panic
argument_list|(
argument|fmt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*VARARGS 1*/
end_comment

begin_block
block|{
name|yyerror
argument_list|(
literal|"Assembler panic: bad internal data structure."
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|)
expr_stmt|;
name|delete
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

