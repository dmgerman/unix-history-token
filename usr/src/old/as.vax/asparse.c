begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright (c) 1982 Regents of the University of California  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)asparse.c 4.19 %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"asscan.h"
end_include

begin_include
include|#
directive|include
file|"assyms.h"
end_include

begin_include
include|#
directive|include
file|"asexpr.h"
end_include

begin_decl_stmt
name|int
name|lgensym
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|genref
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|bitfield
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bitoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|curlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current length of literals */
end_comment

begin_comment
comment|/*  *	The following three variables are communication between various  *	modules to special case a number of things.  They are properly  *	categorized as hacks.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|symtab
modifier|*
name|lastnam
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*last name seen by the lexical analyzer*/
end_comment

begin_decl_stmt
name|int
name|exprisname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*last factor in an expression was a name*/
end_comment

begin_decl_stmt
name|int
name|droppedLP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*one is analyzing an expression beginning with*/
end_comment

begin_comment
comment|/*a left parenthesis, which has already been*/
end_comment

begin_comment
comment|/*shifted. (Used to parse (<expr>)(rn)*/
end_comment

begin_decl_stmt
name|char
name|yytext
index|[
name|NCPName
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the lexical image*/
end_comment

begin_decl_stmt
name|int
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the lexical value; sloppy typing*/
end_comment

begin_decl_stmt
name|struct
name|Opcode
name|yyopcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lexical value for an opcode */
end_comment

begin_decl_stmt
name|Bignum
name|yybignum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lexical value for a big number */
end_comment

begin_comment
comment|/*  *	Expression and argument managers  */
end_comment

begin_decl_stmt
name|struct
name|exp
modifier|*
name|xp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*next free expression slot, used by expr.c*/
end_comment

begin_decl_stmt
name|struct
name|exp
name|explist
index|[
name|NEXP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*max of 20 expressions in one opcode*/
end_comment

begin_decl_stmt
name|struct
name|arg
name|arglist
index|[
name|NARG
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*building up operands in instructions*/
end_comment

begin_comment
comment|/*  *	Sets to accelerate token discrimination  */
end_comment

begin_decl_stmt
name|char
name|tokensets
index|[
operator|(
name|LASTTOKEN
operator|)
operator|-
operator|(
name|FIRSTTOKEN
operator|)
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|UDotsname
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*name of the assembly source*/
end_comment

begin_macro
name|yyparse
argument_list|()
end_macro

begin_block
block|{
name|reg
name|struct
name|exp
modifier|*
name|locxp
decl_stmt|;
comment|/* 		 *	loc1xp and ptrloc1xp are used in the 		 * 	expression lookahead 		 */
name|struct
name|exp
modifier|*
name|loc1xp
decl_stmt|;
comment|/*must be non register*/
name|struct
name|exp
modifier|*
modifier|*
name|ptrloc1xp
init|=
operator|&
name|loc1xp
decl_stmt|;
name|struct
name|exp
modifier|*
name|pval
decl_stmt|;
comment|/*hacking expr:expr*/
name|reg
name|struct
name|symtab
modifier|*
name|np
decl_stmt|;
name|reg
name|int
name|argcnt
decl_stmt|;
name|reg
name|inttoktype
name|val
decl_stmt|;
comment|/*what yylex gives*/
name|reg
name|inttoktype
name|auxval
decl_stmt|;
comment|/*saves val*/
name|reg
name|struct
name|arg
modifier|*
name|ap
decl_stmt|;
comment|/*first free argument*/
name|reg
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
name|reg
name|struct
name|symtab
modifier|*
name|stpt
decl_stmt|;
name|struct
name|strdesc
modifier|*
name|stringp
decl_stmt|;
comment|/*handles string lists*/
name|int
name|regno
decl_stmt|;
comment|/*handles arguments*/
name|int
modifier|*
name|ptrregno
init|=
operator|&
name|regno
decl_stmt|;
name|int
name|sawmul
decl_stmt|;
comment|/*saw * */
name|int
name|sawindex
decl_stmt|;
comment|/*saw [rn]*/
name|int
name|sawsize
decl_stmt|;
name|int
name|seg_type
decl_stmt|;
comment|/*the kind of segment: data or text*/
name|int
name|seg_number
decl_stmt|;
comment|/*the segment number*/
name|int
name|space_value
decl_stmt|;
comment|/*how much .space needs*/
name|int
name|fill_rep
decl_stmt|;
comment|/*how many reps for .fill */
name|int
name|fill_size
decl_stmt|;
comment|/*how many bytes for .fill */
name|int
name|field_width
decl_stmt|;
comment|/*how wide a field is to be*/
name|int
name|field_value
decl_stmt|;
comment|/*the value to stuff in a field*/
name|char
modifier|*
name|stabname
decl_stmt|;
comment|/*name of stab dealing with*/
name|ptrall
name|stabstart
decl_stmt|;
comment|/*where the stab starts in the buffer*/
name|int
name|reloc_how
decl_stmt|;
comment|/* how to relocate expressions */
name|int
name|toconv
decl_stmt|;
comment|/* how to convert bignums */
name|int
name|incasetable
decl_stmt|;
comment|/* set if in a case table */
name|incasetable
operator|=
literal|0
expr_stmt|;
name|xp
operator|=
name|explist
expr_stmt|;
name|ap
operator|=
name|arglist
expr_stmt|;
name|val
operator|=
name|yylex
argument_list|()
expr_stmt|;
while|while
condition|(
name|val
operator|!=
name|PARSEEOF
condition|)
block|{
comment|/* primary loop */
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|LINSTBEGIN
argument_list|)
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|INT
condition|)
block|{
name|int
name|i
init|=
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
operator|)
operator|->
name|e_xvalue
decl_stmt|;
name|shift
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|COLON
condition|)
block|{
name|yyerror
argument_list|(
literal|"Local label %d is not followed by a ':' for a label definition"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|errorfix
goto|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|9
condition|)
block|{
name|yyerror
argument_list|(
literal|"Local labels are 0-9"
argument_list|)
expr_stmt|;
goto|goto
name|errorfix
goto|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|yytext
argument_list|,
literal|"L%d\001%d"
argument_list|,
name|i
argument_list|,
name|lgensym
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lgensym
index|[
name|i
index|]
operator|++
expr_stmt|;
name|genref
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|yylval
operator|=
operator|(
name|int
operator|)
operator|*
name|lookup
argument_list|(
name|passno
operator|==
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|NAME
expr_stmt|;
name|np
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
goto|goto
name|restlab
goto|;
block|}
if|if
condition|(
name|val
operator|==
name|NL
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
name|SEMI
condition|)
name|shift
expr_stmt|;
else|else
block|{
comment|/*its a name, so we have a label or def */
if|if
condition|(
name|val
operator|!=
name|NAME
condition|)
block|{
name|ERROR
argument_list|(
literal|"Name expected for a label"
argument_list|)
expr_stmt|;
block|}
name|np
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|COLON
condition|)
block|{
name|yyerror
argument_list|(
literal|"\"%s\" is not followed by a ':' for a label definition"
argument_list|,
name|FETCHNAME
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|errorfix
goto|;
block|}
name|restlab
label|:
name|shift
expr_stmt|;
name|flushfield
argument_list|(
name|NBPW
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|->
name|s_type
operator|&
name|XTYPE
operator|)
operator|!=
name|XUNDEF
condition|)
block|{
if|if
condition|(
operator|(
name|np
operator|->
name|s_type
operator|&
name|XTYPE
operator|)
operator|!=
name|dotp
operator|->
name|e_xtype
operator|||
name|np
operator|->
name|s_value
operator|!=
name|dotp
operator|->
name|e_xvalue
operator|||
operator|(
name|passno
operator|==
literal|1
operator|&&
name|np
operator|->
name|s_index
operator|!=
name|dotp
operator|->
name|e_xloc
operator|)
condition|)
block|{
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
name|yyerror
argument_list|(
literal|"%s redefined"
argument_list|,
name|FETCHNAME
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|yyerror
argument_list|(
literal|"%s redefined: PHASE ERROR, 1st: %d, 2nd: %d"
argument_list|,
name|FETCHNAME
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|s_value
argument_list|,
name|dotp
operator|->
name|e_xvalue
argument_list|)
expr_stmt|;
block|}
block|}
name|np
operator|->
name|s_type
operator|&=
operator|~
operator|(
name|XTYPE
operator||
name|XFORW
operator|)
expr_stmt|;
name|np
operator|->
name|s_type
operator||=
name|dotp
operator|->
name|e_xtype
expr_stmt|;
name|np
operator|->
name|s_value
operator|=
name|dotp
operator|->
name|e_xvalue
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
name|np
operator|->
name|s_index
operator|=
name|dotp
operator|-
name|usedot
expr_stmt|;
if|if
condition|(
name|FETCHNAME
argument_list|(
name|np
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
block|{
name|nlabels
operator|++
expr_stmt|;
block|}
name|np
operator|->
name|s_tag
operator|=
name|LABELID
expr_stmt|;
block|}
block|}
comment|/*end of this being a label*/
block|}
comment|/*end of consuming all labels, NLs and SEMIS */
name|xp
operator|=
name|explist
expr_stmt|;
name|ap
operator|=
name|arglist
expr_stmt|;
comment|/* 	 *	process the INSTRUCTION body 	 */
switch|switch
condition|(
name|val
condition|)
block|{
default|default:
name|ERROR
argument_list|(
literal|"Unrecognized instruction or directive"
argument_list|)
expr_stmt|;
case|case
name|IABORT
case|:
name|shift
expr_stmt|;
name|sawabort
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
break|break;
case|case
name|PARSEEOF
case|:
name|tokptr
operator|-=
sizeof|sizeof
argument_list|(
name|bytetoktype
argument_list|)
expr_stmt|;
operator|*
name|tokptr
operator|++
operator|=
name|VOID
expr_stmt|;
name|tokptr
index|[
literal|1
index|]
operator|=
name|VOID
expr_stmt|;
name|tokptr
index|[
literal|2
index|]
operator|=
name|PARSEEOF
expr_stmt|;
break|break;
case|case
name|IFILE
case|:
name|shift
expr_stmt|;
name|stringp
operator|=
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|STRING
argument_list|)
expr_stmt|;
name|dotsname
operator|=
operator|&
name|UDotsname
index|[
literal|0
index|]
expr_stmt|;
name|movestr
argument_list|(
name|dotsname
argument_list|,
name|stringp
operator|->
name|sd_string
argument_list|,
name|min
argument_list|(
name|stringp
operator|->
name|sd_strlen
argument_list|,
sizeof|sizeof
argument_list|(
name|UDotsname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ILINENO
case|:
name|shift
expr_stmt|;
comment|/*over the ILINENO*/
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
break|break;
case|case
name|ISET
case|:
comment|/* .set<name> ,<expr> */
name|shift
expr_stmt|;
name|np
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|NAME
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|np
operator|->
name|s_type
operator|&=
operator|(
name|XXTRN
operator||
name|XFORW
operator|)
expr_stmt|;
name|np
operator|->
name|s_type
operator||=
name|locxp
operator|->
name|e_xtype
operator|&
operator|(
name|XTYPE
operator||
name|XFORW
operator|)
expr_stmt|;
name|np
operator|->
name|s_value
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
name|np
operator|->
name|s_index
operator|=
name|locxp
operator|->
name|e_xloc
expr_stmt|;
if|if
condition|(
operator|(
name|locxp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|==
name|XUNDEF
condition|)
name|yyerror
argument_list|(
literal|"Illegal set?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ILSYM
case|:
comment|/*.lsym name , expr */
name|shift
expr_stmt|;
name|np
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|NAME
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 	 *	Build the unique occurance of the 	 *	symbol. 	 *	The character scanner will have 	 *	already entered it into the symbol 	 *	table, but we should remove it 	 */
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
name|stpt
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|symalloc
argument_list|()
expr_stmt|;
name|stpt
operator|->
name|s_name
operator|=
name|np
operator|->
name|s_name
expr_stmt|;
name|np
operator|->
name|s_tag
operator|=
name|OBSOLETE
expr_stmt|;
comment|/*invalidate original */
name|nforgotten
operator|++
expr_stmt|;
name|np
operator|=
name|stpt
expr_stmt|;
if|if
condition|(
operator|(
name|locxp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|!=
name|XABS
condition|)
name|yyerror
argument_list|(
literal|"Illegal second argument to lsym"
argument_list|)
expr_stmt|;
name|np
operator|->
name|s_value
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
name|np
operator|->
name|s_type
operator|=
name|XABS
expr_stmt|;
name|np
operator|->
name|s_tag
operator|=
name|ILSYM
expr_stmt|;
block|}
break|break;
case|case
name|IGLOBAL
case|:
comment|/*.globl<name> */
name|shift
expr_stmt|;
name|np
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|NAME
argument_list|)
expr_stmt|;
name|np
operator|->
name|s_type
operator||=
name|XXTRN
expr_stmt|;
break|break;
case|case
name|IDATA
case|:
comment|/*.data [<expr> ] */
case|case
name|ITEXT
case|:
comment|/*.text [<expr> ] */
name|seg_type
operator|=
operator|-
name|val
expr_stmt|;
name|shift
expr_stmt|;
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|EBEGOPS
operator|+
name|YUKKYEXPRBEG
operator|+
name|SAFEEXPRBEG
argument_list|)
condition|)
block|{
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|seg_type
operator|=
operator|-
name|seg_type
expr_stmt|;
comment|/*now, it is positive*/
block|}
if|if
condition|(
name|seg_type
operator|<
literal|0
condition|)
block|{
comment|/*there wasn't an associated expr*/
name|seg_number
operator|=
literal|0
expr_stmt|;
name|seg_type
operator|=
operator|-
name|seg_type
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|locxp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|!=
name|XABS
operator|)
comment|/* tekmdp */
operator|||
operator|(
name|seg_number
operator|=
name|locxp
operator|->
name|e_xvalue
operator|)
operator|>=
name|NLOC
condition|)
block|{
name|yyerror
argument_list|(
literal|"illegal location counter"
argument_list|)
expr_stmt|;
name|seg_number
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|seg_type
operator|==
name|IDATA
condition|)
name|seg_number
operator|+=
name|NLOC
expr_stmt|;
name|flushfield
argument_list|(
name|NBPW
operator|/
literal|4
argument_list|)
expr_stmt|;
name|dotp
operator|=
operator|&
name|usedot
index|[
name|seg_number
index|]
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
block|{
comment|/* go salt away in pass 2*/
name|txtfil
operator|=
name|usefile
index|[
name|seg_number
index|]
expr_stmt|;
name|relfil
operator|=
name|rusefile
index|[
name|seg_number
index|]
expr_stmt|;
block|}
break|break;
comment|/* 	 *	Storage filler directives: 	 * 	 *	.byte	[<exprlist>] 	 * 	 *	exprlist:  empty | exprlist outexpr 	 *	outexpr:<expr> |<expr> :<expr> 	 */
case|case
name|IBYTE
case|:
name|curlen
operator|=
name|NBPW
operator|/
literal|4
expr_stmt|;
goto|goto
name|elist
goto|;
case|case
name|IWORD
case|:
name|curlen
operator|=
name|NBPW
operator|/
literal|2
expr_stmt|;
goto|goto
name|elist
goto|;
case|case
name|IINT
case|:
name|curlen
operator|=
name|NBPW
expr_stmt|;
goto|goto
name|elist
goto|;
case|case
name|ILONG
case|:
name|curlen
operator|=
name|NBPW
expr_stmt|;
goto|goto
name|elist
goto|;
name|elist
label|:
name|seg_type
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
comment|/* 	 *	Expression List processing 	 */
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|EBEGOPS
operator|+
name|YUKKYEXPRBEG
operator|+
name|SAFEEXPRBEG
argument_list|)
condition|)
block|{
do|do
block|{
comment|/* 		 *	expression list consists of a list of : 		 *<expr> 		 *<expr> :<expr>  		 *		(pack expr2 into expr1 bits 		 */
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 		 *	now, pointing at the next token 		 */
if|if
condition|(
name|val
operator|==
name|COLON
condition|)
block|{
name|shiftover
argument_list|(
name|COLON
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|pval
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|locxp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|!=
name|XABS
condition|)
comment|/* tekmdp */
name|yyerror
argument_list|(
literal|"Width not absolute"
argument_list|)
expr_stmt|;
name|field_width
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
name|locxp
operator|=
name|pval
expr_stmt|;
if|if
condition|(
name|bitoff
operator|+
name|field_width
operator|>
name|curlen
condition|)
name|flushfield
argument_list|(
name|curlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|field_width
operator|>
name|curlen
condition|)
name|yyerror
argument_list|(
literal|"Expression crosses field boundary"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|field_width
operator|=
name|curlen
expr_stmt|;
name|flushfield
argument_list|(
name|curlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|locxp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|!=
name|XABS
condition|)
block|{
if|if
condition|(
name|bitoff
condition|)
name|yyerror
argument_list|(
literal|"Illegal relocation in field"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|curlen
condition|)
block|{
case|case
name|NBPW
operator|/
literal|4
case|:
name|reloc_how
operator|=
name|TYPB
expr_stmt|;
break|break;
case|case
name|NBPW
operator|/
literal|2
case|:
name|reloc_how
operator|=
name|TYPW
expr_stmt|;
break|break;
case|case
name|NBPW
case|:
name|reloc_how
operator|=
name|TYPL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
name|dotp
operator|->
name|e_xvalue
operator|+=
name|ty_nbyte
index|[
name|reloc_how
index|]
expr_stmt|;
block|}
else|else
block|{
name|outrel
argument_list|(
name|locxp
argument_list|,
name|reloc_how
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 *	 			 *	See if we are doing a case instruction. 			 *	If so, then see if the branch distance, 			 *	stored as a word, 			 *	is going to loose sig bits. 			 */
if|if
condition|(
name|passno
operator|==
literal|2
operator|&&
name|incasetable
condition|)
block|{
if|if
condition|(
operator|(
name|locxp
operator|->
name|e_xvalue
operator|<
operator|-
literal|32768
operator|)
operator|||
operator|(
name|locxp
operator|->
name|e_xvalue
operator|>
literal|32767
operator|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"Case will branch too far"
argument_list|)
expr_stmt|;
block|}
block|}
name|field_value
operator|=
name|locxp
operator|->
name|e_xvalue
operator|&
operator|(
operator|(
literal|1L
operator|<<
name|field_width
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|bitfield
operator||=
name|field_value
operator|<<
name|bitoff
expr_stmt|;
name|bitoff
operator|+=
name|field_width
expr_stmt|;
block|}
name|xp
operator|=
name|explist
expr_stmt|;
if|if
condition|(
name|auxval
operator|=
operator|(
name|val
operator|==
name|CM
operator|)
condition|)
name|shift
expr_stmt|;
block|}
do|while
condition|(
name|auxval
condition|)
do|;
block|}
comment|/* there existed an expression at all */
name|flushfield
argument_list|(
name|curlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curlen
operator|==
name|NBPW
operator|/
literal|4
operator|)
operator|&&
name|bitoff
condition|)
name|dotp
operator|->
name|e_xvalue
operator|++
expr_stmt|;
break|break;
comment|/*end of case IBYTE, IWORD, ILONG, IINT*/
case|case
name|ISPACE
case|:
comment|/* .space<expr> */
name|shift
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|locxp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|!=
name|XABS
condition|)
comment|/* tekmdp */
name|yyerror
argument_list|(
literal|"Space size not absolute"
argument_list|)
expr_stmt|;
name|space_value
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
name|ospace
label|:
name|flushfield
argument_list|(
name|NBPW
operator|/
literal|4
argument_list|)
expr_stmt|;
block|{
specifier|static
name|char
name|spacebuf
index|[
literal|128
index|]
decl_stmt|;
while|while
condition|(
name|space_value
operator|>
sizeof|sizeof
argument_list|(
name|spacebuf
argument_list|)
condition|)
block|{
name|outs
argument_list|(
name|spacebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|spacebuf
argument_list|)
argument_list|)
expr_stmt|;
name|space_value
operator|-=
sizeof|sizeof
argument_list|(
name|spacebuf
argument_list|)
expr_stmt|;
block|}
name|outs
argument_list|(
name|spacebuf
argument_list|,
name|space_value
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 *	.fill rep, size, value 	 *	repeat rep times: fill size bytes with (truncated) value 	 *	size must be between 1 and 8 	 */
case|case
name|IFILL
case|:
name|shift
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|locxp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|!=
name|XABS
condition|)
comment|/* tekmdp */
name|yyerror
argument_list|(
literal|"Fill repetition count not absolute"
argument_list|)
expr_stmt|;
name|fill_rep
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|locxp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|!=
name|XABS
condition|)
comment|/* tekmdp */
name|yyerror
argument_list|(
literal|"Fill size not absolute"
argument_list|)
expr_stmt|;
name|fill_size
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
if|if
condition|(
name|fill_size
operator|<=
literal|0
operator|||
name|fill_size
operator|>
literal|8
condition|)
name|yyerror
argument_list|(
literal|"Fill count not in in 1..8"
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
operator|&&
operator|(
name|locxp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|!=
name|XABS
condition|)
comment|/* tekmdp */
name|yyerror
argument_list|(
literal|"Fill value not absolute"
argument_list|)
expr_stmt|;
name|flushfield
argument_list|(
name|NBPW
operator|/
literal|4
argument_list|)
expr_stmt|;
name|dotp
operator|->
name|e_xvalue
operator|+=
name|fill_rep
operator|*
name|fill_size
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
block|{
while|while
condition|(
name|fill_rep
operator|--
operator|>
literal|0
condition|)
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|locxp
operator|->
name|e_xvalue
argument_list|,
name|fill_size
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IASCII
case|:
comment|/* .ascii [<stringlist> ] */
case|case
name|IASCIZ
case|:
comment|/* .asciz [<stringlist> ] */
name|auxval
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
comment|/* 	 *	Code to consume a string list 	 * 	 *	stringlist: empty | STRING | stringlist STRING 	 */
while|while
condition|(
name|val
operator|==
name|STRING
condition|)
block|{
name|int
name|mystrlen
decl_stmt|;
name|flushfield
argument_list|(
name|NBPW
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitoff
condition|)
name|dotp
operator|->
name|e_xvalue
operator|++
expr_stmt|;
name|stringp
operator|=
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
expr_stmt|;
comment|/* 		 *	utilize the string scanner cheat; 		 *	the scanner appended a null byte on the string, 		 *	but didn't charge it to sd_strlen 		 */
name|mystrlen
operator|=
name|stringp
operator|->
name|sd_strlen
expr_stmt|;
name|mystrlen
operator|+=
operator|(
name|auxval
operator|==
name|IASCIZ
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|stringp
operator|->
name|sd_place
operator|&
name|STR_CORE
condition|)
block|{
name|outs
argument_list|(
name|stringp
operator|->
name|sd_string
argument_list|,
name|mystrlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|,
name|nread
decl_stmt|;
name|fseek
argument_list|(
name|strfile
argument_list|,
name|stringp
operator|->
name|sd_stroff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mystrlen
condition|;
comment|/*VOID*/
control|)
block|{
name|nread
operator|=
name|fread
argument_list|(
name|yytext
argument_list|,
literal|1
argument_list|,
name|min
argument_list|(
name|mystrlen
operator|-
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|yytext
argument_list|)
argument_list|)
argument_list|,
name|strfile
argument_list|)
expr_stmt|;
name|outs
argument_list|(
name|yytext
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|i
operator|+=
name|nread
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|dotp
operator|->
name|e_xvalue
operator|+=
name|mystrlen
expr_stmt|;
block|}
name|shift
expr_stmt|;
comment|/*over the STRING*/
if|if
condition|(
name|val
operator|==
name|CM
condition|)
comment|/*could be a split string*/
name|shift
expr_stmt|;
block|}
break|break;
case|case
name|IORG
case|:
comment|/* .org<expr> */
name|shift
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|locxp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|==
name|XABS
condition|)
comment|/* tekmdp */
name|orgwarn
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|locxp
operator|->
name|e_xtype
operator|&
operator|~
name|XXTRN
operator|)
operator|!=
name|dotp
operator|->
name|e_xtype
condition|)
name|yyerror
argument_list|(
literal|"Illegal expression to set origin"
argument_list|)
expr_stmt|;
name|space_value
operator|=
name|locxp
operator|->
name|e_xvalue
operator|-
name|dotp
operator|->
name|e_xvalue
expr_stmt|;
if|if
condition|(
name|space_value
operator|<
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Backwards 'org'"
argument_list|)
expr_stmt|;
goto|goto
name|ospace
goto|;
break|break;
comment|/*  *  *	Process stabs.  Stabs are created only by the f77  *	and the C compiler with the -g flag set.  *	We only look at the stab ONCE, during pass 1, and  *	virtually remove the stab from the intermediate file  *	so it isn't seen during pass2.  This makes for some  *	hairy processing to handle labels occuring in  *	stab entries, but since most expressions in the  *	stab are integral we save lots of time in the second  *	pass by not looking at the stabs.  *	A stab that is tagged floating will be bumped during  *	the jxxx resolution phase.  A stab tagged fixed will  *	not be be bumped.  *  *	.stab:	Old fashioned stabs  *	.stabn: For stabs without names  *	.stabs:	For stabs with string names  *	.stabd: For stabs for line numbers or bracketing,  *		without a string name, without  *		a final expression.  The value of the  *		final expression is taken to be  the current  *		location counter, and is patched by the 2nd pass  *  *	.stab{<expr>,}*NCPName,<expr>,<expr>,<expr>,<expr>  *	.stabn<expr>,<expr>,<expr>,<expr>  *	.stabs   STRING,<expr>,<expr>,<expr>,<expr>  *	.stabd<expr>,<expr>,<expr> # .   */
case|case
name|ISTAB
case|:
name|yyerror
argument_list|(
literal|".stab directive no longer supported"
argument_list|)
expr_stmt|;
goto|goto
name|errorfix
goto|;
name|tailstab
label|:
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|locxp
operator|->
name|e_xvalue
operator|&
name|STABTYPS
operator|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"Invalid type in %s"
argument_list|,
name|stabname
argument_list|)
expr_stmt|;
goto|goto
name|errorfix
goto|;
block|}
name|stpt
operator|->
name|s_ptype
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|stpt
operator|->
name|s_other
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|stpt
operator|->
name|s_desc
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|exprisname
operator|=
literal|0
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|p
operator|=
name|locxp
operator|->
name|e_xname
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/*absolute expr to begin with*/
name|stpt
operator|->
name|s_value
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
name|stpt
operator|->
name|s_index
operator|=
name|dotp
operator|-
name|usedot
expr_stmt|;
if|if
condition|(
name|exprisname
condition|)
block|{
switch|switch
condition|(
name|stpt
operator|->
name|s_ptype
condition|)
block|{
case|case
name|N_GSYM
case|:
case|case
name|N_FNAME
case|:
case|case
name|N_RSYM
case|:
case|case
name|N_SSYM
case|:
case|case
name|N_LSYM
case|:
case|case
name|N_PSYM
case|:
case|case
name|N_BCOMM
case|:
case|case
name|N_ECOMM
case|:
case|case
name|N_LENG
case|:
name|stpt
operator|->
name|s_tag
operator|=
name|STABFIXED
expr_stmt|;
break|break;
default|default:
name|stpt
operator|->
name|s_tag
operator|=
name|STABFLOATING
expr_stmt|;
break|break;
block|}
block|}
else|else
name|stpt
operator|->
name|s_tag
operator|=
name|STABFIXED
expr_stmt|;
block|}
else|else
block|{
comment|/*really have a name*/
name|stpt
operator|->
name|s_dest
operator|=
name|locxp
operator|->
name|e_xname
expr_stmt|;
name|stpt
operator|->
name|s_index
operator|=
name|p
operator|->
name|s_index
expr_stmt|;
name|stpt
operator|->
name|s_type
operator|=
name|p
operator|->
name|s_type
operator||
name|STABFLAG
expr_stmt|;
comment|/* 		 *	We will assign a more accruate 		 *	guess of locxp's location when 		 *	we sort the symbol table 		 *	The final value of value is 		 *	given by stabfix() 		 */
comment|/*  * For exprs of the form (name + value) one needs to remember locxp->e_xvalue  * for use in stabfix. The right place to keep this is in stpt->s_value  * however this gets corrupted at an unknown point.  * As a bandaid hack the value is preserved in s_desc and s_other (a  * short and a char). This destroys these two values and will  * be fixed. May 19 ,1983 Alastair Fyfe  */
if|if
condition|(
name|locxp
operator|->
name|e_xvalue
condition|)
block|{
name|stpt
operator|->
name|s_other
operator|=
operator|(
name|locxp
operator|->
name|e_xvalue
operator|>>
literal|16
operator|)
expr_stmt|;
name|stpt
operator|->
name|s_desc
operator|=
operator|(
name|locxp
operator|->
name|e_xvalue
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
name|stpt
operator|->
name|s_tag
operator|=
name|STABFLOATING
expr_stmt|;
block|}
block|}
comment|/* 	 *	tokptr now points at one token beyond 	 *	the current token stored in val and yylval, 	 *	which are the next tokens after the end of 	 *	this .stab directive.  This next token must 	 *	be either a SEMI or NL, so is of width just 	 *	one.  Therefore, to point to the next token 	 *	after the end of this stab, just back up one.. 	 */
name|buildskip
argument_list|(
name|stabstart
argument_list|,
operator|(
name|bytetoktype
operator|*
operator|)
name|tokptr
operator|-
sizeof|sizeof
argument_list|(
name|bytetoktype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/*end of the .stab*/
case|case
name|ISTABDOT
case|:
name|stabname
operator|=
literal|".stabd"
expr_stmt|;
name|stpt
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
comment|/* 	 *	We clobber everything after the 	 *	.stabd and its pointer... we MUST 	 *	be able to get back to this .stabd 	 *	so that we can resolve its final value 	 */
name|stabstart
operator|=
name|tokptr
expr_stmt|;
name|shift
expr_stmt|;
comment|/*over the ISTABDOT*/
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|locxp
operator|->
name|e_xvalue
operator|&
name|STABTYPS
operator|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"Invalid type in .stabd"
argument_list|)
expr_stmt|;
goto|goto
name|errorfix
goto|;
block|}
name|stpt
operator|->
name|s_ptype
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|stpt
operator|->
name|s_other
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|stpt
operator|->
name|s_desc
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
comment|/* 		 * 		 *	Now, clobber everything but the 		 *	.stabd pseudo and the pointer 		 *	to its symbol table entry 		 *	tokptr points to the next token, 		 *	build the skip up to this 		 */
name|buildskip
argument_list|(
name|stabstart
argument_list|,
operator|(
name|bytetoktype
operator|*
operator|)
name|tokptr
operator|-
sizeof|sizeof
argument_list|(
name|bytetoktype
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	pass 1:	Assign a good guess for its position 	 *		(ensures they are sorted into right place)/ 	 *	pass 2:	Fix the actual value 	 */
name|stpt
operator|->
name|s_value
operator|=
name|dotp
operator|->
name|e_xvalue
expr_stmt|;
name|stpt
operator|->
name|s_index
operator|=
name|dotp
operator|-
name|usedot
expr_stmt|;
name|stpt
operator|->
name|s_tag
operator|=
name|STABFLOATING
expr_stmt|;
comment|/*although it has no effect in pass 2*/
break|break;
case|case
name|ISTABNONE
case|:
name|stabname
operator|=
literal|".stabn"
expr_stmt|;
goto|goto
name|shortstab
goto|;
case|case
name|ISTABSTR
case|:
name|stabname
operator|=
literal|".stabs"
expr_stmt|;
name|shortstab
label|:
name|auxval
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
goto|goto
name|errorfix
goto|;
name|stpt
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|stabstart
operator|=
name|tokptr
expr_stmt|;
operator|(
name|bytetoktype
operator|*
operator|)
name|stabstart
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|symtab
operator|*
argument_list|)
expr_stmt|;
operator|(
name|bytetoktype
operator|*
operator|)
name|stabstart
operator|-=
sizeof|sizeof
argument_list|(
name|bytetoktype
argument_list|)
expr_stmt|;
name|shift
expr_stmt|;
if|if
condition|(
name|auxval
operator|==
name|ISTABSTR
condition|)
block|{
name|stringp
operator|=
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|STRING
argument_list|)
expr_stmt|;
name|stpt
operator|->
name|s_name
operator|=
operator|(
name|char
operator|*
operator|)
name|stringp
expr_stmt|;
comment|/* 		 *	We want the trailing null included in this string. 		 *	We utilize the cheat the string scanner used, 		 *	and merely increment the string length 		 */
name|stringp
operator|->
name|sd_strlen
operator|+=
literal|1
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stpt
operator|->
name|s_name
operator|=
operator|(
name|char
operator|*
operator|)
name|savestr
argument_list|(
literal|"\0"
argument_list|,
literal|0
argument_list|,
name|STR_BOTH
argument_list|)
expr_stmt|;
block|}
goto|goto
name|tailstab
goto|;
break|break;
case|case
name|ICOMM
case|:
comment|/* .comm<name> ,<expr> */
case|case
name|ILCOMM
case|:
comment|/* .lcomm<name> ,<expr> */
name|auxval
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|np
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|NAME
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|locxp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|!=
name|XABS
condition|)
comment|/* tekmdp */
name|yyerror
argument_list|(
literal|"comm size not absolute"
argument_list|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
operator|&&
operator|(
name|np
operator|->
name|s_type
operator|&
name|XTYPE
operator|)
operator|!=
name|XUNDEF
condition|)
name|yyerror
argument_list|(
literal|"Redefinition of %s"
argument_list|,
name|FETCHNAME
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
name|np
operator|->
name|s_value
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
if|if
condition|(
name|auxval
operator|==
name|ICOMM
condition|)
name|np
operator|->
name|s_type
operator||=
name|XXTRN
expr_stmt|;
else|else
block|{
name|np
operator|->
name|s_type
operator|&=
operator|~
name|XTYPE
expr_stmt|;
name|np
operator|->
name|s_type
operator||=
name|XBSS
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IALIGN
case|:
comment|/* .align<expr> */
name|stpt
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|shift
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|jalign
argument_list|(
name|locxp
argument_list|,
name|stpt
argument_list|)
expr_stmt|;
break|break;
case|case
name|INST0
case|:
comment|/* instructions w/o arguments*/
name|incasetable
operator|=
literal|0
expr_stmt|;
name|insout
argument_list|(
name|yyopcode
argument_list|,
operator|(
expr|struct
name|arg
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|shift
expr_stmt|;
break|break;
case|case
name|INSTn
case|:
comment|/* instructions with arguments*/
case|case
name|IJXXX
case|:
comment|/* UNIX style jump instructions */
name|auxval
operator|=
name|val
expr_stmt|;
comment|/* 	 *	Code to process an argument list 	 */
name|ap
operator|=
name|arglist
expr_stmt|;
name|xp
operator|=
name|explist
expr_stmt|;
name|shift
expr_stmt|;
comment|/* bring in the first token for the arg list*/
for|for
control|(
name|argcnt
operator|=
literal|1
init|;
name|argcnt
operator|<=
literal|6
condition|;
name|argcnt
operator|++
operator|,
name|ap
operator|++
control|)
block|{
comment|/* 		 *	code to process an argument proper 		 */
name|sawindex
operator|=
name|sawmul
operator|=
name|sawsize
operator|=
literal|0
expr_stmt|;
block|{
switch|switch
condition|(
name|val
condition|)
block|{
default|default:
name|disp
label|:
if|if
condition|(
operator|!
operator|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|EBEGOPS
operator|+
name|YUKKYEXPRBEG
operator|+
name|SAFEEXPRBEG
argument_list|)
operator|)
condition|)
block|{
name|ERROR
argument_list|(
literal|"expression expected"
argument_list|)
expr_stmt|;
block|}
name|expr
argument_list|(
name|ap
operator|->
name|a_xp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|overdisp
label|:
if|if
condition|(
name|val
operator|==
name|LP
operator|||
name|sawsize
condition|)
block|{
name|shiftover
argument_list|(
name|LP
argument_list|)
expr_stmt|;
name|findreg
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|RP
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_atype
operator|=
name|ADISP
expr_stmt|;
name|ap
operator|->
name|a_areg1
operator|=
name|regno
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|->
name|a_atype
operator|=
name|AEXP
expr_stmt|;
name|ap
operator|->
name|a_areg1
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|index
goto|;
case|case
name|SIZESPEC
case|:
name|sizespec
label|:
name|sawsize
operator|=
name|yylval
expr_stmt|;
name|shift
expr_stmt|;
goto|goto
name|disp
goto|;
case|case
name|REG
case|:
case|case
name|REGOP
case|:
name|findreg
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_atype
operator|=
name|AREG
expr_stmt|;
name|ap
operator|->
name|a_areg1
operator|=
name|regno
expr_stmt|;
break|break;
case|case
name|MUL
case|:
name|sawmul
operator|=
literal|1
expr_stmt|;
name|shift
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|LP
condition|)
goto|goto
name|base
goto|;
if|if
condition|(
name|val
operator|==
name|LITOP
condition|)
goto|goto
name|imm
goto|;
if|if
condition|(
name|val
operator|==
name|SIZESPEC
condition|)
goto|goto
name|sizespec
goto|;
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|EBEGOPS
operator|+
name|YUKKYEXPRBEG
operator|+
name|SAFEEXPRBEG
argument_list|)
condition|)
goto|goto
name|disp
goto|;
name|ERROR
argument_list|(
literal|"expression, '(' or '$' expected"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LP
case|:
name|base
label|:
name|shift
expr_stmt|;
comment|/*consume the LP*/
comment|/* 			 *	hack the ambiguity of 			 *	movl (expr) (rn), ... 			 *	note that (expr) could also 			 *	be (rn) (by special hole in the 			 *	grammar), which we ensure 			 *	means register indirection, instead 			 *	of an expression with value n 			 */
if|if
condition|(
name|val
operator|!=
name|REG
operator|&&
name|val
operator|!=
name|REGOP
condition|)
block|{
name|droppedLP
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|exprparse
argument_list|(
name|val
argument_list|,
operator|&
operator|(
name|ap
operator|->
name|a_xp
operator|)
argument_list|)
expr_stmt|;
name|droppedLP
operator|=
literal|0
expr_stmt|;
goto|goto
name|overdisp
goto|;
block|}
name|findreg
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|RP
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|PLUS
condition|)
block|{
name|shift
expr_stmt|;
name|ap
operator|->
name|a_atype
operator|=
name|AINCR
expr_stmt|;
block|}
else|else
name|ap
operator|->
name|a_atype
operator|=
name|ABASE
expr_stmt|;
name|ap
operator|->
name|a_areg1
operator|=
name|regno
expr_stmt|;
goto|goto
name|index
goto|;
case|case
name|LITOP
case|:
name|imm
label|:
name|shift
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_atype
operator|=
name|AIMM
expr_stmt|;
name|ap
operator|->
name|a_areg1
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|a_xp
operator|=
name|locxp
expr_stmt|;
goto|goto
name|index
goto|;
case|case
name|MP
case|:
name|shift
expr_stmt|;
comment|/* -(reg) */
name|findreg
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|RP
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_atype
operator|=
name|ADECR
expr_stmt|;
name|ap
operator|->
name|a_areg1
operator|=
name|regno
expr_stmt|;
name|index
label|:
comment|/*look for [reg] */
if|if
condition|(
name|val
operator|==
name|LB
condition|)
block|{
name|shift
expr_stmt|;
name|findreg
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|RB
argument_list|)
expr_stmt|;
name|sawindex
operator|=
literal|1
expr_stmt|;
name|ap
operator|->
name|a_areg2
operator|=
name|regno
expr_stmt|;
block|}
break|break;
block|}
comment|/*end of the switch to process an arg*/
block|}
comment|/*end of processing an argument*/
if|if
condition|(
name|sawmul
condition|)
block|{
comment|/* 			 * Make a concession for *(%r) 			 * meaning *0(%r)  			 */
if|if
condition|(
name|ap
operator|->
name|a_atype
operator|==
name|ABASE
condition|)
block|{
name|ap
operator|->
name|a_atype
operator|=
name|ADISP
expr_stmt|;
name|xp
operator|->
name|e_xtype
operator|=
name|XABS
expr_stmt|;
name|xp
operator|->
name|e_number
operator|=
name|Znumber
expr_stmt|;
name|xp
operator|->
name|e_number
operator|.
name|num_tag
operator|=
name|TYPL
expr_stmt|;
name|xp
operator|->
name|e_xloc
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|a_xp
operator|=
name|xp
operator|++
expr_stmt|;
block|}
name|ap
operator|->
name|a_atype
operator||=
name|ASTAR
expr_stmt|;
name|sawmul
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sawindex
condition|)
block|{
name|ap
operator|->
name|a_atype
operator||=
name|AINDX
expr_stmt|;
name|sawindex
operator|=
literal|0
expr_stmt|;
block|}
name|ap
operator|->
name|a_dispsize
operator|=
name|sawsize
operator|==
literal|0
condition|?
name|d124
else|:
name|sawsize
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|CM
condition|)
break|break;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
block|}
comment|/*processing all the arguments*/
if|if
condition|(
name|argcnt
operator|>
literal|6
condition|)
block|{
name|yyerror
argument_list|(
literal|"More than 6 arguments"
argument_list|)
expr_stmt|;
goto|goto
name|errorfix
goto|;
block|}
comment|/* 	 *	See if this is a case instruction, 	 *	so we can set up tests on the following 	 *	vector of branch displacements 	 */
if|if
condition|(
name|yyopcode
operator|.
name|Op_eopcode
operator|==
name|CORE
condition|)
block|{
switch|switch
condition|(
name|yyopcode
operator|.
name|Op_popcode
condition|)
block|{
case|case
literal|0x8f
case|:
comment|/* caseb */
case|case
literal|0xaf
case|:
comment|/* casew */
case|case
literal|0xcf
case|:
comment|/* casel */
name|incasetable
operator|++
expr_stmt|;
break|break;
default|default:
name|incasetable
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|insout
argument_list|(
name|yyopcode
argument_list|,
name|arglist
argument_list|,
name|auxval
operator|==
name|INSTn
condition|?
name|argcnt
else|:
operator|-
name|argcnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IQUAD
case|:
name|toconv
operator|=
name|TYPQ
expr_stmt|;
goto|goto
name|bignumlist
goto|;
case|case
name|IOCTA
case|:
name|toconv
operator|=
name|TYPO
expr_stmt|;
goto|goto
name|bignumlist
goto|;
case|case
name|IFFLOAT
case|:
name|toconv
operator|=
name|TYPF
expr_stmt|;
goto|goto
name|bignumlist
goto|;
case|case
name|IDFLOAT
case|:
name|toconv
operator|=
name|TYPD
expr_stmt|;
goto|goto
name|bignumlist
goto|;
case|case
name|IGFLOAT
case|:
name|toconv
operator|=
name|TYPG
expr_stmt|;
goto|goto
name|bignumlist
goto|;
case|case
name|IHFLOAT
case|:
name|toconv
operator|=
name|TYPH
expr_stmt|;
goto|goto
name|bignumlist
goto|;
name|bignumlist
label|:
comment|/* 	 *	eat a list of non 32 bit numbers. 	 *	IQUAD and IOCTA can, possibly, return 	 *	INT's, if the numbers are "small". 	 * 	 *	The value of the numbers is coming back 	 *	as an expression, NOT in yybignum. 	 */
name|shift
expr_stmt|;
comment|/* over the opener */
if|if
condition|(
operator|(
name|val
operator|==
name|BIGNUM
operator|)
operator|||
operator|(
name|val
operator|==
name|INT
operator|)
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|(
name|val
operator|!=
name|BIGNUM
operator|)
operator|&&
operator|(
name|val
operator|!=
name|INT
operator|)
condition|)
block|{
name|ERROR
argument_list|(
name|ty_float
index|[
name|toconv
index|]
condition|?
literal|"floating number expected"
else|:
literal|"integer number expected"
argument_list|)
expr_stmt|;
block|}
name|dotp
operator|->
name|e_xvalue
operator|+=
name|ty_nbyte
index|[
name|toconv
index|]
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
block|{
name|bignumwrite
argument_list|(
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
operator|)
operator|->
name|e_number
argument_list|,
name|toconv
argument_list|)
expr_stmt|;
block|}
name|xp
operator|=
name|explist
expr_stmt|;
name|shift
expr_stmt|;
comment|/* over this number */
if|if
condition|(
name|auxval
operator|=
operator|(
name|val
operator|==
name|CM
operator|)
condition|)
name|shift
expr_stmt|;
comment|/* over the comma */
block|}
do|while
condition|(
name|auxval
condition|)
do|;
comment|/* as long as there are commas */
block|}
break|break;
comment|/* end of the case for initialized big numbers */
block|}
comment|/*end of the switch for looking at each reserved word*/
continue|continue;
name|errorfix
label|:
comment|/* 	 *	got here by either requesting to skip to the 	 *	end of this statement, or by erroring out and 	 *	wanting to apply panic mode recovery 	 */
while|while
condition|(
operator|(
name|val
operator|!=
name|NL
operator|)
operator|&&
operator|(
name|val
operator|!=
name|SEMI
operator|)
operator|&&
operator|(
name|val
operator|!=
name|PARSEEOF
operator|)
condition|)
block|{
name|shift
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
name|NL
condition|)
name|lineno
operator|++
expr_stmt|;
name|shift
expr_stmt|;
block|}
comment|/*end of the loop to read the entire file, line by line*/
block|}
end_block

begin_comment
comment|/*end of yyparse*/
end_comment

begin_comment
comment|/*  *	Process a register declaration of the form  *	%<expr>  *  *	Note:  *		The scanner has already processed funny registers of the form  *	%dd[+-]*, where dd is a decimal number in the range 00 to 15 (optional  *	preceding zero digit).  If there was any space between the % and  *	the digit, the scanner wouldn't have recognized it, so we  *	hack it out here.  */
end_comment

begin_function
name|inttoktype
name|funnyreg
parameter_list|(
name|val
parameter_list|,
name|regnoback
parameter_list|)
comment|/*what the read head will sit on*/
name|inttoktype
name|val
decl_stmt|;
comment|/*what the read head is sitting on*/
name|int
modifier|*
name|regnoback
decl_stmt|;
comment|/*call by return*/
block|{
name|reg
name|struct
name|exp
modifier|*
name|locxp
decl_stmt|;
name|struct
name|exp
modifier|*
name|loc1xp
decl_stmt|;
name|struct
name|exp
modifier|*
modifier|*
name|ptrloc1xp
init|=
operator|&
name|loc1xp
decl_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/*and leave the current read head with value*/
if|if
condition|(
operator|(
name|passno
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|locxp
operator|->
name|e_xtype
operator|&
name|XTYPE
operator|)
operator|!=
name|XABS
operator|||
operator|(
name|locxp
operator|->
name|e_xvalue
operator|<
literal|0
operator|)
operator|||
operator|(
name|locxp
operator|->
name|e_xvalue
operator|>=
literal|16
operator|)
operator|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"Illegal register"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|regnoback
operator|=
name|locxp
operator|->
name|e_xvalue
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Shift over error  */
end_comment

begin_macro
name|shiftoerror
argument_list|(
argument|token
argument_list|)
end_macro

begin_decl_stmt
name|int
name|token
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|tok_to_name
parameter_list|()
function_decl|;
name|yyerror
argument_list|(
literal|"%s expected"
argument_list|,
name|tok_to_name
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|yyerror
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|sink
value|stdout
if|if
condition|(
name|anyerrs
operator|==
literal|0
operator|&&
name|anywarnings
operator|==
literal|0
operator|&&
operator|!
name|silent
condition|)
name|fprintf
argument_list|(
name|sink
argument_list|,
literal|"Assembler:\n"
argument_list|)
expr_stmt|;
name|anyerrs
operator|++
expr_stmt|;
if|if
condition|(
name|silent
condition|)
return|return;
name|fprintf
argument_list|(
name|sink
argument_list|,
literal|"\"%s\", line %d: "
argument_list|,
name|dotsname
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sink
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sink
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|sink
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|yywarning
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|sink
value|stdout
if|if
condition|(
name|anyerrs
operator|==
literal|0
operator|&&
name|anywarnings
operator|==
literal|0
operator|&&
operator|!
name|silent
condition|)
name|fprintf
argument_list|(
name|sink
argument_list|,
literal|"Assembler:\n"
argument_list|)
expr_stmt|;
name|anywarnings
operator|++
expr_stmt|;
if|if
condition|(
name|silent
condition|)
return|return;
name|fprintf
argument_list|(
name|sink
argument_list|,
literal|"\"%s\", line %d: WARNING: "
argument_list|,
name|dotsname
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sink
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sink
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|sink
block|}
end_block

end_unit

