begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)update.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * update: the key output optimization routine of the whole editor.  * The input consists of two bit matrices (mold is what's on the screen,  * mnew is what we want to be on the screen) and the coordinates of  * the lower left corner on the screen where this matrix is.  * This routine does whatever is necessary to get the screen to look  * like mnew, assuming that it currently looks like mold.  *  * (If I could patent this process for bread and other food I  * would be a rich man.)  */
end_comment

begin_include
include|#
directive|include
file|"bit.h"
end_include

begin_macro
name|update
argument_list|(
argument|mold
argument_list|,
argument|mnew
argument_list|,
argument|rows
argument_list|,
argument|cols
argument_list|,
argument|baser
argument_list|,
argument|basec
argument_list|)
end_macro

begin_decl_stmt
name|bitmat
name|mold
decl_stmt|,
name|mnew
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|,
name|baser
decl_stmt|,
name|basec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|irow
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|nr1
decl_stmt|,
name|nr2
decl_stmt|,
name|nc1
decl_stmt|,
name|nc2
decl_stmt|;
specifier|extern
name|int
name|QUIET
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"update(mold=%x, mnew=%x, rows=%d, cols=%d, baser=%d, basec=%d)\n"
argument_list|,
name|mold
argument_list|,
name|mnew
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
name|baser
argument_list|,
name|basec
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|QUIET
condition|)
return|return;
name|aminmax
argument_list|(
name|mold
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|c1
argument_list|,
operator|&
name|r2
argument_list|,
operator|&
name|c2
argument_list|)
expr_stmt|;
name|aminmax
argument_list|(
name|mnew
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
operator|&
name|nr1
argument_list|,
operator|&
name|nc1
argument_list|,
operator|&
name|nr2
argument_list|,
operator|&
name|nc2
argument_list|)
expr_stmt|;
name|r1
operator|=
name|min
argument_list|(
name|r1
argument_list|,
name|nr1
argument_list|)
expr_stmt|;
name|r2
operator|=
name|max
argument_list|(
name|r2
argument_list|,
name|nr2
argument_list|)
expr_stmt|;
name|c1
operator|=
name|min
argument_list|(
name|c1
argument_list|,
name|nc1
argument_list|)
expr_stmt|;
name|c2
operator|=
name|max
argument_list|(
name|c2
argument_list|,
name|nc2
argument_list|)
expr_stmt|;
name|dumpmat
argument_list|(
literal|"mold:"
argument_list|,
name|mold
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|)
expr_stmt|;
name|dumpmat
argument_list|(
literal|"mnew:"
argument_list|,
name|mnew
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|r1
init|;
name|i
operator|<=
name|r2
condition|;
name|i
operator|++
control|)
block|{
name|irow
operator|=
name|baser
operator|+
name|rows
operator|-
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|emptyrow
argument_list|(
name|mnew
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|emptyrow
argument_list|(
name|mold
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
name|i
argument_list|)
condition|)
block|{
continue|continue;
comment|/* identically blank. skip. */
block|}
comment|/* 			 * Row i is to be cleared.  Look for some more 			 * rows to clear and do it all at once. 			 */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|rows
operator|&&
name|emptyrow
argument_list|(
name|mnew
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
name|j
argument_list|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
name|areaclear
argument_list|(
name|baser
operator|+
name|rows
operator|-
name|j
argument_list|,
name|basec
argument_list|,
name|irow
argument_list|,
name|basec
operator|+
name|cols
operator|-
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|j
operator|-
literal|1
expr_stmt|;
comment|/* skip the others */
block|}
else|else
for|for
control|(
name|j
operator|=
name|c1
init|;
name|j
operator|<=
name|c2
condition|;
name|j
operator|++
control|)
block|{
comment|/* 			 * Result row is not all blank.  We look for stretches 			 * of bits that have to be changed (in either 			 * direction) and draw an exclusive or line over all 			 * the bits in each stretch. 			 */
if|if
condition|(
name|mat
argument_list|(
name|mold
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
literal|1
argument_list|)
operator|!=
name|mat
argument_list|(
name|mnew
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
literal|2
argument_list|)
condition|)
block|{
for|for
control|(
name|k
operator|=
name|j
operator|+
literal|1
init|;
name|k
operator|<
name|cols
operator|&&
name|mat
argument_list|(
name|mold
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
name|i
argument_list|,
name|k
argument_list|,
literal|3
argument_list|)
operator|!=
name|mat
argument_list|(
name|mnew
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
name|i
argument_list|,
name|k
argument_list|,
literal|4
argument_list|)
condition|;
name|k
operator|++
control|)
empty_stmt|;
name|k
operator|--
expr_stmt|;
name|setxor
argument_list|()
expr_stmt|;
name|line
argument_list|(
name|basec
operator|+
name|j
argument_list|,
name|irow
argument_list|,
name|basec
operator|+
name|k
argument_list|,
name|irow
argument_list|)
expr_stmt|;
name|j
operator|=
name|k
expr_stmt|;
comment|/* skip the others */
block|}
block|}
block|}
block|}
end_block

end_unit

