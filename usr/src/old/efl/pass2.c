begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"defs"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|indent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|verb
index|[]
init|=
block|{
literal|" "
block|,
literal|" "
block|,
literal|"continue"
block|,
literal|"call "
block|,
literal|"do "
block|,
literal|"if "
block|,
literal|"if "
block|,
literal|"goto "
block|,
literal|"return"
block|,
literal|"read "
block|,
literal|"write "
block|,
literal|"format "
block|,
literal|"stop "
block|,
literal|"data "
block|,
literal|"equivalence "
block|,
literal|"common "
block|,
literal|"external "
block|,
literal|"rewind"
block|,
literal|"backspace"
block|,
literal|"endfile"
block|,
literal|"subroutine "
block|,
literal|"function "
block|,
literal|"program"
block|,
literal|"blockdata"
block|,
literal|"end"
block|,
name|CNULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ops
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|ptr
name|getsii
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* generate code */
end_comment

begin_macro
name|pass2
argument_list|()
end_macro

begin_block
block|{
name|exnull
argument_list|()
expr_stmt|;
if|if
condition|(
name|comments
condition|)
name|putcomment
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"    Pass 2\n"
argument_list|)
expr_stmt|;
name|dclsect
operator|=
literal|0
expr_stmt|;
name|indent
operator|=
literal|0
expr_stmt|;
name|namegen
argument_list|()
expr_stmt|;
name|dclgen
argument_list|()
expr_stmt|;
name|body
argument_list|(
name|iefile
argument_list|)
expr_stmt|;
name|datas
argument_list|()
expr_stmt|;
name|body
argument_list|(
name|icfile
argument_list|)
expr_stmt|;
name|p2stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|p2key
argument_list|(
name|FEND
argument_list|)
expr_stmt|;
name|p2flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"    Pass 2 done\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|datas
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|int
name|n1
decl_stmt|;
name|rewii
argument_list|(
name|idfile
argument_list|)
expr_stmt|;
name|swii
argument_list|(
name|idfile
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getic
argument_list|(
operator|&
name|n1
argument_list|)
expr_stmt|;
name|n
operator|=
name|n1
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ICEOF
case|:
return|return;
case|case
name|ICMARK
case|:
break|break;
case|case
name|ICBLANK
case|:
name|putblank
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICNAME
case|:
if|if
condition|(
operator|*
name|ftnames
index|[
name|n
index|]
operator|==
literal|'\0'
condition|)
name|fatal1
argument_list|(
literal|"no name for n=%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p2stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|p2key
argument_list|(
name|FDATA
argument_list|)
expr_stmt|;
name|p2str
argument_list|(
name|ftnames
index|[
name|n
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICOP
case|:
name|p2str
argument_list|(
name|ops
index|[
name|n
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICCONST
case|:
name|p2str
argument_list|(
name|getsii
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal1
argument_list|(
literal|"datas: invalid intermediate tag %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|body
argument_list|(
argument|fileadd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|fileblock
modifier|*
modifier|*
name|fileadd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n1
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|prevc
decl_stmt|;
name|int
name|ifn
decl_stmt|;
name|rewii
argument_list|(
name|fileadd
argument_list|)
expr_stmt|;
name|swii
argument_list|(
name|fileadd
argument_list|)
expr_stmt|;
name|prevc
operator|=
literal|0
expr_stmt|;
name|ifn
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getic
argument_list|(
operator|&
name|n1
argument_list|)
expr_stmt|;
name|n
operator|=
name|n1
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ICEOF
case|:
return|return;
case|case
name|ICBEGIN
case|:
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|prevc
condition|)
name|p2key
argument_list|(
name|FCONTINUE
argument_list|)
expr_stmt|;
else|else
name|prevc
operator|=
literal|1
expr_stmt|;
name|p2stmt
argument_list|(
name|stnos
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prevc
condition|)
name|p2stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICKEYWORD
case|:
name|p2key
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|FIF2
condition|)
break|break;
name|getic
argument_list|(
operator|&
name|ifn
argument_list|)
expr_stmt|;
if|if
condition|(
name|indifs
index|[
name|ifn
index|]
condition|)
name|skipuntil
argument_list|(
name|ICMARK
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICOP
case|:
name|p2str
argument_list|(
name|ops
index|[
name|n
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICNAME
case|:
if|if
condition|(
operator|*
name|ftnames
index|[
name|n
index|]
operator|==
literal|'\0'
condition|)
name|fatal1
argument_list|(
literal|"no name for n=%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p2str
argument_list|(
name|ftnames
index|[
name|n
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICCOMMENT
case|:
if|if
condition|(
name|prevc
condition|)
name|p2key
argument_list|(
name|FCONTINUE
argument_list|)
expr_stmt|;
name|p2com
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICBLANK
case|:
name|putblank
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICCONST
case|:
name|p2str
argument_list|(
name|getsii
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICINDPTR
case|:
name|n
operator|=
name|indifs
index|[
name|n
index|]
expr_stmt|;
case|case
name|ICLABEL
case|:
name|p2str
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|p2int
argument_list|(
name|stnos
index|[
name|n
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMARK
case|:
if|if
condition|(
name|indifs
index|[
name|ifn
index|]
condition|)
block|{
name|p2str
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|p2key
argument_list|(
name|FGOTO
argument_list|)
expr_stmt|;
name|p2int
argument_list|(
name|stnos
index|[
name|indifs
index|[
name|ifn
index|]
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skipuntil
argument_list|(
name|ICINDENT
argument_list|)
expr_stmt|;
name|p2str
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ICINDENT
case|:
name|indent
operator|=
name|n
operator|*
name|INDENTSPACES
expr_stmt|;
name|p2indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"Bad pass2 value %o,%o"
argument_list|,
name|c
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|!=
name|ICBEGIN
operator|&&
name|c
operator|!=
name|ICINDENT
condition|)
name|prevc
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|putname
argument_list|(
name|p
argument_list|)
specifier|register
name|ptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|vextbase
condition|)
block|{
name|putic
argument_list|(
name|ICNAME
argument_list|,
name|p
operator|->
name|vextbase
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFTNTYPES
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|p
operator|->
name|vbase
index|[
name|i
index|]
condition|)
block|{
name|putic
argument_list|(
name|ICNAME
argument_list|,
name|p
operator|->
name|vbase
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|p
operator|->
name|sthead
operator|->
name|namep
argument_list|)
operator|<=
name|XL
condition|)
name|fatal1
argument_list|(
literal|"no fortran slot for name %s"
argument_list|,
name|p
operator|->
name|sthead
operator|->
name|namep
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putconst
argument_list|(
argument|ty
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ptr
name|mkchcon
parameter_list|()
function_decl|;
if|if
condition|(
name|ty
operator|!=
name|TYCHAR
condition|)
name|putsii
argument_list|(
name|ICCONST
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
comment|/* change character constant to a variable */
name|putname
argument_list|(
name|mkchcon
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|putzcon
argument_list|(
name|p
argument_list|)
specifier|register
name|ptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"(%s,%s)"
argument_list|,
name|p
operator|->
name|leftp
argument_list|,
name|p
operator|->
name|rightp
argument_list|)
expr_stmt|;
name|putsii
argument_list|(
name|ICCONST
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putcomment
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|comments
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
name|putsii
argument_list|(
name|ICCOMMENT
argument_list|,
name|p
operator|->
name|datap
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|p
operator|->
name|datap
argument_list|)
expr_stmt|;
block|}
name|frchain
argument_list|(
operator|&
name|comments
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putblank
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|p2putc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|skipuntil
argument_list|(
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getic
argument_list|(
operator|&
name|n
argument_list|)
operator|)
operator|!=
name|k
operator|&&
name|i
operator|!=
name|ICEOF
condition|)
if|if
condition|(
name|i
operator|==
name|ICCOMMENT
operator|||
name|i
operator|==
name|ICCONST
condition|)
name|getsii
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|p2int
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* put an integer constant in the output */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2str
argument_list|(
name|convic
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2key
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* print a keyword */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2str
argument_list|(
name|verb
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2str
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* write a character string on the output */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|nftnch
operator|==
name|LINESPACES
operator|-
literal|1
operator|&&
operator|(
name|n
operator|==
literal|1
operator|||
operator|(
name|n
operator|==
literal|2
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|' '
operator|)
operator|)
condition|)
name|p2putc
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|n
operator|<=
name|LINESPACES
operator|&&
name|nftnch
operator|+
name|n
operator|>
name|LINESPACES
operator|-
literal|1
condition|)
name|p2line
argument_list|(
name|min
argument_list|(
name|LINESPACES
operator|-
name|n
argument_list|,
name|indent
operator|+
name|INDENTSPACES
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|p2putc
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|p2stmt
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* start a statement with label n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|codefile
argument_list|,
literal|"\n%4d  "
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|codefile
argument_list|,
literal|"\n      "
argument_list|)
expr_stmt|;
name|nftnch
operator|=
literal|0
expr_stmt|;
name|nftncont
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|p2com
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* copy a comment */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|getsii
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
comment|/* a literal escape line */
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|codefile
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
name|putc
argument_list|(
operator|*
operator|++
name|q
argument_list|,
name|codefile
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* actually a comment line */
block|{
operator|++
name|q
expr_stmt|;
operator|--
name|n
expr_stmt|;
do|do
block|{
name|k
operator|=
operator|(
name|n
operator|>
literal|71
condition|?
literal|71
else|:
name|n
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|codefile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|tailor
operator|.
name|ftnsys
operator|==
name|CRAY
condition|?
literal|'C'
else|:
literal|'c'
argument_list|,
name|codefile
argument_list|)
expr_stmt|;
while|while
condition|(
name|k
operator|--
operator|>
literal|0
condition|)
name|putc
argument_list|(
operator|*
name|q
operator|++
argument_list|,
name|codefile
argument_list|)
expr_stmt|;
name|n
operator|-=
literal|71
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|>
literal|0
condition|)
do|;
block|}
block|}
end_block

begin_macro
name|p2flush
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|nftnch
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|codefile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|nftnch
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|p2putc
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|nftnch
operator|>=
name|LINESPACES
condition|)
comment|/* end of line */
name|p2line
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tailor
operator|.
name|ftnsys
operator|==
name|CRAY
condition|)
name|putc
argument_list|(
name|islower
argument_list|(
name|c
argument_list|)
condition|?
name|toupper
argument_list|(
name|c
argument_list|)
else|:
name|c
argument_list|,
name|codefile
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
name|c
argument_list|,
name|codefile
argument_list|)
expr_stmt|;
operator|++
name|nftnch
expr_stmt|;
block|}
end_block

begin_macro
name|p2line
argument_list|(
argument|in
argument_list|)
end_macro

begin_decl_stmt
name|int
name|in
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|contchar
decl_stmt|;
if|if
condition|(
operator|++
name|nftncont
operator|>
literal|19
condition|)
block|{
name|execerr
argument_list|(
literal|"too many continuation lines"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|contchar
operator|=
literal|'X'
expr_stmt|;
block|}
if|if
condition|(
name|tailor
operator|.
name|ftncontnu
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|codefile
argument_list|,
literal|"\n&"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* standard column-6 continuation */
if|if
condition|(
name|nftncont
operator|<
literal|20
condition|)
name|contchar
operator|=
literal|"0123456789ABCDEFGHIJ"
index|[
name|nftncont
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|codefile
argument_list|,
literal|"\n     %c"
argument_list|,
name|contchar
argument_list|)
expr_stmt|;
block|}
name|nftnch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|in
operator|>
literal|0
condition|)
name|p2indent
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|p2indent
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|p2putc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

