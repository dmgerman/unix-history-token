begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"defs"
end_include

begin_macro
name|hide
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|ptr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|warn1
argument_list|(
literal|"Name %s hidden by a new declaration"
argument_list|,
name|p
operator|->
name|namep
argument_list|)
expr_stmt|;
name|hidlist
operator|=
name|mkchain
argument_list|(
name|p
operator|->
name|varp
argument_list|,
name|hidlist
argument_list|)
expr_stmt|;
name|p
operator|->
name|varp
operator|=
literal|0
expr_stmt|;
operator|++
name|nhid
index|[
name|blklevel
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  remove all symbol table entries in terminated block,     revive old hidden names */
end_comment

begin_macro
name|unhide
argument_list|()
end_macro

begin_block
block|{
name|chainp
name|p
decl_stmt|;
specifier|register
name|ptr
name|q
decl_stmt|;
specifier|register
name|ptr
name|v
decl_stmt|;
specifier|register
name|struct
name|stentry
modifier|*
name|s
decl_stmt|;
name|struct
name|stentry
modifier|*
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|hashtab
init|;
name|hp
operator|<
name|hashend
condition|;
operator|++
name|hp
control|)
if|if
condition|(
name|s
operator|=
operator|*
name|hp
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|=
name|s
operator|->
name|varp
operator|)
operator|&&
name|v
operator|->
name|blklevel
operator|==
name|blklevel
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|tag
operator|==
name|TLABEL
condition|)
if|if
condition|(
name|blklevel
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|labdefined
operator|==
literal|0
condition|)
name|laberr
argument_list|(
literal|"%s never defined"
argument_list|,
name|v
operator|->
name|sthead
operator|->
name|namep
argument_list|)
expr_stmt|;
name|s
operator|->
name|varp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* move label out a level */
if|if
condition|(
name|v
operator|->
name|labdefined
condition|)
name|v
operator|->
name|labinacc
operator|=
literal|1
expr_stmt|;
name|v
operator|->
name|blklevel
operator|--
expr_stmt|;
operator|++
name|ndecl
index|[
name|blklevel
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|v
operator|->
name|tag
operator|==
name|TNAME
condition|)
block|{
name|TEST
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"gone(%s) level %d\n"
argument_list|,
name|s
operator|->
name|namep
argument_list|,
name|blklevel
argument_list|)
decl_stmt|;
name|gonelist
operator|=
name|mkchain
argument_list|(
name|s
operator|->
name|varp
argument_list|,
name|gonelist
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|tag
operator|!=
name|TSTRUCT
condition|)
block|{
operator|++
name|ndecl
index|[
name|blklevel
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|tag
operator|==
name|TDEFINE
condition|)
name|frdef
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|varp
operator|=
literal|0
expr_stmt|;
block|}
operator|--
name|ndecl
index|[
name|blklevel
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|hidlist
init|;
name|p
operator|&&
operator|(
operator|(
name|v
operator|=
operator|(
name|q
operator|=
name|p
operator|->
name|datap
operator|)
operator|->
name|sthead
operator|)
operator|->
name|varp
operator|==
name|NULL
operator|)
condition|;
name|p
operator|=
name|hidlist
control|)
block|{
name|v
operator|->
name|varp
operator|=
name|q
expr_stmt|;
name|v
operator|->
name|tag
operator|=
name|q
operator|->
name|tag
expr_stmt|;
name|v
operator|->
name|subtype
operator|=
name|q
operator|->
name|subtype
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|blklevel
operator|>
name|q
operator|->
name|blklevel
condition|)
name|v
operator|->
name|blklevel
operator|=
name|q
operator|->
name|blklevel
expr_stmt|;
name|hidlist
operator|=
name|p
operator|->
name|nextp
expr_stmt|;
name|p
operator|->
name|nextp
operator|=
name|CHNULL
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
operator|--
name|nhid
index|[
name|blklevel
index|]
expr_stmt|;
name|TEST
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"unhide(%s), blklevel %d\n"
argument_list|,
name|v
operator|->
name|namep
argument_list|,
name|v
operator|->
name|blklevel
argument_list|)
decl_stmt|;
block|}
if|if
condition|(
name|ndecl
index|[
name|blklevel
index|]
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%d declarations leftover at block level %d"
argument_list|,
name|ndecl
index|[
name|blklevel
index|]
argument_list|,
name|blklevel
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nhid
index|[
name|blklevel
index|]
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"leftover hidden variables"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|ptr
name|bgnexec
parameter_list|()
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
name|p
operator|=
name|allexcblock
argument_list|()
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TEXEC
expr_stmt|;
name|p
operator|->
name|prevexec
operator|=
name|thisexec
expr_stmt|;
if|if
condition|(
name|thisexec
operator|&&
name|thisexec
operator|->
name|copylab
condition|)
block|{
name|p
operator|->
name|labelno
operator|=
name|thisexec
operator|->
name|labelno
expr_stmt|;
name|p
operator|->
name|labused
operator|=
name|thisexec
operator|->
name|labused
expr_stmt|;
name|thisexec
operator|->
name|labelno
operator|=
literal|0
expr_stmt|;
block|}
name|thisexec
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|ptr
name|addexec
parameter_list|()
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
specifier|register
name|ptr
name|q
decl_stmt|;
name|q
operator|=
name|thisexec
expr_stmt|;
name|p
operator|=
name|q
operator|->
name|prevexec
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|temps
condition|)
name|tempvarlist
operator|=
name|hookup
argument_list|(
name|q
operator|->
name|temps
argument_list|,
name|tempvarlist
argument_list|)
expr_stmt|;
name|p
operator|->
name|brnchend
operator|=
name|q
operator|->
name|brnchend
expr_stmt|;
name|p
operator|->
name|nftnst
operator|+=
name|q
operator|->
name|nftnst
expr_stmt|;
name|p
operator|->
name|labeled
operator||=
name|q
operator|->
name|labeled
expr_stmt|;
name|p
operator|->
name|uniffable
operator||=
name|q
operator|->
name|uniffable
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|labelno
operator|&&
operator|!
operator|(
name|q
operator|->
name|labused
operator|)
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|nxtlabno
condition|)
name|exnull
argument_list|()
expr_stmt|;
else|else
name|q
operator|->
name|nxtlabno
operator|=
name|q
operator|->
name|labelno
expr_stmt|;
block|}
name|thisexec
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|nxtlabno
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|labelno
operator|&&
operator|!
operator|(
name|p
operator|->
name|labused
operator|)
condition|)
name|exnull
argument_list|()
expr_stmt|;
name|p
operator|->
name|labelno
operator|=
name|q
operator|->
name|nxtlabno
expr_stmt|;
name|p
operator|->
name|labused
operator|=
literal|0
expr_stmt|;
block|}
name|frexcblock
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|pushctl
argument_list|(
argument|t
argument_list|,
argument|vp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|ptr
name|vp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ptr
name|q
decl_stmt|;
name|ptr
name|p
decl_stmt|;
name|int
name|junk
decl_stmt|;
name|q
operator|=
name|allexcblock
argument_list|()
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TCONTROL
expr_stmt|;
name|q
operator|->
name|subtype
operator|=
name|t
expr_stmt|;
name|q
operator|->
name|loopvar
operator|=
name|vp
expr_stmt|;
name|q
operator|->
name|prevctl
operator|=
name|thisctl
expr_stmt|;
name|thisctl
operator|=
name|q
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|STSWITCH
case|:
name|q
operator|->
name|xlab
operator|=
name|nextlab
argument_list|()
expr_stmt|;
name|q
operator|->
name|nextlab
operator|=
literal|0
expr_stmt|;
name|exgoto
argument_list|(
name|q
operator|->
name|xlab
argument_list|)
expr_stmt|;
name|ncases
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|STFOR
case|:
name|exlab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|q
operator|->
name|nextlab
operator|=
name|nextlab
argument_list|()
expr_stmt|;
name|q
operator|->
name|xlab
operator|=
name|nextlab
argument_list|()
expr_stmt|;
break|break;
case|case
name|STWHILE
case|:
name|q
operator|->
name|nextlab
operator|=
name|thislab
argument_list|()
expr_stmt|;
if|if
condition|(
name|vp
condition|)
name|exifgo
argument_list|(
name|mknode
argument_list|(
name|TNOTOP
argument_list|,
name|OPNOT
argument_list|,
name|vp
argument_list|,
name|PNULL
argument_list|)
argument_list|,
name|q
operator|->
name|breaklab
operator|=
name|nextlab
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|thisexec
operator|->
name|copylab
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|STREPEAT
case|:
name|exnull
argument_list|()
expr_stmt|;
name|q
operator|->
name|xlab
operator|=
name|thislab
argument_list|()
expr_stmt|;
name|thisexec
operator|->
name|copylab
operator|=
literal|1
expr_stmt|;
name|junk
operator|=
name|nextindif
argument_list|()
expr_stmt|;
name|indifs
index|[
name|junk
index|]
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|indifn
operator|=
name|junk
expr_stmt|;
name|indifs
index|[
name|q
operator|->
name|indifn
index|]
operator|=
name|q
operator|->
name|xlab
expr_stmt|;
break|break;
case|case
name|STDO
case|:
name|q
operator|->
name|nextlab
operator|=
name|nextlab
argument_list|()
expr_stmt|;
name|exlab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putic
argument_list|(
name|ICKEYWORD
argument_list|,
name|FDO
argument_list|)
expr_stmt|;
name|putic
argument_list|(
name|ICLABEL
argument_list|,
name|q
operator|->
name|nextlab
argument_list|)
expr_stmt|;
name|putic
argument_list|(
name|ICBLANK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|mknode
argument_list|(
name|TASGNOP
argument_list|,
name|OPASGN
argument_list|,
name|vp
operator|->
name|dovar
argument_list|,
name|vp
operator|->
name|dopar
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|prexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|putic
argument_list|(
name|ICOP
argument_list|,
name|OPCOMMA
argument_list|)
expr_stmt|;
name|prexpr
argument_list|(
name|vp
operator|->
name|dopar
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|vp
operator|->
name|dopar
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|dopar
index|[
literal|2
index|]
condition|)
block|{
name|putic
argument_list|(
name|ICOP
argument_list|,
name|OPCOMMA
argument_list|)
expr_stmt|;
name|prexpr
argument_list|(
name|vp
operator|->
name|dopar
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|vp
operator|->
name|dopar
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|cfree
argument_list|(
name|vp
argument_list|)
expr_stmt|;
break|break;
case|case
name|STIF
case|:
name|exif
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|thisexec
operator|->
name|nftnst
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|fatal1
argument_list|(
literal|"pushctl: invalid control block type %d"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
operator|++
name|ctllevel
expr_stmt|;
block|}
end_block

begin_macro
name|popctl
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
name|ptr
name|newp
decl_stmt|;
name|chainp
name|q
decl_stmt|;
name|int
name|first
decl_stmt|,
name|deflabno
decl_stmt|,
name|blab
decl_stmt|,
name|cmin
decl_stmt|,
name|cmax
decl_stmt|,
name|range
decl_stmt|,
name|caseval
decl_stmt|,
name|optcase
decl_stmt|;
name|int
name|labp
index|[
name|MAXSWITCH
index|]
decl_stmt|;
if|if
condition|(
name|thisctl
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"empty control stack popped"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|thisctl
operator|->
name|subtype
condition|)
block|{
case|case
name|STSWITCH
case|:
comment|/*		if(thisexec->brnchend == 0)	*/
block|{
if|if
condition|(
name|thisctl
operator|->
name|breaklab
operator|==
literal|0
condition|)
name|thisctl
operator|->
name|breaklab
operator|=
name|nextlab
argument_list|()
expr_stmt|;
name|exgoto
argument_list|(
name|thisctl
operator|->
name|breaklab
argument_list|)
expr_stmt|;
block|}
name|exlab
argument_list|(
name|thisctl
operator|->
name|xlab
argument_list|)
expr_stmt|;
name|deflabno
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|YES
expr_stmt|;
name|optcase
operator|=
operator|(
name|thisctl
operator|->
name|loopvar
operator|->
name|vtype
operator|==
name|TYINT
operator|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|thisctl
operator|->
name|loopctl
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|nextcase
control|)
if|if
condition|(
name|p
operator|->
name|labdefined
operator|==
literal|0
condition|)
block|{
name|laberr
argument_list|(
literal|"undefined case label"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|optcase
operator|=
name|NO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|casexpr
operator|==
literal|0
condition|)
name|deflabno
operator|=
name|p
operator|->
name|labelno
expr_stmt|;
elseif|else
if|if
condition|(
name|isicon
argument_list|(
name|p
operator|->
name|casexpr
argument_list|,
operator|&
name|caseval
argument_list|)
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
name|NO
expr_stmt|;
name|cmin
operator|=
name|cmax
operator|=
name|caseval
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|caseval
operator|<
name|cmin
condition|)
name|cmin
operator|=
name|caseval
expr_stmt|;
if|if
condition|(
name|caseval
operator|>
name|cmax
condition|)
name|cmax
operator|=
name|caseval
expr_stmt|;
block|}
operator|++
name|ncases
expr_stmt|;
block|}
else|else
name|optcase
operator|=
name|NO
expr_stmt|;
name|range
operator|=
name|cmax
operator|-
name|cmin
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|optcase
operator|&&
name|ncases
operator|>
literal|2
operator|&&
name|range
operator|<
literal|2
operator|*
name|ncases
operator|&&
name|range
operator|<
name|MAXSWITCH
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|range
condition|;
operator|++
name|i
control|)
name|labp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|thisctl
operator|->
name|loopctl
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|nextcase
control|)
if|if
condition|(
name|p
operator|->
name|labdefined
operator|&&
name|p
operator|->
name|casexpr
condition|)
block|{
name|isicon
argument_list|(
name|p
operator|->
name|casexpr
argument_list|,
operator|&
name|caseval
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|casexpr
argument_list|)
expr_stmt|;
name|labp
index|[
name|caseval
operator|-
name|cmin
index|]
operator|=
name|p
operator|->
name|labelno
expr_stmt|;
block|}
name|q
operator|=
name|CHNULL
expr_stmt|;
name|blab
operator|=
operator|(
name|deflabno
condition|?
name|deflabno
else|:
name|thisctl
operator|->
name|breaklab
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|range
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|q
operator|=
name|mkchain
argument_list|(
name|labp
index|[
name|i
index|]
condition|?
name|labp
index|[
name|i
index|]
else|:
name|blab
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|excompgoto
argument_list|(
name|q
argument_list|,
name|mknode
argument_list|(
name|TAROP
argument_list|,
name|OPPLUS
argument_list|,
name|mkint
argument_list|(
literal|1
operator|-
name|cmin
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|thisctl
operator|->
name|loopvar
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|thisctl
operator|->
name|loopctl
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|nextcase
control|)
if|if
condition|(
name|p
operator|->
name|labdefined
operator|&&
name|p
operator|->
name|casexpr
condition|)
name|exifgo
argument_list|(
name|mknode
argument_list|(
name|TRELOP
argument_list|,
name|OPEQ
argument_list|,
name|cpexpr
argument_list|(
name|thisctl
operator|->
name|loopvar
argument_list|)
argument_list|,
name|p
operator|->
name|casexpr
argument_list|)
argument_list|,
name|p
operator|->
name|labelno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deflabno
condition|)
name|exgoto
argument_list|(
name|deflabno
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|thisctl
operator|->
name|loopctl
init|;
name|p
condition|;
name|p
operator|=
name|newp
control|)
block|{
name|newp
operator|=
name|p
operator|->
name|nextcase
expr_stmt|;
name|cfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|thisctl
operator|->
name|loopctl
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|STFOR
case|:
name|exgoto
argument_list|(
name|thisctl
operator|->
name|nextlab
argument_list|)
expr_stmt|;
break|break;
case|case
name|STWHILE
case|:
name|exgoto
argument_list|(
name|thisctl
operator|->
name|nextlab
argument_list|)
expr_stmt|;
break|break;
case|case
name|STREPEAT
case|:
break|break;
case|case
name|STDO
case|:
name|exnull
argument_list|()
expr_stmt|;
name|exlab
argument_list|(
name|thisctl
operator|->
name|nextlab
argument_list|)
expr_stmt|;
name|putic
argument_list|(
name|ICKEYWORD
argument_list|,
name|FCONTINUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|STIF
case|:
break|break;
case|case
name|STPROC
case|:
break|break;
default|default:
name|fatal1
argument_list|(
literal|"popctl: invalid control block type %d"
argument_list|,
name|thisctl
operator|->
name|subtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thisctl
operator|->
name|breaklab
operator|!=
literal|0
condition|)
name|thisexec
operator|->
name|nxtlabno
operator|=
name|thisctl
operator|->
name|breaklab
expr_stmt|;
name|p
operator|=
name|thisctl
operator|->
name|prevctl
expr_stmt|;
name|frexcblock
argument_list|(
name|thisctl
argument_list|)
expr_stmt|;
name|thisctl
operator|=
name|p
expr_stmt|;
operator|--
name|ctllevel
expr_stmt|;
block|}
end_block

end_unit

