begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)cmd.c	4.3 %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#
end_empty

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Bell Telephone Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_function_decl
name|PROC
name|IOPTR
name|inout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PROC
name|VOID
name|chkword
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PROC
name|VOID
name|chksym
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PROC
name|TREPTR
name|term
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PROC
name|TREPTR
name|makelist
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PROC
name|TREPTR
name|list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PROC
name|REGPTR
name|syncase
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PROC
name|TREPTR
name|item
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PROC
name|VOID
name|skipnl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PROC
name|VOID
name|prsym
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PROC
name|VOID
name|synbad
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ========	command line decoding	========*/
end_comment

begin_function
name|TREPTR
name|makefork
parameter_list|(
name|flgs
parameter_list|,
name|i
parameter_list|)
name|INT
name|flgs
decl_stmt|;
name|TREPTR
name|i
decl_stmt|;
block|{
name|REG
name|TREPTR
name|t
decl_stmt|;
name|t
operator|=
name|getstak
argument_list|(
name|FORKTYPE
argument_list|)
expr_stmt|;
name|t
operator|->
name|forknod
operator|.
name|forktyp
operator|=
name|flgs
operator||
name|TFORK
expr_stmt|;
name|t
operator|->
name|forknod
operator|.
name|forktre
operator|=
name|i
expr_stmt|;
name|t
operator|->
name|forknod
operator|.
name|forkio
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|TREPTR
name|makelist
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|,
name|r
parameter_list|)
name|INT
name|type
decl_stmt|;
name|TREPTR
name|i
decl_stmt|,
name|r
decl_stmt|;
block|{
name|REG
name|TREPTR
name|t
decl_stmt|;
name|IF
name|i
operator|==
literal|0
name|ORF
name|r
operator|==
literal|0
name|THEN
name|synbad
argument_list|()
expr_stmt|;
name|ELSE
name|t
init|=
name|getstak
argument_list|(
name|LSTTYPE
argument_list|)
decl_stmt|;
name|t
operator|->
name|lstnod
operator|.
name|lsttyp
operator|=
name|type
expr_stmt|;
name|t
operator|->
name|lstnod
operator|.
name|lstlef
operator|=
name|i
expr_stmt|;
name|t
operator|->
name|lstnod
operator|.
name|lstrit
operator|=
name|r
expr_stmt|;
name|FI
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cmd  *	empty  *	list  *	list& [ cmd ]  *	list [ ; cmd ]  */
end_comment

begin_function
name|TREPTR
name|cmd
parameter_list|(
name|sym
parameter_list|,
name|flg
parameter_list|)
name|REG
name|INT
name|sym
decl_stmt|;
name|INT
name|flg
decl_stmt|;
block|{
name|REG
name|TREPTR
name|i
decl_stmt|,
name|e
decl_stmt|;
name|i
operator|=
name|list
argument_list|(
name|flg
argument_list|)
expr_stmt|;
name|IF
name|wdval
operator|==
name|NL
name|THEN
name|IF
name|flg
operator|&
name|NLFLG
name|THEN
name|wdval
operator|=
literal|';'
expr_stmt|;
name|chkpr
argument_list|(
name|NL
argument_list|)
expr_stmt|;
name|FI
name|ELIF
name|i
operator|==
literal|0
name|ANDF
argument_list|(
name|flg
operator|&
name|MTFLG
argument_list|)
operator|==
literal|0
name|THEN
name|synbad
argument_list|()
expr_stmt|;
name|FI
name|SWITCH
name|wdval
name|IN
case|case
literal|'&'
case|:
name|IF
name|i
name|THEN
name|i
init|=
name|makefork
argument_list|(
name|FINT
operator||
name|FPRS
operator||
name|FAMP
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|ELSE
name|synbad
parameter_list|()
function_decl|;
name|FI
case|case
literal|';'
case|:
name|IF
name|e
init|=
name|cmd
argument_list|(
argument|sym
argument_list|,
argument|flg|MTFLG
argument_list|)
name|THEN
name|i
operator|=
name|makelist
argument_list|(
name|TLST
argument_list|,
name|i
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|FI
break|break;
case|case
name|EOFSYM
case|:
name|IF
name|sym
operator|==
name|NL
name|THEN
break|break;
name|FI
default|default:
name|IF
name|sym
name|THEN
name|chksym
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|FI
name|ENDSW
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * list  *	term  *	list&& term  *	list || term  */
end_comment

begin_function
name|LOCAL
name|TREPTR
name|list
parameter_list|(
name|flg
parameter_list|)
block|{
name|REG
name|TREPTR
name|r
decl_stmt|;
name|REG
name|INT
name|b
decl_stmt|;
name|r
operator|=
name|term
argument_list|(
name|flg
argument_list|)
expr_stmt|;
name|WHILE
name|r
name|ANDF
argument_list|(
operator|(
name|b
operator|=
operator|(
name|wdval
operator|==
name|ANDFSYM
operator|)
operator|)
name|ORF
name|wdval
operator|==
name|ORFSYM
argument_list|)
name|DO
name|r
init|=
name|makelist
argument_list|(
operator|(
name|b
condition|?
name|TAND
else|:
name|TORF
operator|)
argument_list|,
name|r
argument_list|,
name|term
argument_list|(
name|NLFLG
argument_list|)
argument_list|)
decl_stmt|;
name|OD
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * term  *	item  *	item |^ term  */
end_comment

begin_function
name|LOCAL
name|TREPTR
name|term
parameter_list|(
name|flg
parameter_list|)
block|{
name|REG
name|TREPTR
name|t
decl_stmt|;
name|reserv
operator|++
expr_stmt|;
name|IF
name|flg
modifier|&
name|NLFLG
name|THEN
name|skipnl
parameter_list|()
function_decl|;
name|ELSE
name|word
parameter_list|()
function_decl|;
name|FI
name|IF
argument_list|(
name|t
operator|=
name|item
argument_list|(
name|TRUE
argument_list|)
argument_list|)
name|ANDF
argument_list|(
name|wdval
operator|==
literal|'^'
name|ORF
name|wdval
operator|==
literal|'|'
argument_list|)
name|THEN
decl|return
argument_list|(
name|makelist
argument_list|(
name|TFIL
argument_list|,
name|makefork
argument_list|(
name|FPOU
argument_list|,
name|t
argument_list|)
argument_list|,
name|makefork
argument_list|(
name|FPIN
operator||
name|FPCL
argument_list|,
name|term
argument_list|(
name|NLFLG
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ELSE
return|return
operator|(
name|t
operator|)
return|;
name|FI
block|}
end_function

begin_function
name|LOCAL
name|REGPTR
name|syncase
parameter_list|(
name|esym
parameter_list|)
name|REG
name|INT
name|esym
decl_stmt|;
block|{
name|skipnl
argument_list|()
expr_stmt|;
name|IF
name|wdval
operator|==
name|esym
name|THEN
return|return
operator|(
literal|0
operator|)
return|;
name|ELSE
name|REG
name|REGPTR
name|r
init|=
name|getstak
argument_list|(
name|REGTYPE
argument_list|)
decl_stmt|;
name|r
operator|->
name|regptr
operator|=
literal|0
expr_stmt|;
name|LOOP
name|wdarg
operator|->
name|argnxt
init|=
name|r
operator|->
name|regptr
decl_stmt|;
name|r
operator|->
name|regptr
operator|=
name|wdarg
expr_stmt|;
name|IF
name|wdval
name|ORF
argument_list|(
name|word
argument_list|()
operator|!=
literal|')'
name|ANDF
name|wdval
operator|!=
literal|'|'
argument_list|)
name|THEN
name|synbad
argument_list|()
decl_stmt|;
name|FI
name|IF
name|wdval
operator|==
literal|'|'
name|THEN
name|word
argument_list|()
expr_stmt|;
name|ELSE
break|break;
name|FI
name|POOL
name|r
operator|->
name|regcom
init|=
name|cmd
argument_list|(
literal|0
argument_list|,
name|NLFLG
operator||
name|MTFLG
argument_list|)
decl_stmt|;
name|IF
name|wdval
operator|==
name|ECSYM
name|THEN
name|r
operator|->
name|regnxt
operator|=
name|syncase
argument_list|(
name|esym
argument_list|)
expr_stmt|;
name|ELSE
name|chksym
argument_list|(
name|esym
argument_list|)
decl_stmt|;
name|r
operator|->
name|regnxt
operator|=
literal|0
expr_stmt|;
name|FI
return|return
operator|(
name|r
operator|)
return|;
name|FI
block|}
end_function

begin_comment
comment|/*  * item  *  *	( cmd ) [< in  ] [> out ]  *	word word* [< in ] [> out ]  *	if ... then ... else ... fi  *	for ... while ... do ... done  *	case ... in ... esac  *	begin ... end  */
end_comment

begin_function
name|LOCAL
name|TREPTR
name|item
parameter_list|(
name|flag
parameter_list|)
name|BOOL
name|flag
decl_stmt|;
block|{
name|REG
name|TREPTR
name|t
decl_stmt|;
name|REG
name|IOPTR
name|io
decl_stmt|;
name|IF
name|flag
name|THEN
name|io
init|=
name|inout
argument_list|(
operator|(
name|IOPTR
operator|)
literal|0
argument_list|)
decl_stmt|;
name|ELSE
name|io
init|=
literal|0
decl_stmt|;
name|FI
name|SWITCH
name|wdval
name|IN
case|case
name|CASYM
case|:
name|BEGIN
name|t
init|=
name|getstak
argument_list|(
name|SWTYPE
argument_list|)
decl_stmt|;
name|chkword
argument_list|()
expr_stmt|;
name|t
operator|->
name|swnod
operator|.
name|swarg
operator|=
name|wdarg
operator|->
name|argval
expr_stmt|;
name|skipnl
argument_list|()
expr_stmt|;
name|chksym
argument_list|(
name|INSYM
operator||
name|BRSYM
argument_list|)
expr_stmt|;
name|t
operator|->
name|swnod
operator|.
name|swlst
operator|=
name|syncase
argument_list|(
name|wdval
operator|==
name|INSYM
condition|?
name|ESSYM
else|:
name|KTSYM
argument_list|)
expr_stmt|;
name|t
operator|->
name|swnod
operator|.
name|swtyp
operator|=
name|TSW
expr_stmt|;
break|break;
name|END
case|case
name|IFSYM
case|:
name|BEGIN
name|REG
name|INT
name|w
decl_stmt|;
name|t
operator|=
name|getstak
argument_list|(
name|IFTYPE
argument_list|)
expr_stmt|;
name|t
operator|->
name|ifnod
operator|.
name|iftyp
operator|=
name|TIF
expr_stmt|;
name|t
operator|->
name|ifnod
operator|.
name|iftre
operator|=
name|cmd
argument_list|(
name|THSYM
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
name|t
operator|->
name|ifnod
operator|.
name|thtre
operator|=
name|cmd
argument_list|(
name|ELSYM
operator||
name|FISYM
operator||
name|EFSYM
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
name|t
operator|->
name|ifnod
operator|.
name|eltre
operator|=
operator|(
operator|(
name|w
operator|=
name|wdval
operator|)
operator|==
name|ELSYM
condition|?
name|cmd
argument_list|(
name|FISYM
argument_list|,
name|NLFLG
argument_list|)
else|:
operator|(
name|w
operator|==
name|EFSYM
condition|?
operator|(
name|wdval
operator|=
name|IFSYM
operator|,
name|item
argument_list|(
literal|0
argument_list|)
operator|)
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|IF
name|w
operator|==
name|EFSYM
name|THEN
return|return
operator|(
name|t
operator|)
name|FI
break|break;
name|END
case|case
name|FORSYM
case|:
name|BEGIN
name|t
init|=
name|getstak
argument_list|(
name|FORTYPE
argument_list|)
decl_stmt|;
name|t
operator|->
name|fornod
operator|.
name|fortyp
operator|=
name|TFOR
expr_stmt|;
name|t
operator|->
name|fornod
operator|.
name|forlst
operator|=
literal|0
expr_stmt|;
name|chkword
argument_list|()
expr_stmt|;
name|t
operator|->
name|fornod
operator|.
name|fornam
operator|=
name|wdarg
operator|->
name|argval
expr_stmt|;
name|IF
name|skipnl
argument_list|()
operator|==
name|INSYM
name|THEN
name|chkword
argument_list|()
expr_stmt|;
name|t
operator|->
name|fornod
operator|.
name|forlst
operator|=
name|item
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|IF
name|wdval
operator|!=
name|NL
name|ANDF
name|wdval
operator|!=
literal|';'
name|THEN
name|synbad
argument_list|()
expr_stmt|;
name|FI
name|chkpr
argument_list|(
name|wdval
argument_list|)
decl_stmt|;
name|skipnl
argument_list|()
expr_stmt|;
name|FI
name|chksym
argument_list|(
name|DOSYM
operator||
name|BRSYM
argument_list|)
decl_stmt|;
name|t
operator|->
name|fornod
operator|.
name|fortre
operator|=
name|cmd
argument_list|(
name|wdval
operator|==
name|DOSYM
condition|?
name|ODSYM
else|:
name|KTSYM
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
break|break;
name|END
case|case
name|WHSYM
case|:
case|case
name|UNSYM
case|:
name|BEGIN
name|t
init|=
name|getstak
argument_list|(
name|WHTYPE
argument_list|)
decl_stmt|;
name|t
operator|->
name|whnod
operator|.
name|whtyp
operator|=
operator|(
name|wdval
operator|==
name|WHSYM
condition|?
name|TWH
else|:
name|TUN
operator|)
expr_stmt|;
name|t
operator|->
name|whnod
operator|.
name|whtre
operator|=
name|cmd
argument_list|(
name|DOSYM
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
name|t
operator|->
name|whnod
operator|.
name|dotre
operator|=
name|cmd
argument_list|(
name|ODSYM
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
break|break;
name|END
case|case
name|BRSYM
case|:
name|t
operator|=
name|cmd
argument_list|(
name|KTSYM
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|BEGIN
name|REG
name|PARPTR
name|p
decl_stmt|;
name|p
operator|=
name|getstak
argument_list|(
name|PARTYPE
argument_list|)
expr_stmt|;
name|p
operator|->
name|partre
operator|=
name|cmd
argument_list|(
literal|')'
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
name|p
operator|->
name|partyp
operator|=
name|TPAR
expr_stmt|;
name|t
operator|=
name|makefork
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
name|END
default|default:
name|IF
name|io
operator|==
literal|0
name|THEN
return|return
operator|(
literal|0
operator|)
return|;
name|FI
case|case
literal|0
case|:
name|BEGIN
name|REG
name|ARGPTR
name|argp
decl_stmt|;
name|REG
name|ARGPTR
modifier|*
name|argtail
decl_stmt|;
name|REG
name|ARGPTR
modifier|*
name|argset
init|=
literal|0
decl_stmt|;
name|INT
name|keywd
init|=
literal|1
decl_stmt|;
name|t
operator|=
name|getstak
argument_list|(
name|COMTYPE
argument_list|)
expr_stmt|;
name|t
operator|->
name|comnod
operator|.
name|comio
operator|=
name|io
expr_stmt|;
comment|/*initial io chain*/
name|argtail
operator|=
operator|&
operator|(
name|t
operator|->
name|comnod
operator|.
name|comarg
operator|)
expr_stmt|;
name|WHILE
name|wdval
operator|==
literal|0
name|DO
name|argp
operator|=
name|wdarg
expr_stmt|;
name|IF
name|wdset
name|ANDF
name|keywd
name|THEN
name|argp
operator|->
name|argnxt
init|=
name|argset
decl_stmt|;
name|argset
operator|=
name|argp
expr_stmt|;
name|ELSE
modifier|*
name|argtail
init|=
name|argp
decl_stmt|;
name|argtail
operator|=
operator|&
operator|(
name|argp
operator|->
name|argnxt
operator|)
expr_stmt|;
name|keywd
operator|=
name|flags
operator|&
name|keyflg
expr_stmt|;
name|FI
name|word
parameter_list|()
function_decl|;
name|IF
name|flag
name|THEN
name|t
operator|->
name|comnod
operator|.
name|comio
init|=
name|inout
argument_list|(
name|t
operator|->
name|comnod
operator|.
name|comio
argument_list|)
decl_stmt|;
name|FI
name|OD
name|t
operator|->
name|comnod
operator|.
name|comtyp
init|=
name|TCOM
decl_stmt|;
name|t
operator|->
name|comnod
operator|.
name|comset
operator|=
name|argset
expr_stmt|;
operator|*
name|argtail
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
name|END
name|ENDSW
name|reserv
operator|++
expr_stmt|;
name|word
argument_list|()
expr_stmt|;
name|IF
name|io
init|=
name|inout
argument_list|(
argument|io
argument_list|)
name|THEN
name|t
operator|=
name|makefork
argument_list|(
literal|0
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|t
operator|->
name|treio
operator|.
name|treio
operator|=
name|io
expr_stmt|;
name|FI
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|VOID
name|skipnl
parameter_list|()
block|{
name|WHILE
argument_list|(
argument|reserv++
argument_list|,
argument|word()==NL
argument_list|)
name|DO
name|chkpr
argument_list|(
name|NL
argument_list|)
name|OD
decl|return
argument_list|(
name|wdval
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|IOPTR
name|inout
parameter_list|(
name|lastio
parameter_list|)
name|IOPTR
name|lastio
decl_stmt|;
block|{
name|REG
name|INT
name|iof
decl_stmt|;
name|REG
name|IOPTR
name|iop
decl_stmt|;
name|REG
name|CHAR
name|c
decl_stmt|;
name|iof
operator|=
name|wdnum
expr_stmt|;
name|SWITCH
name|wdval
name|IN
case|case
name|DOCSYM
case|:
name|iof
operator||=
name|IODOC
expr_stmt|;
break|break;
case|case
name|APPSYM
case|:
case|case
literal|'>'
case|:
name|IF
name|wdnum
operator|==
literal|0
name|THEN
name|iof
operator||=
literal|1
name|FI
name|iof
operator||=
name|IOPUT
expr_stmt|;
name|IF
name|wdval
operator|==
name|APPSYM
name|THEN
name|iof
operator||=
name|IOAPP
expr_stmt|;
break|break;
name|FI
case|case
literal|'<'
case|:
name|IF
argument_list|(
name|c
operator|=
name|nextc
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|==
literal|'&'
name|THEN
name|iof
operator||=
name|IOMOV
expr_stmt|;
name|ELIF
name|c
operator|==
literal|'>'
name|THEN
name|iof
operator||=
name|IORDW
expr_stmt|;
name|ELSE
name|peekc
init|=
name|c
operator||
name|MARK
decl_stmt|;
name|FI
break|break;
default|default:
return|return
operator|(
name|lastio
operator|)
return|;
name|ENDSW
name|chkword
parameter_list|()
function_decl|;
name|iop
operator|=
name|getstak
argument_list|(
name|IOTYPE
argument_list|)
expr_stmt|;
name|iop
operator|->
name|ioname
operator|=
name|wdarg
operator|->
name|argval
expr_stmt|;
name|iop
operator|->
name|iofile
operator|=
name|iof
expr_stmt|;
name|IF
name|iof
modifier|&
name|IODOC
name|THEN
name|iop
operator|->
name|iolst
init|=
name|iopend
decl_stmt|;
name|iopend
operator|=
name|iop
expr_stmt|;
name|FI
name|word
parameter_list|()
function_decl|;
name|iop
operator|->
name|ionxt
operator|=
name|inout
argument_list|(
name|lastio
argument_list|)
expr_stmt|;
return|return
operator|(
name|iop
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|VOID
name|chkword
parameter_list|()
block|{
name|IF
name|word
argument_list|()
name|THEN
name|synbad
argument_list|()
expr_stmt|;
name|FI
block|}
end_function

begin_function
name|LOCAL
name|VOID
name|chksym
parameter_list|(
name|sym
parameter_list|)
block|{
name|REG
name|INT
name|x
init|=
name|sym
operator|&
name|wdval
decl_stmt|;
name|IF
argument_list|(
operator|(
name|x
operator|&
name|SYMFLG
operator|)
condition|?
name|x
else|:
name|sym
argument_list|)
operator|!=
name|wdval
name|THEN
name|synbad
argument_list|()
expr_stmt|;
name|FI
block|}
end_function

begin_function
name|LOCAL
name|VOID
name|prsym
parameter_list|(
name|sym
parameter_list|)
block|{
name|IF
name|sym
modifier|&
name|SYMFLG
name|THEN
name|REG
name|SYSPTR
name|sp
init|=
name|reserved
decl_stmt|;
name|WHILE
name|sp
operator|->
name|sysval
name|ANDF
name|sp
operator|->
name|sysval
operator|!=
name|sym
name|DO
name|sp
operator|++
name|OD
name|prs
argument_list|(
name|sp
operator|->
name|sysnam
argument_list|)
expr_stmt|;
name|ELIF
name|sym
operator|==
name|EOFSYM
name|THEN
name|prs
argument_list|(
name|endoffile
argument_list|)
expr_stmt|;
name|ELSE
name|IF
name|sym
modifier|&
name|SYMREP
name|THEN
name|prc
argument_list|(
name|sym
argument_list|)
name|FI
name|IF
name|sym
decl|==
name|NL
name|THEN
name|prs
argument_list|(
literal|"newline"
argument_list|)
decl_stmt|;
name|ELSE
name|prc
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|FI
name|FI
block|}
end_function

begin_function
name|LOCAL
name|VOID
name|synbad
parameter_list|()
block|{
name|prp
argument_list|()
expr_stmt|;
name|prs
argument_list|(
name|synmsg
argument_list|)
expr_stmt|;
name|IF
argument_list|(
name|flags
operator|&
name|ttyflg
argument_list|)
operator|==
literal|0
name|THEN
name|prs
argument_list|(
name|atline
argument_list|)
expr_stmt|;
name|prn
argument_list|(
name|standin
operator|->
name|flin
argument_list|)
expr_stmt|;
name|FI
name|prs
argument_list|(
name|colon
argument_list|)
decl_stmt|;
name|prc
argument_list|(
name|LQ
argument_list|)
expr_stmt|;
name|IF
name|wdval
name|THEN
name|prsym
argument_list|(
name|wdval
argument_list|)
decl_stmt|;
name|ELSE
name|prs
argument_list|(
name|wdarg
operator|->
name|argval
argument_list|)
decl_stmt|;
name|FI
name|prc
argument_list|(
name|RQ
argument_list|)
decl_stmt|;
name|prs
argument_list|(
name|unexpected
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|exitsh
argument_list|(
name|SYNBAD
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

