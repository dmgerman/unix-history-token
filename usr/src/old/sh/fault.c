begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)fault.c	4.3 8/11/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#
end_empty

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Bell Telephone Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
name|STRING
name|trapcom
index|[
name|MAXTRAP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BOOL
name|trapflg
index|[
name|MAXTRAP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BOOL
name|trapjmp
index|[
name|MAXTRAP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ========	fault handling routines	   ======== */
end_comment

begin_function
name|VOID
name|fault
parameter_list|(
name|sig
parameter_list|)
name|REG
name|INT
name|sig
decl_stmt|;
block|{
name|REG
name|INT
name|flag
decl_stmt|;
name|IF
name|sig
operator|==
name|MEMF
name|THEN
name|IF
name|setbrk
argument_list|(
name|brkincr
argument_list|)
operator|==
operator|-
literal|1
name|THEN
name|error
argument_list|(
name|nospace
argument_list|)
expr_stmt|;
name|FI
name|ELIF
name|sig
operator|==
name|ALARM
name|THEN
name|IF
name|flags
operator|&
name|waiting
name|THEN
name|done
argument_list|()
expr_stmt|;
name|FI
name|ELSE
name|flag
init|=
operator|(
name|trapcom
index|[
name|sig
index|]
condition|?
name|TRAPSET
else|:
name|SIGSET
operator|)
decl_stmt|;
name|trapnote
operator||=
name|flag
expr_stmt|;
name|trapflg
index|[
name|sig
index|]
operator||=
name|flag
expr_stmt|;
name|FI
name|IF
name|trapjmp
index|[
name|sig
index|]
name|ANDF
name|sig
operator|==
name|INTR
name|THEN
name|trapjmp
index|[
name|sig
index|]
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
name|INTbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FI
block|}
end_function

begin_macro
name|stdsigs
argument_list|()
end_macro

begin_block
block|{
name|ignsig
argument_list|(
name|QUIT
argument_list|)
expr_stmt|;
name|getsig
argument_list|(
name|INTR
argument_list|)
expr_stmt|;
name|getsig
argument_list|(
name|MEMF
argument_list|)
expr_stmt|;
name|getsig
argument_list|(
name|ALARM
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ignsig
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|REG
name|INT
name|s
decl_stmt|,
name|i
decl_stmt|;
name|IF
argument_list|(
name|s
operator|=
name|signal
argument_list|(
name|i
operator|=
name|n
argument_list|,
literal|1
argument_list|)
operator|&
literal|01
argument_list|)
operator|==
literal|0
name|THEN
name|trapflg
index|[
name|i
index|]
operator||=
name|SIGMOD
expr_stmt|;
name|FI
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_macro
name|getsig
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|REG
name|INT
name|i
decl_stmt|;
name|IF
name|trapflg
index|[
name|i
operator|=
name|n
index|]
modifier|&
name|SIGMOD
name|ORF
name|ignsig
argument_list|(
name|i
argument_list|)
decl|==0
name|THEN
name|signal
argument_list|(
name|i
argument_list|,
name|fault
argument_list|)
decl_stmt|;
name|FI
block|}
end_block

begin_macro
name|oldsigs
argument_list|()
end_macro

begin_block
block|{
name|REG
name|INT
name|i
decl_stmt|;
name|REG
name|STRING
name|t
decl_stmt|;
name|i
operator|=
name|MAXTRAP
expr_stmt|;
name|WHILE
name|i
operator|--
name|DO
name|t
operator|=
name|trapcom
index|[
name|i
index|]
expr_stmt|;
name|IF
name|t
operator|==
literal|0
name|ORF
operator|*
name|t
name|THEN
name|clrsig
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|FI
name|trapflg
index|[
name|i
index|]
init|=
literal|0
decl_stmt|;
name|OD
name|trapnote
init|=
literal|0
decl_stmt|;
block|}
end_block

begin_macro
name|clrsig
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|INT
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|free
argument_list|(
name|trapcom
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|trapcom
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|IF
name|trapflg
index|[
name|i
index|]
modifier|&
name|SIGMOD
name|THEN
name|signal
parameter_list|(
name|i
parameter_list|,
name|fault
parameter_list|)
function_decl|;
name|trapflg
index|[
name|i
index|]
operator|&=
operator|~
name|SIGMOD
expr_stmt|;
name|FI
block|}
end_block

begin_macro
name|chktrap
argument_list|()
end_macro

begin_block
block|{
comment|/* check for traps */
name|REG
name|INT
name|i
init|=
name|MAXTRAP
decl_stmt|;
name|REG
name|STRING
name|t
decl_stmt|;
name|trapnote
operator|&=
operator|~
name|TRAPSET
expr_stmt|;
name|WHILE
operator|--
name|i
name|DO
name|IF
name|trapflg
index|[
name|i
index|]
operator|&
name|TRAPSET
name|THEN
name|trapflg
index|[
name|i
index|]
operator|&=
operator|~
name|TRAPSET
expr_stmt|;
name|IF
name|t
init|=
name|trapcom
index|[
name|i
index|]
name|THEN
name|INT
name|savxit
operator|=
name|exitval
decl_stmt|;
name|execexp
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exitval
operator|=
name|savxit
expr_stmt|;
name|exitset
argument_list|()
expr_stmt|;
name|FI
name|FI
name|OD
block|}
end_block

end_unit

