begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ld.c	5.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * ld - string table version for VAX  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<ranlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/*  * Basic strategy:  *  * The loader takes a number of files and libraries as arguments.  * A first pass examines each file in turn.  Normal files are  * unconditionally loaded, and the (external) symbols they define and require  * are noted in the symbol table.   Libraries are searched, and the  * library members which define needed symbols are remembered  * in a special data structure so they can be selected on the second  * pass.  Symbols defined and required by library members are also  * recorded.  *  * After the first pass, the loader knows the size of the basic text  * data, and bss segments from the sum of the sizes of the modules which  * were required.  It has computed, for each ``common'' symbol, the  * maximum size of any reference to it, and these symbols are then assigned  * storage locations after their sizes are appropriately rounded.  * The loader now knows all sizes for the eventual output file, and  * can determine the final locations of external symbols before it  * begins a second pass.  *  * On the second pass each normal file and required library member  * is processed again.  The symbol table for each such file is  * reread and relevant parts of it are placed in the output.  The offsets  * in the local symbol table for externally defined symbols are recorded  * since relocation information refers to symbols in this way.  * Armed with all necessary information, the text and data segments  * are relocated and the result is placed in the output file, which  * is pasted together, ``in place'', by writing to it in several  * different places concurrently.  */
end_comment

begin_comment
comment|/*  * Internal data structures  *  * All internal data structures are segmented and dynamically extended.  * The basic structures hold 1103 (NSYM) symbols, ~~200 (NROUT)  * referenced library members, and 100 (NSYMPR) private (local) symbols  * per object module.  For large programs and/or modules, these structures  * expand to be up to 40 (NSEG) times as large as this as necessary.  */
end_comment

begin_define
define|#
directive|define
name|NSEG
value|40
end_define

begin_comment
comment|/* Number of segments, each data structure */
end_comment

begin_define
define|#
directive|define
name|NSYM
value|1103
end_define

begin_comment
comment|/* Number of symbols per segment */
end_comment

begin_define
define|#
directive|define
name|NROUT
value|250
end_define

begin_comment
comment|/* Number of library references per segment */
end_comment

begin_define
define|#
directive|define
name|NSYMPR
value|100
end_define

begin_comment
comment|/* Number of private symbols per segment */
end_comment

begin_comment
comment|/*  * Structure describing each symbol table segment.  * Each segment has its own hash table.  We record the first  * address in and first address beyond both the symbol and hash  * tables, for use in the routine symx and the lookup routine respectively.  * The symfree routine also understands this structure well as it used  * to back out symbols from modules we decide that we don't need in pass 1.  *  * Csymseg points to the current symbol table segment;  * csymseg->sy_first[csymseg->sy_used] is the next symbol slot to be allocated,  * (unless csymseg->sy_used == NSYM in which case we will allocate another  * symbol table segment first.)  */
end_comment

begin_struct
struct|struct
name|symseg
block|{
name|struct
name|nlist
modifier|*
name|sy_first
decl_stmt|;
comment|/* base of this alloc'ed segment */
name|struct
name|nlist
modifier|*
name|sy_last
decl_stmt|;
comment|/* end of this segment, for n_strx */
name|int
name|sy_used
decl_stmt|;
comment|/* symbols used in this seg */
name|struct
name|nlist
modifier|*
modifier|*
name|sy_hfirst
decl_stmt|;
comment|/* base of hash table, this seg */
name|struct
name|nlist
modifier|*
modifier|*
name|sy_hlast
decl_stmt|;
comment|/* end of hash table, this seg */
block|}
name|symseg
index|[
name|NSEG
index|]
struct|,
modifier|*
name|csymseg
struct|;
end_struct

begin_comment
comment|/*  * The lookup routine uses quadratic rehash.  Since a quadratic rehash  * only probes 1/2 of the buckets in the table, and since the hash  * table is segmented the same way the symbol table is, we make the  * hash table have twice as many buckets as there are symbol table slots  * in the segment.  This guarantees that the quadratic rehash will never  * fail to find an empty bucket if the segment is not full and the  * symbol is not there.  */
end_comment

begin_define
define|#
directive|define
name|HSIZE
value|(NSYM*2)
end_define

begin_comment
comment|/*  * Xsym converts symbol table indices (ala x) into symbol table pointers.  * Symx (harder, but never used in loops) inverts pointers into the symbol  * table into indices using the symseg[] structure.  */
end_comment

begin_define
define|#
directive|define
name|xsym
parameter_list|(
name|x
parameter_list|)
value|(symseg[(x)/NSYM].sy_first+((x)%NSYM))
end_define

begin_comment
comment|/* symx() is a function, defined below */
end_comment

begin_decl_stmt
name|struct
name|nlist
name|cursym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current symbol */
end_comment

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|lastsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last symbol entered */
end_comment

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|nextsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next available symbol table entry */
end_comment

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|addsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first sym defined during incr load */
end_comment

begin_decl_stmt
name|int
name|nsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pass2: number of local symbols in a.out */
end_comment

begin_comment
comment|/* nsym + symx(nextsym) is the symbol table size during pass2 */
end_comment

begin_decl_stmt
name|struct
name|nlist
modifier|*
modifier|*
name|lookup
argument_list|()
decl_stmt|,
modifier|*
modifier|*
name|slookup
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|p_etext
decl_stmt|,
modifier|*
name|p_edata
decl_stmt|,
modifier|*
name|p_end
decl_stmt|,
modifier|*
name|entrypt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Definitions of segmentation for library member table.  * For each library we encounter on pass 1 we record pointers to all  * members which we will load on pass 2.  These are recorded as offsets  * into the archive in the library member table.  Libraries are  * separated in the table by the special offset value -1.  */
end_comment

begin_decl_stmt
name|off_t
name|li_init
index|[
name|NROUT
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|libseg
block|{
name|off_t
modifier|*
name|li_first
decl_stmt|;
name|int
name|li_used
decl_stmt|;
name|int
name|li_used2
decl_stmt|;
block|}
name|libseg
index|[
name|NSEG
index|]
init|=
block|{
name|li_init
block|,
literal|0
block|,
literal|0
block|, }
struct|,
modifier|*
name|clibseg
init|=
name|libseg
struct|;
end_struct

begin_comment
comment|/*  * In processing each module on pass 2 we must relocate references  * relative to external symbols.  These references are recorded  * in the relocation information as relative to local symbol numbers  * assigned to the external symbols when the module was created.  * Thus before relocating the module in pass 2 we create a table  * which maps these internal numbers to symbol table entries.  * A hash table is constructed, based on the local symbol table indices,  * for quick lookup of these symbols.  */
end_comment

begin_define
define|#
directive|define
name|LHSIZ
value|31
end_define

begin_struct
struct|struct
name|local
block|{
name|int
name|l_index
decl_stmt|;
comment|/* index to symbol in file */
name|struct
name|nlist
modifier|*
name|l_symbol
decl_stmt|;
comment|/* ptr to symbol table */
name|struct
name|local
modifier|*
name|l_link
decl_stmt|;
comment|/* hash link */
block|}
modifier|*
name|lochash
index|[
name|LHSIZ
index|]
struct|,
name|lhinit
index|[
name|NSYMPR
index|]
struct|;
end_struct

begin_struct
struct|struct
name|locseg
block|{
name|struct
name|local
modifier|*
name|lo_first
decl_stmt|;
name|int
name|lo_used
decl_stmt|;
block|}
name|locseg
index|[
name|NSEG
index|]
init|=
block|{
name|lhinit
block|,
literal|0
block|}
struct|,
modifier|*
name|clocseg
struct|;
end_struct

begin_comment
comment|/*  * Libraries are typically built with a table of contents,  * which is the first member of a library with special file  * name __.SYMDEF and contains a list of symbol names  * and with each symbol the offset of the library member which defines  * it.  The loader uses this table to quickly tell which library members  * are (potentially) useful.  The alternative, examining the symbol  * table of each library member, is painfully slow for large archives.  *  * See<ranlib.h> for the definition of the ranlib structure and an  * explanation of the __.SYMDEF file format.  */
end_comment

begin_decl_stmt
name|int
name|tnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of symbols in table of contents */
end_comment

begin_decl_stmt
name|int
name|ssiz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of string table for table of contents */
end_comment

begin_decl_stmt
name|struct
name|ranlib
modifier|*
name|tab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the table of contents (dynamically allocated) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tabstr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string table for table of contents */
end_comment

begin_comment
comment|/*  * We open each input file or library only once, but in pass2 we  * (historically) read from such a file at 2 different places at the  * same time.  These structures are remnants from those days,  * and now serve only to catch ``Premature EOF''.  * In order to make I/O more efficient, we provide routines which  * use the optimal block size returned by stat().  */
end_comment

begin_define
define|#
directive|define
name|BLKSIZE
value|1024
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|short
modifier|*
name|fakeptr
decl_stmt|;
name|int
name|bno
decl_stmt|;
name|int
name|nibuf
decl_stmt|;
name|int
name|nuser
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
block|}
name|PAGE
typedef|;
end_typedef

begin_decl_stmt
name|PAGE
name|page
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|p_blksize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|p_blkshift
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|p_blkmask
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|short
modifier|*
name|fakeptr
decl_stmt|;
name|int
name|bno
decl_stmt|;
name|int
name|nibuf
decl_stmt|;
name|int
name|nuser
decl_stmt|;
block|}
name|fpage
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|bno
decl_stmt|;
name|int
name|nibuf
decl_stmt|;
name|long
name|size
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|PAGE
modifier|*
name|pno
decl_stmt|;
block|}
name|STREAM
typedef|;
end_typedef

begin_decl_stmt
name|STREAM
name|text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STREAM
name|reloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Header from the a.out and the archive it is from (if any).  */
end_comment

begin_decl_stmt
name|struct
name|exec
name|filhdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ar_hdr
name|archdr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OARMAG
value|0177545
end_define

begin_comment
comment|/*  * Options.  */
end_comment

begin_decl_stmt
name|int
name|trace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard local symbols */
end_comment

begin_decl_stmt
name|int
name|Xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard locals starting with 'L' */
end_comment

begin_decl_stmt
name|int
name|Sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard all except locals and globals*/
end_comment

begin_decl_stmt
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* preserve relocation bits, don't define common */
end_comment

begin_decl_stmt
name|int
name|arflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original copy of rflag */
end_comment

begin_decl_stmt
name|int
name|sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard all symbols */
end_comment

begin_decl_stmt
name|int
name|Mflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print rudimentary load map */
end_comment

begin_decl_stmt
name|int
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pure procedure */
end_comment

begin_decl_stmt
name|int
name|dflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* define common even with rflag */
end_comment

begin_decl_stmt
name|int
name|zflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* demand paged  */
end_comment

begin_decl_stmt
name|long
name|hsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of hole at beginning of data to be squashed */
end_comment

begin_decl_stmt
name|int
name|Aflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* doing incremental load */
end_comment

begin_decl_stmt
name|int
name|Nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* want impure a.out */
end_comment

begin_decl_stmt
name|int
name|funding
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reading fundamental file for incremental load */
end_comment

begin_decl_stmt
name|int
name|yflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of symbols to be traced */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ytab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the symbols */
end_comment

begin_comment
comment|/*  * These are the cumulative sizes, set in pass 1, which  * appear in the a.out header when the loader is finished.  */
end_comment

begin_decl_stmt
name|off_t
name|tsize
decl_stmt|,
name|dsize
decl_stmt|,
name|bsize
decl_stmt|,
name|trsize
decl_stmt|,
name|drsize
decl_stmt|,
name|ssize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Symbol relocation: c?rel is a scale factor which is  * added to an old relocation to convert it to new units;  * i.e. it is the difference between segment origins.  * (Thus if we are loading from a data segment which began at location  * 4 in a .o file into an a.out where it will be loaded starting at  * 1024, cdrel will be 1020.)  */
end_comment

begin_decl_stmt
name|long
name|ctrel
decl_stmt|,
name|cdrel
decl_stmt|,
name|cbrel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Textbase is the start address of all text, 0 unless given by -T.  * Database is the base of all data, computed before and used during pass2.  */
end_comment

begin_decl_stmt
name|long
name|textbase
decl_stmt|,
name|database
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The base addresses for the loaded text, data and bss from the  * current module during pass2 are given by torigin, dorigin and borigin.  */
end_comment

begin_decl_stmt
name|long
name|torigin
decl_stmt|,
name|dorigin
decl_stmt|,
name|borigin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Errlev is nonzero when errors have occured.  * Delarg is an implicit argument to the routine delexit  * which is called on error.  We do ``delarg = errlev'' before normal  * exits, and only if delarg is 0 (i.e. errlev was 0) do we make the  * result file executable.  */
end_comment

begin_decl_stmt
name|int
name|errlev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delarg
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The biobuf structure and associated routines are used to write  * into one file at several places concurrently.  Calling bopen  * with a biobuf structure sets it up to write ``biofd'' starting  * at the specified offset.  You can then use ``bwrite'' and/or ``bputc''  * to stuff characters in the stream, much like ``fwrite'' and ``fputc''.  * Calling bflush drains all the buffers and MUST be done before exit.  */
end_comment

begin_struct
struct|struct
name|biobuf
block|{
name|short
name|b_nleft
decl_stmt|;
comment|/* Number free spaces left in b_buf */
comment|/* Initialize to be less than b_bufsize initially, to boundary align in file */
name|char
modifier|*
name|b_ptr
decl_stmt|;
comment|/* Next place to stuff characters */
name|char
modifier|*
name|b_buf
decl_stmt|;
comment|/* Pointer to the buffer */
name|int
name|b_bufsize
decl_stmt|;
comment|/* Size of the buffer */
name|off_t
name|b_off
decl_stmt|;
comment|/* Current file offset */
name|struct
name|biobuf
modifier|*
name|b_link
decl_stmt|;
comment|/* Link in chain for bflush() */
block|}
modifier|*
name|biobufs
struct|;
end_struct

begin_define
define|#
directive|define
name|bputc
parameter_list|(
name|c
parameter_list|,
name|b
parameter_list|)
value|((b)->b_nleft ? (--(b)->b_nleft, *(b)->b_ptr++ = (c)) \ 		       : bflushc(b, c))
end_define

begin_decl_stmt
name|int
name|biofd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|off_t
name|boffset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|biobuf
modifier|*
name|tout
decl_stmt|,
modifier|*
name|dout
decl_stmt|,
modifier|*
name|trout
decl_stmt|,
modifier|*
name|drout
decl_stmt|,
modifier|*
name|sout
decl_stmt|,
modifier|*
name|strout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Offset is the current offset in the string file.  * Its initial value reflects the fact that we will  * eventually stuff the size of the string table at the  * beginning of the string table (i.e. offset itself!).  */
end_comment

begin_decl_stmt
name|off_t
name|offset
init|=
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ofilfnd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -o given; otherwise move l.out to a.out */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ofilename
init|=
literal|"l.out"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ofilemode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* respect umask even for unsucessful ld's */
end_comment

begin_decl_stmt
name|int
name|infil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input file descriptor */
end_comment

begin_decl_stmt
name|char
modifier|*
name|filname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and its name */
end_comment

begin_define
define|#
directive|define
name|NDIRS
value|25
end_define

begin_define
define|#
directive|define
name|NDEFDIRS
value|3
end_define

begin_comment
comment|/* number of default directories in dirs[] */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dirs
index|[
name|NDIRS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directories for library search */
end_comment

begin_decl_stmt
name|int
name|ndir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of directories */
end_comment

begin_comment
comment|/*  * Base of the string table of the current module (pass1 and pass2).  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|curstr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * System software page size, as returned by getpagesize.  */
end_comment

begin_decl_stmt
name|int
name|pagesize
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
name|get
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|delexit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|savestr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|int
name|num
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
name|save
decl_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|delexit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|delexit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
comment|/*  	 * Pull out search directories. 	 */
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
name|ap
operator|=
name|argv
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|ap
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|ap
index|[
literal|1
index|]
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
name|ap
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-L: pathname missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndir
operator|>=
name|NDIRS
operator|-
name|NDEFDIRS
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-L: too many directories"
argument_list|)
expr_stmt|;
name|dirs
index|[
name|ndir
operator|++
index|]
operator|=
operator|&
name|ap
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
comment|/* add default search directories */
name|dirs
index|[
name|ndir
operator|++
index|]
operator|=
literal|"/lib"
expr_stmt|;
name|dirs
index|[
name|ndir
operator|++
index|]
operator|=
literal|"/usr/lib"
expr_stmt|;
name|dirs
index|[
name|ndir
operator|++
index|]
operator|=
literal|"/usr/local/lib"
expr_stmt|;
name|p
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Scan files once to find where symbols are defined. 	 */
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|trace
condition|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|filname
operator|=
literal|0
expr_stmt|;
name|ap
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|!=
literal|'-'
condition|)
block|{
name|load1arg
argument_list|(
name|ap
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|ap
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|ap
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'o'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-o where?"
argument_list|)
expr_stmt|;
name|ofilename
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|ofilfnd
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
case|case
literal|'e'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-u or -c: arg missing"
argument_list|)
expr_stmt|;
name|enter
argument_list|(
name|slookup
argument_list|(
operator|*
name|p
operator|++
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|entrypt
operator|=
name|lastsym
expr_stmt|;
continue|continue;
case|case
literal|'H'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-H: arg missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsize
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-H: too late, some text already loaded"
argument_list|)
expr_stmt|;
name|hsize
operator|=
name|atoi
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'A'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-A: arg missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Aflag
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-A: only one base file allowed"
argument_list|)
expr_stmt|;
name|Aflag
operator|=
literal|1
expr_stmt|;
name|nflag
operator|=
literal|0
expr_stmt|;
name|funding
operator|=
literal|1
expr_stmt|;
name|load1arg
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|trsize
operator|=
name|drsize
operator|=
name|tsize
operator|=
name|dsize
operator|=
name|bsize
operator|=
literal|0
expr_stmt|;
name|ctrel
operator|=
name|cdrel
operator|=
name|cbrel
operator|=
literal|0
expr_stmt|;
name|funding
operator|=
literal|0
expr_stmt|;
name|addsym
operator|=
name|nextsym
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-D: arg missing"
argument_list|)
expr_stmt|;
name|num
operator|=
name|htoi
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|>
name|num
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-D: too small"
argument_list|)
expr_stmt|;
name|dsize
operator|=
name|num
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-T: arg missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsize
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-T: too late, some text already loaded"
argument_list|)
expr_stmt|;
name|textbase
operator|=
name|htoi
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
name|save
operator|=
name|ap
index|[
operator|--
name|i
index|]
expr_stmt|;
name|ap
index|[
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
name|load1arg
argument_list|(
operator|&
name|ap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ap
index|[
name|i
index|]
operator|=
name|save
expr_stmt|;
goto|goto
name|next
goto|;
case|case
literal|'M'
case|:
name|Mflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
name|xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'X'
case|:
name|Xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'S'
case|:
name|Sflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|rflag
operator|++
expr_stmt|;
name|arflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|sflag
operator|++
expr_stmt|;
name|xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|nflag
operator|++
expr_stmt|;
name|Nflag
operator|=
name|zflag
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'N'
case|:
name|Nflag
operator|++
expr_stmt|;
name|nflag
operator|=
name|zflag
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|dflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
name|printf
argument_list|(
literal|"ld: -i ignored\n"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
name|trace
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'y'
case|:
if|if
condition|(
name|ap
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"-y: symbol name missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yflag
operator|==
literal|0
condition|)
block|{
name|ytab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|argc
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ytab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (-y)"
argument_list|)
expr_stmt|;
block|}
name|ytab
index|[
name|yflag
operator|++
index|]
operator|=
operator|&
name|ap
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
goto|goto
name|next
goto|;
case|case
literal|'z'
case|:
name|zflag
operator|++
expr_stmt|;
name|Nflag
operator|=
name|nflag
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'L'
case|:
goto|goto
name|next
goto|;
default|default:
name|filname
operator|=
name|savestr
argument_list|(
literal|"-x"
argument_list|)
expr_stmt|;
comment|/* kludge */
name|filname
index|[
literal|1
index|]
operator|=
name|ap
index|[
name|i
index|]
expr_stmt|;
comment|/* kludge */
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* kludge */
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad flag"
argument_list|)
expr_stmt|;
block|}
name|next
label|:
empty_stmt|;
block|}
if|if
condition|(
name|rflag
operator|==
literal|0
operator|&&
name|Nflag
operator|==
literal|0
operator|&&
name|nflag
operator|==
literal|0
condition|)
name|zflag
operator|++
expr_stmt|;
name|endload
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert a ascii string which is a hex number.  * Used by -T and -D options.  */
end_comment

begin_expr_stmt
name|htoi
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
name|n
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|n
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|n
operator|+=
literal|10
operator|+
operator|(
name|c
operator|-
literal|'a'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|n
operator|+=
literal|10
operator|+
operator|(
name|c
operator|-
literal|'A'
operator|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"badly formed hex number"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|delexit
argument_list|()
end_macro

begin_block
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
name|long
name|size
decl_stmt|;
name|char
name|c
init|=
literal|0
decl_stmt|;
name|bflush
argument_list|()
expr_stmt|;
name|unlink
argument_list|(
literal|"l.out"
argument_list|)
expr_stmt|;
comment|/* 	 * We have to insure that the last block of the data segment 	 * is allocated a full pagesize block. If the underlying 	 * file system allocates frags that are smaller than pagesize, 	 * a full zero filled pagesize block needs to be allocated so  	 * that when it is demand paged, the paged in block will be  	 * appropriately filled with zeros. 	 */
name|fstat
argument_list|(
name|biofd
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|size
operator|=
name|round
argument_list|(
name|stbuf
operator|.
name|st_size
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rflag
operator|&&
name|size
operator|>
name|stbuf
operator|.
name|st_size
condition|)
block|{
name|lseek
argument_list|(
name|biofd
argument_list|,
name|size
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|biofd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|delarg
operator||=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|delarg
operator|==
literal|0
operator|&&
name|Aflag
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|ofilename
argument_list|,
name|ofilemode
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|delarg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|endload
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|long
name|dnum
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|clibseg
operator|=
name|libseg
expr_stmt|;
name|filname
operator|=
literal|0
expr_stmt|;
name|middle
argument_list|()
expr_stmt|;
name|setupout
argument_list|()
expr_stmt|;
name|p
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
name|ap
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|!=
literal|'-'
condition|)
block|{
name|load2arg
argument_list|(
name|ap
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|ap
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|ap
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'D'
case|:
name|dnum
operator|=
name|htoi
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dorigin
operator|<
name|dnum
condition|)
while|while
condition|(
name|dorigin
operator|<
name|dnum
condition|)
name|bputc
argument_list|(
literal|0
argument_list|,
name|dout
argument_list|)
operator|,
name|dorigin
operator|++
expr_stmt|;
comment|/* fall into ... */
case|case
literal|'T'
case|:
case|case
literal|'u'
case|:
case|case
literal|'e'
case|:
case|case
literal|'o'
case|:
case|case
literal|'H'
case|:
operator|++
name|c
expr_stmt|;
operator|++
name|p
expr_stmt|;
comment|/* fall into ... */
default|default:
continue|continue;
case|case
literal|'A'
case|:
name|funding
operator|=
literal|1
expr_stmt|;
name|load2arg
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|funding
operator|=
literal|0
expr_stmt|;
name|c
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'y'
case|:
case|case
literal|'L'
case|:
goto|goto
name|next
goto|;
case|case
literal|'l'
case|:
name|ap
index|[
operator|--
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
name|load2arg
argument_list|(
operator|&
name|ap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|next
label|:
empty_stmt|;
block|}
name|finishout
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Scan file to find defined symbols.  */
end_comment

begin_expr_stmt
name|load1arg
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ranlib
modifier|*
name|tp
decl_stmt|;
name|off_t
name|nloc
decl_stmt|;
name|int
name|kind
decl_stmt|;
name|kind
operator|=
name|getfile
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mflag
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|filname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
comment|/* 	 * Plain file. 	 */
case|case
literal|0
case|:
name|load1
argument_list|(
literal|0
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Archive without table of contents. 	 * (Slowly) process each member. 	 */
case|case
literal|1
case|:
name|error
argument_list|(
operator|-
literal|1
argument_list|,
literal|"warning: archive has no table of contents; add one using ranlib(1)"
argument_list|)
expr_stmt|;
name|nloc
operator|=
name|SARMAG
expr_stmt|;
while|while
condition|(
name|step
argument_list|(
name|nloc
argument_list|)
condition|)
name|nloc
operator|+=
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
operator|+
name|round
argument_list|(
name|atol
argument_list|(
name|archdr
operator|.
name|ar_size
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Archive with table of contents. 	 * Read the table of contents and its associated string table. 	 * Pass through the library resolving symbols until nothing changes 	 * for an entire pass (i.e. you can get away with backward references 	 * when there is a table of contents!) 	 */
case|case
literal|2
case|:
name|nloc
operator|=
name|SARMAG
operator|+
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|nloc
argument_list|,
sizeof|sizeof
argument_list|(
name|tnum
argument_list|)
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tnum
argument_list|,
sizeof|sizeof
argument_list|(
name|tnum
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|nloc
operator|+=
sizeof|sizeof
argument_list|(
name|tnum
argument_list|)
expr_stmt|;
name|tab
operator|=
operator|(
expr|struct
name|ranlib
operator|*
operator|)
name|malloc
argument_list|(
name|tnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (toc)"
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|nloc
argument_list|,
name|tnum
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|,
name|tnum
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|nloc
operator|+=
name|tnum
expr_stmt|;
name|tnum
operator|/=
sizeof|sizeof
argument_list|(
expr|struct
name|ranlib
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|nloc
argument_list|,
sizeof|sizeof
argument_list|(
name|ssiz
argument_list|)
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ssiz
argument_list|,
sizeof|sizeof
argument_list|(
name|ssiz
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|nloc
operator|+=
sizeof|sizeof
argument_list|(
name|ssiz
argument_list|)
expr_stmt|;
name|tabstr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|ssiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|tabstr
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (tocstr)"
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|nloc
argument_list|,
name|ssiz
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tabstr
argument_list|,
name|ssiz
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
operator|&
name|tab
index|[
name|tnum
index|]
init|;
operator|--
name|tp
operator|>=
name|tab
condition|;
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|ran_un
operator|.
name|ran_strx
operator|<
literal|0
operator|||
name|tp
operator|->
name|ran_un
operator|.
name|ran_strx
operator|>=
name|ssiz
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"mangled archive table of contents"
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ran_un
operator|.
name|ran_name
operator|=
name|tabstr
operator|+
name|tp
operator|->
name|ran_un
operator|.
name|ran_strx
expr_stmt|;
block|}
while|while
condition|(
name|ldrand
argument_list|()
condition|)
continue|continue;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tabstr
argument_list|)
expr_stmt|;
name|nextlibp
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Table of contents is out of date, so search 	 * as a normal library (but skip the __.SYMDEF file). 	 */
case|case
literal|3
case|:
name|error
argument_list|(
operator|-
literal|1
argument_list|,
literal|"warning: table of contents for archive is out of date; rerun ranlib(1)"
argument_list|)
expr_stmt|;
name|nloc
operator|=
name|SARMAG
expr_stmt|;
do|do
name|nloc
operator|+=
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
operator|+
name|round
argument_list|(
name|atol
argument_list|(
name|archdr
operator|.
name|ar_size
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
do|while
condition|(
name|step
argument_list|(
name|nloc
argument_list|)
condition|)
do|;
break|break;
block|}
name|close
argument_list|(
name|infil
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Advance to the next archive member, which  * is at offset nloc in the archive.  If the member  * is useful, record its location in the liblist structure  * for use in pass2.  Mark the end of the archive in libilst with a -1.  */
end_comment

begin_macro
name|step
argument_list|(
argument|nloc
argument_list|)
end_macro

begin_decl_stmt
name|off_t
name|nloc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|nloc
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
block|{
name|nextlibp
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|getarhdr
argument_list|()
expr_stmt|;
if|if
condition|(
name|load1
argument_list|(
literal|1
argument_list|,
name|nloc
operator|+
operator|(
sizeof|sizeof
name|archdr
operator|)
argument_list|)
condition|)
name|nextlibp
argument_list|(
name|nloc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Record the location of a useful archive member.  * Recording -1 marks the end of files from an archive.  * The liblist data structure is dynamically extended here.  */
end_comment

begin_macro
name|nextlibp
argument_list|(
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|off_t
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|clibseg
operator|->
name|li_used
operator|==
name|NROUT
condition|)
block|{
if|if
condition|(
operator|++
name|clibseg
operator|==
operator|&
name|libseg
index|[
name|NSEG
index|]
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"too many files loaded from libraries"
argument_list|)
expr_stmt|;
name|clibseg
operator|->
name|li_first
operator|=
operator|(
name|off_t
operator|*
operator|)
name|malloc
argument_list|(
name|NROUT
operator|*
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clibseg
operator|->
name|li_first
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (nextlibp)"
argument_list|)
expr_stmt|;
block|}
name|clibseg
operator|->
name|li_first
index|[
name|clibseg
operator|->
name|li_used
operator|++
index|]
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|val
operator|!=
operator|-
literal|1
operator|&&
name|Mflag
condition|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|archdr
operator|.
name|ar_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * One pass over an archive with a table of contents.  * Remember the number of symbols currently defined,  * then call step on members which look promising (i.e.  * that define a symbol which is currently externally undefined).  * Indicate to our caller whether this process netted any more symbols.  */
end_comment

begin_macro
name|ldrand
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|,
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|ranlib
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tplast
decl_stmt|;
name|off_t
name|loc
decl_stmt|;
name|int
name|nsymt
init|=
name|symx
argument_list|(
name|nextsym
argument_list|)
decl_stmt|;
name|tplast
operator|=
operator|&
name|tab
index|[
name|tnum
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|tab
init|;
name|tp
operator|<=
name|tplast
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|slookup
argument_list|(
name|tp
operator|->
name|ran_un
operator|.
name|ran_name
argument_list|)
operator|)
operator|==
literal|0
operator|||
operator|*
name|hp
operator|==
literal|0
condition|)
continue|continue;
name|sp
operator|=
operator|*
name|hp
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
condition|)
continue|continue;
name|step
argument_list|(
name|tp
operator|->
name|ran_off
argument_list|)
expr_stmt|;
name|loc
operator|=
name|tp
operator|->
name|ran_off
expr_stmt|;
while|while
condition|(
name|tp
operator|<
name|tplast
operator|&&
operator|(
name|tp
operator|+
literal|1
operator|)
operator|->
name|ran_off
operator|==
name|loc
condition|)
name|tp
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|symx
argument_list|(
name|nextsym
argument_list|)
operator|!=
name|nsymt
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Examine a single file or archive member on pass 1.  */
end_comment

begin_macro
name|load1
argument_list|(
argument|libflg
argument_list|,
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|off_t
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|struct
name|nlist
modifier|*
name|savnext
decl_stmt|;
name|int
name|ndef
decl_stmt|,
name|nlocal
decl_stmt|,
name|type
decl_stmt|,
name|size
decl_stmt|,
name|nsymt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|off_t
name|maxoff
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|readhdr
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|filhdr
operator|.
name|a_syms
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
argument_list|(
literal|1
argument_list|,
literal|"no namelist"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|libflg
condition|)
name|maxoff
operator|=
name|atol
argument_list|(
name|archdr
operator|.
name|ar_size
argument_list|)
expr_stmt|;
else|else
block|{
name|fstat
argument_list|(
name|infil
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
name|maxoff
operator|=
name|stb
operator|.
name|st_size
expr_stmt|;
block|}
if|if
condition|(
name|N_STROFF
argument_list|(
name|filhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
operator|>=
name|maxoff
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"too small (old format .o?)"
argument_list|)
expr_stmt|;
name|ctrel
operator|=
name|tsize
expr_stmt|;
name|cdrel
operator|+=
name|dsize
expr_stmt|;
name|cbrel
operator|+=
name|bsize
expr_stmt|;
name|ndef
operator|=
literal|0
expr_stmt|;
name|nlocal
operator|=
sizeof|sizeof
argument_list|(
name|cursym
argument_list|)
expr_stmt|;
name|savnext
operator|=
name|nextsym
expr_stmt|;
name|loc
operator|+=
name|N_SYMOFF
argument_list|(
name|filhdr
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
name|filhdr
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_syms
argument_list|,
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|&
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|size
argument_list|)
argument_list|,
operator|&
name|reloc
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_syms
operator|+
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
name|curstr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|curstr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"no space for string table"
argument_list|)
expr_stmt|;
name|mget
argument_list|(
name|curstr
operator|+
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
operator|&
name|reloc
argument_list|)
expr_stmt|;
while|while
condition|(
name|text
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cursym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
condition|)
block|{
if|if
condition|(
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|<
sizeof|sizeof
argument_list|(
name|size
argument_list|)
operator|||
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|>=
name|size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad string table index (pass 1)"
argument_list|)
expr_stmt|;
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|curstr
operator|+
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
block|}
name|type
operator|=
name|cursym
operator|.
name|n_type
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|N_EXT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Xflag
operator|==
literal|0
operator|||
name|cursym
operator|.
name|n_un
operator|.
name|n_name
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|||
name|type
operator|&
name|N_STAB
condition|)
name|nlocal
operator|+=
sizeof|sizeof
name|cursym
expr_stmt|;
continue|continue;
block|}
name|symreloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|enter
argument_list|(
name|lookup
argument_list|()
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|=
name|lastsym
operator|)
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
condition|)
continue|continue;
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|==
name|N_EXT
operator|+
name|N_UNDF
condition|)
block|{
if|if
condition|(
name|cursym
operator|.
name|n_value
operator|>
name|sp
operator|->
name|n_value
condition|)
name|sp
operator|->
name|n_value
operator|=
name|cursym
operator|.
name|n_value
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|n_value
operator|!=
literal|0
operator|&&
name|cursym
operator|.
name|n_type
operator|==
name|N_EXT
operator|+
name|N_TEXT
condition|)
continue|continue;
name|ndef
operator|++
expr_stmt|;
name|sp
operator|->
name|n_type
operator|=
name|cursym
operator|.
name|n_type
expr_stmt|;
name|sp
operator|->
name|n_value
operator|=
name|cursym
operator|.
name|n_value
expr_stmt|;
block|}
if|if
condition|(
name|libflg
operator|==
literal|0
operator|||
name|ndef
condition|)
block|{
name|tsize
operator|+=
name|filhdr
operator|.
name|a_text
expr_stmt|;
name|dsize
operator|+=
name|round
argument_list|(
name|filhdr
operator|.
name|a_data
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|bsize
operator|+=
name|round
argument_list|(
name|filhdr
operator|.
name|a_bss
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|ssize
operator|+=
name|nlocal
expr_stmt|;
name|trsize
operator|+=
name|filhdr
operator|.
name|a_trsize
expr_stmt|;
name|drsize
operator|+=
name|filhdr
operator|.
name|a_drsize
expr_stmt|;
if|if
condition|(
name|funding
condition|)
name|textbase
operator|=
operator|(
operator|*
name|slookup
argument_list|(
literal|"_end"
argument_list|)
operator|)
operator|->
name|n_value
expr_stmt|;
name|nsymt
operator|=
name|symx
argument_list|(
name|nextsym
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|symx
argument_list|(
name|savnext
argument_list|)
init|;
name|i
operator|<
name|nsymt
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|xsym
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|sp
operator|->
name|n_un
operator|.
name|n_name
operator|=
name|savestr
argument_list|(
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|curstr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * No symbols defined by this library member. 	 * Rip out the hash table entries and reset the symbol table. 	 */
name|symfree
argument_list|(
name|savnext
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curstr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|middle
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|long
name|csize
decl_stmt|,
name|t
decl_stmt|,
name|corigin
decl_stmt|,
name|ocsize
decl_stmt|;
name|int
name|nund
decl_stmt|,
name|rnd
decl_stmt|;
name|char
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|nsymt
decl_stmt|;
name|torigin
operator|=
literal|0
expr_stmt|;
name|dorigin
operator|=
literal|0
expr_stmt|;
name|borigin
operator|=
literal|0
expr_stmt|;
name|p_etext
operator|=
operator|*
name|slookup
argument_list|(
literal|"_etext"
argument_list|)
expr_stmt|;
name|p_edata
operator|=
operator|*
name|slookup
argument_list|(
literal|"_edata"
argument_list|)
expr_stmt|;
name|p_end
operator|=
operator|*
name|slookup
argument_list|(
literal|"_end"
argument_list|)
expr_stmt|;
comment|/* 	 * If there are any undefined symbols, save the relocation bits. 	 */
name|nsymt
operator|=
name|symx
argument_list|(
name|nextsym
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsymt
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|xsym
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|n_type
operator|==
name|N_EXT
operator|+
name|N_UNDF
operator|&&
name|sp
operator|->
name|n_value
operator|==
literal|0
operator|&&
name|sp
operator|!=
name|p_end
operator|&&
name|sp
operator|!=
name|p_edata
operator|&&
name|sp
operator|!=
name|p_etext
condition|)
block|{
name|rflag
operator|++
expr_stmt|;
name|dflag
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|rflag
condition|)
name|sflag
operator|=
name|zflag
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Assign common locations. 	 */
name|csize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|Aflag
condition|)
name|addsym
operator|=
name|symseg
index|[
literal|0
index|]
operator|.
name|sy_first
expr_stmt|;
name|database
operator|=
name|round
argument_list|(
name|tsize
operator|+
name|textbase
argument_list|,
operator|(
name|nflag
operator|||
name|zflag
condition|?
name|pagesize
else|:
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|database
operator|+=
name|hsize
expr_stmt|;
if|if
condition|(
name|dflag
operator|||
name|rflag
operator|==
literal|0
condition|)
block|{
name|ldrsym
argument_list|(
name|p_etext
argument_list|,
name|tsize
argument_list|,
name|N_EXT
operator|+
name|N_TEXT
argument_list|)
expr_stmt|;
name|ldrsym
argument_list|(
name|p_edata
argument_list|,
name|dsize
argument_list|,
name|N_EXT
operator|+
name|N_DATA
argument_list|)
expr_stmt|;
name|ldrsym
argument_list|(
name|p_end
argument_list|,
name|bsize
argument_list|,
name|N_EXT
operator|+
name|N_BSS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|symx
argument_list|(
name|addsym
argument_list|)
init|;
name|i
operator|<
name|nsymt
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|xsym
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|sp
operator|->
name|n_type
operator|)
operator|==
name|N_EXT
operator|+
name|N_UNDF
operator|&&
operator|(
name|t
operator|=
name|sp
operator|->
name|n_value
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|t
operator|>=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|rnd
operator|=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|>=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|rnd
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
else|else
name|rnd
operator|=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|csize
operator|=
name|round
argument_list|(
name|csize
argument_list|,
name|rnd
argument_list|)
expr_stmt|;
name|sp
operator|->
name|n_value
operator|=
name|csize
expr_stmt|;
name|sp
operator|->
name|n_type
operator|=
name|N_EXT
operator|+
name|N_COMM
expr_stmt|;
name|ocsize
operator|=
name|csize
expr_stmt|;
name|csize
operator|+=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|&
name|N_EXT
operator|&&
operator|(
name|s
operator|&
name|N_TYPE
operator|)
operator|==
name|N_UNDF
operator|&&
name|s
operator|&
name|N_STAB
condition|)
block|{
name|sp
operator|->
name|n_value
operator|=
name|ocsize
expr_stmt|;
name|sp
operator|->
name|n_type
operator|=
operator|(
name|s
operator|&
name|N_STAB
operator|)
operator||
operator|(
name|N_EXT
operator|+
name|N_COMM
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Now set symbols to their final value 	 */
name|csize
operator|=
name|round
argument_list|(
name|csize
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|torigin
operator|=
name|textbase
expr_stmt|;
name|dorigin
operator|=
name|database
expr_stmt|;
name|corigin
operator|=
name|dorigin
operator|+
name|dsize
expr_stmt|;
name|borigin
operator|=
name|corigin
operator|+
name|csize
expr_stmt|;
name|nund
operator|=
literal|0
expr_stmt|;
name|nsymt
operator|=
name|symx
argument_list|(
name|nextsym
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|symx
argument_list|(
name|addsym
argument_list|)
init|;
name|i
operator|<
name|nsymt
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|xsym
argument_list|(
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|n_type
operator|&
operator|(
name|N_TYPE
operator|+
name|N_EXT
operator|)
condition|)
block|{
case|case
name|N_EXT
operator|+
name|N_UNDF
case|:
if|if
condition|(
name|arflag
operator|==
literal|0
condition|)
name|errlev
operator||=
literal|01
expr_stmt|;
if|if
condition|(
operator|(
name|arflag
operator|==
literal|0
operator|||
name|dflag
operator|)
operator|&&
name|sp
operator|->
name|n_value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|==
name|p_end
operator|||
name|sp
operator|==
name|p_etext
operator|||
name|sp
operator|==
name|p_edata
condition|)
continue|continue;
if|if
condition|(
name|nund
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Undefined:\n"
argument_list|)
expr_stmt|;
name|nund
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|N_EXT
operator|+
name|N_ABS
case|:
default|default:
continue|continue;
case|case
name|N_EXT
operator|+
name|N_TEXT
case|:
name|sp
operator|->
name|n_value
operator|+=
name|torigin
expr_stmt|;
continue|continue;
case|case
name|N_EXT
operator|+
name|N_DATA
case|:
name|sp
operator|->
name|n_value
operator|+=
name|dorigin
expr_stmt|;
continue|continue;
case|case
name|N_EXT
operator|+
name|N_BSS
case|:
name|sp
operator|->
name|n_value
operator|+=
name|borigin
expr_stmt|;
continue|continue;
case|case
name|N_EXT
operator|+
name|N_COMM
case|:
name|sp
operator|->
name|n_type
operator|=
operator|(
name|sp
operator|->
name|n_type
operator|&
name|N_STAB
operator|)
operator||
operator|(
name|N_EXT
operator|+
name|N_BSS
operator|)
expr_stmt|;
name|sp
operator|->
name|n_value
operator|+=
name|corigin
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|sflag
operator|||
name|xflag
condition|)
name|ssize
operator|=
literal|0
expr_stmt|;
name|bsize
operator|+=
name|csize
expr_stmt|;
name|nsym
operator|=
name|ssize
operator|/
operator|(
sizeof|sizeof
name|cursym
operator|)
expr_stmt|;
if|if
condition|(
name|Aflag
condition|)
block|{
name|fixspec
argument_list|(
name|p_etext
argument_list|,
name|torigin
argument_list|)
expr_stmt|;
name|fixspec
argument_list|(
name|p_edata
argument_list|,
name|dorigin
argument_list|)
expr_stmt|;
name|fixspec
argument_list|(
name|p_end
argument_list|,
name|borigin
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|fixspec
argument_list|(
argument|sym
argument_list|,
argument|offset
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|sym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|symx
argument_list|(
name|sym
argument_list|)
operator|<
name|symx
argument_list|(
name|addsym
argument_list|)
operator|&&
name|sym
operator|!=
literal|0
condition|)
name|sym
operator|->
name|n_value
operator|+=
name|offset
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ldrsym
argument_list|(
name|sp
argument_list|,
name|val
argument_list|,
name|type
argument_list|)
specifier|register
expr|struct
name|nlist
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|long
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|sp
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_UNDF
operator|||
name|sp
operator|->
name|n_value
operator|)
operator|&&
operator|!
name|Aflag
condition|)
block|{
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|"user attempt to redfine loader-defined symbol"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|n_type
operator|=
name|type
expr_stmt|;
name|sp
operator|->
name|n_value
operator|=
name|val
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|off_t
name|wroff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|biobuf
name|toutb
decl_stmt|;
end_decl_stmt

begin_macro
name|setupout
argument_list|()
end_macro

begin_block
block|{
name|int
name|bss
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|ofilemode
operator|=
literal|0777
operator|&
operator|~
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|biofd
operator|=
name|creat
argument_list|(
name|ofilename
argument_list|,
literal|0666
operator|&
name|ofilemode
argument_list|)
expr_stmt|;
if|if
condition|(
name|biofd
operator|<
literal|0
condition|)
block|{
name|filname
operator|=
name|ofilename
expr_stmt|;
comment|/* kludge */
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* kludge */
name|error
argument_list|(
literal|1
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
comment|/* kludge */
block|}
name|fstat
argument_list|(
name|biofd
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
comment|/* suppose file exists, wrong*/
if|if
condition|(
name|stbuf
operator|.
name|st_mode
operator|&
literal|0111
condition|)
block|{
comment|/* mode, ld fails? */
name|chmod
argument_list|(
name|ofilename
argument_list|,
name|stbuf
operator|.
name|st_mode
operator|&
literal|0666
argument_list|)
expr_stmt|;
name|ofilemode
operator|=
name|stbuf
operator|.
name|st_mode
expr_stmt|;
block|}
name|filhdr
operator|.
name|a_magic
operator|=
name|nflag
condition|?
name|NMAGIC
else|:
operator|(
name|zflag
condition|?
name|ZMAGIC
else|:
name|OMAGIC
operator|)
expr_stmt|;
name|filhdr
operator|.
name|a_text
operator|=
name|nflag
condition|?
name|tsize
else|:
name|round
argument_list|(
name|tsize
argument_list|,
name|zflag
condition|?
name|pagesize
else|:
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|filhdr
operator|.
name|a_data
operator|=
name|zflag
condition|?
name|round
argument_list|(
name|dsize
argument_list|,
name|pagesize
argument_list|)
else|:
name|dsize
expr_stmt|;
name|bss
operator|=
name|bsize
operator|-
operator|(
name|filhdr
operator|.
name|a_data
operator|-
name|dsize
operator|)
expr_stmt|;
if|if
condition|(
name|bss
operator|<
literal|0
condition|)
name|bss
operator|=
literal|0
expr_stmt|;
name|filhdr
operator|.
name|a_bss
operator|=
name|bss
expr_stmt|;
name|filhdr
operator|.
name|a_trsize
operator|=
name|trsize
expr_stmt|;
name|filhdr
operator|.
name|a_drsize
operator|=
name|drsize
expr_stmt|;
name|filhdr
operator|.
name|a_syms
operator|=
name|sflag
condition|?
literal|0
else|:
operator|(
name|ssize
operator|+
operator|(
sizeof|sizeof
name|cursym
operator|)
operator|*
name|symx
argument_list|(
name|nextsym
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|entrypt
condition|)
block|{
if|if
condition|(
name|entrypt
operator|->
name|n_type
operator|!=
name|N_EXT
operator|+
name|N_TEXT
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"entry point not in text"
argument_list|)
expr_stmt|;
else|else
name|filhdr
operator|.
name|a_entry
operator|=
name|entrypt
operator|->
name|n_value
expr_stmt|;
block|}
else|else
name|filhdr
operator|.
name|a_entry
operator|=
literal|0
expr_stmt|;
name|filhdr
operator|.
name|a_trsize
operator|=
operator|(
name|rflag
condition|?
name|trsize
else|:
literal|0
operator|)
expr_stmt|;
name|filhdr
operator|.
name|a_drsize
operator|=
operator|(
name|rflag
condition|?
name|drsize
else|:
literal|0
operator|)
expr_stmt|;
name|tout
operator|=
operator|&
name|toutb
expr_stmt|;
name|bopen
argument_list|(
name|tout
argument_list|,
literal|0
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|filhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|filhdr
argument_list|)
argument_list|,
name|tout
argument_list|)
expr_stmt|;
if|if
condition|(
name|zflag
condition|)
name|bseek
argument_list|(
name|tout
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
name|wroff
operator|=
name|N_TXTOFF
argument_list|(
name|filhdr
argument_list|)
operator|+
name|filhdr
operator|.
name|a_text
expr_stmt|;
name|outb
argument_list|(
operator|&
name|dout
argument_list|,
name|filhdr
operator|.
name|a_data
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|outb
argument_list|(
operator|&
name|trout
argument_list|,
name|filhdr
operator|.
name|a_trsize
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|&
name|drout
argument_list|,
name|filhdr
operator|.
name|a_drsize
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sflag
operator|==
literal|0
operator|||
name|xflag
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
operator|&
name|sout
argument_list|,
name|filhdr
operator|.
name|a_syms
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
name|wroff
operator|+=
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|&
name|strout
argument_list|,
literal|0
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|outb
argument_list|(
name|bp
argument_list|,
name|inc
argument_list|,
name|bufsize
argument_list|)
specifier|register
expr|struct
name|biobuf
operator|*
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|*
name|bp
operator|=
operator|(
expr|struct
name|biobuf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|biobuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (outb)"
argument_list|)
expr_stmt|;
name|bopen
argument_list|(
operator|*
name|bp
argument_list|,
name|wroff
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|wroff
operator|+=
name|inc
expr_stmt|;
block|}
end_block

begin_macro
name|load2arg
argument_list|(
argument|acp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|acp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|off_t
name|loc
decl_stmt|;
name|cp
operator|=
name|acp
expr_stmt|;
if|if
condition|(
name|getfile
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|cp
operator|>=
name|acp
operator|&&
operator|*
operator|--
name|cp
operator|!=
literal|'/'
condition|)
empty_stmt|;
name|mkfsym
argument_list|(
operator|++
name|cp
argument_list|)
expr_stmt|;
name|load2
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* scan archive members referenced */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|clibseg
operator|->
name|li_used2
operator|==
name|clibseg
operator|->
name|li_used
condition|)
block|{
if|if
condition|(
name|clibseg
operator|->
name|li_used
operator|<
name|NROUT
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"libseg botch"
argument_list|)
expr_stmt|;
name|clibseg
operator|++
expr_stmt|;
block|}
name|loc
operator|=
name|clibseg
operator|->
name|li_first
index|[
name|clibseg
operator|->
name|li_used2
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|loc
operator|==
operator|-
literal|1
condition|)
break|break;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
argument_list|)
expr_stmt|;
name|getarhdr
argument_list|()
expr_stmt|;
name|mkfsym
argument_list|(
name|archdr
operator|.
name|ar_name
argument_list|)
expr_stmt|;
name|load2
argument_list|(
name|loc
operator|+
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|infil
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|load2
argument_list|(
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|long
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|size
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|local
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|symno
decl_stmt|,
name|i
decl_stmt|;
name|int
name|type
decl_stmt|;
name|readhdr
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|funding
condition|)
block|{
name|ctrel
operator|=
name|torigin
expr_stmt|;
name|cdrel
operator|+=
name|dorigin
expr_stmt|;
name|cbrel
operator|+=
name|borigin
expr_stmt|;
block|}
comment|/* 	 * Reread the symbol table, recording the numbering 	 * of symbols for fixing external references. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LHSIZ
condition|;
name|i
operator|++
control|)
name|lochash
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|clocseg
operator|=
name|locseg
expr_stmt|;
name|clocseg
operator|->
name|lo_used
operator|=
literal|0
expr_stmt|;
name|symno
operator|=
operator|-
literal|1
expr_stmt|;
name|loc
operator|+=
name|N_TXTOFF
argument_list|(
name|filhdr
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
operator|+
name|filhdr
operator|.
name|a_drsize
operator|+
name|filhdr
operator|.
name|a_syms
argument_list|,
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|&
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|size
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
operator|+
name|filhdr
operator|.
name|a_drsize
operator|+
name|filhdr
operator|.
name|a_syms
operator|+
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
name|curstr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|curstr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of space reading string table (pass 2)"
argument_list|)
expr_stmt|;
name|mget
argument_list|(
name|curstr
operator|+
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
operator|+
name|filhdr
operator|.
name|a_drsize
argument_list|,
name|filhdr
operator|.
name|a_syms
argument_list|)
expr_stmt|;
while|while
condition|(
name|text
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|symno
operator|++
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cursym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
condition|)
block|{
if|if
condition|(
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|<
sizeof|sizeof
argument_list|(
name|size
argument_list|)
operator|||
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
operator|>=
name|size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad string table index (pass 2)"
argument_list|)
expr_stmt|;
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|curstr
operator|+
name|cursym
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
block|}
comment|/* inline expansion of symreloc() */
switch|switch
condition|(
name|cursym
operator|.
name|n_type
operator|&
literal|017
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_EXT
operator|+
name|N_TEXT
case|:
name|cursym
operator|.
name|n_value
operator|+=
name|ctrel
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
case|case
name|N_EXT
operator|+
name|N_DATA
case|:
name|cursym
operator|.
name|n_value
operator|+=
name|cdrel
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
case|case
name|N_EXT
operator|+
name|N_BSS
case|:
name|cursym
operator|.
name|n_value
operator|+=
name|cbrel
expr_stmt|;
break|break;
case|case
name|N_EXT
operator|+
name|N_UNDF
case|:
break|break;
default|default:
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|&
name|N_EXT
condition|)
name|cursym
operator|.
name|n_type
operator|=
name|N_EXT
operator|+
name|N_ABS
expr_stmt|;
block|}
comment|/* end inline expansion of symreloc() */
name|type
operator|=
name|cursym
operator|.
name|n_type
expr_stmt|;
if|if
condition|(
name|yflag
operator|&&
name|cursym
operator|.
name|n_un
operator|.
name|n_name
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|yflag
condition|;
name|i
operator|++
control|)
comment|/* fast check for 2d character! */
if|if
condition|(
name|ytab
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
name|cursym
operator|.
name|n_un
operator|.
name|n_name
index|[
literal|1
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|ytab
index|[
name|i
index|]
argument_list|,
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
condition|)
block|{
name|tracesym
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|N_EXT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|sflag
operator|&&
operator|!
name|xflag
operator|&&
operator|(
operator|!
name|Xflag
operator|||
name|cursym
operator|.
name|n_un
operator|.
name|n_name
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|||
name|type
operator|&
name|N_STAB
operator|)
condition|)
name|symwrite
argument_list|(
operator|&
name|cursym
argument_list|,
name|sout
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|funding
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|lookup
argument_list|()
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"internal error: symbol not found"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|==
name|N_EXT
operator|+
name|N_UNDF
condition|)
block|{
if|if
condition|(
name|clocseg
operator|->
name|lo_used
operator|==
name|NSYMPR
condition|)
block|{
if|if
condition|(
operator|++
name|clocseg
operator|==
operator|&
name|locseg
index|[
name|NSEG
index|]
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"local symbol overflow"
argument_list|)
expr_stmt|;
name|clocseg
operator|->
name|lo_used
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|clocseg
operator|->
name|lo_first
operator|==
literal|0
condition|)
block|{
name|clocseg
operator|->
name|lo_first
operator|=
operator|(
expr|struct
name|local
operator|*
operator|)
name|malloc
argument_list|(
name|NSYMPR
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|local
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clocseg
operator|->
name|lo_first
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of memory (clocseg)"
argument_list|)
expr_stmt|;
block|}
name|lp
operator|=
operator|&
name|clocseg
operator|->
name|lo_first
index|[
name|clocseg
operator|->
name|lo_used
operator|++
index|]
expr_stmt|;
name|lp
operator|->
name|l_index
operator|=
name|symno
expr_stmt|;
name|lp
operator|->
name|l_symbol
operator|=
name|sp
expr_stmt|;
name|lp
operator|->
name|l_link
operator|=
name|lochash
index|[
name|symno
operator|%
name|LHSIZ
index|]
expr_stmt|;
name|lochash
index|[
name|symno
operator|%
name|LHSIZ
index|]
operator|=
name|lp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|&
name|N_STAB
condition|)
continue|continue;
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|!=
name|sp
operator|->
name|n_type
operator|||
name|cursym
operator|.
name|n_value
operator|!=
name|sp
operator|->
name|n_value
condition|)
block|{
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|"multiply defined"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|funding
condition|)
return|return;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
name|filhdr
operator|.
name|a_text
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
argument_list|,
name|filhdr
operator|.
name|a_trsize
argument_list|)
expr_stmt|;
name|load2td
argument_list|(
name|ctrel
argument_list|,
name|torigin
operator|-
name|textbase
argument_list|,
name|tout
argument_list|,
name|trout
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
argument_list|,
name|filhdr
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|a_text
operator|+
name|filhdr
operator|.
name|a_data
operator|+
name|filhdr
operator|.
name|a_trsize
argument_list|,
name|filhdr
operator|.
name|a_drsize
argument_list|)
expr_stmt|;
name|load2td
argument_list|(
name|cdrel
argument_list|,
name|dorigin
operator|-
name|database
argument_list|,
name|dout
argument_list|,
name|drout
argument_list|)
expr_stmt|;
while|while
condition|(
name|filhdr
operator|.
name|a_data
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|bputc
argument_list|(
literal|0
argument_list|,
name|dout
argument_list|)
expr_stmt|;
name|filhdr
operator|.
name|a_data
operator|++
expr_stmt|;
block|}
name|torigin
operator|+=
name|filhdr
operator|.
name|a_text
expr_stmt|;
name|dorigin
operator|+=
name|round
argument_list|(
name|filhdr
operator|.
name|a_data
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|borigin
operator|+=
name|round
argument_list|(
name|filhdr
operator|.
name|a_bss
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curstr
argument_list|)
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|tynames
block|{
name|int
name|ty_value
decl_stmt|;
name|char
modifier|*
name|ty_name
decl_stmt|;
block|}
name|tynames
index|[]
init|=
block|{
name|N_UNDF
block|,
literal|"undefined"
block|,
name|N_ABS
block|,
literal|"absolute"
block|,
name|N_TEXT
block|,
literal|"text"
block|,
name|N_DATA
block|,
literal|"data"
block|,
name|N_BSS
block|,
literal|"bss"
block|,
name|N_COMM
block|,
literal|"common"
block|,
literal|0
block|,
literal|0
block|, }
struct|;
end_struct

begin_macro
name|tracesym
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|tynames
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|&
name|N_STAB
condition|)
return|return;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|filname
argument_list|)
expr_stmt|;
if|if
condition|(
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|archdr
operator|.
name|ar_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cursym
operator|.
name|n_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_UNDF
operator|&&
name|cursym
operator|.
name|n_value
condition|)
block|{
name|printf
argument_list|(
literal|"definition of common %s size %d\n"
argument_list|,
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|cursym
operator|.
name|n_value
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|tp
operator|=
name|tynames
init|;
name|tp
operator|->
name|ty_name
condition|;
name|tp
operator|++
control|)
if|if
condition|(
name|tp
operator|->
name|ty_value
operator|==
operator|(
name|cursym
operator|.
name|n_type
operator|&
name|N_TYPE
operator|)
condition|)
break|break;
name|printf
argument_list|(
operator|(
name|cursym
operator|.
name|n_type
operator|&
name|N_TYPE
operator|)
condition|?
literal|"definition of"
else|:
literal|"reference to"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|&
name|N_EXT
condition|)
name|printf
argument_list|(
literal|" external"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ty_name
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|tp
operator|->
name|ty_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|cursym
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine relocates the single text or data segment argument.  * Offsets from external symbols are resolved by adding the value  * of the external symbols.  Non-external reference are updated to account  * for the relative motion of the segments (ctrel, cdrel, ...).  If  * a relocation was pc-relative, then we update it to reflect the  * change in the positioning of the segments by adding the displacement  * of the referenced segment and subtracting the displacement of the  * current segment (creloc).  *  * If we are saving the relocation information, then we increase  * each relocation datum address by our base position in the new segment.  */
end_comment

begin_macro
name|load2td
argument_list|(
argument|creloc
argument_list|,
argument|position
argument_list|,
argument|b1
argument_list|,
argument|b2
argument_list|)
end_macro

begin_decl_stmt
name|long
name|creloc
decl_stmt|,
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|biobuf
modifier|*
name|b1
decl_stmt|,
modifier|*
name|b2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|local
modifier|*
name|lp
decl_stmt|;
name|long
name|tw
decl_stmt|;
specifier|register
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|,
modifier|*
name|rpend
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|relp
decl_stmt|;
name|char
modifier|*
name|codep
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|relsz
decl_stmt|,
name|codesz
decl_stmt|;
name|relsz
operator|=
name|reloc
operator|.
name|size
expr_stmt|;
name|relp
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|malloc
argument_list|(
name|relsz
argument_list|)
expr_stmt|;
name|codesz
operator|=
name|text
operator|.
name|size
expr_stmt|;
name|codep
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|codesz
argument_list|)
expr_stmt|;
if|if
condition|(
name|relp
operator|==
literal|0
operator|||
name|codep
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"out of memory (load2td)"
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
name|relp
argument_list|,
name|relsz
argument_list|,
operator|&
name|reloc
argument_list|)
expr_stmt|;
name|rpend
operator|=
operator|&
name|relp
index|[
name|relsz
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
index|]
expr_stmt|;
name|mget
argument_list|(
name|codep
argument_list|,
name|codesz
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|relp
init|;
name|rp
operator|<
name|rpend
condition|;
name|rp
operator|++
control|)
block|{
name|cp
operator|=
name|codep
operator|+
name|rp
operator|->
name|r_address
expr_stmt|;
comment|/* 		 * Pick up previous value at location to be relocated. 		 */
switch|switch
condition|(
name|rp
operator|->
name|r_length
condition|)
block|{
case|case
literal|0
case|:
comment|/* byte */
name|tw
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* word */
name|tw
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* long */
name|tw
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|1
argument_list|,
literal|"load2td botch: bad length"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If relative to an external which is defined, 		 * resolve to a simpler kind of reference in the 		 * result file.  If the external is undefined, just 		 * convert the symbol number to the number of the 		 * symbol in the result file and leave it undefined. 		 */
if|if
condition|(
name|rp
operator|->
name|r_extern
condition|)
block|{
comment|/* 			 * Search the hash table which maps local 			 * symbol numbers to symbol tables entries 			 * in the new a.out file. 			 */
name|lp
operator|=
name|lochash
index|[
name|rp
operator|->
name|r_symbolnum
operator|%
name|LHSIZ
index|]
expr_stmt|;
while|while
condition|(
name|lp
operator|->
name|l_index
operator|!=
name|rp
operator|->
name|r_symbolnum
condition|)
block|{
name|lp
operator|=
name|lp
operator|->
name|l_link
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"local symbol botch"
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|lp
operator|->
name|l_symbol
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|n_type
operator|==
name|N_EXT
operator|+
name|N_UNDF
condition|)
name|rp
operator|->
name|r_symbolnum
operator|=
name|nsym
operator|+
name|symx
argument_list|(
name|sp
argument_list|)
expr_stmt|;
else|else
block|{
name|rp
operator|->
name|r_symbolnum
operator|=
name|sp
operator|->
name|n_type
operator|&
name|N_TYPE
expr_stmt|;
name|tw
operator|+=
name|sp
operator|->
name|n_value
expr_stmt|;
name|rp
operator|->
name|r_extern
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|rp
operator|->
name|r_symbolnum
operator|&
name|N_TYPE
condition|)
block|{
comment|/* 		 * Relocation is relative to the loaded position 		 * of another segment.  Update by the change in position 		 * of that segment. 		 */
case|case
name|N_TEXT
case|:
name|tw
operator|+=
name|ctrel
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|tw
operator|+=
name|cdrel
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|tw
operator|+=
name|cbrel
expr_stmt|;
break|break;
case|case
name|N_ABS
case|:
break|break;
default|default:
name|error
argument_list|(
literal|1
argument_list|,
literal|"relocation format botch (symbol type))"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Relocation is pc relative, so decrease the relocation 		 * by the amount the current segment is displaced. 		 * (E.g if we are a relative reference to a text location 		 * from data space, we added the increase in the text address 		 * above, and subtract the increase in our (data) address 		 * here, leaving the net change the relative change in the 		 * positioning of our text and data segments.) 		 */
if|if
condition|(
name|rp
operator|->
name|r_pcrel
condition|)
name|tw
operator|-=
name|creloc
expr_stmt|;
comment|/* 		 * Put the value back in the segment, 		 * while checking for overflow. 		 */
switch|switch
condition|(
name|rp
operator|->
name|r_length
condition|)
block|{
case|case
literal|0
case|:
comment|/* byte */
if|if
condition|(
name|tw
operator|<
operator|-
literal|128
operator|||
name|tw
operator|>
literal|127
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"byte displacement overflow"
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
name|tw
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* word */
if|if
condition|(
name|tw
operator|<
operator|-
literal|32768
operator|||
name|tw
operator|>
literal|32767
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|"word displacement overflow"
argument_list|)
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
name|tw
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* long */
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
name|tw
expr_stmt|;
break|break;
block|}
comment|/* 		 * If we are saving relocation information, 		 * we must convert the address in the segment from 		 * the old .o file into an address in the segment in 		 * the new a.out, by adding the position of our 		 * segment in the new larger segment. 		 */
if|if
condition|(
name|rflag
condition|)
name|rp
operator|->
name|r_address
operator|+=
name|position
expr_stmt|;
block|}
name|bwrite
argument_list|(
name|codep
argument_list|,
name|codesz
argument_list|,
name|b1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|bwrite
argument_list|(
name|relp
argument_list|,
name|relsz
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|relp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|codep
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|finishout
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|nsymt
decl_stmt|;
if|if
condition|(
name|sflag
operator|==
literal|0
condition|)
block|{
name|nsymt
operator|=
name|symx
argument_list|(
name|nextsym
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsymt
condition|;
name|i
operator|++
control|)
name|symwrite
argument_list|(
name|xsym
argument_list|(
name|i
argument_list|)
argument_list|,
name|sout
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
operator|&
name|offset
argument_list|,
sizeof|sizeof
name|offset
argument_list|,
name|sout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ofilfnd
condition|)
block|{
name|unlink
argument_list|(
literal|"a.out"
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
literal|"l.out"
argument_list|,
literal|"a.out"
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"cannot move l.out to a.out"
argument_list|)
expr_stmt|;
name|ofilename
operator|=
literal|"a.out"
expr_stmt|;
block|}
name|delarg
operator|=
name|errlev
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|mkfsym
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|sflag
operator|||
name|xflag
condition|)
return|return;
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|s
expr_stmt|;
name|cursym
operator|.
name|n_type
operator|=
name|N_TEXT
expr_stmt|;
name|cursym
operator|.
name|n_value
operator|=
name|torigin
expr_stmt|;
name|symwrite
argument_list|(
operator|&
name|cursym
argument_list|,
name|sout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getarhdr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|archdr
argument_list|,
sizeof|sizeof
name|archdr
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|archdr
operator|.
name|ar_name
init|;
name|cp
operator|<
operator|&
name|archdr
operator|.
name|ar_name
index|[
sizeof|sizeof
argument_list|(
name|archdr
operator|.
name|ar_name
argument_list|)
index|]
condition|;
control|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|' '
condition|)
block|{
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|mget
argument_list|(
name|loc
argument_list|,
name|n
argument_list|,
name|sp
argument_list|)
specifier|register
name|STREAM
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|take
decl_stmt|;
name|top
label|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|sp
operator|->
name|size
operator|&&
name|sp
operator|->
name|nibuf
condition|)
block|{
name|p
operator|=
name|sp
operator|->
name|ptr
expr_stmt|;
name|take
operator|=
name|sp
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|take
operator|>
name|sp
operator|->
name|nibuf
condition|)
name|take
operator|=
name|sp
operator|->
name|nibuf
expr_stmt|;
if|if
condition|(
name|take
operator|>
name|n
condition|)
name|take
operator|=
name|n
expr_stmt|;
name|n
operator|-=
name|take
expr_stmt|;
name|sp
operator|->
name|size
operator|-=
name|take
expr_stmt|;
name|sp
operator|->
name|nibuf
operator|-=
name|take
expr_stmt|;
name|sp
operator|->
name|pos
operator|+=
name|take
expr_stmt|;
do|do
operator|*
name|loc
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|take
operator|>
literal|0
condition|)
do|;
name|sp
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|n
operator|>
name|p_blksize
condition|)
block|{
name|take
operator|=
name|n
operator|-
name|n
operator|%
name|p_blksize
expr_stmt|;
name|lseek
argument_list|(
name|infil
argument_list|,
operator|(
name|sp
operator|->
name|bno
operator|+
literal|1
operator|)
operator|<<
name|p_blkshift
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|take
operator|>
name|sp
operator|->
name|size
operator|||
name|read
argument_list|(
name|infil
argument_list|,
name|loc
argument_list|,
name|take
argument_list|)
operator|!=
name|take
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"premature EOF"
argument_list|)
expr_stmt|;
name|loc
operator|+=
name|take
expr_stmt|;
name|n
operator|-=
name|take
expr_stmt|;
name|sp
operator|->
name|size
operator|-=
name|take
expr_stmt|;
name|sp
operator|->
name|pos
operator|+=
name|take
expr_stmt|;
name|dseek
argument_list|(
name|sp
argument_list|,
operator|(
name|sp
operator|->
name|bno
operator|+
literal|1
operator|+
operator|(
name|take
operator|>>
name|p_blkshift
operator|)
operator|)
operator|<<
name|p_blkshift
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
operator|*
name|loc
operator|++
operator|=
name|get
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|--
name|n
expr_stmt|;
goto|goto
name|top
goto|;
block|}
end_block

begin_macro
name|symwrite
argument_list|(
argument|sp
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|biobuf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|sp
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|sp
operator|->
name|n_un
operator|.
name|n_strx
operator|=
name|offset
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bwrite
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|strout
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|len
expr_stmt|;
block|}
name|bwrite
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|n_un
operator|.
name|n_name
operator|=
name|str
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dseek
argument_list|(
name|sp
argument_list|,
name|loc
argument_list|,
name|s
argument_list|)
specifier|register
name|STREAM
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|long
name|loc
decl_stmt|,
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PAGE
modifier|*
name|p
decl_stmt|;
specifier|register
name|b
operator|,
name|o
expr_stmt|;
name|int
name|n
decl_stmt|;
name|b
operator|=
name|loc
operator|>>
name|p_blkshift
expr_stmt|;
name|o
operator|=
name|loc
operator|&
name|p_blkmask
expr_stmt|;
if|if
condition|(
name|o
operator|&
literal|01
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"loader error; odd offset"
argument_list|)
expr_stmt|;
operator|--
name|sp
operator|->
name|pno
operator|->
name|nuser
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
operator|)
operator|->
name|bno
operator|!=
name|b
operator|&&
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|1
index|]
operator|)
operator|->
name|bno
operator|!=
name|b
condition|)
if|if
condition|(
name|p
operator|->
name|nuser
operator|==
literal|0
operator|||
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
operator|)
operator|->
name|nuser
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|nuser
operator|==
literal|0
operator|&&
name|page
index|[
literal|1
index|]
operator|.
name|nuser
operator|==
literal|0
condition|)
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|bno
operator|<
name|page
index|[
literal|1
index|]
operator|.
name|bno
condition|)
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|->
name|bno
operator|=
name|b
expr_stmt|;
name|lseek
argument_list|(
name|infil
argument_list|,
name|loc
operator|&
operator|~
operator|(
name|long
operator|)
name|p_blkmask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|infil
argument_list|,
name|p
operator|->
name|buff
argument_list|,
name|p_blksize
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|nibuf
operator|=
name|n
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"botch: no pages"
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|nuser
expr_stmt|;
name|sp
operator|->
name|bno
operator|=
name|b
expr_stmt|;
name|sp
operator|->
name|pno
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|s
operator|!=
operator|-
literal|1
condition|)
block|{
name|sp
operator|->
name|size
operator|=
name|s
expr_stmt|;
name|sp
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
block|}
name|sp
operator|->
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|buff
operator|+
name|o
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|nibuf
operator|=
name|p
operator|->
name|nibuf
operator|-
name|o
operator|)
operator|<=
literal|0
condition|)
name|sp
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|char
name|get
parameter_list|(
name|asp
parameter_list|)
name|STREAM
modifier|*
name|asp
decl_stmt|;
block|{
specifier|register
name|STREAM
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|asp
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|nibuf
operator|-=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dseek
argument_list|(
name|sp
argument_list|,
operator|(
call|(
name|long
call|)
argument_list|(
name|sp
operator|->
name|bno
operator|+
literal|1
argument_list|)
operator|<<
name|p_blkshift
operator|)
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|nibuf
operator|-=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|size
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"premature EOF"
argument_list|)
expr_stmt|;
operator|++
name|fpage
operator|.
name|nuser
expr_stmt|;
operator|--
name|sp
operator|->
name|pno
operator|->
name|nuser
expr_stmt|;
name|sp
operator|->
name|pno
operator|=
operator|(
name|PAGE
operator|*
operator|)
operator|&
name|fpage
expr_stmt|;
block|}
name|sp
operator|->
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|sp
operator|->
name|ptr
operator|++
operator|)
return|;
block|}
end_function

begin_macro
name|getfile
argument_list|(
argument|acp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|acp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|arcmag
index|[
name|SARMAG
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|filname
operator|=
name|acp
expr_stmt|;
if|if
condition|(
name|filname
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|filname
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
name|infil
operator|=
name|libopen
argument_list|(
name|filname
operator|+
literal|2
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
else|else
name|infil
operator|=
name|open
argument_list|(
name|filname
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|infil
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"cannot open"
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|infil
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
name|page
index|[
literal|0
index|]
operator|.
name|bno
operator|=
name|page
index|[
literal|1
index|]
operator|.
name|bno
operator|=
operator|-
literal|1
expr_stmt|;
name|page
index|[
literal|0
index|]
operator|.
name|nuser
operator|=
name|page
index|[
literal|1
index|]
operator|.
name|nuser
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|stb
operator|.
name|st_blksize
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|||
operator|(
name|c
operator|&
operator|(
name|c
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* use default size if not a power of two */
name|c
operator|=
name|BLKSIZE
expr_stmt|;
block|}
if|if
condition|(
name|p_blksize
operator|!=
name|c
condition|)
block|{
name|p_blksize
operator|=
name|c
expr_stmt|;
name|p_blkmask
operator|=
name|c
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p_blkshift
operator|=
literal|0
init|;
name|c
operator|>
literal|1
condition|;
name|p_blkshift
operator|++
control|)
name|c
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|buff
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|page
index|[
literal|0
index|]
operator|.
name|buff
argument_list|)
expr_stmt|;
name|page
index|[
literal|0
index|]
operator|.
name|buff
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|p_blksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|buff
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (getfile)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
index|[
literal|1
index|]
operator|.
name|buff
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|page
index|[
literal|1
index|]
operator|.
name|buff
argument_list|)
expr_stmt|;
name|page
index|[
literal|1
index|]
operator|.
name|buff
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|p_blksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
index|[
literal|1
index|]
operator|.
name|buff
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (getfile)"
argument_list|)
expr_stmt|;
block|}
name|text
operator|.
name|pno
operator|=
name|reloc
operator|.
name|pno
operator|=
operator|(
name|PAGE
operator|*
operator|)
operator|&
name|fpage
expr_stmt|;
name|fpage
operator|.
name|nuser
operator|=
literal|2
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
literal|0L
argument_list|,
name|SARMAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"premature EOF"
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arcmag
argument_list|,
name|SARMAG
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|arcmag
index|[
name|SARMAG
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arcmag
argument_list|,
name|ARMAG
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|SARMAG
argument_list|,
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|getarhdr
argument_list|()
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|archdr
operator|.
name|ar_name
argument_list|,
literal|"__.SYMDEF"
argument_list|,
sizeof|sizeof
argument_list|(
name|archdr
operator|.
name|ar_name
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|stb
operator|.
name|st_mtime
operator|>
name|atol
argument_list|(
name|archdr
operator|.
name|ar_date
argument_list|)
condition|?
literal|3
else|:
literal|2
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Search for a library with given name  * using the directory search array.  */
end_comment

begin_macro
name|libopen
argument_list|(
argument|name
argument_list|,
argument|oflags
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|oflags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
comment|/* backwards compat */
name|name
operator|=
literal|"a"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndir
operator|&&
name|fd
operator|==
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|dirs
index|[
name|i
index|]
init|;
operator|*
name|cp
condition|;
operator|*
name|p
operator|++
operator|=
operator|*
name|cp
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
for|for
control|(
name|cp
operator|=
literal|"lib"
init|;
operator|*
name|cp
condition|;
operator|*
name|p
operator|++
operator|=
operator|*
name|cp
operator|++
control|)
empty_stmt|;
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
operator|*
name|p
operator|++
operator|=
operator|*
name|cp
operator|++
control|)
empty_stmt|;
name|cp
operator|=
literal|".a"
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|cp
operator|++
condition|)
empty_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|oflags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|filname
operator|=
name|buf
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|nlist
modifier|*
modifier|*
name|lookup
parameter_list|()
block|{
specifier|register
name|int
name|sh
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
specifier|register
name|struct
name|symseg
modifier|*
name|gp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|sh
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cursym
operator|.
name|n_un
operator|.
name|n_name
init|;
operator|*
name|cp
condition|;
control|)
name|sh
operator|=
operator|(
name|sh
operator|<<
literal|1
operator|)
operator|+
operator|*
name|cp
operator|++
expr_stmt|;
name|sh
operator|=
operator|(
name|sh
operator|&
literal|0x7fffffff
operator|)
operator|%
name|HSIZE
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|symseg
init|;
name|gp
operator|<
operator|&
name|symseg
index|[
name|NSEG
index|]
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|gp
operator|->
name|sy_first
operator|==
literal|0
condition|)
block|{
name|gp
operator|->
name|sy_first
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|calloc
argument_list|(
name|NSYM
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
name|gp
operator|->
name|sy_hfirst
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|HSIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|sy_first
operator|==
literal|0
operator|||
name|gp
operator|->
name|sy_hfirst
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of space for symbol table"
argument_list|)
expr_stmt|;
name|gp
operator|->
name|sy_last
operator|=
name|gp
operator|->
name|sy_first
operator|+
name|NSYM
expr_stmt|;
name|gp
operator|->
name|sy_hlast
operator|=
name|gp
operator|->
name|sy_hfirst
operator|+
name|HSIZE
expr_stmt|;
block|}
if|if
condition|(
name|gp
operator|>
name|csymseg
condition|)
name|csymseg
operator|=
name|gp
expr_stmt|;
name|hp
operator|=
name|gp
operator|->
name|sy_hfirst
operator|+
name|sh
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|hp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gp
operator|->
name|sy_used
operator|==
name|NSYM
condition|)
break|break;
return|return
operator|(
name|hp
operator|)
return|;
block|}
name|cp1
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cursym
operator|.
name|n_un
operator|.
name|n_name
init|;
operator|*
name|cp
operator|==
operator|*
name|cp1
operator|++
condition|;
control|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|0
condition|)
return|return
operator|(
name|hp
operator|)
return|;
name|hp
operator|+=
name|i
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|hp
operator|>=
name|gp
operator|->
name|sy_hlast
condition|)
name|hp
operator|-=
name|HSIZE
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|HSIZE
condition|)
do|;
if|if
condition|(
name|i
operator|>
name|HSIZE
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"hash table botch"
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|1
argument_list|,
literal|"symbol table overflow"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_macro
name|symfree
argument_list|(
argument|saved
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|saved
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|symseg
modifier|*
name|gp
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|gp
operator|=
name|csymseg
init|;
name|gp
operator|>=
name|symseg
condition|;
name|gp
operator|--
operator|,
name|csymseg
operator|--
control|)
block|{
name|sp
operator|=
name|gp
operator|->
name|sy_first
operator|+
name|gp
operator|->
name|sy_used
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|saved
condition|)
block|{
name|nextsym
operator|=
name|sp
expr_stmt|;
return|return;
block|}
for|for
control|(
name|sp
operator|--
init|;
name|sp
operator|>=
name|gp
operator|->
name|sy_first
condition|;
name|sp
operator|--
control|)
block|{
name|gp
operator|->
name|sy_hfirst
index|[
name|sp
operator|->
name|n_hash
index|]
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|sy_used
operator|--
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|saved
condition|)
block|{
name|nextsym
operator|=
name|sp
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|saved
operator|==
literal|0
condition|)
return|return;
name|error
argument_list|(
literal|1
argument_list|,
literal|"symfree botch"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|nlist
modifier|*
modifier|*
name|slookup
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|cursym
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|s
expr_stmt|;
name|cursym
operator|.
name|n_type
operator|=
name|N_EXT
operator|+
name|N_UNDF
expr_stmt|;
name|cursym
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|lookup
argument_list|()
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|enter
argument_list|(
name|hp
argument_list|)
specifier|register
expr|struct
name|nlist
operator|*
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|*
name|hp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hp
operator|<
name|csymseg
operator|->
name|sy_hfirst
operator|||
name|hp
operator|>=
name|csymseg
operator|->
name|sy_hlast
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"enter botch"
argument_list|)
expr_stmt|;
operator|*
name|hp
operator|=
name|lastsym
operator|=
name|sp
operator|=
name|csymseg
operator|->
name|sy_first
operator|+
name|csymseg
operator|->
name|sy_used
expr_stmt|;
name|csymseg
operator|->
name|sy_used
operator|++
expr_stmt|;
name|sp
operator|->
name|n_un
operator|.
name|n_name
operator|=
name|cursym
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
name|sp
operator|->
name|n_type
operator|=
name|cursym
operator|.
name|n_type
expr_stmt|;
name|sp
operator|->
name|n_hash
operator|=
name|hp
operator|-
name|csymseg
operator|->
name|sy_hfirst
expr_stmt|;
name|sp
operator|->
name|n_value
operator|=
name|cursym
operator|.
name|n_value
expr_stmt|;
name|nextsym
operator|=
name|lastsym
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|lastsym
operator|=
operator|*
name|hp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|symx
argument_list|(
argument|sp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|symseg
modifier|*
name|gp
decl_stmt|;
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|gp
operator|=
name|csymseg
init|;
name|gp
operator|>=
name|symseg
condition|;
name|gp
operator|--
control|)
comment|/*<= is sloppy so nextsym will always work */
if|if
condition|(
name|sp
operator|>=
name|gp
operator|->
name|sy_first
operator|&&
name|sp
operator|<=
name|gp
operator|->
name|sy_last
condition|)
return|return
operator|(
operator|(
name|gp
operator|-
name|symseg
operator|)
operator|*
name|NSYM
operator|+
name|sp
operator|-
name|gp
operator|->
name|sy_first
operator|)
return|;
name|error
argument_list|(
literal|1
argument_list|,
literal|"symx botch"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_block

begin_macro
name|symreloc
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|funding
condition|)
return|return;
switch|switch
condition|(
name|cursym
operator|.
name|n_type
operator|&
literal|017
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_EXT
operator|+
name|N_TEXT
case|:
name|cursym
operator|.
name|n_value
operator|+=
name|ctrel
expr_stmt|;
return|return;
case|case
name|N_DATA
case|:
case|case
name|N_EXT
operator|+
name|N_DATA
case|:
name|cursym
operator|.
name|n_value
operator|+=
name|cdrel
expr_stmt|;
return|return;
case|case
name|N_BSS
case|:
case|case
name|N_EXT
operator|+
name|N_BSS
case|:
name|cursym
operator|.
name|n_value
operator|+=
name|cbrel
expr_stmt|;
return|return;
case|case
name|N_EXT
operator|+
name|N_UNDF
case|:
return|return;
default|default:
if|if
condition|(
name|cursym
operator|.
name|n_type
operator|&
name|N_EXT
condition|)
name|cursym
operator|.
name|n_type
operator|=
name|N_EXT
operator|+
name|N_ABS
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_macro
name|error
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|errlev
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"ld:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filname
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|filname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|-
literal|1
operator|&&
name|archdr
operator|.
name|ar_name
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|archdr
operator|.
name|ar_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|n
condition|)
name|delexit
argument_list|()
expr_stmt|;
name|errlev
operator|=
literal|2
expr_stmt|;
block|}
end_block

begin_macro
name|readhdr
argument_list|(
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|off_t
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|filhdr
argument_list|)
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|short
operator|*
operator|)
operator|&
name|filhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|filhdr
argument_list|)
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|filhdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|filhdr
operator|.
name|a_magic
operator|==
name|OARMAG
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"old archive"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad magic number"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filhdr
operator|.
name|a_text
operator|&
literal|01
operator|||
name|filhdr
operator|.
name|a_data
operator|&
literal|01
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"text/data size odd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filhdr
operator|.
name|a_magic
operator|==
name|NMAGIC
operator|||
name|filhdr
operator|.
name|a_magic
operator|==
name|ZMAGIC
condition|)
block|{
name|cdrel
operator|=
operator|-
name|round
argument_list|(
name|filhdr
operator|.
name|a_text
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
name|cbrel
operator|=
name|cdrel
operator|-
name|filhdr
operator|.
name|a_data
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filhdr
operator|.
name|a_magic
operator|==
name|OMAGIC
condition|)
block|{
name|cdrel
operator|=
operator|-
name|filhdr
operator|.
name|a_text
expr_stmt|;
name|cbrel
operator|=
name|cdrel
operator|-
name|filhdr
operator|.
name|a_data
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"bad format"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|round
argument_list|(
argument|v
argument_list|,
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|int
name|v
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|r
operator|--
expr_stmt|;
name|v
operator|+=
name|r
expr_stmt|;
name|v
operator|&=
operator|~
operator|(
name|long
operator|)
name|r
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|NSAVETAB
value|8192
end_define

begin_decl_stmt
name|char
modifier|*
name|savetab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|saveleft
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|savestr
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|saveleft
condition|)
block|{
name|saveleft
operator|=
name|NSAVETAB
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|saveleft
condition|)
name|saveleft
operator|=
name|len
expr_stmt|;
name|savetab
operator|=
name|malloc
argument_list|(
name|saveleft
argument_list|)
expr_stmt|;
if|if
condition|(
name|savetab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (savestr)"
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|savetab
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|=
name|savetab
expr_stmt|;
name|savetab
operator|+=
name|len
expr_stmt|;
name|saveleft
operator|-=
name|len
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|bopen
argument_list|(
name|bp
argument_list|,
name|off
argument_list|,
name|bufsize
argument_list|)
specifier|register
expr|struct
name|biobuf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|bp
operator|->
name|b_ptr
operator|=
name|bp
operator|->
name|b_buf
operator|=
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_ptr
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"ran out of memory (bopen)"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|bufsize
expr_stmt|;
name|bp
operator|->
name|b_nleft
operator|=
name|bufsize
operator|-
operator|(
name|off
operator|%
name|bufsize
operator|)
expr_stmt|;
name|bp
operator|->
name|b_off
operator|=
name|off
expr_stmt|;
name|bp
operator|->
name|b_link
operator|=
name|biobufs
expr_stmt|;
name|biobufs
operator|=
name|bp
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|bwrerror
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|bwrite
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|bp
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|biobuf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|put
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
name|top
label|:
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|bp
operator|->
name|b_nleft
condition|)
block|{
name|put
operator|=
name|bp
operator|->
name|b_nleft
expr_stmt|;
if|if
condition|(
name|put
operator|>
name|cnt
condition|)
name|put
operator|=
name|cnt
expr_stmt|;
name|bp
operator|->
name|b_nleft
operator|-=
name|put
expr_stmt|;
name|to
operator|=
name|bp
operator|->
name|b_ptr
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|to
argument_list|,
name|put
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_ptr
operator|+=
name|put
expr_stmt|;
name|p
operator|+=
name|put
expr_stmt|;
name|cnt
operator|-=
name|put
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|cnt
operator|>=
name|bp
operator|->
name|b_bufsize
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_ptr
operator|!=
name|bp
operator|->
name|b_buf
condition|)
name|bflush1
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|put
operator|=
name|cnt
operator|-
name|cnt
operator|%
name|bp
operator|->
name|b_bufsize
expr_stmt|;
if|if
condition|(
name|boffset
operator|!=
name|bp
operator|->
name|b_off
condition|)
name|lseek
argument_list|(
name|biofd
argument_list|,
name|bp
operator|->
name|b_off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|biofd
argument_list|,
name|p
argument_list|,
name|put
argument_list|)
operator|!=
name|put
condition|)
block|{
name|bwrerror
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|"output write error"
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_off
operator|+=
name|put
expr_stmt|;
name|boffset
operator|=
name|bp
operator|->
name|b_off
expr_stmt|;
name|p
operator|+=
name|put
expr_stmt|;
name|cnt
operator|-=
name|put
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|bflush1
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
end_block

begin_macro
name|bflush
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|biobuf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|bwrerror
condition|)
return|return;
for|for
control|(
name|bp
operator|=
name|biobufs
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_link
control|)
name|bflush1
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|bflush1
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|biobuf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|cnt
init|=
name|bp
operator|->
name|b_ptr
operator|-
name|bp
operator|->
name|b_buf
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|boffset
operator|!=
name|bp
operator|->
name|b_off
condition|)
name|lseek
argument_list|(
name|biofd
argument_list|,
name|bp
operator|->
name|b_off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|biofd
argument_list|,
name|bp
operator|->
name|b_buf
argument_list|,
name|cnt
argument_list|)
operator|!=
name|cnt
condition|)
block|{
name|bwrerror
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|"output write error"
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_off
operator|+=
name|cnt
expr_stmt|;
name|boffset
operator|=
name|bp
operator|->
name|b_off
expr_stmt|;
name|bp
operator|->
name|b_ptr
operator|=
name|bp
operator|->
name|b_buf
expr_stmt|;
name|bp
operator|->
name|b_nleft
operator|=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|bflushc
argument_list|(
name|bp
argument_list|,
name|c
argument_list|)
specifier|register
expr|struct
name|biobuf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|bflush1
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bputc
argument_list|(
name|c
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|bseek
argument_list|(
name|bp
argument_list|,
name|off
argument_list|)
specifier|register
expr|struct
name|biobuf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|off_t
name|off
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bflush1
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_nleft
operator|=
name|bp
operator|->
name|b_bufsize
operator|-
operator|(
name|off
operator|%
name|bp
operator|->
name|b_bufsize
operator|)
expr_stmt|;
name|bp
operator|->
name|b_off
operator|=
name|off
expr_stmt|;
block|}
end_block

end_unit

