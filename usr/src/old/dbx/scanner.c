begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)scanner.c	1.10 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Debugger scanner.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"scanner.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"keywords.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_typedef
typedef|typedef
name|int
name|Token
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|s_type
decl_stmt|;
define|#
directive|define
name|ST_FILE
value|0
define|#
directive|define
name|ST_ALIAS
value|1
name|char
modifier|*
name|s_name
decl_stmt|;
name|int
name|s_lineno
decl_stmt|;
union|union
block|{
name|File
name|su_file
decl_stmt|;
struct|struct
name|sum
block|{
name|char
modifier|*
name|sum_data
decl_stmt|;
name|char
modifier|*
name|sum_cur
decl_stmt|;
block|}
name|su_macro
struct|;
block|}
name|su
union|;
define|#
directive|define
name|s_file
value|su.su_file
define|#
directive|define
name|s_macro
value|su.su_macro
define|#
directive|define
name|s_data
value|s_macro.sum_data
define|#
directive|define
name|s_cur
value|s_macro.sum_cur
block|}
name|STREAM
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NSTREAMS
value|10
end_define

begin_decl_stmt
name|private
name|STREAM
name|stack
index|[
name|NSTREAMS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|STREAM
modifier|*
name|sp
init|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|String
name|initfile
init|=
literal|".dbxinit"
decl_stmt|;
end_decl_stmt

begin_function_decl
name|private
name|Token
name|getident
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|Token
name|getnum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|Token
name|getstring
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|Char
name|charcon
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAXLINESIZE
value|1024
end_define

begin_decl_stmt
name|private
name|Char
name|yytext
index|[
name|MAXLINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Boolean
name|shellmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Boolean
name|doaliases
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|scanner_init
parameter_list|()
block|{
specifier|register
name|Integer
name|i
decl_stmt|;
if|if
condition|(
name|sp
operator|<
name|stack
condition|)
operator|(
name|void
operator|)
name|pushinput
argument_list|(
name|ST_FILE
argument_list|,
name|nil
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|shellmode
operator|=
name|false
expr_stmt|;
name|doaliases
operator|=
name|true
expr_stmt|;
name|errfilename
operator|=
name|nil
expr_stmt|;
name|errlineno
operator|=
name|sp
operator|->
name|s_lineno
operator|=
literal|0
expr_stmt|;
name|yytext
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXDEPTH
value|25
end_define

begin_comment
comment|/*  * Read a single token.  * There are two "modes" of operation:  one as in a compiler,  * and one for reading shell-like syntax.  */
end_comment

begin_function
name|public
name|Token
name|yylex
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|Token
name|t
decl_stmt|;
specifier|static
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|depth
operator|>
name|MAXDEPTH
condition|)
block|{
name|depth
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"Alias loop (maximum %d deep).\n"
argument_list|,
name|MAXDEPTH
argument_list|)
expr_stmt|;
block|}
name|again
label|:
do|do
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
name|t
operator|=
name|getident
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NAME
operator|&&
name|doaliases
condition|)
block|{
name|p
operator|=
name|findalias
argument_list|(
name|yylval
operator|.
name|y_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|lexdebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"alias %s to \"%s\"\n"
argument_list|,
name|ident
argument_list|(
name|yylval
operator|.
name|y_name
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pushinput
argument_list|(
name|ST_ALIAS
argument_list|,
literal|""
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|unwindinput
argument_list|(
name|ST_ALIAS
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Alias stack overflow."
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|yylex
argument_list|()
expr_stmt|;
block|}
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|t
operator|=
name|shellmode
condition|?
name|getident
argument_list|(
name|c
argument_list|)
else|:
name|getnum
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|t
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_lineno
operator|!=
literal|0
condition|)
block|{
name|sp
operator|->
name|s_lineno
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_type
operator|==
name|ST_FILE
condition|)
name|errlineno
operator|=
name|sp
operator|->
name|s_lineno
expr_stmt|;
block|}
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
name|t
operator|=
name|getstring
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
name|shellmode
condition|)
block|{
name|t
operator|=
name|getident
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|ungetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|t
operator|=
name|isdigit
argument_list|(
name|c
argument_list|)
condition|?
name|getnum
argument_list|(
literal|'.'
argument_list|)
else|:
literal|'.'
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|shellmode
operator|||
name|c
operator|!=
literal|'<'
condition|)
block|{
name|ungetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|t
operator|=
literal|'<'
expr_stmt|;
block|}
else|else
name|t
operator|=
name|LFORMER
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|shellmode
operator|||
name|c
operator|!=
literal|'>'
condition|)
block|{
name|ungetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|t
operator|=
literal|'>'
expr_stmt|;
block|}
else|else
name|t
operator|=
name|RFORMER
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'^'
condition|)
block|{
name|ungetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|t
operator|=
literal|'#'
expr_stmt|;
block|}
else|else
name|t
operator|=
name|ABSTRACTION
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|shellmode
condition|)
block|{
name|t
operator|=
name|getident
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'>'
condition|)
block|{
name|ungetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|t
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
name|t
operator|=
name|ARROW
expr_stmt|;
break|break;
case|case
name|EOF
case|:
name|t
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|t
operator|=
name|shellmode
operator|&&
name|index
argument_list|(
literal|"!&*()[];"
argument_list|,
name|c
argument_list|)
operator|==
name|nil
condition|?
name|getident
argument_list|(
name|c
argument_list|)
else|:
name|c
expr_stmt|;
break|break;
block|}
name|done
label|:
if|if
condition|(
name|lexdebug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"token "
argument_list|)
expr_stmt|;
name|print_token
argument_list|(
name|stderr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|depth
operator|--
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan an identifier and check to see if it's a keyword.  */
end_comment

begin_function
name|private
name|Token
name|getident
parameter_list|(
name|c
parameter_list|)
name|Char
name|c
decl_stmt|;
block|{
specifier|register
name|Char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|Token
name|t
decl_stmt|;
name|q
operator|=
name|yytext
expr_stmt|;
if|if
condition|(
name|shellmode
condition|)
block|{
do|do
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|index
argument_list|(
literal|" \t\n!&<>*[]();"
argument_list|,
name|c
argument_list|)
operator|==
name|nil
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
condition|)
do|;
block|}
name|ungetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|yylval
operator|.
name|y_name
operator|=
name|identname
argument_list|(
name|yytext
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|shellmode
condition|)
return|return
operator|(
name|NAME
operator|)
return|;
name|t
operator|=
name|findkeyword
argument_list|(
name|yylval
operator|.
name|y_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|==
name|nil
condition|?
name|NAME
else|:
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan a number.  */
end_comment

begin_function
name|private
name|Token
name|getnum
parameter_list|(
name|c
parameter_list|)
name|Char
name|c
decl_stmt|;
block|{
specifier|register
name|Char
modifier|*
name|q
decl_stmt|;
specifier|register
name|Token
name|t
decl_stmt|;
name|Integer
name|base
init|=
literal|10
decl_stmt|;
name|q
operator|=
name|yytext
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'x'
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|ungetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|base
operator|==
literal|16
condition|)
block|{
while|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getch
argument_list|()
argument_list|)
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
operator|)
condition|)
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
do|do
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'e'
expr_stmt|;
do|do
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
do|;
block|}
block|}
name|ungetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|yylval
operator|.
name|y_real
operator|=
name|atof
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
return|return
operator|(
name|REAL
operator|)
return|;
block|}
name|ungetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|10
case|:
name|yylval
operator|.
name|y_int
operator|=
name|atol
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|yylval
operator|.
name|y_int
operator|=
name|octal
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|yylval
operator|.
name|y_int
operator|=
name|hex
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badcaseval
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|INT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a string of octal digits to an integer.  */
end_comment

begin_function
name|private
name|int
name|octal
parameter_list|(
name|s
parameter_list|)
name|String
name|s
decl_stmt|;
block|{
specifier|register
name|Char
modifier|*
name|p
decl_stmt|;
specifier|register
name|Integer
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
name|n
operator|=
operator|(
name|n
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a string of hexadecimal digits to an integer.  */
end_comment

begin_function
name|private
name|int
name|hex
parameter_list|(
name|s
parameter_list|)
name|String
name|s
decl_stmt|;
block|{
specifier|register
name|Char
modifier|*
name|p
decl_stmt|;
specifier|register
name|Integer
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
name|n
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'f'
condition|)
name|n
operator|+=
operator|(
operator|*
name|p
operator|-
literal|'a'
operator|+
literal|10
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'F'
condition|)
name|n
operator|+=
operator|(
operator|*
name|p
operator|-
literal|'A'
operator|+
literal|10
operator|)
expr_stmt|;
else|else
name|n
operator|+=
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan a string.  */
end_comment

begin_function
name|private
name|Token
name|getstring
parameter_list|(
name|match
parameter_list|)
name|Char
name|match
decl_stmt|;
block|{
specifier|register
name|Char
modifier|*
name|q
decl_stmt|,
name|c
decl_stmt|;
name|q
operator|=
name|yytext
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|"Unterminated string."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|match
condition|)
break|break;
operator|*
name|q
operator|++
operator|=
name|charcon
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|yylval
operator|.
name|y_string
operator|=
name|strdup
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
return|return
operator|(
name|STRING
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a character constant.  * Watch out for backslashes.  */
end_comment

begin_function
name|private
name|Char
name|charcon
parameter_list|(
name|c
parameter_list|)
name|Char
name|c
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|v
decl_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|v
operator|=
operator|(
name|v
operator|<<
literal|3
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|ungetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
for|for
control|(
name|cp
operator|=
literal|"f\ft\tb\bn\nr\rv\v"
init|;
operator|*
name|cp
operator|!=
name|c
condition|;
name|cp
operator|+=
literal|2
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|*
name|cp
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parser error handling.  */
end_comment

begin_function
name|public
name|yyerror
parameter_list|(
name|s
parameter_list|)
name|String
name|s
decl_stmt|;
block|{
if|if
condition|(
name|streq
argument_list|(
name|s
argument_list|,
literal|"syntax error"
argument_list|)
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Syntax error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytext
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" on \"%s\"."
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Eat the current line.  */
end_comment

begin_decl_stmt
name|private
name|Char
name|lastc
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|gobble
parameter_list|()
block|{
specifier|register
name|char
name|c
decl_stmt|;
if|if
condition|(
name|lastc
operator|!=
literal|'\n'
operator|&&
name|lastc
operator|!=
name|EOF
condition|)
while|while
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Input file management routines.  */
end_comment

begin_function
name|public
name|setinput
parameter_list|(
name|filename
parameter_list|)
name|Filename
name|filename
decl_stmt|;
block|{
name|File
name|f
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|nil
condition|)
name|error
argument_list|(
literal|"%s: Can't open."
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pushinput
argument_list|(
name|ST_FILE
argument_list|,
name|filename
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|unwindinput
argument_list|(
name|ST_FILE
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Source file nesting too deep."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send the current line to the shell.  */
end_comment

begin_function
name|public
name|shellline
parameter_list|()
block|{
specifier|register
name|Char
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
for|for
control|(
name|p
operator|=
name|yytext
init|;
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|;
operator|*
name|p
operator|++
operator|=
name|c
control|)
empty_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|shell
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
name|erecover
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the rest of the current line in "shell mode".  */
end_comment

begin_function
name|public
name|beginshellmode
parameter_list|()
block|{
name|shellmode
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
name|public
name|endshellmode
parameter_list|()
block|{
name|shellmode
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
name|public
name|stopaliasing
parameter_list|()
block|{
name|doaliases
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
name|public
name|startaliasing
parameter_list|()
block|{
name|doaliases
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a token for debugging.  */
end_comment

begin_function
name|public
name|print_token
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
name|File
name|f
decl_stmt|;
name|Token
name|t
decl_stmt|;
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
literal|'\n'
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"char '\\n'"
argument_list|)
expr_stmt|;
return|return;
case|case
name|EOF
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"EOF"
argument_list|)
expr_stmt|;
return|return;
case|case
name|NAME
case|:
case|case
name|STRING
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s, \"%s\""
argument_list|,
name|keywdstring
argument_list|(
name|t
argument_list|)
argument_list|,
name|ident
argument_list|(
name|yylval
operator|.
name|y_name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|t
operator|<
literal|256
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"char '%c'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|keywdstring
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|public
name|int
name|getch
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|again
label|:
switch|switch
condition|(
name|sp
operator|->
name|s_type
condition|)
block|{
case|case
name|ST_FILE
case|:
name|c
operator|=
name|getc
argument_list|(
name|sp
operator|->
name|s_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|isterm
argument_list|(
name|sp
operator|->
name|s_file
argument_list|)
condition|)
block|{
name|clearerr
argument_list|(
name|sp
operator|->
name|s_file
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
break|break;
case|case
name|ST_ALIAS
case|:
name|c
operator|=
operator|*
name|sp
operator|->
name|s_cur
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|c
operator|=
name|EOF
expr_stmt|;
operator|--
name|sp
operator|->
name|s_cur
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"Invalid input stream (type %d) to getch."
argument_list|,
name|sp
operator|->
name|s_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|popinput
argument_list|()
condition|)
goto|goto
name|again
goto|;
return|return
operator|(
name|lastc
operator|=
name|c
operator|)
return|;
block|}
end_function

begin_function
name|private
name|int
name|ungetch
parameter_list|(
name|c
parameter_list|)
name|Char
name|c
decl_stmt|;
block|{
name|Char
name|uc
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|sp
operator|->
name|s_type
condition|)
block|{
case|case
name|ST_FILE
case|:
name|uc
operator|=
name|ungetc
argument_list|(
name|c
argument_list|,
name|sp
operator|->
name|s_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST_ALIAS
case|:
if|if
condition|(
name|sp
operator|->
name|s_cur
operator|==
name|sp
operator|->
name|s_data
condition|)
name|panic
argument_list|(
literal|"Illegal ungetch on alias."
argument_list|)
expr_stmt|;
operator|*
operator|--
name|sp
operator|->
name|s_cur
operator|=
name|c
expr_stmt|;
name|uc
operator|=
name|c
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Invalid input stream (type %d) to ungetch."
argument_list|,
name|sp
operator|->
name|s_type
argument_list|)
expr_stmt|;
block|}
name|lastc
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|uc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Push the current input stream and  * make the supplied stream the current.  */
end_comment

begin_comment
comment|/*VARARGS3*/
end_comment

begin_function
name|public
name|pushinput
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|info
parameter_list|)
name|int
name|type
decl_stmt|;
name|Filename
name|name
decl_stmt|;
block|{
if|if
condition|(
name|sp
operator|>=
operator|&
name|stack
index|[
name|NSTREAMS
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|++
name|sp
expr_stmt|;
name|sp
operator|->
name|s_type
operator|=
name|type
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ST_FILE
case|:
name|sp
operator|->
name|s_file
operator|=
operator|(
name|File
operator|)
name|info
expr_stmt|;
name|errfilename
operator|=
name|sp
operator|->
name|s_name
operator|=
name|name
expr_stmt|;
name|errlineno
operator|=
name|sp
operator|->
name|s_lineno
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ST_ALIAS
case|:
name|sp
operator|->
name|s_cur
operator|=
name|sp
operator|->
name|s_data
operator|=
operator|(
name|char
operator|*
operator|)
name|info
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Invalid input stream (type %d) to pushinput."
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|public
name|popinput
parameter_list|()
block|{
if|if
condition|(
name|sp
operator|<=
operator|&
name|stack
index|[
literal|0
index|]
condition|)
comment|/* never pop stdin or equivalent */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_type
operator|==
name|ST_FILE
operator|&&
name|sp
operator|->
name|s_file
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|sp
operator|->
name|s_file
argument_list|)
expr_stmt|;
operator|--
name|sp
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_type
operator|==
name|ST_FILE
condition|)
name|errfilename
operator|=
name|sp
operator|->
name|s_name
expr_stmt|;
name|errlineno
operator|=
name|sp
operator|->
name|s_lineno
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unwind the input stack of all input types specified.  * This is called to recover from an infinite  * loop in alias processing or source file including.  */
end_comment

begin_function
name|public
name|unwindinput
parameter_list|(
name|type
parameter_list|)
name|Integer
name|type
decl_stmt|;
block|{
while|while
condition|(
name|sp
operator|->
name|s_type
operator|==
name|type
operator|&&
name|popinput
argument_list|()
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return whether we are currently reading from standard input.  */
end_comment

begin_function
name|public
name|Boolean
name|isstdin
parameter_list|()
block|{
return|return
operator|(
call|(
name|Boolean
call|)
argument_list|(
name|sp
operator|->
name|s_type
operator|==
name|ST_FILE
operator|&&
name|sp
operator|->
name|s_file
operator|==
name|stdin
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|public
name|Boolean
name|istty
parameter_list|()
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|isterm
argument_list|(
name|sp
operator|->
name|s_file
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

