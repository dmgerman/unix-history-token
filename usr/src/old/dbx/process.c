begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)process.c 1.12 %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Process management.  *  * This module contains the routines to manage the execution and  * tracing of the debuggee process.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"events.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_include
include|#
directive|include
file|"operators.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"coredump.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_typedef
typedef|typedef
name|struct
name|Process
modifier|*
name|Process
typedef|;
end_typedef

begin_decl_stmt
name|Process
name|process
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFSIG
value|-1
end_define

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NOTSTARTED
value|1
end_define

begin_define
define|#
directive|define
name|STOPPED
value|0177
end_define

begin_define
define|#
directive|define
name|FINISHED
value|0
end_define

begin_comment
comment|/*  * Cache-ing of instruction segment is done to reduce the number  * of system calls.  */
end_comment

begin_define
define|#
directive|define
name|CSIZE
value|1003
end_define

begin_comment
comment|/* size of instruction cache */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|Word
name|addr
decl_stmt|;
name|Word
name|val
decl_stmt|;
block|}
name|CacheWord
typedef|;
end_typedef

begin_comment
comment|/*  * This structure holds the information we need from the user structure.  */
end_comment

begin_struct
struct|struct
name|Process
block|{
name|int
name|pid
decl_stmt|;
comment|/* process being traced */
name|int
name|mask
decl_stmt|;
comment|/* process status word */
name|Word
name|reg
index|[
name|NREG
index|]
decl_stmt|;
comment|/* process' registers */
name|Word
name|oreg
index|[
name|NREG
index|]
decl_stmt|;
comment|/* registers when process last stopped */
name|short
name|status
decl_stmt|;
comment|/* either STOPPED or FINISHED */
name|short
name|signo
decl_stmt|;
comment|/* signal that stopped process */
name|int
name|exitval
decl_stmt|;
comment|/* return value from exit() */
name|long
name|sigset
decl_stmt|;
comment|/* bit array of traced signals */
name|CacheWord
name|word
index|[
name|CSIZE
index|]
decl_stmt|;
comment|/* text segment cache */
name|Ttyinfo
name|ttyinfo
decl_stmt|;
comment|/* process' terminal characteristics */
block|}
struct|;
end_struct

begin_comment
comment|/*  * These definitions are for the arguments to "pio".  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|PREAD
block|,
name|PWRITE
block|}
name|PioOp
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|TEXTSEG
block|,
name|DATASEG
block|}
name|PioSeg
typedef|;
end_typedef

begin_decl_stmt
name|private
name|struct
name|Process
name|pbuf
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXNCMDARGS
value|100
end_define

begin_comment
comment|/* maximum number of arguments to RUN */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Boolean
name|just_started
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|String
name|argv
index|[
name|MAXNCMDARGS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|String
name|infile
decl_stmt|,
name|outfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize process information.  */
end_comment

begin_function
name|public
name|process_init
parameter_list|()
block|{
specifier|register
name|Integer
name|i
decl_stmt|;
name|Char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|process
operator|=
operator|&
name|pbuf
expr_stmt|;
name|process
operator|->
name|status
operator|=
operator|(
name|coredump
operator|)
condition|?
name|STOPPED
else|:
name|NOTSTARTED
expr_stmt|;
name|setsigtrace
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NREG
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$r%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|defregname
argument_list|(
name|identname
argument_list|(
name|buf
argument_list|,
name|false
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|defregname
argument_list|(
name|identname
argument_list|(
literal|"$ap"
argument_list|,
name|true
argument_list|)
argument_list|,
name|ARGP
argument_list|)
expr_stmt|;
name|defregname
argument_list|(
name|identname
argument_list|(
literal|"$fp"
argument_list|,
name|true
argument_list|)
argument_list|,
name|FRP
argument_list|)
expr_stmt|;
name|defregname
argument_list|(
name|identname
argument_list|(
literal|"$sp"
argument_list|,
name|true
argument_list|)
argument_list|,
name|STKP
argument_list|)
expr_stmt|;
name|defregname
argument_list|(
name|identname
argument_list|(
literal|"$pc"
argument_list|,
name|true
argument_list|)
argument_list|,
name|PROGCTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|coredump
condition|)
block|{
name|coredump_readin
argument_list|(
name|process
operator|->
name|mask
argument_list|,
name|process
operator|->
name|reg
argument_list|,
name|process
operator|->
name|signo
argument_list|)
expr_stmt|;
name|pc
operator|=
name|process
operator|->
name|reg
index|[
name|PROGCTR
index|]
expr_stmt|;
name|getsrcpos
argument_list|()
expr_stmt|;
block|}
name|arginit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routines to get at process information from outside this module.  */
end_comment

begin_function
name|public
name|Word
name|reg
parameter_list|(
name|n
parameter_list|)
name|Integer
name|n
decl_stmt|;
block|{
specifier|register
name|Word
name|w
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NREG
condition|)
block|{
name|w
operator|=
name|process
operator|->
name|mask
expr_stmt|;
block|}
else|else
block|{
name|w
operator|=
name|process
operator|->
name|reg
index|[
name|n
index|]
expr_stmt|;
block|}
return|return
name|w
return|;
block|}
end_function

begin_function
name|public
name|setreg
parameter_list|(
name|n
parameter_list|,
name|w
parameter_list|)
name|Integer
name|n
decl_stmt|;
name|Word
name|w
decl_stmt|;
block|{
name|process
operator|->
name|reg
index|[
name|n
index|]
operator|=
name|w
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Begin execution.  *  * We set a breakpoint at the end of the code so that the  * process data doesn't disappear after the program terminates.  */
end_comment

begin_function_decl
name|private
name|Boolean
name|remade
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|public
name|start
parameter_list|(
name|argv
parameter_list|,
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|String
name|argv
index|[]
decl_stmt|;
name|String
name|infile
decl_stmt|,
name|outfile
decl_stmt|;
block|{
name|String
name|pargv
index|[
literal|4
index|]
decl_stmt|;
name|Node
name|cond
decl_stmt|;
if|if
condition|(
name|coredump
condition|)
block|{
name|coredump
operator|=
name|false
expr_stmt|;
name|fclose
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|coredump_close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|argv
operator|==
name|nil
condition|)
block|{
name|argv
operator|=
name|pargv
expr_stmt|;
name|pargv
index|[
literal|0
index|]
operator|=
name|objname
expr_stmt|;
name|pargv
index|[
literal|1
index|]
operator|=
name|nil
expr_stmt|;
block|}
else|else
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|nil
expr_stmt|;
block|}
if|if
condition|(
name|remade
argument_list|(
name|objname
argument_list|)
condition|)
block|{
name|reinit
argument_list|(
name|argv
argument_list|,
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
name|pstart
argument_list|(
name|process
argument_list|,
name|argv
argument_list|,
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|process
operator|->
name|status
operator|==
name|STOPPED
condition|)
block|{
name|pc
operator|=
literal|0
expr_stmt|;
name|curfunc
operator|=
name|program
expr_stmt|;
if|if
condition|(
name|objsize
operator|!=
literal|0
condition|)
block|{
name|cond
operator|=
name|build
argument_list|(
name|O_EQ
argument_list|,
name|build
argument_list|(
name|O_SYM
argument_list|,
name|pcsym
argument_list|)
argument_list|,
name|build
argument_list|(
name|O_LCON
argument_list|,
name|lastaddr
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|event_once
argument_list|(
name|cond
argument_list|,
name|buildcmdlist
argument_list|(
name|build
argument_list|(
name|O_ENDX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if the object file has changed since the symbolic  * information last was read.  */
end_comment

begin_decl_stmt
name|private
name|time_t
name|modtime
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|Boolean
name|remade
parameter_list|(
name|filename
parameter_list|)
name|String
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|Boolean
name|b
decl_stmt|;
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
operator|(
name|Boolean
operator|)
operator|(
name|modtime
operator|!=
literal|0
name|and
name|modtime
operator|<
name|s
operator|.
name|st_mtime
operator|)
expr_stmt|;
name|modtime
operator|=
name|s
operator|.
name|st_mtime
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Set up what signals we want to trace.  */
end_comment

begin_function
name|private
name|setsigtrace
parameter_list|()
block|{
specifier|register
name|Integer
name|i
decl_stmt|;
specifier|register
name|Process
name|p
decl_stmt|;
name|p
operator|=
name|process
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NSIG
condition|;
name|i
operator|++
control|)
block|{
name|psigtrace
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|psigtrace
argument_list|(
name|p
argument_list|,
name|SIGHUP
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|psigtrace
argument_list|(
name|p
argument_list|,
name|SIGKILL
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|psigtrace
argument_list|(
name|p
argument_list|,
name|SIGALRM
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|psigtrace
argument_list|(
name|p
argument_list|,
name|SIGTSTP
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|psigtrace
argument_list|(
name|p
argument_list|,
name|SIGCONT
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|psigtrace
argument_list|(
name|p
argument_list|,
name|SIGCHLD
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the argument list.  */
end_comment

begin_function
name|public
name|arginit
parameter_list|()
block|{
name|infile
operator|=
name|nil
expr_stmt|;
name|outfile
operator|=
name|nil
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|objname
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add an argument to the list for the debuggee.  */
end_comment

begin_function
name|public
name|newarg
parameter_list|(
name|arg
parameter_list|)
name|String
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|>=
name|MAXNCMDARGS
condition|)
block|{
name|error
argument_list|(
literal|"too many arguments"
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the standard input for the debuggee.  */
end_comment

begin_function
name|public
name|inarg
parameter_list|(
name|filename
parameter_list|)
name|String
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|infile
operator|!=
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"multiple input redirects"
argument_list|)
expr_stmt|;
block|}
name|infile
operator|=
name|filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the standard output for the debuggee.  * Probably should check to avoid overwriting an existing file.  */
end_comment

begin_function
name|public
name|outarg
parameter_list|(
name|filename
parameter_list|)
name|String
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|outfile
operator|!=
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"multiple output redirect"
argument_list|)
expr_stmt|;
block|}
name|outfile
operator|=
name|filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start debuggee executing.  */
end_comment

begin_function
name|public
name|run
parameter_list|()
block|{
name|process
operator|->
name|status
operator|=
name|STOPPED
expr_stmt|;
name|fixbps
argument_list|()
expr_stmt|;
name|curline
operator|=
literal|0
expr_stmt|;
name|start
argument_list|(
name|argv
argument_list|,
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|just_started
operator|=
name|true
expr_stmt|;
name|isstopped
operator|=
name|false
expr_stmt|;
name|cont
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Continue execution wherever we left off.  *  * Note that this routine never returns.  Eventually bpact() will fail  * and we'll call printstatus or step will call it.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|Intfunc
parameter_list|()
function_decl|;
end_typedef

begin_decl_stmt
name|private
name|Intfunc
modifier|*
name|dbintr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|private
name|intr
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|succeeds
value|== true
end_define

begin_define
define|#
directive|define
name|fails
value|== false
end_define

begin_function
name|public
name|cont
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|dbintr
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|just_started
condition|)
block|{
name|just_started
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|not
name|isstopped
condition|)
block|{
name|error
argument_list|(
literal|"can't continue execution"
argument_list|)
expr_stmt|;
block|}
name|isstopped
operator|=
name|false
expr_stmt|;
name|stepover
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|single_stepping
condition|)
block|{
name|printnews
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|setallbps
argument_list|()
expr_stmt|;
name|resume
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|unsetallbps
argument_list|()
expr_stmt|;
if|if
condition|(
name|bpact
argument_list|()
name|fails
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
block|}
block|}
name|stepover
argument_list|()
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * This routine is called if we get an interrupt while "running" px  * but actually in the debugger.  Could happen, for example, while  * processing breakpoints.  *  * We basically just want to keep going; the assumption is  * that when the process resumes it will get the interrupt  * which will then be handled.  */
end_comment

begin_function
name|private
name|intr
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|public
name|fixintr
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|dbintr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Resume execution.  */
end_comment

begin_function
name|public
name|resume
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
specifier|register
name|Process
name|p
decl_stmt|;
name|p
operator|=
name|process
expr_stmt|;
if|if
condition|(
name|traceexec
condition|)
block|{
name|printf
argument_list|(
literal|"execution resumes at pc 0x%x\n"
argument_list|,
name|process
operator|->
name|reg
index|[
name|PROGCTR
index|]
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|pcont
argument_list|(
name|p
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|pc
operator|=
name|process
operator|->
name|reg
index|[
name|PROGCTR
index|]
expr_stmt|;
if|if
condition|(
name|traceexec
condition|)
block|{
name|printf
argument_list|(
literal|"execution stops at pc 0x%x on sig %d\n"
argument_list|,
name|process
operator|->
name|reg
index|[
name|PROGCTR
index|]
argument_list|,
name|p
operator|->
name|signo
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|status
operator|!=
name|STOPPED
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|signo
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"program terminated by signal %d"
argument_list|,
name|p
operator|->
name|signo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|not
name|runfirst
condition|)
block|{
name|error
argument_list|(
literal|"program unexpectedly exited with %d"
argument_list|,
name|p
operator|->
name|exitval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Continue execution up to the next source line.  *  * There are two ways to define the next source line depending on what  * is desired when a procedure or function call is encountered.  Step  * stops at the beginning of the procedure or call; next skips over it.  */
end_comment

begin_comment
comment|/*  * Stepc is what is called when the step command is given.  * It has to play with the "isstopped" information.  */
end_comment

begin_function
name|public
name|stepc
parameter_list|()
block|{
if|if
condition|(
name|not
name|isstopped
condition|)
block|{
name|error
argument_list|(
literal|"can't continue execution"
argument_list|)
expr_stmt|;
block|}
name|isstopped
operator|=
name|false
expr_stmt|;
name|dostep
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|isstopped
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
name|public
name|next
parameter_list|()
block|{
if|if
condition|(
name|not
name|isstopped
condition|)
block|{
name|error
argument_list|(
literal|"can't continue execution"
argument_list|)
expr_stmt|;
block|}
name|isstopped
operator|=
name|false
expr_stmt|;
name|dostep
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|isstopped
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Single-step over the current machine instruction.  *  * If we're single-stepping by source line we want to step to the  * next source line.  Otherwise we're going to continue so there's  * no reason to do all the work necessary to single-step to the next  * source line.  */
end_comment

begin_function
name|private
name|stepover
parameter_list|()
block|{
name|Boolean
name|b
decl_stmt|;
if|if
condition|(
name|single_stepping
condition|)
block|{
name|dostep
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|inst_tracing
expr_stmt|;
name|inst_tracing
operator|=
name|true
expr_stmt|;
name|dostep
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|inst_tracing
operator|=
name|b
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Resume execution up to the given address.  It is assumed that  * no breakpoints exist between the current address and the one  * we're stepping to.  This saves us from setting all the breakpoints.  */
end_comment

begin_function
name|public
name|stepto
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
name|setbp
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|resume
argument_list|(
name|DEFSIG
argument_list|)
expr_stmt|;
name|unsetbp
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print the status of the process.  * This routine does not return.  */
end_comment

begin_function
name|public
name|printstatus
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
name|process
operator|->
name|status
operator|==
name|FINISHED
condition|)
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curfunc
operator|=
name|whatblock
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|getsrcpos
argument_list|()
expr_stmt|;
if|if
condition|(
name|process
operator|->
name|signo
operator|==
name|SIGINT
condition|)
block|{
name|isstopped
operator|=
name|true
expr_stmt|;
name|printerror
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isbperr
argument_list|()
name|and
name|isstopped
condition|)
block|{
name|printf
argument_list|(
literal|"stopped "
argument_list|)
expr_stmt|;
name|printloc
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|curline
operator|>
literal|0
condition|)
block|{
name|printlines
argument_list|(
name|curline
argument_list|,
name|curline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printinst
argument_list|(
name|pc
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
name|erecover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fixbps
argument_list|()
expr_stmt|;
name|fixintr
argument_list|()
expr_stmt|;
name|isstopped
operator|=
name|true
expr_stmt|;
name|printerror
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print out the current location in the debuggee.  */
end_comment

begin_function
name|public
name|printloc
parameter_list|()
block|{
name|printf
argument_list|(
literal|"in "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stdout
argument_list|,
name|curfunc
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|curline
operator|>
literal|0
name|and
name|not
name|useInstLoc
condition|)
block|{
name|printsrcpos
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|useInstLoc
operator|=
name|false
expr_stmt|;
name|curline
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"at 0x%x"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Some functions for testing the state of the process.  */
end_comment

begin_function
name|public
name|Boolean
name|notstarted
parameter_list|(
name|p
parameter_list|)
name|Process
name|p
decl_stmt|;
block|{
return|return
call|(
name|Boolean
call|)
argument_list|(
name|p
operator|->
name|status
operator|==
name|NOTSTARTED
argument_list|)
return|;
block|}
end_function

begin_function
name|public
name|Boolean
name|isfinished
parameter_list|(
name|p
parameter_list|)
name|Process
name|p
decl_stmt|;
block|{
return|return
call|(
name|Boolean
call|)
argument_list|(
name|p
operator|->
name|status
operator|==
name|FINISHED
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the signal number which stopped the process.  */
end_comment

begin_function
name|public
name|Integer
name|errnum
parameter_list|(
name|p
parameter_list|)
name|Process
name|p
decl_stmt|;
block|{
return|return
name|p
operator|->
name|signo
return|;
block|}
end_function

begin_comment
comment|/*  * Return the termination code of the process.  */
end_comment

begin_function
name|public
name|Integer
name|exitcode
parameter_list|(
name|p
parameter_list|)
name|Process
name|p
decl_stmt|;
block|{
return|return
name|p
operator|->
name|exitval
return|;
block|}
end_function

begin_comment
comment|/*  * These routines are used to access the debuggee process from  * outside this module.  *  * They invoke "pio" which eventually leads to a call to "ptrace".  * The system generates an I/O error when a ptrace fails.  During reads  * these are ignored, during writes they are reported as an error, and  * for anything else they cause a fatal error.  */
end_comment

begin_function_decl
specifier|extern
name|Intfunc
modifier|*
name|onsyserr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|badaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|read_err
argument_list|()
decl_stmt|,
name|write_err
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read from the process' instruction area.  */
end_comment

begin_function
name|public
name|iread
parameter_list|(
name|buff
parameter_list|,
name|addr
parameter_list|,
name|nbytes
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|Intfunc
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|onsyserr
argument_list|(
name|EIO
argument_list|,
name|read_err
argument_list|)
expr_stmt|;
name|badaddr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|coredump
condition|)
block|{
name|coredump_readtext
argument_list|(
name|buff
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pio
argument_list|(
name|process
argument_list|,
name|PREAD
argument_list|,
name|TEXTSEG
argument_list|,
name|buff
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
name|onsyserr
argument_list|(
name|EIO
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Write to the process' instruction area, usually in order to set  * or unset a breakpoint.  */
end_comment

begin_function
name|public
name|iwrite
parameter_list|(
name|buff
parameter_list|,
name|addr
parameter_list|,
name|nbytes
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|Intfunc
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|coredump
condition|)
block|{
name|error
argument_list|(
literal|"no process to write to"
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|onsyserr
argument_list|(
name|EIO
argument_list|,
name|write_err
argument_list|)
expr_stmt|;
name|badaddr
operator|=
name|addr
expr_stmt|;
name|pio
argument_list|(
name|process
argument_list|,
name|PWRITE
argument_list|,
name|TEXTSEG
argument_list|,
name|buff
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|onsyserr
argument_list|(
name|EIO
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read for the process' data area.  */
end_comment

begin_function
name|public
name|dread
parameter_list|(
name|buff
parameter_list|,
name|addr
parameter_list|,
name|nbytes
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|Intfunc
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|onsyserr
argument_list|(
name|EIO
argument_list|,
name|read_err
argument_list|)
expr_stmt|;
name|badaddr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|coredump
condition|)
block|{
name|coredump_readdata
argument_list|(
name|buff
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pio
argument_list|(
name|process
argument_list|,
name|PREAD
argument_list|,
name|DATASEG
argument_list|,
name|buff
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
name|onsyserr
argument_list|(
name|EIO
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write to the process' data area.  */
end_comment

begin_function
name|public
name|dwrite
parameter_list|(
name|buff
parameter_list|,
name|addr
parameter_list|,
name|nbytes
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|Intfunc
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|coredump
condition|)
block|{
name|error
argument_list|(
literal|"no process to write to"
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|onsyserr
argument_list|(
name|EIO
argument_list|,
name|write_err
argument_list|)
expr_stmt|;
name|badaddr
operator|=
name|addr
expr_stmt|;
name|pio
argument_list|(
name|process
argument_list|,
name|PWRITE
argument_list|,
name|DATASEG
argument_list|,
name|buff
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|onsyserr
argument_list|(
name|EIO
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trap for errors in reading or writing to a process.  * The current approach is to "ignore" read errors and complain  * bitterly about write errors.  */
end_comment

begin_function
name|private
name|read_err
parameter_list|()
block|{
comment|/*      * Ignore.      */
block|}
end_function

begin_function
name|private
name|write_err
parameter_list|()
block|{
name|error
argument_list|(
literal|"can't write to process (address 0x%x)"
argument_list|,
name|badaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ptrace interface.  */
end_comment

begin_comment
comment|/*  * This magic macro enables us to look at the process' registers  * in its user structure.  */
end_comment

begin_define
define|#
directive|define
name|regloc
parameter_list|(
name|reg
parameter_list|)
value|(ctob(UPAGES) + ( sizeof(int) * (reg) ))
end_define

begin_define
define|#
directive|define
name|WMASK
value|(~(sizeof(Word) - 1))
end_define

begin_define
define|#
directive|define
name|cachehash
parameter_list|(
name|addr
parameter_list|)
value|((unsigned) ((addr>> 2) % CSIZE))
end_define

begin_define
define|#
directive|define
name|FIRSTSIG
value|SIGINT
end_define

begin_define
define|#
directive|define
name|LASTSIG
value|SIGQUIT
end_define

begin_define
define|#
directive|define
name|ischild
parameter_list|(
name|pid
parameter_list|)
value|((pid) == 0)
end_define

begin_define
define|#
directive|define
name|traceme
parameter_list|()
value|ptrace(0, 0, 0, 0)
end_define

begin_define
define|#
directive|define
name|setrep
parameter_list|(
name|n
parameter_list|)
value|(1<< ((n)-1))
end_define

begin_define
define|#
directive|define
name|istraced
parameter_list|(
name|p
parameter_list|)
value|(p->sigset&setrep(p->signo))
end_define

begin_comment
comment|/*  * Ptrace options (specified in first argument).  */
end_comment

begin_define
define|#
directive|define
name|UREAD
value|3
end_define

begin_comment
comment|/* read from process's user structure */
end_comment

begin_define
define|#
directive|define
name|UWRITE
value|6
end_define

begin_comment
comment|/* write to process's user structure */
end_comment

begin_define
define|#
directive|define
name|IREAD
value|1
end_define

begin_comment
comment|/* read from process's instruction space */
end_comment

begin_define
define|#
directive|define
name|IWRITE
value|4
end_define

begin_comment
comment|/* write to process's instruction space */
end_comment

begin_define
define|#
directive|define
name|DREAD
value|2
end_define

begin_comment
comment|/* read from process's data space */
end_comment

begin_define
define|#
directive|define
name|DWRITE
value|5
end_define

begin_comment
comment|/* write to process's data space */
end_comment

begin_define
define|#
directive|define
name|CONT
value|7
end_define

begin_comment
comment|/* continue stopped process */
end_comment

begin_define
define|#
directive|define
name|SSTEP
value|9
end_define

begin_comment
comment|/* continue for approximately one instruction */
end_comment

begin_define
define|#
directive|define
name|PKILL
value|8
end_define

begin_comment
comment|/* terminate the process */
end_comment

begin_comment
comment|/*  * Start up a new process by forking and exec-ing the  * given argument list, returning when the process is loaded  * and ready to execute.  The PROCESS information (pointed to  * by the first argument) is appropriately filled.  *  * If the given PROCESS structure is associated with an already running  * process, we terminate it.  */
end_comment

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
name|private
name|pstart
parameter_list|(
name|p
parameter_list|,
name|argv
parameter_list|,
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|Process
name|p
decl_stmt|;
name|String
name|argv
index|[]
decl_stmt|;
name|String
name|infile
decl_stmt|;
name|String
name|outfile
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|Fileid
name|in
decl_stmt|,
name|out
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|pid
operator|!=
literal|0
condition|)
block|{
comment|/* child already running? */
name|ptrace
argument_list|(
name|PKILL
argument_list|,
name|p
operator|->
name|pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... kill it! */
name|pwait
argument_list|(
name|p
operator|->
name|pid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* wait for it to exit */
name|unptraced
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
name|psigtrace
argument_list|(
name|p
argument_list|,
name|SIGTRAP
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|->
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|panic
argument_list|(
literal|"can't fork"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ischild
argument_list|(
name|p
operator|->
name|pid
argument_list|)
condition|)
block|{
name|traceme
argument_list|()
expr_stmt|;
if|if
condition|(
name|infile
operator|!=
name|nil
condition|)
block|{
name|in
operator|=
name|open
argument_list|(
name|infile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
operator|-
literal|1
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"can't read "
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|infile
argument_list|,
name|strlen
argument_list|(
name|infile
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fswap
argument_list|(
literal|0
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outfile
operator|!=
name|nil
condition|)
block|{
name|out
operator|=
name|creat
argument_list|(
name|outfile
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
operator|-
literal|1
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"can't write "
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|outfile
argument_list|,
name|strlen
argument_list|(
name|outfile
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fswap
argument_list|(
literal|1
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|execv
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"can't exec "
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pwait
argument_list|(
name|p
operator|->
name|pid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|getinfo
argument_list|(
name|p
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|status
operator|!=
name|STOPPED
condition|)
block|{
name|error
argument_list|(
literal|"program could not begin execution"
argument_list|)
expr_stmt|;
block|}
name|ptraced
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Continue a stopped process.  The first argument points to a Process  * structure.  Before the process is restarted it's user area is modified  * according to the values in the structure.  When this routine finishes,  * the structure has the new values from the process's user area.  *  * Pcont terminates when the process stops with a signal pending that  * is being traced (via psigtrace), or when the process terminates.  */
end_comment

begin_function
name|private
name|pcont
parameter_list|(
name|p
parameter_list|,
name|signo
parameter_list|)
name|Process
name|p
decl_stmt|;
name|int
name|signo
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|pid
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"program not active"
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|setinfo
argument_list|(
name|p
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|sigs_off
argument_list|()
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|CONT
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|p
operator|->
name|reg
index|[
name|PROGCTR
index|]
argument_list|,
name|p
operator|->
name|signo
argument_list|)
operator|<
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"error %d trying to continue process"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
name|pwait
argument_list|(
name|p
operator|->
name|pid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|sigs_on
argument_list|()
expr_stmt|;
name|getinfo
argument_list|(
name|p
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|->
name|status
operator|==
name|STOPPED
name|and
name|not
name|istraced
argument_list|(
name|p
argument_list|)
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Single step as best ptrace can.  */
end_comment

begin_function
name|public
name|pstep
parameter_list|(
name|p
parameter_list|)
name|Process
name|p
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|setinfo
argument_list|(
name|p
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|sigs_off
argument_list|()
expr_stmt|;
name|ptrace
argument_list|(
name|SSTEP
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|p
operator|->
name|reg
index|[
name|PROGCTR
index|]
argument_list|,
name|p
operator|->
name|signo
argument_list|)
expr_stmt|;
name|pwait
argument_list|(
name|p
operator|->
name|pid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|sigs_on
argument_list|()
expr_stmt|;
name|getinfo
argument_list|(
name|p
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return from execution when the given signal is pending.  */
end_comment

begin_function
name|public
name|psigtrace
parameter_list|(
name|p
parameter_list|,
name|sig
parameter_list|,
name|sw
parameter_list|)
name|Process
name|p
decl_stmt|;
name|int
name|sig
decl_stmt|;
name|Boolean
name|sw
decl_stmt|;
block|{
if|if
condition|(
name|sw
condition|)
block|{
name|p
operator|->
name|sigset
operator||=
name|setrep
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|sigset
operator|&=
operator|~
name|setrep
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Don't catch any signals.  * Particularly useful when letting a process finish uninhibited.  */
end_comment

begin_function
name|public
name|unsetsigtraces
parameter_list|(
name|p
parameter_list|)
name|Process
name|p
decl_stmt|;
block|{
name|p
operator|->
name|sigset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Turn off attention to signals not being caught.  */
end_comment

begin_decl_stmt
name|private
name|Intfunc
modifier|*
name|sigfunc
index|[
name|NSIG
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|sigs_off
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRSTSIG
init|;
name|i
operator|<
name|LASTSIG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|SIGKILL
condition|)
block|{
name|sigfunc
index|[
name|i
index|]
operator|=
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Turn back on attention to signals.  */
end_comment

begin_function
name|private
name|sigs_on
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRSTSIG
init|;
name|i
operator|<
name|LASTSIG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|SIGKILL
condition|)
block|{
name|signal
argument_list|(
name|i
argument_list|,
name|sigfunc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Get process information from user area.  */
end_comment

begin_decl_stmt
name|private
name|int
name|rloc
index|[]
init|=
block|{
name|R0
block|,
name|R1
block|,
name|R2
block|,
name|R3
block|,
name|R4
block|,
name|R5
block|,
name|R6
block|,
name|R7
block|,
name|R8
block|,
name|R9
block|,
name|R10
block|,
name|R11
block|,
name|AP
block|,
name|FP
block|,
name|SP
block|,
name|PC
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|getinfo
parameter_list|(
name|p
parameter_list|,
name|status
parameter_list|)
specifier|register
name|Process
name|p
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|p
operator|->
name|signo
operator|=
operator|(
name|status
operator|&
literal|0177
operator|)
expr_stmt|;
name|p
operator|->
name|exitval
operator|=
operator|(
operator|(
name|status
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|signo
operator|!=
name|STOPPED
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|FINISHED
expr_stmt|;
name|p
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|status
operator|=
name|p
operator|->
name|signo
expr_stmt|;
name|p
operator|->
name|signo
operator|=
name|p
operator|->
name|exitval
expr_stmt|;
name|p
operator|->
name|exitval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|mask
operator|=
name|ptrace
argument_list|(
name|UREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|PS
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NREG
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|->
name|reg
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|UREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|rloc
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|oreg
index|[
name|i
index|]
operator|=
name|p
operator|->
name|reg
index|[
name|i
index|]
expr_stmt|;
block|}
name|savetty
argument_list|(
name|stdout
argument_list|,
operator|&
operator|(
name|p
operator|->
name|ttyinfo
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set process's user area information from given process structure.  */
end_comment

begin_function
name|private
name|setinfo
parameter_list|(
name|p
parameter_list|,
name|signo
parameter_list|)
specifier|register
name|Process
name|p
decl_stmt|;
name|int
name|signo
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
if|if
condition|(
name|signo
operator|==
name|DEFSIG
condition|)
block|{
if|if
condition|(
name|istraced
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|p
operator|->
name|signo
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|->
name|signo
operator|=
name|signo
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NREG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|p
operator|->
name|reg
index|[
name|i
index|]
operator|)
operator|!=
name|p
operator|->
name|oreg
index|[
name|i
index|]
condition|)
block|{
name|ptrace
argument_list|(
name|UWRITE
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|regloc
argument_list|(
name|rloc
index|[
name|i
index|]
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|restoretty
argument_list|(
name|stdout
argument_list|,
operator|&
operator|(
name|p
operator|->
name|ttyinfo
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Structure for reading and writing by words, but dealing with bytes.  */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|Word
name|pword
decl_stmt|;
name|Byte
name|pbyte
index|[
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
index|]
decl_stmt|;
block|}
name|Pword
typedef|;
end_typedef

begin_comment
comment|/*  * Read (write) from (to) the process' address space.  * We must deal with ptrace's inability to look anywhere other  * than at a word boundary.  */
end_comment

begin_function_decl
name|private
name|Word
name|fetch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|store
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|private
name|pio
parameter_list|(
name|p
parameter_list|,
name|op
parameter_list|,
name|seg
parameter_list|,
name|buff
parameter_list|,
name|addr
parameter_list|,
name|nbytes
parameter_list|)
name|Process
name|p
decl_stmt|;
name|PioOp
name|op
decl_stmt|;
name|PioSeg
name|seg
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Address
name|newaddr
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
name|Pword
name|w
decl_stmt|;
name|Address
name|wordaddr
decl_stmt|;
name|int
name|byteoff
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|status
operator|!=
name|STOPPED
condition|)
block|{
name|error
argument_list|(
literal|"program is not active"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|buff
expr_stmt|;
name|newaddr
operator|=
name|addr
expr_stmt|;
name|wordaddr
operator|=
operator|(
name|newaddr
operator|&
name|WMASK
operator|)
expr_stmt|;
if|if
condition|(
name|wordaddr
operator|!=
name|newaddr
condition|)
block|{
name|w
operator|.
name|pword
operator|=
name|fetch
argument_list|(
name|p
argument_list|,
name|seg
argument_list|,
name|wordaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|newaddr
operator|-
name|wordaddr
init|;
name|i
operator|<
expr|sizeof
operator|(
name|Word
operator|)
name|and
name|nbytes
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|op
operator|==
name|PREAD
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|w
operator|.
name|pbyte
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|w
operator|.
name|pbyte
index|[
name|i
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
name|nbytes
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|PWRITE
condition|)
block|{
name|store
argument_list|(
name|p
argument_list|,
name|seg
argument_list|,
name|wordaddr
argument_list|,
name|w
operator|.
name|pword
argument_list|)
expr_stmt|;
block|}
name|newaddr
operator|=
name|wordaddr
operator|+
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
block|}
name|byteoff
operator|=
operator|(
name|nbytes
operator|&
operator|(
operator|~
name|WMASK
operator|)
operator|)
expr_stmt|;
name|nbytes
operator|-=
name|byteoff
expr_stmt|;
name|bufend
operator|=
name|cp
operator|+
name|nbytes
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|bufend
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|PREAD
condition|)
block|{
operator|*
operator|(
operator|(
name|Word
operator|*
operator|)
name|cp
operator|)
operator|=
name|fetch
argument_list|(
name|p
argument_list|,
name|seg
argument_list|,
name|newaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|store
argument_list|(
name|p
argument_list|,
name|seg
argument_list|,
name|newaddr
argument_list|,
operator|*
operator|(
operator|(
name|Word
operator|*
operator|)
name|cp
operator|)
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
name|newaddr
operator|+=
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|byteoff
operator|>
literal|0
condition|)
block|{
name|w
operator|.
name|pword
operator|=
name|fetch
argument_list|(
name|p
argument_list|,
name|seg
argument_list|,
name|newaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|byteoff
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|op
operator|==
name|PREAD
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|w
operator|.
name|pbyte
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|w
operator|.
name|pbyte
index|[
name|i
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|==
name|PWRITE
condition|)
block|{
name|store
argument_list|(
name|p
argument_list|,
name|seg
argument_list|,
name|newaddr
argument_list|,
name|w
operator|.
name|pword
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Get a word from a process at the given address.  * The address is assumed to be on a word boundary.  *  * A simple cache scheme is used to avoid redundant ptrace calls  * to the instruction space since it is assumed to be pure.  *  * It is necessary to use a write-through scheme so that  * breakpoints right next to each other don't interfere.  */
end_comment

begin_decl_stmt
name|private
name|Integer
name|nfetchs
decl_stmt|,
name|nreads
decl_stmt|,
name|nwrites
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|Word
name|fetch
parameter_list|(
name|p
parameter_list|,
name|seg
parameter_list|,
name|addr
parameter_list|)
name|Process
name|p
decl_stmt|;
name|PioSeg
name|seg
decl_stmt|;
specifier|register
name|int
name|addr
decl_stmt|;
block|{
specifier|register
name|CacheWord
modifier|*
name|wp
decl_stmt|;
specifier|register
name|Word
name|w
decl_stmt|;
switch|switch
condition|(
name|seg
condition|)
block|{
case|case
name|TEXTSEG
case|:
operator|++
name|nfetchs
expr_stmt|;
name|wp
operator|=
operator|&
name|p
operator|->
name|word
index|[
name|cachehash
argument_list|(
name|addr
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
name|or
name|wp
operator|->
name|addr
operator|!=
name|addr
condition|)
block|{
operator|++
name|nreads
expr_stmt|;
name|w
operator|=
name|ptrace
argument_list|(
name|IREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wp
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|wp
operator|->
name|val
operator|=
name|w
expr_stmt|;
block|}
else|else
block|{
name|w
operator|=
name|wp
operator|->
name|val
expr_stmt|;
block|}
break|break;
case|case
name|DATASEG
case|:
name|w
operator|=
name|ptrace
argument_list|(
name|DREAD
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"fetch: bad seg %d"
argument_list|,
name|seg
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
return|return
name|w
return|;
block|}
end_function

begin_comment
comment|/*  * Put a word into the process' address space at the given address.  * The address is assumed to be on a word boundary.  */
end_comment

begin_function
name|private
name|store
parameter_list|(
name|p
parameter_list|,
name|seg
parameter_list|,
name|addr
parameter_list|,
name|data
parameter_list|)
name|Process
name|p
decl_stmt|;
name|PioSeg
name|seg
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|Word
name|data
decl_stmt|;
block|{
specifier|register
name|CacheWord
modifier|*
name|wp
decl_stmt|;
switch|switch
condition|(
name|seg
condition|)
block|{
case|case
name|TEXTSEG
case|:
operator|++
name|nwrites
expr_stmt|;
name|wp
operator|=
operator|&
name|p
operator|->
name|word
index|[
name|cachehash
argument_list|(
name|addr
argument_list|)
index|]
expr_stmt|;
name|wp
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|wp
operator|->
name|val
operator|=
name|data
expr_stmt|;
name|ptrace
argument_list|(
name|IWRITE
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATASEG
case|:
name|ptrace
argument_list|(
name|DWRITE
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"store: bad seg %d"
argument_list|,
name|seg
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_function
name|public
name|printptraceinfo
parameter_list|()
block|{
name|printf
argument_list|(
literal|"%d fetchs, %d reads, %d writes\n"
argument_list|,
name|nfetchs
argument_list|,
name|nreads
argument_list|,
name|nwrites
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Swap file numbers so as to redirect standard input and output.  */
end_comment

begin_function
name|private
name|fswap
parameter_list|(
name|oldfd
parameter_list|,
name|newfd
parameter_list|)
name|int
name|oldfd
decl_stmt|;
name|int
name|newfd
decl_stmt|;
block|{
if|if
condition|(
name|oldfd
operator|!=
name|newfd
condition|)
block|{
name|close
argument_list|(
name|oldfd
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

