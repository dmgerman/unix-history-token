begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)stabstring.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: stabstring.c,v 1.6 84/12/26 10:42:17 linton Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * String information interpretation  *  * The string part of a stab entry is broken up into name and type information.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"stabstring.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"languages.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Special characters in symbol table information.  */
end_comment

begin_define
define|#
directive|define
name|CONSTNAME
value|'c'
end_define

begin_define
define|#
directive|define
name|TYPENAME
value|'t'
end_define

begin_define
define|#
directive|define
name|TAGNAME
value|'T'
end_define

begin_define
define|#
directive|define
name|MODULEBEGIN
value|'m'
end_define

begin_define
define|#
directive|define
name|EXTPROCEDURE
value|'P'
end_define

begin_define
define|#
directive|define
name|PRIVPROCEDURE
value|'Q'
end_define

begin_define
define|#
directive|define
name|INTPROCEDURE
value|'I'
end_define

begin_define
define|#
directive|define
name|EXTFUNCTION
value|'F'
end_define

begin_define
define|#
directive|define
name|PRIVFUNCTION
value|'f'
end_define

begin_define
define|#
directive|define
name|INTFUNCTION
value|'J'
end_define

begin_define
define|#
directive|define
name|EXTVAR
value|'G'
end_define

begin_define
define|#
directive|define
name|MODULEVAR
value|'S'
end_define

begin_define
define|#
directive|define
name|OWNVAR
value|'V'
end_define

begin_define
define|#
directive|define
name|REGVAR
value|'r'
end_define

begin_define
define|#
directive|define
name|VALUEPARAM
value|'p'
end_define

begin_define
define|#
directive|define
name|VARIABLEPARAM
value|'v'
end_define

begin_define
define|#
directive|define
name|LOCALVAR
end_define

begin_comment
comment|/* default */
end_comment

begin_comment
comment|/*  * Type information special characters.  */
end_comment

begin_define
define|#
directive|define
name|T_SUBRANGE
value|'r'
end_define

begin_define
define|#
directive|define
name|T_ARRAY
value|'a'
end_define

begin_define
define|#
directive|define
name|T_OLDOPENARRAY
value|'A'
end_define

begin_define
define|#
directive|define
name|T_OPENARRAY
value|'O'
end_define

begin_define
define|#
directive|define
name|T_DYNARRAY
value|'D'
end_define

begin_define
define|#
directive|define
name|T_SUBARRAY
value|'E'
end_define

begin_define
define|#
directive|define
name|T_RECORD
value|'s'
end_define

begin_define
define|#
directive|define
name|T_UNION
value|'u'
end_define

begin_define
define|#
directive|define
name|T_ENUM
value|'e'
end_define

begin_define
define|#
directive|define
name|T_PTR
value|'*'
end_define

begin_define
define|#
directive|define
name|T_FUNCVAR
value|'f'
end_define

begin_define
define|#
directive|define
name|T_PROCVAR
value|'p'
end_define

begin_define
define|#
directive|define
name|T_IMPORTED
value|'i'
end_define

begin_define
define|#
directive|define
name|T_SET
value|'S'
end_define

begin_define
define|#
directive|define
name|T_OPAQUE
value|'o'
end_define

begin_define
define|#
directive|define
name|T_FILE
value|'d'
end_define

begin_comment
comment|/*  * Table of types indexed by per-file unique identification number.  */
end_comment

begin_define
define|#
directive|define
name|NTYPES
value|1000
end_define

begin_decl_stmt
name|private
name|Symbol
name|typetable
index|[
name|NTYPES
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|initTypeTable
parameter_list|()
block|{
name|bzero
argument_list|(
name|typetable
argument_list|,
sizeof|sizeof
argument_list|(
name|typetable
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|language_op
argument_list|(
name|curlang
argument_list|,
name|L_MODINIT
argument_list|)
operator|)
operator|(
name|typetable
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Put an nlist entry into the symbol table.  * If it's already there just add the associated information.  *  * Type information is encoded in the name following a ":".  */
end_comment

begin_function_decl
name|private
name|Symbol
name|constype
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|Char
modifier|*
name|curchar
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|skipchar
parameter_list|(
name|ptr
parameter_list|,
name|ch
parameter_list|)
define|\
value|{ \     if (*ptr != ch) { \ 	panic("expected char '%c', found '%s'", ch, ptr); \     } \     ++ptr; \ }
end_define

begin_define
define|#
directive|define
name|optchar
parameter_list|(
name|ptr
parameter_list|,
name|ch
parameter_list|)
define|\
value|{ \     if (*ptr == ch) { \ 	++ptr; \     } \ }
end_define

begin_define
define|#
directive|define
name|chkcont
parameter_list|(
name|ptr
parameter_list|)
define|\
value|{ \     if (*ptr == '?') { \ 	ptr = getcont(); \     } \ }
end_define

begin_define
define|#
directive|define
name|newSym
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
define|\
value|{ \     s = insert(n); \     s->level = curblock->level + 1; \     s->language = curlang; \     s->block = curblock; \ }
end_define

begin_define
define|#
directive|define
name|makeVariable
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|,
name|off
parameter_list|)
define|\
value|{ \     newSym(s, n); \     s->class = VAR; \     s->symvalue.offset = off; \     getType(s); \ }
end_define

begin_define
define|#
directive|define
name|makeParameter
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|,
name|cl
parameter_list|,
name|off
parameter_list|)
define|\
value|{ \     newSym(s, n); \     s->class = cl; \     s->symvalue.offset = off; \     curparam->chain = s; \     curparam = s; \     getType(s); \ }
end_define

begin_function
name|public
name|entersym
parameter_list|(
name|name
parameter_list|,
name|np
parameter_list|)
name|String
name|name
decl_stmt|;
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
block|{
name|Symbol
name|s
decl_stmt|,
name|t
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|Name
name|n
decl_stmt|;
name|char
name|c
decl_stmt|;
name|p
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|n
operator|=
name|identname
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|chkUnnamedBlock
argument_list|()
expr_stmt|;
name|curchar
operator|=
name|p
operator|+
literal|2
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CONSTNAME
case|:
name|newSym
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|constName
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPENAME
case|:
name|newSym
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|typeName
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAGNAME
case|:
name|s
operator|=
name|symbol_alloc
argument_list|()
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|n
expr_stmt|;
name|s
operator|->
name|level
operator|=
name|curblock
operator|->
name|level
operator|+
literal|1
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|s
operator|->
name|block
operator|=
name|curblock
expr_stmt|;
name|tagName
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODULEBEGIN
case|:
name|publicRoutine
argument_list|(
operator|&
name|s
argument_list|,
name|n
argument_list|,
name|MODULE
argument_list|,
name|np
operator|->
name|n_value
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|curmodule
operator|=
name|s
expr_stmt|;
break|break;
case|case
name|EXTPROCEDURE
case|:
name|publicRoutine
argument_list|(
operator|&
name|s
argument_list|,
name|n
argument_list|,
name|PROC
argument_list|,
name|np
operator|->
name|n_value
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRIVPROCEDURE
case|:
name|privateRoutine
argument_list|(
operator|&
name|s
argument_list|,
name|n
argument_list|,
name|PROC
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTPROCEDURE
case|:
name|publicRoutine
argument_list|(
operator|&
name|s
argument_list|,
name|n
argument_list|,
name|PROC
argument_list|,
name|np
operator|->
name|n_value
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXTFUNCTION
case|:
name|publicRoutine
argument_list|(
operator|&
name|s
argument_list|,
name|n
argument_list|,
name|FUNC
argument_list|,
name|np
operator|->
name|n_value
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRIVFUNCTION
case|:
name|privateRoutine
argument_list|(
operator|&
name|s
argument_list|,
name|n
argument_list|,
name|FUNC
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTFUNCTION
case|:
name|publicRoutine
argument_list|(
operator|&
name|s
argument_list|,
name|n
argument_list|,
name|FUNC
argument_list|,
name|np
operator|->
name|n_value
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXTVAR
case|:
name|extVar
argument_list|(
operator|&
name|s
argument_list|,
name|n
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODULEVAR
case|:
if|if
condition|(
name|curblock
operator|->
name|class
operator|!=
name|MODULE
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
block|}
name|makeVariable
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
name|s
operator|->
name|level
operator|=
name|program
operator|->
name|level
expr_stmt|;
name|s
operator|->
name|block
operator|=
name|curmodule
expr_stmt|;
name|getExtRef
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|OWNVAR
case|:
name|makeVariable
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
name|ownVariable
argument_list|(
name|s
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
name|getExtRef
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGVAR
case|:
name|makeVariable
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
name|s
operator|->
name|level
operator|=
operator|-
operator|(
name|s
operator|->
name|level
operator|)
expr_stmt|;
break|break;
case|case
name|VALUEPARAM
case|:
name|makeParameter
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|VAR
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|VARIABLEPARAM
case|:
name|makeParameter
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|REF
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* local variable */
operator|--
name|curchar
expr_stmt|;
name|makeVariable
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tracesyms
condition|)
block|{
name|printdecl
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Enter a named constant.  */
end_comment

begin_function
name|private
name|constName
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|integer
name|i
decl_stmt|;
name|double
name|d
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|buf
index|[
literal|1000
index|]
decl_stmt|;
name|s
operator|->
name|class
operator|=
name|CONST
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|p
operator|=
name|curchar
expr_stmt|;
operator|++
name|curchar
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'b'
case|:
name|s
operator|->
name|type
operator|=
name|t_boolean
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|=
name|build
argument_list|(
name|O_LCON
argument_list|,
name|getint
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|s
operator|->
name|type
operator|=
name|t_char
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|=
name|build
argument_list|(
name|O_LCON
argument_list|,
name|getint
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|s
operator|->
name|type
operator|=
name|t_int
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|=
name|build
argument_list|(
name|O_LCON
argument_list|,
name|getint
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|sscanf
argument_list|(
name|curchar
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|curchar
operator|!=
literal|'\0'
name|and
operator|*
name|curchar
operator|!=
literal|';'
condition|)
block|{
operator|++
name|curchar
expr_stmt|;
block|}
operator|--
name|curchar
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|t_real
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|=
name|build
argument_list|(
name|O_FCON
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|p
operator|=
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|curchar
operator|!=
literal|'\''
condition|)
block|{
operator|*
name|p
operator|=
operator|*
name|curchar
expr_stmt|;
operator|++
name|p
expr_stmt|;
operator|++
name|curchar
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|=
name|build
argument_list|(
name|O_SCON
argument_list|,
name|strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|->
name|nodetype
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|getType
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|=
name|build
argument_list|(
name|O_LCON
argument_list|,
name|getint
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|getType
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|i
operator|=
name|getint
argument_list|()
expr_stmt|;
comment|/* set size */
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|i
operator|=
name|getint
argument_list|()
expr_stmt|;
comment|/* number of bits in constant */
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|=
name|build
argument_list|(
name|O_LCON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|s
operator|->
name|type
operator|=
name|t_int
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|=
name|build
argument_list|(
name|O_LCON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[internal error: unknown constant type '%c']"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|->
name|symvalue
operator|.
name|constval
operator|->
name|nodetype
operator|=
name|s
operator|->
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enter a type name.  */
end_comment

begin_function
name|private
name|typeName
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
specifier|register
name|integer
name|i
decl_stmt|;
name|s
operator|->
name|class
operator|=
name|TYPE
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|s
operator|->
name|block
operator|=
name|curblock
expr_stmt|;
name|s
operator|->
name|level
operator|=
name|curblock
operator|->
name|level
operator|+
literal|1
expr_stmt|;
name|i
operator|=
name|getint
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"bad input on type \"%s\" at \"%s\""
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
name|NTYPES
condition|)
block|{
name|panic
argument_list|(
literal|"too many types in file \"%s\""
argument_list|,
name|curfilename
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*      * A hack for C typedefs that don't create new types,      * e.g. typedef unsigned int Hashvalue;      *  or  typedef struct blah BLAH;      */
if|if
condition|(
operator|*
name|curchar
operator|!=
literal|'='
condition|)
block|{
name|s
operator|->
name|type
operator|=
name|typetable
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|nil
condition|)
block|{
name|s
operator|->
name|type
operator|=
name|symbol_alloc
argument_list|()
expr_stmt|;
name|typetable
index|[
name|i
index|]
operator|=
name|s
operator|->
name|type
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|typetable
index|[
name|i
index|]
operator|!=
name|nil
condition|)
block|{
name|typetable
index|[
name|i
index|]
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|typetable
index|[
name|i
index|]
operator|->
name|class
operator|=
name|TYPE
expr_stmt|;
name|typetable
index|[
name|i
index|]
operator|->
name|type
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|typetable
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
block|}
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|getType
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Enter a tag name.  */
end_comment

begin_function
name|private
name|tagName
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
specifier|register
name|integer
name|i
decl_stmt|;
name|s
operator|->
name|class
operator|=
name|TAG
expr_stmt|;
name|i
operator|=
name|getint
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"bad input on tag \"%s\" at \"%s\""
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
name|NTYPES
condition|)
block|{
name|panic
argument_list|(
literal|"too many types in file \"%s\""
argument_list|,
name|curfilename
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetable
index|[
name|i
index|]
operator|!=
name|nil
condition|)
block|{
name|typetable
index|[
name|i
index|]
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|typetable
index|[
name|i
index|]
operator|->
name|class
operator|=
name|TYPE
expr_stmt|;
name|typetable
index|[
name|i
index|]
operator|->
name|type
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|typetable
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
block|}
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|getType
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup a symbol entry for a public procedure or function.  *  * If it contains nested procedures, then it may already be defined  * in the current block as a MODULE.  */
end_comment

begin_function
name|private
name|publicRoutine
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|,
name|class
parameter_list|,
name|addr
parameter_list|,
name|isinternal
parameter_list|)
name|Symbol
modifier|*
name|s
decl_stmt|;
name|Name
name|n
decl_stmt|;
name|Symclass
name|class
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|boolean
name|isinternal
decl_stmt|;
block|{
name|Symbol
name|nt
decl_stmt|,
name|t
decl_stmt|;
name|newSym
argument_list|(
name|nt
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|isinternal
condition|)
block|{
name|markInternal
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
name|enterRoutine
argument_list|(
name|nt
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|find
argument_list|(
argument|t
argument_list|,
argument|n
argument_list|)
name|where
name|t
operator|!=
name|nt
name|and
name|t
operator|->
name|class
operator|==
name|MODULE
name|and
name|t
operator|->
name|block
operator|==
name|nt
operator|->
name|block
name|endfind
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|t
operator|=
name|nt
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|language
operator|=
name|nt
operator|->
name|language
expr_stmt|;
name|t
operator|->
name|class
operator|=
name|nt
operator|->
name|class
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|nt
operator|->
name|type
expr_stmt|;
name|t
operator|->
name|chain
operator|=
name|nt
operator|->
name|chain
expr_stmt|;
name|t
operator|->
name|symvalue
operator|=
name|nt
operator|->
name|symvalue
expr_stmt|;
name|nt
operator|->
name|class
operator|=
name|EXTREF
expr_stmt|;
name|nt
operator|->
name|symvalue
operator|.
name|extref
operator|=
name|t
expr_stmt|;
name|delete
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|curparam
operator|=
name|t
expr_stmt|;
name|changeBlock
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|block
operator|==
name|program
condition|)
block|{
name|t
operator|->
name|level
operator|=
name|program
operator|->
name|level
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|MODULE
condition|)
block|{
name|t
operator|->
name|level
operator|=
name|t
operator|->
name|block
operator|->
name|level
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|block
operator|->
name|class
operator|==
name|MODULE
condition|)
block|{
name|t
operator|->
name|level
operator|=
name|t
operator|->
name|block
operator|->
name|block
operator|->
name|level
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|level
operator|=
name|t
operator|->
name|block
operator|->
name|level
operator|+
literal|1
expr_stmt|;
block|}
operator|*
name|s
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup a symbol entry for a private procedure or function.  */
end_comment

begin_function
name|private
name|privateRoutine
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|,
name|class
parameter_list|,
name|addr
parameter_list|)
name|Symbol
modifier|*
name|s
decl_stmt|;
name|Name
name|n
decl_stmt|;
name|Symclass
name|class
decl_stmt|;
name|Address
name|addr
decl_stmt|;
block|{
name|Symbol
name|t
decl_stmt|;
name|boolean
name|isnew
decl_stmt|;
name|find
argument_list|(
argument|t
argument_list|,
argument|n
argument_list|)
name|where
name|t
operator|->
name|level
operator|==
name|curmodule
operator|->
name|level
name|and
name|t
operator|->
name|class
operator|==
name|class
name|endfind
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|isnew
operator|=
name|true
expr_stmt|;
name|t
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isnew
operator|=
name|false
expr_stmt|;
block|}
name|t
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|enterRoutine
argument_list|(
name|t
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnew
condition|)
block|{
name|t
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|src
operator|=
name|false
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|funcv
operator|.
expr|inline
operator|=
name|false
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
operator|=
name|addr
expr_stmt|;
name|newfunc
argument_list|(
name|t
argument_list|,
name|codeloc
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|findbeginning
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
operator|*
name|s
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up for beginning a new procedure, function, or module.  * If it's a function, then read the type.  *  * If the next character is a ",", then read the name of the enclosing block.  * Otherwise assume the previous function, if any, is over, and the current  * routine is at the same level.  */
end_comment

begin_function
name|private
name|enterRoutine
parameter_list|(
name|s
parameter_list|,
name|class
parameter_list|)
name|Symbol
name|s
decl_stmt|;
name|Symclass
name|class
decl_stmt|;
block|{
name|s
operator|->
name|class
operator|=
name|class
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|FUNC
condition|)
block|{
name|getType
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|class
operator|!=
name|MODULE
condition|)
block|{
name|getExtRef
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|curchar
operator|==
literal|','
condition|)
block|{
operator|++
name|curchar
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|curchar
operator|!=
literal|'\0'
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
name|enterNestedBlock
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|curblock
operator|->
name|class
operator|==
name|FUNC
name|or
name|curblock
operator|->
name|class
operator|==
name|PROC
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|class
operator|==
name|MODULE
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
block|}
name|enterblock
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|curparam
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handling an external variable is tricky, since we might already  * know it but need to define it's type for other type information  * in the file.  So just in case we read the type information anyway.  */
end_comment

begin_function
name|private
name|extVar
parameter_list|(
name|symp
parameter_list|,
name|n
parameter_list|,
name|off
parameter_list|)
name|Symbol
modifier|*
name|symp
decl_stmt|;
name|Name
name|n
decl_stmt|;
name|integer
name|off
decl_stmt|;
block|{
name|Symbol
name|s
decl_stmt|,
name|t
decl_stmt|;
name|find
argument_list|(
argument|s
argument_list|,
argument|n
argument_list|)
name|where
name|s
operator|->
name|level
operator|==
name|program
operator|->
name|level
name|and
name|s
operator|->
name|class
operator|==
name|VAR
name|endfind
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|makeVariable
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|s
operator|->
name|level
operator|=
name|program
operator|->
name|level
expr_stmt|;
name|s
operator|->
name|block
operator|=
name|curmodule
expr_stmt|;
name|getExtRef
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
block|}
operator|*
name|symp
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the stab string contains the name of the external  * reference.  If so, we create a symbol with that name and class EXTREF, and  * connect it to the given symbol.  This link is created so that when  * we see the linker symbol we can resolve it to the given symbol.  */
end_comment

begin_function
name|private
name|getExtRef
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|Name
name|n
decl_stmt|;
name|Symbol
name|t
decl_stmt|;
if|if
condition|(
operator|*
name|curchar
operator|==
literal|','
name|and
operator|*
operator|(
name|curchar
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|curchar
operator|+
literal|1
argument_list|,
literal|','
argument_list|)
expr_stmt|;
operator|*
name|curchar
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|nil
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|=
name|identname
argument_list|(
name|curchar
operator|+
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|curchar
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|identname
argument_list|(
name|curchar
operator|+
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|t
operator|->
name|language
operator|=
name|s
operator|->
name|language
expr_stmt|;
name|t
operator|->
name|class
operator|=
name|EXTREF
expr_stmt|;
name|t
operator|->
name|block
operator|=
name|program
expr_stmt|;
name|t
operator|->
name|level
operator|=
name|program
operator|->
name|level
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|extref
operator|=
name|s
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find a block with the given identifier in the given outer block.  * If not there, then create it.  */
end_comment

begin_function
name|private
name|Symbol
name|findBlock
parameter_list|(
name|id
parameter_list|,
name|m
parameter_list|)
name|String
name|id
decl_stmt|;
name|Symbol
name|m
decl_stmt|;
block|{
name|Name
name|n
decl_stmt|;
name|Symbol
name|s
decl_stmt|;
name|n
operator|=
name|identname
argument_list|(
name|id
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|find
argument_list|(
argument|s
argument_list|,
argument|n
argument_list|)
name|where
name|s
operator|->
name|block
operator|==
name|m
name|and
name|isblock
argument_list|(
argument|s
argument_list|)
name|endfind
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|s
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|block
operator|=
name|m
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|MODULE
expr_stmt|;
name|s
operator|->
name|level
operator|=
name|m
operator|->
name|level
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Enter a nested block.  * The block within which it is nested is described  * by "module{:module}[:proc]".  */
end_comment

begin_function
name|private
name|enterNestedBlock
parameter_list|(
name|b
parameter_list|)
name|Symbol
name|b
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|Symbol
name|m
decl_stmt|,
name|s
decl_stmt|;
name|Name
name|n
decl_stmt|;
name|q
operator|=
name|curchar
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|q
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|m
operator|=
name|program
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|nil
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|m
operator|=
name|findBlock
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|q
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|q
operator|!=
literal|'\0'
condition|)
block|{
name|m
operator|=
name|findBlock
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|b
operator|->
name|level
operator|=
name|m
operator|->
name|level
operator|+
literal|1
expr_stmt|;
name|b
operator|->
name|block
operator|=
name|m
expr_stmt|;
name|pushBlock
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enter a statically-allocated variable defined within a routine.  *  * Global BSS variables are chained together so we can resolve them  * when the start of common is determined.  The list is kept in order  * so that f77 can display all vars in a COMMON.  */
end_comment

begin_function
name|private
name|ownVariable
parameter_list|(
name|s
parameter_list|,
name|addr
parameter_list|)
name|Symbol
name|s
decl_stmt|;
name|Address
name|addr
decl_stmt|;
block|{
name|s
operator|->
name|level
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|curcomm
condition|)
block|{
if|if
condition|(
name|commchain
operator|!=
name|nil
condition|)
block|{
name|commchain
operator|->
name|symvalue
operator|.
name|common
operator|.
name|chain
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|curcomm
operator|->
name|symvalue
operator|.
name|common
operator|.
name|offset
operator|=
operator|(
name|integer
operator|)
name|s
expr_stmt|;
block|}
name|commchain
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|common
operator|.
name|offset
operator|=
name|addr
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|common
operator|.
name|chain
operator|=
name|nil
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get a type from the current stab string for the given symbol.  */
end_comment

begin_function
name|private
name|getType
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|s
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|class
operator|==
name|TAG
condition|)
block|{
name|addtag
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Construct a type out of a string encoding.  */
end_comment

begin_function_decl
name|private
name|Rangetype
name|getRangeBoundType
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|private
name|Symbol
name|constype
parameter_list|(
name|type
parameter_list|)
name|Symbol
name|type
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
specifier|register
name|integer
name|n
decl_stmt|;
name|char
name|class
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|curchar
operator|==
literal|'@'
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|curchar
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|nil
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"missing ';' after type attributes"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curchar
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|curchar
argument_list|)
condition|)
block|{
name|n
operator|=
name|getint
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|NTYPES
condition|)
block|{
name|panic
argument_list|(
literal|"too many types in file \"%s\""
argument_list|,
name|curfilename
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|curchar
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|typetable
index|[
name|n
index|]
operator|!=
name|nil
condition|)
block|{
name|t
operator|=
name|typetable
index|[
name|n
index|]
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|symbol_alloc
argument_list|()
expr_stmt|;
name|typetable
index|[
name|n
index|]
operator|=
name|t
expr_stmt|;
block|}
operator|++
name|curchar
expr_stmt|;
name|constype
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|typetable
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|t
operator|=
name|symbol_alloc
argument_list|()
expr_stmt|;
name|typetable
index|[
name|n
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|nil
condition|)
block|{
name|t
operator|=
name|symbol_alloc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|type
expr_stmt|;
block|}
name|t
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|t
operator|->
name|level
operator|=
name|curblock
operator|->
name|level
operator|+
literal|1
expr_stmt|;
name|t
operator|->
name|block
operator|=
name|curblock
expr_stmt|;
name|class
operator|=
operator|*
name|curchar
operator|++
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|T_SUBRANGE
case|:
name|consSubrange
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_ARRAY
case|:
name|t
operator|->
name|class
operator|=
name|ARRAY
expr_stmt|;
name|t
operator|->
name|chain
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|chkcont
argument_list|(
name|curchar
argument_list|)
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_OLDOPENARRAY
case|:
name|t
operator|->
name|class
operator|=
name|DYNARRAY
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|ndims
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|t
operator|->
name|chain
operator|=
name|t_int
expr_stmt|;
break|break;
case|case
name|T_OPENARRAY
case|:
case|case
name|T_DYNARRAY
case|:
name|consDynarray
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SUBARRAY
case|:
name|t
operator|->
name|class
operator|=
name|SUBARRAY
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|ndims
operator|=
name|getint
argument_list|()
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|t
operator|->
name|chain
operator|=
name|t_int
expr_stmt|;
break|break;
case|case
name|T_RECORD
case|:
name|consRecord
argument_list|(
name|t
argument_list|,
name|RECORD
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_UNION
case|:
name|consRecord
argument_list|(
name|t
argument_list|,
name|VARNT
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_ENUM
case|:
name|consEnum
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PTR
case|:
name|t
operator|->
name|class
operator|=
name|PTR
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
break|break;
comment|/* 	     * C function variables are different from Modula-2's. 	     */
case|case
name|T_FUNCVAR
case|:
name|t
operator|->
name|class
operator|=
name|FFUNC
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|streq
argument_list|(
name|language_name
argument_list|(
name|curlang
argument_list|)
argument_list|,
literal|"c"
argument_list|)
condition|)
block|{
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|consParamlist
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_PROCVAR
case|:
name|t
operator|->
name|class
operator|=
name|FPROC
expr_stmt|;
name|consParamlist
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_IMPORTED
case|:
name|consImpType
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SET
case|:
name|t
operator|->
name|class
operator|=
name|SET
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_OPAQUE
case|:
name|consOpaqType
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_FILE
case|:
name|t
operator|->
name|class
operator|=
name|FILET
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badcaseval
argument_list|(
name|class
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*  * Construct a subrange type.  */
end_comment

begin_function
name|private
name|consSubrange
parameter_list|(
name|t
parameter_list|)
name|Symbol
name|t
decl_stmt|;
block|{
name|t
operator|->
name|class
operator|=
name|RANGE
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|chkcont
argument_list|(
name|curchar
argument_list|)
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lowertype
operator|=
name|getRangeBoundType
argument_list|()
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
operator|=
name|getint
argument_list|()
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|chkcont
argument_list|(
name|curchar
argument_list|)
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|uppertype
operator|=
name|getRangeBoundType
argument_list|()
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
operator|=
name|getint
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Figure out the bound type of a range.  *  * Some letters indicate a dynamic bound, ie what follows  * is the offset from the fp which contains the bound; this will  * need a different encoding when pc a['A'..'Z'] is  * added; J is a special flag to handle fortran a(*) bounds  */
end_comment

begin_function
name|private
name|Rangetype
name|getRangeBoundType
parameter_list|()
block|{
name|Rangetype
name|r
decl_stmt|;
switch|switch
condition|(
operator|*
name|curchar
condition|)
block|{
case|case
literal|'A'
case|:
name|r
operator|=
name|R_ARG
expr_stmt|;
name|curchar
operator|++
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|r
operator|=
name|R_TEMP
expr_stmt|;
name|curchar
operator|++
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|r
operator|=
name|R_ADJUST
expr_stmt|;
name|curchar
operator|++
expr_stmt|;
break|break;
default|default:
name|r
operator|=
name|R_CONST
expr_stmt|;
break|break;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Construct a dynamic array descriptor.  */
end_comment

begin_function
name|private
name|consDynarray
parameter_list|(
name|t
parameter_list|)
specifier|register
name|Symbol
name|t
decl_stmt|;
block|{
name|t
operator|->
name|class
operator|=
name|DYNARRAY
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|ndims
operator|=
name|getint
argument_list|()
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|t
operator|->
name|chain
operator|=
name|t_int
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct a record or union type.  */
end_comment

begin_function
name|private
name|consRecord
parameter_list|(
name|t
parameter_list|,
name|class
parameter_list|)
name|Symbol
name|t
decl_stmt|;
name|Symclass
name|class
decl_stmt|;
block|{
specifier|register
name|Symbol
name|u
decl_stmt|;
specifier|register
name|char
modifier|*
name|cur
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|Name
name|name
decl_stmt|;
name|integer
name|d
decl_stmt|;
name|t
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|getint
argument_list|()
expr_stmt|;
name|d
operator|=
name|curblock
operator|->
name|level
operator|+
literal|1
expr_stmt|;
name|u
operator|=
name|t
expr_stmt|;
name|cur
operator|=
name|curchar
expr_stmt|;
while|while
condition|(
operator|*
name|cur
operator|!=
literal|';'
name|and
operator|*
name|cur
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|cur
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"index(\"%s\", ':') failed"
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|identname
argument_list|(
name|cur
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|u
operator|->
name|chain
operator|=
name|newSymbol
argument_list|(
name|name
argument_list|,
name|d
argument_list|,
name|FIELD
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|cur
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|u
operator|=
name|u
operator|->
name|chain
expr_stmt|;
name|u
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|curchar
operator|=
name|cur
expr_stmt|;
name|u
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|u
operator|->
name|symvalue
operator|.
name|field
operator|.
name|offset
operator|=
name|getint
argument_list|()
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|u
operator|->
name|symvalue
operator|.
name|field
operator|.
name|length
operator|=
name|getint
argument_list|()
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|chkcont
argument_list|(
name|curchar
argument_list|)
expr_stmt|;
name|cur
operator|=
name|curchar
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cur
operator|==
literal|';'
condition|)
block|{
operator|++
name|cur
expr_stmt|;
block|}
name|curchar
operator|=
name|cur
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct an enumeration type.  */
end_comment

begin_function
name|private
name|consEnum
parameter_list|(
name|t
parameter_list|)
name|Symbol
name|t
decl_stmt|;
block|{
specifier|register
name|Symbol
name|u
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|integer
name|count
decl_stmt|;
name|t
operator|->
name|class
operator|=
name|SCAL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|u
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|curchar
operator|!=
literal|';'
name|and
operator|*
name|curchar
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|curchar
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|!=
name|nil
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|u
operator|->
name|chain
operator|=
name|insert
argument_list|(
name|identname
argument_list|(
name|curchar
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|curchar
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|u
operator|=
name|u
operator|->
name|chain
expr_stmt|;
name|u
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|u
operator|->
name|class
operator|=
name|CONST
expr_stmt|;
name|u
operator|->
name|level
operator|=
name|curblock
operator|->
name|level
operator|+
literal|1
expr_stmt|;
name|u
operator|->
name|block
operator|=
name|curblock
expr_stmt|;
name|u
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|u
operator|->
name|symvalue
operator|.
name|constval
operator|=
name|build
argument_list|(
name|O_LCON
argument_list|,
operator|(
name|long
operator|)
name|getint
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|chkcont
argument_list|(
name|curchar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|curchar
operator|==
literal|';'
condition|)
block|{
operator|++
name|curchar
expr_stmt|;
block|}
name|t
operator|->
name|symvalue
operator|.
name|iconval
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct a parameter list for a function or procedure variable.  */
end_comment

begin_function
name|private
name|consParamlist
parameter_list|(
name|t
parameter_list|)
name|Symbol
name|t
decl_stmt|;
block|{
name|Symbol
name|p
decl_stmt|;
name|integer
name|i
decl_stmt|,
name|d
decl_stmt|,
name|n
decl_stmt|,
name|paramclass
decl_stmt|;
name|n
operator|=
name|getint
argument_list|()
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|p
operator|=
name|t
expr_stmt|;
name|d
operator|=
name|curblock
operator|->
name|level
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|->
name|chain
operator|=
name|newSymbol
argument_list|(
name|nil
argument_list|,
name|d
argument_list|,
name|VAR
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|chain
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|paramclass
operator|=
name|getint
argument_list|()
expr_stmt|;
if|if
condition|(
name|paramclass
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|class
operator|=
name|REF
expr_stmt|;
block|}
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|chkcont
argument_list|(
name|curchar
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Construct an imported type.  * Add it to a list of symbols to get fixed up.  */
end_comment

begin_function
name|private
name|consImpType
parameter_list|(
name|t
parameter_list|)
name|Symbol
name|t
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|Symbol
name|tmp
decl_stmt|;
name|p
operator|=
name|curchar
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|','
name|and
operator|*
name|p
operator|!=
literal|';'
name|and
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|panic
argument_list|(
literal|"bad import symbol entry '%s'"
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|class
operator|=
name|TYPEREF
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|typeref
operator|=
name|curchar
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|curchar
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|tmp
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curchar
operator|=
name|p
expr_stmt|;
block|}
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct an opaque type entry.  */
end_comment

begin_function
name|private
name|consOpaqType
parameter_list|(
name|t
parameter_list|)
name|Symbol
name|t
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|Symbol
name|s
decl_stmt|;
specifier|register
name|Name
name|n
decl_stmt|;
name|boolean
name|def
decl_stmt|;
name|p
operator|=
name|curchar
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
name|and
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|panic
argument_list|(
literal|"bad opaque symbol entry '%s'"
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|def
operator|=
call|(
name|Boolean
call|)
argument_list|(
operator|*
name|p
operator|==
literal|','
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|=
name|identname
argument_list|(
name|curchar
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|find
argument_list|(
argument|s
argument_list|,
argument|n
argument_list|)
name|where
name|s
operator|->
name|class
operator|==
name|TYPEREF
name|endfind
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|s
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|TYPEREF
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|nil
expr_stmt|;
block|}
name|curchar
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|def
condition|)
block|{
name|s
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|class
operator|=
name|TYPE
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read an integer from the current position in the type string.  */
end_comment

begin_function
name|private
name|integer
name|getint
parameter_list|()
block|{
specifier|register
name|integer
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|Boolean
name|isneg
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|curchar
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|isneg
operator|=
name|true
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
else|else
block|{
name|isneg
operator|=
name|false
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|n
operator|=
literal|10
operator|*
name|n
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|curchar
operator|=
name|p
expr_stmt|;
return|return
name|isneg
condition|?
operator|(
operator|-
name|n
operator|)
else|:
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Add a tag name.  This is a kludge to be able to refer  * to tags that have the same name as some other symbol  * in the same block.  */
end_comment

begin_function
name|private
name|addtag
parameter_list|(
name|s
parameter_list|)
specifier|register
name|Symbol
name|s
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$$%.90s"
argument_list|,
name|ident
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|insert
argument_list|(
name|identname
argument_list|(
name|buf
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|language
operator|=
name|s
operator|->
name|language
expr_stmt|;
name|t
operator|->
name|class
operator|=
name|TAG
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|s
operator|->
name|type
expr_stmt|;
name|t
operator|->
name|block
operator|=
name|s
operator|->
name|block
expr_stmt|;
block|}
end_function

end_unit

