begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)printsym.c	1.14 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: printsym.c,v 1.5 84/12/26 10:41:28 linton Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Printing of symbolic information.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"languages.h"
end_include

begin_include
include|#
directive|include
file|"printsym.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"keywords.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Maximum number of arguments to a function.  * This is used as a check for the possibility that the stack has been  * overwritten and therefore a saved argument pointer might indicate  * to an absurdly large number of arguments.  */
end_comment

begin_define
define|#
directive|define
name|MAXARGSPASSED
value|20
end_define

begin_comment
comment|/*  * Return a pointer to the string for the name of the class that  * the given symbol belongs to.  */
end_comment

begin_decl_stmt
name|private
name|String
name|clname
index|[]
init|=
block|{
literal|"bad use"
block|,
literal|"constant"
block|,
literal|"type"
block|,
literal|"variable"
block|,
literal|"array"
block|,
literal|"@dynarray"
block|,
literal|"@subarray"
block|,
literal|"fileptr"
block|,
literal|"record"
block|,
literal|"field"
block|,
literal|"procedure"
block|,
literal|"function"
block|,
literal|"funcvar"
block|,
literal|"ref"
block|,
literal|"pointer"
block|,
literal|"file"
block|,
literal|"set"
block|,
literal|"range"
block|,
literal|"label"
block|,
literal|"withptr"
block|,
literal|"scalar"
block|,
literal|"string"
block|,
literal|"program"
block|,
literal|"improper"
block|,
literal|"variant"
block|,
literal|"procparam"
block|,
literal|"funcparam"
block|,
literal|"module"
block|,
literal|"tag"
block|,
literal|"common"
block|,
literal|"extref"
block|,
literal|"typeref"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|String
name|classname
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
return|return
name|clname
index|[
name|ord
argument_list|(
name|s
operator|->
name|class
argument_list|)
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Note the entry of the given block, unless it's the main program.  */
end_comment

begin_function
name|public
name|printentry
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|!=
name|program
condition|)
block|{
name|printf
argument_list|(
literal|"\nentering %s "
argument_list|,
name|classname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stdout
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Note the exit of the given block  */
end_comment

begin_function
name|public
name|printexit
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|!=
name|program
condition|)
block|{
name|printf
argument_list|(
literal|"leaving %s "
argument_list|,
name|classname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stdout
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Note the call of s from t.  */
end_comment

begin_function
name|public
name|printcall
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
name|Symbol
name|s
decl_stmt|,
name|t
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"calling "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stdout
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|printparams
argument_list|(
name|s
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" from %s "
argument_list|,
name|classname
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stdout
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note the return from s.  If s is a function, print the value  * it is returning.  This is somewhat painful, since the function  * has actually just returned.  */
end_comment

begin_function
name|public
name|printrtn
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|Boolean
name|isindirect
decl_stmt|;
name|printf
argument_list|(
literal|"returning "
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|class
operator|==
name|FUNC
operator|&&
operator|(
operator|!
name|istypename
argument_list|(
name|s
operator|->
name|type
argument_list|,
literal|"void"
argument_list|)
operator|)
condition|)
block|{
name|len
operator|=
name|size
argument_list|(
name|s
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|canpush
argument_list|(
name|len
argument_list|)
condition|)
block|{
name|t
operator|=
name|rtype
argument_list|(
name|s
operator|->
name|type
argument_list|)
expr_stmt|;
name|isindirect
operator|=
operator|(
name|Boolean
operator|)
operator|(
name|t
operator|->
name|class
operator|==
name|RECORD
name|or
name|t
operator|->
name|class
operator|==
name|VARNT
operator|)
expr_stmt|;
name|pushretval
argument_list|(
name|len
argument_list|,
name|isindirect
argument_list|)
expr_stmt|;
name|printval
argument_list|(
name|s
operator|->
name|type
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"(value too large) "
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"from "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stdout
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print the values of the parameters of the given procedure or function.  * The frame distinguishes recursive instances of a procedure.  *  * If the procedure or function is internal, the argument count is  * not valid so we ignore it.  */
end_comment

begin_function
name|public
name|printparams
parameter_list|(
name|f
parameter_list|,
name|frame
parameter_list|)
name|Symbol
name|f
decl_stmt|;
name|Frame
name|frame
decl_stmt|;
block|{
name|Symbol
name|param
decl_stmt|;
name|int
name|n
decl_stmt|,
name|m
decl_stmt|,
name|s
decl_stmt|;
name|n
operator|=
name|nargspassed
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|isinternal
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|param
operator|=
name|f
operator|->
name|chain
expr_stmt|;
if|if
condition|(
name|param
operator|!=
name|nil
name|or
name|n
operator|>
literal|0
condition|)
block|{
name|m
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|param
operator|!=
name|nil
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|psize
argument_list|(
argument|param
argument_list|)
name|div
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|s
operator|=
literal|1
expr_stmt|;
block|}
name|m
operator|-=
name|s
expr_stmt|;
if|if
condition|(
name|showaggrs
condition|)
block|{
name|printv
argument_list|(
name|param
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printparamv
argument_list|(
name|param
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
name|param
operator|=
name|param
operator|->
name|chain
expr_stmt|;
if|if
condition|(
name|param
operator|==
name|nil
condition|)
break|break;
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|>
name|MAXARGSPASSED
condition|)
block|{
name|m
operator|=
name|MAXARGSPASSED
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|chain
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
operator|--
name|m
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x"
argument_list|,
name|argn
argument_list|(
name|n
operator|-
name|m
argument_list|,
name|frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol should be printed.  We don't print files,  * for example, simply because there's no good way to do it.  * The symbol must be within the given function.  */
end_comment

begin_function
name|public
name|Boolean
name|should_print
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|Boolean
name|b
decl_stmt|;
specifier|register
name|Symbol
name|t
decl_stmt|;
switch|switch
condition|(
name|s
operator|->
name|class
condition|)
block|{
case|case
name|VAR
case|:
case|case
name|FVAR
case|:
if|if
condition|(
name|isparam
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|b
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|rtype
argument_list|(
name|s
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|b
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|t
operator|->
name|class
condition|)
block|{
case|case
name|FILET
case|:
case|case
name|SET
case|:
case|case
name|BADUSE
case|:
name|b
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|b
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
default|default:
name|b
operator|=
name|false
expr_stmt|;
break|break;
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Print out a parameter value.  *  * Since this is intended to be printed on a single line with other information  * aggregate values are not printed.  */
end_comment

begin_function
name|public
name|printparamv
parameter_list|(
name|p
parameter_list|,
name|frame
parameter_list|)
name|Symbol
name|p
decl_stmt|;
name|Frame
name|frame
decl_stmt|;
block|{
name|Symbol
name|t
decl_stmt|;
name|t
operator|=
name|rtype
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|class
condition|)
block|{
case|case
name|ARRAY
case|:
case|case
name|DYNARRAY
case|:
case|case
name|SUBARRAY
case|:
name|t
operator|=
name|rtype
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|compatible
argument_list|(
name|t
argument_list|,
name|t_char
argument_list|)
condition|)
block|{
name|printv
argument_list|(
name|p
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s = (...)"
argument_list|,
name|symname
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RECORD
case|:
name|printf
argument_list|(
literal|"%s = (...)"
argument_list|,
name|symname
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printv
argument_list|(
name|p
argument_list|,
name|frame
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Print the name and value of a variable.  */
end_comment

begin_function
name|public
name|printv
parameter_list|(
name|s
parameter_list|,
name|frame
parameter_list|)
name|Symbol
name|s
decl_stmt|;
name|Frame
name|frame
decl_stmt|;
block|{
name|Address
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|Symbol
name|t
decl_stmt|;
if|if
condition|(
name|isambiguous
argument_list|(
argument|s
argument_list|)
name|and
name|ismodule
argument_list|(
name|container
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
name|printname
argument_list|(
name|stdout
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s = "
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isvarparam
argument_list|(
argument|s
argument_list|)
name|and
name|not
name|isopenarray
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|rpush
argument_list|(
name|address
argument_list|(
name|s
argument_list|,
name|frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Address
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|pop
argument_list|(
name|Address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|address
argument_list|(
name|s
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|size
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|canpush
argument_list|(
name|len
argument_list|)
condition|)
block|{
name|rpush
argument_list|(
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printval
argument_list|(
name|s
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"*** expression too large ***"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out the name of a symbol.  */
end_comment

begin_function
name|public
name|printname
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|)
name|File
name|f
decl_stmt|;
name|Symbol
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"(noname)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|program
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isredirected
argument_list|()
name|or
name|isambiguous
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|printwhich
argument_list|(
name|f
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print the fully specified variable that is described by the given identifer.  */
end_comment

begin_function
name|public
name|printwhich
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|)
name|File
name|f
decl_stmt|;
name|Symbol
name|s
decl_stmt|;
block|{
name|printouter
argument_list|(
name|f
argument_list|,
name|container
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print the fully qualified name of each symbol that has the same name  * as the given symbol.  */
end_comment

begin_function
name|public
name|printwhereis
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|)
name|File
name|f
decl_stmt|;
name|Symbol
name|s
decl_stmt|;
block|{
specifier|register
name|Name
name|n
decl_stmt|;
specifier|register
name|Symbol
name|t
decl_stmt|;
name|checkref
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|n
operator|=
name|s
operator|->
name|name
expr_stmt|;
name|t
operator|=
name|lookup
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|printwhich
argument_list|(
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|next_sym
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|name
operator|==
name|n
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|printwhich
argument_list|(
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|t
operator|->
name|next_sym
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|printouter
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|)
name|File
name|f
decl_stmt|;
name|Symbol
name|s
decl_stmt|;
block|{
name|Symbol
name|outer
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|nil
condition|)
block|{
name|outer
operator|=
name|container
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|outer
operator|!=
name|nil
name|and
name|outer
operator|!=
name|program
condition|)
block|{
name|printouter
argument_list|(
name|f
argument_list|,
name|outer
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s."
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|public
name|printdecl
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|Language
name|lang
decl_stmt|;
name|checkref
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|language
operator|==
name|nil
name|or
name|s
operator|->
name|language
operator|==
name|primlang
condition|)
block|{
name|lang
operator|=
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lang
operator|=
name|s
operator|->
name|language
expr_stmt|;
block|}
operator|(
operator|*
name|language_op
argument_list|(
name|lang
argument_list|,
name|L_PRINTDECL
argument_list|)
operator|)
operator|(
name|s
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Straight dump of symbol information.  */
end_comment

begin_function
name|public
name|psym
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"name\t%s\n"
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lang\t%s\n"
argument_list|,
name|language_name
argument_list|(
name|s
operator|->
name|language
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"level\t%d\n"
argument_list|,
name|s
operator|->
name|level
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"class\t%s\n"
argument_list|,
name|classname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"type\t0x%x"
argument_list|,
name|s
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|nil
name|and
name|s
operator|->
name|type
operator|->
name|name
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|symname
argument_list|(
name|s
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nchain\t0x%x"
argument_list|,
name|s
operator|->
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|chain
operator|!=
name|nil
name|and
name|s
operator|->
name|chain
operator|->
name|name
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|symname
argument_list|(
name|s
operator|->
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nblock\t0x%x"
argument_list|,
name|s
operator|->
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|block
operator|->
name|name
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stdout
argument_list|,
name|s
operator|->
name|block
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|class
condition|)
block|{
case|case
name|TYPE
case|:
name|printf
argument_list|(
literal|"size\t%d\n"
argument_list|,
name|size
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR
case|:
case|case
name|REF
case|:
if|if
condition|(
name|s
operator|->
name|level
operator|>=
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"address\t0x%x\n"
argument_list|,
name|s
operator|->
name|symvalue
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"offset\t%d\n"
argument_list|,
name|s
operator|->
name|symvalue
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"size\t%d\n"
argument_list|,
name|size
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD
case|:
case|case
name|VARNT
case|:
name|printf
argument_list|(
literal|"size\t%d\n"
argument_list|,
name|s
operator|->
name|symvalue
operator|.
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD
case|:
name|printf
argument_list|(
literal|"offset\t%d\n"
argument_list|,
name|s
operator|->
name|symvalue
operator|.
name|field
operator|.
name|offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"size\t%d\n"
argument_list|,
name|s
operator|->
name|symvalue
operator|.
name|field
operator|.
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROG
case|:
case|case
name|PROC
case|:
case|case
name|FUNC
case|:
name|printf
argument_list|(
literal|"address\t0x%x\n"
argument_list|,
name|s
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|isinline
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"inline procedure\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nosource
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"does not have source information\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"has source information\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RANGE
case|:
name|prangetype
argument_list|(
name|s
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lowertype
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lower\t%d\n"
argument_list|,
name|s
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
argument_list|)
expr_stmt|;
name|prangetype
argument_list|(
name|s
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|uppertype
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"upper\t%d\n"
argument_list|,
name|s
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* do nothing */
break|break;
block|}
block|}
end_function

begin_function
name|private
name|prangetype
parameter_list|(
name|r
parameter_list|)
name|Rangetype
name|r
decl_stmt|;
block|{
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|R_CONST
case|:
name|printf
argument_list|(
literal|"CONST"
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_ARG
case|:
name|printf
argument_list|(
literal|"ARG"
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_TEMP
case|:
name|printf
argument_list|(
literal|"TEMP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_ADJUST
case|:
name|printf
argument_list|(
literal|"ADJUST"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out the value on top of the stack according to the given type.  */
end_comment

begin_function
name|public
name|printval
parameter_list|(
name|t
parameter_list|)
name|Symbol
name|t
decl_stmt|;
block|{
name|Symbol
name|s
decl_stmt|;
name|checkref
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|TYPEREF
condition|)
block|{
name|resolveRef
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|t
operator|->
name|class
condition|)
block|{
case|case
name|PROC
case|:
case|case
name|FUNC
case|:
name|s
operator|=
name|pop
argument_list|(
name|Symbol
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|t
operator|->
name|language
operator|==
name|nil
name|or
name|t
operator|->
name|language
operator|==
name|primlang
condition|)
block|{
operator|(
operator|*
name|language_op
argument_list|(
name|findlanguage
argument_list|(
literal|".c"
argument_list|)
argument_list|,
name|L_PRINTVAL
argument_list|)
operator|)
operator|(
name|t
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|language_op
argument_list|(
name|t
operator|->
name|language
argument_list|,
name|L_PRINTVAL
argument_list|)
operator|)
operator|(
name|t
operator|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out the value of a record, field by field.  */
end_comment

begin_function
name|public
name|printrecord
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|Symbol
name|f
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|chain
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"record has no fields"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|sp
operator|-=
name|size
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|f
operator|=
name|s
operator|->
name|chain
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|nil
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|printfield
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|chain
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|nil
condition|)
break|break;
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a field.  */
end_comment

begin_function
name|private
name|printfield
parameter_list|(
name|f
parameter_list|)
name|Symbol
name|f
decl_stmt|;
block|{
name|Stack
modifier|*
name|savesp
decl_stmt|;
specifier|register
name|int
name|off
decl_stmt|,
name|len
decl_stmt|;
name|printf
argument_list|(
literal|"%s = "
argument_list|,
name|symname
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|savesp
operator|=
name|sp
expr_stmt|;
name|off
operator|=
name|f
operator|->
name|symvalue
operator|.
name|field
operator|.
name|offset
expr_stmt|;
name|len
operator|=
name|f
operator|->
name|symvalue
operator|.
name|field
operator|.
name|length
expr_stmt|;
name|sp
operator|+=
operator|(
operator|(
name|off
operator|+
name|len
operator|+
name|BITSPERBYTE
operator|-
literal|1
operator|)
name|div
name|BITSPERBYTE
operator|)
expr_stmt|;
name|printval
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|sp
operator|=
name|savesp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out the contents of an array.  * Haven't quite figured out what the best format is.  *  * This is rather inefficient.  *  * The "2*elsize" is there since "printval" drops the stack by elsize.  */
end_comment

begin_function
name|public
name|printarray
parameter_list|(
name|a
parameter_list|)
name|Symbol
name|a
decl_stmt|;
block|{
name|Stack
modifier|*
name|savesp
decl_stmt|,
modifier|*
name|newsp
decl_stmt|;
name|Symbol
name|eltype
decl_stmt|;
name|long
name|elsize
decl_stmt|;
name|String
name|sep
decl_stmt|;
name|savesp
operator|=
name|sp
expr_stmt|;
name|sp
operator|-=
operator|(
name|size
argument_list|(
name|a
argument_list|)
operator|)
expr_stmt|;
name|newsp
operator|=
name|sp
expr_stmt|;
name|eltype
operator|=
name|rtype
argument_list|(
name|a
operator|->
name|type
argument_list|)
expr_stmt|;
name|elsize
operator|=
name|size
argument_list|(
name|eltype
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|eltype
operator|->
name|class
operator|==
name|RECORD
name|or
name|eltype
operator|->
name|class
operator|==
name|ARRAY
name|or
name|eltype
operator|->
name|class
operator|==
name|VARNT
condition|)
block|{
name|sep
operator|=
literal|"\n"
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|+=
name|elsize
init|;
name|sp
operator|<=
name|savesp
condition|;
name|sp
operator|+=
literal|2
operator|*
name|elsize
control|)
block|{
if|if
condition|(
name|sp
operator|-
name|elsize
operator|!=
name|newsp
condition|)
block|{
name|fputs
argument_list|(
name|sep
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printval
argument_list|(
name|eltype
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|newsp
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|sep
argument_list|,
literal|"\n"
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out the value of a real number in Pascal notation.  * This is, unfortunately, different than what one gets  * from "%g" in printf.  */
end_comment

begin_function
name|public
name|prtreal
parameter_list|(
name|r
parameter_list|)
name|double
name|r
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%g"
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|printf
argument_list|(
literal|"0%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'-'
name|and
name|buf
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|printf
argument_list|(
literal|"-0%s"
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
argument_list|(
name|buf
argument_list|,
literal|'.'
argument_list|)
operator|==
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|".0"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out a character using ^? notation for unprintables.  */
end_comment

begin_function
name|public
name|printchar
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
literal|0
name|and
name|c
operator|<
literal|' '
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
operator|-
literal|1
operator|+
literal|'A'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|'~'
condition|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\\0%o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out a value for a range type (integer, char, or boolean).  */
end_comment

begin_function
name|public
name|printRangeVal
parameter_list|(
name|val
parameter_list|,
name|t
parameter_list|)
name|long
name|val
decl_stmt|;
name|Symbol
name|t
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|t_boolean
operator|->
name|type
name|or
name|istypename
argument_list|(
name|t
operator|->
name|type
argument_list|,
literal|"boolean"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|boolean
operator|)
name|val
condition|)
block|{
name|printf
argument_list|(
literal|"true"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"false"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|t_char
operator|->
name|type
name|or
name|istypename
argument_list|(
name|t
operator|->
name|type
argument_list|,
literal|"char"
argument_list|)
condition|)
block|{
if|if
condition|(
name|varIsSet
argument_list|(
literal|"$hexchars"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"0x%lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|printchar
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|varIsSet
argument_list|(
literal|"$hexints"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"0x%lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%lu"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out an enumerated value by finding the corresponding  * name in the enumeration list.  */
end_comment

begin_function
name|public
name|printEnum
parameter_list|(
name|i
parameter_list|,
name|t
parameter_list|)
name|integer
name|i
decl_stmt|;
name|Symbol
name|t
decl_stmt|;
block|{
specifier|register
name|Symbol
name|e
decl_stmt|;
name|e
operator|=
name|t
operator|->
name|chain
expr_stmt|;
while|while
condition|(
name|e
operator|!=
name|nil
name|and
name|e
operator|->
name|symvalue
operator|.
name|constval
operator|->
name|value
operator|.
name|lcon
operator|!=
name|i
condition|)
block|{
name|e
operator|=
name|e
operator|->
name|chain
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|symname
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out a null-terminated string (pointer to char)  * starting at the given address.  */
end_comment

begin_function
name|public
name|printString
parameter_list|(
name|addr
parameter_list|,
name|quotes
parameter_list|)
name|Address
name|addr
decl_stmt|;
name|boolean
name|quotes
decl_stmt|;
block|{
specifier|register
name|Address
name|a
decl_stmt|;
specifier|register
name|integer
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|boolean
name|endofstring
decl_stmt|;
union|union
block|{
name|char
name|ch
index|[
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
index|]
decl_stmt|;
name|int
name|word
decl_stmt|;
block|}
name|u
union|;
if|if
condition|(
name|varIsSet
argument_list|(
literal|"$hexstrings"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"0x%x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|quotes
condition|)
block|{
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|addr
expr_stmt|;
name|endofstring
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|not
name|endofstring
condition|)
block|{
name|dread
argument_list|(
operator|&
name|u
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|u
operator|.
name|ch
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|endofstring
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|printchar
argument_list|(
name|u
operator|.
name|ch
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
expr|sizeof
operator|(
name|Word
operator|)
name|and
name|not
name|endofstring
condition|)
do|;
name|a
operator|+=
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quotes
condition|)
block|{
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

