begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  *  Debug routines  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"operators.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_include
include|#
directive|include
file|"events.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"scanner.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
name|public
name|boolean
name|tracetree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace building of parse trees */
end_comment

begin_decl_stmt
name|public
name|boolean
name|traceeval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace tree evaluation */
end_comment

begin_comment
comment|/*  * Dynamically turn on/off a debug flag, or display some information.  */
end_comment

begin_function
name|public
name|debug
parameter_list|(
name|p
parameter_list|)
name|Node
name|p
decl_stmt|;
block|{
name|int
name|code
decl_stmt|;
name|code
operator|=
name|p
operator|->
name|value
operator|.
name|lcon
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
name|puts
argument_list|(
literal|"debugging flags:"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    1        trace scanner return values"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    2        trace breakpoints"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    3        trace execution"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    4        trace tree building"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    5        trace tree evaluation"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"   -[12345]  turns off corresponding flag"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    6        dump function table"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
operator|-
literal|1
case|:
ifdef|#
directive|ifdef
name|LEXDEBUG
name|lexdebug
operator|=
call|(
name|boolean
call|)
argument_list|(
name|code
operator|>
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"can't debug scanner (not compiled with LEXDEBUG)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|2
case|:
case|case
operator|-
literal|2
case|:
name|tracebpts
operator|=
call|(
name|boolean
call|)
argument_list|(
name|code
operator|>
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
operator|-
literal|3
case|:
name|traceexec
operator|=
call|(
name|boolean
call|)
argument_list|(
name|code
operator|>
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
case|case
operator|-
literal|4
case|:
name|tracetree
operator|=
call|(
name|boolean
call|)
argument_list|(
name|code
operator|>
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
case|case
operator|-
literal|5
case|:
name|traceeval
operator|=
call|(
name|boolean
call|)
argument_list|(
name|code
operator|>
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|dumpfunctab
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"unknown debug flag"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_decl_stmt
name|private
name|String
name|leafname
index|[]
init|=
block|{
literal|"nop"
block|,
literal|"name"
block|,
literal|"sym"
block|,
literal|"lcon"
block|,
literal|"fcon"
block|,
literal|"scon"
block|,
literal|"rval"
block|,
literal|"index"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|String
name|opname
parameter_list|(
name|op
parameter_list|)
name|Operator
name|op
decl_stmt|;
block|{
name|String
name|s
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|O_ITOF
case|:
name|s
operator|=
literal|"itof"
expr_stmt|;
break|break;
case|case
name|O_ENDX
case|:
name|s
operator|=
literal|"endx"
expr_stmt|;
break|break;
case|case
name|O_QLINE
case|:
name|s
operator|=
literal|"qline"
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ord
argument_list|(
name|op
argument_list|)
operator|<=
name|ord
argument_list|(
name|O_INDEX
argument_list|)
condition|)
block|{
name|s
operator|=
name|leafname
index|[
name|ord
argument_list|(
name|op
argument_list|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|opinfo
index|[
name|ord
argument_list|(
name|op
argument_list|)
index|]
operator|.
name|opstring
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[op %d]"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
block|}
block|}
break|break;
block|}
return|return
name|s
return|;
block|}
end_function

end_unit

