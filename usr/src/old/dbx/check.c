begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)check.c 1.3 %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check a tree for semantic correctness.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"operators.h"
end_include

begin_include
include|#
directive|include
file|"events.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"scanner.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Check that the nodes in a tree have the correct arguments  * in order to be evaluated.  Basically the error checking here  * frees the evaluation routines from worrying about anything  * except dynamic errors, e.g. subscript out of range.  */
end_comment

begin_function
name|public
name|check
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Node
name|p
decl_stmt|;
block|{
name|Address
name|addr
decl_stmt|;
name|Symbol
name|f
decl_stmt|;
name|checkref
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|O_LIST
case|:
if|if
condition|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|op
operator|==
name|O_SYM
condition|)
block|{
name|f
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|sym
expr_stmt|;
if|if
condition|(
name|not
name|isblock
argument_list|(
argument|f
argument_list|)
name|or
name|ismodule
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not a procedure or function"
argument_list|,
name|symname
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|firstline
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NOADDR
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is empty"
argument_list|,
name|symname
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|O_TRACE
case|:
case|case
name|O_TRACEI
case|:
name|chktrace
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_STOP
case|:
case|case
name|O_STOPI
case|:
name|chkstop
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Check arguments to a trace command.  */
end_comment

begin_function
name|private
name|chktrace
parameter_list|(
name|p
parameter_list|)
name|Node
name|p
decl_stmt|;
block|{
name|Node
name|exp
decl_stmt|,
name|place
decl_stmt|,
name|cond
decl_stmt|;
name|exp
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|place
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
expr_stmt|;
name|cond
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|nil
condition|)
block|{
name|chkblock
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|op
operator|==
name|O_LCON
name|or
name|exp
operator|->
name|op
operator|==
name|O_QLINE
condition|)
block|{
if|if
condition|(
name|place
operator|!=
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"unexpected \"at\" or \"in\""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|O_TRACE
condition|)
block|{
name|chkline
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chkaddr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|place
operator|!=
name|nil
name|and
argument_list|(
argument|place->op == O_QLINE or place->op == O_LCON
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|O_TRACE
condition|)
block|{
name|chkline
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chkaddr
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|exp
operator|->
name|op
operator|!=
name|O_RVAL
name|and
name|exp
operator|->
name|op
operator|!=
name|O_SYM
name|and
name|exp
operator|->
name|op
operator|!=
name|O_CALL
condition|)
block|{
name|error
argument_list|(
literal|"can't trace expressions"
argument_list|)
expr_stmt|;
block|}
name|chkblock
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check arguments to a stop command.  */
end_comment

begin_function
name|private
name|chkstop
parameter_list|(
name|p
parameter_list|)
name|Node
name|p
decl_stmt|;
block|{
name|Node
name|exp
decl_stmt|,
name|place
decl_stmt|,
name|cond
decl_stmt|;
name|exp
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|place
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
expr_stmt|;
name|cond
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|op
operator|!=
name|O_RVAL
name|and
name|exp
operator|->
name|op
operator|!=
name|O_SYM
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expected variable, found "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
name|chkblock
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cond
operator|!=
name|nil
condition|)
block|{
name|chkblock
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|place
operator|->
name|op
operator|==
name|O_SYM
condition|)
block|{
name|chkblock
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|O_STOP
condition|)
block|{
name|chkline
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chkaddr
argument_list|(
name|place
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see that the given node specifies some subprogram.  * Nil is ok since that means the entire program.  */
end_comment

begin_function
name|private
name|chkblock
parameter_list|(
name|b
parameter_list|)
name|Node
name|b
decl_stmt|;
block|{
if|if
condition|(
name|b
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|op
operator|!=
name|O_SYM
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expected subprogram, found "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|not
name|isblock
argument_list|(
argument|b->value.sym
argument_list|)
name|or
name|ismodule
argument_list|(
name|b
operator|->
name|value
operator|.
name|sym
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not a subprogram"
argument_list|,
name|symname
argument_list|(
name|b
operator|->
name|value
operator|.
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check to make sure a node corresponds to a source line.  */
end_comment

begin_function
name|private
name|chkline
parameter_list|(
name|p
parameter_list|)
name|Node
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"missing line"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|O_QLINE
name|and
name|p
operator|->
name|op
operator|!=
name|O_LCON
condition|)
block|{
name|error
argument_list|(
literal|"expected source line number, found \"%t\""
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check to make sure a node corresponds to an address.  */
end_comment

begin_function
name|private
name|chkaddr
parameter_list|(
name|p
parameter_list|)
name|Node
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"missing address"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|O_LCON
name|and
name|p
operator|->
name|op
operator|!=
name|O_QLINE
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expected address, found \""
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

