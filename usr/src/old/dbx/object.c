begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)object.c 1.4 %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Object code interface, mainly for extraction of symbolic information.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"languages.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"lists.h"
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_struct
struct|struct
block|{
name|unsigned
name|int
name|stringsize
decl_stmt|;
comment|/* size of the dumped string table */
name|unsigned
name|int
name|nsyms
decl_stmt|;
comment|/* number of symbols */
name|unsigned
name|int
name|nfiles
decl_stmt|;
comment|/* number of files */
name|unsigned
name|int
name|nlines
decl_stmt|;
comment|/* number of lines */
block|}
name|nlhdr
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|public
name|String
name|objname
init|=
literal|"a.out"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|Integer
name|objsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|char
modifier|*
name|stringtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|String
name|progname
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Language
name|curlang
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Symbol
name|curmodule
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Symbol
name|curparam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Boolean
name|warned
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Filetab
modifier|*
name|filep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Linetab
modifier|*
name|linep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Address
name|curfaddr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|curfilename
parameter_list|()
value|(filep-1)->filename
end_define

begin_comment
comment|/*  * Blocks are figured out on the fly while reading the symbol table.  */
end_comment

begin_define
define|#
directive|define
name|MAXBLKDEPTH
value|25
end_define

begin_decl_stmt
name|private
name|Symbol
name|curblock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Symbol
name|blkstack
index|[
name|MAXBLKDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Integer
name|curlevel
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|enterblock
parameter_list|(
name|b
parameter_list|)
value|{ \     blkstack[curlevel] = curblock; \     ++curlevel; \     b->level = curlevel; \     b->block = curblock; \     curblock = b; \ }
end_define

begin_define
define|#
directive|define
name|exitblock
parameter_list|()
value|{ \     --curlevel; \     curblock = blkstack[curlevel]; \ }
end_define

begin_comment
comment|/*  * Enter a source line or file name reference into the appropriate table.  * Expanded inline to reduce procedure calls.  *  * private enterline(linenumber, address)  * Lineno linenumber;  * Address address;  *  ...  */
end_comment

begin_define
define|#
directive|define
name|enterline
parameter_list|(
name|linenumber
parameter_list|,
name|address
parameter_list|)
define|\
value|{ \     register Linetab *lp; \  \     lp = linep - 1; \     if (linenumber != lp->line) { \ 	if (address != lp->addr) { \ 	    ++lp; \ 	} \ 	lp->line = linenumber; \ 	lp->addr = address; \ 	linep = lp + 1; \     } \ }
end_define

begin_define
define|#
directive|define
name|NTYPES
value|1000
end_define

begin_decl_stmt
name|private
name|Symbol
name|typetable
index|[
name|NTYPES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read in the namelist from the obj file.  *  * Reads and seeks are used instead of fread's and fseek's  * for efficiency sake; there's a lot of data being read here.  */
end_comment

begin_function
name|public
name|readobj
parameter_list|(
name|file
parameter_list|)
name|String
name|file
decl_stmt|;
block|{
name|Fileid
name|f
decl_stmt|;
name|struct
name|exec
name|hdr
decl_stmt|;
name|struct
name|nlist
name|nlist
decl_stmt|;
name|f
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"can't open %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|read
argument_list|(
name|f
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|objsize
operator|=
name|hdr
operator|.
name|a_text
expr_stmt|;
name|nlhdr
operator|.
name|nsyms
operator|=
name|hdr
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
name|nlist
argument_list|)
expr_stmt|;
name|nlhdr
operator|.
name|nfiles
operator|=
name|nlhdr
operator|.
name|nsyms
expr_stmt|;
name|nlhdr
operator|.
name|nlines
operator|=
name|nlhdr
operator|.
name|nsyms
expr_stmt|;
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|long
operator|)
name|N_STROFF
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|f
argument_list|,
operator|&
operator|(
name|nlhdr
operator|.
name|stringsize
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|nlhdr
operator|.
name|stringsize
argument_list|)
argument_list|)
expr_stmt|;
name|nlhdr
operator|.
name|stringsize
operator|-=
literal|4
expr_stmt|;
name|stringtab
operator|=
name|newarr
argument_list|(
name|char
argument_list|,
name|nlhdr
operator|.
name|stringsize
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|f
argument_list|,
name|stringtab
argument_list|,
name|nlhdr
operator|.
name|stringsize
argument_list|)
expr_stmt|;
name|allocmaps
argument_list|(
name|nlhdr
operator|.
name|nfiles
argument_list|,
name|nlhdr
operator|.
name|nlines
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|long
operator|)
name|N_SYMOFF
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|readsyms
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ordfunctab
argument_list|()
expr_stmt|;
name|setnlines
argument_list|()
expr_stmt|;
name|setnfiles
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read in symbols from object file.  */
end_comment

begin_function
name|private
name|readsyms
parameter_list|(
name|f
parameter_list|)
name|Fileid
name|f
decl_stmt|;
block|{
name|struct
name|nlist
modifier|*
name|namelist
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|,
modifier|*
name|ub
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
specifier|register
name|String
name|name
decl_stmt|;
specifier|register
name|Boolean
name|afterlg
decl_stmt|;
name|initsyms
argument_list|()
expr_stmt|;
name|namelist
operator|=
name|newarr
argument_list|(
expr|struct
name|nlist
argument_list|,
name|nlhdr
operator|.
name|nsyms
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|f
argument_list|,
name|namelist
argument_list|,
name|nlhdr
operator|.
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
name|afterlg
operator|=
name|false
expr_stmt|;
name|ub
operator|=
operator|&
name|namelist
index|[
name|nlhdr
operator|.
name|nsyms
index|]
expr_stmt|;
for|for
control|(
name|np
operator|=
operator|&
name|namelist
index|[
literal|0
index|]
init|;
name|np
operator|<
name|ub
condition|;
name|np
operator|++
control|)
block|{
name|index
operator|=
name|np
operator|->
name|n_un
operator|.
name|n_strx
expr_stmt|;
if|if
condition|(
name|index
operator|!=
literal|0
condition|)
block|{
name|name
operator|=
operator|&
name|stringtab
index|[
name|index
operator|-
literal|4
index|]
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|nil
expr_stmt|;
block|}
comment|/* 	 * assumptions: 	 *	not an N_STAB	==> name != nil 	 *	name[0] == '-'	==> name == "-lg" 	 *	name[0] != '_'	==> filename or invisible 	 * 	 * The "-lg" signals the beginning of global loader symbols. 	 */
if|if
condition|(
operator|(
name|np
operator|->
name|n_type
operator|&
name|N_STAB
operator|)
operator|!=
literal|0
condition|)
block|{
name|enter_nl
argument_list|(
name|name
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|afterlg
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|curblock
operator|->
name|class
operator|!=
name|PROG
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
if|if
condition|(
name|curblock
operator|->
name|class
operator|!=
name|PROG
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
block|}
block|}
name|enterline
argument_list|(
literal|0
argument_list|,
operator|(
name|linep
operator|-
literal|1
operator|)
operator|->
name|addr
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|afterlg
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
name|check_global
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
name|check_local
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|np
operator|->
name|n_type
operator|&
name|N_TEXT
operator|)
operator|==
name|N_TEXT
condition|)
block|{
name|check_filename
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|dispose
argument_list|(
name|namelist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize symbol information.  */
end_comment

begin_function
name|private
name|initsyms
parameter_list|()
block|{
name|curblock
operator|=
name|nil
expr_stmt|;
name|curlevel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|progname
operator|==
name|nil
condition|)
block|{
name|progname
operator|=
name|strdup
argument_list|(
name|objname
argument_list|)
expr_stmt|;
if|if
condition|(
name|rindex
argument_list|(
name|progname
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|nil
condition|)
block|{
name|progname
operator|=
name|rindex
argument_list|(
name|progname
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|index
argument_list|(
name|progname
argument_list|,
literal|'.'
argument_list|)
operator|!=
name|nil
condition|)
block|{
operator|*
operator|(
name|index
argument_list|(
name|progname
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|program
operator|=
name|insert
argument_list|(
name|identname
argument_list|(
name|progname
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|program
operator|->
name|class
operator|=
name|PROG
expr_stmt|;
name|newfunc
argument_list|(
name|program
argument_list|)
expr_stmt|;
name|findbeginning
argument_list|(
name|program
argument_list|)
expr_stmt|;
name|enterblock
argument_list|(
name|program
argument_list|)
expr_stmt|;
name|curmodule
operator|=
name|program
expr_stmt|;
name|t_boolean
operator|=
name|maketype
argument_list|(
literal|"$boolean"
argument_list|,
literal|0L
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|t_int
operator|=
name|maketype
argument_list|(
literal|"$integer"
argument_list|,
literal|0x80000000L
argument_list|,
literal|0x7fffffffL
argument_list|)
expr_stmt|;
name|t_char
operator|=
name|maketype
argument_list|(
literal|"$char"
argument_list|,
literal|0L
argument_list|,
literal|127L
argument_list|)
expr_stmt|;
name|t_real
operator|=
name|maketype
argument_list|(
literal|"$real"
argument_list|,
literal|4L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|t_nil
operator|=
name|maketype
argument_list|(
literal|"$nil"
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free all the object file information that's being stored.  */
end_comment

begin_function
name|public
name|objfree
parameter_list|()
block|{
name|symbol_free
argument_list|()
expr_stmt|;
name|keywords_free
argument_list|()
expr_stmt|;
name|names_free
argument_list|()
expr_stmt|;
name|dispose
argument_list|(
name|stringtab
argument_list|)
expr_stmt|;
name|clrfunctab
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enter a namelist entry.  */
end_comment

begin_function
name|private
name|enter_nl
parameter_list|(
name|name
parameter_list|,
name|np
parameter_list|)
name|String
name|name
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
name|String
name|mname
decl_stmt|,
name|suffix
decl_stmt|;
specifier|register
name|Name
name|n
decl_stmt|;
specifier|register
name|Symbol
modifier|*
name|tt
decl_stmt|;
name|s
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|nil
condition|)
block|{
name|n
operator|=
name|nil
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|identname
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|np
operator|->
name|n_type
condition|)
block|{
case|case
name|N_LBRAC
case|:
name|s
operator|=
name|symbol_alloc
argument_list|()
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|PROC
expr_stmt|;
name|enterblock
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_RBRAC
case|:
name|exitblock
argument_list|()
expr_stmt|;
break|break;
case|case
name|N_SLINE
case|:
name|enterline
argument_list|(
operator|(
name|Lineno
operator|)
name|np
operator|->
name|n_desc
argument_list|,
operator|(
name|Address
operator|)
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Compilation unit.  C associates scope with filenames 	 * so we treat them as "modules".  The filename without 	 * the suffix is used for the module name. 	 * 	 * Because there is no explicit "end-of-block" mark in 	 * the object file, we must exit blocks for the current 	 * procedure and module. 	 */
case|case
name|N_SO
case|:
name|mname
operator|=
name|strdup
argument_list|(
name|ident
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rindex
argument_list|(
name|mname
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|nil
condition|)
block|{
name|mname
operator|=
name|rindex
argument_list|(
name|mname
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|suffix
operator|=
name|rindex
argument_list|(
name|mname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|curlang
operator|=
name|findlanguage
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffix
operator|!=
name|nil
condition|)
block|{
operator|*
name|suffix
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|curblock
operator|->
name|class
operator|!=
name|PROG
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
if|if
condition|(
name|curblock
operator|->
name|class
operator|!=
name|PROG
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
block|}
block|}
name|s
operator|=
name|insert
argument_list|(
name|identname
argument_list|(
name|mname
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|MODULE
expr_stmt|;
name|enterblock
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|curmodule
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|program
operator|->
name|language
operator|==
name|nil
condition|)
block|{
name|program
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
block|}
name|warned
operator|=
name|false
expr_stmt|;
name|enterfile
argument_list|(
name|ident
argument_list|(
name|n
argument_list|)
argument_list|,
operator|(
name|Address
operator|)
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
for|for
control|(
name|tt
operator|=
operator|&
name|typetable
index|[
literal|0
index|]
init|;
name|tt
operator|<
operator|&
name|typetable
index|[
name|NTYPES
index|]
condition|;
name|tt
operator|++
control|)
block|{
operator|*
name|tt
operator|=
name|nil
expr_stmt|;
block|}
break|break;
comment|/* 	 * Textually included files. 	 */
case|case
name|N_SOL
case|:
name|enterfile
argument_list|(
name|name
argument_list|,
operator|(
name|Address
operator|)
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * These symbols are assumed to have non-nil names. 	 */
case|case
name|N_GSYM
case|:
case|case
name|N_FUN
case|:
case|case
name|N_STSYM
case|:
case|case
name|N_LCSYM
case|:
case|case
name|N_RSYM
case|:
case|case
name|N_PSYM
case|:
case|case
name|N_LSYM
case|:
case|case
name|N_SSYM
case|:
if|if
condition|(
name|index
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|==
name|nil
condition|)
block|{
if|if
condition|(
name|not
name|warned
condition|)
block|{
name|warned
operator|=
name|true
expr_stmt|;
comment|/* 		     * Shouldn't do this if user might be typing. 		     * 		    warning("old style symbol information found in \"%s\"", 			curfilename()); 		     * 		     */
block|}
block|}
else|else
block|{
name|entersym
argument_list|(
name|name
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|N_PC
case|:
break|break;
case|case
name|N_LENG
case|:
comment|/* 	     * Should complain out this, obviously the wrong symbol format. 	     */
break|break;
default|default:
if|if
condition|(
name|name
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"%s, "
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ntype %2x, desc %x, value %x\n"
argument_list|,
name|np
operator|->
name|n_type
argument_list|,
name|np
operator|->
name|n_desc
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if a global _name is already in the symbol table,  * if not then insert it.  */
end_comment

begin_function
name|private
name|check_global
parameter_list|(
name|name
parameter_list|,
name|np
parameter_list|)
name|String
name|name
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
block|{
specifier|register
name|Name
name|n
decl_stmt|;
specifier|register
name|Symbol
name|t
decl_stmt|;
if|if
condition|(
name|not
name|streq
argument_list|(
name|name
argument_list|,
literal|"end"
argument_list|)
condition|)
block|{
name|n
operator|=
name|identname
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|->
name|n_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_TEXT
condition|)
block|{
name|find
argument_list|(
argument|t
argument_list|,
argument|n
argument_list|)
name|where
name|t
operator|->
name|level
operator|==
name|program
operator|->
name|level
name|and
name|isblock
argument_list|(
argument|t
argument_list|)
name|endfind
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|t
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|t
operator|->
name|language
operator|=
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
expr_stmt|;
name|t
operator|->
name|class
operator|=
name|FUNC
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|t_int
expr_stmt|;
name|t
operator|->
name|block
operator|=
name|curblock
expr_stmt|;
name|t
operator|->
name|level
operator|=
name|program
operator|->
name|level
expr_stmt|;
block|}
name|t
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
operator|=
name|np
operator|->
name|n_value
expr_stmt|;
name|newfunc
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|findbeginning
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|find
argument_list|(
argument|t
argument_list|,
argument|n
argument_list|)
name|where
name|t
operator|->
name|class
operator|==
name|VAR
name|and
name|t
operator|->
name|level
operator|==
name|program
operator|->
name|level
name|endfind
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|t
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|t
operator|->
name|language
operator|=
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
expr_stmt|;
name|t
operator|->
name|class
operator|=
name|VAR
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|t_int
expr_stmt|;
name|t
operator|->
name|block
operator|=
name|curblock
expr_stmt|;
name|t
operator|->
name|level
operator|=
name|program
operator|->
name|level
expr_stmt|;
block|}
name|t
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|np
operator|->
name|n_value
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if a local _name is known in the current scope.  * If not then enter it.  */
end_comment

begin_function
name|private
name|check_local
parameter_list|(
name|name
parameter_list|,
name|np
parameter_list|)
name|String
name|name
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
block|{
specifier|register
name|Name
name|n
decl_stmt|;
specifier|register
name|Symbol
name|t
decl_stmt|,
name|cur
decl_stmt|;
name|n
operator|=
name|identname
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|(
operator|(
name|np
operator|->
name|n_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_TEXT
operator|)
condition|?
name|curmodule
else|:
name|curblock
expr_stmt|;
name|find
argument_list|(
argument|t
argument_list|,
argument|n
argument_list|)
name|where
name|t
operator|->
name|block
operator|==
name|cur
name|endfind
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|t
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|t
operator|->
name|language
operator|=
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|t_int
expr_stmt|;
name|t
operator|->
name|block
operator|=
name|cur
expr_stmt|;
name|t
operator|->
name|level
operator|=
name|cur
operator|->
name|level
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|->
name|n_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_TEXT
condition|)
block|{
name|t
operator|->
name|class
operator|=
name|FUNC
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
operator|=
name|np
operator|->
name|n_value
expr_stmt|;
name|newfunc
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|findbeginning
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|class
operator|=
name|VAR
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|np
operator|->
name|n_value
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if a symbol corresponds to a object file name.  * For some reason these are listed as in the text segment.  */
end_comment

begin_function
name|private
name|check_filename
parameter_list|(
name|name
parameter_list|)
name|String
name|name
decl_stmt|;
block|{
specifier|register
name|String
name|mname
decl_stmt|;
specifier|register
name|Integer
name|i
decl_stmt|;
specifier|register
name|Symbol
name|s
decl_stmt|;
name|mname
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|mname
argument_list|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
name|and
name|mname
index|[
name|i
index|]
operator|==
literal|'.'
name|and
name|mname
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'o'
condition|)
block|{
name|mname
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|--
name|i
expr_stmt|;
while|while
condition|(
name|mname
index|[
name|i
index|]
operator|!=
literal|'/'
name|and
name|i
operator|>=
literal|0
condition|)
block|{
operator|--
name|i
expr_stmt|;
block|}
name|s
operator|=
name|insert
argument_list|(
name|identname
argument_list|(
operator|&
name|mname
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|MODULE
expr_stmt|;
if|if
condition|(
name|curblock
operator|->
name|class
operator|!=
name|PROG
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
if|if
condition|(
name|curblock
operator|->
name|class
operator|!=
name|PROG
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
block|}
block|}
name|enterblock
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|curmodule
operator|=
name|s
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Put an nlist into the symbol table.  * If it's already there just add the associated information.  *  * Type information is encoded in the name following a ":".  */
end_comment

begin_function_decl
name|private
name|Symbol
name|constype
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|Char
modifier|*
name|curchar
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|skipchar
parameter_list|(
name|ptr
parameter_list|,
name|ch
parameter_list|)
value|{ \     if (*ptr != ch) { \ 	panic("expected char '%c', found char '%c'", ch, *ptr); \     } \     ++ptr; \ }
end_define

begin_function
name|private
name|entersym
parameter_list|(
name|str
parameter_list|,
name|np
parameter_list|)
name|String
name|str
decl_stmt|;
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|Name
name|n
decl_stmt|;
specifier|register
name|Integer
name|i
decl_stmt|;
name|Boolean
name|knowtype
decl_stmt|,
name|isnew
decl_stmt|;
name|Symclass
name|class
decl_stmt|;
name|Integer
name|level
decl_stmt|;
name|p
operator|=
name|index
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|n
operator|=
name|identname
argument_list|(
name|str
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"FfGV"
argument_list|,
name|c
argument_list|)
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'F'
name|or
name|c
operator|==
literal|'f'
condition|)
block|{
name|class
operator|=
name|FUNC
expr_stmt|;
block|}
else|else
block|{
name|class
operator|=
name|VAR
expr_stmt|;
block|}
name|level
operator|=
operator|(
name|c
operator|==
literal|'f'
condition|?
name|curmodule
operator|->
name|level
else|:
name|program
operator|->
name|level
operator|)
expr_stmt|;
name|find
argument_list|(
argument|s
argument_list|,
argument|n
argument_list|)
name|where
name|s
operator|->
name|level
operator|==
name|level
name|and
name|s
operator|->
name|class
operator|==
name|class
name|endfind
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|isnew
operator|=
name|true
expr_stmt|;
name|s
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isnew
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|isnew
operator|=
name|true
expr_stmt|;
name|s
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
comment|/*      * Default attributes.      */
name|s
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|VAR
expr_stmt|;
name|s
operator|->
name|block
operator|=
name|curblock
expr_stmt|;
name|s
operator|->
name|level
operator|=
name|curlevel
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|np
operator|->
name|n_value
expr_stmt|;
name|curchar
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|knowtype
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'t'
case|:
comment|/* type name */
name|s
operator|->
name|class
operator|=
name|TYPE
expr_stmt|;
name|i
operator|=
name|getint
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"bad input on type \"%s\" at \"%s\""
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
name|NTYPES
condition|)
block|{
name|panic
argument_list|(
literal|"too many types in file \"%s\""
argument_list|,
name|curfilename
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * A hack for C typedefs that don't create new types, 	     * e.g. typedef unsigned int Hashvalue; 	     */
if|if
condition|(
operator|*
name|curchar
operator|==
literal|'\0'
condition|)
block|{
name|s
operator|->
name|type
operator|=
name|typetable
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"nil type for %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|knowtype
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|typetable
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
comment|/* tag */
name|s
operator|->
name|class
operator|=
name|TAG
expr_stmt|;
name|i
operator|=
name|getint
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"bad input on tag \"%s\" at \"%s\""
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
name|NTYPES
condition|)
block|{
name|panic
argument_list|(
literal|"too many types in file \"%s\""
argument_list|,
name|curfilename
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetable
index|[
name|i
index|]
operator|!=
name|nil
condition|)
block|{
name|typetable
index|[
name|i
index|]
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|typetable
index|[
name|i
index|]
operator|->
name|class
operator|=
name|TYPE
expr_stmt|;
name|typetable
index|[
name|i
index|]
operator|->
name|type
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|typetable
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
block|}
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* public function */
case|case
literal|'f'
case|:
comment|/* private function */
name|s
operator|->
name|class
operator|=
name|FUNC
expr_stmt|;
if|if
condition|(
name|curblock
operator|->
name|class
operator|==
name|FUNC
name|or
name|curblock
operator|->
name|class
operator|==
name|PROC
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
block|}
name|enterblock
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'F'
condition|)
block|{
name|s
operator|->
name|level
operator|=
name|program
operator|->
name|level
expr_stmt|;
name|isnew
operator|=
name|false
expr_stmt|;
block|}
name|curparam
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|isnew
condition|)
block|{
name|s
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
operator|=
name|np
operator|->
name|n_value
expr_stmt|;
name|newfunc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|findbeginning
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'G'
case|:
comment|/* public variable */
name|s
operator|->
name|level
operator|=
name|program
operator|->
name|level
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* private variable */
name|s
operator|->
name|level
operator|=
name|curmodule
operator|->
name|level
expr_stmt|;
name|s
operator|->
name|block
operator|=
name|curmodule
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* own variable */
name|s
operator|->
name|level
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* register variable */
name|s
operator|->
name|level
operator|=
operator|-
operator|(
name|s
operator|->
name|level
operator|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* parameter variable */
name|curparam
operator|->
name|chain
operator|=
name|s
expr_stmt|;
name|curparam
operator|=
name|s
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* varies parameter */
name|s
operator|->
name|class
operator|=
name|REF
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|np
operator|->
name|n_value
expr_stmt|;
name|curparam
operator|->
name|chain
operator|=
name|s
expr_stmt|;
name|curparam
operator|=
name|s
expr_stmt|;
break|break;
default|default:
comment|/* local variable */
operator|--
name|curchar
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|not
name|knowtype
condition|)
block|{
name|s
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|class
operator|==
name|TAG
condition|)
block|{
name|addtag
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tracesyms
condition|)
block|{
name|printdecl
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Construct a type out of a string encoding.  *  * The forms of the string are  *  *<number>  *<number>=<type>  *	r<type>;<number>;<number>		$ subrange  *	a<type>;<type>				$ array[index] of element  *	s{<name>:<type>;<number>;<number>}	$ record  *	*<type>					$ pointer  */
end_comment

begin_function
name|private
name|Symbol
name|constype
parameter_list|(
name|type
parameter_list|)
name|Symbol
name|type
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|,
name|u
decl_stmt|;
specifier|register
name|Char
modifier|*
name|p
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
specifier|register
name|Integer
name|n
decl_stmt|;
name|Integer
name|b
decl_stmt|;
name|Name
name|name
decl_stmt|;
name|Char
name|class
decl_stmt|;
name|b
operator|=
name|curlevel
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|curchar
argument_list|)
condition|)
block|{
name|n
operator|=
name|getint
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"bad type number at \"%s\""
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>=
name|NTYPES
condition|)
block|{
name|panic
argument_list|(
literal|"too many types in file \"%s\""
argument_list|,
name|curfilename
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|curchar
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|typetable
index|[
name|n
index|]
operator|!=
name|nil
condition|)
block|{
name|t
operator|=
name|typetable
index|[
name|n
index|]
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|symbol_alloc
argument_list|()
expr_stmt|;
name|typetable
index|[
name|n
index|]
operator|=
name|t
expr_stmt|;
block|}
operator|++
name|curchar
expr_stmt|;
name|constype
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|typetable
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|t
operator|=
name|symbol_alloc
argument_list|()
expr_stmt|;
name|typetable
index|[
name|n
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|nil
condition|)
block|{
name|t
operator|=
name|symbol_alloc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|type
expr_stmt|;
block|}
name|t
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|t
operator|->
name|level
operator|=
name|b
expr_stmt|;
name|class
operator|=
operator|*
name|curchar
operator|++
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|'r'
case|:
name|t
operator|->
name|class
operator|=
name|RANGE
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
operator|=
name|getint
argument_list|()
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
operator|=
name|getint
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|t
operator|->
name|class
operator|=
name|ARRAY
expr_stmt|;
name|t
operator|->
name|chain
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'u'
case|:
name|t
operator|->
name|class
operator|=
operator|(
name|class
operator|==
literal|'s'
operator|)
condition|?
name|RECORD
else|:
name|VARNT
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|getint
argument_list|()
expr_stmt|;
name|u
operator|=
name|t
expr_stmt|;
name|cur
operator|=
name|curchar
expr_stmt|;
while|while
condition|(
operator|*
name|cur
operator|!=
literal|';'
name|and
operator|*
name|cur
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|cur
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"index(\"%s\", ':') failed"
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|identname
argument_list|(
name|cur
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|u
operator|->
name|chain
operator|=
name|newSymbol
argument_list|(
name|name
argument_list|,
name|b
argument_list|,
name|FIELD
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|cur
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|u
operator|=
name|u
operator|->
name|chain
expr_stmt|;
name|u
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|curchar
operator|=
name|cur
expr_stmt|;
name|u
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|u
operator|->
name|symvalue
operator|.
name|field
operator|.
name|offset
operator|=
name|getint
argument_list|()
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|u
operator|->
name|symvalue
operator|.
name|field
operator|.
name|length
operator|=
name|getint
argument_list|()
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|cur
operator|=
name|curchar
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cur
operator|==
literal|';'
condition|)
block|{
operator|++
name|cur
expr_stmt|;
block|}
name|curchar
operator|=
name|cur
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|t
operator|->
name|class
operator|=
name|SCAL
expr_stmt|;
name|u
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|curchar
operator|!=
literal|';'
name|and
operator|*
name|curchar
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|curchar
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|!=
name|nil
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|u
operator|->
name|chain
operator|=
name|insert
argument_list|(
name|identname
argument_list|(
name|curchar
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|curchar
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|u
operator|=
name|u
operator|->
name|chain
expr_stmt|;
name|u
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|u
operator|->
name|class
operator|=
name|CONST
expr_stmt|;
name|u
operator|->
name|level
operator|=
name|b
expr_stmt|;
name|u
operator|->
name|block
operator|=
name|curblock
expr_stmt|;
name|u
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|u
operator|->
name|symvalue
operator|.
name|iconval
operator|=
name|getint
argument_list|()
expr_stmt|;
name|skipchar
argument_list|(
name|curchar
argument_list|,
literal|','
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'*'
case|:
name|t
operator|->
name|class
operator|=
name|PTR
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|t
operator|->
name|class
operator|=
name|FUNC
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|constype
argument_list|(
name|nil
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badcaseval
argument_list|(
name|class
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*  * Read an integer from the current position in the type string.  */
end_comment

begin_function
name|private
name|Integer
name|getint
parameter_list|()
block|{
specifier|register
name|Integer
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|Boolean
name|isneg
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|curchar
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|isneg
operator|=
name|true
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
else|else
block|{
name|isneg
operator|=
name|false
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|n
operator|=
literal|10
operator|*
name|n
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|curchar
operator|=
name|p
expr_stmt|;
return|return
name|isneg
condition|?
operator|(
operator|-
name|n
operator|)
else|:
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Add a tag name.  This is a kludge to be able to refer  * to tags that have the same name as some other symbol  * in the same block.  */
end_comment

begin_function
name|private
name|addtag
parameter_list|(
name|s
parameter_list|)
specifier|register
name|Symbol
name|s
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$$%.90s"
argument_list|,
name|ident
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|insert
argument_list|(
name|identname
argument_list|(
name|buf
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|language
operator|=
name|s
operator|->
name|language
expr_stmt|;
name|t
operator|->
name|class
operator|=
name|TAG
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|s
operator|->
name|type
expr_stmt|;
name|t
operator|->
name|block
operator|=
name|s
operator|->
name|block
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate file and line tables and initialize indices.  */
end_comment

begin_function
name|private
name|allocmaps
parameter_list|(
name|nf
parameter_list|,
name|nl
parameter_list|)
name|Integer
name|nf
decl_stmt|,
name|nl
decl_stmt|;
block|{
if|if
condition|(
name|filetab
operator|!=
name|nil
condition|)
block|{
name|dispose
argument_list|(
name|filetab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linetab
operator|!=
name|nil
condition|)
block|{
name|dispose
argument_list|(
name|linetab
argument_list|)
expr_stmt|;
block|}
name|filetab
operator|=
name|newarr
argument_list|(
name|Filetab
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|linetab
operator|=
name|newarr
argument_list|(
name|Linetab
argument_list|,
name|nl
argument_list|)
expr_stmt|;
name|filep
operator|=
name|filetab
expr_stmt|;
name|linep
operator|=
name|linetab
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a file to the file table.  */
end_comment

begin_function
name|private
name|enterfile
parameter_list|(
name|filename
parameter_list|,
name|addr
parameter_list|)
name|String
name|filename
decl_stmt|;
name|Address
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|addr
operator|!=
name|curfaddr
condition|)
block|{
name|filep
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|filep
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|filep
operator|->
name|lineindex
operator|=
name|linep
operator|-
name|linetab
expr_stmt|;
operator|++
name|filep
expr_stmt|;
name|curfaddr
operator|=
name|addr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Since we only estimated the number of lines (and it was a poor  * estimation) and since we need to know the exact number of lines  * to do a binary search, we set it when we're done.  */
end_comment

begin_function
name|private
name|setnlines
parameter_list|()
block|{
name|nlhdr
operator|.
name|nlines
operator|=
name|linep
operator|-
name|linetab
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Similarly for nfiles ...  */
end_comment

begin_function
name|private
name|setnfiles
parameter_list|()
block|{
name|nlhdr
operator|.
name|nfiles
operator|=
name|filep
operator|-
name|filetab
expr_stmt|;
name|setsource
argument_list|(
name|filetab
index|[
literal|0
index|]
operator|.
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

