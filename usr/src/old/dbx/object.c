begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)object.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: object.c,v 1.5 87/03/26 20:24:58 donn Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Object code interface, mainly for extraction of symbolic information.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"stabstring.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"languages.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"lists.h"
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_struct
struct|struct
block|{
name|unsigned
name|int
name|stringsize
decl_stmt|;
comment|/* size of the dumped string table */
name|unsigned
name|int
name|nsyms
decl_stmt|;
comment|/* number of symbols */
name|unsigned
name|int
name|nfiles
decl_stmt|;
comment|/* number of files */
name|unsigned
name|int
name|nlines
decl_stmt|;
comment|/* number of lines */
block|}
name|nlhdr
struct|;
end_struct

begin_include
include|#
directive|include
file|"languages.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|N_MOD2
end_ifndef

begin_define
define|#
directive|define
name|N_MOD2
value|0x50
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|public
name|String
name|objname
init|=
literal|"a.out"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|integer
name|objsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|Language
name|curlang
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|Symbol
name|curmodule
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|Symbol
name|curparam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|Symbol
name|curcomm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|Symbol
name|commchain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|stringtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|nlist
modifier|*
name|curnp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Boolean
name|warned
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Boolean
name|strip_
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Filetab
modifier|*
name|filep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Linetab
modifier|*
name|linep
decl_stmt|,
modifier|*
name|prevlinep
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|String
name|curfilename
parameter_list|()
block|{
return|return
operator|(
operator|(
name|filep
operator|-
literal|1
operator|)
operator|->
name|filename
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Blocks are figured out on the fly while reading the symbol table.  */
end_comment

begin_define
define|#
directive|define
name|MAXBLKDEPTH
value|25
end_define

begin_decl_stmt
name|public
name|Symbol
name|curblock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Symbol
name|blkstack
index|[
name|MAXBLKDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|integer
name|curlevel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|integer
name|bnum
decl_stmt|,
name|nesting
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Address
name|addrstk
index|[
name|MAXBLKDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|pushBlock
parameter_list|(
name|b
parameter_list|)
name|Symbol
name|b
decl_stmt|;
block|{
if|if
condition|(
name|curlevel
operator|>=
name|MAXBLKDEPTH
condition|)
block|{
name|fatal
argument_list|(
literal|"nesting depth too large (%d)"
argument_list|,
name|curlevel
argument_list|)
expr_stmt|;
block|}
name|blkstack
index|[
name|curlevel
index|]
operator|=
name|curblock
expr_stmt|;
operator|++
name|curlevel
expr_stmt|;
name|curblock
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|traceblocks
condition|)
block|{
name|printf
argument_list|(
literal|"entering block %s\n"
argument_list|,
name|symname
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Change the current block with saving the previous one,  * since it is assumed that the symbol for the current one is to be deleted.  */
end_comment

begin_function
name|public
name|changeBlock
parameter_list|(
name|b
parameter_list|)
name|Symbol
name|b
decl_stmt|;
block|{
name|curblock
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_function
name|public
name|enterblock
parameter_list|(
name|b
parameter_list|)
name|Symbol
name|b
decl_stmt|;
block|{
if|if
condition|(
name|curblock
operator|==
name|nil
condition|)
block|{
name|b
operator|->
name|level
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b
operator|->
name|level
operator|=
name|curblock
operator|->
name|level
operator|+
literal|1
expr_stmt|;
block|}
name|b
operator|->
name|block
operator|=
name|curblock
expr_stmt|;
name|pushBlock
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|public
name|exitblock
parameter_list|()
block|{
if|if
condition|(
name|curblock
operator|->
name|class
operator|==
name|FUNC
name|or
name|curblock
operator|->
name|class
operator|==
name|PROC
condition|)
block|{
if|if
condition|(
name|prevlinep
operator|!=
name|linep
condition|)
block|{
name|curblock
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|src
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|curlevel
operator|<=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"nesting depth underflow (%d)"
argument_list|,
name|curlevel
argument_list|)
expr_stmt|;
block|}
operator|--
name|curlevel
expr_stmt|;
if|if
condition|(
name|traceblocks
condition|)
block|{
name|printf
argument_list|(
literal|"exiting block %s\n"
argument_list|,
name|symname
argument_list|(
name|curblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|curblock
operator|=
name|blkstack
index|[
name|curlevel
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enter a source line or file name reference into the appropriate table.  * Expanded inline to reduce procedure calls.  *  * private enterline (linenumber, address)  * Lineno linenumber;  * Address address;  *  ...  */
end_comment

begin_define
define|#
directive|define
name|enterline
parameter_list|(
name|linenumber
parameter_list|,
name|address
parameter_list|)
define|\
value|{ \     register Linetab *lp; \  \     lp = linep - 1; \     if (linenumber != lp->line) { \ 	if (address != lp->addr) { \ 	    ++lp; \ 	} \ 	lp->line = linenumber; \ 	lp->addr = address; \ 	linep = lp + 1; \     } \ }
end_define

begin_comment
comment|/*  * Read in the namelist from the obj file.  *  * Reads and seeks are used instead of fread's and fseek's  * for efficiency sake; there's a lot of data being read here.  */
end_comment

begin_function
name|public
name|readobj
parameter_list|(
name|file
parameter_list|)
name|String
name|file
decl_stmt|;
block|{
name|Fileid
name|f
decl_stmt|;
name|struct
name|exec
name|hdr
decl_stmt|;
name|struct
name|nlist
name|nlist
decl_stmt|;
name|f
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"can't open %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|read
argument_list|(
name|f
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|objsize
operator|=
literal|0
expr_stmt|;
name|nlhdr
operator|.
name|nsyms
operator|=
literal|0
expr_stmt|;
name|nlhdr
operator|.
name|nfiles
operator|=
literal|0
expr_stmt|;
name|nlhdr
operator|.
name|nlines
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|objsize
operator|=
name|hdr
operator|.
name|a_text
expr_stmt|;
name|nlhdr
operator|.
name|nsyms
operator|=
name|hdr
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
name|nlist
argument_list|)
expr_stmt|;
name|nlhdr
operator|.
name|nfiles
operator|=
name|nlhdr
operator|.
name|nsyms
expr_stmt|;
name|nlhdr
operator|.
name|nlines
operator|=
name|nlhdr
operator|.
name|nsyms
expr_stmt|;
block|}
if|if
condition|(
name|nlhdr
operator|.
name|nsyms
operator|>
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|long
operator|)
name|N_STROFF
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|f
argument_list|,
operator|&
operator|(
name|nlhdr
operator|.
name|stringsize
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|nlhdr
operator|.
name|stringsize
argument_list|)
argument_list|)
expr_stmt|;
name|nlhdr
operator|.
name|stringsize
operator|-=
literal|4
expr_stmt|;
name|stringtab
operator|=
name|newarr
argument_list|(
name|char
argument_list|,
name|nlhdr
operator|.
name|stringsize
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|f
argument_list|,
name|stringtab
argument_list|,
name|nlhdr
operator|.
name|stringsize
argument_list|)
expr_stmt|;
name|allocmaps
argument_list|(
name|nlhdr
operator|.
name|nfiles
argument_list|,
name|nlhdr
operator|.
name|nlines
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|long
operator|)
name|N_SYMOFF
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|readsyms
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ordfunctab
argument_list|()
expr_stmt|;
name|setnlines
argument_list|()
expr_stmt|;
name|setnfiles
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|initsyms
argument_list|()
expr_stmt|;
block|}
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Found the beginning of the externals in the object file  * (signified by the "-lg" or find an external), close the  * block for the last procedure.  */
end_comment

begin_function
name|private
name|foundglobals
parameter_list|()
block|{
if|if
condition|(
name|curblock
operator|->
name|class
operator|!=
name|PROG
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
if|if
condition|(
name|curblock
operator|->
name|class
operator|!=
name|PROG
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
block|}
block|}
name|enterline
argument_list|(
literal|0
argument_list|,
operator|(
name|linep
operator|-
literal|1
operator|)
operator|->
name|addr
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read in symbols from object file.  */
end_comment

begin_function
name|private
name|readsyms
parameter_list|(
name|f
parameter_list|)
name|Fileid
name|f
decl_stmt|;
block|{
name|struct
name|nlist
modifier|*
name|namelist
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|,
modifier|*
name|ub
decl_stmt|;
specifier|register
name|String
name|name
decl_stmt|;
name|boolean
name|afterlg
decl_stmt|,
name|foundstab
decl_stmt|;
name|integer
name|index
decl_stmt|;
name|char
modifier|*
name|lastchar
decl_stmt|;
name|initsyms
argument_list|()
expr_stmt|;
name|namelist
operator|=
name|newarr
argument_list|(
expr|struct
name|nlist
argument_list|,
name|nlhdr
operator|.
name|nsyms
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|f
argument_list|,
name|namelist
argument_list|,
name|nlhdr
operator|.
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
name|afterlg
operator|=
name|false
expr_stmt|;
name|foundstab
operator|=
name|false
expr_stmt|;
name|ub
operator|=
operator|&
name|namelist
index|[
name|nlhdr
operator|.
name|nsyms
index|]
expr_stmt|;
name|curnp
operator|=
operator|&
name|namelist
index|[
literal|0
index|]
expr_stmt|;
name|np
operator|=
name|curnp
expr_stmt|;
while|while
condition|(
name|np
operator|<
name|ub
condition|)
block|{
name|index
operator|=
name|np
operator|->
name|n_un
operator|.
name|n_strx
expr_stmt|;
if|if
condition|(
name|index
operator|!=
literal|0
condition|)
block|{
name|name
operator|=
operator|&
name|stringtab
index|[
name|index
operator|-
literal|4
index|]
expr_stmt|;
comment|/*              *  If the program contains any .f files a trailing _ is stripped        	     *  from the name on the assumption it was added by the compiler. 	     *  This only affects names that follow the sdb N_SO entry with              *  the .f name.               */
if|if
condition|(
name|strip_
name|and
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|lastchar
operator|=
operator|&
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|lastchar
operator|==
literal|'_'
condition|)
block|{
operator|*
name|lastchar
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|name
operator|=
name|nil
expr_stmt|;
block|}
comment|/* 	 * Assumptions: 	 *	not an N_STAB	==> name != nil 	 *	name[0] == '-'	==> name == "-lg" 	 *	name[0] != '_'	==> filename or invisible 	 * 	 * The "-lg" signals the beginning of global loader symbols.          * 	 */
if|if
condition|(
operator|(
name|np
operator|->
name|n_type
operator|&
name|N_STAB
operator|)
operator|!=
literal|0
condition|)
block|{
name|foundstab
operator|=
name|true
expr_stmt|;
name|enter_nl
argument_list|(
name|name
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|afterlg
operator|=
name|true
expr_stmt|;
name|foundglobals
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|afterlg
condition|)
block|{
name|check_global
argument_list|(
name|name
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|np
operator|->
name|n_type
operator|&
name|N_EXT
operator|)
operator|==
name|N_EXT
condition|)
block|{
name|afterlg
operator|=
name|true
expr_stmt|;
name|foundglobals
argument_list|()
expr_stmt|;
name|check_global
argument_list|(
name|name
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
name|check_local
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|np
operator|->
name|n_type
operator|&
name|N_TEXT
operator|)
operator|==
name|N_TEXT
condition|)
block|{
name|check_filename
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
operator|++
name|curnp
expr_stmt|;
name|np
operator|=
name|curnp
expr_stmt|;
block|}
if|if
condition|(
name|not
name|foundstab
condition|)
block|{
name|warning
argument_list|(
literal|"no source compiled with -g"
argument_list|)
expr_stmt|;
block|}
name|dispose
argument_list|(
name|namelist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a continuation entry from the name list.  * Return the beginning of the name.  */
end_comment

begin_function
name|public
name|String
name|getcont
parameter_list|()
block|{
specifier|register
name|integer
name|index
decl_stmt|;
specifier|register
name|String
name|name
decl_stmt|;
operator|++
name|curnp
expr_stmt|;
name|index
operator|=
name|curnp
operator|->
name|n_un
operator|.
name|n_strx
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|name
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
operator|&
name|stringtab
index|[
name|index
operator|-
literal|4
index|]
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize symbol information.  */
end_comment

begin_function
name|private
name|initsyms
parameter_list|()
block|{
name|curblock
operator|=
name|nil
expr_stmt|;
name|curlevel
operator|=
literal|0
expr_stmt|;
name|nesting
operator|=
literal|0
expr_stmt|;
name|program
operator|=
name|insert
argument_list|(
name|identname
argument_list|(
literal|""
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|program
operator|->
name|class
operator|=
name|PROG
expr_stmt|;
name|program
operator|->
name|language
operator|=
name|primlang
expr_stmt|;
name|program
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
operator|=
name|CODESTART
expr_stmt|;
name|program
operator|->
name|symvalue
operator|.
name|funcv
operator|.
expr|inline
operator|=
name|false
expr_stmt|;
name|newfunc
argument_list|(
name|program
argument_list|,
name|codeloc
argument_list|(
name|program
argument_list|)
argument_list|)
expr_stmt|;
name|findbeginning
argument_list|(
name|program
argument_list|)
expr_stmt|;
name|enterblock
argument_list|(
name|program
argument_list|)
expr_stmt|;
name|curmodule
operator|=
name|program
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free all the object file information that's being stored.  */
end_comment

begin_function
name|public
name|objfree
parameter_list|()
block|{
name|symbol_free
argument_list|()
expr_stmt|;
comment|/* keywords_free(); */
comment|/* names_free(); */
comment|/* dispose(stringtab); */
name|clrfunctab
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enter a namelist entry.  */
end_comment

begin_function
name|private
name|enter_nl
parameter_list|(
name|name
parameter_list|,
name|np
parameter_list|)
name|String
name|name
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
specifier|register
name|Name
name|n
decl_stmt|;
name|s
operator|=
name|nil
expr_stmt|;
switch|switch
condition|(
name|np
operator|->
name|n_type
condition|)
block|{
comment|/* 	 * Build a symbol for the FORTRAN common area.  All GSYMS that follow 	 * will be chained in a list with the head kept in common.offset, and 	 * the tail in common.chain. 	 */
case|case
name|N_BCOMM
case|:
if|if
condition|(
name|curcomm
condition|)
block|{
name|curcomm
operator|->
name|symvalue
operator|.
name|common
operator|.
name|chain
operator|=
name|commchain
expr_stmt|;
block|}
name|n
operator|=
name|identname
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|curcomm
operator|=
name|lookup
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|curcomm
operator|==
name|nil
condition|)
block|{
name|curcomm
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|curcomm
operator|->
name|class
operator|=
name|COMMON
expr_stmt|;
name|curcomm
operator|->
name|block
operator|=
name|curblock
expr_stmt|;
name|curcomm
operator|->
name|level
operator|=
name|program
operator|->
name|level
expr_stmt|;
name|curcomm
operator|->
name|symvalue
operator|.
name|common
operator|.
name|chain
operator|=
name|nil
expr_stmt|;
block|}
name|commchain
operator|=
name|curcomm
operator|->
name|symvalue
operator|.
name|common
operator|.
name|chain
expr_stmt|;
break|break;
case|case
name|N_ECOMM
case|:
if|if
condition|(
name|curcomm
condition|)
block|{
name|curcomm
operator|->
name|symvalue
operator|.
name|common
operator|.
name|chain
operator|=
name|commchain
expr_stmt|;
name|curcomm
operator|=
name|nil
expr_stmt|;
block|}
break|break;
case|case
name|N_LBRAC
case|:
operator|++
name|nesting
expr_stmt|;
name|addrstk
index|[
name|nesting
index|]
operator|=
operator|(
name|linep
operator|-
literal|1
operator|)
operator|->
name|addr
expr_stmt|;
break|break;
case|case
name|N_RBRAC
case|:
operator|--
name|nesting
expr_stmt|;
if|if
condition|(
name|addrstk
index|[
name|nesting
index|]
operator|==
name|NOADDR
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
name|newfunc
argument_list|(
name|curblock
argument_list|,
operator|(
name|linep
operator|-
literal|1
operator|)
operator|->
name|addr
argument_list|)
expr_stmt|;
name|addrstk
index|[
name|nesting
index|]
operator|=
operator|(
name|linep
operator|-
literal|1
operator|)
operator|->
name|addr
expr_stmt|;
block|}
break|break;
case|case
name|N_SLINE
case|:
name|enterline
argument_list|(
operator|(
name|Lineno
operator|)
name|np
operator|->
name|n_desc
argument_list|,
operator|(
name|Address
operator|)
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Source files. 	 */
case|case
name|N_SO
case|:
name|n
operator|=
name|identname
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|enterSourceModule
argument_list|(
name|n
argument_list|,
operator|(
name|Address
operator|)
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Textually included files. 	 */
case|case
name|N_SOL
case|:
name|enterfile
argument_list|(
name|name
argument_list|,
operator|(
name|Address
operator|)
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * These symbols are assumed to have non-nil names. 	 */
case|case
name|N_GSYM
case|:
case|case
name|N_FUN
case|:
case|case
name|N_STSYM
case|:
case|case
name|N_LCSYM
case|:
case|case
name|N_RSYM
case|:
case|case
name|N_PSYM
case|:
case|case
name|N_LSYM
case|:
case|case
name|N_SSYM
case|:
case|case
name|N_LENG
case|:
if|if
condition|(
name|index
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|==
name|nil
condition|)
block|{
if|if
condition|(
name|not
name|warned
condition|)
block|{
name|warned
operator|=
name|true
expr_stmt|;
name|printf
argument_list|(
literal|"warning: old style symbol information "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"found in \"%s\"\n"
argument_list|,
name|curfilename
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|entersym
argument_list|(
name|name
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|N_PC
case|:
case|case
name|N_MOD2
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"warning:  stab entry unrecognized: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"name %s,"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ntype %2x, desc %x, value %x'\n"
argument_list|,
name|np
operator|->
name|n_type
argument_list|,
name|np
operator|->
name|n_desc
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Try to find the symbol that is referred to by the given name.  Since it's  * an external, we need to follow a level or two of indirection.  */
end_comment

begin_function
name|private
name|Symbol
name|findsym
parameter_list|(
name|n
parameter_list|,
name|var_isextref
parameter_list|)
name|Name
name|n
decl_stmt|;
name|boolean
modifier|*
name|var_isextref
decl_stmt|;
block|{
specifier|register
name|Symbol
name|r
decl_stmt|,
name|s
decl_stmt|;
operator|*
name|var_isextref
operator|=
name|false
expr_stmt|;
name|find
argument_list|(
argument|s
argument_list|,
argument|n
argument_list|)
name|where
argument_list|(
argument|s->level == program->level and ( 		s->class == EXTREF or s->class == VAR or 		s->class == PROC or s->class == FUNC 	    )
argument_list|)
name|or
argument_list|(
argument|s->block == program and s->class == MODULE
argument_list|)
name|endfind
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|r
operator|=
name|nil
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|class
operator|==
name|EXTREF
condition|)
block|{
operator|*
name|var_isextref
operator|=
name|true
expr_stmt|;
name|r
operator|=
name|s
operator|->
name|symvalue
operator|.
name|extref
expr_stmt|;
name|delete
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Now check for another level of indirection that could come from 	 * a forward reference in procedure nesting information.  In this case 	 * the symbol has already been deleted. 	 */
if|if
condition|(
name|r
operator|!=
name|nil
name|and
name|r
operator|->
name|class
operator|==
name|EXTREF
condition|)
block|{
name|r
operator|=
name|r
operator|->
name|symvalue
operator|.
name|extref
expr_stmt|;
block|}
comment|/*     } else if (s->class == MODULE) { 	s->class = FUNC; 	s->level = program->level; 	r = s;  */
block|}
else|else
block|{
name|r
operator|=
name|s
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Create a symbol for a text symbol with no source information.  * We treat it as an assembly language function.  */
end_comment

begin_function
name|private
name|Symbol
name|deffunc
parameter_list|(
name|n
parameter_list|)
name|Name
name|n
decl_stmt|;
block|{
name|Symbol
name|f
decl_stmt|;
name|f
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|f
operator|->
name|language
operator|=
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
expr_stmt|;
name|f
operator|->
name|class
operator|=
name|FUNC
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|t_int
expr_stmt|;
name|f
operator|->
name|block
operator|=
name|curblock
expr_stmt|;
name|f
operator|->
name|level
operator|=
name|program
operator|->
name|level
expr_stmt|;
name|f
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|src
operator|=
name|false
expr_stmt|;
name|f
operator|->
name|symvalue
operator|.
name|funcv
operator|.
expr|inline
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|chain
operator|!=
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"chain not nil in deffunc"
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/*  * Create a symbol for a data or bss symbol with no source information.  * We treat it as an assembly language variable.  */
end_comment

begin_function
name|private
name|Symbol
name|defvar
parameter_list|(
name|n
parameter_list|)
name|Name
name|n
decl_stmt|;
block|{
name|Symbol
name|v
decl_stmt|;
name|v
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|v
operator|->
name|language
operator|=
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
expr_stmt|;
name|v
operator|->
name|storage
operator|=
name|EXT
expr_stmt|;
name|v
operator|->
name|class
operator|=
name|VAR
expr_stmt|;
name|v
operator|->
name|type
operator|=
name|t_int
expr_stmt|;
name|v
operator|->
name|level
operator|=
name|program
operator|->
name|level
expr_stmt|;
name|v
operator|->
name|block
operator|=
name|curblock
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/*  * Update a symbol entry with a text address.  */
end_comment

begin_function
name|private
name|updateTextSym
parameter_list|(
name|s
parameter_list|,
name|name
parameter_list|,
name|addr
parameter_list|)
name|Symbol
name|s
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|Address
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|class
operator|==
name|VAR
condition|)
block|{
name|s
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|addr
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
name|newfunc
argument_list|(
name|s
argument_list|,
name|codeloc
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|findbeginning
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Avoid seeing Pascal labels as text symbols.  */
end_comment

begin_function
name|private
name|boolean
name|PascalLabel
parameter_list|(
name|n
parameter_list|)
name|Name
name|n
decl_stmt|;
block|{
name|boolean
name|b
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|b
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|curlang
operator|==
name|findlanguage
argument_list|(
literal|".p"
argument_list|)
condition|)
block|{
name|p
operator|=
name|ident
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
name|and
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'$'
condition|)
block|{
name|b
operator|=
name|true
expr_stmt|;
break|break;
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a global _name is already in the symbol table,  * if not then insert it.  */
end_comment

begin_function
name|private
name|check_global
parameter_list|(
name|name
parameter_list|,
name|np
parameter_list|)
name|String
name|name
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
block|{
specifier|register
name|Name
name|n
decl_stmt|;
specifier|register
name|Symbol
name|t
decl_stmt|,
name|u
decl_stmt|;
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|boolean
name|isextref
decl_stmt|;
name|integer
name|count
decl_stmt|;
if|if
condition|(
name|not
name|streq
argument_list|(
name|name
argument_list|,
literal|"_end"
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
name|n
operator|=
name|identname
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|identname
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|(
name|n
argument_list|)
operator|!=
name|nil
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|n
operator|=
name|identname
argument_list|(
name|buf
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|np
operator|->
name|n_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_TEXT
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|findsym
argument_list|(
name|n
argument_list|,
operator|&
name|isextref
argument_list|)
expr_stmt|;
while|while
condition|(
name|isextref
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|updateTextSym
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
name|t
operator|=
name|findsym
argument_list|(
name|n
argument_list|,
operator|&
name|isextref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
if|if
condition|(
name|not
name|PascalLabel
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|t
operator|=
name|deffunc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|updateTextSym
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracesyms
condition|)
block|{
name|printdecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|MODULE
condition|)
block|{
name|u
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|deffunc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|t
operator|->
name|block
operator|=
name|u
expr_stmt|;
if|if
condition|(
name|tracesyms
condition|)
block|{
name|printdecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|updateTextSym
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
name|np
operator|->
name|n_value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|np
operator|->
name|n_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_BSS
name|or
argument_list|(
name|np
operator|->
name|n_type
operator|&
name|N_TYPE
argument_list|)
operator|==
name|N_DATA
condition|)
block|{
name|find
argument_list|(
argument|t
argument_list|,
argument|n
argument_list|)
name|where
name|t
operator|->
name|class
operator|==
name|COMMON
name|endfind
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|nil
condition|)
block|{
name|u
operator|=
operator|(
name|Symbol
operator|)
name|t
operator|->
name|symvalue
operator|.
name|common
operator|.
name|offset
expr_stmt|;
while|while
condition|(
name|u
operator|!=
name|nil
condition|)
block|{
name|u
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|u
operator|->
name|symvalue
operator|.
name|common
operator|.
name|offset
operator|+
name|np
operator|->
name|n_value
expr_stmt|;
name|u
operator|=
name|u
operator|->
name|symvalue
operator|.
name|common
operator|.
name|chain
expr_stmt|;
block|}
block|}
else|else
block|{
name|check_var
argument_list|(
name|np
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|check_var
argument_list|(
name|np
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if a namelist entry refers to a variable.  * If not, create a variable for the entry.  In any case,  * set the offset of the variable according to the value field  * in the entry.  *  * If the external name has been referred to by several other symbols,  * we must update each of them.  */
end_comment

begin_function
name|private
name|check_var
parameter_list|(
name|np
parameter_list|,
name|n
parameter_list|)
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
specifier|register
name|Name
name|n
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|,
name|u
decl_stmt|,
name|next
decl_stmt|;
name|Symbol
name|conflict
decl_stmt|;
name|t
operator|=
name|lookup
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|t
operator|=
name|defvar
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|np
operator|->
name|n_value
expr_stmt|;
if|if
condition|(
name|tracesyms
condition|)
block|{
name|printdecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|conflict
operator|=
name|nil
expr_stmt|;
do|do
block|{
name|next
operator|=
name|t
operator|->
name|next_sym
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|name
operator|==
name|n
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|MODULE
name|and
name|t
operator|->
name|block
operator|==
name|program
condition|)
block|{
name|conflict
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|EXTREF
name|and
name|t
operator|->
name|level
operator|==
name|program
operator|->
name|level
condition|)
block|{
name|u
operator|=
name|t
operator|->
name|symvalue
operator|.
name|extref
expr_stmt|;
while|while
condition|(
name|u
operator|!=
name|nil
name|and
name|u
operator|->
name|class
operator|==
name|EXTREF
condition|)
block|{
name|u
operator|=
name|u
operator|->
name|symvalue
operator|.
name|extref
expr_stmt|;
block|}
name|u
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|np
operator|->
name|n_value
expr_stmt|;
name|delete
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|level
operator|==
name|program
operator|->
name|level
name|and
argument_list|(
argument|t->class == VAR or t->class == PROC or t->class == FUNC
argument_list|)
condition|)
block|{
name|conflict
operator|=
name|nil
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|np
operator|->
name|n_value
expr_stmt|;
block|}
block|}
name|t
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|!=
name|nil
condition|)
do|;
if|if
condition|(
name|conflict
operator|!=
name|nil
condition|)
block|{
name|u
operator|=
name|defvar
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|u
operator|->
name|block
operator|=
name|conflict
expr_stmt|;
name|u
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|np
operator|->
name|n_value
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if a local _name is known in the current scope.  * If not then enter it.  */
end_comment

begin_function
name|private
name|check_local
parameter_list|(
name|name
parameter_list|,
name|np
parameter_list|)
name|String
name|name
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
block|{
specifier|register
name|Name
name|n
decl_stmt|;
specifier|register
name|Symbol
name|t
decl_stmt|,
name|cur
decl_stmt|;
name|n
operator|=
name|identname
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|(
operator|(
name|np
operator|->
name|n_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_TEXT
operator|)
condition|?
name|curmodule
else|:
name|curblock
expr_stmt|;
name|find
argument_list|(
argument|t
argument_list|,
argument|n
argument_list|)
name|where
name|t
operator|->
name|block
operator|==
name|cur
name|endfind
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|t
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|t
operator|->
name|language
operator|=
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|t_int
expr_stmt|;
name|t
operator|->
name|block
operator|=
name|cur
expr_stmt|;
name|t
operator|->
name|storage
operator|=
name|EXT
expr_stmt|;
name|t
operator|->
name|level
operator|=
name|cur
operator|->
name|level
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|->
name|n_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_TEXT
condition|)
block|{
name|t
operator|->
name|class
operator|=
name|FUNC
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|src
operator|=
name|false
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|funcv
operator|.
expr|inline
operator|=
name|false
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
operator|=
name|np
operator|->
name|n_value
expr_stmt|;
name|newfunc
argument_list|(
name|t
argument_list|,
name|codeloc
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|findbeginning
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|class
operator|=
name|VAR
expr_stmt|;
name|t
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|np
operator|->
name|n_value
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if a symbol corresponds to a object file name.  * For some reason these are listed as in the text segment.  */
end_comment

begin_function
name|private
name|check_filename
parameter_list|(
name|name
parameter_list|)
name|String
name|name
decl_stmt|;
block|{
specifier|register
name|String
name|mname
decl_stmt|;
specifier|register
name|integer
name|i
decl_stmt|;
name|Name
name|n
decl_stmt|;
name|Symbol
name|s
decl_stmt|;
name|mname
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|mname
argument_list|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
name|and
name|mname
index|[
name|i
index|]
operator|==
literal|'.'
name|and
name|mname
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'o'
condition|)
block|{
name|mname
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|--
name|i
expr_stmt|;
while|while
condition|(
name|mname
index|[
name|i
index|]
operator|!=
literal|'/'
name|and
name|i
operator|>=
literal|0
condition|)
block|{
operator|--
name|i
expr_stmt|;
block|}
name|n
operator|=
name|identname
argument_list|(
operator|&
name|mname
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|find
argument_list|(
argument|s
argument_list|,
argument|n
argument_list|)
name|where
name|s
operator|->
name|block
operator|==
name|program
name|and
name|s
operator|->
name|class
operator|==
name|MODULE
name|endfind
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|s
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|MODULE
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
operator|=
literal|0
expr_stmt|;
name|findbeginning
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curblock
operator|->
name|class
operator|!=
name|PROG
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
if|if
condition|(
name|curblock
operator|->
name|class
operator|!=
name|PROG
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
block|}
block|}
name|enterblock
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|curmodule
operator|=
name|s
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if a symbol is about to be defined within an unnamed block.  * If this happens, we create a procedure for the unnamed block, make it  * "inline" so that tracebacks don't associate an activation record with it,  * and enter it into the function table so that it will be detected  * by "whatblock".  */
end_comment

begin_function
name|public
name|chkUnnamedBlock
parameter_list|()
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
specifier|static
name|int
name|bnum
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|Address
name|startaddr
decl_stmt|;
if|if
condition|(
name|nesting
operator|>
literal|0
name|and
name|addrstk
index|[
name|nesting
index|]
operator|!=
name|NOADDR
condition|)
block|{
name|startaddr
operator|=
operator|(
name|linep
operator|-
literal|1
operator|)
operator|->
name|addr
expr_stmt|;
operator|++
name|bnum
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$b%d"
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|s
operator|=
name|insert
argument_list|(
name|identname
argument_list|(
name|buf
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|PROC
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|src
operator|=
name|false
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|funcv
operator|.
expr|inline
operator|=
name|true
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
operator|=
name|startaddr
expr_stmt|;
name|enterblock
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|newfunc
argument_list|(
name|s
argument_list|,
name|startaddr
argument_list|)
expr_stmt|;
name|addrstk
index|[
name|nesting
index|]
operator|=
name|NOADDR
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compilation unit.  C associates scope with filenames  * so we treat them as "modules".  The filename without  * the suffix is used for the module name.  *  * Because there is no explicit "end-of-block" mark in  * the object file, we must exit blocks for the current  * procedure and module.  */
end_comment

begin_function
name|private
name|enterSourceModule
parameter_list|(
name|n
parameter_list|,
name|addr
parameter_list|)
name|Name
name|n
decl_stmt|;
name|Address
name|addr
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
name|Name
name|nn
decl_stmt|;
name|String
name|mname
decl_stmt|,
name|suffix
decl_stmt|;
name|mname
operator|=
name|strdup
argument_list|(
name|ident
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rindex
argument_list|(
name|mname
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|nil
condition|)
block|{
name|mname
operator|=
name|rindex
argument_list|(
name|mname
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|suffix
operator|=
name|rindex
argument_list|(
name|mname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffix
operator|>
name|mname
operator|&&
operator|*
operator|(
name|suffix
operator|-
literal|1
operator|)
operator|==
literal|'.'
condition|)
block|{
comment|/* special hack for C++ */
operator|--
name|suffix
expr_stmt|;
block|}
name|curlang
operator|=
name|findlanguage
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|curlang
operator|==
name|findlanguage
argument_list|(
literal|".f"
argument_list|)
condition|)
block|{
name|strip_
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|suffix
operator|!=
name|nil
condition|)
block|{
operator|*
name|suffix
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|not
argument_list|(
operator|*
name|language_op
argument_list|(
name|curlang
argument_list|,
name|L_HASMODULES
argument_list|)
argument_list|)
argument_list|()
condition|)
block|{
if|if
condition|(
name|curblock
operator|->
name|class
operator|!=
name|PROG
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
if|if
condition|(
name|curblock
operator|->
name|class
operator|!=
name|PROG
condition|)
block|{
name|exitblock
argument_list|()
expr_stmt|;
block|}
block|}
name|nn
operator|=
name|identname
argument_list|(
name|mname
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|curmodule
operator|==
name|nil
name|or
name|curmodule
operator|->
name|name
operator|!=
name|nn
condition|)
block|{
name|s
operator|=
name|insert
argument_list|(
name|nn
argument_list|)
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|MODULE
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
operator|=
literal|0
expr_stmt|;
name|findbeginning
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|curmodule
expr_stmt|;
block|}
name|s
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
name|enterblock
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|curmodule
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|program
operator|->
name|language
operator|==
name|nil
condition|)
block|{
name|program
operator|->
name|language
operator|=
name|curlang
expr_stmt|;
block|}
name|warned
operator|=
name|false
expr_stmt|;
name|enterfile
argument_list|(
name|ident
argument_list|(
name|n
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|initTypeTable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate file and line tables and initialize indices.  */
end_comment

begin_function
name|private
name|allocmaps
parameter_list|(
name|nf
parameter_list|,
name|nl
parameter_list|)
name|integer
name|nf
decl_stmt|,
name|nl
decl_stmt|;
block|{
if|if
condition|(
name|filetab
operator|!=
name|nil
condition|)
block|{
name|dispose
argument_list|(
name|filetab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linetab
operator|!=
name|nil
condition|)
block|{
name|dispose
argument_list|(
name|linetab
argument_list|)
expr_stmt|;
block|}
name|filetab
operator|=
name|newarr
argument_list|(
name|Filetab
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|linetab
operator|=
name|newarr
argument_list|(
name|Linetab
argument_list|,
name|nl
argument_list|)
expr_stmt|;
name|filep
operator|=
name|filetab
expr_stmt|;
name|linep
operator|=
name|linetab
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a file to the file table.  *  * If the new address is the same as the previous file address  * this routine used to not enter the file, but this caused some  * problems so it has been removed.  It's not clear that this in  * turn may not also cause a problem.  */
end_comment

begin_function
name|private
name|enterfile
parameter_list|(
name|filename
parameter_list|,
name|addr
parameter_list|)
name|String
name|filename
decl_stmt|;
name|Address
name|addr
decl_stmt|;
block|{
name|filep
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|filep
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|filep
operator|->
name|lineindex
operator|=
name|linep
operator|-
name|linetab
expr_stmt|;
operator|++
name|filep
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Since we only estimated the number of lines (and it was a poor  * estimation) and since we need to know the exact number of lines  * to do a binary search, we set it when we're done.  */
end_comment

begin_function
name|private
name|setnlines
parameter_list|()
block|{
name|nlhdr
operator|.
name|nlines
operator|=
name|linep
operator|-
name|linetab
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Similarly for nfiles ...  */
end_comment

begin_function
name|private
name|setnfiles
parameter_list|()
block|{
name|nlhdr
operator|.
name|nfiles
operator|=
name|filep
operator|-
name|filetab
expr_stmt|;
name|setsource
argument_list|(
name|filetab
index|[
literal|0
index|]
operator|.
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

