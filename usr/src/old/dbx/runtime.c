begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)runtime.c 1.6 %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Runtime organization dependent routines, mostly dealing with  * activation records.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"events.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_include
include|#
directive|include
file|"operators.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_typedef
typedef|typedef
name|struct
name|Frame
modifier|*
name|Frame
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NSAVEREG
value|12
end_define

begin_struct
struct|struct
name|Frame
block|{
name|Integer
name|condition_handler
decl_stmt|;
name|Integer
name|mask
decl_stmt|;
name|Address
name|save_ap
decl_stmt|;
comment|/* argument pointer */
name|Address
name|save_fp
decl_stmt|;
comment|/* frame pointer */
name|Address
name|save_pc
decl_stmt|;
comment|/* program counter */
name|Word
name|save_reg
index|[
name|NSAVEREG
index|]
decl_stmt|;
comment|/* not necessarily there */
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|Boolean
name|walkingstack
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set a frame to the current activation record.  */
end_comment

begin_function
name|private
name|getcurframe
parameter_list|(
name|frp
parameter_list|)
specifier|register
name|Frame
name|frp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|checkref
argument_list|(
name|frp
argument_list|)
expr_stmt|;
name|frp
operator|->
name|mask
operator|=
name|reg
argument_list|(
name|NREG
argument_list|)
expr_stmt|;
name|frp
operator|->
name|save_ap
operator|=
name|reg
argument_list|(
name|ARGP
argument_list|)
expr_stmt|;
name|frp
operator|->
name|save_fp
operator|=
name|reg
argument_list|(
name|FRP
argument_list|)
expr_stmt|;
name|frp
operator|->
name|save_pc
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSAVEREG
condition|;
name|i
operator|++
control|)
block|{
name|frp
operator|->
name|save_reg
index|[
name|i
index|]
operator|=
name|reg
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return a pointer to the next activation record up the stack.  * Return nil if there is none.  * Writes over space pointed to by given argument.  */
end_comment

begin_define
define|#
directive|define
name|bis
parameter_list|(
name|b
parameter_list|,
name|n
parameter_list|)
value|((b& (1<< (n))) != 0)
end_define

begin_function
name|private
name|Frame
name|nextframe
parameter_list|(
name|frp
parameter_list|)
name|Frame
name|frp
decl_stmt|;
block|{
specifier|register
name|Frame
name|newfrp
decl_stmt|;
name|struct
name|Frame
name|frame
decl_stmt|;
specifier|register
name|Integer
name|i
decl_stmt|,
name|j
decl_stmt|,
name|mask
decl_stmt|;
name|Address
name|prev_frame
decl_stmt|,
name|callpc
decl_stmt|;
name|private
name|Integer
name|ntramp
init|=
literal|0
decl_stmt|;
name|newfrp
operator|=
name|frp
expr_stmt|;
name|prev_frame
operator|=
name|frp
operator|->
name|save_fp
expr_stmt|;
comment|/*  The check for interrupt generated frames is taken from adb with only  *  partial understanding : say you're in sub and on a sigxxx siggsub  *  gets control and dies; the stack does NOT look like main, sub, sigsub.  *  *  As best I can make out it looks like:  *   main (machine check exception block + sub) sysframe  sigsub.  *  ie when the sig occurs push an exception block on the user stack  *  and a frame for the routine in which it occured then push another  *  frame corresponding to a call from the kernel to sigsub.  *  *  The addr in sub at which the exception occured is not in sub.save_pc  *  but in the machine check exception block. It can be referenced as  *  sub.save_reg[11].  *  *  The current approach ignores the sys_frame (what adb reports as sigtramp)  *  and takes the pc for sub from the exception block. This  *  allows where to report: main sub sigsub, which seems reasonable  */
name|nextf
label|:
name|dread
argument_list|(
operator|&
name|frame
argument_list|,
name|prev_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntramp
operator|==
literal|1
condition|)
name|callpc
operator|=
operator|(
name|Address
operator|)
name|frame
operator|.
name|save_reg
index|[
literal|11
index|]
expr_stmt|;
else|else
name|callpc
operator|=
name|frame
operator|.
name|save_pc
expr_stmt|;
if|if
condition|(
name|frame
operator|.
name|save_fp
operator|==
name|nil
condition|)
block|{
name|newfrp
operator|=
name|nil
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|callpc
operator|>
literal|0x80000000
operator|-
literal|0x200
operator|*
name|UPAGES
condition|)
block|{
name|ntramp
operator|++
expr_stmt|;
name|prev_frame
operator|=
name|frame
operator|.
name|save_fp
expr_stmt|;
goto|goto
name|nextf
goto|;
block|}
else|else
block|{
name|frame
operator|.
name|save_pc
operator|=
name|callpc
expr_stmt|;
name|ntramp
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|frame
operator|.
name|mask
operator|>>
literal|16
operator|)
operator|&
literal|0x0fff
operator|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSAVEREG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bis
argument_list|(
name|mask
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|newfrp
operator|->
name|save_reg
index|[
name|i
index|]
operator|=
name|frame
operator|.
name|save_reg
index|[
name|j
index|]
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
name|newfrp
operator|->
name|condition_handler
operator|=
name|frame
operator|.
name|condition_handler
expr_stmt|;
name|newfrp
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|newfrp
operator|->
name|save_ap
operator|=
name|frame
operator|.
name|save_ap
expr_stmt|;
name|newfrp
operator|->
name|save_fp
operator|=
name|frame
operator|.
name|save_fp
expr_stmt|;
name|newfrp
operator|->
name|save_pc
operator|=
name|frame
operator|.
name|save_pc
expr_stmt|;
block|}
return|return
name|newfrp
return|;
block|}
end_function

begin_comment
comment|/*  * Return the frame associated with the given function.  * If the function is nil, return the most recently activated frame.  *  * Static allocation for the frame.  */
end_comment

begin_function
name|public
name|Frame
name|findframe
parameter_list|(
name|f
parameter_list|)
name|Symbol
name|f
decl_stmt|;
block|{
specifier|register
name|Frame
name|frp
decl_stmt|;
specifier|static
name|struct
name|Frame
name|frame
decl_stmt|;
name|Symbol
name|p
decl_stmt|;
name|Boolean
name|done
decl_stmt|;
name|frp
operator|=
operator|&
name|frame
expr_stmt|;
name|getcurframe
argument_list|(
name|frp
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|nil
condition|)
block|{
name|done
operator|=
name|false
expr_stmt|;
do|do
block|{
name|p
operator|=
name|whatblock
argument_list|(
name|frp
operator|->
name|save_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|f
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|program
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
name|frp
operator|=
name|nil
expr_stmt|;
block|}
else|else
block|{
name|frp
operator|=
name|nextframe
argument_list|(
name|frp
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|nil
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|not
name|done
condition|)
do|;
block|}
return|return
name|frp
return|;
block|}
end_function

begin_comment
comment|/*  * Find the return address of the current procedure/function.  */
end_comment

begin_function
name|public
name|Address
name|return_addr
parameter_list|()
block|{
name|Frame
name|frp
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|struct
name|Frame
name|frame
decl_stmt|;
name|frp
operator|=
operator|&
name|frame
expr_stmt|;
name|getcurframe
argument_list|(
name|frp
argument_list|)
expr_stmt|;
name|frp
operator|=
name|nextframe
argument_list|(
name|frp
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|nil
condition|)
block|{
name|addr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|frp
operator|->
name|save_pc
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * Push the value associated with the current function.  */
end_comment

begin_function
name|public
name|pushretval
parameter_list|(
name|len
parameter_list|,
name|isindirect
parameter_list|)
name|Integer
name|len
decl_stmt|;
name|Boolean
name|isindirect
decl_stmt|;
block|{
name|Word
name|r0
decl_stmt|;
name|r0
operator|=
name|reg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isindirect
condition|)
block|{
name|rpush
argument_list|(
operator|(
name|Address
operator|)
name|r0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|len
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|char
argument_list|)
case|:
name|push
argument_list|(
name|char
argument_list|,
name|r0
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|short
argument_list|)
case|:
name|push
argument_list|(
name|short
argument_list|,
name|r0
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
condition|)
block|{
name|push
argument_list|(
name|Word
argument_list|,
name|r0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
condition|)
block|{
name|push
argument_list|(
name|Word
argument_list|,
name|r0
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Word
argument_list|,
name|reg
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"not indirect in pushretval?"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return the base address for locals in the given frame.  */
end_comment

begin_function
name|public
name|Address
name|locals_base
parameter_list|(
name|frp
parameter_list|)
specifier|register
name|Frame
name|frp
decl_stmt|;
block|{
return|return
operator|(
name|frp
operator|==
name|nil
operator|)
condition|?
name|reg
argument_list|(
name|FRP
argument_list|)
else|:
name|frp
operator|->
name|save_fp
return|;
block|}
end_function

begin_comment
comment|/*  * Return the base address for arguments in the given frame.  */
end_comment

begin_function
name|public
name|Address
name|args_base
parameter_list|(
name|frp
parameter_list|)
specifier|register
name|Frame
name|frp
decl_stmt|;
block|{
return|return
operator|(
name|frp
operator|==
name|nil
operator|)
condition|?
name|reg
argument_list|(
name|ARGP
argument_list|)
else|:
name|frp
operator|->
name|save_ap
return|;
block|}
end_function

begin_comment
comment|/*  * Return saved register n from the given frame.  */
end_comment

begin_function
name|public
name|Word
name|savereg
parameter_list|(
name|n
parameter_list|,
name|frp
parameter_list|)
specifier|register
name|Integer
name|n
decl_stmt|;
specifier|register
name|Frame
name|frp
decl_stmt|;
block|{
specifier|register
name|Word
name|w
decl_stmt|;
if|if
condition|(
name|frp
operator|==
name|nil
condition|)
block|{
name|w
operator|=
name|reg
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|ARGP
case|:
name|w
operator|=
name|frp
operator|->
name|save_ap
expr_stmt|;
break|break;
case|case
name|FRP
case|:
name|w
operator|=
name|frp
operator|->
name|save_fp
expr_stmt|;
break|break;
case|case
name|STKP
case|:
name|w
operator|=
name|reg
argument_list|(
name|STKP
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROGCTR
case|:
name|w
operator|=
name|frp
operator|->
name|save_pc
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
argument|n>=
literal|0
argument|and n< NSAVEREG
argument_list|)
empty_stmt|;
name|w
operator|=
name|frp
operator|->
name|save_reg
index|[
name|n
index|]
expr_stmt|;
break|break;
block|}
block|}
return|return
name|w
return|;
block|}
end_function

begin_comment
comment|/*  * Return the nth argument to the current procedure.  */
end_comment

begin_function
name|public
name|Word
name|argn
parameter_list|(
name|n
parameter_list|,
name|frp
parameter_list|)
name|Integer
name|n
decl_stmt|;
name|Frame
name|frp
decl_stmt|;
block|{
name|Word
name|w
decl_stmt|;
name|dread
argument_list|(
operator|&
name|w
argument_list|,
name|args_base
argument_list|(
name|frp
argument_list|)
operator|+
operator|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the entry address for a procedure or function parameter,  * given the address of the descriptor.  */
end_comment

begin_function
name|public
name|Address
name|fparamaddr
parameter_list|(
name|a
parameter_list|)
name|Address
name|a
decl_stmt|;
block|{
name|Address
name|r
decl_stmt|;
name|dread
argument_list|(
operator|&
name|r
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Print a list of currently active blocks starting with most recent.  */
end_comment

begin_function
name|public
name|wherecmd
parameter_list|()
block|{
name|walkstack
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump the world to the given file.  * Like "where", but variables are dumped also.  */
end_comment

begin_function
name|public
name|dump
parameter_list|()
block|{
name|walkstack
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Walk the stack of active procedures printing information  * about each active procedure.  */
end_comment

begin_function
name|private
name|walkstack
parameter_list|(
name|dumpvariables
parameter_list|)
name|Boolean
name|dumpvariables
decl_stmt|;
block|{
specifier|register
name|Frame
name|frp
decl_stmt|;
specifier|register
name|Symbol
name|f
decl_stmt|;
specifier|register
name|Boolean
name|save
decl_stmt|;
specifier|register
name|Lineno
name|line
decl_stmt|;
name|struct
name|Frame
name|frame
decl_stmt|;
if|if
condition|(
name|notstarted
argument_list|(
name|process
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"program is not active"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|save
operator|=
name|walkingstack
expr_stmt|;
name|walkingstack
operator|=
name|true
expr_stmt|;
name|frp
operator|=
operator|&
name|frame
expr_stmt|;
name|getcurframe
argument_list|(
name|frp
argument_list|)
expr_stmt|;
name|f
operator|=
name|whatblock
argument_list|(
name|frp
operator|->
name|save_pc
argument_list|)
expr_stmt|;
do|do
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|symname
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|printparams
argument_list|(
name|f
argument_list|,
name|frp
argument_list|)
expr_stmt|;
name|line
operator|=
name|srcline
argument_list|(
name|frp
operator|->
name|save_pc
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|", line %d"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" in \"%s\"\n"
argument_list|,
name|srcfilename
argument_list|(
name|frp
operator|->
name|save_pc
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" at 0x%x\n"
argument_list|,
name|frp
operator|->
name|save_pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dumpvariables
condition|)
block|{
name|dumpvars
argument_list|(
name|f
argument_list|,
name|frp
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|frp
operator|=
name|nextframe
argument_list|(
name|frp
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|!=
name|nil
condition|)
block|{
name|f
operator|=
name|whatblock
argument_list|(
name|frp
operator|->
name|save_pc
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|frp
operator|!=
name|nil
name|and
name|f
operator|!=
name|program
condition|)
do|;
if|if
condition|(
name|dumpvariables
condition|)
block|{
name|printf
argument_list|(
literal|"in \"%s\":\n"
argument_list|,
name|symname
argument_list|(
name|program
argument_list|)
argument_list|)
expr_stmt|;
name|dumpvars
argument_list|(
name|program
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|walkingstack
operator|=
name|save
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find the entry point of a procedure or function.  */
end_comment

begin_function
name|public
name|findbeginning
parameter_list|(
name|f
parameter_list|)
name|Symbol
name|f
decl_stmt|;
block|{
name|f
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|beginaddr
operator|+=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the address corresponding to the first line in a function.  */
end_comment

begin_function
name|public
name|Address
name|firstline
parameter_list|(
name|f
parameter_list|)
name|Symbol
name|f
decl_stmt|;
block|{
name|Address
name|addr
decl_stmt|;
name|addr
operator|=
name|codeloc
argument_list|(
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
name|linelookup
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
name|and
name|addr
operator|<
name|objsize
condition|)
block|{
operator|++
name|addr
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|==
name|objsize
condition|)
block|{
name|addr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * Catcher drops strike three ...  */
end_comment

begin_function
name|public
name|runtofirst
parameter_list|()
block|{
name|Address
name|addr
decl_stmt|;
name|addr
operator|=
name|pc
expr_stmt|;
while|while
condition|(
name|linelookup
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
name|and
name|addr
operator|<
name|objsize
condition|)
block|{
operator|++
name|addr
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|<
name|objsize
condition|)
block|{
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the address corresponding to the end of the program.  *  * We look for the entry to "exit".  */
end_comment

begin_function
name|public
name|Address
name|lastaddr
parameter_list|()
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
name|s
operator|=
name|lookup
argument_list|(
name|identname
argument_list|(
literal|"exit"
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"can't find exit"
argument_list|)
expr_stmt|;
block|}
return|return
name|codeloc
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decide if the given function is currently active.  *  * We avoid calls to "findframe" during a stack trace for efficiency.  * Presumably information evaluated while walking the stack is active.  */
end_comment

begin_function
name|public
name|Boolean
name|isactive
parameter_list|(
name|f
parameter_list|)
name|Symbol
name|f
decl_stmt|;
block|{
specifier|register
name|Boolean
name|b
decl_stmt|;
if|if
condition|(
name|isfinished
argument_list|(
name|process
argument_list|)
condition|)
block|{
name|b
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|walkingstack
name|or
name|f
operator|==
name|program
name|or
argument_list|(
argument|ismodule(f) and isactive(container(f))
argument_list|)
condition|)
block|{
name|b
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
call|(
name|Boolean
call|)
argument_list|(
name|findframe
argument_list|(
name|f
argument_list|)
operator|!=
name|nil
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a call to a procedure.  */
end_comment

begin_function
name|public
name|callproc
parameter_list|(
name|procnode
parameter_list|,
name|arglist
parameter_list|)
name|Node
name|procnode
decl_stmt|;
name|Node
name|arglist
decl_stmt|;
block|{
name|Symbol
name|proc
decl_stmt|;
name|Integer
name|argc
decl_stmt|;
if|if
condition|(
name|procnode
operator|->
name|op
operator|!=
name|O_SYM
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't call \""
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|procnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
name|assert
argument_list|(
name|procnode
operator|->
name|op
operator|==
name|O_SYM
argument_list|)
expr_stmt|;
name|proc
operator|=
name|procnode
operator|->
name|value
operator|.
name|sym
expr_stmt|;
if|if
condition|(
name|not
name|isblock
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not a procedure or function"
argument_list|,
name|symname
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pushenv
argument_list|()
expr_stmt|;
name|pc
operator|=
name|codeloc
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|argc
operator|=
name|pushargs
argument_list|(
name|proc
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|beginproc
argument_list|(
name|proc
argument_list|,
name|argc
argument_list|)
expr_stmt|;
name|isstopped
operator|=
name|true
expr_stmt|;
name|event_once
argument_list|(
name|build
argument_list|(
name|O_EQ
argument_list|,
name|build
argument_list|(
name|O_SYM
argument_list|,
name|pcsym
argument_list|)
argument_list|,
name|build
argument_list|(
name|O_SYM
argument_list|,
name|retaddrsym
argument_list|)
argument_list|)
argument_list|,
name|buildcmdlist
argument_list|(
name|build
argument_list|(
name|O_PROCRTN
argument_list|,
name|proc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cont
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Push the arguments on the process' stack.  We do this by first  * evaluating them on the "eval" stack, then copying into the process'  * space.  */
end_comment

begin_function
name|private
name|Integer
name|pushargs
parameter_list|(
name|proc
parameter_list|,
name|arglist
parameter_list|)
name|Symbol
name|proc
decl_stmt|;
name|Node
name|arglist
decl_stmt|;
block|{
name|Stack
modifier|*
name|savesp
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|args_size
decl_stmt|;
name|savesp
operator|=
name|sp
expr_stmt|;
name|argc
operator|=
name|evalargs
argument_list|(
name|proc
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|args_size
operator|=
name|sp
operator|-
name|savesp
expr_stmt|;
name|setreg
argument_list|(
name|STKP
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
operator|-
name|args_size
argument_list|)
expr_stmt|;
name|dwrite
argument_list|(
name|savesp
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
argument_list|,
name|args_size
argument_list|)
expr_stmt|;
name|sp
operator|=
name|savesp
expr_stmt|;
return|return
name|argc
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate arguments left-to-right.  */
end_comment

begin_function
name|private
name|Integer
name|evalargs
parameter_list|(
name|proc
parameter_list|,
name|arglist
parameter_list|)
name|Symbol
name|proc
decl_stmt|;
name|Node
name|arglist
decl_stmt|;
block|{
name|Node
name|p
decl_stmt|,
name|exp
decl_stmt|;
name|Symbol
name|arg
decl_stmt|;
name|Stack
modifier|*
name|savesp
decl_stmt|;
name|Address
name|addr
decl_stmt|;
name|Integer
name|count
decl_stmt|;
name|savesp
operator|=
name|sp
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|arg
operator|=
name|proc
operator|->
name|chain
expr_stmt|;
for|for
control|(
name|p
operator|=
name|arglist
init|;
name|p
operator|!=
name|nil
condition|;
name|p
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
control|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|O_COMMA
condition|)
block|{
name|panic
argument_list|(
literal|"evalargs: arglist missing comma"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|==
name|nil
condition|)
block|{
name|sp
operator|=
name|savesp
expr_stmt|;
name|error
argument_list|(
literal|"too many parameters to %s"
argument_list|,
name|symname
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exp
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|not
name|compatible
argument_list|(
name|arg
operator|->
name|type
argument_list|,
name|exp
operator|->
name|nodetype
argument_list|)
condition|)
block|{
name|sp
operator|=
name|savesp
expr_stmt|;
name|error
argument_list|(
literal|"expression for parameter %s is of wrong type"
argument_list|,
name|symname
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|->
name|class
operator|==
name|REF
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|op
operator|!=
name|O_RVAL
condition|)
block|{
name|sp
operator|=
name|savesp
expr_stmt|;
name|error
argument_list|(
literal|"variable expected for parameter \"%s\""
argument_list|,
name|symname
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|lval
argument_list|(
name|exp
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Address
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eval
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|arg
operator|->
name|chain
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|!=
name|nil
condition|)
block|{
name|sp
operator|=
name|savesp
expr_stmt|;
name|error
argument_list|(
literal|"not enough parameters to %s"
argument_list|,
name|symname
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
name|public
name|procreturn
parameter_list|(
name|f
parameter_list|)
name|Symbol
name|f
decl_stmt|;
block|{
name|flushoutput
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stdout
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" returns successfully\n"
argument_list|,
name|symname
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|popenv
argument_list|()
expr_stmt|;
name|erecover
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Push the current environment.  */
end_comment

begin_function
name|private
name|pushenv
parameter_list|()
block|{
name|push
argument_list|(
name|Address
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Lineno
argument_list|,
name|curline
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|String
argument_list|,
name|cursource
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Boolean
argument_list|,
name|isstopped
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Symbol
argument_list|,
name|curfunc
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Word
argument_list|,
name|reg
argument_list|(
name|PROGCTR
argument_list|)
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|Word
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pop back to the real world.  */
end_comment

begin_function
name|public
name|popenv
parameter_list|()
block|{
specifier|register
name|String
name|filename
decl_stmt|;
name|setreg
argument_list|(
name|STKP
argument_list|,
name|pop
argument_list|(
name|Word
argument_list|)
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|PROGCTR
argument_list|,
name|pop
argument_list|(
name|Word
argument_list|)
argument_list|)
expr_stmt|;
name|curfunc
operator|=
name|pop
argument_list|(
name|Symbol
argument_list|)
expr_stmt|;
name|isstopped
operator|=
name|pop
argument_list|(
name|Boolean
argument_list|)
expr_stmt|;
name|filename
operator|=
name|pop
argument_list|(
name|String
argument_list|)
expr_stmt|;
name|curline
operator|=
name|pop
argument_list|(
name|Lineno
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pop
argument_list|(
name|Address
argument_list|)
expr_stmt|;
name|setsource
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush the debuggee's standard output.  *  * This is VERY dependent on the use of stdio.  */
end_comment

begin_function
name|public
name|flushoutput
parameter_list|()
block|{
specifier|register
name|Symbol
name|p
decl_stmt|,
name|iob
decl_stmt|;
specifier|register
name|Stack
modifier|*
name|savesp
decl_stmt|;
name|p
operator|=
name|lookup
argument_list|(
name|identname
argument_list|(
literal|"fflush"
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|nil
name|and
name|not
name|isblock
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|next_sym
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|nil
condition|)
block|{
name|iob
operator|=
name|lookup
argument_list|(
name|identname
argument_list|(
literal|"_iob"
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iob
operator|!=
name|nil
condition|)
block|{
name|pushenv
argument_list|()
expr_stmt|;
name|pc
operator|=
name|codeloc
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|savesp
operator|=
name|sp
expr_stmt|;
name|push
argument_list|(
name|long
argument_list|,
name|address
argument_list|(
name|iob
argument_list|,
name|nil
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|_iobuf
argument_list|)
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|STKP
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|dwrite
argument_list|(
name|savesp
argument_list|,
name|reg
argument_list|(
name|STKP
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|savesp
expr_stmt|;
name|beginproc
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stepto
argument_list|(
name|return_addr
argument_list|()
argument_list|)
expr_stmt|;
name|popenv
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

