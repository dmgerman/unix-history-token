begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)machine.c 1.9 8/5/83"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: machine.c,v 1.3 84/03/27 10:21:26 linton Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Target machine dependent stuff.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"events.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"ops.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|Address
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|Byte
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|Word
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NREG
value|16
end_define

begin_define
define|#
directive|define
name|ARGP
value|12
end_define

begin_define
define|#
directive|define
name|FRP
value|13
end_define

begin_define
define|#
directive|define
name|STKP
value|14
end_define

begin_define
define|#
directive|define
name|PROGCTR
value|15
end_define

begin_define
define|#
directive|define
name|BITSPERBYTE
value|8
end_define

begin_define
define|#
directive|define
name|BITSPERWORD
value|(BITSPERBYTE * sizeof(Word))
end_define

begin_define
define|#
directive|define
name|nargspassed
parameter_list|(
name|frame
parameter_list|)
value|argn(0, frame)
end_define

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_decl_stmt
name|Address
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Address
name|prtaddr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|private
name|Address
name|printop
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Decode and print the instructions within the given address range.  */
end_comment

begin_function
name|public
name|printinst
parameter_list|(
name|lowaddr
parameter_list|,
name|highaddr
parameter_list|)
name|Address
name|lowaddr
decl_stmt|;
name|Address
name|highaddr
decl_stmt|;
block|{
specifier|register
name|Address
name|addr
decl_stmt|;
for|for
control|(
name|addr
operator|=
name|lowaddr
init|;
name|addr
operator|<=
name|highaddr
condition|;
control|)
block|{
name|addr
operator|=
name|printop
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
name|prtaddr
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Another approach:  print n instructions starting at the given address.  */
end_comment

begin_function
name|public
name|printninst
parameter_list|(
name|count
parameter_list|,
name|addr
parameter_list|)
name|int
name|count
decl_stmt|;
name|Address
name|addr
decl_stmt|;
block|{
specifier|register
name|Integer
name|i
decl_stmt|;
specifier|register
name|Address
name|newaddr
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"non-positive repetition count"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newaddr
operator|=
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|newaddr
operator|=
name|printop
argument_list|(
name|newaddr
argument_list|)
expr_stmt|;
block|}
name|prtaddr
operator|=
name|newaddr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Hacked version of adb's VAX instruction decoder.  */
end_comment

begin_function
name|private
name|Address
name|printop
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
name|Optab
name|op
decl_stmt|;
name|VaxOpcode
name|ins
decl_stmt|;
name|unsigned
name|char
name|mode
decl_stmt|;
name|int
name|argtype
decl_stmt|,
name|amode
decl_stmt|,
name|argno
decl_stmt|,
name|argval
decl_stmt|;
name|String
name|reg
decl_stmt|;
name|Boolean
name|indexf
decl_stmt|;
name|short
name|offset
decl_stmt|;
name|argval
operator|=
literal|0
expr_stmt|;
name|indexf
operator|=
name|false
expr_stmt|;
name|printf
argument_list|(
literal|"%08x  "
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|iread
argument_list|(
operator|&
name|ins
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
name|op
operator|=
name|optab
index|[
name|ins
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|op
operator|.
name|iname
argument_list|)
expr_stmt|;
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|op
operator|.
name|numargs
condition|;
name|argno
operator|++
control|)
block|{
if|if
condition|(
name|indexf
operator|==
name|true
condition|)
block|{
name|indexf
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argno
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|argtype
operator|=
name|op
operator|.
name|argtype
index|[
name|argno
index|]
expr_stmt|;
if|if
condition|(
name|is_branch_disp
argument_list|(
name|argtype
argument_list|)
condition|)
block|{
name|mode
operator|=
literal|0xAF
operator|+
operator|(
name|typelen
argument_list|(
name|argtype
argument_list|)
operator|<<
literal|5
operator|)
expr_stmt|;
block|}
else|else
block|{
name|iread
argument_list|(
operator|&
name|mode
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
block|}
name|reg
operator|=
name|regname
index|[
name|regnm
argument_list|(
name|mode
argument_list|)
index|]
expr_stmt|;
name|amode
operator|=
name|addrmode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|amode
condition|)
block|{
case|case
name|LITSHORT
case|:
case|case
name|LITUPTO31
case|:
case|case
name|LITUPTO47
case|:
case|case
name|LITUPTO63
case|:
if|if
condition|(
name|typelen
argument_list|(
name|argtype
argument_list|)
operator|==
name|TYPF
operator|||
name|typelen
argument_list|(
name|argtype
argument_list|)
operator|==
name|TYPD
condition|)
name|printf
argument_list|(
literal|"$%s"
argument_list|,
name|fltimm
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"$%x"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|argval
operator|=
name|mode
expr_stmt|;
break|break;
case|case
name|INDEX
case|:
name|printf
argument_list|(
literal|"[%s]"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|indexf
operator|=
name|true
expr_stmt|;
name|argno
operator|--
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGDEF
case|:
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTODEC
case|:
name|printf
argument_list|(
literal|"-(%s)"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTOINC
case|:
if|if
condition|(
name|reg
operator|!=
name|regname
index|[
name|PROGCTR
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"(%s)+"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|typelen
argument_list|(
name|argtype
argument_list|)
condition|)
block|{
case|case
name|TYPB
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|TYPW
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TYPL
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TYPF
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%06x"
argument_list|,
name|argval
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TYPQ
case|:
case|case
name|TYPD
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%06x"
argument_list|,
name|argval
argument_list|)
expr_stmt|;
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
operator|+
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%06x"
argument_list|,
name|argval
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|8
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|AUTOINCDEF
case|:
if|if
condition|(
name|reg
operator|==
name|regname
index|[
name|PROGCTR
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"*$"
argument_list|)
expr_stmt|;
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"*(%s)+"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BYTEDISP
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|BYTEDISPDEF
case|:
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|WORDDISP
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|WORDDISPDEF
case|:
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|LONGDISP
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|LONGDISPDEF
case|:
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ins
operator|==
name|O_CASEB
operator|||
name|ins
operator|==
name|O_CASEW
operator|||
name|ins
operator|==
name|O_CASEL
condition|)
block|{
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<=
name|argval
condition|;
name|argno
operator|++
control|)
block|{
name|iread
argument_list|(
operator|&
name|offset
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t\t%d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * Print the displacement of an instruction that uses displacement  * addressing.  */
end_comment

begin_function
name|private
name|int
name|printdisp
parameter_list|(
name|addr
parameter_list|,
name|nbytes
parameter_list|,
name|reg
parameter_list|,
name|mode
parameter_list|)
name|Address
name|addr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|char
modifier|*
name|reg
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|char
name|byte
decl_stmt|;
name|short
name|hword
decl_stmt|;
name|int
name|argval
decl_stmt|;
name|Symbol
name|f
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|iread
argument_list|(
operator|&
name|byte
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
argument_list|)
expr_stmt|;
name|argval
operator|=
name|byte
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|iread
argument_list|(
operator|&
name|hword
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|hword
argument_list|)
argument_list|)
expr_stmt|;
name|argval
operator|=
name|hword
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reg
operator|==
name|regname
index|[
name|PROGCTR
index|]
operator|&&
name|mode
operator|>=
name|BYTEDISP
condition|)
block|{
name|argval
operator|+=
name|addr
operator|+
name|nbytes
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|==
name|regname
index|[
name|PROGCTR
index|]
condition|)
block|{
name|f
operator|=
name|whatblock
argument_list|(
operator|(
name|Address
operator|)
name|argval
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|codeloc
argument_list|(
name|f
argument_list|)
operator|==
name|argval
operator|+
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|symname
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%x"
argument_list|,
name|argval
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%d(%s)"
argument_list|,
name|argval
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
return|return
name|argval
return|;
block|}
end_function

begin_comment
comment|/*  * Print the contents of the addresses within the given range  * according to the given format.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|String
name|name
decl_stmt|;
name|String
name|printfstring
decl_stmt|;
name|int
name|length
decl_stmt|;
block|}
name|Format
typedef|;
end_typedef

begin_decl_stmt
name|private
name|Format
name|fmt
index|[]
init|=
block|{
block|{
literal|"d"
block|,
literal|" %d"
block|,
expr|sizeof
operator|(
name|short
operator|)
block|}
block|,
block|{
literal|"D"
block|,
literal|" %ld"
block|,
expr|sizeof
operator|(
name|long
operator|)
block|}
block|,
block|{
literal|"o"
block|,
literal|" %o"
block|,
expr|sizeof
operator|(
name|short
operator|)
block|}
block|,
block|{
literal|"O"
block|,
literal|" %lo"
block|,
expr|sizeof
operator|(
name|long
operator|)
block|}
block|,
block|{
literal|"x"
block|,
literal|" %04x"
block|,
expr|sizeof
operator|(
name|short
operator|)
block|}
block|,
block|{
literal|"X"
block|,
literal|" %08x"
block|,
expr|sizeof
operator|(
name|long
operator|)
block|}
block|,
block|{
literal|"b"
block|,
literal|" \\%o"
block|,
expr|sizeof
operator|(
name|char
operator|)
block|}
block|,
block|{
literal|"c"
block|,
literal|" '%c'"
block|,
expr|sizeof
operator|(
name|char
operator|)
block|}
block|,
block|{
literal|"s"
block|,
literal|"%c"
block|,
expr|sizeof
operator|(
name|char
operator|)
block|}
block|,
block|{
literal|"f"
block|,
literal|" %f"
block|,
expr|sizeof
operator|(
name|float
operator|)
block|}
block|,
block|{
literal|"g"
block|,
literal|" %g"
block|,
expr|sizeof
operator|(
name|double
operator|)
block|}
block|,
block|{
name|nil
block|,
name|nil
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|Format
modifier|*
name|findformat
parameter_list|(
name|s
parameter_list|)
name|String
name|s
decl_stmt|;
block|{
specifier|register
name|Format
modifier|*
name|f
decl_stmt|;
name|f
operator|=
operator|&
name|fmt
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|f
operator|->
name|name
operator|!=
name|nil
name|and
name|not
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
name|s
argument_list|)
condition|)
block|{
operator|++
name|f
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|name
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"bad print format \"%s\""
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_function
name|public
name|Address
name|printdata
parameter_list|(
name|lowaddr
parameter_list|,
name|highaddr
parameter_list|,
name|format
parameter_list|)
name|Address
name|lowaddr
decl_stmt|;
name|Address
name|highaddr
decl_stmt|;
name|String
name|format
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|Address
name|addr
decl_stmt|;
specifier|register
name|Format
modifier|*
name|f
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|lowaddr
operator|>
name|highaddr
condition|)
block|{
name|error
argument_list|(
literal|"first address larger than second"
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|findformat
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|lowaddr
init|;
name|addr
operator|<=
name|highaddr
condition|;
name|addr
operator|+=
name|f
operator|->
name|length
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%08x: "
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|dread
argument_list|(
operator|&
name|value
argument_list|,
name|addr
argument_list|,
name|f
operator|->
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|f
operator|->
name|printfstring
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
literal|16
name|div
name|f
operator|->
name|length
operator|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|prtaddr
operator|=
name|addr
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * The other approach is to print n items starting with a given address.  */
end_comment

begin_function
name|public
name|printndata
parameter_list|(
name|count
parameter_list|,
name|startaddr
parameter_list|,
name|format
parameter_list|)
name|int
name|count
decl_stmt|;
name|Address
name|startaddr
decl_stmt|;
name|String
name|format
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|Address
name|addr
decl_stmt|;
specifier|register
name|Format
modifier|*
name|f
decl_stmt|;
specifier|register
name|Boolean
name|isstring
decl_stmt|;
name|char
name|c
decl_stmt|;
union|union
block|{
name|char
name|charv
decl_stmt|;
name|short
name|shortv
decl_stmt|;
name|int
name|intv
decl_stmt|;
name|float
name|floatv
decl_stmt|;
name|double
name|doublev
decl_stmt|;
block|}
name|value
union|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"non-positive repetition count"
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|findformat
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|isstring
operator|=
operator|(
name|Boolean
operator|)
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|startaddr
expr_stmt|;
name|value
operator|.
name|intv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%08x: "
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isstring
condition|)
block|{
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|dread
argument_list|(
operator|&
name|c
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|printchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|++
name|addr
expr_stmt|;
name|dread
argument_list|(
operator|&
name|c
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|String
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dread
argument_list|(
operator|&
name|value
argument_list|,
name|addr
argument_list|,
name|f
operator|->
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|f
operator|->
name|printfstring
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
literal|16
name|div
name|f
operator|->
name|length
operator|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
name|addr
operator|+=
name|f
operator|->
name|length
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|prtaddr
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a value according to the given format.  */
end_comment

begin_function
name|public
name|printvalue
parameter_list|(
name|v
parameter_list|,
name|format
parameter_list|)
name|long
name|v
decl_stmt|;
name|String
name|format
decl_stmt|;
block|{
name|Format
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|f
operator|=
name|findformat
argument_list|(
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
literal|"s"
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|v
expr_stmt|;
name|q
operator|=
name|p
operator|+
sizeof|sizeof
argument_list|(
name|v
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|q
condition|)
block|{
name|printchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|f
operator|->
name|printfstring
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out an execution time error.  * Assumes the source position of the error has been calculated.  *  * Have to check if the -r option was specified; if so then  * the object file information hasn't been read in yet.  */
end_comment

begin_function
name|public
name|printerror
parameter_list|()
block|{
specifier|extern
name|Integer
name|sys_nsig
decl_stmt|;
specifier|extern
name|String
name|sys_siglist
index|[]
decl_stmt|;
name|Integer
name|err
decl_stmt|;
if|if
condition|(
name|isfinished
argument_list|(
name|process
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\"%s\" exits with code %d\n"
argument_list|,
name|objname
argument_list|,
name|exitcode
argument_list|(
name|process
argument_list|)
argument_list|)
expr_stmt|;
name|erecover
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|runfirst
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Entering debugger ..."
argument_list|)
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" type 'help' for help\n"
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|errnum
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|SIGINT
condition|)
block|{
name|printf
argument_list|(
literal|"\n\ninterrupt "
argument_list|)
expr_stmt|;
name|printloc
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|==
name|SIGTRAP
condition|)
block|{
name|printf
argument_list|(
literal|"\nerror "
argument_list|)
expr_stmt|;
name|printloc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|err
operator|<
literal|0
name|or
name|err
operator|>
name|sys_nsig
condition|)
block|{
name|printf
argument_list|(
literal|"\nsignal %d "
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n%s "
argument_list|,
name|sys_siglist
index|[
name|err
index|]
argument_list|)
expr_stmt|;
block|}
name|printloc
argument_list|()
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|curline
operator|>
literal|0
condition|)
block|{
name|printlines
argument_list|(
name|curline
argument_list|,
name|curline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printinst
argument_list|(
name|pc
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
name|erecover
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note the termination of the program.  We do this so as to avoid  * having the process exit, which would make the values of variables  * inaccessible.  We do want to flush all output buffers here,  * otherwise it'll never get done.  */
end_comment

begin_function
name|public
name|endprogram
parameter_list|()
block|{
name|Integer
name|exitcode
decl_stmt|;
name|stepto
argument_list|(
name|nextaddr
argument_list|(
name|pc
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|printnews
argument_list|()
expr_stmt|;
name|exitcode
operator|=
name|argn
argument_list|(
literal|1
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nexecution completed, exit code is %d\n"
argument_list|,
name|exitcode
argument_list|)
expr_stmt|;
name|getsrcpos
argument_list|()
expr_stmt|;
name|erecover
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Single step the machine a source line (or instruction if "inst_tracing"  * is true).  If "isnext" is true, skip over procedure calls.  */
end_comment

begin_function_decl
name|private
name|Address
name|getcall
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|public
name|dostep
parameter_list|(
name|isnext
parameter_list|)
name|Boolean
name|isnext
decl_stmt|;
block|{
specifier|register
name|Address
name|addr
decl_stmt|;
specifier|register
name|Lineno
name|line
decl_stmt|;
name|String
name|filename
decl_stmt|;
name|Address
name|startaddr
decl_stmt|,
name|prevaddr
decl_stmt|;
name|startaddr
operator|=
name|pc
expr_stmt|;
name|prevaddr
operator|=
name|startaddr
expr_stmt|;
name|addr
operator|=
name|nextaddr
argument_list|(
name|pc
argument_list|,
name|isnext
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|inst_tracing
name|and
name|nlhdr
operator|.
name|nlines
operator|!=
literal|0
condition|)
block|{
name|line
operator|=
name|linelookup
argument_list|(
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
operator|==
literal|0
condition|)
block|{
name|prevaddr
operator|=
name|addr
expr_stmt|;
name|addr
operator|=
name|nextaddr
argument_list|(
name|addr
argument_list|,
name|isnext
argument_list|)
expr_stmt|;
name|line
operator|=
name|linelookup
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
name|curline
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
name|curline
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|==
name|startaddr
condition|)
block|{
name|stepto
argument_list|(
name|prevaddr
argument_list|)
expr_stmt|;
block|}
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|filename
operator|=
name|srcfilename
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|setsource
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute the next address that will be executed from the given one.  * If "isnext" is true then consider a procedure call as straight line code.  *  * We must unfortunately do much of the same work that is necessary  * to print instructions.  In addition we have to deal with branches.  * Unconditional branches we just follow, for conditional branches  * we continue execution to the current location and then single step  * the machine.  We assume that the last argument in an instruction  * that branches is the branch address (or relative offset).  */
end_comment

begin_function_decl
name|private
name|Address
name|findnextaddr
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|public
name|Address
name|nextaddr
parameter_list|(
name|startaddr
parameter_list|,
name|isnext
parameter_list|)
name|Address
name|startaddr
decl_stmt|;
name|boolean
name|isnext
decl_stmt|;
block|{
name|Address
name|addr
decl_stmt|;
name|addr
operator|=
name|usignal
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
name|or
name|addr
operator|==
literal|1
condition|)
block|{
name|addr
operator|=
name|findnextaddr
argument_list|(
name|startaddr
argument_list|,
name|isnext
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_function
name|private
name|Address
name|findnextaddr
parameter_list|(
name|startaddr
parameter_list|,
name|isnext
parameter_list|)
name|Address
name|startaddr
decl_stmt|;
name|Boolean
name|isnext
decl_stmt|;
block|{
specifier|register
name|Address
name|addr
decl_stmt|;
name|Optab
name|op
decl_stmt|;
name|VaxOpcode
name|ins
decl_stmt|;
name|unsigned
name|char
name|mode
decl_stmt|;
name|int
name|argtype
decl_stmt|,
name|amode
decl_stmt|,
name|argno
decl_stmt|,
name|argval
decl_stmt|;
name|String
name|r
decl_stmt|;
name|Boolean
name|indexf
decl_stmt|;
enum|enum
block|{
name|KNOWN
block|,
name|SEQUENTIAL
block|,
name|BRANCH
block|}
name|addrstatus
enum|;
name|argval
operator|=
literal|0
expr_stmt|;
name|indexf
operator|=
name|false
expr_stmt|;
name|addr
operator|=
name|startaddr
expr_stmt|;
name|iread
argument_list|(
operator|&
name|ins
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ins
condition|)
block|{
case|case
name|O_BRB
case|:
case|case
name|O_BRW
case|:
name|addrstatus
operator|=
name|BRANCH
expr_stmt|;
break|break;
case|case
name|O_BSBB
case|:
case|case
name|O_BSBW
case|:
case|case
name|O_JSB
case|:
case|case
name|O_CALLG
case|:
case|case
name|O_CALLS
case|:
if|if
condition|(
name|isnext
condition|)
block|{
name|addrstatus
operator|=
name|SEQUENTIAL
expr_stmt|;
block|}
else|else
block|{
name|addrstatus
operator|=
name|KNOWN
expr_stmt|;
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|addr
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
name|pc
operator|=
name|addr
expr_stmt|;
name|setcurfunc
argument_list|(
name|whatblock
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|bpact
argument_list|()
expr_stmt|;
if|if
condition|(
name|nosource
argument_list|(
argument|curfunc
argument_list|)
name|and
name|canskip
argument_list|(
argument|curfunc
argument_list|)
name|and
name|nlhdr
operator|.
name|nlines
operator|!=
literal|0
condition|)
block|{
name|addrstatus
operator|=
name|KNOWN
expr_stmt|;
name|addr
operator|=
name|return_addr
argument_list|()
expr_stmt|;
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|bpact
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|callnews
argument_list|(
comment|/* iscall = */
name|true
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|O_RSB
case|:
case|case
name|O_RET
case|:
name|addrstatus
operator|=
name|KNOWN
expr_stmt|;
name|callnews
argument_list|(
comment|/* iscall = */
name|false
argument_list|)
expr_stmt|;
name|addr
operator|=
name|return_addr
argument_list|()
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|pc
condition|)
block|{
comment|/* recursive ret to self */
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
name|bpact
argument_list|()
expr_stmt|;
break|break;
case|case
name|O_JMP
case|:
comment|/* because it may be jmp (r1) */
case|case
name|O_BNEQ
case|:
case|case
name|O_BEQL
case|:
case|case
name|O_BGTR
case|:
case|case
name|O_BLEQ
case|:
case|case
name|O_BGEQ
case|:
case|case
name|O_BLSS
case|:
case|case
name|O_BGTRU
case|:
case|case
name|O_BLEQU
case|:
case|case
name|O_BVC
case|:
case|case
name|O_BVS
case|:
case|case
name|O_BCC
case|:
case|case
name|O_BCS
case|:
case|case
name|O_CASEB
case|:
case|case
name|O_CASEW
case|:
case|case
name|O_CASEL
case|:
case|case
name|O_BBS
case|:
case|case
name|O_BBC
case|:
case|case
name|O_BBSS
case|:
case|case
name|O_BBCS
case|:
case|case
name|O_BBSC
case|:
case|case
name|O_BBCC
case|:
case|case
name|O_BBSSI
case|:
case|case
name|O_BBCCI
case|:
case|case
name|O_BLBS
case|:
case|case
name|O_BLBC
case|:
case|case
name|O_ACBL
case|:
case|case
name|O_AOBLSS
case|:
case|case
name|O_AOBLEQ
case|:
case|case
name|O_SOBGEQ
case|:
case|case
name|O_SOBGTR
case|:
name|addrstatus
operator|=
name|KNOWN
expr_stmt|;
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|addr
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
name|pc
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|addrstatus
operator|=
name|SEQUENTIAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addrstatus
operator|!=
name|KNOWN
condition|)
block|{
name|addr
operator|+=
literal|1
expr_stmt|;
name|op
operator|=
name|optab
index|[
name|ins
index|]
expr_stmt|;
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|op
operator|.
name|numargs
condition|;
name|argno
operator|++
control|)
block|{
if|if
condition|(
name|indexf
operator|==
name|true
condition|)
block|{
name|indexf
operator|=
name|false
expr_stmt|;
block|}
name|argtype
operator|=
name|op
operator|.
name|argtype
index|[
name|argno
index|]
expr_stmt|;
if|if
condition|(
name|is_branch_disp
argument_list|(
name|argtype
argument_list|)
condition|)
block|{
name|mode
operator|=
literal|0xAF
operator|+
operator|(
name|typelen
argument_list|(
name|argtype
argument_list|)
operator|<<
literal|5
operator|)
expr_stmt|;
block|}
else|else
block|{
name|iread
argument_list|(
operator|&
name|mode
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
block|}
name|r
operator|=
name|regname
index|[
name|regnm
argument_list|(
name|mode
argument_list|)
index|]
expr_stmt|;
name|amode
operator|=
name|addrmode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|amode
condition|)
block|{
case|case
name|LITSHORT
case|:
case|case
name|LITUPTO31
case|:
case|case
name|LITUPTO47
case|:
case|case
name|LITUPTO63
case|:
name|argval
operator|=
name|mode
expr_stmt|;
break|break;
case|case
name|INDEX
case|:
name|indexf
operator|=
name|true
expr_stmt|;
operator|--
name|argno
expr_stmt|;
break|break;
case|case
name|REG
case|:
case|case
name|REGDEF
case|:
case|case
name|AUTODEC
case|:
break|break;
case|case
name|AUTOINC
case|:
if|if
condition|(
name|r
operator|==
name|regname
index|[
name|PROGCTR
index|]
condition|)
block|{
switch|switch
condition|(
name|typelen
argument_list|(
name|argtype
argument_list|)
condition|)
block|{
case|case
name|TYPB
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|TYPW
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TYPL
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TYPF
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TYPQ
case|:
case|case
name|TYPD
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
operator|+
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|8
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|AUTOINCDEF
case|:
if|if
condition|(
name|r
operator|==
name|regname
index|[
name|PROGCTR
index|]
condition|)
block|{
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|BYTEDISP
case|:
case|case
name|BYTEDISPDEF
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|WORDDISP
case|:
case|case
name|WORDDISPDEF
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|LONGDISP
case|:
case|case
name|LONGDISPDEF
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ins
operator|==
name|O_CALLS
name|or
name|ins
operator|==
name|O_CALLG
condition|)
block|{
name|argval
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|addrstatus
operator|==
name|BRANCH
condition|)
block|{
name|addr
operator|=
name|argval
expr_stmt|;
block|}
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * Get the displacement of an instruction that uses displacement addressing.  */
end_comment

begin_function
name|private
name|int
name|getdisp
parameter_list|(
name|addr
parameter_list|,
name|nbytes
parameter_list|,
name|reg
parameter_list|,
name|mode
parameter_list|)
name|Address
name|addr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|String
name|reg
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|char
name|byte
decl_stmt|;
name|short
name|hword
decl_stmt|;
name|int
name|argval
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|iread
argument_list|(
operator|&
name|byte
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
argument_list|)
expr_stmt|;
name|argval
operator|=
name|byte
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|iread
argument_list|(
operator|&
name|hword
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|hword
argument_list|)
argument_list|)
expr_stmt|;
name|argval
operator|=
name|hword
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reg
operator|==
name|regname
index|[
name|PROGCTR
index|]
operator|&&
name|mode
operator|>=
name|BYTEDISP
condition|)
block|{
name|argval
operator|+=
name|addr
operator|+
name|nbytes
expr_stmt|;
block|}
return|return
name|argval
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BP_OP
value|O_BPT
end_define

begin_comment
comment|/* breakpoint trap */
end_comment

begin_define
define|#
directive|define
name|BP_ERRNO
value|SIGTRAP
end_define

begin_comment
comment|/* signal received at a breakpoint */
end_comment

begin_comment
comment|/*  * Setting a breakpoint at a location consists of saving  * the word at the location and poking a BP_OP there.  *  * We save the locations and words on a list for use in unsetting.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|Savelist
modifier|*
name|Savelist
typedef|;
end_typedef

begin_struct
struct|struct
name|Savelist
block|{
name|Address
name|location
decl_stmt|;
name|Byte
name|save
decl_stmt|;
name|Byte
name|refcount
decl_stmt|;
name|Savelist
name|link
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|Savelist
name|savelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set a breakpoint at the given address.  Only save the word there  * if it's not already a breakpoint.  */
end_comment

begin_function
name|public
name|setbp
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
name|Byte
name|w
decl_stmt|;
name|Byte
name|save
decl_stmt|;
specifier|register
name|Savelist
name|newsave
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|savelist
init|;
name|s
operator|!=
name|nil
condition|;
name|s
operator|=
name|s
operator|->
name|link
control|)
block|{
if|if
condition|(
name|s
operator|->
name|location
operator|==
name|addr
condition|)
block|{
name|s
operator|->
name|refcount
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|iread
argument_list|(
operator|&
name|save
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|newsave
operator|=
name|new
argument_list|(
name|Savelist
argument_list|)
expr_stmt|;
name|newsave
operator|->
name|location
operator|=
name|addr
expr_stmt|;
name|newsave
operator|->
name|save
operator|=
name|save
expr_stmt|;
name|newsave
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|newsave
operator|->
name|link
operator|=
name|savelist
expr_stmt|;
name|savelist
operator|=
name|newsave
expr_stmt|;
name|w
operator|=
name|BP_OP
expr_stmt|;
name|iwrite
argument_list|(
operator|&
name|w
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unset a breakpoint; unfortunately we have to search the SAVELIST  * to find the saved value.  The assumption is that the SAVELIST will  * usually be quite small.  */
end_comment

begin_function
name|public
name|unsetbp
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
specifier|register
name|Savelist
name|s
decl_stmt|,
name|prev
decl_stmt|;
name|prev
operator|=
name|nil
expr_stmt|;
for|for
control|(
name|s
operator|=
name|savelist
init|;
name|s
operator|!=
name|nil
condition|;
name|s
operator|=
name|s
operator|->
name|link
control|)
block|{
if|if
condition|(
name|s
operator|->
name|location
operator|==
name|addr
condition|)
block|{
name|iwrite
argument_list|(
operator|&
name|s
operator|->
name|save
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|==
name|nil
condition|)
block|{
name|savelist
operator|=
name|s
operator|->
name|link
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|link
operator|=
name|s
operator|->
name|link
expr_stmt|;
block|}
name|dispose
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|prev
operator|=
name|s
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"unsetbp: couldn't find address %d"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Predicate to test if the reason the process stopped was because  * of a breakpoint.  */
end_comment

begin_function
name|public
name|Boolean
name|isbperr
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
operator|(
name|not
name|isfinished
argument_list|(
argument|process
argument_list|)
name|and
name|errnum
argument_list|(
name|process
argument_list|)
operator|==
name|SIGTRAP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enter a procedure by creating and executing a call instruction.  */
end_comment

begin_define
define|#
directive|define
name|CALLSIZE
value|7
end_define

begin_comment
comment|/* size of call instruction */
end_comment

begin_function
name|public
name|beginproc
parameter_list|(
name|p
parameter_list|,
name|argc
parameter_list|)
name|Symbol
name|p
decl_stmt|;
name|Integer
name|argc
decl_stmt|;
block|{
name|char
name|save
index|[
name|CALLSIZE
index|]
decl_stmt|;
struct|struct
block|{
name|VaxOpcode
name|op
decl_stmt|;
name|unsigned
name|char
name|numargs
decl_stmt|;
name|unsigned
name|char
name|mode
decl_stmt|;
name|char
name|addr
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
comment|/* unaligned long */
block|}
name|call
struct|;
name|long
name|dest
decl_stmt|;
name|pc
operator|=
literal|2
expr_stmt|;
name|iread
argument_list|(
name|save
argument_list|,
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|call
operator|.
name|op
operator|=
name|O_CALLS
expr_stmt|;
name|call
operator|.
name|numargs
operator|=
name|argc
expr_stmt|;
name|call
operator|.
name|mode
operator|=
literal|0xef
expr_stmt|;
name|dest
operator|=
name|codeloc
argument_list|(
name|p
argument_list|)
operator|-
literal|2
operator|-
operator|(
name|pc
operator|+
literal|7
operator|)
expr_stmt|;
name|mov
argument_list|(
operator|&
name|dest
argument_list|,
name|call
operator|.
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|call
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|iwrite
argument_list|(
operator|&
name|call
argument_list|,
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|call
argument_list|)
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|PROGCTR
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|iwrite
argument_list|(
name|save
argument_list|,
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

