begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)tahoe.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * Target machine dependent stuff.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"events.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"keywords.h"
end_include

begin_include
include|#
directive|include
file|"ops.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|Address
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|Byte
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|Word
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NREG
value|16
end_define

begin_define
define|#
directive|define
name|FRP
value|13
end_define

begin_define
define|#
directive|define
name|STKP
value|14
end_define

begin_define
define|#
directive|define
name|PROGCTR
value|15
end_define

begin_define
define|#
directive|define
name|BITSPERBYTE
value|8
end_define

begin_define
define|#
directive|define
name|BITSPERWORD
value|(BITSPERBYTE * sizeof(Word))
end_define

begin_define
define|#
directive|define
name|nargspassed
parameter_list|(
name|frame
parameter_list|)
value|((frame->removed-4)/4)
end_define

begin_comment
comment|/*  * Extract a field's value from the integer i.  The value  * is placed in i in such as way as the first bit of the  * field is contained in the first byte of the integer.  */
end_comment

begin_define
define|#
directive|define
name|extractfield
parameter_list|(
name|i
parameter_list|,
name|s
parameter_list|)
define|\
value|((i>> BITSPERWORD - ((s)->symvalue.field.offset mod BITSPERBYTE + \ 		(s)->symvalue.field.length))& \ 	 ((1<< (s)->symvalue.field.length) - 1))
end_define

begin_comment
comment|/*  * Rearrange the stack so that the top of stack has  * something corresponding to newsize, whereas before it had  * something corresponding to oldsize.  If we are expanding  * then the stack is padded at the front of the data with nulls.  * If we are contracting, the appropriate amount is shaved off the  * front by copying up the stack.  */
end_comment

begin_define
define|#
directive|define
name|typerename
parameter_list|(
name|oldsize
parameter_list|,
name|newsize
parameter_list|)
value|{ \ 	int osize = oldsize; \ 	Stack *osp; \ \ 	len = newsize - osize; \ 	osp = sp - osize; \ 	if (len> 0) { \ 		mov(osp, osp+len, osize);
comment|/* copy old up and pad */
value|\ 		bzero(osp, len); \ 	} else if (len< 0) \ 		mov(osp-len, osp, osize+len);
comment|/* copy new size down */
value|\ 	sp += len; \ }
end_define

begin_define
define|#
directive|define
name|SYSBASE
value|0xc0000000
end_define

begin_comment
comment|/* base of system address space */
end_comment

begin_define
define|#
directive|define
name|physaddr
parameter_list|(
name|a
parameter_list|)
value|((a)&~ 0xc0000000)
end_define

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_decl_stmt
name|Address
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Address
name|prtaddr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Indices into u. for use in collecting registers values.  */
end_comment

begin_decl_stmt
name|public
name|int
name|rloc
index|[]
init|=
block|{
name|R0
block|,
name|R1
block|,
name|R2
block|,
name|R3
block|,
name|R4
block|,
name|R5
block|,
name|R6
block|,
name|R7
block|,
name|R8
block|,
name|R9
block|,
name|R10
block|,
name|R11
block|,
name|R12
block|,
name|FP
block|,
name|SP
block|,
name|PC
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|private
name|Address
name|printop
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|Optab
modifier|*
name|ioptab
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index by opcode to optab */
end_comment

begin_comment
comment|/*  * Initialize the opcode lookup table.  */
end_comment

begin_function
name|public
name|optab_init
parameter_list|()
block|{
specifier|register
name|Optab
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|optab
init|;
name|p
operator|->
name|iname
condition|;
name|p
operator|++
control|)
name|ioptab
index|[
name|p
operator|->
name|val
operator|&
literal|0xff
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode and print the instructions within the given address range.  */
end_comment

begin_function
name|public
name|printinst
parameter_list|(
name|lowaddr
parameter_list|,
name|highaddr
parameter_list|)
name|Address
name|lowaddr
decl_stmt|,
name|highaddr
decl_stmt|;
block|{
specifier|register
name|Address
name|addr
decl_stmt|;
for|for
control|(
name|addr
operator|=
name|lowaddr
init|;
name|addr
operator|<=
name|highaddr
condition|;
control|)
name|addr
operator|=
name|printop
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|prtaddr
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Another approach:  print n instructions starting at the given address.  */
end_comment

begin_function
name|public
name|printninst
parameter_list|(
name|count
parameter_list|,
name|addr
parameter_list|)
name|int
name|count
decl_stmt|;
name|Address
name|addr
decl_stmt|;
block|{
specifier|register
name|Integer
name|i
decl_stmt|;
specifier|register
name|Address
name|newaddr
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"non-positive repetition count"
argument_list|)
expr_stmt|;
for|for
control|(
name|newaddr
operator|=
name|addr
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|newaddr
operator|=
name|printop
argument_list|(
name|newaddr
argument_list|)
expr_stmt|;
name|prtaddr
operator|=
name|newaddr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hacked version of adb's instruction decoder.  */
end_comment

begin_function
name|private
name|Address
name|printop
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
specifier|register
name|Optab
modifier|*
name|op
decl_stmt|;
name|Opcode
name|ins
decl_stmt|;
name|unsigned
name|char
name|mode
decl_stmt|;
name|int
name|argtype
decl_stmt|,
name|amode
decl_stmt|,
name|argno
decl_stmt|,
name|argval
decl_stmt|,
name|r
decl_stmt|;
name|String
name|reg
decl_stmt|;
name|Boolean
name|indexf
decl_stmt|;
name|short
name|offset
decl_stmt|;
name|argval
operator|=
literal|0
expr_stmt|;
name|indexf
operator|=
name|false
expr_stmt|;
name|printf
argument_list|(
literal|"%08x  "
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|iread
argument_list|(
operator|&
name|ins
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
name|op
operator|=
name|ioptab
index|[
name|ins
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|op
operator|->
name|iname
argument_list|)
expr_stmt|;
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|op
operator|->
name|numargs
condition|;
name|argno
operator|++
control|)
block|{
if|if
condition|(
name|indexf
operator|==
name|true
condition|)
name|indexf
operator|=
name|false
expr_stmt|;
else|else
name|printf
argument_list|(
name|argno
operator|==
literal|0
condition|?
literal|"\t"
else|:
literal|","
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|op
operator|->
name|argtype
index|[
name|argno
index|]
expr_stmt|;
if|if
condition|(
name|is_branch_disp
argument_list|(
name|argtype
argument_list|)
condition|)
name|mode
operator|=
literal|0xAF
operator|+
operator|(
name|typelen
argument_list|(
name|argtype
argument_list|)
operator|<<
literal|5
operator|)
expr_stmt|;
else|else
name|iread
argument_list|(
operator|&
name|mode
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|,
name|addr
operator|+=
literal|1
expr_stmt|;
name|reg
operator|=
name|regname
index|[
name|regnm
argument_list|(
name|mode
argument_list|)
index|]
expr_stmt|;
name|amode
operator|=
name|addrmode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|amode
condition|)
block|{
case|case
name|LITSHORT
case|:
case|case
name|LITUPTO31
case|:
case|case
name|LITUPTO47
case|:
case|case
name|LITUPTO63
case|:
if|if
condition|(
name|ins
operator|==
name|O_KCALL
operator|&&
name|mode
operator|>=
literal|0
operator|&&
name|mode
operator|<
name|SYSSIZE
operator|&&
name|systab
index|[
name|mode
index|]
condition|)
name|printf
argument_list|(
literal|"$%s"
argument_list|,
name|systab
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"$%x"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|argval
operator|=
name|mode
expr_stmt|;
break|break;
case|case
name|INDEX
case|:
name|printf
argument_list|(
literal|"[%s]"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|indexf
operator|=
name|true
expr_stmt|;
name|argno
operator|--
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGDEF
case|:
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTODEC
case|:
name|printf
argument_list|(
literal|"-(%s)"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTOINC
case|:
name|r
operator|=
name|mode
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0xf
operator|||
name|r
operator|==
literal|8
operator|||
name|r
operator|==
literal|9
condition|)
block|{
name|int
name|size
init|=
operator|(
name|mode
operator|&
literal|03
operator|)
operator|+
literal|1
decl_stmt|;
comment|/* immediate mode */
name|printf
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
name|regname
index|[
name|PROGCTR
index|]
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|size
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"(%s)+"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTOINCDEF
case|:
if|if
condition|(
operator|(
name|mode
operator|&
literal|0xf
operator|)
operator|==
literal|0xf
condition|)
block|{
name|printf
argument_list|(
literal|"*$"
argument_list|)
expr_stmt|;
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"*(%s)+"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYTEDISP
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|BYTEDISPDEF
case|:
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|WORDDISP
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|WORDDISPDEF
case|:
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|LONGDISP
case|:
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|LONGDISPDEF
case|:
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|argval
operator|=
name|printdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ins
operator|==
name|O_CASEL
condition|)
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<=
name|argval
condition|;
name|argno
operator|++
control|)
block|{
name|iread
argument_list|(
operator|&
name|offset
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t\t%d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print the displacement of an instruction that uses displacement  * addressing.  */
end_comment

begin_function
name|private
name|int
name|printdisp
parameter_list|(
name|addr
parameter_list|,
name|nbytes
parameter_list|,
name|reg
parameter_list|,
name|mode
parameter_list|)
name|Address
name|addr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|char
modifier|*
name|reg
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|char
name|byte
decl_stmt|;
name|short
name|hword
decl_stmt|;
name|int
name|argval
decl_stmt|;
name|Symbol
name|f
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|iread
argument_list|(
operator|&
name|byte
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
argument_list|)
expr_stmt|;
name|argval
operator|=
name|byte
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|iread
argument_list|(
operator|&
name|hword
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|hword
argument_list|)
argument_list|)
expr_stmt|;
name|argval
operator|=
name|hword
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reg
operator|==
name|regname
index|[
name|PROGCTR
index|]
operator|&&
name|mode
operator|>=
name|BYTEDISP
condition|)
name|argval
operator|+=
name|addr
operator|+
name|nbytes
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|regname
index|[
name|PROGCTR
index|]
condition|)
block|{
name|f
operator|=
name|whatblock
argument_list|(
operator|(
name|Address
operator|)
name|argval
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|codeloc
argument_list|(
name|f
argument_list|)
operator|==
name|argval
operator|+
literal|2
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|symname
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%x"
argument_list|,
name|argval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|varIsSet
argument_list|(
literal|"$hexoffsets"
argument_list|)
condition|)
block|{
if|if
condition|(
name|argval
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"-%x(%s)"
argument_list|,
operator|-
operator|(
name|argval
operator|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%x(%s)"
argument_list|,
name|argval
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%d(%s)"
argument_list|,
name|argval
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|argval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print the contents of the addresses within the given range  * according to the given format.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|String
name|name
decl_stmt|;
name|String
name|printfstring
decl_stmt|;
name|int
name|length
decl_stmt|;
block|}
name|Format
typedef|;
end_typedef

begin_decl_stmt
name|private
name|Format
name|fmt
index|[]
init|=
block|{
block|{
literal|"d"
block|,
literal|" %d"
block|,
expr|sizeof
operator|(
name|short
operator|)
block|}
block|,
block|{
literal|"D"
block|,
literal|" %ld"
block|,
expr|sizeof
operator|(
name|long
operator|)
block|}
block|,
block|{
literal|"o"
block|,
literal|" %o"
block|,
expr|sizeof
operator|(
name|short
operator|)
block|}
block|,
block|{
literal|"O"
block|,
literal|" %lo"
block|,
expr|sizeof
operator|(
name|long
operator|)
block|}
block|,
block|{
literal|"x"
block|,
literal|" %04x"
block|,
expr|sizeof
operator|(
name|short
operator|)
block|}
block|,
block|{
literal|"X"
block|,
literal|" %08x"
block|,
expr|sizeof
operator|(
name|long
operator|)
block|}
block|,
block|{
literal|"b"
block|,
literal|" \\%o"
block|,
expr|sizeof
operator|(
name|char
operator|)
block|}
block|,
block|{
literal|"c"
block|,
literal|" '%c'"
block|,
expr|sizeof
operator|(
name|char
operator|)
block|}
block|,
block|{
literal|"s"
block|,
literal|"%c"
block|,
expr|sizeof
operator|(
name|char
operator|)
block|}
block|,
block|{
literal|"f"
block|,
literal|" %f"
block|,
expr|sizeof
operator|(
name|float
operator|)
block|}
block|,
block|{
literal|"g"
block|,
literal|" %g"
block|,
expr|sizeof
operator|(
name|double
operator|)
block|}
block|,
block|{
name|nil
block|,
name|nil
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|Format
modifier|*
name|findformat
parameter_list|(
name|s
parameter_list|)
name|String
name|s
decl_stmt|;
block|{
specifier|register
name|Format
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
operator|&
name|fmt
index|[
literal|0
index|]
init|;
name|f
operator|->
name|name
operator|!=
name|nil
operator|&&
operator|!
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
name|s
argument_list|)
condition|;
name|f
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|f
operator|->
name|name
operator|==
name|nil
condition|)
name|error
argument_list|(
literal|"bad print format \"%s\""
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_function
name|public
name|Address
name|printdata
parameter_list|(
name|lowaddr
parameter_list|,
name|highaddr
parameter_list|,
name|format
parameter_list|)
name|Address
name|lowaddr
decl_stmt|;
name|Address
name|highaddr
decl_stmt|;
name|String
name|format
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|Address
name|addr
decl_stmt|;
specifier|register
name|Format
modifier|*
name|f
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|lowaddr
operator|>
name|highaddr
condition|)
name|error
argument_list|(
literal|"first address larger than second"
argument_list|)
expr_stmt|;
name|f
operator|=
name|findformat
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|lowaddr
init|;
name|addr
operator|<=
name|highaddr
condition|;
name|addr
operator|+=
name|f
operator|->
name|length
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%08x: "
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|dread
argument_list|(
operator|&
name|value
argument_list|,
name|addr
argument_list|,
name|f
operator|->
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|f
operator|->
name|printfstring
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
literal|16
name|div
name|f
operator|->
name|length
operator|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|prtaddr
operator|=
name|addr
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The other approach is to print n items starting with a given address.  */
end_comment

begin_function
name|public
name|printndata
parameter_list|(
name|count
parameter_list|,
name|startaddr
parameter_list|,
name|format
parameter_list|)
name|int
name|count
decl_stmt|;
name|Address
name|startaddr
decl_stmt|;
name|String
name|format
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|Address
name|addr
decl_stmt|;
specifier|register
name|Format
modifier|*
name|f
decl_stmt|;
specifier|register
name|Boolean
name|isstring
decl_stmt|;
name|char
name|c
decl_stmt|;
union|union
block|{
name|char
name|charv
decl_stmt|;
name|short
name|shortv
decl_stmt|;
name|int
name|intv
decl_stmt|;
name|float
name|floatv
decl_stmt|;
name|double
name|doublev
decl_stmt|;
block|}
name|value
union|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"non-positive repetition count"
argument_list|)
expr_stmt|;
name|f
operator|=
name|findformat
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|isstring
operator|=
operator|(
name|Boolean
operator|)
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|startaddr
expr_stmt|;
name|value
operator|.
name|intv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%08x: "
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|isstring
condition|)
block|{
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|dread
argument_list|(
operator|&
name|c
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|printchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|++
name|addr
expr_stmt|;
name|dread
argument_list|(
operator|&
name|c
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|String
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dread
argument_list|(
operator|&
name|value
argument_list|,
name|addr
argument_list|,
name|f
operator|->
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|f
operator|->
name|printfstring
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
literal|16
name|div
name|f
operator|->
name|length
operator|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
name|addr
operator|+=
name|f
operator|->
name|length
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|prtaddr
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a value according to the given format.  */
end_comment

begin_function
name|public
name|printvalue
parameter_list|(
name|v
parameter_list|,
name|format
parameter_list|)
name|long
name|v
decl_stmt|;
name|String
name|format
decl_stmt|;
block|{
name|Format
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|f
operator|=
name|findformat
argument_list|(
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|f
operator|->
name|name
argument_list|,
literal|"s"
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|v
operator|,
name|q
operator|=
name|p
operator|+
sizeof|sizeof
argument_list|(
name|v
argument_list|)
init|;
name|p
operator|<
name|q
condition|;
operator|++
name|p
control|)
name|printchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
name|f
operator|->
name|printfstring
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out an execution time error.  * Assumes the source position of the error has been calculated.  *  * Have to check if the -r option was specified; if so then  * the object file information hasn't been read in yet.  */
end_comment

begin_function
name|public
name|printerror
parameter_list|()
block|{
specifier|extern
name|Integer
name|sys_nsig
decl_stmt|;
specifier|extern
name|String
name|sys_siglist
index|[]
decl_stmt|;
name|integer
name|err
decl_stmt|;
if|if
condition|(
name|isfinished
argument_list|(
name|process
argument_list|)
condition|)
block|{
name|err
operator|=
name|exitcode
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"\"%s\" terminated abnormally (exit code %d)\n"
argument_list|,
name|objname
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|erecover
argument_list|()
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\"%s\" terminated normally\n"
argument_list|,
name|objname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|runfirst
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Entering debugger ...\n"
argument_list|)
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
block|}
name|err
operator|=
name|errnum
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printsig
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printloc
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|curline
operator|>
literal|0
condition|)
name|printlines
argument_list|(
name|curline
argument_list|,
name|curline
argument_list|)
expr_stmt|;
else|else
name|printinst
argument_list|(
name|pc
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|erecover
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a signal.  */
end_comment

begin_decl_stmt
name|private
name|String
name|illinames
index|[]
init|=
block|{
literal|"reserved addressing fault"
block|,
literal|"priviliged instruction fault"
block|,
literal|"reserved operand fault"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NILLINAMES
value|(sizeof (illinames) / sizeof (illinames[0]))
end_define

begin_decl_stmt
name|private
name|String
name|fpenames
index|[]
init|=
block|{
name|nil
block|,
literal|"integer overflow trap"
block|,
literal|"integer divide by zero trap"
block|,
literal|"floating point divide by zero trap"
block|,
literal|"floating point overflow trap"
block|,
literal|"floating point underflow trap"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NFPENAMES
value|(sizeof (fpenames) / sizeof (fpenames[0]))
end_define

begin_function
name|public
name|printsig
parameter_list|(
name|signo
parameter_list|)
name|integer
name|signo
decl_stmt|;
block|{
name|integer
name|code
decl_stmt|;
if|if
condition|(
name|signo
operator|<
literal|0
name|or
name|signo
operator|>
name|sys_nsig
condition|)
name|printf
argument_list|(
literal|"[signal %d]"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sys_siglist
index|[
name|signo
index|]
argument_list|)
expr_stmt|;
name|code
operator|=
name|errcode
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|signo
operator|==
name|SIGILL
condition|)
if|if
condition|(
name|code
operator|>=
literal|0
operator|&&
name|code
operator|<
name|NILLINAMES
condition|)
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|illinames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|signo
operator|==
name|SIGFPE
condition|)
if|if
condition|(
name|code
operator|>
literal|0
name|and
name|code
operator|<
name|NFPENAMES
condition|)
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|fpenames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note the termination of the program.  We do this so as to avoid  * having the process exit, which would make the values of variables  * inaccessible.  We do want to flush all output buffers here,  * otherwise it'll never get done.  */
end_comment

begin_function
name|public
name|endprogram
parameter_list|()
block|{
name|Integer
name|exitcode
decl_stmt|;
name|stepto
argument_list|(
name|nextaddr
argument_list|(
name|pc
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|printnews
argument_list|()
expr_stmt|;
name|exitcode
operator|=
name|argn
argument_list|(
literal|1
argument_list|,
name|nil
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitcode
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"\nexecution completed (exit code %d)\n"
argument_list|,
name|exitcode
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\nexecution completed\n"
argument_list|)
expr_stmt|;
name|getsrcpos
argument_list|()
expr_stmt|;
name|erecover
argument_list|()
expr_stmt|;
block|}
end_function

begin_function_decl
name|private
name|Address
name|getcall
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Single step the machine a source line (or instruction if "inst_tracing"  * is true).  If "isnext" is true, skip over procedure calls.  */
end_comment

begin_function
name|public
name|dostep
parameter_list|(
name|isnext
parameter_list|)
name|Boolean
name|isnext
decl_stmt|;
block|{
specifier|register
name|Address
name|addr
decl_stmt|;
specifier|register
name|Lineno
name|line
decl_stmt|;
name|String
name|filename
decl_stmt|;
name|Address
name|startaddr
decl_stmt|;
name|startaddr
operator|=
name|pc
expr_stmt|;
name|addr
operator|=
name|nextaddr
argument_list|(
name|pc
argument_list|,
name|isnext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inst_tracing
operator|&&
name|nlhdr
operator|.
name|nlines
operator|!=
literal|0
condition|)
block|{
name|line
operator|=
name|linelookup
argument_list|(
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|line
operator|==
literal|0
condition|;
name|line
operator|=
name|linelookup
argument_list|(
name|addr
argument_list|)
control|)
name|addr
operator|=
name|nextaddr
argument_list|(
name|addr
argument_list|,
name|isnext
argument_list|)
expr_stmt|;
name|curline
operator|=
name|line
expr_stmt|;
block|}
else|else
name|curline
operator|=
literal|0
expr_stmt|;
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|filename
operator|=
name|srcfilename
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|setsource
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|private
name|Address
name|findnextaddr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Compute the next address that will be executed from the given one.  * If "isnext" is true then consider a procedure call as straight line code.  *  * We must unfortunately do much of the same work that is necessary  * to print instructions.  In addition we have to deal with branches.  * Unconditional branches we just follow, for conditional branches  * we continue execution to the current location and then single step  * the machine.  We assume that the last argument in an instruction  * that branches is the branch address (or relative offset).  */
end_comment

begin_function
name|public
name|Address
name|nextaddr
parameter_list|(
name|startaddr
parameter_list|,
name|isnext
parameter_list|)
name|Address
name|startaddr
decl_stmt|;
name|boolean
name|isnext
decl_stmt|;
block|{
name|Address
name|addr
decl_stmt|;
name|addr
operator|=
name|usignal
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
name|or
name|addr
operator|==
literal|1
condition|)
name|addr
operator|=
name|findnextaddr
argument_list|(
name|startaddr
argument_list|,
name|isnext
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if it's ok to skip function f entered by instruction ins.  * If so, we're going to compute the return address and step to it.  */
end_comment

begin_function
name|private
name|boolean
name|skipfunc
parameter_list|(
name|ins
parameter_list|,
name|f
parameter_list|)
name|Opcode
name|ins
decl_stmt|;
name|Symbol
name|f
decl_stmt|;
block|{
return|return
operator|(
call|(
name|boolean
call|)
argument_list|(
operator|!
name|inst_tracing
operator|&&
name|nlhdr
operator|.
name|nlines
operator|!=
literal|0
operator|&&
name|nosource
argument_list|(
name|curfunc
argument_list|)
operator|&&
name|canskip
argument_list|(
name|curfunc
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|private
name|Address
name|findnextaddr
parameter_list|(
name|startaddr
parameter_list|,
name|isnext
parameter_list|)
name|Address
name|startaddr
decl_stmt|;
name|Boolean
name|isnext
decl_stmt|;
block|{
specifier|register
name|Address
name|addr
decl_stmt|;
name|Optab
modifier|*
name|op
decl_stmt|;
name|Opcode
name|ins
decl_stmt|;
name|unsigned
name|char
name|mode
decl_stmt|;
name|int
name|argtype
decl_stmt|,
name|amode
decl_stmt|,
name|argno
decl_stmt|,
name|argval
decl_stmt|,
name|nib
decl_stmt|;
name|String
name|r
decl_stmt|;
name|Boolean
name|indexf
decl_stmt|;
enum|enum
block|{
name|KNOWN
block|,
name|SEQUENTIAL
block|,
name|BRANCH
block|}
name|addrstatus
enum|;
name|argval
operator|=
literal|0
expr_stmt|;
name|indexf
operator|=
name|false
expr_stmt|;
name|addr
operator|=
name|startaddr
expr_stmt|;
name|iread
argument_list|(
operator|&
name|ins
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ins
condition|)
block|{
case|case
name|O_CALLF
case|:
case|case
name|O_CALLS
case|:
name|addrstatus
operator|=
name|KNOWN
expr_stmt|;
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|addr
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
name|pc
operator|=
name|addr
expr_stmt|;
name|setcurfunc
argument_list|(
name|whatblock
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|bpact
argument_list|()
expr_stmt|;
if|if
condition|(
name|isnext
name|or
name|skipfunc
argument_list|(
name|ins
argument_list|,
name|curfunc
argument_list|)
condition|)
block|{
name|addrstatus
operator|=
name|KNOWN
expr_stmt|;
name|addr
operator|=
name|return_addr
argument_list|()
expr_stmt|;
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|bpact
argument_list|()
expr_stmt|;
block|}
else|else
name|callnews
argument_list|(
comment|/* iscall = */
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_RET
case|:
name|addrstatus
operator|=
name|KNOWN
expr_stmt|;
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|callnews
argument_list|(
comment|/* iscall = */
name|false
argument_list|)
expr_stmt|;
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|addr
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
name|pc
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
name|printstatus
argument_list|()
expr_stmt|;
name|bpact
argument_list|()
expr_stmt|;
break|break;
case|case
name|O_BRB
case|:
case|case
name|O_BRW
case|:
case|case
name|O_JMP
case|:
case|case
name|O_BBSSI
case|:
case|case
name|O_BCC
case|:
case|case
name|O_BCS
case|:
case|case
name|O_BEQL
case|:
case|case
name|O_BGEQ
case|:
case|case
name|O_BGTR
case|:
case|case
name|O_BGTRU
case|:
case|case
name|O_BLEQ
case|:
case|case
name|O_BLEQU
case|:
case|case
name|O_BLSS
case|:
case|case
name|O_BNEQ
case|:
case|case
name|O_BVC
case|:
case|case
name|O_BVS
case|:
case|case
name|O_CASEL
case|:
case|case
name|O_AOBLSS
case|:
case|case
name|O_AOBLEQ
case|:
name|addrstatus
operator|=
name|KNOWN
expr_stmt|;
name|stepto
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|addr
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
name|pc
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
name|printstatus
argument_list|()
expr_stmt|;
break|break;
default|default:
name|addrstatus
operator|=
name|SEQUENTIAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addrstatus
operator|==
name|KNOWN
condition|)
return|return
operator|(
name|addr
operator|)
return|;
name|addr
operator|+=
literal|1
expr_stmt|;
name|op
operator|=
name|ioptab
index|[
name|ins
index|]
expr_stmt|;
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|argno
operator|<
name|op
operator|->
name|numargs
condition|;
name|argno
operator|++
control|)
block|{
if|if
condition|(
name|indexf
operator|==
name|true
condition|)
name|indexf
operator|=
name|false
expr_stmt|;
name|argtype
operator|=
name|op
operator|->
name|argtype
index|[
name|argno
index|]
expr_stmt|;
if|if
condition|(
name|is_branch_disp
argument_list|(
name|argtype
argument_list|)
condition|)
name|mode
operator|=
literal|0xAF
operator|+
operator|(
name|typelen
argument_list|(
name|argtype
argument_list|)
operator|<<
literal|5
operator|)
expr_stmt|;
else|else
name|iread
argument_list|(
operator|&
name|mode
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|,
name|addr
operator|+=
literal|1
expr_stmt|;
name|r
operator|=
name|regname
index|[
name|regnm
argument_list|(
name|mode
argument_list|)
index|]
expr_stmt|;
name|amode
operator|=
name|addrmode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|amode
condition|)
block|{
case|case
name|LITSHORT
case|:
case|case
name|LITUPTO31
case|:
case|case
name|LITUPTO47
case|:
case|case
name|LITUPTO63
case|:
name|argval
operator|=
name|mode
expr_stmt|;
break|break;
case|case
name|INDEX
case|:
name|indexf
operator|=
name|true
expr_stmt|;
operator|--
name|argno
expr_stmt|;
break|break;
case|case
name|REG
case|:
case|case
name|REGDEF
case|:
case|case
name|AUTODEC
case|:
break|break;
case|case
name|AUTOINC
case|:
name|nib
operator|=
name|mode
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|nib
operator|==
literal|0xf
operator|||
name|nib
operator|==
literal|8
operator|||
name|nib
operator|==
literal|9
condition|)
block|{
name|int
name|size
init|=
operator|(
name|mode
operator|&
literal|03
operator|)
operator|+
literal|1
decl_stmt|;
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
name|regname
index|[
name|PROGCTR
index|]
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|size
expr_stmt|;
block|}
break|break;
case|case
name|AUTOINCDEF
case|:
if|if
condition|(
operator|(
name|mode
operator|&
literal|0xf
operator|)
operator|!=
literal|0xf
condition|)
break|break;
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|BYTEDISP
case|:
case|case
name|BYTEDISPDEF
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|WORDDISP
case|:
case|case
name|WORDDISPDEF
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|2
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|LONGDISP
case|:
case|case
name|LONGDISPDEF
case|:
name|argval
operator|=
name|getdisp
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|,
name|r
argument_list|,
name|amode
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ins
operator|==
name|O_CALLF
name|or
name|ins
operator|==
name|O_CALLS
condition|)
name|argval
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|addrstatus
operator|==
name|BRANCH
condition|)
name|addr
operator|=
name|argval
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the displacement of an instruction that uses displacement addressing.  */
end_comment

begin_function
name|private
name|int
name|getdisp
parameter_list|(
name|addr
parameter_list|,
name|nbytes
parameter_list|,
name|reg
parameter_list|,
name|mode
parameter_list|)
name|Address
name|addr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|String
name|reg
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|char
name|byte
decl_stmt|;
name|short
name|hword
decl_stmt|;
name|int
name|argval
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|iread
argument_list|(
operator|&
name|byte
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
argument_list|)
expr_stmt|;
name|argval
operator|=
name|byte
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|iread
argument_list|(
operator|&
name|hword
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|hword
argument_list|)
argument_list|)
expr_stmt|;
name|argval
operator|=
name|hword
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|iread
argument_list|(
operator|&
name|argval
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|argval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reg
operator|==
name|regname
index|[
name|PROGCTR
index|]
operator|&&
name|mode
operator|>=
name|BYTEDISP
condition|)
name|argval
operator|+=
name|addr
operator|+
name|nbytes
expr_stmt|;
return|return
operator|(
name|argval
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BP_OP
value|O_BPT
end_define

begin_comment
comment|/* breakpoint trap */
end_comment

begin_define
define|#
directive|define
name|BP_ERRNO
value|SIGTRAP
end_define

begin_comment
comment|/* signal received at a breakpoint */
end_comment

begin_comment
comment|/*  * Setting a breakpoint at a location consists of saving  * the word at the location and poking a BP_OP there.  *  * We save the locations and words on a list for use in unsetting.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|Savelist
modifier|*
name|Savelist
typedef|;
end_typedef

begin_struct
struct|struct
name|Savelist
block|{
name|Address
name|location
decl_stmt|;
name|Byte
name|save
decl_stmt|;
name|Byte
name|refcount
decl_stmt|;
name|Savelist
name|link
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|Savelist
name|savelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set a breakpoint at the given address.  Only save the word there  * if it's not already a breakpoint.  */
end_comment

begin_function
name|public
name|setbp
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
name|Byte
name|w
decl_stmt|,
name|save
decl_stmt|;
specifier|register
name|Savelist
name|newsave
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|savelist
init|;
name|s
operator|!=
name|nil
condition|;
name|s
operator|=
name|s
operator|->
name|link
control|)
if|if
condition|(
name|s
operator|->
name|location
operator|==
name|addr
condition|)
block|{
name|s
operator|->
name|refcount
operator|++
expr_stmt|;
return|return;
block|}
name|iread
argument_list|(
operator|&
name|save
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|newsave
operator|=
name|new
argument_list|(
name|Savelist
argument_list|)
expr_stmt|;
name|newsave
operator|->
name|location
operator|=
name|addr
expr_stmt|;
name|newsave
operator|->
name|save
operator|=
name|save
expr_stmt|;
name|newsave
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|newsave
operator|->
name|link
operator|=
name|savelist
expr_stmt|;
name|savelist
operator|=
name|newsave
expr_stmt|;
name|w
operator|=
name|BP_OP
expr_stmt|;
name|iwrite
argument_list|(
operator|&
name|w
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unset a breakpoint; unfortunately we have to search the SAVELIST  * to find the saved value.  The assumption is that the SAVELIST will  * usually be quite small.  */
end_comment

begin_function
name|public
name|unsetbp
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
specifier|register
name|Savelist
name|s
decl_stmt|,
name|prev
decl_stmt|;
name|prev
operator|=
name|nil
expr_stmt|;
for|for
control|(
name|s
operator|=
name|savelist
init|;
name|s
operator|!=
name|nil
condition|;
name|s
operator|=
name|s
operator|->
name|link
control|)
block|{
if|if
condition|(
name|s
operator|->
name|location
operator|==
name|addr
condition|)
block|{
name|iwrite
argument_list|(
operator|&
name|s
operator|->
name|save
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|==
name|nil
condition|)
name|savelist
operator|=
name|s
operator|->
name|link
expr_stmt|;
else|else
name|prev
operator|->
name|link
operator|=
name|s
operator|->
name|link
expr_stmt|;
name|dispose
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|prev
operator|=
name|s
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"unsetbp: couldn't find address %d"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enter a procedure by creating and executing a call instruction.  */
end_comment

begin_define
define|#
directive|define
name|CALLSIZE
value|7
end_define

begin_comment
comment|/* size of call instruction */
end_comment

begin_function
name|public
name|beginproc
parameter_list|(
name|p
parameter_list|,
name|argc
parameter_list|)
name|Symbol
name|p
decl_stmt|;
name|Integer
name|argc
decl_stmt|;
block|{
name|char
name|save
index|[
name|CALLSIZE
index|]
decl_stmt|;
struct|struct
block|{
name|Opcode
name|op
decl_stmt|;
name|unsigned
name|char
name|numargs
decl_stmt|;
name|unsigned
name|char
name|mode
decl_stmt|;
name|char
name|addr
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
comment|/* unaligned long */
block|}
name|call
struct|;
name|long
name|dest
decl_stmt|;
name|error
argument_list|(
literal|"Can't do a \"call\" right now...sorry"
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
literal|4
operator|*
name|argc
operator|+
literal|4
operator|>
literal|256
condition|)
name|error
argument_list|(
literal|"too many parameters (max %d)"
argument_list|,
literal|256
operator|/
literal|4
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pc
operator|=
literal|2
expr_stmt|;
name|iread
argument_list|(
name|save
argument_list|,
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|call
operator|.
name|op
operator|=
name|O_CALLF
expr_stmt|;
name|call
operator|.
name|numargs
operator|=
literal|4
operator|*
name|argc
operator|+
literal|4
expr_stmt|;
name|call
operator|.
name|mode
operator|=
literal|0xef
expr_stmt|;
comment|/* longword relative */
name|dest
operator|=
name|codeloc
argument_list|(
name|p
argument_list|)
operator|-
literal|2
operator|-
operator|(
name|pc
operator|+
name|CALLSIZE
operator|)
expr_stmt|;
name|mov
argument_list|(
operator|&
name|dest
argument_list|,
name|call
operator|.
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|call
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|iwrite
argument_list|(
operator|&
name|call
argument_list|,
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|call
argument_list|)
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|PROGCTR
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pstep
argument_list|(
name|process
argument_list|,
name|DEFSIG
argument_list|)
expr_stmt|;
name|iwrite
argument_list|(
name|save
argument_list|,
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|reg
argument_list|(
name|PROGCTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isbperr
argument_list|()
condition|)
name|printstatus
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Special variables for debugging the kernel.  */
end_comment

begin_decl_stmt
name|public
name|integer
name|masterpcbb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|integer
name|slr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|struct
name|pte
modifier|*
name|sbr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|struct
name|pcb
name|pcb
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|getpcb
parameter_list|()
block|{
name|fseek
argument_list|(
name|corefile
argument_list|,
name|masterpcbb
operator|&
operator|~
literal|0xc0000000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|get
argument_list|(
name|corefile
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"p0br %lx p0lr %lx p2br %lx p2lr %lx\n"
argument_list|,
name|pcb
operator|.
name|pcb_p0br
argument_list|,
name|pcb
operator|.
name|pcb_p0lr
argument_list|,
name|pcb
operator|.
name|pcb_p2br
argument_list|,
name|pcb
operator|.
name|pcb_p2lr
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|0
argument_list|,
name|pcb
operator|.
name|pcb_r0
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|1
argument_list|,
name|pcb
operator|.
name|pcb_r1
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|2
argument_list|,
name|pcb
operator|.
name|pcb_r2
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|3
argument_list|,
name|pcb
operator|.
name|pcb_r3
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|4
argument_list|,
name|pcb
operator|.
name|pcb_r4
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|5
argument_list|,
name|pcb
operator|.
name|pcb_r5
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|6
argument_list|,
name|pcb
operator|.
name|pcb_r6
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|7
argument_list|,
name|pcb
operator|.
name|pcb_r7
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|8
argument_list|,
name|pcb
operator|.
name|pcb_r8
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|9
argument_list|,
name|pcb
operator|.
name|pcb_r9
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|10
argument_list|,
name|pcb
operator|.
name|pcb_r10
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|11
argument_list|,
name|pcb
operator|.
name|pcb_r11
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
literal|12
argument_list|,
name|pcb
operator|.
name|pcb_r12
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|FRP
argument_list|,
name|pcb
operator|.
name|pcb_fp
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|STKP
argument_list|,
name|pcb
operator|.
name|pcb_ksp
argument_list|)
expr_stmt|;
name|setreg
argument_list|(
name|PROGCTR
argument_list|,
name|pcb
operator|.
name|pcb_pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|public
name|copyregs
argument_list|(
name|savreg
argument_list|,
name|reg
argument_list|)
name|Word
name|savreg
index|[]
decl_stmt|,
name|reg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
index|[
literal|0
index|]
operator|=
name|savreg
index|[
name|R0
index|]
expr_stmt|;
name|reg
index|[
literal|1
index|]
operator|=
name|savreg
index|[
name|R1
index|]
expr_stmt|;
name|reg
index|[
literal|2
index|]
operator|=
name|savreg
index|[
name|R2
index|]
expr_stmt|;
name|reg
index|[
literal|3
index|]
operator|=
name|savreg
index|[
name|R3
index|]
expr_stmt|;
name|reg
index|[
literal|4
index|]
operator|=
name|savreg
index|[
name|R4
index|]
expr_stmt|;
name|reg
index|[
literal|5
index|]
operator|=
name|savreg
index|[
name|R5
index|]
expr_stmt|;
name|reg
index|[
literal|6
index|]
operator|=
name|savreg
index|[
name|R6
index|]
expr_stmt|;
name|reg
index|[
literal|7
index|]
operator|=
name|savreg
index|[
name|R7
index|]
expr_stmt|;
name|reg
index|[
literal|8
index|]
operator|=
name|savreg
index|[
name|R8
index|]
expr_stmt|;
name|reg
index|[
literal|9
index|]
operator|=
name|savreg
index|[
name|R9
index|]
expr_stmt|;
name|reg
index|[
literal|10
index|]
operator|=
name|savreg
index|[
name|R10
index|]
expr_stmt|;
name|reg
index|[
literal|11
index|]
operator|=
name|savreg
index|[
name|R11
index|]
expr_stmt|;
name|reg
index|[
literal|12
index|]
operator|=
name|savreg
index|[
name|R12
index|]
expr_stmt|;
name|reg
index|[
name|FRP
index|]
operator|=
name|savreg
index|[
name|FP
index|]
expr_stmt|;
name|reg
index|[
name|STKP
index|]
operator|=
name|savreg
index|[
name|SP
index|]
expr_stmt|;
name|reg
index|[
name|PROGCTR
index|]
operator|=
name|savreg
index|[
name|PC
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Map a virtual address to a physical address.  */
end_comment

begin_function
name|public
name|Address
name|vmap
parameter_list|(
name|addr
parameter_list|)
name|Address
name|addr
decl_stmt|;
block|{
name|int
name|oldaddr
init|=
name|addr
decl_stmt|,
name|v
decl_stmt|;
name|struct
name|pte
name|pte
decl_stmt|;
name|addr
operator|&=
operator|~
literal|0xc0000000
expr_stmt|;
name|v
operator|=
name|btop
argument_list|(
name|addr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|oldaddr
operator|&
literal|0xc0000000
condition|)
block|{
case|case
literal|0xc0000000
case|:
comment|/* 		 * In system space get system pte.  If 		 * valid or reclaimable then physical address 		 * is combination of its page number and the page 		 * offset of the original address. 		 */
if|if
condition|(
name|v
operator|>=
name|slr
condition|)
goto|goto
name|oor
goto|;
name|addr
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
name|sbr
operator|+
name|v
argument_list|)
operator|)
operator|&
operator|~
literal|0xc0000000
expr_stmt|;
goto|goto
name|simple
goto|;
case|case
literal|0x80000000
case|:
comment|/* 		 * In p2 spce must not be in shadow region. 		 */
if|if
condition|(
name|v
operator|<
name|pcb
operator|.
name|pcb_p2lr
condition|)
goto|goto
name|oor
goto|;
name|addr
operator|=
call|(
name|long
call|)
argument_list|(
name|pcb
operator|.
name|pcb_p2br
operator|+
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x40000000
case|:
comment|/* 		 * In p1 space everything is verboten (for now). 		 */
goto|goto
name|oor
goto|;
case|case
literal|0x00000000
case|:
comment|/* 		 * In p0 space must not be off end of region. 		 */
if|if
condition|(
name|v
operator|>=
name|pcb
operator|.
name|pcb_p0lr
condition|)
goto|goto
name|oor
goto|;
name|addr
operator|=
call|(
name|long
call|)
argument_list|(
name|pcb
operator|.
name|pcb_p0br
operator|+
name|v
argument_list|)
expr_stmt|;
break|break;
name|oor
label|:
name|error
argument_list|(
literal|"address out of segment"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For p0/p1/p2 address, user-level page table should 	 * be in kernel vm.  Do second-level indirect by recursing. 	 */
if|if
condition|(
operator|(
name|addr
operator|&
literal|0xc0000000
operator|)
operator|!=
literal|0xc0000000
condition|)
name|error
argument_list|(
literal|"bad p0br, p1br, or p2br in pcb"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|vmap
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|simple
label|:
comment|/* 	 * Addr is now address of the pte of the page we 	 * are interested in; get the pte and paste up the 	 * physical address. 	 */
name|fseek
argument_list|(
name|corefile
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|pte
argument_list|,
sizeof|sizeof
argument_list|(
name|pte
argument_list|)
argument_list|,
literal|1
argument_list|,
name|corefile
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"page table botch"
argument_list|)
expr_stmt|;
comment|/* SHOULD CHECK NOT I/O ADDRESS; NEED CPU TYPE! */
if|if
condition|(
name|pte
operator|.
name|pg_v
operator|==
literal|0
operator|&&
operator|(
name|pte
operator|.
name|pg_fod
operator|||
name|pte
operator|.
name|pg_pfnum
operator|==
literal|0
operator|)
condition|)
name|error
argument_list|(
literal|"page not valid/reclaimable"
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|long
call|)
argument_list|(
name|ptob
argument_list|(
name|pte
operator|.
name|pg_pfnum
argument_list|)
operator|+
operator|(
name|oldaddr
operator|&
name|PGOFSET
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

