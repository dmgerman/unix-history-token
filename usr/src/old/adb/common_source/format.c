begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)format.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * adb - formats  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<cencode.h>
end_include

begin_decl_stmt
specifier|extern
name|char
name|BADMOD
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|NOFORK
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol desirability in exform() */
end_comment

begin_enum
enum|enum
block|{
name|IFEXACT
block|,
name|ALWAYS
block|,
name|NEVER
block|}
name|wantsym
enum|;
end_enum

begin_function_decl
name|char
modifier|*
name|exform
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Execute the given format `ecount' times.  */
end_comment

begin_macro
name|scanform
argument_list|(
argument|forcesym
argument_list|,
argument|fmt
argument_list|,
argument|space
argument_list|,
argument|ptype
argument_list|)
end_macro

begin_decl_stmt
name|int
name|forcesym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|space
decl_stmt|,
name|ptype
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|expr_t
name|ntimes
init|=
name|ecount
decl_stmt|;
name|addr_t
name|savdot
decl_stmt|,
name|newdot
decl_stmt|;
if|if
condition|(
name|ntimes
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|wantsym
operator|=
name|forcesym
condition|?
name|ALWAYS
else|:
name|IFEXACT
init|;
condition|;
name|wantsym
operator|=
name|IFEXACT
control|)
block|{
name|p
operator|=
name|fmt
expr_stmt|;
name|savdot
operator|=
name|dot
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* loop over format items */
name|n
operator|=
literal|0
expr_stmt|;
comment|/* get optional count */
while|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
operator|*
name|p
operator|++
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
comment|/* end of format */
break|break;
name|p
operator|=
name|exform
argument_list|(
name|n
condition|?
name|n
else|:
literal|1
argument_list|,
name|p
operator|-
operator|(
name|c
operator|!=
literal|'\\'
operator|)
argument_list|,
name|space
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
block|}
name|dotinc
operator|=
operator|(
name|newdot
operator|=
name|dot
operator|)
operator|-
name|savdot
expr_stmt|;
name|dot
operator|=
name|savdot
expr_stmt|;
if|if
condition|(
name|errflag
operator|!=
name|NULL
operator|&&
operator|(
name|long
operator|)
name|ntimes
operator|<
literal|0
condition|)
block|{
name|errflag
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|checkerr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|--
name|ntimes
operator|==
literal|0
condition|)
break|break;
name|dot
operator|=
name|newdot
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Print a halfword or a word from dot.  */
end_comment

begin_macro
name|showdot
argument_list|(
argument|fullword
argument_list|,
argument|space
argument_list|,
argument|ptype
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fullword
decl_stmt|,
name|space
decl_stmt|,
name|ptype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|c
init|=
name|fullword
condition|?
literal|'4'
else|:
literal|'2'
decl_stmt|;
name|wantsym
operator|=
name|NEVER
expr_stmt|;
operator|(
name|void
operator|)
name|exform
argument_list|(
literal|1
argument_list|,
operator|&
name|c
argument_list|,
name|space
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The following are used inside exform().  *  * The various FT_ values specify the type of the object accessed  * by some format character.  FT_DULL indicates that no object is  * accessed (or that it is done in some peculiar way).  * The fsize array holds the size (in bytes)  * of each of those types; the fmttypes[] array lists the type for  * each character.  To save space, since there are many characters  * for some of the types, they are stored as strings.  */
end_comment

begin_enum
enum|enum
block|{
name|FT_DULL
block|,
name|FT_CHAR
block|,
name|FT_HW
block|,
name|FT_FW
block|,
name|FT_ADDR
block|,
name|FT_FLT
block|,
name|FT_DBL
block|,
name|FT_TM
block|}
enum|;
end_enum

begin_comment
comment|/* these may have to be turned into `#define's */
end_comment

begin_decl_stmt
specifier|static
name|char
name|fsize
index|[]
init|=
block|{
comment|/* ordered by enumeration above! */
literal|0
block|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|hword_t
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|expr_t
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|addr_t
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
block|,
expr|sizeof
operator|(
name|time_t
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|fmttypes
block|{
name|char
modifier|*
name|ft_chars
decl_stmt|;
name|int
name|ft_type
decl_stmt|;
block|}
name|fmttypes
index|[]
init|=
block|{
block|{
literal|"\t\" +-NRST^inrst"
block|,
name|FT_DULL
block|}
block|,
block|{
literal|"1BCbc"
block|,
name|FT_CHAR
block|}
block|,
block|{
literal|"2doquvxz"
block|,
name|FT_HW
block|}
block|,
block|{
literal|"4DOQUVXZ"
block|,
name|FT_FW
block|}
block|,
block|{
literal|"p"
block|,
name|FT_ADDR
block|}
block|,
block|{
literal|"f"
block|,
name|FT_FLT
block|}
block|,
block|{
literal|"F"
block|,
name|FT_DBL
block|}
block|,
block|{
literal|"Y"
block|,
name|FT_TM
block|}
block|,
literal|0
block|}
struct|;
end_struct

begin_comment
comment|/*  * Execute a single format item `fcount' times; set  * dotinc and move dot.  Return the address of the next  * format item, or NULL upon error reading an object.  *  * I must apologise for the length of this routine, but  * it is bloated mainly with type correctness.  */
end_comment

begin_function
name|char
modifier|*
name|exform
parameter_list|(
name|fcount
parameter_list|,
name|fmt
parameter_list|,
name|space
parameter_list|,
name|ptype
parameter_list|)
name|int
name|fcount
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|space
decl_stmt|,
name|ptype
decl_stmt|;
block|{
specifier|register
name|struct
name|fmttypes
modifier|*
name|ftp
decl_stmt|;
specifier|register
name|int
name|sz
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|,
name|fmtchar
decl_stmt|;
name|addr_t
name|savdot
decl_stmt|,
name|off
decl_stmt|;
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
union|union
block|{
name|char
name|c
decl_stmt|;
name|hword_t
name|hw
decl_stmt|;
name|expr_t
name|fw
decl_stmt|;
name|float
name|f
decl_stmt|;
name|double
name|d
decl_stmt|;
name|time_t
name|tm
decl_stmt|;
name|addr_t
name|a
decl_stmt|;
block|}
name|obj
union|;
while|while
condition|(
name|fcount
operator|>
literal|0
condition|)
block|{
comment|/* 		 * First decode the type to be used with the expression. 		 * If address, print dot as a symbol, save it in var 0, 		 * and bypass all the nonsense. 		 */
name|p
operator|=
name|fmt
expr_stmt|;
name|fmtchar
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* address: special */
if|if
condition|(
name|fmtchar
operator|==
literal|'a'
condition|)
block|{
name|pdot
argument_list|()
expr_stmt|;
name|wantsym
operator|=
name|NEVER
expr_stmt|;
comment|/* well, hardly ever */
name|var
index|[
literal|0
index|]
operator|=
name|dot
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
for|for
control|(
name|ftp
operator|=
name|fmttypes
init|;
operator|(
name|s
operator|=
name|ftp
operator|->
name|ft_chars
operator|)
operator|!=
name|NULL
condition|;
name|ftp
operator|++
control|)
while|while
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|fmtchar
condition|)
goto|goto
name|found
goto|;
name|error
argument_list|(
name|BADMOD
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|found
label|:
comment|/* plop out a symbol, if desired */
if|if
condition|(
name|wantsym
operator|==
name|ALWAYS
condition|)
name|pdot
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|wantsym
operator|==
name|IFEXACT
operator|&&
operator|(
name|sp
operator|=
name|findsym
argument_list|(
name|dot
argument_list|,
name|ptype
argument_list|,
operator|&
name|off
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|off
operator|==
literal|0
condition|)
name|adbprintf
argument_list|(
literal|"\n%s:%16t"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
comment|/* \n ??? */
name|wantsym
operator|=
name|NEVER
expr_stmt|;
comment|/* 		 * Now read the sort of object we decided fmtchar represents, 		 * or compute it from the expression given for dot. 		 */
name|sz
operator|=
name|fsize
index|[
name|ftp
operator|->
name|ft_type
index|]
expr_stmt|;
if|if
condition|(
name|space
operator|!=
name|SP_NONE
condition|)
block|{
comment|/* can just read into the union */
if|if
condition|(
name|sz
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|adbread
argument_list|(
name|space
argument_list|,
name|dot
argument_list|,
operator|&
name|obj
argument_list|,
name|sz
argument_list|)
expr_stmt|;
else|else
name|obj
operator|.
name|fw
operator|=
name|edot
expr_stmt|;
block|}
else|else
block|{
comment|/* must decode type in order to assign, alas */
switch|switch
condition|(
name|ftp
operator|->
name|ft_type
condition|)
block|{
case|case
name|FT_CHAR
case|:
name|obj
operator|.
name|c
operator|=
name|edot
expr_stmt|;
break|break;
case|case
name|FT_HW
case|:
name|obj
operator|.
name|hw
operator|=
name|edot
expr_stmt|;
break|break;
case|case
name|FT_FW
case|:
name|obj
operator|.
name|fw
operator|=
name|edot
expr_stmt|;
break|break;
case|case
name|FT_DULL
case|:
case|case
name|FT_ADDR
case|:
name|obj
operator|.
name|a
operator|=
name|dot
expr_stmt|;
break|break;
case|case
name|FT_FLT
case|:
case|case
name|FT_DBL
case|:
name|obj
operator|.
name|fw
operator|=
literal|0
expr_stmt|;
name|etofloat
argument_list|(
name|edot
argument_list|,
operator|&
name|obj
operator|.
name|c
argument_list|,
name|ftp
operator|->
name|ft_type
operator|==
name|FT_DBL
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_TM
case|:
name|obj
operator|.
name|fw
operator|=
literal|0
expr_stmt|;
name|obj
operator|.
name|tm
operator|=
name|edot
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"exform 1"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
comment|/* if we could not read the object, stop now. */
if|if
condition|(
name|errflag
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|mkfault
condition|)
name|error
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Now copy the value read (or assigned) to var[0]. 		 * Here some of the types are collapsed: since the 		 * idea is to be able to get the value back later 		 * by reading var[0] and going through the type 		 * decoding above, it sometimes suffices to record 		 * as many bits as fit in an expr_t (see expr.c). 		 * 		 * Note that double precision numbers generally lose 		 * bits, since sizeof(double) can be> sizeof(expr_t). 		 */
switch|switch
condition|(
name|ftp
operator|->
name|ft_type
condition|)
block|{
case|case
name|FT_CHAR
case|:
name|var
index|[
literal|0
index|]
operator|=
name|obj
operator|.
name|c
expr_stmt|;
break|break;
case|case
name|FT_HW
case|:
name|var
index|[
literal|0
index|]
operator|=
name|obj
operator|.
name|hw
expr_stmt|;
break|break;
case|case
name|FT_FW
case|:
case|case
name|FT_FLT
case|:
case|case
name|FT_DBL
case|:
case|case
name|FT_TM
case|:
name|var
index|[
literal|0
index|]
operator|=
name|obj
operator|.
name|fw
expr_stmt|;
break|break;
case|case
name|FT_DULL
case|:
case|case
name|FT_ADDR
case|:
name|var
index|[
literal|0
index|]
operator|=
name|obj
operator|.
name|a
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"exform 2"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* set the size, if this object has a size */
if|if
condition|(
name|sz
condition|)
name|dotinc
operator|=
name|sz
expr_stmt|;
comment|/* finally, do the command */
if|if
condition|(
name|charpos
argument_list|()
operator|==
literal|0
condition|)
name|adbprintf
argument_list|(
literal|"%16m"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fmtchar
condition|)
block|{
comment|/* 			 * Many of the formats translate to a %-8 or %-16 			 * edition of themselves; we use a single string, 			 * and modify the format part, for these. 			 */
specifier|static
name|char
name|cfmt
index|[]
init|=
literal|"%-*?"
decl_stmt|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|dotinc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|adbprintf
argument_list|(
literal|"%*t"
argument_list|,
name|fcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|adbprintf
argument_list|(
literal|"%*m"
argument_list|,
name|fcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
literal|'p'
case|:
name|psymoff
argument_list|(
literal|"%R"
argument_list|,
name|obj
operator|.
name|a
argument_list|,
name|ptype
argument_list|,
name|maxoff
argument_list|,
literal|"%16t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|printc
argument_list|(
name|obj
operator|.
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|printesc
argument_list|(
name|obj
operator|.
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|adbprintf
argument_list|(
literal|"%-8O"
argument_list|,
operator|(
name|expr_t
operator|)
operator|(
name|u_char
operator|)
name|obj
operator|.
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|savdot
operator|=
name|dot
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|adbread
argument_list|(
name|space
argument_list|,
name|dot
argument_list|,
operator|&
name|obj
operator|.
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|||
name|iserr
argument_list|()
operator|||
name|obj
operator|.
name|c
operator|==
literal|0
condition|)
break|break;
name|dot
operator|=
name|inkdot
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtchar
operator|==
literal|'S'
condition|)
name|printesc
argument_list|(
name|obj
operator|.
name|c
argument_list|)
expr_stmt|;
else|else
name|printc
argument_list|(
name|obj
operator|.
name|c
argument_list|)
expr_stmt|;
name|endline
argument_list|()
expr_stmt|;
block|}
name|dotinc
operator|=
name|dot
operator|-
name|savdot
operator|+
literal|1
expr_stmt|;
name|dot
operator|=
name|savdot
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|adbprintf
argument_list|(
literal|"%-8R"
argument_list|,
operator|(
name|expr_t
operator|)
operator|(
name|u_char
operator|)
name|obj
operator|.
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|fmtchar
operator|=
literal|'r'
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'v'
case|:
case|case
literal|'u'
case|:
case|case
literal|'d'
case|:
case|case
literal|'o'
case|:
case|case
literal|'q'
case|:
case|case
literal|'x'
case|:
case|case
literal|'z'
case|:
name|cfmt
index|[
literal|3
index|]
operator|=
name|fmtchar
expr_stmt|;
name|adbprintf
argument_list|(
name|cfmt
argument_list|,
literal|8
argument_list|,
name|obj
operator|.
name|hw
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|fmtchar
operator|=
literal|'R'
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'V'
case|:
case|case
literal|'U'
case|:
case|case
literal|'D'
case|:
case|case
literal|'O'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Z'
case|:
name|cfmt
index|[
literal|3
index|]
operator|=
name|fmtchar
expr_stmt|;
name|adbprintf
argument_list|(
name|cfmt
argument_list|,
literal|16
argument_list|,
name|obj
operator|.
name|fw
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|adbprintf
argument_list|(
literal|"%-24Y"
argument_list|,
name|obj
operator|.
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|printins
argument_list|(
name|space
argument_list|)
expr_stmt|;
comment|/* also sets dotinc */
name|printc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|s
operator|=
name|checkfloat
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|obj
operator|.
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|adbprintf
argument_list|(
literal|"%-16s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|adbprintf
argument_list|(
literal|"%-16.9f"
argument_list|,
name|obj
operator|.
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|s
operator|=
name|checkfloat
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|obj
operator|.
name|d
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|adbprintf
argument_list|(
literal|"%-32s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|adbprintf
argument_list|(
literal|"%-32.18f"
argument_list|,
name|obj
operator|.
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
name|printc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|dotinc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'"'
condition|)
name|printc
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
name|dotinc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|dot
operator|=
name|inkdot
argument_list|(
operator|-
name|dotinc
operator|*
name|fcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
literal|'+'
case|:
name|dot
operator|=
name|inkdot
argument_list|(
name|fcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
literal|'-'
case|:
name|dot
operator|=
name|inkdot
argument_list|(
operator|-
name|fcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"exform 3"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|space
operator|!=
name|SP_NONE
condition|)
name|dot
operator|=
name|inkdot
argument_list|(
name|dotinc
argument_list|)
expr_stmt|;
name|fcount
operator|--
expr_stmt|;
name|endline
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print dot in its canonical format.  */
end_comment

begin_macro
name|pdot
argument_list|()
end_macro

begin_block
block|{
name|psymoff
argument_list|(
literal|"%R"
argument_list|,
name|dot
argument_list|,
name|SP_INSTR
argument_list|,
name|maxoff
argument_list|,
literal|":%16t"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print character c using ASCII escape conventions.  */
end_comment

begin_expr_stmt
name|printesc
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|adbprintf
argument_list|(
literal|"%s"
argument_list|,
name|cencode
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|,
name|isprint
argument_list|(
name|c
argument_list|)
condition|?
literal|0
else|:
name|CENC_GRAPH
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

