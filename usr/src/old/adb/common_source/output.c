begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * This module is believed to contain source code proprietary to AT&T.  * Use and redistribution is subject to the Berkeley Software License  * Agreement and your Software Agreement with AT&T (Western Electric).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)output.c	5.2 (Berkeley) 4/4/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * adb - output  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_decl_stmt
specifier|extern
name|char
name|TOODEEP
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|infile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|outfile
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|printbuf
index|[
name|LINELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|printptr
init|=
name|printbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print the string s.  */
end_comment

begin_expr_stmt
name|prints
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
name|printc
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print the character c.  */
end_comment

begin_macro
name|printc
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|mkfault
condition|)
return|return;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
return|return;
case|case
literal|'\n'
case|:
name|sendout
argument_list|()
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
operator|*
name|printptr
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|printptr
operator|>=
operator|&
name|printbuf
index|[
name|LINELEN
operator|-
literal|1
index|]
condition|)
comment|/* 1 == space for \n */
name|sendout
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Send (write) out the contents of the print buffer, compressing  * spaces into tabs.  */
end_comment

begin_expr_stmt
specifier|static
name|sendout
argument_list|()
block|{
specifier|register
name|char
operator|*
name|p
block|,
operator|*
name|q
block|;
specifier|register
name|int
name|c
block|,
name|off
operator|=
literal|0
block|,
name|spaces
operator|=
literal|0
block|,
name|s
block|;
define|#
directive|define
name|tabsize
parameter_list|(
name|x
parameter_list|)
value|(8 - ((x)& 7))
for|for
control|(
name|q
operator|=
name|p
operator|=
name|printbuf
init|;
name|p
operator|<
name|printptr
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
name|spaces
operator|++
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|spaces
operator|+=
name|tabsize
argument_list|(
name|off
operator|+
name|spaces
argument_list|)
expr_stmt|;
break|break;
default|default:
name|s
operator|=
name|tabsize
argument_list|(
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
name|spaces
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|spaces
operator|>=
name|s
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\t'
expr_stmt|;
name|spaces
operator|-=
name|s
expr_stmt|;
name|s
operator|=
literal|8
expr_stmt|;
block|}
end_expr_stmt

begin_while
while|while
condition|(
operator|--
name|spaces
operator|>=
literal|0
condition|)
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
end_while

begin_expr_stmt
name|spaces
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} 	}
operator|*
name|q
operator|++
operator|=
literal|'\n'
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|write
argument_list|(
name|outfile
argument_list|,
name|printbuf
argument_list|,
name|q
operator|-
name|printbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|printptr
operator|=
name|printbuf
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|tabsize
end_undef

begin_expr_stmt
unit|}  charpos
operator|(
operator|)
block|{
return|return
operator|(
name|printptr
operator|-
name|printbuf
operator|)
return|;
block|}
end_expr_stmt

begin_macro
name|endline
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|printptr
operator|-
name|printbuf
operator|>=
name|maxcol
condition|)
name|printc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|flushbuf
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|printptr
operator|!=
name|printbuf
condition|)
name|sendout
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* this should not be necessary! */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_undef
undef|#
directive|undef
name|va_arg
end_undef

begin_define
define|#
directive|define
name|va_arg
parameter_list|(
name|ap
parameter_list|,
name|type
parameter_list|)
value|(ap = ap, (type)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Context passed between adbprintf and decodefmt.  */
end_comment

begin_struct
struct|struct
name|prf
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format pointer */
name|va_list
name|ap
decl_stmt|;
comment|/* argument pointer */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* digit buffer, or %s string */
name|int
name|adj
decl_stmt|;
comment|/* 'l'eft (-) or 'r'ight adjustment */
name|int
name|width
decl_stmt|;
comment|/* width from format */
name|int
name|prec
decl_stmt|;
comment|/* precision from format */
block|}
struct|;
end_struct

begin_comment
comment|/*  * adb's very own version of printf() ... of course, all the format  * escapes are different.  Noteworthy are the %<width>m and %<tabstop>t  * formats, which move the given width, or to the given tabstop, and  * the %?a format, which evaluates one argument, and if not zero, prints  * according to format a.  (Note that any modifiers must appear in the   * `a' part, not in the %? part.)  */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|adbprintf
argument_list|(
argument|fmt
argument_list|,
argument|va_alist
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|prf
name|prf
decl_stmt|;
name|char
name|digits
index|[
literal|130
index|]
decl_stmt|;
comment|/* good to at least 128 bit expr_t */
comment|/* set up the fields adbprf needs */
name|prf
operator|.
name|fmt
operator|=
name|fmt
expr_stmt|;
name|va_start
argument_list|(
name|prf
operator|.
name|ap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* look for % conversions */
name|s
operator|=
name|prf
operator|.
name|fmt
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'%'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return;
name|printc
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|prf
operator|.
name|fmt
operator|=
name|s
expr_stmt|;
name|prf
operator|.
name|buf
operator|=
name|digits
expr_stmt|;
name|dofmt
argument_list|(
operator|&
name|prf
argument_list|)
expr_stmt|;
comment|/* format one format */
name|n
operator|=
name|strlen
argument_list|(
name|s
operator|=
name|prf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|prf
operator|.
name|prec
operator|>=
literal|0
operator|&&
name|n
operator|>
name|prf
operator|.
name|prec
condition|)
name|n
operator|=
name|prf
operator|.
name|prec
expr_stmt|;
name|c
operator|=
name|prf
operator|.
name|width
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|prf
operator|.
name|adj
operator|==
literal|'r'
condition|)
while|while
condition|(
operator|--
name|c
operator|>=
literal|0
condition|)
name|printc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|printc
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|c
operator|>=
literal|0
condition|)
name|printc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|prf
operator|.
name|ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do a single format.  */
end_comment

begin_expr_stmt
specifier|static
name|dofmt
argument_list|(
name|prf
argument_list|)
specifier|register
expr|struct
name|prf
operator|*
name|prf
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|prf
operator|->
name|fmt
decl_stmt|;
specifier|register
name|va_list
name|ap
init|=
name|prf
operator|->
name|ap
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|expr_t
name|v
decl_stmt|;
name|int
name|pluspref
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|null
index|[]
init|=
literal|""
decl_stmt|;
name|prf
operator|->
name|adj
operator|=
literal|'r'
expr_stmt|;
name|prf
operator|->
name|width
operator|=
literal|0
expr_stmt|;
name|prf
operator|->
name|prec
operator|=
operator|-
literal|1
expr_stmt|;
name|more
label|:
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|sw
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'-'
case|:
name|prf
operator|->
name|adj
operator|=
literal|'l'
expr_stmt|;
goto|goto
name|more
goto|;
case|case
literal|'+'
case|:
name|pluspref
operator|=
literal|1
expr_stmt|;
goto|goto
name|more
goto|;
case|case
literal|'*'
case|:
name|prf
operator|->
name|width
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
goto|goto
name|more
goto|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
for|for
control|(
name|n
operator|=
name|c
operator|-
literal|'0'
init|;
name|isdigit
argument_list|(
name|c
operator|=
operator|*
name|s
operator|++
argument_list|)
condition|;
control|)
name|n
operator|=
literal|10
operator|*
name|n
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|prf
operator|->
name|width
operator|=
name|n
expr_stmt|;
goto|goto
name|sw
goto|;
case|case
literal|'.'
case|:
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|prf
operator|->
name|prec
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
goto|goto
name|more
goto|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|isdigit
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
operator|*
name|s
operator|++
control|)
name|n
operator|=
literal|10
operator|*
name|n
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|prf
operator|->
name|prec
operator|=
name|n
expr_stmt|;
goto|goto
name|sw
goto|;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
comment|/* print in signed version of current radix */
if|if
condition|(
operator|(
name|n
operator|=
name|radix
operator|)
operator|>
literal|0
condition|)
name|n
operator|=
operator|-
name|n
expr_stmt|;
goto|goto
name|rprint
goto|;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|n
operator|=
operator|-
literal|8
expr_stmt|;
goto|goto
name|rprint
goto|;
comment|/* octal */
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|n
operator|=
operator|-
literal|10
expr_stmt|;
goto|goto
name|rprint
goto|;
comment|/* decimal */
case|case
literal|'z'
case|:
case|case
literal|'Z'
case|:
name|n
operator|=
operator|-
literal|16
expr_stmt|;
goto|goto
name|rprint
goto|;
comment|/* hex */
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|n
operator|=
literal|8
expr_stmt|;
goto|goto
name|rprint
goto|;
comment|/* and */
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
name|n
operator|=
literal|10
expr_stmt|;
goto|goto
name|rprint
goto|;
comment|/* unsigned */
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|n
operator|=
literal|16
expr_stmt|;
goto|goto
name|rprint
goto|;
comment|/* versions */
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|n
operator|=
name|radix
expr_stmt|;
name|rprint
label|:
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|v
operator|=
name|n
operator|<
literal|0
condition|?
name|SF_ARG
else|:
name|UF_ARG
expr_stmt|;
else|else
name|v
operator|=
name|n
operator|<
literal|0
condition|?
name|SH_ARG
else|:
name|UH_ARG
expr_stmt|;
name|printradix
argument_list|(
name|prf
operator|->
name|buf
argument_list|,
name|v
argument_list|,
name|n
argument_list|,
name|pluspref
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|printdate
argument_list|(
name|prf
operator|->
name|buf
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|time_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
operator|*
name|prf
operator|->
name|buf
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|prf
operator|->
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|prf
operator|->
name|buf
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* here comes stdio ... sigh */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|prf
operator|->
name|buf
argument_list|,
literal|"%+*.*e"
argument_list|,
name|prf
operator|->
name|width
argument_list|,
name|prf
operator|->
name|prec
operator|>=
literal|0
condition|?
name|prf
operator|->
name|prec
else|:
literal|16
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|prf
operator|->
name|prec
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|prf
operator|->
name|buf
operator|=
name|null
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|prf
operator|->
name|width
condition|)
name|prf
operator|->
name|width
operator|-=
name|charpos
argument_list|()
operator|%
name|prf
operator|->
name|width
expr_stmt|;
name|prf
operator|->
name|buf
operator|=
name|null
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|c
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|prf
operator|->
name|fmt
operator|=
name|s
expr_stmt|;
name|prf
operator|->
name|ap
operator|=
name|ap
expr_stmt|;
name|dofmt
argument_list|(
name|prf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|prf
operator|->
name|buf
operator|=
name|null
expr_stmt|;
return|return;
default|default:
name|panic
argument_list|(
literal|"dofmt"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|prf
operator|->
name|fmt
operator|=
name|s
expr_stmt|;
name|prf
operator|->
name|ap
operator|=
name|ap
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print the date into the buffer at `p'.  */
end_comment

begin_expr_stmt
specifier|static
name|printdate
argument_list|(
name|p
argument_list|,
name|tm
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|time_t
name|tm
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|asc
init|=
name|ctime
argument_list|(
operator|&
name|tm
argument_list|)
decl_stmt|;
name|char
modifier|*
name|strncpy
parameter_list|()
function_decl|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|p
argument_list|,
name|asc
operator|+
literal|20
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* "1988" */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|p
operator|+
literal|4
argument_list|,
name|asc
operator|+
literal|3
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* " Aug 18 03:04:49" */
name|p
index|[
literal|20
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print the value `val' in base `base' into the buffer at `p'.  * If base is negative, assume the number is signed.  */
end_comment

begin_expr_stmt
specifier|static
name|printradix
argument_list|(
name|p
argument_list|,
name|val
argument_list|,
name|base
argument_list|,
name|pluspref
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|expr_t
name|val
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pluspref
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|expr_t
name|high
decl_stmt|;
name|char
name|digs
index|[
literal|128
index|]
decl_stmt|;
comment|/* good to 128 bits minimum */
if|if
condition|(
name|base
operator|<
literal|0
condition|)
block|{
name|base
operator|=
operator|-
name|base
expr_stmt|;
if|if
condition|(
operator|(
name|sexpr_t
operator|)
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|=
operator|-
name|val
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pluspref
condition|)
operator|*
name|p
operator|++
operator|=
literal|'+'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pluspref
condition|)
operator|*
name|p
operator|++
operator|=
literal|'+'
expr_stmt|;
name|d
operator|=
name|digs
expr_stmt|;
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|8
case|:
while|while
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
operator|*
name|d
operator|++
operator|=
name|val
operator|&
literal|7
expr_stmt|;
name|val
operator|>>=
literal|3
expr_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|16
case|:
do|do
block|{
operator|*
name|d
operator|++
operator|=
name|val
operator|&
literal|15
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|val
operator|>>=
literal|4
operator|)
operator|!=
literal|0
condition|)
do|;
break|break;
default|default:
do|do
block|{
name|high
operator|=
name|val
operator|/
name|base
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|val
operator|-
operator|(
name|high
operator|*
name|base
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|val
operator|=
name|high
operator|)
operator|!=
literal|0
condition|)
do|;
break|break;
block|}
while|while
condition|(
name|d
operator|>
name|digs
condition|)
operator|*
name|p
operator|++
operator|=
literal|"0123456789abcdef"
index|[
operator|*
operator|--
name|d
index|]
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * BEGIN XXX  * THIS BELONGS ELSEWHERE  */
end_comment

begin_define
define|#
directive|define
name|MAXIFD
value|5
end_define

begin_struct
struct|struct
block|{
name|int
name|fd
decl_stmt|;
name|expr_t
name|v9
decl_stmt|;
block|}
name|istack
index|[
name|MAXIFD
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|ifiledepth
decl_stmt|;
end_decl_stmt

begin_macro
name|iclose
argument_list|(
argument|stack
argument_list|,
argument|err
argument_list|)
end_macro

begin_decl_stmt
name|int
name|stack
decl_stmt|,
name|err
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|infile
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|infile
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|ifiledepth
operator|>=
literal|0
condition|)
if|if
condition|(
name|istack
index|[
name|ifiledepth
index|]
operator|.
name|fd
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|istack
index|[
name|ifiledepth
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
name|ifiledepth
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stack
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|infile
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|infile
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stack
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ifiledepth
operator|>=
name|MAXIFD
condition|)
name|error
argument_list|(
name|TOODEEP
argument_list|)
expr_stmt|;
name|istack
index|[
name|ifiledepth
index|]
operator|.
name|fd
operator|=
name|infile
expr_stmt|;
name|istack
index|[
name|ifiledepth
index|]
operator|.
name|v9
operator|=
name|var
index|[
literal|9
index|]
expr_stmt|;
name|ifiledepth
operator|++
expr_stmt|;
name|infile
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|infile
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|infile
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ifiledepth
operator|>
literal|0
condition|)
block|{
name|infile
operator|=
name|istack
index|[
operator|--
name|ifiledepth
index|]
operator|.
name|fd
expr_stmt|;
name|var
index|[
literal|9
index|]
operator|=
name|istack
index|[
name|ifiledepth
index|]
operator|.
name|v9
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|oclose
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|outfile
operator|!=
literal|1
condition|)
block|{
name|flushbuf
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|outfile
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block

end_unit

