begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)command.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * adb - commands  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_decl_stmt
specifier|extern
name|char
name|BADEQ
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "unexpected `='" */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|NOMATCH
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "cannot locate value" */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|BADVAR
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "bad variable" */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|BADCOM
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "bad command" */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|NOFORK
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "try again" */
end_comment

begin_comment
comment|/*  * executing is used in main() to see if it is necessary to  * delete any breakpoints that might have been set; if an  * error occurs while a subprocess command is running, executing  * will be set.  */
end_comment

begin_decl_stmt
name|int
name|executing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lastcom remembers the previous command */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|c
decl_stmt|;
comment|/* the command */
name|int
name|star
decl_stmt|;
comment|/* true iff it was in alternate space */
block|}
name|lastcom
struct|;
end_struct

begin_comment
comment|/*  * Execute the given command buffer.  * If defcom is nonzero, it is used as the default command.  */
end_comment

begin_macro
name|command
argument_list|(
argument|buf
argument_list|,
argument|defcom
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|defcom
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lp
operator|=
name|buf
expr_stmt|;
do|do
block|{
name|cmds
argument_list|(
name|defcom
argument_list|)
expr_stmt|;
name|flushbuf
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|rdc
argument_list|()
operator|==
literal|';'
condition|)
do|;
name|unreadc
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|cmds
argument_list|(
argument|defcom
argument_list|)
name|int
name|defcom
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|struct
name|reglist
modifier|*
name|reg
decl_stmt|;
comment|/* 	 * Pick up the optional first expression (`dot'), 	 * then, if the next character is a comma, pick up 	 * the second optional expression (`ecount'). 	 */
if|if
condition|(
name|gavedot
operator|=
name|oexpr
argument_list|()
condition|)
name|ditto
operator|=
name|dot
operator|=
name|edot
operator|=
name|expv
expr_stmt|;
else|else
name|edot
operator|=
name|dot
expr_stmt|;
comment|/* probably equal, but possibly truncating */
if|if
condition|(
name|rdc
argument_list|()
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|!
name|oexpr
argument_list|()
condition|)
name|error
argument_list|(
literal|"count expected"
argument_list|)
expr_stmt|;
name|gavecount
operator|=
literal|1
expr_stmt|;
name|ecount
operator|=
name|expv
expr_stmt|;
block|}
else|else
block|{
name|gavecount
operator|=
literal|0
expr_stmt|;
name|ecount
operator|=
literal|1
expr_stmt|;
name|unreadc
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Pick up the command.  If there is no command, do the 	 * previous (or default) command, and if no dot was given, 	 * use the `next' dot. 	 */
name|c
operator|=
name|rdc
argument_list|()
expr_stmt|;
if|if
condition|(
name|eol
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|defcom
operator|!=
literal|0
condition|)
block|{
name|lastcom
operator|.
name|c
operator|=
name|defcom
expr_stmt|;
name|lastcom
operator|.
name|star
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gavedot
condition|)
name|dot
operator|=
name|inkdot
argument_list|(
name|dotinc
argument_list|)
expr_stmt|;
name|unreadc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|lastcom
operator|.
name|c
operator|=
name|c
expr_stmt|;
name|lastcom
operator|.
name|star
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|lastcom
operator|.
name|c
condition|)
block|{
case|case
literal|'='
case|:
name|fmtcom
argument_list|(
name|SP_NONE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|fmtcom
argument_list|(
name|SP_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|fmtcom
argument_list|(
name|SP_INSTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|lastcom
operator|.
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reglookup
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|setreg
argument_list|(
name|reg
argument_list|,
name|edot
argument_list|)
condition|)
name|prints
argument_list|(
literal|"register write failed"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|varlookup
argument_list|(
name|rdc
argument_list|()
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
name|var
index|[
name|c
index|]
operator|=
name|edot
expr_stmt|;
else|else
name|error
argument_list|(
name|BADVAR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|lastcom
operator|.
name|c
operator|=
literal|0
expr_stmt|;
name|shell
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|lastcom
operator|.
name|c
operator|=
literal|0
expr_stmt|;
name|printtrace
argument_list|(
name|nextchar
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
if|if
condition|(
operator|!
name|executing
condition|)
block|{
name|executing
operator|=
literal|1
expr_stmt|;
name|subpcs
argument_list|(
name|nextchar
argument_list|()
argument_list|)
expr_stmt|;
name|executing
operator|=
literal|0
expr_stmt|;
name|lastcom
operator|.
name|c
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
name|prints
argument_list|(
literal|"adb\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|BADCOM
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_block

begin_comment
comment|/*  * Perform a format-based command (one in ? / or =).  */
end_comment

begin_expr_stmt
specifier|static
name|fmtcom
argument_list|(
argument|space
argument_list|,
argument|eqcom
argument_list|)
name|int
name|space
operator|,
name|eqcom
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* special commands m, lL, wW do not operate in SP_NONE (`=') */
name|void
name|mcom
argument_list|()
decl_stmt|,
name|lcom
argument_list|()
decl_stmt|,
name|wcom
argument_list|()
decl_stmt|;
specifier|static
struct|struct
name|fcmd
block|{
name|int
name|c
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|()
function_decl|;
block|}
name|fcmd
index|[]
init|=
block|{
block|{
literal|'m'
block|,
name|mcom
block|}
block|,
block|{
literal|'l'
block|,
name|lcom
block|}
block|,
block|{
literal|'L'
block|,
name|lcom
block|}
block|,
block|{
literal|'w'
block|,
name|wcom
block|}
block|,
block|{
literal|'W'
block|,
name|wcom
block|}
block|,
literal|0
block|}
struct|;
specifier|register
name|struct
name|fcmd
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|ptype
init|=
name|space
decl_stmt|;
specifier|static
name|char
name|stformat
index|[
name|LINELEN
index|]
init|=
literal|"X\"= \"^i"
decl_stmt|;
specifier|static
name|char
name|eqformat
index|[
name|LINELEN
index|]
init|=
literal|"z"
decl_stmt|;
comment|/* 	 * Are we operating in the alternate `star' space? 	 */
if|if
condition|(
operator|!
name|eqcom
condition|)
block|{
if|if
condition|(
name|rdc
argument_list|()
operator|==
literal|'*'
condition|)
name|lastcom
operator|.
name|star
operator|=
literal|1
expr_stmt|;
else|else
name|unreadc
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastcom
operator|.
name|star
condition|)
block|{
name|space
operator||=
name|SP_STAR
expr_stmt|;
comment|/* print as data for instr, and vice versa */
name|ptype
operator|=
operator|(
name|SP_DATA
operator|+
name|SP_INSTR
operator|)
operator|-
name|ptype
expr_stmt|;
block|}
block|}
comment|/* 	 * Check for the special commands first. 	 */
name|c
operator|=
name|rdc
argument_list|()
expr_stmt|;
for|for
control|(
name|f
operator|=
name|fcmd
init|;
name|f
operator|->
name|c
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
name|f
operator|->
name|c
condition|)
block|{
if|if
condition|(
name|eqcom
condition|)
name|error
argument_list|(
name|BADEQ
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
operator|->
name|fn
call|)
argument_list|(
name|space
argument_list|,
name|ptype
argument_list|,
name|isupper
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|unreadc
argument_list|()
expr_stmt|;
name|getformat
argument_list|(
name|eqcom
condition|?
name|eqformat
else|:
name|stformat
argument_list|,
name|LINELEN
argument_list|)
expr_stmt|;
name|scanform
argument_list|(
operator|!
name|eqcom
argument_list|,
name|eqcom
condition|?
name|eqformat
else|:
name|stformat
argument_list|,
name|space
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set a map (?m, /m commands).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|mcom
parameter_list|(
name|space
parameter_list|,
name|ptype
parameter_list|,
name|fullword
parameter_list|)
name|int
name|space
decl_stmt|,
name|ptype
decl_stmt|,
name|fullword
decl_stmt|;
block|{
specifier|register
name|struct
name|map
modifier|*
name|smap
decl_stmt|;
specifier|register
name|struct
name|m1
modifier|*
name|mm
decl_stmt|;
name|char
name|c
decl_stmt|;
name|smap
operator|=
name|space
operator|&
name|SP_DATA
condition|?
operator|&
name|datmap
else|:
operator|&
name|txtmap
expr_stmt|;
name|mm
operator|=
name|space
operator|&
name|SP_STAR
condition|?
operator|&
name|smap
operator|->
name|m2
else|:
operator|&
name|smap
operator|->
name|m1
expr_stmt|;
if|if
condition|(
name|oexpr
argument_list|()
condition|)
block|{
name|mm
operator|->
name|b
operator|=
name|expv
expr_stmt|;
if|if
condition|(
name|oexpr
argument_list|()
condition|)
block|{
name|mm
operator|->
name|e
operator|=
name|expv
expr_stmt|;
if|if
condition|(
name|oexpr
argument_list|()
condition|)
name|mm
operator|->
name|f
operator|=
name|expv
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|rdc
argument_list|()
operator|)
operator|==
literal|'?'
condition|)
name|smap
operator|->
name|ufd
operator|=
name|symfile
operator|.
name|fd
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|smap
operator|->
name|ufd
operator|=
name|corefile
operator|.
name|fd
expr_stmt|;
else|else
name|unreadc
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Locate a value (l, L commands).  */
end_comment

begin_function
specifier|static
name|void
name|lcom
parameter_list|(
name|space
parameter_list|,
name|ptype
parameter_list|,
name|fullword
parameter_list|)
name|int
name|space
decl_stmt|,
name|ptype
decl_stmt|,
name|fullword
decl_stmt|;
block|{
specifier|register
name|expr_t
name|val
decl_stmt|,
name|mask
decl_stmt|;
name|addr_t
name|savdot
decl_stmt|;
comment|/* search for exp */
name|savdot
operator|=
name|dot
expr_stmt|;
name|val
operator|=
name|rexpr
argument_list|()
expr_stmt|;
if|if
condition|(
name|oexpr
argument_list|()
condition|)
name|mask
operator|=
name|expv
expr_stmt|;
else|else
name|mask
operator|=
operator|~
literal|0L
expr_stmt|;
if|if
condition|(
name|fullword
condition|)
block|{
name|expr_t
name|w
decl_stmt|;
name|dotinc
operator|=
sizeof|sizeof
argument_list|(
name|w
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|adbread
argument_list|(
name|space
argument_list|,
name|dot
argument_list|,
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iserr
argument_list|()
operator|||
operator|(
name|w
operator|&
name|mask
operator|)
operator|==
name|val
condition|)
break|break;
name|dot
operator|=
name|inkdot
argument_list|(
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hword_t
name|hw
decl_stmt|;
name|dotinc
operator|=
sizeof|sizeof
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
name|hword_t
operator|)
name|mask
expr_stmt|;
name|val
operator|=
operator|(
name|hword_t
operator|)
name|val
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|adbread
argument_list|(
name|space
argument_list|,
name|dot
argument_list|,
operator|&
name|hw
argument_list|,
sizeof|sizeof
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iserr
argument_list|()
operator|||
operator|(
name|hw
operator|&
name|mask
operator|)
operator|==
name|val
condition|)
break|break;
name|dot
operator|=
name|inkdot
argument_list|(
sizeof|sizeof
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iserr
argument_list|()
condition|)
block|{
name|dot
operator|=
name|savdot
expr_stmt|;
name|errflag
operator|=
name|NOMATCH
expr_stmt|;
block|}
name|psymoff
argument_list|(
literal|"%R"
argument_list|,
name|dot
argument_list|,
name|ptype
argument_list|,
name|maxoff
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write new values (w, W).  */
end_comment

begin_function
specifier|static
name|void
name|wcom
parameter_list|(
name|space
parameter_list|,
name|ptype
parameter_list|,
name|fullword
parameter_list|)
name|int
name|space
decl_stmt|,
name|ptype
decl_stmt|,
name|fullword
decl_stmt|;
block|{
name|addr_t
name|savdot
decl_stmt|;
name|hword_t
name|hw
decl_stmt|;
operator|(
name|void
operator|)
name|rexpr
argument_list|()
expr_stmt|;
do|do
block|{
name|savdot
operator|=
name|dot
expr_stmt|;
name|pdot
argument_list|()
expr_stmt|;
name|showdot
argument_list|(
name|fullword
argument_list|,
name|space
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
comment|/* also advances */
name|errflag
operator|=
name|NULL
expr_stmt|;
name|dot
operator|=
name|savdot
expr_stmt|;
if|if
condition|(
name|fullword
condition|)
operator|(
name|void
operator|)
name|adbwrite
argument_list|(
name|space
argument_list|,
name|dot
argument_list|,
operator|&
name|expv
argument_list|,
sizeof|sizeof
argument_list|(
name|expv
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|hw
operator|=
name|expv
expr_stmt|;
operator|(
name|void
operator|)
name|adbwrite
argument_list|(
name|space
argument_list|,
name|dot
argument_list|,
operator|&
name|hw
argument_list|,
sizeof|sizeof
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|savdot
operator|=
name|dot
expr_stmt|;
name|adbprintf
argument_list|(
literal|"=%8t"
argument_list|)
expr_stmt|;
name|showdot
argument_list|(
name|fullword
argument_list|,
name|space
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|printc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|oexpr
argument_list|()
operator|&&
operator|!
name|iserr
argument_list|()
condition|)
do|;
name|dot
operator|=
name|savdot
expr_stmt|;
name|checkerr
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do a shell escape.  *  * THE vfork CODE BELOW IS CURRENTLY BROKEN  * MUST CHANGE signal TO sigvec BELOW  */
end_comment

begin_expr_stmt
specifier|static
name|shell
argument_list|()
block|{
name|int
name|rc
block|,
name|unixpid
block|;
expr|union
name|wait
name|status
block|;
name|char
operator|*
name|argp
operator|=
name|lp
block|;
name|char
operator|*
name|getenv
argument_list|()
block|,
operator|*
name|eshell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
block|;
if|if
condition|(
name|eshell
operator|==
literal|0
condition|)
name|eshell
operator|=
literal|"/bin/sh"
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|readchar
argument_list|()
operator|!=
literal|'\n'
condition|)
comment|/* void */
empty_stmt|;
end_while

begin_ifndef
ifndef|#
directive|ifndef
name|VFORK
end_ifndef

begin_define
define|#
directive|define
name|vfork
value|fork
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
operator|(
name|unixpid
operator|=
name|vfork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|sigquit
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|eshell
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|argp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|16
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|VFORK
end_ifdef

begin_expr_stmt
operator|*
name|lp
operator|=
literal|'\n'
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|unixpid
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
name|NOFORK
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|(
name|rc
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|unixpid
operator|&&
name|rc
operator|!=
operator|-
literal|1
condition|)
comment|/* void */
empty_stmt|;
end_while

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intcatch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|prints
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unreadc
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * Read a format into the given buffer.  If nothing is  * read, leave the buffer alone.  */
end_comment

begin_macro
unit|static
name|getformat
argument_list|(
argument|buf
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|quote
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|readchar
argument_list|()
operator|)
operator|,
name|quote
condition|?
name|c
operator|!=
literal|'\n'
else|:
operator|!
name|eol
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|quote
operator|=
operator|!
name|quote
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|unreadc
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|buf
condition|)
comment|/* nonempty */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Convert a (one-character) variable name to an index, or -1 for  * error.  */
end_comment

begin_expr_stmt
name|varlookup
argument_list|(
name|name
argument_list|)
specifier|register
name|int
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
name|name
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
name|isalpha
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
name|isupper
argument_list|(
name|name
argument_list|)
condition|?
name|name
operator|-
literal|'a'
operator|+
literal|10
else|:
name|name
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*   * If the text at the current input point matches a register name,  * consume that text and return a pointer to the register; otherwise  * leave it unconsumed and return NULL.  */
end_comment

begin_function
name|struct
name|reglist
modifier|*
name|reglookup
parameter_list|()
block|{
specifier|register
name|struct
name|reglist
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
name|c0
decl_stmt|,
name|c1
decl_stmt|;
name|char
modifier|*
name|oldlp
init|=
name|lp
decl_stmt|;
specifier|extern
name|struct
name|reglist
name|reglist
index|[]
decl_stmt|;
name|c0
operator|=
name|rdc
argument_list|()
expr_stmt|;
name|c1
operator|=
name|readchar
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|reglist
init|;
operator|(
name|a
operator|=
name|p
operator|->
name|r_name
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|a
operator|++
operator|!=
name|c0
operator|||
operator|*
name|a
operator|++
operator|!=
name|c1
condition|)
continue|continue;
name|b
operator|=
name|lp
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|a
operator|==
literal|0
condition|)
block|{
comment|/* name matched: stop short */
name|lp
operator|=
name|b
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|*
name|a
operator|++
operator|==
operator|*
name|b
operator|++
condition|)
do|;
block|}
name|lp
operator|=
name|oldlp
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

