begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)output.c	1.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  *	UNIX debugger  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
name|INT
name|mkfault
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|infile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|outfile
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|maxpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|maxoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|radix
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
name|printbuf
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
modifier|*
name|printptr
init|=
name|printbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
modifier|*
name|digitptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|TOODEEP
decl_stmt|;
end_decl_stmt

begin_macro
name|printc
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|CHAR
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CHAR
name|d
decl_stmt|;
name|REG
name|STRING
name|q
decl_stmt|;
name|REG
name|posn
decl_stmt|,
name|tabs
decl_stmt|,
name|p
decl_stmt|;
name|IF
name|mkfault
name|THEN
return|return;
name|ELIF
argument_list|(
operator|*
name|printptr
operator|=
name|c
argument_list|)
operator|==
name|EOR
name|THEN
name|tabs
operator|=
literal|0
expr_stmt|;
name|posn
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|printbuf
expr_stmt|;
name|FOR
name|p
init|=
literal|0
decl_stmt|;
name|p
operator|<
name|printptr
operator|-
name|printbuf
expr_stmt|;
name|p
operator|++
name|DO
name|d
operator|=
name|printbuf
index|[
name|p
index|]
expr_stmt|;
name|IF
argument_list|(
name|p
operator|&
literal|7
argument_list|)
operator|==
literal|0
name|ANDF
name|posn
name|THEN
name|tabs
operator|++
expr_stmt|;
name|posn
operator|=
literal|0
expr_stmt|;
name|FI
name|IF
name|d
operator|==
name|SP
name|THEN
name|posn
operator|++
expr_stmt|;
name|ELSE
name|WHILE
name|tabs
operator|>
literal|0
name|DO
operator|*
name|q
operator|++
operator|=
name|TB
expr_stmt|;
name|tabs
operator|--
expr_stmt|;
name|OD
name|WHILE
name|posn
operator|>
literal|0
name|DO
operator|*
name|q
operator|++
operator|=
name|SP
expr_stmt|;
name|posn
operator|--
expr_stmt|;
name|OD
operator|*
name|q
operator|++
operator|=
name|d
expr_stmt|;
name|FI
name|OD
operator|*
name|q
operator|++
operator|=
name|EOR
expr_stmt|;
ifdef|#
directive|ifdef
name|EDDT
name|printptr
operator|=
name|printbuf
expr_stmt|;
do|do
name|putchar
argument_list|(
operator|*
name|printptr
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
name|printptr
operator|<
name|q
condition|)
do|;
else|#
directive|else
name|write
argument_list|(
name|outfile
argument_list|,
name|printbuf
argument_list|,
name|q
operator|-
name|printbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printptr
operator|=
name|printbuf
expr_stmt|;
name|ELIF
name|c
operator|==
name|TB
name|THEN
operator|*
name|printptr
operator|++
operator|=
name|SP
expr_stmt|;
name|WHILE
argument_list|(
name|printptr
operator|-
name|printbuf
argument_list|)
operator|&
literal|7
name|DO
operator|*
name|printptr
operator|++
operator|=
name|SP
expr_stmt|;
name|OD
name|ELIF
name|c
name|THEN
name|printptr
operator|++
expr_stmt|;
name|FI
name|IF
name|printptr
operator|>=
operator|&
name|printbuf
index|[
name|MAXLIN
operator|-
literal|9
index|]
name|THEN
name|write
argument_list|(
name|outfile
argument_list|,
name|printbuf
argument_list|,
name|printptr
operator|-
name|printbuf
argument_list|)
expr_stmt|;
name|printptr
operator|=
name|printbuf
expr_stmt|;
name|FI
block|}
end_block

begin_macro
name|charpos
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|printptr
operator|-
name|printbuf
operator|)
return|;
block|}
end_block

begin_macro
name|flushbuf
argument_list|()
end_macro

begin_block
block|{
name|IF
name|printptr
operator|!=
name|printbuf
name|THEN
name|printc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
name|FI
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|printf
argument_list|(
argument|fmat
argument_list|,
argument|a1
argument_list|)
end_macro

begin_decl_stmt
name|STRING
name|fmat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|a1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|STRING
name|fptr
decl_stmt|;
name|REG
name|STRING
name|s
decl_stmt|;
name|REG
name|L_INT
modifier|*
name|dptr
decl_stmt|;
name|L_REAL
modifier|*
name|rptr
decl_stmt|;
name|REG
name|width
decl_stmt|,
name|prec
decl_stmt|;
name|CHAR
name|c
decl_stmt|,
name|adj
decl_stmt|;
name|INT
name|x
decl_stmt|,
name|n
decl_stmt|;
name|REG
name|L_INT
name|lx
decl_stmt|;
name|CHAR
name|digits
index|[
literal|64
index|]
decl_stmt|;
name|fptr
operator|=
name|fmat
expr_stmt|;
name|dptr
operator|=
operator|(
name|L_INT
operator|*
operator|)
operator|&
name|a1
expr_stmt|;
name|WHILE
name|c
init|=
operator|*
name|fptr
operator|++
name|DO
name|IF
name|c
operator|!=
literal|'%'
name|THEN
name|printc
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|ELSE
name|IF
operator|*
name|fptr
operator|==
literal|'-'
name|THEN
name|adj
operator|=
literal|'l'
expr_stmt|;
name|fptr
operator|++
expr_stmt|;
name|ELSE
name|adj
init|=
literal|'r'
decl_stmt|;
name|FI
name|width
init|=
name|convert
argument_list|(
operator|&
name|fptr
argument_list|)
decl_stmt|;
name|IF
operator|*
name|fptr
operator|==
literal|'.'
name|THEN
name|fptr
operator|++
expr_stmt|;
name|prec
operator|=
name|convert
argument_list|(
operator|&
name|fptr
argument_list|)
expr_stmt|;
name|ELSE
name|prec
init|=
operator|-
literal|1
decl_stmt|;
name|FI
name|digitptr
init|=
name|digits
decl_stmt|;
name|rptr
operator|=
operator|(
name|L_REAL
operator|*
operator|)
name|dptr
expr_stmt|;
name|x
operator|=
name|lx
operator|=
operator|*
name|dptr
operator|++
expr_stmt|;
name|s
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|fptr
operator|++
condition|)
block|{
case|case
literal|'d'
case|:
name|printnum
argument_list|(
name|x
argument_list|,
operator|-
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|printnum
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|x
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|printnum
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|x
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|printnum
argument_list|(
name|x
argument_list|,
operator|-
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|printnum
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|x
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|printnum
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|x
argument_list|,
operator|-
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|printnum
argument_list|(
name|lx
argument_list|,
name|radix
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|printdate
argument_list|(
name|lx
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|printnum
argument_list|(
name|lx
argument_list|,
operator|-
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|printnum
argument_list|(
name|lx
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|printnum
argument_list|(
name|lx
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|printnum
argument_list|(
name|lx
argument_list|,
operator|-
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|printnum
argument_list|(
name|lx
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|printnum
argument_list|(
name|lx
argument_list|,
operator|-
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|printc
argument_list|(
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|s
operator|=
operator|(
name|STRING
operator|)
name|lx
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|EDDT
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|dptr
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|s
operator|=
name|digits
argument_list|,
literal|"%*.*f"
argument_list|,
name|width
argument_list|,
name|prec
argument_list|,
operator|*
name|rptr
argument_list|)
expr_stmt|;
name|prec
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'m'
case|:
break|break;
case|case
literal|'M'
case|:
name|width
operator|=
name|x
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
case|case
literal|'t'
case|:
name|IF
name|c
operator|==
literal|'T'
name|THEN
name|width
operator|=
name|x
expr_stmt|;
name|ELSE
name|dptr
operator|--
expr_stmt|;
name|FI
name|IF
name|width
name|THEN
name|width
operator|-=
name|charpos
argument_list|()
operator|%
name|width
expr_stmt|;
name|FI
break|break;
default|default:
name|printc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|dptr
operator|--
expr_stmt|;
block|}
name|IF
name|s
operator|==
literal|0
name|THEN
operator|*
name|digitptr
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|digits
expr_stmt|;
name|FI
name|n
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|n
operator|=
operator|(
name|prec
operator|<
name|n
name|ANDF
name|prec
operator|>=
literal|0
condition|?
name|prec
else|:
name|n
operator|)
expr_stmt|;
name|width
operator|-=
name|n
expr_stmt|;
name|IF
name|adj
operator|==
literal|'r'
name|THEN
name|WHILE
name|width
operator|--
operator|>
literal|0
name|DO
name|printc
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|OD
name|FI
name|WHILE
name|n
operator|--
name|DO
name|printc
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|OD
name|WHILE
name|width
operator|--
operator|>
literal|0
name|DO
name|printc
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|OD
name|digitptr
init|=
name|digits
decl_stmt|;
name|FI
name|OD
block|}
end_block

begin_macro
name|printdate
argument_list|(
argument|tvec
argument_list|)
end_macro

begin_decl_stmt
name|L_INT
name|tvec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REG
name|i
decl_stmt|;
name|REG
name|STRING
name|timeptr
decl_stmt|;
name|STRING
name|ctime
parameter_list|()
function_decl|;
ifndef|#
directive|ifndef
name|EDDT
name|timeptr
operator|=
name|ctime
argument_list|(
operator|&
name|tvec
argument_list|)
expr_stmt|;
else|#
directive|else
name|timeptr
operator|=
literal|"????????????????????????"
expr_stmt|;
endif|#
directive|endif
name|FOR
name|i
init|=
literal|20
decl_stmt|;
name|i
operator|<
literal|24
expr_stmt|;
name|i
operator|++
name|DO
operator|*
name|digitptr
operator|++
operator|=
operator|*
operator|(
name|timeptr
operator|+
name|i
operator|)
expr_stmt|;
name|OD
name|FOR
name|i
init|=
literal|3
decl_stmt|;
name|i
operator|<
literal|19
expr_stmt|;
name|i
operator|++
name|DO
operator|*
name|digitptr
operator|++
operator|=
operator|*
operator|(
name|timeptr
operator|+
name|i
operator|)
expr_stmt|;
name|OD
block|}
end_block

begin_comment
comment|/*printdate*/
end_comment

begin_macro
name|convert
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|REG
name|STRING
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REG
name|CHAR
name|c
decl_stmt|;
name|INT
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|WHILE
argument_list|(
argument|(c = *(*cp)++)>=
literal|'0'
argument_list|)
name|ANDF
argument_list|(
argument|c<=
literal|'9'
argument_list|)
name|DO
name|n
init|=
name|n
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
decl_stmt|;
name|OD
argument_list|(
operator|*
name|cp
argument_list|)
operator|--
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|printnum
argument_list|(
argument|n
argument_list|,
argument|base
argument_list|)
end_macro

begin_decl_stmt
name|REG
name|POS
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REG
name|CHAR
modifier|*
name|dptr
decl_stmt|;
name|CHAR
name|digs
index|[
literal|15
index|]
decl_stmt|;
name|dptr
operator|=
name|digs
expr_stmt|;
name|IF
name|base
operator|<
literal|0
name|THEN
name|base
operator|=
operator|-
name|base
expr_stmt|;
name|IF
argument_list|(
argument|L_INT
argument_list|)
name|n
operator|<
literal|0
name|THEN
name|n
operator|=
operator|-
name|n
expr_stmt|;
operator|*
name|digitptr
operator|++
operator|=
literal|'-'
expr_stmt|;
name|FI
name|FI
name|WHILE
name|n
name|DO
operator|*
name|dptr
operator|++
operator|=
name|n
operator|%
name|base
expr_stmt|;
name|n
operator|/=
name|base
expr_stmt|;
name|OD
name|IF
name|dptr
operator|==
name|digs
name|THEN
operator|*
name|dptr
operator|++
operator|=
literal|0
expr_stmt|;
name|FI
name|WHILE
name|dptr
operator|!=
name|digs
name|DO
name|n
operator|=
operator|*
operator|--
name|dptr
expr_stmt|;
operator|*
name|digitptr
operator|++
operator|=
operator|(
name|n
operator|+
operator|(
name|n
operator|<=
literal|9
condition|?
literal|'0'
else|:
literal|'a'
operator|-
literal|10
operator|)
operator|)
expr_stmt|;
name|OD
block|}
end_block

begin_define
define|#
directive|define
name|MAXIFD
value|5
end_define

begin_struct
struct|struct
block|{
name|int
name|fd
decl_stmt|;
name|int
name|r9
decl_stmt|;
block|}
name|istack
index|[
name|MAXIFD
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|ifiledepth
decl_stmt|;
end_decl_stmt

begin_macro
name|iclose
argument_list|(
argument|stack
argument_list|,
argument|err
argument_list|)
end_macro

begin_block
block|{
name|IF
name|err
name|THEN
name|IF
name|infile
name|THEN
name|close
parameter_list|(
name|infile
parameter_list|)
function_decl|;
name|infile
operator|=
literal|0
expr_stmt|;
name|FI
name|WHILE
operator|--
name|ifiledepth
operator|>=
literal|0
name|DO
name|IF
name|istack
index|[
name|ifiledepth
index|]
operator|.
name|fd
name|THEN
name|close
argument_list|(
name|istack
index|[
name|ifiledepth
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
name|FI
name|OD
name|ifiledepth
init|=
literal|0
decl_stmt|;
name|ELIF
name|stack
operator|==
literal|0
name|THEN
name|IF
name|infile
name|THEN
name|close
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|infile
operator|=
literal|0
expr_stmt|;
name|FI
name|ELIF
name|stack
operator|>
literal|0
name|THEN
name|IF
name|ifiledepth
operator|>=
name|MAXIFD
name|THEN
name|error
argument_list|(
name|TOODEEP
argument_list|)
expr_stmt|;
name|FI
name|istack
index|[
name|ifiledepth
index|]
operator|.
name|fd
operator|=
name|infile
expr_stmt|;
name|istack
index|[
name|ifiledepth
index|]
operator|.
name|r9
operator|=
name|var
index|[
literal|9
index|]
expr_stmt|;
name|ifiledepth
operator|++
expr_stmt|;
name|infile
operator|=
literal|0
expr_stmt|;
name|ELSE
name|IF
name|infile
name|THEN
name|close
parameter_list|(
name|infile
parameter_list|)
function_decl|;
name|infile
operator|=
literal|0
expr_stmt|;
name|FI
name|IF
name|ifiledepth
operator|>
literal|0
name|THEN
name|infile
operator|=
name|istack
index|[
operator|--
name|ifiledepth
index|]
operator|.
name|fd
expr_stmt|;
name|var
index|[
literal|9
index|]
operator|=
name|istack
index|[
name|ifiledepth
index|]
operator|.
name|r9
expr_stmt|;
name|FI
name|FI
block|}
end_block

begin_macro
name|oclose
argument_list|()
end_macro

begin_block
block|{
name|IF
name|outfile
operator|!=
literal|1
name|THEN
name|flushbuf
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|outfile
operator|=
literal|1
expr_stmt|;
name|FI
block|}
end_block

begin_macro
name|endline
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|maxpos
operator|<=
name|charpos
argument_list|()
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

