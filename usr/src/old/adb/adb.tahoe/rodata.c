begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)rodata.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * adb - machine dependent read-only data  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_define
define|#
directive|define
name|N
parameter_list|(
name|arr
parameter_list|)
value|(sizeof(arr) / sizeof(arr[0]))
end_define

begin_comment
comment|/*  * Registers.  The offset value is an offset from u.u_ar0 if negative,  * or if positive, is an offset into the pcb in u.u_pcb.  PCC will not  * let us scale the pcb offsets (grr) so instead we scale the ar0 offsets.  * The `address in pcb' is in the local copy of the kernel pcb, for use  * with kernel dumps.  *  * The registers are printed in the order they are listed here.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pcb
name|pcb
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|pcboff
parameter_list|(
name|field
parameter_list|)
value|(int)&((struct pcb *)0)->field
end_define

begin_define
define|#
directive|define
name|ar0off
parameter_list|(
name|off
parameter_list|)
value|off * 4
end_define

begin_decl_stmt
name|struct
name|reglist
name|reglist
index|[]
init|=
block|{
comment|/* name		offset			address in pcb */
block|{
literal|"p2lr"
block|,
name|pcboff
argument_list|(
name|pcb_p2lr
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_p2lr
block|}
block|,
block|{
literal|"p2br"
block|,
name|pcboff
argument_list|(
name|pcb_p2br
argument_list|)
block|,
operator|(
name|int
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_p2br
block|}
block|,
block|{
literal|"p0lr"
block|,
name|pcboff
argument_list|(
name|pcb_p0lr
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_p0lr
block|}
block|,
block|{
literal|"p0br"
block|,
name|pcboff
argument_list|(
name|pcb_p0br
argument_list|)
block|,
operator|(
name|int
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_p0br
block|}
block|,
block|{
literal|"ksp"
block|,
name|pcboff
argument_list|(
name|pcb_ksp
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_ksp
block|}
block|,
define|#
directive|define
name|HFS
value|-8
comment|/* should be in<tahoe/reg.h>! */
block|{
literal|"hfs"
block|,
name|ar0off
argument_list|(
name|HFS
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_hfs
block|}
block|,
block|{
literal|"psl"
block|,
name|ar0off
argument_list|(
name|PS
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_psl
block|}
block|,
block|{
literal|"pc"
block|,
name|ar0off
argument_list|(
name|PC
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_pc
block|}
block|,
block|{
literal|"ach"
block|,
name|ar0off
argument_list|(
name|RACH
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_ach
block|}
block|,
block|{
literal|"acl"
block|,
name|ar0off
argument_list|(
name|RACL
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_acl
block|}
block|,
block|{
literal|"usp"
block|,
name|ar0off
argument_list|(
name|SP
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_usp
block|}
block|,
block|{
literal|"fp"
block|,
name|ar0off
argument_list|(
name|FP
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_fp
block|}
block|,
block|{
literal|"r12"
block|,
name|ar0off
argument_list|(
name|R12
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_r12
block|}
block|,
block|{
literal|"r11"
block|,
name|ar0off
argument_list|(
name|R11
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_r11
block|}
block|,
block|{
literal|"r10"
block|,
name|ar0off
argument_list|(
name|R10
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_r10
block|}
block|,
block|{
literal|"r9"
block|,
name|ar0off
argument_list|(
name|R9
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_r9
block|}
block|,
block|{
literal|"r8"
block|,
name|ar0off
argument_list|(
name|R8
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_r8
block|}
block|,
block|{
literal|"r7"
block|,
name|ar0off
argument_list|(
name|R7
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_r7
block|}
block|,
block|{
literal|"r6"
block|,
name|ar0off
argument_list|(
name|R6
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_r6
block|}
block|,
block|{
literal|"r5"
block|,
name|ar0off
argument_list|(
name|R5
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_r5
block|}
block|,
block|{
literal|"r4"
block|,
name|ar0off
argument_list|(
name|R4
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_r4
block|}
block|,
block|{
literal|"r3"
block|,
name|ar0off
argument_list|(
name|R3
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_r3
block|}
block|,
block|{
literal|"r2"
block|,
name|ar0off
argument_list|(
name|R2
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_r2
block|}
block|,
block|{
literal|"r1"
block|,
name|ar0off
argument_list|(
name|R1
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_r1
block|}
block|,
block|{
literal|"r0"
block|,
name|ar0off
argument_list|(
name|R0
argument_list|)
block|,
operator|&
name|pcb
operator|.
name|pcb_r0
block|}
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names for codes for illegal instruction */
end_comment

begin_decl_stmt
name|char
modifier|*
name|illinames
index|[]
init|=
block|{
literal|" (reserved addressing fault)"
block|,
literal|" (priviliged instruction fault)"
block|,
literal|" (reserved operand fault)"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nillinames
init|=
name|N
argument_list|(
name|illinames
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names for codes for floating point exception */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fpenames
index|[]
init|=
block|{
literal|""
block|,
literal|" (integer overflow trap)"
block|,
literal|" (integer divide by zero trap)"
block|,
comment|/* not valid 	" (floating overflow trap)", 	" (floating/decimal divide by zero trap)", 	" (floating underflow trap)", 	" (decimal overflow trap)", 	" (subscript out of range trap)", 	" (floating overflow fault)", 	" (floating divide by zero fault)", 	" (floating underflow fault)",  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfpenames
init|=
name|N
argument_list|(
name|fpenames
argument_list|)
decl_stmt|;
end_decl_stmt

end_unit

