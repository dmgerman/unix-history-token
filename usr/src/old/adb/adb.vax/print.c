begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)print.c 4.1 %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  *	UNIX debugger  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
name|MSG
name|LONGFIL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|NOTOPEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|A68BAD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|A68LNK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MSG
name|BADMOD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAP
name|txtmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAP
name|datmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|lastframe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDR
name|callpc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|infile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|maxoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|maxpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|radix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol management */
end_comment

begin_decl_stmt
name|L_INT
name|localval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* breakpoints */
end_comment

begin_decl_stmt
name|BKPTR
name|bkpthead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|REGLIST
name|reglist
index|[]
init|=
block|{
literal|"p1lr"
block|,
name|P1LR
block|,
literal|"p1br"
block|,
name|P1BR
block|,
literal|"p0lr"
block|,
name|P0LR
block|,
literal|"p0br"
block|,
name|P0BR
block|,
literal|"ksp"
block|,
name|KSP
block|,
literal|"esp"
block|,
name|ESP
block|,
literal|"ssp"
block|,
name|SSP
block|,
literal|"psl"
block|,
name|PSL
block|,
literal|"pc"
block|,
name|PC
block|,
literal|"usp"
block|,
name|USP
block|,
literal|"fp"
block|,
name|FP
block|,
literal|"ap"
block|,
name|AP
block|,
literal|"r11"
block|,
name|R11
block|,
literal|"r10"
block|,
name|R10
block|,
literal|"r9"
block|,
name|R9
block|,
literal|"r8"
block|,
name|R8
block|,
literal|"r7"
block|,
name|R7
block|,
literal|"r6"
block|,
name|R6
block|,
literal|"r5"
block|,
name|R5
block|,
literal|"r4"
block|,
name|R4
block|,
literal|"r3"
block|,
name|R3
block|,
literal|"r2"
block|,
name|R2
block|,
literal|"r1"
block|,
name|R1
block|,
literal|"r0"
block|,
name|R0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lastc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|fcor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|errflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|signo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|sigcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|dot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|var
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|symfil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|corfil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|adrval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|adrflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|L_INT
name|cntval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|cntflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|signals
index|[]
init|=
block|{
literal|""
block|,
literal|"hangup"
block|,
literal|"interrupt"
block|,
literal|"quit"
block|,
literal|"illegal instruction"
block|,
literal|"trace/BPT"
block|,
literal|"IOT"
block|,
literal|"EMT"
block|,
literal|"floating exception"
block|,
literal|"killed"
block|,
literal|"bus error"
block|,
literal|"memory fault"
block|,
literal|"bad system call"
block|,
literal|"broken pipe"
block|,
literal|"alarm call"
block|,
literal|"terminated"
block|,
literal|"signal 16"
block|,
literal|"stop (signal)"
block|,
literal|"stop (tty)"
block|,
literal|"continue (signal)"
block|,
literal|"child termination"
block|,
literal|"stop (tty input)"
block|,
literal|"stop (tty output)"
block|,
literal|"input available (signal)"
block|,
literal|"cpu timelimit"
block|,
literal|"file sizelimit"
block|,
literal|"signal 26"
block|,
literal|"signal 27"
block|,
literal|"signal 28"
block|,
literal|"signal 29"
block|,
literal|"signal 30"
block|,
literal|"signal 31"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* general printing routines ($) */
end_comment

begin_macro
name|printtrace
argument_list|(
argument|modif
argument_list|)
end_macro

begin_block
block|{
name|INT
name|narg
decl_stmt|,
name|i
decl_stmt|,
name|stat
decl_stmt|,
name|name
decl_stmt|,
name|limit
decl_stmt|;
name|POS
name|dynam
decl_stmt|;
name|REG
name|BKPTR
name|bkptr
decl_stmt|;
name|CHAR
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|ADDR
name|word
decl_stmt|;
name|STRING
name|comptr
decl_stmt|;
name|ADDR
name|argp
decl_stmt|,
name|frame
decl_stmt|,
name|link
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|sp
decl_stmt|;
name|INT
name|stack
decl_stmt|;
name|INT
name|ntramp
decl_stmt|;
name|IF
name|cntflg
operator|==
literal|0
name|THEN
name|cntval
operator|=
operator|-
literal|1
expr_stmt|;
name|FI
switch|switch
condition|(
name|modif
condition|)
block|{
case|case
literal|'<'
case|:
name|IF
name|cntval
operator|==
literal|0
name|THEN
name|WHILE
name|readchar
argument_list|()
operator|!=
name|EOR
name|DO
name|OD
name|lp
operator|--
expr_stmt|;
break|break;
name|FI
name|IF
name|rdc
argument_list|()
operator|==
literal|'<'
name|THEN
name|stack
operator|=
literal|1
expr_stmt|;
name|ELSE
name|stack
init|=
literal|0
decl_stmt|;
name|lp
operator|--
expr_stmt|;
name|FI
comment|/* fall through */
case|case
literal|'>'
case|:
block|{
name|CHAR
name|file
index|[
literal|64
index|]
decl_stmt|;
name|CHAR
name|Ifile
index|[
literal|128
index|]
decl_stmt|;
specifier|extern
name|CHAR
modifier|*
name|Ipath
decl_stmt|;
name|INT
name|index
decl_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|IF
name|modif
operator|==
literal|'<'
name|THEN
name|iclose
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ELSE
name|oclose
parameter_list|()
function_decl|;
name|FI
name|IF
name|rdc
argument_list|()
operator|!=
name|EOR
name|THEN
name|REP
name|file
index|[
name|index
operator|++
index|]
operator|=
name|lastc
expr_stmt|;
name|IF
name|index
operator|>=
literal|63
name|THEN
name|error
argument_list|(
name|LONGFIL
argument_list|)
expr_stmt|;
name|FI
name|PER
name|readchar
argument_list|()
operator|!=
name|EOR
name|DONE
name|file
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|IF
name|modif
operator|==
literal|'<'
name|THEN
name|IF
name|Ipath
name|THEN
name|strcpy
argument_list|(
name|Ifile
argument_list|,
name|Ipath
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|Ifile
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|Ifile
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|FI
name|infile
init|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|IF
name|infile
operator|<
literal|0
operator|&&
operator|(
name|infile
operator|=
name|open
argument_list|(
name|Ifile
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
name|THEN
name|infile
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
name|NOTOPEN
argument_list|)
expr_stmt|;
name|ELSE
name|IF
name|cntflg
name|THEN
name|var
index|[
literal|9
index|]
init|=
name|cntval
decl_stmt|;
name|ELSE
name|var
index|[
literal|9
index|]
init|=
literal|1
decl_stmt|;
name|FI
name|FI
name|ELSE
name|outfile
init|=
name|open
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|IF
name|outfile
operator|<
literal|0
name|THEN
name|outfile
operator|=
name|creat
argument_list|(
name|file
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|EDDT
name|ELSE
name|lseek
argument_list|(
name|outfile
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|FI
name|FI
name|ELSE
name|IF
name|modif
operator|==
literal|'<'
name|THEN
name|iclose
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FI
name|FI
name|lp
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|adrflg
condition|)
block|{
if|if
condition|(
name|adrval
operator|<
literal|2
operator|||
name|adrval
operator|>
literal|16
condition|)
block|{
name|printf
argument_list|(
literal|"must have 2<= radix<= 16"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"radix=%d base ten"
argument_list|,
name|radix
operator|=
name|adrval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'%'
case|:
name|done
argument_list|()
expr_stmt|;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|maxpos
operator|=
operator|(
name|adrflg
condition|?
name|adrval
else|:
name|MAXPOS
operator|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|maxoff
operator|=
operator|(
name|adrflg
condition|?
name|adrval
else|:
name|MAXOFF
operator|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|prints
argument_list|(
literal|"variables\n"
argument_list|)
expr_stmt|;
name|FOR
name|i
init|=
literal|0
decl_stmt|;
name|i
operator|<=
literal|35
expr_stmt|;
name|i
operator|++
name|DO
name|IF
name|var
index|[
name|i
index|]
name|THEN
name|printc
argument_list|(
operator|(
name|i
operator|<=
literal|9
condition|?
literal|'0'
else|:
literal|'a'
operator|-
literal|10
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = %Q\n"
argument_list|,
name|var
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FI
name|OD
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|printmap
argument_list|(
literal|"? map"
argument_list|,
operator|&
name|txtmap
argument_list|)
expr_stmt|;
name|printmap
argument_list|(
literal|"/ map"
argument_list|,
operator|&
name|datmap
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
literal|'?'
case|:
name|IF
name|pid
name|THEN
name|printf
argument_list|(
literal|"pcs id = %d\n"
argument_list|,
name|pid
argument_list|)
decl_stmt|;
name|ELSE
name|prints
argument_list|(
literal|"no process\n"
argument_list|)
decl_stmt|;
name|FI
name|sigprint
parameter_list|()
function_decl|;
name|flushbuf
argument_list|()
expr_stmt|;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|printregs
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
name|IF
name|adrflg
name|THEN
name|frame
init|=
name|adrval
decl_stmt|;
name|word
operator|=
name|get
argument_list|(
name|adrval
operator|+
literal|6
argument_list|,
name|DSP
argument_list|)
operator|&
literal|0xFFFF
expr_stmt|;
name|IF
name|word
operator|&
literal|0x2000
name|THEN
comment|/* 'calls', can figure out argp */
name|argp
operator|=
name|adrval
operator|+
literal|20
operator|+
operator|(
operator|(
name|word
operator|>>
literal|14
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
name|word
operator|&=
literal|0xFFF
expr_stmt|;
name|WHILE
name|word
name|DO
name|IF
name|word
operator|&
literal|1
name|THEN
name|argp
operator|+=
literal|4
expr_stmt|;
name|FI
name|word
operator|>>=
literal|1
expr_stmt|;
name|OD
name|ELSE
comment|/* 'callg', can't tell where argp is */
name|argp
init|=
name|frame
decl_stmt|;
name|FI
name|callpc
init|=
name|get
argument_list|(
name|frame
operator|+
literal|16
argument_list|,
name|DSP
argument_list|)
decl_stmt|;
name|ELSE
name|argp
init|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|AP
operator|)
decl_stmt|;
name|frame
operator|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|FP
operator|)
expr_stmt|;
name|callpc
operator|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|PC
operator|)
expr_stmt|;
name|FI
name|lastframe
init|=
literal|0
decl_stmt|;
name|ntramp
operator|=
literal|0
expr_stmt|;
name|WHILE
name|cntval
operator|--
name|DO
name|char
operator|*
name|name
expr_stmt|;
name|chkerr
argument_list|()
expr_stmt|;
if|if
condition|(
name|callpc
operator|>
literal|0x80000000
operator|-
literal|0x200
operator|*
name|UPAGES
condition|)
block|{
name|name
operator|=
literal|"sigtramp"
expr_stmt|;
name|ntramp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ntramp
operator|=
literal|0
expr_stmt|;
name|findsym
argument_list|(
name|callpc
argument_list|,
name|ISYM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|&&
operator|!
name|strcmp
argument_list|(
name|cursym
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
literal|"start"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cursym
condition|)
name|name
operator|=
name|cursym
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
else|else
name|name
operator|=
literal|"?"
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s("
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|narg
operator|=
name|get
argument_list|(
name|argp
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|IF
name|narg
operator|&
operator|~
literal|0xFF
name|THEN
name|narg
operator|=
literal|0
expr_stmt|;
name|FI
name|LOOP
name|IF
name|narg
operator|==
literal|0
name|THEN
break|break;
name|FI
name|printf
argument_list|(
literal|"%R"
argument_list|,
name|get
argument_list|(
name|argp
operator|+=
literal|4
argument_list|,
name|DSP
argument_list|)
argument_list|)
decl_stmt|;
name|IF
operator|--
name|narg
operator|!=
literal|0
name|THEN
name|printc
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|FI
name|POOL
name|printf
argument_list|(
literal|") from %X\n"
argument_list|,
name|callpc
argument_list|)
decl_stmt|;
comment|/* jkf mod */
name|IF
name|modif
operator|==
literal|'C'
name|THEN
name|WHILE
name|localsym
argument_list|(
argument|frame
argument_list|,
argument|argp
argument_list|)
name|DO
name|word
operator|=
name|get
argument_list|(
name|localval
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%8t%s:%10t"
argument_list|,
name|cursym
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|IF
name|errflg
name|THEN
name|prints
argument_list|(
literal|"?\n"
argument_list|)
decl_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
name|ELSE
name|printf
argument_list|(
literal|"%R\n"
argument_list|,
name|word
argument_list|)
decl_stmt|;
name|FI
name|OD
name|FI
if|if
condition|(
name|ntramp
operator|==
literal|1
condition|)
name|callpc
operator|=
name|get
argument_list|(
name|frame
operator|+
literal|64
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
else|else
name|callpc
operator|=
name|get
argument_list|(
name|frame
operator|+
literal|16
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|argp
operator|=
name|get
argument_list|(
name|frame
operator|+
literal|8
argument_list|,
name|DSP
argument_list|)
expr_stmt|;
name|lastframe
operator|=
name|frame
expr_stmt|;
name|frame
operator|=
name|get
argument_list|(
name|frame
operator|+
literal|12
argument_list|,
name|DSP
argument_list|)
operator|&
name|EVEN
expr_stmt|;
name|IF
name|frame
operator|==
literal|0
name|ORF
argument_list|(
argument|!adrflg ANDF !INSTACK(frame)
argument_list|)
name|THEN
break|break;
name|FI
name|OD
break|break;
comment|/*print externals*/
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|esymtab
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|n_type
operator|==
operator|(
name|N_DATA
operator||
name|N_EXT
operator|)
name|ORF
name|sp
operator|->
name|n_type
operator|==
operator|(
name|N_BSS
operator||
name|N_EXT
operator|)
condition|)
name|printf
argument_list|(
literal|"%s:%12t%R\n"
argument_list|,
name|sp
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
name|get
argument_list|(
name|sp
operator|->
name|n_value
argument_list|,
name|DSP
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
name|error
argument_list|(
literal|"No algol 68 on VAX"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
comment|/*print breakpoints*/
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|printf
argument_list|(
literal|"breakpoints\ncount%8tbkpt%24tcommand\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bkptr
operator|=
name|bkpthead
init|;
name|bkptr
condition|;
name|bkptr
operator|=
name|bkptr
operator|->
name|nxtbkpt
control|)
if|if
condition|(
name|bkptr
operator|->
name|flag
condition|)
block|{
name|printf
argument_list|(
literal|"%-8.8d"
argument_list|,
name|bkptr
operator|->
name|count
argument_list|)
expr_stmt|;
name|psymoff
argument_list|(
name|leng
argument_list|(
name|bkptr
operator|->
name|loc
argument_list|)
argument_list|,
name|ISYM
argument_list|,
literal|"%24t"
argument_list|)
expr_stmt|;
name|comptr
operator|=
name|bkptr
operator|->
name|comm
expr_stmt|;
name|WHILE
modifier|*
name|comptr
name|DO
name|printc
argument_list|(
operator|*
name|comptr
operator|++
argument_list|)
decl_stmt|;
name|OD
block|}
break|break;
default|default:
name|error
argument_list|(
name|BADMOD
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|printmap
argument_list|(
argument|s
argument_list|,
argument|amap
argument_list|)
end_macro

begin_decl_stmt
name|STRING
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAP
modifier|*
name|amap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|file
decl_stmt|;
name|file
operator|=
name|amap
operator|->
name|ufd
expr_stmt|;
name|printf
argument_list|(
literal|"%s%12t`%s'\n"
argument_list|,
name|s
argument_list|,
operator|(
name|file
operator|<
literal|0
condition|?
literal|"-"
else|:
operator|(
name|file
operator|==
name|fcor
condition|?
name|corfil
else|:
name|symfil
operator|)
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"b1 = %-16R"
argument_list|,
name|amap
operator|->
name|b1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"e1 = %-16R"
argument_list|,
name|amap
operator|->
name|e1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"f1 = %-16R"
argument_list|,
name|amap
operator|->
name|f1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nb2 = %-16R"
argument_list|,
name|amap
operator|->
name|b2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"e2 = %-16R"
argument_list|,
name|amap
operator|->
name|e2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"f2 = %-16R"
argument_list|,
name|amap
operator|->
name|f2
argument_list|)
expr_stmt|;
name|printc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|printregs
argument_list|()
end_macro

begin_block
block|{
name|REG
name|REGPTR
name|p
decl_stmt|;
name|L_INT
name|v
decl_stmt|;
name|FOR
name|p
init|=
name|reglist
decl_stmt|;
name|p
operator|<
operator|&
name|reglist
index|[
literal|24
index|]
expr_stmt|;
name|p
operator|++
name|DO
name|printf
argument_list|(
literal|"%s%6t%R %16t"
argument_list|,
name|p
operator|->
name|rname
argument_list|,
name|v
operator|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|p
operator|->
name|roffs
operator|)
argument_list|)
expr_stmt|;
name|valpr
argument_list|(
name|v
argument_list|,
operator|(
name|p
operator|->
name|roffs
operator|==
name|PC
condition|?
name|ISYM
else|:
name|DSYM
operator|)
argument_list|)
expr_stmt|;
name|printc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
name|OD
name|printpc
parameter_list|()
function_decl|;
block|}
end_block

begin_macro
name|getreg
argument_list|(
argument|regnam
argument_list|)
end_macro

begin_block
block|{
name|REG
name|REGPTR
name|p
decl_stmt|;
name|REG
name|STRING
name|regptr
decl_stmt|;
name|CHAR
modifier|*
name|olp
decl_stmt|;
name|CHAR
name|regnxt
decl_stmt|;
name|olp
operator|=
name|lp
expr_stmt|;
name|FOR
name|p
init|=
name|reglist
decl_stmt|;
name|p
operator|<
operator|&
name|reglist
index|[
literal|24
index|]
expr_stmt|;
name|p
operator|++
name|DO
name|regptr
operator|=
name|p
operator|->
name|rname
expr_stmt|;
name|IF
argument_list|(
argument|regnam == *regptr++
argument_list|)
name|THEN
name|WHILE
modifier|*
name|regptr
name|DO
name|IF
argument_list|(
name|regnxt
operator|=
name|readchar
argument_list|()
argument_list|)
decl|!=
modifier|*
name|regptr
decl|++
name|THEN
decl|--
name|regptr
decl_stmt|;
break|break;
name|FI
name|OD
name|IF
modifier|*
name|regptr
name|THEN
name|lp
init|=
name|olp
decl_stmt|;
name|ELSE
return|return
operator|(
name|p
operator|->
name|roffs
operator|)
return|;
name|FI
name|FI
name|OD
name|lp
init|=
name|olp
decl_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|printpc
argument_list|()
end_macro

begin_block
block|{
name|dot
operator|=
operator|*
operator|(
name|ADDR
operator|*
operator|)
operator|(
operator|(
operator|(
name|ADDR
operator|)
operator|&
name|u
operator|)
operator|+
name|PC
operator|)
expr_stmt|;
name|psymoff
argument_list|(
name|dot
argument_list|,
name|ISYM
argument_list|,
literal|":%16t"
argument_list|)
expr_stmt|;
name|printins
argument_list|(
literal|0
argument_list|,
name|ISP
argument_list|,
name|chkget
argument_list|(
name|dot
argument_list|,
name|ISP
argument_list|)
argument_list|)
expr_stmt|;
name|printc
argument_list|(
name|EOR
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|illinames
index|[]
init|=
block|{
literal|"reserved addressing fault"
block|,
literal|"priviliged instruction fault"
block|,
literal|"reserved operand fault"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fpenames
index|[]
init|=
block|{
literal|0
block|,
literal|"integer overflow trap"
block|,
literal|"integer divide by zero trap"
block|,
literal|"floating overflow trap"
block|,
literal|"floating/decimal divide by zero trap"
block|,
literal|"floating underflow trap"
block|,
literal|"decimal overflow trap"
block|,
literal|"subscript out of range trap"
block|,
literal|"floating overflow fault"
block|,
literal|"floating divide by zero fault"
block|,
literal|"floating undeflow fault"
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|sigprint
argument_list|()
end_macro

begin_block
block|{
name|IF
argument_list|(
argument|signo>=
literal|0
argument_list|)
name|ANDF
argument_list|(
argument|signo<sizeof signals/sizeof signals[
literal|0
argument|]
argument_list|)
name|THEN
name|prints
parameter_list|(
name|signals
index|[
name|signo
index|]
parameter_list|)
function_decl|;
name|FI
switch|switch
condition|(
name|signo
condition|)
block|{
case|case
name|SIGFPE
case|:
name|IF
argument_list|(
argument|sigcode>
literal|0
argument|&& 		    sigcode< sizeof fpenames / sizeof fpenames[
literal|0
argument|]
argument_list|)
name|THEN
name|prints
argument_list|(
literal|" ("
argument_list|)
decl_stmt|;
name|prints
argument_list|(
name|fpenames
index|[
name|sigcode
index|]
argument_list|)
expr_stmt|;
name|prints
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|FI
break|break;
case|case
name|SIGILL
case|:
name|IF
argument_list|(
argument|sigcode>=
literal|0
argument|&& 		    sigcode< sizeof illinames / sizeof illinames[
literal|0
argument|]
argument_list|)
name|THEN
name|prints
argument_list|(
literal|" ("
argument_list|)
decl_stmt|;
name|prints
argument_list|(
name|illinames
index|[
name|sigcode
index|]
argument_list|)
expr_stmt|;
name|prints
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|FI
break|break;
block|}
block|}
end_block

end_unit

