begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * This module is believed to contain source code proprietary to AT&T.  * Use and redistribution is subject to the Berkeley Software License  * Agreement and your Software Agreement with AT&T (Western Electric).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)b.c	4.4 (Berkeley) 4/17/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"awk.def"
end_include

begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_function_decl
specifier|extern
name|node
modifier|*
name|op2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|fa
modifier|*
name|cgotofn
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAXLIN
value|256
end_define

begin_define
define|#
directive|define
name|NCHARS
value|128
end_define

begin_define
define|#
directive|define
name|NSTATES
value|256
end_define

begin_define
define|#
directive|define
name|type
parameter_list|(
name|v
parameter_list|)
value|v->nobj
end_define

begin_define
define|#
directive|define
name|left
parameter_list|(
name|v
parameter_list|)
value|v->narg[0]
end_define

begin_define
define|#
directive|define
name|right
parameter_list|(
name|v
parameter_list|)
value|v->narg[1]
end_define

begin_define
define|#
directive|define
name|parent
parameter_list|(
name|v
parameter_list|)
value|v->nnext
end_define

begin_define
define|#
directive|define
name|LEAF
value|case CCL: case NCCL: case CHAR: case DOT:
end_define

begin_define
define|#
directive|define
name|UNARY
value|case FINAL: case STAR: case PLUS: case QUEST:
end_define

begin_comment
comment|/* encoding in tree nodes: 	leaf (CCL, NCCL, CHAR, DOT): left is index, right contains value or pointer to value 	unary (FINAL, STAR, PLUS, QUEST): left is child, right is null 	binary (CAT, OR): left and right are children 	parent contains pointer to parent */
end_comment

begin_struct
struct|struct
name|fa
block|{
name|int
name|cch
decl_stmt|;
name|struct
name|fa
modifier|*
name|st
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|state
index|[
name|NSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|foll
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|chars
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|setvec
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|node
modifier|*
name|point
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|setcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxfoll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of highest foll[] entry set by cfoll() */
end_comment

begin_function
name|struct
name|fa
modifier|*
name|makedfa
parameter_list|(
name|p
parameter_list|)
comment|/* returns dfa for tree pointed to by p */
name|node
modifier|*
name|p
decl_stmt|;
block|{
name|node
modifier|*
name|p1
decl_stmt|;
name|struct
name|fa
modifier|*
name|fap
decl_stmt|;
name|p1
operator|=
name|op2
argument_list|(
name|CAT
argument_list|,
name|op2
argument_list|(
name|STAR
argument_list|,
name|op2
argument_list|(
name|DOT
argument_list|,
operator|(
name|node
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|node
operator|*
operator|)
literal|0
argument_list|)
argument_list|,
operator|(
name|node
operator|*
operator|)
literal|0
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* put DOT STAR in front of reg. exp. */
name|p1
operator|=
name|op2
argument_list|(
name|FINAL
argument_list|,
name|p1
argument_list|,
operator|(
name|node
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* install FINAL node */
name|line
operator|=
literal|0
expr_stmt|;
name|penter
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/* enter parent pointers and leaf indices */
name|point
index|[
name|line
index|]
operator|=
name|p1
expr_stmt|;
comment|/* FINAL node */
name|setvec
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* for initial DOT STAR */
name|cfoll
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/* set up follow sets */
name|fap
operator|=
name|cgotofn
argument_list|()
expr_stmt|;
name|freetr
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/* add this when alloc works */
return|return
operator|(
name|fap
operator|)
return|;
block|}
end_function

begin_macro
name|penter
argument_list|(
argument|p
argument_list|)
end_macro

begin_comment
comment|/* set up parent pointers and leaf indices */
end_comment

begin_decl_stmt
name|node
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|type
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|LEAF
name|left
parameter_list|(
name|p
parameter_list|)
init|=
operator|(
name|node
operator|*
operator|)
name|line
function_decl|;
name|point
index|[
name|line
operator|++
index|]
operator|=
name|p
expr_stmt|;
break|break;
name|UNARY
name|penter
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|parent
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
name|p
expr_stmt|;
break|break;
case|case
name|CAT
case|:
case|case
name|OR
case|:
name|penter
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|penter
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|parent
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
name|p
expr_stmt|;
name|parent
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
name|p
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown type %d in penter\n"
argument_list|,
name|type
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|freetr
argument_list|(
argument|p
argument_list|)
end_macro

begin_comment
comment|/* free parse tree and follow sets */
end_comment

begin_decl_stmt
name|node
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|type
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|LEAF
name|foll_free
argument_list|(
operator|(
name|int
operator|)
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
name|UNARY
name|freetr
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAT
case|:
case|case
name|OR
case|:
name|freetr
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|freetr
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown type %d in freetr"
argument_list|,
name|type
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|cclenter
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|i
operator|,
name|c
expr_stmt|;
name|char
modifier|*
name|op
decl_stmt|;
name|op
operator|=
name|p
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
name|i
operator|>
literal|0
operator|&&
name|chars
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
name|chars
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|c
operator|<
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|MAXLIN
condition|)
name|overflo
argument_list|()
expr_stmt|;
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|++
name|c
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|MAXLIN
condition|)
name|overflo
argument_list|()
expr_stmt|;
name|chars
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|chars
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dprintf
argument_list|(
literal|"cclenter: in = |%s|, out = |%s|\n"
argument_list|,
name|op
argument_list|,
name|chars
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|tostring
argument_list|(
name|chars
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|overflo
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"regular expression too long\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|cfoll
argument_list|(
name|v
argument_list|)
comment|/* enter follow set of each leaf of vertex v into foll[leaf] */
specifier|register
name|node
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|int
name|prev
decl_stmt|;
name|int
modifier|*
name|add
parameter_list|()
function_decl|;
name|maxfoll
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|type
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|LEAF
name|setcnt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|line
condition|;
name|i
operator|++
control|)
name|setvec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|follow
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|notin
argument_list|(
name|foll
argument_list|,
operator|(
operator|(
name|int
operator|)
name|left
argument_list|(
name|v
argument_list|)
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|prev
argument_list|)
condition|)
block|{
name|foll
index|[
operator|(
name|int
operator|)
name|left
argument_list|(
name|v
argument_list|)
index|]
operator|=
name|add
argument_list|(
name|setcnt
argument_list|)
expr_stmt|;
block|}
else|else
name|foll
index|[
operator|(
name|int
operator|)
name|left
argument_list|(
name|v
argument_list|)
index|]
operator|=
name|foll
index|[
name|prev
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|left
argument_list|(
name|v
argument_list|)
operator|>
name|maxfoll
condition|)
name|maxfoll
operator|=
operator|(
name|int
operator|)
name|left
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
name|UNARY
name|cfoll
argument_list|(
name|left
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
break|break;
case|case
name|CAT
case|:
case|case
name|OR
case|:
name|cfoll
argument_list|(
name|left
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|cfoll
argument_list|(
name|right
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown type %d in cfoll"
argument_list|,
name|type
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|first
argument_list|(
name|p
argument_list|)
comment|/* collects initially active leaves of p into setvec */
specifier|register
name|node
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* returns 0 or 1 depending on whether p matches empty string */
end_comment

begin_block
block|{
specifier|register
name|b
expr_stmt|;
switch|switch
condition|(
name|type
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|LEAF
if|if
condition|(
name|setvec
index|[
operator|(
name|int
operator|)
name|left
argument_list|(
name|p
argument_list|)
index|]
operator|!=
literal|1
condition|)
block|{
name|setvec
index|[
operator|(
name|int
operator|)
name|left
argument_list|(
name|p
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
name|setcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|CCL
operator|&&
operator|(
operator|*
operator|(
name|char
operator|*
operator|)
name|right
argument_list|(
name|p
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* empty CCL */
else|else
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|FINAL
case|:
case|case
name|PLUS
case|:
if|if
condition|(
name|first
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|STAR
case|:
case|case
name|QUEST
case|:
name|first
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CAT
case|:
if|if
condition|(
name|first
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|first
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|OR
case|:
name|b
operator|=
name|first
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|b
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown type %d in first\n"
argument_list|,
name|type
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|follow
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|node
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* collects leaves that can follow v into setvec */
end_comment

begin_block
block|{
name|node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|type
argument_list|(
name|v
argument_list|)
operator|==
name|FINAL
condition|)
return|return;
name|p
operator|=
name|parent
argument_list|(
name|v
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|STAR
case|:
case|case
name|PLUS
case|:
name|first
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|OR
case|:
case|case
name|QUEST
case|:
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|CAT
case|:
if|if
condition|(
name|v
operator|==
name|left
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* v is left child of p */
if|if
condition|(
name|first
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
comment|/* v is right child */
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|FINAL
case|:
if|if
condition|(
name|setvec
index|[
name|line
index|]
operator|!=
literal|1
condition|)
block|{
name|setvec
index|[
name|line
index|]
operator|=
literal|1
expr_stmt|;
name|setcnt
operator|++
expr_stmt|;
block|}
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|member
argument_list|(
name|c
argument_list|,
name|s
argument_list|)
comment|/* is c in s? */
specifier|register
name|char
name|c
operator|,
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|c
operator|==
operator|*
name|s
operator|++
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|notin
argument_list|(
argument|array
argument_list|,
argument|n
argument_list|,
argument|prev
argument_list|)
end_macro

begin_comment
comment|/* is setvec in array[0] thru array[n]? */
end_comment

begin_decl_stmt
name|int
modifier|*
modifier|*
name|array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|prev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|int
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
name|array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|setcnt
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|setcnt
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|setvec
index|[
operator|*
operator|(
operator|++
name|ptr
operator|)
index|]
operator|!=
literal|1
condition|)
goto|goto
name|nxt
goto|;
operator|*
name|prev
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nxt
label|:
empty_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|int
modifier|*
name|add
parameter_list|(
name|n
parameter_list|)
block|{
comment|/* remember setvec */
name|int
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|ptr
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|()
expr_stmt|;
operator|*
name|ptr
operator|=
name|n
expr_stmt|;
name|dprintf
argument_list|(
literal|"add(%d)\n"
argument_list|,
name|n
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|line
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|setvec
index|[
name|i
index|]
operator|==
literal|1
condition|)
block|{
operator|*
operator|(
operator|++
name|ptr
operator|)
operator|=
name|i
expr_stmt|;
name|dprintf
argument_list|(
literal|"  ptr = %o, *ptr = %d, i = %d\n"
argument_list|,
name|ptr
argument_list|,
operator|*
name|ptr
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|"\n"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|fa
modifier|*
name|cgotofn
parameter_list|()
block|{
specifier|register
name|i
operator|,
name|k
expr_stmt|;
specifier|register
name|int
modifier|*
name|ptr
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|node
modifier|*
name|cp
decl_stmt|;
name|int
name|j
decl_stmt|,
name|n
decl_stmt|,
name|s
decl_stmt|,
name|ind
decl_stmt|,
name|numtrans
decl_stmt|;
name|int
name|finflg
decl_stmt|;
name|int
name|curpos
decl_stmt|,
name|num
decl_stmt|,
name|prev
decl_stmt|;
name|struct
name|fa
modifier|*
name|where
index|[
name|NSTATES
index|]
decl_stmt|;
name|int
name|fatab
index|[
literal|257
index|]
decl_stmt|;
name|struct
name|fa
modifier|*
name|pfa
decl_stmt|;
name|char
name|index
index|[
name|MAXLIN
index|]
decl_stmt|;
name|char
name|iposns
index|[
name|MAXLIN
index|]
decl_stmt|;
name|int
name|sposns
index|[
name|MAXLIN
index|]
decl_stmt|;
name|int
name|spmax
decl_stmt|,
name|spinit
decl_stmt|;
name|char
name|symbol
index|[
name|NCHARS
index|]
decl_stmt|;
name|char
name|isyms
index|[
name|NCHARS
index|]
decl_stmt|;
name|char
name|ssyms
index|[
name|NCHARS
index|]
decl_stmt|;
name|int
name|ssmax
decl_stmt|,
name|ssinit
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|line
condition|;
name|i
operator|++
control|)
name|index
index|[
name|i
index|]
operator|=
name|iposns
index|[
name|i
index|]
operator|=
name|setvec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
name|isyms
index|[
name|i
index|]
operator|=
name|symbol
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|setcnt
operator|=
literal|0
expr_stmt|;
comment|/* compute initial positions and symbols of state 0 */
name|ssmax
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|state
index|[
literal|0
index|]
operator|=
name|foll
index|[
literal|0
index|]
expr_stmt|;
name|spinit
operator|=
operator|*
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spinit
condition|;
name|i
operator|++
control|)
block|{
name|curpos
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
expr_stmt|;
name|sposns
index|[
name|i
index|]
operator|=
name|curpos
expr_stmt|;
name|iposns
index|[
name|curpos
index|]
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|point
index|[
name|curpos
index|]
expr_stmt|;
name|dprintf
argument_list|(
literal|"i = %d, spinit = %d, curpos = %d\n"
argument_list|,
name|i
argument_list|,
name|spinit
argument_list|,
name|curpos
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
argument_list|(
name|cp
argument_list|)
condition|)
block|{
case|case
name|CHAR
case|:
name|k
operator|=
operator|(
name|int
operator|)
name|right
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isyms
index|[
name|k
index|]
operator|!=
literal|1
condition|)
block|{
name|isyms
index|[
name|k
index|]
operator|=
literal|1
expr_stmt|;
name|ssyms
index|[
name|ssmax
operator|++
index|]
operator|=
name|k
expr_stmt|;
block|}
break|break;
case|case
name|DOT
case|:
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|NCHARS
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|!=
name|HAT
condition|)
block|{
if|if
condition|(
name|isyms
index|[
name|k
index|]
operator|!=
literal|1
condition|)
block|{
name|isyms
index|[
name|k
index|]
operator|=
literal|1
expr_stmt|;
name|ssyms
index|[
name|ssmax
operator|++
index|]
operator|=
name|k
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|CCL
case|:
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|right
argument_list|(
name|cp
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
name|HAT
condition|)
block|{
if|if
condition|(
name|isyms
index|[
operator|*
name|p
index|]
operator|!=
literal|1
condition|)
block|{
name|isyms
index|[
operator|*
name|p
index|]
operator|=
literal|1
expr_stmt|;
name|ssyms
index|[
name|ssmax
operator|++
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|NCCL
case|:
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|NCHARS
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|!=
name|HAT
operator|&&
operator|!
name|member
argument_list|(
name|k
argument_list|,
operator|(
name|char
operator|*
operator|)
name|right
argument_list|(
name|cp
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|isyms
index|[
name|k
index|]
operator|!=
literal|1
condition|)
block|{
name|isyms
index|[
name|k
index|]
operator|=
literal|1
expr_stmt|;
name|ssyms
index|[
name|ssmax
operator|++
index|]
operator|=
name|k
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|ssinit
operator|=
name|ssmax
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|n
condition|;
name|s
operator|++
control|)
block|{
name|dprintf
argument_list|(
literal|"s = %d\n"
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ind
operator|=
literal|0
expr_stmt|;
name|numtrans
operator|=
literal|0
expr_stmt|;
name|finflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|state
index|[
name|s
index|]
operator|+
operator|*
name|state
index|[
name|s
index|]
operator|)
operator|==
name|line
condition|)
block|{
comment|/* s final? */
name|finflg
operator|=
literal|1
expr_stmt|;
goto|goto
name|tenter
goto|;
block|}
name|spmax
operator|=
name|spinit
expr_stmt|;
name|ssmax
operator|=
name|ssinit
expr_stmt|;
name|ptr
operator|=
name|state
index|[
name|s
index|]
expr_stmt|;
name|num
operator|=
operator|*
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|curpos
operator|=
operator|*
operator|(
operator|++
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
name|iposns
index|[
name|curpos
index|]
operator|!=
literal|1
operator|&&
name|index
index|[
name|curpos
index|]
operator|!=
literal|1
condition|)
block|{
name|index
index|[
name|curpos
index|]
operator|=
literal|1
expr_stmt|;
name|sposns
index|[
name|spmax
operator|++
index|]
operator|=
name|curpos
expr_stmt|;
block|}
name|cp
operator|=
name|point
index|[
name|curpos
index|]
expr_stmt|;
switch|switch
condition|(
name|type
argument_list|(
name|cp
argument_list|)
condition|)
block|{
case|case
name|CHAR
case|:
name|k
operator|=
operator|(
name|int
operator|)
name|right
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isyms
index|[
name|k
index|]
operator|==
literal|0
operator|&&
name|symbol
index|[
name|k
index|]
operator|==
literal|0
condition|)
block|{
name|symbol
index|[
name|k
index|]
operator|=
literal|1
expr_stmt|;
name|ssyms
index|[
name|ssmax
operator|++
index|]
operator|=
name|k
expr_stmt|;
block|}
break|break;
case|case
name|DOT
case|:
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|NCHARS
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|!=
name|HAT
condition|)
block|{
if|if
condition|(
name|isyms
index|[
name|k
index|]
operator|==
literal|0
operator|&&
name|symbol
index|[
name|k
index|]
operator|==
literal|0
condition|)
block|{
name|symbol
index|[
name|k
index|]
operator|=
literal|1
expr_stmt|;
name|ssyms
index|[
name|ssmax
operator|++
index|]
operator|=
name|k
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|CCL
case|:
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|right
argument_list|(
name|cp
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
name|HAT
condition|)
block|{
if|if
condition|(
name|isyms
index|[
operator|*
name|p
index|]
operator|==
literal|0
operator|&&
name|symbol
index|[
operator|*
name|p
index|]
operator|==
literal|0
condition|)
block|{
name|symbol
index|[
operator|*
name|p
index|]
operator|=
literal|1
expr_stmt|;
name|ssyms
index|[
name|ssmax
operator|++
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|NCCL
case|:
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|NCHARS
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|!=
name|HAT
operator|&&
operator|!
name|member
argument_list|(
name|k
argument_list|,
operator|(
name|char
operator|*
operator|)
name|right
argument_list|(
name|cp
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|isyms
index|[
name|k
index|]
operator|==
literal|0
operator|&&
name|symbol
index|[
name|k
index|]
operator|==
literal|0
condition|)
block|{
name|symbol
index|[
name|k
index|]
operator|=
literal|1
expr_stmt|;
name|ssyms
index|[
name|ssmax
operator|++
index|]
operator|=
name|k
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ssmax
condition|;
name|j
operator|++
control|)
block|{
comment|/* nextstate(s, ssyms[j]) */
name|c
operator|=
name|ssyms
index|[
name|j
index|]
expr_stmt|;
name|symbol
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
name|setcnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|line
condition|;
name|k
operator|++
control|)
name|setvec
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spmax
condition|;
name|i
operator|++
control|)
block|{
name|index
index|[
name|sposns
index|[
name|i
index|]
index|]
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|point
index|[
name|sposns
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|type
argument_list|(
name|cp
argument_list|)
operator|)
operator|!=
name|FINAL
condition|)
if|if
condition|(
name|k
operator|==
name|CHAR
operator|&&
name|c
operator|==
operator|(
name|int
operator|)
name|right
argument_list|(
name|cp
argument_list|)
operator|||
name|k
operator|==
name|DOT
operator|||
name|k
operator|==
name|CCL
operator|&&
name|member
argument_list|(
name|c
argument_list|,
operator|(
name|char
operator|*
operator|)
name|right
argument_list|(
name|cp
argument_list|)
argument_list|)
operator|||
name|k
operator|==
name|NCCL
operator|&&
operator|!
name|member
argument_list|(
name|c
argument_list|,
operator|(
name|char
operator|*
operator|)
name|right
argument_list|(
name|cp
argument_list|)
argument_list|)
condition|)
block|{
name|ptr
operator|=
name|foll
index|[
name|sposns
index|[
name|i
index|]
index|]
expr_stmt|;
name|num
operator|=
operator|*
name|ptr
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|setvec
index|[
operator|*
operator|(
operator|++
name|ptr
operator|)
index|]
operator|!=
literal|1
operator|&&
name|iposns
index|[
operator|*
name|ptr
index|]
operator|!=
literal|1
condition|)
block|{
name|setvec
index|[
operator|*
name|ptr
index|]
operator|=
literal|1
expr_stmt|;
name|setcnt
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end nextstate */
if|if
condition|(
name|notin
argument_list|(
name|state
argument_list|,
name|n
argument_list|,
operator|&
name|prev
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|NSTATES
condition|)
block|{
name|dprintf
argument_list|(
literal|"cgotofn: notin; state = %d, n = %d\n"
argument_list|,
name|state
argument_list|,
name|n
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|overflo
argument_list|()
expr_stmt|;
block|}
name|state
index|[
operator|++
name|n
index|]
operator|=
name|add
argument_list|(
name|setcnt
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"	delta(%d,%o) = %d"
argument_list|,
name|s
argument_list|,
name|c
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|", ind = %d\n"
argument_list|,
name|ind
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fatab
index|[
operator|++
name|ind
index|]
operator|=
name|c
expr_stmt|;
name|fatab
index|[
operator|++
name|ind
index|]
operator|=
name|n
expr_stmt|;
name|numtrans
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prev
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|"	delta(%d,%o) = %d"
argument_list|,
name|s
argument_list|,
name|c
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|", ind = %d\n"
argument_list|,
name|ind
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fatab
index|[
operator|++
name|ind
index|]
operator|=
name|c
expr_stmt|;
name|fatab
index|[
operator|++
name|ind
index|]
operator|=
name|prev
expr_stmt|;
name|numtrans
operator|++
expr_stmt|;
block|}
block|}
block|}
name|tenter
label|:
if|if
condition|(
operator|(
name|pfa
operator|=
operator|(
expr|struct
name|fa
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|numtrans
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fa
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|()
expr_stmt|;
name|where
index|[
name|s
index|]
operator|=
name|pfa
expr_stmt|;
if|if
condition|(
name|finflg
condition|)
name|pfa
operator|->
name|cch
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* s is a final state */
else|else
name|pfa
operator|->
name|cch
operator|=
name|numtrans
expr_stmt|;
name|pfa
operator|->
name|st
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|pfa
operator|+=
literal|1
init|;
name|i
operator|<=
name|numtrans
condition|;
name|i
operator|++
operator|,
name|pfa
operator|++
control|)
block|{
name|pfa
operator|->
name|cch
operator|=
name|fatab
index|[
literal|2
operator|*
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|pfa
operator|->
name|st
operator|=
operator|(
expr|struct
name|fa
operator|*
operator|)
name|fatab
index|[
literal|2
operator|*
name|i
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* N.b. state[0] == foll[0], not separately allocated */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|xfree
argument_list|(
name|state
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* free state[i] */
name|pfa
operator|=
name|where
index|[
name|i
index|]
expr_stmt|;
name|pfa
operator|->
name|st
operator|=
name|where
index|[
literal|0
index|]
expr_stmt|;
name|dprintf
argument_list|(
literal|"state %d: (%o)\n"
argument_list|,
name|i
argument_list|,
name|pfa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"	numtrans = %d,	default = %o\n"
argument_list|,
name|pfa
operator|->
name|cch
argument_list|,
name|pfa
operator|->
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|pfa
operator|->
name|cch
condition|;
name|k
operator|++
control|)
block|{
operator|(
name|pfa
operator|+
name|k
operator|)
operator|->
name|st
operator|=
name|where
index|[
call|(
name|int
call|)
argument_list|(
name|pfa
operator|+
name|k
argument_list|)
operator|->
name|st
index|]
expr_stmt|;
name|dprintf
argument_list|(
literal|"	char = %o,	nextstate = %o\n"
argument_list|,
operator|(
name|pfa
operator|+
name|k
operator|)
operator|->
name|cch
argument_list|,
operator|(
name|pfa
operator|+
name|k
operator|)
operator|->
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|pfa
operator|=
name|where
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|num
operator|=
name|pfa
operator|->
name|cch
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|where
index|[
literal|0
index|]
operator|)
return|;
for|for
control|(
name|pfa
operator|+=
name|num
init|;
name|num
condition|;
name|num
operator|--
operator|,
name|pfa
operator|--
control|)
if|if
condition|(
name|pfa
operator|->
name|cch
operator|==
name|HAT
condition|)
block|{
return|return
operator|(
name|pfa
operator|->
name|st
operator|)
return|;
block|}
return|return
operator|(
name|where
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|match
argument_list|(
name|pfa
argument_list|,
name|p
argument_list|)
specifier|register
expr|struct
name|fa
operator|*
name|pfa
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|count
expr_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|pfa
operator|->
name|cch
operator|==
literal|1
condition|)
block|{
comment|/* fast test for first character, if possible */
name|c
operator|=
operator|(
operator|++
name|pfa
operator|)
operator|->
name|cch
expr_stmt|;
do|do
if|if
condition|(
name|c
operator|==
operator|*
name|p
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|pfa
operator|=
name|pfa
operator|->
name|st
expr_stmt|;
goto|goto
name|adv
goto|;
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|adv
label|:
if|if
condition|(
operator|(
name|count
operator|=
name|pfa
operator|->
name|cch
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
do|do
block|{
for|for
control|(
name|pfa
operator|+=
name|count
init|;
name|count
condition|;
name|count
operator|--
operator|,
name|pfa
operator|--
control|)
if|if
condition|(
name|pfa
operator|->
name|cch
operator|==
operator|*
name|p
condition|)
block|{
break|break;
block|}
name|pfa
operator|=
name|pfa
operator|->
name|st
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|=
name|pfa
operator|->
name|cch
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Free foll[i], taking into account identical foll[] entries.  * This is necessary because cfoll() uses the same physical follow set for  * several foll[] entries when the set is identical.  Called by freetr().  */
end_comment

begin_macro
name|foll_free
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|int
modifier|*
name|p
init|=
name|foll
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|maxfoll
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|foll
index|[
name|j
index|]
operator|==
name|p
condition|)
name|foll
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

