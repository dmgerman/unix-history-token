begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.proprietary.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)run.c	4.10 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"sys/param.h"
end_include

begin_include
include|#
directive|include
file|"awk.def"
end_include

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_include
include|#
directive|include
file|"fcntl.h"
end_include

begin_define
define|#
directive|define
name|RECSIZE
value|BUFSIZ
end_define

begin_define
define|#
directive|define
name|FILENUM
value|NOFILE
end_define

begin_struct
struct|struct
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|}
name|files
index|[
name|FILENUM
index|]
struct|;
end_struct

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|obj
name|execute
argument_list|()
decl_stmt|,
name|nodetoobj
argument_list|()
decl_stmt|,
name|fieldel
argument_list|()
decl_stmt|,
name|dopa2
argument_list|()
decl_stmt|,
name|gettemp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PA2NUM
value|29
end_define

begin_decl_stmt
name|int
name|pairstack
index|[
name|PA2NUM
index|]
decl_stmt|,
name|paircnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|node
modifier|*
name|winner
init|=
operator|(
name|node
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXTMP
value|20
end_define

begin_decl_stmt
name|cell
name|tmps
index|[
name|MAXTMP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cell
name|nullval
init|=
block|{
name|EMPTY
block|,
name|EMPTY
block|,
literal|0.0
block|,
name|NUM
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|obj
name|true
init|=
block|{
name|OBOOL
block|,
name|BTRUE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|obj
name|false
init|=
block|{
name|OBOOL
block|,
name|BFALSE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|run
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|execute
argument_list|(
name|winner
argument_list|)
expr_stmt|;
comment|/* Wait for children to complete if output to a pipe. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FILENUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fp
operator|&&
name|files
index|[
name|i
index|]
operator|.
name|type
operator|==
literal|'|'
condition|)
name|pclose
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|obj
name|execute
parameter_list|(
name|u
parameter_list|)
name|node
modifier|*
name|u
decl_stmt|;
block|{
specifier|register
name|obj
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|()
function_decl|;
name|obj
name|x
decl_stmt|;
name|node
modifier|*
name|a
decl_stmt|;
specifier|extern
name|char
modifier|*
name|printname
index|[]
decl_stmt|;
if|if
condition|(
name|u
operator|==
operator|(
name|node
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
for|for
control|(
name|a
operator|=
name|u
init|;
condition|;
name|a
operator|=
name|a
operator|->
name|nnext
control|)
block|{
if|if
condition|(
name|cantexec
argument_list|(
name|a
argument_list|)
condition|)
return|return
operator|(
name|nodetoobj
argument_list|(
name|a
argument_list|)
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ntype
operator|==
name|NPA2
condition|)
name|proc
operator|=
name|dopa2
expr_stmt|;
else|else
block|{
if|if
condition|(
name|notlegal
argument_list|(
name|a
operator|->
name|nobj
argument_list|)
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal statement %o"
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|proc
operator|=
name|proctab
index|[
name|a
operator|->
name|nobj
operator|-
name|FIRSTTOKEN
index|]
expr_stmt|;
block|}
name|x
operator|=
call|(
modifier|*
name|proc
call|)
argument_list|(
name|a
operator|->
name|narg
argument_list|,
name|a
operator|->
name|nobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfld
argument_list|(
name|x
argument_list|)
condition|)
name|fldbld
argument_list|()
expr_stmt|;
if|if
condition|(
name|isexpr
argument_list|(
name|a
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* a statement, goto next statement */
if|if
condition|(
name|isjump
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|nnext
operator|==
operator|(
name|node
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|obj
name|program
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isexit
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|isjump
argument_list|(
name|x
argument_list|)
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unexpected break, continue or next"
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|getrec
argument_list|()
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isexit
argument_list|(
name|x
argument_list|)
condition|)
break|break;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
operator|||
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|iscont
argument_list|(
name|x
argument_list|)
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unexpected break, continue or next"
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|getline
parameter_list|()
block|{
name|obj
name|x
decl_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|setfval
argument_list|(
name|x
operator|.
name|optr
argument_list|,
operator|(
name|awkfloat
operator|)
name|getrec
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|array
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|,
name|y
decl_stmt|;
specifier|extern
name|obj
name|arrayel
parameter_list|()
function_decl|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|y
operator|=
name|arrayel
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|arrayel
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|node
modifier|*
name|a
decl_stmt|;
name|obj
name|b
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|cell
modifier|*
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
name|obj
name|y
decl_stmt|;
name|s
operator|=
name|getsval
argument_list|(
name|b
operator|.
name|optr
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|cell
operator|*
operator|)
name|a
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|->
name|tval
operator|&
name|ARR
operator|)
condition|)
block|{
name|strfree
argument_list|(
name|x
operator|->
name|sval
argument_list|)
expr_stmt|;
name|x
operator|->
name|tval
operator|&=
operator|~
name|STR
expr_stmt|;
name|x
operator|->
name|tval
operator||=
name|ARR
expr_stmt|;
name|x
operator|->
name|sval
operator|=
operator|(
name|char
operator|*
operator|)
name|makesymtab
argument_list|()
expr_stmt|;
block|}
name|y
operator|.
name|optr
operator|=
name|setsymtab
argument_list|(
name|s
argument_list|,
name|tostring
argument_list|(
literal|""
argument_list|)
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
name|x
operator|->
name|sval
argument_list|)
expr_stmt|;
name|y
operator|.
name|otype
operator|=
name|OCELL
expr_stmt|;
name|y
operator|.
name|osub
operator|=
name|CVAR
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|matchop
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isstr
argument_list|(
name|x
argument_list|)
condition|)
name|s
operator|=
name|x
operator|.
name|optr
operator|->
name|sval
expr_stmt|;
else|else
name|s
operator|=
name|getsval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|i
operator|=
name|match
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|MATCH
operator|&&
name|i
operator|==
literal|1
operator|||
name|n
operator|==
name|NOTMATCH
operator|&&
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|boolop
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|istrue
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown boolean operator %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
case|case
name|BOR
case|:
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|istrue
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|AND
case|:
if|if
condition|(
operator|!
name|i
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|istrue
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|NOT
case|:
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|false
operator|)
return|;
else|else
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
end_function

begin_function
name|obj
name|relop
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|obj
name|x
decl_stmt|,
name|y
decl_stmt|;
name|awkfloat
name|j
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|optr
operator|->
name|tval
operator|&
name|NUM
operator|&&
name|y
operator|.
name|optr
operator|->
name|tval
operator|&
name|NUM
condition|)
block|{
name|j
operator|=
name|x
operator|.
name|optr
operator|->
name|fval
operator|-
name|y
operator|.
name|optr
operator|->
name|fval
expr_stmt|;
name|i
operator|=
name|j
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
operator|(
name|j
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|strcmp
argument_list|(
name|getsval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
argument_list|,
name|getsval
argument_list|(
name|y
operator|.
name|optr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown relational operator %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
case|case
name|LT
case|:
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|LE
case|:
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|NE
case|:
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|EQ
case|:
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|GE
case|:
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|GT
case|:
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
block|}
block|}
end_function

begin_macro
name|tempfree
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|obj
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|istemp
argument_list|(
name|a
argument_list|)
condition|)
return|return;
name|strfree
argument_list|(
name|a
operator|.
name|optr
operator|->
name|sval
argument_list|)
expr_stmt|;
name|a
operator|.
name|optr
operator|->
name|tval
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|obj
name|gettemp
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|obj
name|x
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXTMP
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tmps
index|[
name|i
index|]
operator|.
name|tval
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|MAXTMP
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"out of temporaries in gettemp"
argument_list|)
expr_stmt|;
name|x
operator|.
name|optr
operator|=
operator|&
name|tmps
index|[
name|i
index|]
expr_stmt|;
name|tmps
index|[
name|i
index|]
operator|=
name|nullval
expr_stmt|;
name|x
operator|.
name|otype
operator|=
name|OCELL
expr_stmt|;
name|x
operator|.
name|osub
operator|=
name|CTEMP
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|indirect
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
name|int
name|m
decl_stmt|;
name|cell
modifier|*
name|fieldadr
parameter_list|()
function_decl|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|m
operator|=
name|getfval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|.
name|optr
operator|=
name|fieldadr
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|x
operator|.
name|otype
operator|=
name|OCELL
expr_stmt|;
name|x
operator|.
name|osub
operator|=
name|CFLD
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|substr
parameter_list|(
name|a
parameter_list|,
name|nnn
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
name|temp
decl_stmt|;
name|obj
name|x
decl_stmt|;
name|int
name|k
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|s
operator|=
name|getsval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
name|k
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|m
operator|=
name|getfval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0
condition|)
name|m
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|>
name|k
condition|)
name|m
operator|=
name|k
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|!=
name|nullstat
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|n
operator|=
name|getfval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|n
operator|=
name|k
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
name|k
operator|-
name|m
condition|)
name|n
operator|=
name|k
operator|-
name|m
expr_stmt|;
name|dprintf
argument_list|(
literal|"substr: m=%d, n=%d, s=%s\n"
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|temp
operator|=
name|s
index|[
name|n
operator|+
name|m
operator|-
literal|1
index|]
expr_stmt|;
comment|/* with thanks to John Linderman */
name|s
index|[
name|n
operator|+
name|m
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|setsval
argument_list|(
name|x
operator|.
name|optr
argument_list|,
name|s
operator|+
name|m
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
index|[
name|n
operator|+
name|m
operator|-
literal|1
index|]
operator|=
name|temp
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|sindex
parameter_list|(
name|a
parameter_list|,
name|nnn
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|s1
operator|=
name|getsval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|s2
operator|=
name|getsval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|s1
init|;
operator|*
name|p1
operator|!=
literal|'\0'
condition|;
name|p1
operator|++
control|)
block|{
for|for
control|(
name|q
operator|=
name|p1
operator|,
name|p2
operator|=
name|s2
init|;
operator|*
name|p2
operator|!=
literal|'\0'
operator|&&
operator|*
name|q
operator|==
operator|*
name|p2
condition|;
name|q
operator|++
operator|,
name|p2
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p2
operator|==
literal|'\0'
condition|)
block|{
name|setfval
argument_list|(
name|x
operator|.
name|optr
argument_list|,
call|(
name|awkfloat
call|)
argument_list|(
name|p1
operator|-
name|s1
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* origin 1 */
return|return
operator|(
name|x
operator|)
return|;
block|}
block|}
name|setfval
argument_list|(
name|x
operator|.
name|optr
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|format
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|node
modifier|*
name|a
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|fmt
index|[
literal|200
index|]
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|os
decl_stmt|;
name|obj
name|x
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|awkfloat
name|xf
decl_stmt|;
name|os
operator|=
name|s
expr_stmt|;
name|p
operator|=
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|RECSIZE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|'%'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'%'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'%'
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|t
operator|=
name|fmt
init|;
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|)
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|>=
literal|'a'
operator|&&
operator|*
name|s
operator|<=
literal|'z'
operator|&&
operator|*
name|s
operator|!=
literal|'l'
condition|)
break|break;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|t
operator|>=
name|fmt
operator|+
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"format item %.20s... too long"
argument_list|,
name|os
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'e'
case|:
case|case
literal|'g'
case|:
name|flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|flag
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'l'
condition|)
break|break;
operator|*
operator|(
name|t
operator|-
literal|1
operator|)
operator|=
literal|'l'
expr_stmt|;
operator|*
name|t
operator|=
literal|'d'
expr_stmt|;
operator|*
operator|++
name|t
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'x'
case|:
name|flag
operator|=
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'l'
condition|?
literal|2
else|:
literal|3
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|flag
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|flag
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|flag
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"not enough arguments in printf(%s)"
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|nnext
expr_stmt|;
if|if
condition|(
name|flag
operator|!=
literal|4
condition|)
comment|/* watch out for converting to numbers! */
name|xf
operator|=
name|getfval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
name|xf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
operator|==
literal|2
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
operator|(
name|long
operator|)
name|xf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
operator|==
literal|3
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
operator|(
name|int
operator|)
name|xf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
operator|==
literal|4
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
name|x
operator|.
name|optr
operator|->
name|sval
operator|==
name|NULL
condition|?
literal|""
else|:
name|getsval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|asprintf
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
name|node
modifier|*
name|y
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|y
operator|=
name|a
index|[
literal|0
index|]
operator|->
name|nnext
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|s
operator|=
name|format
argument_list|(
name|getsval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|x
operator|.
name|optr
operator|->
name|sval
operator|=
name|s
expr_stmt|;
name|x
operator|.
name|optr
operator|->
name|tval
operator|=
name|STR
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|arith
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|awkfloat
name|i
decl_stmt|,
name|j
decl_stmt|;
name|obj
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|getfval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|UMINUS
condition|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
name|getfval
argument_list|(
name|y
operator|.
name|optr
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|z
operator|=
name|gettemp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal arithmetic operator %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
case|case
name|ADD
case|:
name|i
operator|+=
name|j
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|i
operator|-=
name|j
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|i
operator|*=
name|j
expr_stmt|;
break|break;
case|case
name|DIVIDE
case|:
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"division by zero"
argument_list|)
expr_stmt|;
name|i
operator|/=
name|j
expr_stmt|;
break|break;
case|case
name|MOD
case|:
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"division by zero"
argument_list|)
expr_stmt|;
name|i
operator|=
name|i
operator|-
name|j
operator|*
call|(
name|long
call|)
argument_list|(
name|i
operator|/
name|j
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMINUS
case|:
name|i
operator|=
operator|-
name|i
expr_stmt|;
break|break;
block|}
name|setfval
argument_list|(
name|z
operator|.
name|optr
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|incrdecr
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|,
name|z
decl_stmt|;
name|int
name|k
decl_stmt|;
name|awkfloat
name|xf
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|xf
operator|=
name|getfval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|n
operator|==
name|PREINCR
operator|||
name|n
operator|==
name|POSTINCR
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|PREINCR
operator|||
name|n
operator|==
name|PREDECR
condition|)
block|{
name|setfval
argument_list|(
name|x
operator|.
name|optr
argument_list|,
name|xf
operator|+
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
name|z
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|setfval
argument_list|(
name|z
operator|.
name|optr
argument_list|,
name|xf
argument_list|)
expr_stmt|;
name|setfval
argument_list|(
name|x
operator|.
name|optr
argument_list|,
name|xf
operator|+
name|k
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|assign
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|,
name|y
decl_stmt|;
name|awkfloat
name|xf
decl_stmt|,
name|yf
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|ASSIGN
condition|)
block|{
comment|/* ordinary assignment */
if|if
condition|(
operator|(
name|y
operator|.
name|optr
operator|->
name|tval
operator|&
operator|(
name|STR
operator||
name|NUM
operator|)
operator|)
operator|==
operator|(
name|STR
operator||
name|NUM
operator|)
condition|)
block|{
name|setsval
argument_list|(
name|x
operator|.
name|optr
argument_list|,
name|y
operator|.
name|optr
operator|->
name|sval
argument_list|)
expr_stmt|;
name|x
operator|.
name|optr
operator|->
name|fval
operator|=
name|y
operator|.
name|optr
operator|->
name|fval
expr_stmt|;
name|x
operator|.
name|optr
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|.
name|optr
operator|->
name|tval
operator|&
name|STR
condition|)
name|setsval
argument_list|(
name|x
operator|.
name|optr
argument_list|,
name|y
operator|.
name|optr
operator|->
name|sval
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|y
operator|.
name|optr
operator|->
name|tval
operator|&
name|NUM
condition|)
name|setfval
argument_list|(
name|x
operator|.
name|optr
argument_list|,
name|y
operator|.
name|optr
operator|->
name|fval
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
name|xf
operator|=
name|getfval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
name|yf
operator|=
name|getfval
argument_list|(
name|y
operator|.
name|optr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|ADDEQ
case|:
name|xf
operator|+=
name|yf
expr_stmt|;
break|break;
case|case
name|SUBEQ
case|:
name|xf
operator|-=
name|yf
expr_stmt|;
break|break;
case|case
name|MULTEQ
case|:
name|xf
operator|*=
name|yf
expr_stmt|;
break|break;
case|case
name|DIVEQ
case|:
if|if
condition|(
name|yf
operator|==
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"division by zero"
argument_list|)
expr_stmt|;
name|xf
operator|/=
name|yf
expr_stmt|;
break|break;
case|case
name|MODEQ
case|:
if|if
condition|(
name|yf
operator|==
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"division by zero"
argument_list|)
expr_stmt|;
name|xf
operator|=
name|xf
operator|-
name|yf
operator|*
call|(
name|long
call|)
argument_list|(
name|xf
operator|/
name|yf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal assignment operator %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|setfval
argument_list|(
name|x
operator|.
name|optr
argument_list|,
name|xf
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|cat
parameter_list|(
name|a
parameter_list|,
name|q
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|getsval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
name|getsval
argument_list|(
name|y
operator|.
name|optr
argument_list|)
expr_stmt|;
name|n1
operator|=
name|strlen
argument_list|(
name|x
operator|.
name|optr
operator|->
name|sval
argument_list|)
expr_stmt|;
name|n2
operator|=
name|strlen
argument_list|(
name|y
operator|.
name|optr
operator|->
name|sval
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n1
operator|+
name|n2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|x
operator|.
name|optr
operator|->
name|sval
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
operator|+
name|n1
argument_list|,
name|y
operator|.
name|optr
operator|->
name|sval
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|z
operator|.
name|optr
operator|->
name|sval
operator|=
name|s
expr_stmt|;
name|z
operator|.
name|optr
operator|->
name|tval
operator|=
name|STR
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|pastat
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
name|nullstat
condition|)
name|x
operator|=
name|true
expr_stmt|;
else|else
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|dopa2
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
if|if
condition|(
name|pairstack
index|[
name|n
index|]
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
name|pairstack
index|[
name|n
index|]
operator|=
literal|1
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pairstack
index|[
name|n
index|]
operator|==
literal|1
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
name|pairstack
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|aprintf
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
name|x
operator|=
name|asprintf
argument_list|(
name|a
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|x
operator|.
name|optr
operator|->
name|sval
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
name|redirprint
argument_list|(
name|x
operator|.
name|optr
operator|->
name|sval
argument_list|,
operator|(
name|int
operator|)
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|split
parameter_list|(
name|a
parameter_list|,
name|nnn
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
name|cell
modifier|*
name|ap
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
name|temp
decl_stmt|,
name|num
index|[
literal|5
index|]
decl_stmt|;
specifier|register
name|int
name|sep
decl_stmt|;
name|int
name|n
decl_stmt|,
name|flag
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|s
operator|=
name|getsval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|==
name|nullstat
condition|)
name|sep
operator|=
operator|*
operator|*
name|FS
expr_stmt|;
else|else
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|sep
operator|=
name|getsval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|ap
operator|=
operator|(
name|cell
operator|*
operator|)
name|a
index|[
literal|1
index|]
expr_stmt|;
name|freesymtab
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"split: s=|%s|, a=%s, sep=|%c|\n"
argument_list|,
name|s
argument_list|,
name|ap
operator|->
name|nval
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|ap
operator|->
name|tval
operator|&=
operator|~
name|STR
expr_stmt|;
name|ap
operator|->
name|tval
operator||=
name|ARR
expr_stmt|;
name|ap
operator|->
name|sval
operator|=
operator|(
name|char
operator|*
operator|)
name|makesymtab
argument_list|()
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|' '
condition|)
for|for
control|(
name|n
operator|=
literal|0
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|||
operator|*
name|s
operator|==
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
break|break;
name|n
operator|++
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
do|do
name|s
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
do|;
name|temp
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|isanumber
argument_list|(
name|t
argument_list|)
condition|)
name|setsymtab
argument_list|(
name|num
argument_list|,
name|tostring
argument_list|(
name|t
argument_list|)
argument_list|,
name|atof
argument_list|(
name|t
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
name|num
argument_list|,
name|tostring
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|++
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
name|sep
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
name|temp
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|isanumber
argument_list|(
name|t
argument_list|)
condition|)
name|setsymtab
argument_list|(
name|num
argument_list|,
name|tostring
argument_list|(
name|t
argument_list|)
argument_list|,
name|atof
argument_list|(
name|t
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
name|num
argument_list|,
name|tostring
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|0
condition|)
break|break;
block|}
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|x
operator|.
name|optr
operator|->
name|tval
operator|=
name|NUM
expr_stmt|;
name|x
operator|.
name|optr
operator|->
name|fval
operator|=
name|n
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|ifstat
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|!=
name|nullstat
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|whilestat
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|isexit
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|obj
name|forstat
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
name|tempfree
argument_list|(
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|!=
name|nullstat
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
else|else
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* turn off break */
name|x
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|isexit
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|obj
name|instat
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|cell
modifier|*
name|vp
decl_stmt|,
modifier|*
name|arrayp
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|tp
decl_stmt|;
name|obj
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vp
operator|=
operator|(
name|cell
operator|*
operator|)
name|a
index|[
literal|0
index|]
expr_stmt|;
name|arrayp
operator|=
operator|(
name|cell
operator|*
operator|)
name|a
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|arrayp
operator|->
name|tval
operator|&
name|ARR
operator|)
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"%s is not an array"
argument_list|,
name|arrayp
operator|->
name|nval
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|cell
operator|*
operator|*
operator|)
name|arrayp
operator|->
name|sval
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSYM
condition|;
name|i
operator|++
control|)
block|{
comment|/* this routine knows too much */
for|for
control|(
name|cp
operator|=
name|tp
index|[
name|i
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextval
control|)
block|{
name|setsval
argument_list|(
name|vp
argument_list|,
name|cp
operator|->
name|nval
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|isexit
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|jump
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|.
name|otype
operator|=
name|OJUMP
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal jump type %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXIT
case|:
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|errorflag
operator|=
name|getfval
argument_list|(
name|y
operator|.
name|optr
argument_list|)
expr_stmt|;
block|}
name|x
operator|.
name|osub
operator|=
name|JEXIT
expr_stmt|;
break|break;
case|case
name|NEXT
case|:
name|x
operator|.
name|osub
operator|=
name|JNEXT
expr_stmt|;
break|break;
case|case
name|BREAK
case|:
name|x
operator|.
name|osub
operator|=
name|JBREAK
expr_stmt|;
break|break;
case|case
name|CONTINUE
case|:
name|x
operator|.
name|osub
operator|=
name|JCONT
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|fncn
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
name|awkfloat
name|u
decl_stmt|;
name|int
name|t
decl_stmt|;
name|t
operator|=
operator|(
name|int
operator|)
name|a
index|[
literal|0
index|]
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|FLENGTH
condition|)
name|u
operator|=
operator|(
name|awkfloat
operator|)
name|strlen
argument_list|(
name|getsval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|FLOG
condition|)
name|u
operator|=
name|log
argument_list|(
name|getfval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|FINT
condition|)
name|u
operator|=
operator|(
name|awkfloat
operator|)
operator|(
name|long
operator|)
name|getfval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|FEXP
condition|)
name|u
operator|=
name|exp
argument_list|(
name|getfval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|FSQRT
condition|)
name|u
operator|=
name|sqrt
argument_list|(
name|getfval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal function type %d"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|setfval
argument_list|(
name|x
operator|.
name|optr
argument_list|,
name|u
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|print
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|node
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|x
decl_stmt|;
name|obj
name|y
decl_stmt|;
name|char
name|s
index|[
name|RECSIZE
index|]
decl_stmt|;
name|s
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|x
operator|=
name|a
index|[
literal|0
index|]
init|;
name|x
operator|!=
name|NULL
condition|;
name|x
operator|=
name|x
operator|->
name|nnext
control|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
name|getsval
argument_list|(
name|y
operator|.
name|optr
argument_list|)
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|nnext
operator|==
name|NULL
condition|)
name|strcat
argument_list|(
name|s
argument_list|,
operator|*
name|ORS
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|s
argument_list|,
operator|*
name|OFS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|>=
name|RECSIZE
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"string %.20s ... too long to print"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|==
name|nullstat
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
name|redirprint
argument_list|(
name|s
argument_list|,
operator|(
name|int
operator|)
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|obj
name|nullproc
parameter_list|()
block|{}
end_function

begin_function
name|obj
name|nodetoobj
parameter_list|(
name|a
parameter_list|)
name|node
modifier|*
name|a
decl_stmt|;
block|{
name|obj
name|x
decl_stmt|;
name|x
operator|.
name|optr
operator|=
operator|(
name|cell
operator|*
operator|)
name|a
operator|->
name|nobj
expr_stmt|;
name|x
operator|.
name|otype
operator|=
name|OCELL
expr_stmt|;
name|x
operator|.
name|osub
operator|=
name|a
operator|->
name|subtype
expr_stmt|;
if|if
condition|(
name|isfld
argument_list|(
name|x
argument_list|)
condition|)
name|fldbld
argument_list|()
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_macro
name|redirprint
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|node
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|obj
name|x
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|getsval
argument_list|(
name|x
operator|.
name|optr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FILENUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fp
operator|&&
name|strcmp
argument_list|(
name|x
operator|.
name|optr
operator|->
name|sval
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|doit
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FILENUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fp
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|FILENUM
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"too many output files %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
literal|'|'
condition|)
comment|/* a pipe! */
name|files
index|[
name|i
index|]
operator|.
name|fp
operator|=
name|popen
argument_list|(
name|x
operator|.
name|optr
operator|->
name|sval
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|==
name|APPEND
condition|)
name|files
index|[
name|i
index|]
operator|.
name|fp
operator|=
name|fopen
argument_list|(
name|x
operator|.
name|optr
operator|->
name|sval
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
else|else
name|files
index|[
name|i
index|]
operator|.
name|fp
operator|=
name|fopen
argument_list|(
name|x
operator|.
name|optr
operator|->
name|sval
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open file %s"
argument_list|,
name|x
operator|.
name|optr
operator|->
name|sval
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"close on exec failure"
argument_list|)
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|=
name|tostring
argument_list|(
name|x
operator|.
name|optr
operator|->
name|sval
argument_list|)
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|type
operator|=
name|a
expr_stmt|;
name|doit
label|:
name|fprintf
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|gcos
name|fflush
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
expr_stmt|;
comment|/* in case someone is waiting for the output */
endif|#
directive|endif
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

