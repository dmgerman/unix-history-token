begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)od.c	5.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * od -- octal, hex, decimal, character dump of data in a file.  *  * usage:  od [-abcdDefFhHiIlLopPvxX] [file] [[+]offset[.][b] [label]]  *  * where the option flags have the following meaning:  *   character	object	radix	signed?  *	a	byte	(10)	(n.a.)	ASCII named byte stream  *	b	byte	  8	 no	byte octal  *	c	byte	 (8)	(no)	character with octal non-graphic bytes  *	d	short	 10	 no  *	D	long	 10	 no  *	e,F	double	(10)		double precision floating pt.  *	f	float	(10)		single precision floating pt.  *	h,x	short	 16	 no  *	H,X	long	 16	 no  *	i	short	 10	yes  *	I,l,L	long	 10	yes  *	o	short	  8	 no	(default conversion)  *	O	long	  8	 no  *  *	p				indicate EVEN parity on 'a' conversion  *	P				indicate ODD parity on 'a' conversion  *	v				show all data - don't skip like lines.  *  * More than one format character may be given.  * If {file} is not specified, standard input is read.  * If {file} is not specified, then {offset} must start with '+'.  * {Offset} may be HEX (0xnnn), OCTAL (0nn), or decimal (nnn.); the default  * is the same as the address radix, which will be the same as the first  * object radix.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|EVEN
value|-1
end_define

begin_define
define|#
directive|define
name|ODD
value|1
end_define

begin_define
define|#
directive|define
name|UNSIGNED
value|0
end_define

begin_define
define|#
directive|define
name|SIGNED
value|1
end_define

begin_function_decl
name|int
name|a_put
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|b_put
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|c_put
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|s_put
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|us_put
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|l_put
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|f_put
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|d_put
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
name|dfmt
block|{
name|int
name|df_field
decl_stmt|;
comment|/* external field required for object */
name|int
name|df_size
decl_stmt|;
comment|/* size (bytes) of object */
name|int
name|df_radix
decl_stmt|;
comment|/* conversion radix */
name|int
name|df_signed
decl_stmt|;
comment|/* signed? flag */
name|int
function_decl|(
modifier|*
name|df_put
function_decl|)
parameter_list|()
function_decl|;
comment|/* function to output object */
name|char
modifier|*
name|df_fmt
decl_stmt|;
block|}
modifier|*
name|conv_vec
index|[
literal|32
index|]
struct|;
end_struct

begin_comment
comment|/* vector of conversions to be done */
end_comment

begin_decl_stmt
name|struct
name|dfmt
name|ascii
init|=
block|{
literal|3
block|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
block|,
literal|10
block|,
literal|0
block|,
name|a_put
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
name|byte
init|=
block|{
literal|3
block|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
block|,
literal|8
block|,
name|UNSIGNED
block|,
name|b_put
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
name|cchar
init|=
block|{
literal|3
block|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
block|,
literal|8
block|,
name|UNSIGNED
block|,
name|c_put
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
name|u_s_oct
init|=
block|{
literal|6
block|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
block|,
literal|8
block|,
name|UNSIGNED
block|,
name|us_put
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
name|u_s_dec
init|=
block|{
literal|5
block|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
block|,
literal|10
block|,
name|UNSIGNED
block|,
name|us_put
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
name|u_s_hex
init|=
block|{
literal|4
block|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
block|,
literal|16
block|,
name|UNSIGNED
block|,
name|us_put
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
name|u_l_oct
init|=
block|{
literal|11
block|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
block|,
literal|8
block|,
name|UNSIGNED
block|,
name|l_put
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
name|u_l_dec
init|=
block|{
literal|10
block|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
block|,
literal|10
block|,
name|UNSIGNED
block|,
name|l_put
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
name|u_l_hex
init|=
block|{
literal|8
block|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
block|,
literal|16
block|,
name|UNSIGNED
block|,
name|l_put
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
name|s_s_dec
init|=
block|{
literal|6
block|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
block|,
literal|10
block|,
name|SIGNED
block|,
name|s_put
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
name|s_l_dec
init|=
block|{
literal|11
block|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
block|,
literal|10
block|,
name|SIGNED
block|,
name|l_put
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
name|flt
init|=
block|{
literal|14
block|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
block|,
literal|10
block|,
name|SIGNED
block|,
name|f_put
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
name|dble
init|=
block|{
literal|21
block|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
block|,
literal|10
block|,
name|SIGNED
block|,
name|d_put
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|usage
index|[]
init|=
literal|"od [-abcdfhilopvx] [file] [[+]offset[.][b] [label]]"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dbuf
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lastdbuf
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|addr_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|label
init|=
operator|-
literal|1L
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_parity
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|fmt
index|[]
init|=
literal|"            %s"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12 blanks */
end_comment

begin_function_decl
name|char
modifier|*
name|icvt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|underline
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|get_addr
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|l
decl_stmt|;
specifier|register
name|n
operator|,
name|same
expr_stmt|;
name|struct
name|dfmt
modifier|*
name|d
decl_stmt|;
name|struct
name|dfmt
modifier|*
modifier|*
name|cv
init|=
name|conv_vec
decl_stmt|;
name|int
name|showall
init|=
name|NO
decl_stmt|;
name|int
name|field
decl_stmt|,
name|llen
decl_stmt|,
name|nelm
decl_stmt|;
name|int
name|max_llen
init|=
literal|0
decl_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|max_llen
operator|=
name|max_nelm
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|p
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'a'
case|:
name|d
operator|=
operator|&
name|ascii
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|d
operator|=
operator|&
name|byte
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|d
operator|=
operator|&
name|cchar
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|d
operator|=
operator|&
name|u_s_dec
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|d
operator|=
operator|&
name|u_l_dec
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'F'
case|:
name|d
operator|=
operator|&
name|dble
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|d
operator|=
operator|&
name|flt
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'x'
case|:
name|d
operator|=
operator|&
name|u_s_hex
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
case|case
literal|'X'
case|:
name|d
operator|=
operator|&
name|u_l_hex
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|d
operator|=
operator|&
name|s_s_dec
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|d
operator|=
operator|&
name|s_l_dec
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|d
operator|=
operator|&
name|u_s_oct
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|d
operator|=
operator|&
name|u_l_oct
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|_parity
operator|=
name|EVEN
expr_stmt|;
continue|continue;
case|case
literal|'P'
case|:
name|_parity
operator|=
name|ODD
expr_stmt|;
continue|continue;
case|case
literal|'v'
case|:
name|showall
operator|=
name|YES
expr_stmt|;
continue|continue;
default|default:
name|printf
argument_list|(
literal|"od: bad flag -%c\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|usage
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|nelm
operator|=
literal|16
operator|/
name|d
operator|->
name|df_size
expr_stmt|;
name|llen
operator|=
operator|(
name|d
operator|->
name|df_field
operator|+
literal|1
operator|)
operator|*
name|nelm
expr_stmt|;
if|if
condition|(
name|llen
operator|>
name|max_llen
condition|)
name|max_llen
operator|=
name|llen
expr_stmt|;
if|if
condition|(
name|nelm
operator|>
name|max_nelm
condition|)
name|max_nelm
operator|=
name|nelm
expr_stmt|;
comment|/* 				 * nelm will always be a power of 2. 				 * line length must always be multiple 				 * of max_nelm. 				 */
name|nelm
operator|=
name|max_nelm
operator|-
literal|1
expr_stmt|;
name|max_llen
operator|=
operator|(
name|max_llen
operator|+
name|nelm
operator|)
operator|&
operator|(
operator|~
name|nelm
operator|)
expr_stmt|;
if|if
condition|(
name|addr_base
operator|==
literal|0
condition|)
name|addr_base
operator|=
name|d
operator|->
name|df_radix
expr_stmt|;
operator|*
operator|(
name|cv
operator|++
operator|)
operator|=
name|d
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cv
operator|==
name|conv_vec
condition|)
block|{
name|addr_base
operator|=
literal|8
expr_stmt|;
operator|*
operator|(
name|cv
operator|++
operator|)
operator|=
operator|&
name|u_s_oct
expr_stmt|;
name|max_nelm
operator|=
literal|16
operator|/
name|u_s_oct
operator|.
name|df_size
expr_stmt|;
name|max_llen
operator|=
name|max_nelm
operator|*
operator|(
name|u_s_oct
operator|.
name|df_field
operator|+
literal|1
operator|)
expr_stmt|;
block|}
operator|*
name|cv
operator|=
operator|(
expr|struct
name|dfmt
operator|*
operator|)
literal|0
expr_stmt|;
name|cv
operator|=
name|conv_vec
expr_stmt|;
while|while
condition|(
name|d
operator|=
operator|*
name|cv
operator|++
condition|)
block|{
name|nelm
operator|=
literal|16
operator|/
name|d
operator|->
name|df_size
expr_stmt|;
name|field
operator|=
name|max_llen
operator|/
name|nelm
expr_stmt|;
name|d
operator|->
name|df_fmt
operator|=
name|fmt
operator|+
literal|12
operator|-
operator|(
name|field
operator|-
name|d
operator|->
name|df_field
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|*
name|argv
operator|!=
literal|'+'
condition|)
block|{
if|if
condition|(
name|freopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"od: cannot open %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|addr
operator|=
name|get_addr
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|offset
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
name|label
operator|=
name|get_addr
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
name|same
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|fread
argument_list|(
name|dbuf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|dbuf
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|same
operator|>=
literal|0
operator|&&
name|strncmp
argument_list|(
name|dbuf
argument_list|,
name|lastdbuf
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|showall
condition|)
block|{
if|if
condition|(
name|same
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"*\n"
argument_list|)
expr_stmt|;
name|same
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|line
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|same
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|dbuf
expr_stmt|;
name|l
operator|=
name|lastdbuf
expr_stmt|;
for|for
control|(
name|nelm
operator|=
literal|0
init|;
name|nelm
operator|<
literal|16
condition|;
name|nelm
operator|++
control|)
block|{
operator|*
name|l
operator|++
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|addr
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|label
operator|>=
literal|0
condition|)
name|label
operator|+=
name|n
expr_stmt|;
block|}
name|put_addr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|put_addr
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fputs
argument_list|(
name|icvt
argument_list|(
name|addr
argument_list|,
name|addr_base
argument_list|,
name|UNSIGNED
argument_list|,
literal|7
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|icvt
argument_list|(
name|label
argument_list|,
name|addr_base
argument_list|,
name|UNSIGNED
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|line
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|first
expr_stmt|;
specifier|register
name|struct
name|dfmt
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|dfmt
modifier|*
modifier|*
name|cv
init|=
name|conv_vec
decl_stmt|;
name|first
operator|=
name|YES
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|cv
operator|++
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|put_addr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|first
operator|=
name|NO
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|>=
literal|0
condition|)
name|fputs
argument_list|(
literal|"\t  "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
name|i
operator|+=
operator|(
operator|*
operator|(
name|c
operator|->
name|df_put
operator|)
operator|)
operator|(
name|dbuf
operator|+
name|i
operator|,
name|c
operator|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|s_put
argument_list|(
argument|n
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|short
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
name|d
operator|->
name|df_fmt
argument_list|,
name|icvt
argument_list|(
operator|(
name|long
operator|)
operator|*
name|n
argument_list|,
name|d
operator|->
name|df_radix
argument_list|,
name|d
operator|->
name|df_signed
argument_list|,
name|d
operator|->
name|df_field
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|df_size
operator|)
return|;
block|}
end_block

begin_macro
name|us_put
argument_list|(
argument|n
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|short
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
name|d
operator|->
name|df_fmt
argument_list|,
name|icvt
argument_list|(
operator|(
name|long
operator|)
operator|*
name|n
argument_list|,
name|d
operator|->
name|df_radix
argument_list|,
name|d
operator|->
name|df_signed
argument_list|,
name|d
operator|->
name|df_field
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|df_size
operator|)
return|;
block|}
end_block

begin_macro
name|l_put
argument_list|(
argument|n
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
name|d
operator|->
name|df_fmt
argument_list|,
name|icvt
argument_list|(
operator|*
name|n
argument_list|,
name|d
operator|->
name|df_radix
argument_list|,
name|d
operator|->
name|df_signed
argument_list|,
name|d
operator|->
name|df_field
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|df_size
operator|)
return|;
block|}
end_block

begin_macro
name|d_put
argument_list|(
argument|f
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|double
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|fbuf
index|[
literal|24
index|]
decl_stmt|;
struct|struct
name|l
block|{
name|long
name|n
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
if|#
directive|if
name|vax
if|if
condition|(
operator|(
operator|(
operator|(
expr|struct
name|l
operator|*
operator|)
name|f
operator|)
operator|->
name|n
index|[
literal|0
index|]
operator|&
literal|0xff00
operator|)
operator|==
literal|0x8000
condition|)
comment|/* Vax illegal f.p. */
name|sprintf
argument_list|(
name|fbuf
argument_list|,
literal|"    %08x %08x"
argument_list|,
operator|(
operator|(
expr|struct
name|l
operator|*
operator|)
name|f
operator|)
operator|->
name|n
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
expr|struct
name|l
operator|*
operator|)
name|f
operator|)
operator|->
name|n
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sprintf
argument_list|(
name|fbuf
argument_list|,
literal|"%21.14e"
argument_list|,
operator|*
name|f
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|d
operator|->
name|df_fmt
argument_list|,
name|fbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|df_size
operator|)
return|;
block|}
end_block

begin_macro
name|f_put
argument_list|(
argument|f
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|float
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|fbuf
index|[
literal|16
index|]
decl_stmt|;
if|#
directive|if
name|vax
if|if
condition|(
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|f
operator|&
literal|0xff00
operator|)
operator|==
literal|0x8000
condition|)
comment|/* Vax illegal f.p. form */
name|sprintf
argument_list|(
name|fbuf
argument_list|,
literal|"      %08x"
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
name|f
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sprintf
argument_list|(
name|fbuf
argument_list|,
literal|"%14.7e"
argument_list|,
operator|*
name|f
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|d
operator|->
name|df_fmt
argument_list|,
name|fbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|df_size
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|asc_name
index|[
literal|34
index|]
index|[
literal|4
index|]
init|=
block|{
literal|"nul"
block|,
literal|"soh"
block|,
literal|"stx"
block|,
literal|"etx"
block|,
literal|"eot"
block|,
literal|"enq"
block|,
literal|"ack"
block|,
literal|"bel"
block|,
literal|" bs"
block|,
literal|" ht"
block|,
literal|" nl"
block|,
literal|" vt"
block|,
literal|" ff"
block|,
literal|" cr"
block|,
literal|" so"
block|,
literal|" si"
block|,
literal|"dle"
block|,
literal|"dc1"
block|,
literal|"dc2"
block|,
literal|"dc3"
block|,
literal|"dc4"
block|,
literal|"nak"
block|,
literal|"syn"
block|,
literal|"etb"
block|,
literal|"can"
block|,
literal|" em"
block|,
literal|"sub"
block|,
literal|"esc"
block|,
literal|" fs"
block|,
literal|" gs"
block|,
literal|" rs"
block|,
literal|" us"
block|,
literal|" sp"
block|,
literal|"del"
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|a_put
argument_list|(
argument|cc
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
init|=
operator|*
name|cc
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
literal|"   "
decl_stmt|;
specifier|register
name|pbit
operator|=
name|parity
argument_list|(
operator|(
name|int
operator|)
name|c
operator|&
literal|0377
argument_list|)
expr_stmt|;
name|c
operator|&=
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|' '
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
name|s
index|[
literal|2
index|]
operator|=
operator|*
name|cc
expr_stmt|;
if|if
condition|(
name|pbit
operator|==
name|_parity
condition|)
name|printf
argument_list|(
name|d
operator|->
name|df_fmt
argument_list|,
name|underline
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|d
operator|->
name|df_fmt
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|0177
condition|)
name|c
operator|=
literal|' '
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pbit
operator|==
name|_parity
condition|)
name|printf
argument_list|(
name|d
operator|->
name|df_fmt
argument_list|,
name|underline
argument_list|(
name|asc_name
index|[
name|c
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|d
operator|->
name|df_fmt
argument_list|,
name|asc_name
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|parity
argument_list|(
argument|word
argument_list|)
end_macro

begin_decl_stmt
name|int
name|word
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|p
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|w
init|=
name|word
decl_stmt|;
if|if
condition|(
name|w
condition|)
do|do
block|{
name|p
operator|^=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|&=
operator|(
operator|~
operator|(
operator|-
name|w
operator|)
operator|)
condition|)
do|;
return|return
operator|(
name|p
condition|?
name|ODD
else|:
name|EVEN
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|underline
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|static
name|char
name|ulbuf
index|[
literal|16
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|u
init|=
name|ulbuf
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|' '
condition|)
block|{
operator|*
name|u
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|u
operator|++
operator|=
literal|'\b'
expr_stmt|;
block|}
operator|*
name|u
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|u
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ulbuf
operator|)
return|;
block|}
end_function

begin_macro
name|b_put
argument_list|(
argument|b
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
name|d
operator|->
name|df_fmt
argument_list|,
name|icvt
argument_list|(
operator|(
name|long
operator|)
operator|*
name|b
operator|&
literal|0377
argument_list|,
name|d
operator|->
name|df_radix
argument_list|,
name|d
operator|->
name|df_signed
argument_list|,
name|d
operator|->
name|df_field
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|c_put
argument_list|(
argument|cc
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfmt
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
init|=
operator|*
name|cc
operator|&
literal|0377
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
literal|"   "
decl_stmt|;
if|if
condition|(
name|c
operator|>
literal|037
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
name|s
index|[
literal|2
index|]
operator|=
operator|*
name|cc
expr_stmt|;
name|printf
argument_list|(
name|d
operator|->
name|df_fmt
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
name|s
operator|=
literal|" \\0"
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|s
operator|=
literal|" \\b"
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|s
operator|=
literal|" \\f"
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|s
operator|=
literal|" \\n"
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|s
operator|=
literal|" \\r"
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|s
operator|=
literal|" \\t"
expr_stmt|;
break|break;
default|default:
name|s
operator|=
name|icvt
argument_list|(
operator|(
name|long
operator|)
name|c
argument_list|,
name|d
operator|->
name|df_radix
argument_list|,
name|d
operator|->
name|df_signed
argument_list|,
name|d
operator|->
name|df_field
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|d
operator|->
name|df_fmt
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * integer to ascii conversion  *  * This code has been rearranged to produce optimized runtime code.  */
end_comment

begin_define
define|#
directive|define
name|MAXINTLENGTH
value|32
end_define

begin_decl_stmt
specifier|static
name|char
name|_digit
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|_icv_buf
index|[
name|MAXINTLENGTH
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|_mask
init|=
literal|0x7fffffff
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|icvt
parameter_list|(
name|value
parameter_list|,
name|radix
parameter_list|,
name|signed
parameter_list|,
name|ndigits
parameter_list|)
name|long
name|value
decl_stmt|;
name|int
name|radix
decl_stmt|;
name|int
name|signed
decl_stmt|;
name|int
name|ndigits
decl_stmt|;
block|{
specifier|register
name|long
name|val
init|=
name|value
decl_stmt|;
specifier|register
name|long
name|rad
init|=
name|radix
decl_stmt|;
specifier|register
name|char
modifier|*
name|b
init|=
operator|&
name|_icv_buf
index|[
name|MAXINTLENGTH
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
init|=
name|_digit
decl_stmt|;
specifier|register
name|long
name|tmp1
decl_stmt|;
specifier|register
name|long
name|tmp2
decl_stmt|;
name|long
name|rem
decl_stmt|;
name|long
name|kludge
decl_stmt|;
name|int
name|sign
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
operator|*
operator|--
name|b
operator|=
literal|'0'
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
comment|/*return(b);*/
block|}
if|if
condition|(
name|signed
operator|&&
operator|(
name|sign
operator|=
operator|(
name|val
operator|<
literal|0
operator|)
operator|)
condition|)
comment|/* signed conversion */
block|{
comment|/* 		 * It is necessary to do the first divide 		 * before the absolute value, for the case -2^31 		 * 		 * This is actually what is being done... 		 * tmp1 = (int)(val % rad); 		 * val /= rad; 		 * val = -val 		 * *--b = d[-tmp1]; 		 */
name|tmp1
operator|=
name|val
operator|/
name|rad
expr_stmt|;
operator|*
operator|--
name|b
operator|=
name|d
index|[
operator|(
name|tmp1
operator|*
name|rad
operator|)
operator|-
name|val
index|]
expr_stmt|;
name|val
operator|=
operator|-
name|tmp1
expr_stmt|;
block|}
else|else
comment|/* unsigned conversion */
block|{
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
comment|/* ALL THIS IS TO SIMULATE UNSIGNED LONG MOD& DIV */
name|kludge
operator|=
name|_mask
operator|-
operator|(
name|rad
operator|-
literal|1
operator|)
expr_stmt|;
name|val
operator|&=
name|_mask
expr_stmt|;
comment|/* 			 * This is really what's being done... 			 * rem = (kludge % rad) + (val % rad); 			 * val = (kludge / rad) + (val / rad) + (rem / rad) + 1; 			 * *--b = d[rem % rad]; 			 */
name|tmp1
operator|=
name|kludge
operator|/
name|rad
expr_stmt|;
name|tmp2
operator|=
name|val
operator|/
name|rad
expr_stmt|;
name|rem
operator|=
operator|(
name|kludge
operator|-
operator|(
name|tmp1
operator|*
name|rad
operator|)
operator|)
operator|+
operator|(
name|val
operator|-
operator|(
name|tmp2
operator|*
name|rad
operator|)
operator|)
expr_stmt|;
name|val
operator|=
operator|++
name|tmp1
operator|+
name|tmp2
expr_stmt|;
name|tmp1
operator|=
name|rem
operator|/
name|rad
expr_stmt|;
name|val
operator|+=
name|tmp1
expr_stmt|;
operator|*
operator|--
name|b
operator|=
name|d
index|[
name|rem
operator|-
operator|(
name|tmp1
operator|*
name|rad
operator|)
index|]
expr_stmt|;
block|}
block|}
while|while
condition|(
name|val
condition|)
block|{
comment|/* 		 * This is really what's being done ... 		 * *--b = d[val % rad]; 		 * val /= rad; 		 */
name|tmp1
operator|=
name|val
operator|/
name|rad
expr_stmt|;
operator|*
operator|--
name|b
operator|=
name|d
index|[
name|val
operator|-
operator|(
name|tmp1
operator|*
name|rad
operator|)
index|]
expr_stmt|;
name|val
operator|=
name|tmp1
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|sign
condition|)
operator|*
operator|--
name|b
operator|=
literal|'-'
expr_stmt|;
name|tmp1
operator|=
name|ndigits
operator|-
operator|(
operator|&
name|_icv_buf
index|[
name|MAXINTLENGTH
index|]
operator|-
name|b
operator|)
expr_stmt|;
name|tmp2
operator|=
name|signed
condition|?
literal|' '
else|:
literal|'0'
expr_stmt|;
while|while
condition|(
name|tmp1
operator|>
literal|0
condition|)
block|{
operator|*
operator|--
name|b
operator|=
name|tmp2
expr_stmt|;
name|tmp1
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_function
name|long
name|get_addr
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|long
name|a
decl_stmt|;
specifier|register
name|int
name|d
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'x'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|addr_base
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
name|addr_base
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
name|addr_base
operator|=
literal|8
expr_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'.'
condition|)
name|addr_base
operator|=
literal|10
expr_stmt|;
block|}
for|for
control|(
name|a
operator|=
literal|0
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|d
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|'0'
operator|&&
name|d
operator|<=
literal|'9'
condition|)
name|a
operator|=
name|a
operator|*
name|addr_base
operator|+
name|d
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|>=
literal|'a'
operator|&&
name|d
operator|<=
literal|'f'
operator|&&
name|addr_base
operator|==
literal|16
condition|)
name|a
operator|=
name|a
operator|*
name|addr_base
operator|+
name|d
operator|+
literal|10
operator|-
literal|'a'
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'b'
condition|)
name|a
operator|*=
literal|512
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'B'
condition|)
name|a
operator|*=
literal|1024
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_macro
name|offset
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|long
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|canseek
argument_list|(
name|stdin
argument_list|)
condition|)
name|fseek
argument_list|(
name|stdin
argument_list|,
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dumbseek
argument_list|(
name|stdin
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dumbseek
argument_list|(
argument|s
argument_list|,
argument|offset
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|nr
decl_stmt|;
while|while
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|nr
operator|=
operator|(
name|offset
operator|>
name|BUFSIZ
operator|)
condition|?
name|BUFSIZ
else|:
operator|(
name|int
operator|)
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|nr
argument_list|,
name|s
argument_list|)
operator|)
operator|!=
name|nr
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"EOF\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|offset
operator|-=
name|n
expr_stmt|;
block|}
block|}
end_block

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_macro
name|canseek
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|statb
decl_stmt|;
return|return
operator|(
operator|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|statb
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|statb
operator|.
name|st_nlink
operator|>
literal|0
operator|)
operator|&&
comment|/*!pipe*/
operator|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

end_unit

