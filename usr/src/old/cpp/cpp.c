begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)cpp.c	1.19 %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLEXNAMES
end_ifdef

begin_define
define|#
directive|define
name|NCPS
value|128
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NCPS
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/* C command /* written by John F. Reiser /* July/August 1978 */
end_comment

begin_define
define|#
directive|define
name|STATIC
end_define

begin_define
define|#
directive|define
name|FIRSTOPEN
value|-2
end_define

begin_define
define|#
directive|define
name|STDIN
value|0
end_define

begin_define
define|#
directive|define
name|READ
value|0
end_define

begin_define
define|#
directive|define
name|WRITE
value|1
end_define

begin_define
define|#
directive|define
name|SALT
value|'#'
end_define

begin_if
if|#
directive|if
operator|!
name|defined
name|BUFSIZ
operator|||
name|BUFSIZ
operator|<
literal|8192
end_if

begin_undef
undef|#
directive|undef
name|BUFSIZ
end_undef

begin_define
define|#
directive|define
name|BUFSIZ
value|8192
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|pbeg
decl_stmt|,
modifier|*
name|pbuf
decl_stmt|,
modifier|*
name|pend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|outp
decl_stmt|,
modifier|*
name|inp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|newp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|cinit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* some code depends on whether characters are sign or zero extended */
end_comment

begin_comment
comment|/*	#if '\377'< 0		not used here, old cpp doesn't understand */
end_comment

begin_if
if|#
directive|if
name|pdp11
operator||
name|vax
operator||
name|mc68000
operator||
name|tahoe
end_if

begin_define
define|#
directive|define
name|COFF
value|128
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COFF
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|gcos
end_if

begin_define
define|#
directive|define
name|ALFSIZ
value|512
end_define

begin_comment
comment|/* alphabet size */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ALFSIZ
value|256
end_define

begin_comment
comment|/* alphabet size */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|macbit
index|[
name|ALFSIZ
operator|+
literal|11
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|toktyp
index|[
name|ALFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BLANK
value|1
end_define

begin_define
define|#
directive|define
name|IDENT
value|2
end_define

begin_define
define|#
directive|define
name|NUMBR
value|3
end_define

begin_comment
comment|/* a superimposed code is used to reduce the number of calls to the /* symbol table lookup routine.  (if the kth character of an identifier /* is 'a' and there are no macro names whose kth character is 'a' /* then the identifier cannot be a macro name, hence there is no need /* to look in the symbol table.)  'scw1' enables the test based on /* single characters and their position in the identifier.  'scw2' /* enables the test based on adjacent pairs of characters and their /* position in the identifier.  scw1 typically costs 1 indexed fetch, /* an AND, and a jump per character of identifier, until the identifier /* is known as a non-macro name or until the end of the identifier. /* scw1 is inexpensive.  scw2 typically costs 4 indexed fetches, /* an add, an AND, and a jump per character of identifier, but it is also /* slightly more effective at reducing symbol table searches. /* scw2 usually costs too much because the symbol table search is /* usually short; but if symbol table search should become expensive, /* the code is here. /* using both scw1 and scw2 is of dubious value. */
end_comment

begin_define
define|#
directive|define
name|scw1
value|1
end_define

begin_define
define|#
directive|define
name|scw2
value|0
end_define

begin_if
if|#
directive|if
name|scw2
end_if

begin_decl_stmt
name|char
name|t21
index|[
name|ALFSIZ
index|]
decl_stmt|,
name|t22
index|[
name|ALFSIZ
index|]
decl_stmt|,
name|t23
index|[
name|ALFSIZ
operator|+
name|NCPS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|scw1
end_if

begin_define
define|#
directive|define
name|b0
value|1
end_define

begin_define
define|#
directive|define
name|b1
value|2
end_define

begin_define
define|#
directive|define
name|b2
value|4
end_define

begin_define
define|#
directive|define
name|b3
value|8
end_define

begin_define
define|#
directive|define
name|b4
value|16
end_define

begin_define
define|#
directive|define
name|b5
value|32
end_define

begin_define
define|#
directive|define
name|b6
value|64
end_define

begin_define
define|#
directive|define
name|b7
value|128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IB
value|1
end_define

begin_define
define|#
directive|define
name|SB
value|2
end_define

begin_define
define|#
directive|define
name|NB
value|4
end_define

begin_define
define|#
directive|define
name|CB
value|8
end_define

begin_define
define|#
directive|define
name|QB
value|16
end_define

begin_define
define|#
directive|define
name|WB
value|32
end_define

begin_decl_stmt
name|char
name|fastab
index|[
name|ALFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|slotab
index|[
name|ALFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ptrtab
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|isslo
value|(ptrtab==(slotab+COFF))
end_define

begin_define
define|#
directive|define
name|isid
parameter_list|(
name|a
parameter_list|)
value|((fastab+COFF)[a]&IB)
end_define

begin_define
define|#
directive|define
name|isspc
parameter_list|(
name|a
parameter_list|)
value|(ptrtab[a]&SB)
end_define

begin_define
define|#
directive|define
name|isnum
parameter_list|(
name|a
parameter_list|)
value|((fastab+COFF)[a]&NB)
end_define

begin_define
define|#
directive|define
name|iscom
parameter_list|(
name|a
parameter_list|)
value|((fastab+COFF)[a]&CB)
end_define

begin_define
define|#
directive|define
name|isquo
parameter_list|(
name|a
parameter_list|)
value|((fastab+COFF)[a]&QB)
end_define

begin_define
define|#
directive|define
name|iswarn
parameter_list|(
name|a
parameter_list|)
value|((fastab+COFF)[a]&WB)
end_define

begin_define
define|#
directive|define
name|eob
parameter_list|(
name|a
parameter_list|)
value|((a)>=pend)
end_define

begin_define
define|#
directive|define
name|bob
parameter_list|(
name|a
parameter_list|)
value|(pbeg>=(a))
end_define

begin_define
define|#
directive|define
name|cputc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|if(!flslvl) putc(a,b)
end_define

begin_decl_stmt
name|char
name|buffer
index|[
name|NCPS
operator|+
name|BUFSIZ
operator|+
name|BUFSIZ
operator|+
name|NCPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lastcopy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DROP
value|0xFE
end_define

begin_comment
comment|/* special character not legal ASCII or EBCDIC */
end_comment

begin_define
define|#
directive|define
name|WARN
value|DROP
end_define

begin_define
define|#
directive|define
name|SAME
value|0
end_define

begin_define
define|#
directive|define
name|MAXINC
value|10
end_define

begin_define
define|#
directive|define
name|MAXFRE
value|14
end_define

begin_comment
comment|/* max buffers of macro pushback */
end_comment

begin_define
define|#
directive|define
name|MAXFRM
value|31
end_define

begin_comment
comment|/* max number of formals/actuals to a macro */
end_comment

begin_decl_stmt
specifier|static
name|char
name|warnc
init|=
name|WARN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mactop
decl_stmt|,
name|fretop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|instack
index|[
name|MAXFRE
index|]
decl_stmt|,
modifier|*
name|bufstack
index|[
name|MAXFRE
index|]
decl_stmt|,
modifier|*
name|endbuf
index|[
name|MAXFRE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|plvl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* parenthesis level during scan for macro actuals */
end_comment

begin_decl_stmt
name|int
name|maclin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number of macro call requiring actuals */
end_comment

begin_decl_stmt
name|char
modifier|*
name|macfil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file name of macro call requiring actuals */
end_comment

begin_decl_stmt
name|char
modifier|*
name|macnam
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of macro requiring actuals */
end_comment

begin_decl_stmt
name|int
name|maclvl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # calls since last decrease in nesting level */
end_comment

begin_decl_stmt
name|char
modifier|*
name|macforw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer which must be exceeded to decrease nesting level */
end_comment

begin_decl_stmt
name|int
name|macdam
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offset to macforw due to buffer shifting */
end_comment

begin_if
if|#
directive|if
name|tgp
end_if

begin_decl_stmt
name|int
name|tgpscan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag for dump(); */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|STATIC
name|int
name|inctop
index|[
name|MAXINC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|fnames
index|[
name|MAXINC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|dirnams
index|[
name|MAXINC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* actual directory of #include files */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|fins
index|[
name|MAXINC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|lineno
index|[
name|MAXINC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|dirs
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -I and<> directories */
end_comment

begin_decl_stmt
name|char
modifier|*
name|strdex
argument_list|()
decl_stmt|,
modifier|*
name|copy
argument_list|()
decl_stmt|,
modifier|*
name|subst
argument_list|()
decl_stmt|,
modifier|*
name|trmdir
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|symtab
modifier|*
name|stsym
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|STATIC
name|int
name|fin
init|=
name|FIRSTOPEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|FILE
modifier|*
name|fout
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|nd
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|pflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't put out lines "# 12 foo.c" */
end_comment

begin_decl_stmt
name|int
name|passcom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't delete comments */
end_comment

begin_decl_stmt
name|int
name|incomment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if parsing a comment */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* allow macro recursion */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|mflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generate makefile dependencies */
end_comment

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of .o file to build dependencies from */
end_comment

begin_decl_stmt
name|STATIC
name|FILE
modifier|*
name|mout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file to place dependencies on */
end_comment

begin_define
define|#
directive|define
name|START
value|1
end_define

begin_define
define|#
directive|define
name|CONT
value|2
end_define

begin_define
define|#
directive|define
name|BACK
value|3
end_define

begin_decl_stmt
name|STATIC
name|int
name|ifno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NPREDEF
value|30
end_define

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|prespc
index|[
name|NPREDEF
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
modifier|*
name|predef
init|=
name|prespc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|punspc
index|[
name|NPREDEF
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
modifier|*
name|prund
init|=
name|punspc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|exfail
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|symtab
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|}
modifier|*
name|lastsym
struct|,
modifier|*
name|lookup
argument_list|()
struct|,
modifier|*
name|slookup
argument_list|()
struct|;
end_struct

begin_if
if|#
directive|if
name|gcos
end_if

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_decl_stmt
specifier|static
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|main
value|mainpp
end_define

begin_undef
undef|#
directive|undef
name|exit
end_undef

begin_define
define|#
directive|define
name|exit
parameter_list|(
name|S
parameter_list|)
value|longjmp(env, 1)
end_define

begin_define
define|#
directive|define
name|open
parameter_list|(
name|S
parameter_list|,
name|D
parameter_list|)
value|fileno(fopen(S, "r"))
end_define

begin_define
define|#
directive|define
name|close
parameter_list|(
name|F
parameter_list|)
value|fclose(_f[F])
end_define

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|_f
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|symsiz
value|500
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|symsiz
value|2000
end_define

begin_comment
comment|/* std = 500, wnj aug 1979 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|STATIC
name|struct
name|symtab
name|stab
index|[
name|symsiz
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|defloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|udfloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|incloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|ifloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|elsloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|eifloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|ifdloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|ifnloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|ysysloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|varloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|lneloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|ulnloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|uflloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|symtab
modifier|*
name|identloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sys 5r3 compatibility */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|trulvl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|flslvl
decl_stmt|;
end_decl_stmt

begin_macro
name|sayline
argument_list|(
argument|where
argument_list|)
end_macro

begin_decl_stmt
name|int
name|where
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|mflag
operator|&&
name|where
operator|==
name|START
condition|)
name|fprintf
argument_list|(
name|mout
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|infile
argument_list|,
name|fnames
index|[
name|ifno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflag
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"# %d \"%s\"\n"
argument_list|,
name|lineno
index|[
name|ifno
index|]
argument_list|,
name|fnames
index|[
name|ifno
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* data structure guide /* /* most of the scanning takes place in the buffer: /* /*  (low address)                                             (high address) /*  pbeg                           pbuf                                 pend /*  |<-- BUFSIZ chars -->      |<-- BUFSIZ chars -->        | /*  _______________________________________________________________________ /* |_______________________________________________________________________| /*          |               |               | /*          |<-- waiting -->|               |<-- waiting --> /*          |    to be      |<-- current -->|    to be /*          |    written    |    token      |    scanned /*          |               |               | /*          outp            inp             p /* /*  *outp   first char not yet written to output file /*  *inp    first char of current token /*  *p      first char not yet scanned /* /* macro expansion: write from *outp to *inp (chars waiting to be written), /* ignore from *inp to *p (chars of the macro call), place generated /* characters in front of *p (in reverse order), update pointers, /* resume scanning. /* /* symbol table pointers point to just beyond the end of macro definitions; /* the first preceding character is the number of formal parameters. /* the appearance of a formal in the body of a definition is marked by /* 2 chars: the char WARN, and a char containing the parameter number. /* the first char of a definition is preceded by a zero character. /* /* when macro expansion attempts to back up over the beginning of the /* buffer, some characters preceding *pend are saved in a side buffer, /* the address of the side buffer is put on 'instack', and the rest /* of the main buffer is moved to the right.  the end of the saved buffer /* is kept in 'endbuf' since there may be nulls in the saved buffer. /* /* similar action is taken when an 'include' statement is processed, /* except that the main buffer must be completely emptied.  the array /* element 'inctop[ifno]' records the last side buffer saved when /* file 'ifno' was included.  these buffers remain dormant while /* the file is being read, and are reactivated at end-of-file. /* /* instack[0 : mactop] holds the addresses of all pending side buffers. /* instack[inctop[ifno]+1 : mactop-1] holds the addresses of the side /* buffers which are "live"; the side buffers instack[0 : inctop[ifno]] /* are dormant, waiting for end-of-file on the current file. /* /* space for side buffers is obtained from 'malloc' and is never returned. /* bufstack[0:fretop-1] holds addresses of side buffers which /* are available for use. */
end_comment

begin_macro
name|dump
argument_list|()
end_macro

begin_block
block|{
comment|/* write part of buffer which lies between  outp  and  inp . /* this should be a direct call to 'write', but the system slows to a crawl /* if it has to do an unaligned copy.  thus we buffer.  this silly loop /* is 15% of the total time, thus even the 'putc' macro is too slow. */
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|(
name|p1
operator|=
name|outp
operator|)
operator|==
name|inp
operator|||
name|flslvl
operator|!=
literal|0
condition|)
return|return;
if|#
directive|if
name|tgp
define|#
directive|define
name|MAXOUT
value|80
if|if
condition|(
operator|!
name|tgpscan
condition|)
block|{
comment|/* scan again to insure<= MAXOUT chars between linefeeds */
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|pblank
decl_stmt|;
name|char
name|savc
decl_stmt|,
name|stopc
decl_stmt|,
name|brk
decl_stmt|;
name|tgpscan
operator|=
literal|1
expr_stmt|;
name|brk
operator|=
name|stopc
operator|=
name|pblank
operator|=
literal|0
expr_stmt|;
name|p2
operator|=
name|inp
expr_stmt|;
name|savc
operator|=
operator|*
name|p2
expr_stmt|;
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p1
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|stopc
operator|==
name|c
condition|)
name|stopc
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'\''
condition|)
name|stopc
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|p1
operator|-
name|outp
operator|>
name|MAXOUT
operator|&&
name|pblank
operator|!=
literal|0
condition|)
block|{
operator|*
name|pblank
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|inp
operator|=
name|pblank
expr_stmt|;
name|dump
argument_list|()
expr_stmt|;
name|brk
operator|=
literal|1
expr_stmt|;
name|pblank
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|stopc
operator|==
literal|0
condition|)
name|pblank
operator|=
name|p1
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|brk
condition|)
name|sayline
argument_list|(
name|CONT
argument_list|)
expr_stmt|;
operator|*
name|p2
operator|=
name|savc
expr_stmt|;
name|inp
operator|=
name|p2
expr_stmt|;
name|p1
operator|=
name|outp
expr_stmt|;
name|tgpscan
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|f
operator|=
name|fout
expr_stmt|;
if|#
directive|if
name|gcos
comment|/* filter out "$ program c" card if first line of input */
comment|/* gmatch is a simple pattern matcher in the GCOS Standard Library */
block|{
specifier|static
name|int
name|gmfirst
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|gmfirst
condition|)
block|{
operator|++
name|gmfirst
expr_stmt|;
if|if
condition|(
name|gmatch
argument_list|(
name|p1
argument_list|,
literal|"^$*program[ \t]*c*"
argument_list|)
condition|)
name|p1
operator|=
name|strdex
argument_list|(
name|p1
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
while|while
condition|(
name|p1
operator|<
name|inp
condition|)
name|putc
argument_list|(
operator|*
name|p1
operator|++
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|outp
operator|=
name|p1
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|refill
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
comment|/* dump buffer.  save chars from inp to p.  read into buffer at pbuf, /* contiguous with p.  update pointers, return new p. */
specifier|register
name|char
modifier|*
name|np
decl_stmt|,
modifier|*
name|op
decl_stmt|;
specifier|register
name|int
name|ninbuf
decl_stmt|;
name|dump
argument_list|()
expr_stmt|;
name|np
operator|=
name|pbuf
operator|-
operator|(
name|p
operator|-
name|inp
operator|)
expr_stmt|;
name|op
operator|=
name|inp
expr_stmt|;
if|if
condition|(
name|bob
argument_list|(
name|np
operator|+
literal|1
argument_list|)
condition|)
block|{
name|pperror
argument_list|(
literal|"token too long"
argument_list|)
expr_stmt|;
name|np
operator|=
name|pbeg
expr_stmt|;
name|p
operator|=
name|inp
operator|+
name|BUFSIZ
expr_stmt|;
block|}
name|macdam
operator|+=
name|np
operator|-
name|inp
expr_stmt|;
name|outp
operator|=
name|inp
operator|=
name|np
expr_stmt|;
while|while
condition|(
name|op
operator|<
name|p
condition|)
operator|*
name|np
operator|++
operator|=
operator|*
name|op
operator|++
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|mactop
operator|>
name|inctop
index|[
name|ifno
index|]
condition|)
block|{
comment|/* retrieve hunk of pushed-back macro text */
name|op
operator|=
name|instack
index|[
operator|--
name|mactop
index|]
expr_stmt|;
name|np
operator|=
name|pbuf
expr_stmt|;
do|do
block|{
while|while
condition|(
operator|*
name|np
operator|++
operator|=
operator|*
name|op
operator|++
condition|)
empty_stmt|;
block|}
do|while
condition|(
name|op
operator|<
name|endbuf
index|[
name|mactop
index|]
condition|)
do|;
name|pend
operator|=
name|np
operator|-
literal|1
expr_stmt|;
comment|/* make buffer space avail for 'include' processing */
if|if
condition|(
name|fretop
operator|<
name|MAXFRE
condition|)
name|bufstack
index|[
name|fretop
operator|++
index|]
operator|=
name|instack
index|[
name|mactop
index|]
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
else|else
block|{
comment|/* get more text from file(s) */
name|maclvl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|<
operator|(
name|ninbuf
operator|=
name|read
argument_list|(
name|fin
argument_list|,
name|pbuf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
condition|)
block|{
name|pend
operator|=
name|pbuf
operator|+
name|ninbuf
expr_stmt|;
operator|*
name|pend
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* end of #include file */
if|if
condition|(
name|ifno
operator|==
literal|0
condition|)
block|{
comment|/* end of input */
if|if
condition|(
name|plvl
operator|!=
literal|0
condition|)
block|{
name|int
name|n
init|=
name|plvl
decl_stmt|,
name|tlin
init|=
name|lineno
index|[
name|ifno
index|]
decl_stmt|;
name|char
modifier|*
name|tfil
init|=
name|fnames
index|[
name|ifno
index|]
decl_stmt|;
name|lineno
index|[
name|ifno
index|]
operator|=
name|maclin
expr_stmt|;
name|fnames
index|[
name|ifno
index|]
operator|=
name|macfil
expr_stmt|;
name|pperror
argument_list|(
literal|"%s: unterminated macro call"
argument_list|,
name|macnam
argument_list|)
expr_stmt|;
name|lineno
index|[
name|ifno
index|]
operator|=
name|tlin
expr_stmt|;
name|fnames
index|[
name|ifno
index|]
operator|=
name|tfil
expr_stmt|;
name|np
operator|=
name|p
expr_stmt|;
operator|*
name|np
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* shut off unterminated quoted string */
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
operator|*
name|np
operator|++
operator|=
literal|')'
expr_stmt|;
comment|/* supply missing parens */
name|pend
operator|=
name|np
expr_stmt|;
operator|*
name|np
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|plvl
operator|<
literal|0
condition|)
name|plvl
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
if|if
condition|(
name|trulvl
operator|||
name|flslvl
condition|)
if|if
condition|(
name|incomment
condition|)
name|pperror
argument_list|(
literal|"unterminated comment"
argument_list|)
expr_stmt|;
else|else
name|pperror
argument_list|(
literal|"missing endif"
argument_list|)
expr_stmt|;
name|inp
operator|=
name|p
expr_stmt|;
name|dump
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|exfail
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|fin
operator|=
name|fins
index|[
operator|--
name|ifno
index|]
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|=
name|dirnams
index|[
name|ifno
index|]
expr_stmt|;
name|sayline
argument_list|(
name|BACK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|BEG
value|0
end_define

begin_define
define|#
directive|define
name|LF
value|1
end_define

begin_function
name|char
modifier|*
name|cotoken
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|char
name|quoc
decl_stmt|;
specifier|static
name|int
name|state
init|=
name|BEG
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|BEG
condition|)
goto|goto
name|prevlf
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|again
label|:
while|while
condition|(
operator|!
name|isspc
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
empty_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|inp
operator|=
name|p
operator|-
literal|1
operator|)
condition|)
block|{
case|case
literal|0
case|:
block|{
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
block|{
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
else|else
operator|++
name|p
expr_stmt|;
comment|/* ignore null byte */
block|}
break|break;
case|case
literal|'|'
case|:
case|case
literal|'&'
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* sloscan only */
if|if
condition|(
operator|*
name|p
operator|++
operator|==
operator|*
name|inp
condition|)
break|break;
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
break|break;
case|case
literal|'='
case|:
case|case
literal|'!'
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* sloscan only */
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'='
condition|)
break|break;
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
break|break;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* sloscan only */
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'='
operator|||
name|p
index|[
operator|-
literal|2
index|]
operator|==
name|p
index|[
operator|-
literal|1
index|]
condition|)
break|break;
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
break|break;
case|case
literal|'\\'
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|lineno
index|[
name|ifno
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|p
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'/'
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'*'
condition|)
block|{
comment|/* comment */
name|incomment
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|passcom
condition|)
block|{
name|inp
operator|=
name|p
operator|-
literal|2
expr_stmt|;
name|dump
argument_list|()
expr_stmt|;
operator|++
name|flslvl
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|!
name|iscom
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'/'
condition|)
goto|goto
name|endcom
goto|;
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|passcom
condition|)
block|{
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|-
name|inp
operator|)
operator|>=
name|BUFSIZ
condition|)
block|{
comment|/* split long comment */
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* last char written is '*' */
name|cputc
argument_list|(
literal|'/'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
comment|/* terminate first part */
comment|/* and fake start of 2nd */
name|outp
operator|=
name|inp
operator|=
name|p
operator|-=
literal|3
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
else|else
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|lineno
index|[
name|ifno
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|passcom
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|passcom
condition|)
block|{
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|-
name|inp
operator|)
operator|>=
name|BUFSIZ
condition|)
block|{
comment|/* split long comment */
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cputc
argument_list|(
literal|'*'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|cputc
argument_list|(
literal|'/'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|outp
operator|=
name|inp
operator|=
name|p
operator|-=
literal|2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
else|else
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
operator|++
name|p
expr_stmt|;
comment|/* ignore null byte */
block|}
name|endcom
label|:
name|incomment
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|passcom
condition|)
block|{
name|outp
operator|=
name|inp
operator|=
name|p
expr_stmt|;
operator|--
name|flslvl
expr_stmt|;
goto|goto
name|again
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
break|break;
if|#
directive|if
name|gcos
case|case
literal|'`'
case|:
endif|#
directive|endif
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
block|{
name|quoc
operator|=
name|p
index|[
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|!
name|isquo
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
name|quoc
condition|)
break|break;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|--
name|p
expr_stmt|;
break|break;
block|}
comment|/* bare \n terminates quotation */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|lineno
index|[
name|ifno
index|]
expr_stmt|;
break|break;
block|}
comment|/* escaped \n ignored */
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|p
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
operator|++
name|p
expr_stmt|;
comment|/* it was a different quote character */
block|}
block|}
break|break;
case|case
literal|'\n'
case|:
block|{
operator|++
name|lineno
index|[
name|ifno
index|]
expr_stmt|;
if|if
condition|(
name|isslo
condition|)
block|{
name|state
operator|=
name|LF
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
name|prevlf
label|:
name|state
operator|=
name|BEG
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'#'
condition|)
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
name|eob
argument_list|(
name|inp
operator|=
operator|--
name|p
argument_list|)
condition|)
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
goto|goto
name|again
goto|;
block|}
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|isnum
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
break|break;
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
if|#
directive|if
name|scw1
define|#
directive|define
name|tmac1
parameter_list|(
name|c
parameter_list|,
name|bit
parameter_list|)
value|if (!xmac1(c,bit,&)) goto nomac
define|#
directive|define
name|xmac1
parameter_list|(
name|c
parameter_list|,
name|bit
parameter_list|,
name|op
parameter_list|)
value|((macbit+COFF)[c] op (bit))
else|#
directive|else
define|#
directive|define
name|tmac1
parameter_list|(
name|c
parameter_list|,
name|bit
parameter_list|)
define|#
directive|define
name|xmac1
parameter_list|(
name|c
parameter_list|,
name|bit
parameter_list|,
name|op
parameter_list|)
endif|#
directive|endif
if|#
directive|if
name|scw2
define|#
directive|define
name|tmac2
parameter_list|(
name|c0
parameter_list|,
name|c1
parameter_list|,
name|cpos
parameter_list|)
value|if (!xmac2(c0,c1,cpos,&)) goto nomac
define|#
directive|define
name|xmac2
parameter_list|(
name|c0
parameter_list|,
name|c1
parameter_list|,
name|cpos
parameter_list|,
name|op
parameter_list|)
define|\
value|((macbit+COFF)[(t21+COFF)[c0]+(t22+COFF)[c1]] op (t23+COFF+cpos)[c0])
else|#
directive|else
define|#
directive|define
name|tmac2
parameter_list|(
name|c0
parameter_list|,
name|c1
parameter_list|,
name|cpos
parameter_list|)
define|#
directive|define
name|xmac2
parameter_list|(
name|c0
parameter_list|,
name|c1
parameter_list|,
name|cpos
parameter_list|,
name|op
parameter_list|)
endif|#
directive|endif
if|if
condition|(
name|flslvl
condition|)
goto|goto
name|nomac
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|p
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|tmac1
argument_list|(
name|c
argument_list|,
name|b0
argument_list|)
expr_stmt|;
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isid
argument_list|(
name|i
argument_list|)
condition|)
goto|goto
name|endid
goto|;
name|tmac1
argument_list|(
name|i
argument_list|,
name|b1
argument_list|)
expr_stmt|;
name|tmac2
argument_list|(
name|c
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isid
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|endid
goto|;
name|tmac1
argument_list|(
name|c
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|tmac2
argument_list|(
name|i
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isid
argument_list|(
name|i
argument_list|)
condition|)
goto|goto
name|endid
goto|;
name|tmac1
argument_list|(
name|i
argument_list|,
name|b3
argument_list|)
expr_stmt|;
name|tmac2
argument_list|(
name|c
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isid
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|endid
goto|;
name|tmac1
argument_list|(
name|c
argument_list|,
name|b4
argument_list|)
expr_stmt|;
name|tmac2
argument_list|(
name|i
argument_list|,
name|c
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isid
argument_list|(
name|i
argument_list|)
condition|)
goto|goto
name|endid
goto|;
name|tmac1
argument_list|(
name|i
argument_list|,
name|b5
argument_list|)
expr_stmt|;
name|tmac2
argument_list|(
name|c
argument_list|,
name|i
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isid
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|endid
goto|;
name|tmac1
argument_list|(
name|c
argument_list|,
name|b6
argument_list|)
expr_stmt|;
name|tmac2
argument_list|(
name|i
argument_list|,
name|c
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isid
argument_list|(
name|i
argument_list|)
condition|)
goto|goto
name|endid
goto|;
name|tmac1
argument_list|(
name|i
argument_list|,
name|b7
argument_list|)
expr_stmt|;
name|tmac2
argument_list|(
name|c
argument_list|,
name|i
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|tmac2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
while|while
condition|(
name|isid
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
block|{
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|inp
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
goto|goto
name|lokid
goto|;
name|endid
label|:
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
block|{
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|inp
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
name|tmac2
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
operator|+
operator|(
name|p
operator|-
name|inp
operator|)
argument_list|)
expr_stmt|;
name|lokid
label|:
name|slookup
argument_list|(
name|inp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|newp
condition|)
block|{
name|p
operator|=
name|newp
expr_stmt|;
goto|goto
name|again
goto|;
block|}
else|else
break|break;
name|nomac
label|:
while|while
condition|(
name|isid
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|eob
argument_list|(
operator|--
name|p
argument_list|)
condition|)
block|{
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|nomac
goto|;
block|}
else|else
break|break;
block|}
break|break;
block|}
comment|/* end of switch */
if|if
condition|(
name|isslo
condition|)
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* end of infinite loop */
block|}
end_function

begin_function
name|char
modifier|*
name|skipbl
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
comment|/* get next non-blank token */
do|do
block|{
name|outp
operator|=
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|toktyp
operator|+
name|COFF
operator|)
index|[
operator|*
name|inp
index|]
operator|==
name|BLANK
condition|)
do|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|unfill
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
comment|/* take<= BUFSIZ chars from right end of buffer and put them on instack . /* slide rest of buffer to the right, update pointers, return new p. */
specifier|register
name|char
modifier|*
name|np
decl_stmt|,
modifier|*
name|op
decl_stmt|;
specifier|register
name|int
name|d
decl_stmt|;
if|if
condition|(
name|mactop
operator|>=
name|MAXFRE
condition|)
block|{
name|pperror
argument_list|(
literal|"%s: too much pushback"
argument_list|,
name|macnam
argument_list|)
expr_stmt|;
name|p
operator|=
name|inp
operator|=
name|pend
expr_stmt|;
name|dump
argument_list|()
expr_stmt|;
comment|/* begin flushing pushback */
while|while
condition|(
name|mactop
operator|>
name|inctop
index|[
name|ifno
index|]
condition|)
block|{
name|p
operator|=
name|refill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|inp
operator|=
name|pend
expr_stmt|;
name|dump
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fretop
operator|>
literal|0
condition|)
name|np
operator|=
name|bufstack
index|[
operator|--
name|fretop
index|]
expr_stmt|;
else|else
block|{
name|np
operator|=
name|malloc
argument_list|(
name|BUFSIZ
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|pperror
argument_list|(
literal|"no space"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exfail
argument_list|)
expr_stmt|;
block|}
name|np
index|[
name|BUFSIZ
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|instack
index|[
name|mactop
index|]
operator|=
name|np
expr_stmt|;
name|op
operator|=
name|pend
operator|-
name|BUFSIZ
expr_stmt|;
if|if
condition|(
name|op
operator|<
name|p
condition|)
name|op
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|np
operator|++
operator|=
operator|*
name|op
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|eob
argument_list|(
name|op
argument_list|)
condition|)
break|break;
block|}
comment|/* out with old */
name|endbuf
index|[
name|mactop
operator|++
index|]
operator|=
name|np
expr_stmt|;
comment|/* mark end of saved text */
name|np
operator|=
name|pbuf
operator|+
name|BUFSIZ
expr_stmt|;
name|op
operator|=
name|pend
operator|-
name|BUFSIZ
expr_stmt|;
name|pend
operator|=
name|np
expr_stmt|;
if|if
condition|(
name|op
operator|<
name|p
condition|)
name|op
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|outp
operator|<
name|op
condition|)
operator|*
operator|--
name|np
operator|=
operator|*
operator|--
name|op
expr_stmt|;
comment|/* slide over new */
if|if
condition|(
name|bob
argument_list|(
name|np
argument_list|)
condition|)
name|pperror
argument_list|(
literal|"token too long"
argument_list|)
expr_stmt|;
name|d
operator|=
name|np
operator|-
name|outp
expr_stmt|;
name|outp
operator|+=
name|d
expr_stmt|;
name|inp
operator|+=
name|d
expr_stmt|;
name|macdam
operator|+=
name|d
expr_stmt|;
return|return
operator|(
name|p
operator|+
name|d
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|doincl
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|filok
decl_stmt|,
name|inctype
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
modifier|*
name|dirp
decl_stmt|,
modifier|*
name|nfil
decl_stmt|;
name|char
name|filname
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|p
operator|=
name|skipbl
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cp
operator|=
name|filname
expr_stmt|;
if|if
condition|(
operator|*
name|inp
operator|++
operator|==
literal|'<'
condition|)
block|{
comment|/* special<> syntax */
name|inctype
operator|=
literal|1
expr_stmt|;
operator|++
name|flslvl
expr_stmt|;
comment|/* prevent macro expansion */
for|for
control|(
init|;
condition|;
control|)
block|{
name|outp
operator|=
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|inp
operator|==
literal|'\n'
condition|)
block|{
operator|--
name|p
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|inp
operator|==
literal|'>'
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|gimpel
if|if
condition|(
operator|*
name|inp
operator|==
literal|'.'
operator|&&
operator|!
name|intss
argument_list|()
condition|)
operator|*
name|inp
operator|=
literal|'#'
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|inp
operator|<
name|p
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|inp
operator|++
expr_stmt|;
block|}
operator|--
name|flslvl
expr_stmt|;
comment|/* reenable macro expansion */
block|}
elseif|else
if|if
condition|(
name|inp
index|[
operator|-
literal|1
index|]
operator|==
literal|'"'
condition|)
block|{
comment|/* regular "" syntax */
name|inctype
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|gimpel
while|while
condition|(
name|inp
operator|<
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|inp
operator|==
literal|'.'
operator|&&
operator|!
name|intss
argument_list|()
condition|)
operator|*
name|inp
operator|=
literal|'#'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|*
name|inp
operator|++
expr_stmt|;
block|}
else|#
directive|else
while|while
condition|(
name|inp
operator|<
name|p
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|inp
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
operator|--
name|cp
operator|==
literal|'"'
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|pperror
argument_list|(
literal|"bad include syntax"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inctype
operator|=
literal|2
expr_stmt|;
block|}
comment|/* flush current file to \n , then write \n */
operator|++
name|flslvl
expr_stmt|;
do|do
block|{
name|outp
operator|=
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|inp
operator|!=
literal|'\n'
condition|)
do|;
operator|--
name|flslvl
expr_stmt|;
name|inp
operator|=
name|p
expr_stmt|;
name|dump
argument_list|()
expr_stmt|;
if|if
condition|(
name|inctype
operator|==
literal|2
condition|)
return|return
operator|(
name|p
operator|)
return|;
comment|/* look for included file */
if|if
condition|(
name|ifno
operator|+
literal|1
operator|>=
name|MAXINC
condition|)
block|{
name|pperror
argument_list|(
literal|"Unreasonable include nesting"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|nfil
operator|=
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pperror
argument_list|(
literal|"no space"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exfail
argument_list|)
expr_stmt|;
block|}
name|filok
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dirp
operator|=
name|dirs
operator|+
name|inctype
init|;
operator|*
name|dirp
condition|;
operator|++
name|dirp
control|)
block|{
if|if
condition|(
if|#
directive|if
name|gcos
name|strdex
argument_list|(
argument|filname
argument_list|,
literal|'/'
argument_list|)
else|#
directive|else
name|filname
index|[
literal|0
index|]
operator|==
literal|'/'
endif|#
directive|endif
operator|||
operator|*
operator|*
name|dirp
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|nfil
argument_list|,
name|filname
argument_list|)
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|nfil
argument_list|,
operator|*
name|dirp
argument_list|)
expr_stmt|;
if|#
directive|if
name|unix
operator|||
name|gcos
name|strcat
argument_list|(
name|nfil
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ibm
ifndef|#
directive|ifndef
name|gimpel
name|strcat
argument_list|(
name|nfil
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|strcat
argument_list|(
name|nfil
argument_list|,
name|filname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<
operator|(
name|fins
index|[
name|ifno
operator|+
literal|1
index|]
operator|=
name|open
argument_list|(
name|nfil
argument_list|,
name|READ
argument_list|)
operator|)
condition|)
block|{
name|filok
operator|=
literal|1
expr_stmt|;
name|fin
operator|=
name|fins
index|[
operator|++
name|ifno
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|filok
operator|==
literal|0
condition|)
block|{
name|pperror
argument_list|(
literal|"Can't find include file %s"
argument_list|,
name|filname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nfil
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfil
operator|=
name|realloc
argument_list|(
name|nfil
argument_list|,
name|strlen
argument_list|(
name|nfil
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lineno
index|[
name|ifno
index|]
operator|=
literal|1
expr_stmt|;
name|fnames
index|[
name|ifno
index|]
operator|=
name|nfil
expr_stmt|;
name|dirnams
index|[
name|ifno
index|]
operator|=
name|dirs
index|[
literal|0
index|]
operator|=
name|trmdir
argument_list|(
name|copy
argument_list|(
name|nfil
argument_list|)
argument_list|)
expr_stmt|;
name|sayline
argument_list|(
name|START
argument_list|)
expr_stmt|;
comment|/* save current contents of buffer */
while|while
condition|(
operator|!
name|eob
argument_list|(
name|p
argument_list|)
condition|)
name|p
operator|=
name|unfill
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|inctop
index|[
name|ifno
index|]
operator|=
name|mactop
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|equfrm
argument_list|(
name|a
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
specifier|register
name|char
operator|*
name|a
operator|,
operator|*
name|p1
operator|,
operator|*
name|p2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|c
operator|=
operator|*
name|p2
expr_stmt|;
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
name|flag
operator|=
name|strcmp
argument_list|(
name|a
argument_list|,
name|p1
argument_list|)
expr_stmt|;
operator|*
name|p2
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|flag
operator|==
name|SAME
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|dodef
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
comment|/* process '#define' */
specifier|register
name|char
modifier|*
name|pin
decl_stmt|,
modifier|*
name|psav
decl_stmt|,
modifier|*
name|cf
decl_stmt|;
name|char
modifier|*
modifier|*
name|pf
decl_stmt|,
modifier|*
modifier|*
name|qf
decl_stmt|;
name|int
name|b
decl_stmt|,
name|c
decl_stmt|,
name|params
decl_stmt|;
name|struct
name|symtab
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|oldval
decl_stmt|;
name|char
modifier|*
name|space
decl_stmt|,
modifier|*
name|newspace
decl_stmt|;
name|char
modifier|*
name|formal
index|[
name|MAXFRM
index|]
decl_stmt|;
comment|/* formal[n] is name of nth formal */
name|char
name|formtxt
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* space for formal names */
name|int
name|opt_passcom
init|=
name|passcom
decl_stmt|;
name|passcom
operator|=
literal|0
expr_stmt|;
comment|/* don't put comments in macro expansions */
operator|++
name|flslvl
expr_stmt|;
comment|/* prevent macro expansion during 'define' */
name|p
operator|=
name|skipbl
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pin
operator|=
name|inp
expr_stmt|;
if|if
condition|(
operator|(
name|toktyp
operator|+
name|COFF
operator|)
index|[
operator|*
name|pin
index|]
operator|!=
name|IDENT
condition|)
block|{
name|ppwarn
argument_list|(
literal|"illegal macro name"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|inp
operator|!=
literal|'\n'
condition|)
name|p
operator|=
name|skipbl
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|passcom
operator|=
name|opt_passcom
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
name|np
operator|=
name|slookup
argument_list|(
name|pin
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldval
operator|=
name|np
operator|->
name|value
condition|)
name|free
argument_list|(
name|lastcopy
argument_list|)
expr_stmt|;
comment|/* was previously defined */
name|b
operator|=
literal|1
expr_stmt|;
name|cf
operator|=
name|pin
expr_stmt|;
while|while
condition|(
name|cf
operator|<
name|p
condition|)
block|{
comment|/* update macbit */
name|c
operator|=
operator|*
name|cf
operator|++
expr_stmt|;
name|xmac1
argument_list|(
name|c
argument_list|,
name|b
argument_list|,
operator||=
argument_list|)
expr_stmt|;
name|b
operator|=
operator|(
name|b
operator|+
name|b
operator|)
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|cf
operator|!=
name|p
condition|)
name|xmac2
argument_list|(
name|c
argument_list|,
operator|*
name|cf
argument_list|,
operator|-
literal|1
operator|+
operator|(
name|cf
operator|-
name|pin
operator|)
argument_list|,
operator||=
argument_list|)
expr_stmt|;
else|else
name|xmac2
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
operator|+
operator|(
name|cf
operator|-
name|pin
operator|)
argument_list|,
operator||=
argument_list|)
expr_stmt|;
block|}
name|params
operator|=
literal|0
expr_stmt|;
name|outp
operator|=
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pin
operator|=
name|inp
expr_stmt|;
if|if
condition|(
operator|*
name|pin
operator|==
literal|'('
condition|)
block|{
comment|/* with parameters; identify the formals */
name|cf
operator|=
name|formtxt
expr_stmt|;
name|pf
operator|=
name|formal
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
operator|=
name|skipbl
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pin
operator|=
name|inp
expr_stmt|;
if|if
condition|(
operator|*
name|pin
operator|==
literal|'\n'
condition|)
block|{
operator|--
name|lineno
index|[
name|ifno
index|]
expr_stmt|;
operator|--
name|p
expr_stmt|;
name|pperror
argument_list|(
literal|"%s: missing )"
argument_list|,
name|np
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|pin
operator|==
literal|')'
condition|)
break|break;
if|if
condition|(
operator|*
name|pin
operator|==
literal|','
condition|)
continue|continue;
if|if
condition|(
operator|(
name|toktyp
operator|+
name|COFF
operator|)
index|[
operator|*
name|pin
index|]
operator|!=
name|IDENT
condition|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|pperror
argument_list|(
literal|"bad formal: %s"
argument_list|,
name|pin
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pf
operator|>=
operator|&
name|formal
index|[
name|MAXFRM
index|]
condition|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|pperror
argument_list|(
literal|"too many formals: %s"
argument_list|,
name|pin
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pf
operator|++
operator|=
name|cf
expr_stmt|;
while|while
condition|(
name|pin
operator|<
name|p
condition|)
operator|*
name|cf
operator|++
operator|=
operator|*
name|pin
operator|++
expr_stmt|;
operator|*
name|cf
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|params
expr_stmt|;
block|}
block|}
if|if
condition|(
name|params
operator|==
literal|0
condition|)
operator|--
name|params
expr_stmt|;
comment|/* #define foo() ... */
block|}
elseif|else
if|if
condition|(
operator|*
name|pin
operator|==
literal|'\n'
condition|)
block|{
operator|--
name|lineno
index|[
name|ifno
index|]
expr_stmt|;
operator|--
name|p
expr_stmt|;
block|}
comment|/* remember beginning of macro body, so that we can 	/* warn if a redefinition is different from old value. 	*/
name|space
operator|=
name|psav
operator|=
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|==
name|NULL
condition|)
block|{
name|pperror
argument_list|(
literal|"too much defining"
argument_list|)
expr_stmt|;
name|passcom
operator|=
name|opt_passcom
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
operator|*
name|psav
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* accumulate definition until linefeed */
name|outp
operator|=
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pin
operator|=
name|inp
expr_stmt|;
if|if
condition|(
operator|*
name|pin
operator|==
literal|'\\'
operator|&&
name|pin
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* ignore escaped lf */
if|if
condition|(
operator|*
name|pin
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|params
condition|)
block|{
comment|/* mark the appearance of formals in the definiton */
if|if
condition|(
operator|(
name|toktyp
operator|+
name|COFF
operator|)
index|[
operator|*
name|pin
index|]
operator|==
name|IDENT
condition|)
block|{
for|for
control|(
name|qf
operator|=
name|pf
init|;
operator|--
name|qf
operator|>=
name|formal
condition|;
control|)
block|{
if|if
condition|(
name|equfrm
argument_list|(
operator|*
name|qf
argument_list|,
name|pin
argument_list|,
name|p
argument_list|)
condition|)
block|{
operator|*
name|psav
operator|++
operator|=
name|qf
operator|-
name|formal
operator|+
literal|1
expr_stmt|;
operator|*
name|psav
operator|++
operator|=
name|WARN
expr_stmt|;
name|pin
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|pin
operator|==
literal|'"'
operator|||
operator|*
name|pin
operator|==
literal|'\''
if|#
directive|if
name|gcos
operator|||
operator|*
name|pin
operator|==
literal|'`'
endif|#
directive|endif
condition|)
block|{
comment|/* inside quotation marks, too */
name|char
name|quoc
init|=
operator|*
name|pin
decl_stmt|;
for|for
control|(
operator|*
name|psav
operator|++
operator|=
operator|*
name|pin
operator|++
init|;
name|pin
operator|<
name|p
operator|&&
operator|*
name|pin
operator|!=
name|quoc
condition|;
control|)
block|{
while|while
condition|(
name|pin
operator|<
name|p
operator|&&
operator|!
name|isid
argument_list|(
operator|*
name|pin
argument_list|)
condition|)
operator|*
name|psav
operator|++
operator|=
operator|*
name|pin
operator|++
expr_stmt|;
name|cf
operator|=
name|pin
expr_stmt|;
while|while
condition|(
name|cf
operator|<
name|p
operator|&&
name|isid
argument_list|(
operator|*
name|cf
argument_list|)
condition|)
operator|++
name|cf
expr_stmt|;
for|for
control|(
name|qf
operator|=
name|pf
init|;
operator|--
name|qf
operator|>=
name|formal
condition|;
control|)
block|{
if|if
condition|(
name|equfrm
argument_list|(
operator|*
name|qf
argument_list|,
name|pin
argument_list|,
name|cf
argument_list|)
condition|)
block|{
operator|*
name|psav
operator|++
operator|=
name|qf
operator|-
name|formal
operator|+
literal|1
expr_stmt|;
operator|*
name|psav
operator|++
operator|=
name|WARN
expr_stmt|;
name|pin
operator|=
name|cf
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|pin
operator|<
name|cf
condition|)
operator|*
name|psav
operator|++
operator|=
operator|*
name|pin
operator|++
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|pin
operator|<
name|p
condition|)
operator|*
name|psav
operator|++
operator|=
operator|*
name|pin
operator|++
expr_stmt|;
block|}
operator|*
name|psav
operator|++
operator|=
name|params
expr_stmt|;
operator|*
name|psav
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|cf
operator|=
name|oldval
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* redefinition */
operator|--
name|cf
expr_stmt|;
comment|/* skip no. of params, which may be zero */
while|while
condition|(
operator|*
operator|--
name|cf
condition|)
empty_stmt|;
comment|/* go back to the beginning */
if|if
condition|(
literal|0
operator|!=
name|strcmp
argument_list|(
operator|++
name|cf
argument_list|,
name|space
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* redefinition different from old */
operator|--
name|lineno
index|[
name|ifno
index|]
expr_stmt|;
name|ppwarn
argument_list|(
literal|"%s redefined"
argument_list|,
name|np
operator|->
name|name
argument_list|)
expr_stmt|;
operator|++
name|lineno
index|[
name|ifno
index|]
expr_stmt|;
name|np
operator|->
name|value
operator|=
name|psav
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|space
argument_list|)
expr_stmt|;
comment|/* identical redef.; reclaim space */
block|}
else|else
name|np
operator|->
name|value
operator|=
name|psav
operator|-
literal|1
expr_stmt|;
operator|--
name|flslvl
expr_stmt|;
name|inp
operator|=
name|pin
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|value
operator|==
name|psav
operator|-
literal|1
condition|)
block|{
name|newspace
operator|=
name|realloc
argument_list|(
name|space
argument_list|,
name|psav
operator|-
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|newspace
operator|==
name|NULL
condition|)
block|{
name|pperror
argument_list|(
literal|"no space"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exfail
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Adjust pointer in case this moved. 		 */
name|np
operator|->
name|value
operator|+=
name|newspace
operator|-
name|space
expr_stmt|;
block|}
name|passcom
operator|=
name|opt_passcom
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|fasscan
parameter_list|()
value|ptrtab=fastab+COFF
end_define

begin_define
define|#
directive|define
name|sloscan
parameter_list|()
value|ptrtab=slotab+COFF
end_define

begin_function
name|char
modifier|*
name|control
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
comment|/* find and handle preprocessor control lines */
specifier|register
name|struct
name|symtab
modifier|*
name|np
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fasscan
argument_list|()
expr_stmt|;
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|inp
operator|==
literal|'\n'
condition|)
operator|++
name|inp
expr_stmt|;
name|dump
argument_list|()
expr_stmt|;
name|sloscan
argument_list|()
expr_stmt|;
name|p
operator|=
name|skipbl
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
operator|--
name|inp
operator|=
name|SALT
expr_stmt|;
name|outp
operator|=
name|inp
expr_stmt|;
operator|++
name|flslvl
expr_stmt|;
name|np
operator|=
name|slookup
argument_list|(
name|inp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|flslvl
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|defloc
condition|)
block|{
comment|/* define */
if|if
condition|(
name|flslvl
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|dodef
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|np
operator|==
name|incloc
condition|)
block|{
comment|/* include */
if|if
condition|(
name|flslvl
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|doincl
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|np
operator|==
name|ifnloc
condition|)
block|{
comment|/* ifndef */
operator|++
name|flslvl
expr_stmt|;
name|p
operator|=
name|skipbl
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|np
operator|=
name|slookup
argument_list|(
name|inp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|flslvl
expr_stmt|;
if|if
condition|(
name|flslvl
operator|==
literal|0
operator|&&
name|np
operator|->
name|value
operator|==
literal|0
condition|)
operator|++
name|trulvl
expr_stmt|;
else|else
operator|++
name|flslvl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|np
operator|==
name|ifdloc
condition|)
block|{
comment|/* ifdef */
operator|++
name|flslvl
expr_stmt|;
name|p
operator|=
name|skipbl
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|np
operator|=
name|slookup
argument_list|(
name|inp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|flslvl
expr_stmt|;
if|if
condition|(
name|flslvl
operator|==
literal|0
operator|&&
name|np
operator|->
name|value
operator|!=
literal|0
condition|)
operator|++
name|trulvl
expr_stmt|;
else|else
operator|++
name|flslvl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|np
operator|==
name|eifloc
condition|)
block|{
comment|/* endif */
if|if
condition|(
name|flslvl
condition|)
block|{
if|if
condition|(
operator|--
name|flslvl
operator|==
literal|0
condition|)
name|sayline
argument_list|(
name|CONT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trulvl
condition|)
operator|--
name|trulvl
expr_stmt|;
else|else
name|pperror
argument_list|(
literal|"If-less endif"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|np
operator|==
name|elsloc
condition|)
block|{
comment|/* else */
if|if
condition|(
name|flslvl
condition|)
block|{
if|if
condition|(
operator|--
name|flslvl
operator|!=
literal|0
condition|)
operator|++
name|flslvl
expr_stmt|;
else|else
block|{
operator|++
name|trulvl
expr_stmt|;
name|sayline
argument_list|(
name|CONT
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|trulvl
condition|)
block|{
operator|++
name|flslvl
expr_stmt|;
operator|--
name|trulvl
expr_stmt|;
block|}
else|else
name|pperror
argument_list|(
literal|"If-less else"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|np
operator|==
name|udfloc
condition|)
block|{
comment|/* undefine */
if|if
condition|(
name|flslvl
operator|==
literal|0
condition|)
block|{
operator|++
name|flslvl
expr_stmt|;
name|p
operator|=
name|skipbl
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|slookup
argument_list|(
name|inp
argument_list|,
name|p
argument_list|,
name|DROP
argument_list|)
expr_stmt|;
operator|--
name|flslvl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|np
operator|==
name|ifloc
condition|)
block|{
comment|/* if */
if|#
directive|if
name|tgp
name|pperror
argument_list|(
literal|" IF not implemented, true assumed"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flslvl
operator|==
literal|0
condition|)
operator|++
name|trulvl
expr_stmt|;
else|else
operator|++
name|flslvl
expr_stmt|;
else|#
directive|else
name|newp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|flslvl
operator|==
literal|0
operator|&&
name|yyparse
argument_list|()
condition|)
operator|++
name|trulvl
expr_stmt|;
else|else
operator|++
name|flslvl
expr_stmt|;
name|p
operator|=
name|newp
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|np
operator|==
name|lneloc
condition|)
block|{
comment|/* line */
if|if
condition|(
name|flslvl
operator|==
literal|0
operator|&&
name|pflag
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|savestring
parameter_list|()
function_decl|;
name|char
name|filename
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|cp
init|=
name|filename
decl_stmt|;
name|outp
operator|=
name|inp
operator|=
name|p
expr_stmt|;
operator|*
operator|--
name|outp
operator|=
literal|'#'
expr_stmt|;
comment|/* Find the line number.. */
do|do
block|{
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|isnum
argument_list|(
operator|*
name|inp
argument_list|)
operator|&&
operator|*
name|inp
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|isnum
argument_list|(
operator|*
name|inp
argument_list|)
condition|)
name|lineno
index|[
name|ifno
index|]
operator|=
name|atoi
argument_list|(
name|inp
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Skip over the blank token */
name|inp
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|inp
operator|!=
literal|'\n'
condition|)
block|{
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|inp
operator|=
name|p
expr_stmt|;
block|}
comment|/* Add a quote if missing..  */
if|if
condition|(
operator|*
name|inp
operator|!=
literal|'\n'
condition|)
block|{
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Add a quote if missing..  */
if|if
condition|(
operator|*
name|inp
operator|==
literal|'"'
condition|)
name|inp
operator|++
expr_stmt|;
else|else
block|{
name|dump
argument_list|()
expr_stmt|;
operator|*
operator|--
name|outp
operator|=
literal|'"'
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|inp
operator|!=
literal|'\n'
condition|)
block|{
while|while
condition|(
name|inp
operator|<
name|p
operator|&&
operator|*
name|inp
operator|!=
literal|'"'
operator|&&
name|cp
operator|<
name|filename
operator|+
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|inp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|inp
operator|==
literal|'"'
condition|)
break|break;
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|fnames
index|[
name|ifno
index|]
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* Add a quote if missing..  */
if|if
condition|(
operator|*
name|inp
operator|!=
literal|'"'
condition|)
block|{
name|dump
argument_list|()
expr_stmt|;
operator|*
operator|--
name|outp
operator|=
literal|'"'
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|inp
operator|!=
literal|'\n'
condition|)
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|np
operator|==
name|identloc
condition|)
block|{
comment|/* ident (for Sys 5r3 compat) */
while|while
condition|(
operator|*
name|inp
operator|!=
literal|'\n'
condition|)
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|++
name|inp
operator|==
literal|'\n'
condition|)
name|outp
operator|=
name|inp
expr_stmt|;
comment|/* allows blank line after # */
else|else
name|pperror
argument_list|(
literal|"undefined control"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* flush to lf */
operator|++
name|flslvl
expr_stmt|;
while|while
condition|(
operator|*
name|inp
operator|!=
literal|'\n'
condition|)
block|{
name|outp
operator|=
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
operator|--
name|flslvl
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|savestring
parameter_list|(
name|start
parameter_list|,
name|finish
parameter_list|)
specifier|register
name|char
modifier|*
name|start
decl_stmt|,
decl|*
name|finish
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|retbuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|retbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|finish
operator|-
name|start
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|retbuf
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|finish
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|start
operator|++
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|retbuf
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|symtab
modifier|*
name|stsym
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* make definition look exactly like end of #define line */
comment|/* copy to avoid running off end of world when param list is at end */
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isid
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
empty_stmt|;
comment|/* skip first identifier */
if|if
condition|(
operator|*
operator|--
name|p
operator|==
literal|'='
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|" 1"
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
block|}
name|pend
operator|=
name|p
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'\n'
expr_stmt|;
name|sloscan
argument_list|()
expr_stmt|;
name|dodef
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|lastsym
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|symtab
modifier|*
name|ppsym
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* kluge */
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|cinit
operator|=
name|SALT
expr_stmt|;
name|sp
operator|=
name|stsym
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|sp
operator|->
name|name
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'#'
expr_stmt|;
name|strcpy
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
name|sp
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|cinit
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|pperror
argument_list|(
argument|s
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fnames
index|[
name|ifno
index|]
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
if|#
directive|if
name|gcos
literal|"*%c*   \"%s\", line "
argument_list|,
name|exfail
operator|>=
literal|0
condition|?
literal|'F'
else|:
literal|'W'
argument_list|,
else|#
directive|else
literal|"%s: "
argument_list|,
endif|#
directive|endif
name|fnames
index|[
name|ifno
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: "
argument_list|,
name|lineno
index|[
name|ifno
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|++
name|exfail
expr_stmt|;
block|}
end_block

begin_macro
name|yyerror
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pperror
argument_list|(
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ppwarn
argument_list|(
argument|s
argument_list|,
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fail
init|=
name|exfail
decl_stmt|;
name|exfail
operator|=
operator|-
literal|1
expr_stmt|;
name|pperror
argument_list|(
name|s
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|exfail
operator|=
name|fail
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|symtab
modifier|*
name|lookup
parameter_list|(
name|namep
parameter_list|,
name|enterf
parameter_list|)
name|char
modifier|*
name|namep
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|np
decl_stmt|,
modifier|*
name|snp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|int
name|around
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
comment|/* namep had better not be too long (currently,<=NCPS chars) */
name|np
operator|=
name|namep
expr_stmt|;
name|around
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|cinit
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|np
operator|++
condition|)
name|i
operator|+=
name|i
operator|+
name|c
expr_stmt|;
name|c
operator|=
name|i
expr_stmt|;
comment|/* c=i for register usage on pdp11 */
name|c
operator|%=
name|symsiz
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|c
operator|+=
name|symsiz
expr_stmt|;
name|sp
operator|=
operator|&
name|stab
index|[
name|c
index|]
expr_stmt|;
while|while
condition|(
name|snp
operator|=
name|sp
operator|->
name|name
condition|)
block|{
name|np
operator|=
name|namep
expr_stmt|;
while|while
condition|(
operator|*
name|snp
operator|++
operator|==
operator|*
name|np
condition|)
if|if
condition|(
operator|*
name|np
operator|++
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|enterf
operator|==
name|DROP
condition|)
block|{
name|sp
operator|->
name|name
index|[
literal|0
index|]
operator|=
name|DROP
expr_stmt|;
name|sp
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|lastsym
operator|=
name|sp
operator|)
return|;
block|}
if|if
condition|(
operator|--
name|sp
operator|<
operator|&
name|stab
index|[
literal|0
index|]
condition|)
if|if
condition|(
name|around
condition|)
block|{
name|pperror
argument_list|(
literal|"too many defines"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exfail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|around
expr_stmt|;
name|sp
operator|=
operator|&
name|stab
index|[
name|symsiz
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|enterf
operator|==
literal|1
condition|)
name|sp
operator|->
name|name
operator|=
name|namep
expr_stmt|;
return|return
operator|(
name|lastsym
operator|=
name|sp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|symtab
modifier|*
name|slookup
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|enterf
parameter_list|)
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|enterf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p3
decl_stmt|;
name|char
name|c2
decl_stmt|,
name|c3
decl_stmt|;
name|struct
name|symtab
modifier|*
name|np
decl_stmt|;
name|c2
operator|=
operator|*
name|p2
expr_stmt|;
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
comment|/* mark end of token */
if|if
condition|(
operator|(
name|p2
operator|-
name|p1
operator|)
operator|>
name|NCPS
condition|)
name|p3
operator|=
name|p1
operator|+
name|NCPS
expr_stmt|;
else|else
name|p3
operator|=
name|p2
expr_stmt|;
name|c3
operator|=
operator|*
name|p3
expr_stmt|;
operator|*
name|p3
operator|=
literal|'\0'
expr_stmt|;
comment|/* truncate to NCPS chars or less */
if|if
condition|(
name|enterf
operator|==
literal|1
condition|)
name|p1
operator|=
name|copy
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|np
operator|=
name|lookup
argument_list|(
name|p1
argument_list|,
name|enterf
argument_list|)
expr_stmt|;
operator|*
name|p3
operator|=
name|c3
expr_stmt|;
operator|*
name|p2
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|value
operator|!=
literal|0
operator|&&
name|flslvl
operator|==
literal|0
condition|)
name|newp
operator|=
name|subst
argument_list|(
name|p2
argument_list|,
name|np
argument_list|)
expr_stmt|;
else|else
name|newp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|subst
parameter_list|(
name|p
parameter_list|,
name|sp
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
block|{
specifier|static
name|char
name|match
index|[]
init|=
literal|"%s: argument mismatch"
decl_stmt|;
specifier|register
name|char
modifier|*
name|ca
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|int
name|params
decl_stmt|;
name|char
modifier|*
name|actual
index|[
name|MAXFRM
index|]
decl_stmt|;
comment|/* actual[n] is text of nth actual   */
name|char
name|actused
index|[
name|MAXFRM
index|]
decl_stmt|;
comment|/* for newline processing in actuals */
name|char
name|acttxt
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* space for actuals */
name|int
name|nlines
init|=
literal|0
decl_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|vp
operator|=
name|sp
operator|->
name|value
operator|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|-
name|macforw
operator|)
operator|<=
name|macdam
condition|)
block|{
if|if
condition|(
operator|++
name|maclvl
operator|>
name|symsiz
operator|&&
operator|!
name|rflag
condition|)
block|{
name|pperror
argument_list|(
literal|"%s: macro recursion"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
else|else
name|maclvl
operator|=
literal|0
expr_stmt|;
comment|/* level decreased */
name|macforw
operator|=
name|p
expr_stmt|;
name|macdam
operator|=
literal|0
expr_stmt|;
comment|/* new target for decrease in level */
name|macnam
operator|=
name|sp
operator|->
name|name
expr_stmt|;
name|dump
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|ulnloc
condition|)
block|{
name|vp
operator|=
name|acttxt
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|vp
argument_list|,
literal|"%d"
argument_list|,
name|lineno
index|[
name|ifno
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|vp
operator|++
condition|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|==
name|uflloc
condition|)
block|{
name|vp
operator|=
name|acttxt
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|vp
argument_list|,
literal|"\"%s\""
argument_list|,
name|fnames
index|[
name|ifno
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|vp
operator|++
condition|)
empty_stmt|;
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
name|params
operator|=
operator|*
operator|--
name|vp
operator|&
literal|0xFF
operator|)
condition|)
block|{
comment|/* definition calls for params */
specifier|register
name|char
modifier|*
modifier|*
name|pa
decl_stmt|;
name|ca
operator|=
name|acttxt
expr_stmt|;
name|pa
operator|=
name|actual
expr_stmt|;
if|if
condition|(
name|params
operator|==
literal|0xFF
condition|)
name|params
operator|=
literal|1
expr_stmt|;
comment|/* #define foo() ... */
name|sloscan
argument_list|()
expr_stmt|;
operator|++
name|flslvl
expr_stmt|;
comment|/* no expansion during search for actuals */
name|plvl
operator|=
operator|-
literal|1
expr_stmt|;
do|do
name|p
operator|=
name|skipbl
argument_list|(
name|p
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|inp
operator|==
literal|'\n'
condition|)
do|;
comment|/* skip \n too */
if|if
condition|(
operator|*
name|inp
operator|==
literal|'('
condition|)
block|{
name|maclin
operator|=
name|lineno
index|[
name|ifno
index|]
expr_stmt|;
name|macfil
operator|=
name|fnames
index|[
name|ifno
index|]
expr_stmt|;
for|for
control|(
name|plvl
operator|=
literal|1
init|;
name|plvl
operator|!=
literal|0
condition|;
control|)
block|{
operator|*
name|ca
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|outp
operator|=
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|cotoken
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|inp
operator|==
literal|'('
condition|)
operator|++
name|plvl
expr_stmt|;
if|if
condition|(
operator|*
name|inp
operator|==
literal|')'
operator|&&
operator|--
name|plvl
operator|==
literal|0
condition|)
block|{
operator|--
name|params
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|plvl
operator|==
literal|1
operator|&&
operator|*
name|inp
operator|==
literal|','
condition|)
block|{
operator|--
name|params
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|inp
operator|<
name|p
condition|)
operator|*
name|ca
operator|++
operator|=
operator|*
name|inp
operator|++
expr_stmt|;
if|if
condition|(
name|ca
operator|>
operator|&
name|acttxt
index|[
name|BUFSIZ
index|]
condition|)
name|pperror
argument_list|(
literal|"%s: actuals too long"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pa
operator|>=
operator|&
name|actual
index|[
name|MAXFRM
index|]
condition|)
name|ppwarn
argument_list|(
name|match
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|actused
index|[
name|pa
operator|-
name|actual
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|pa
operator|++
operator|=
name|ca
expr_stmt|;
block|}
block|}
name|nlines
operator|=
name|lineno
index|[
name|ifno
index|]
operator|-
name|maclin
expr_stmt|;
name|lineno
index|[
name|ifno
index|]
operator|=
name|maclin
expr_stmt|;
comment|/* don't count newlines here */
block|}
if|if
condition|(
name|params
operator|!=
literal|0
condition|)
name|ppwarn
argument_list|(
name|match
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|params
operator|>=
literal|0
condition|)
operator|*
name|pa
operator|++
operator|=
literal|""
operator|+
literal|1
expr_stmt|;
comment|/* null string for missing actuals */
operator|--
name|flslvl
expr_stmt|;
name|fasscan
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* push definition onto front of input stack */
while|while
condition|(
operator|!
name|iswarn
argument_list|(
operator|*
operator|--
name|vp
argument_list|)
condition|)
block|{
if|if
condition|(
name|bob
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|outp
operator|=
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|unfill
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
operator|--
name|p
operator|=
operator|*
name|vp
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|vp
operator|==
name|warnc
condition|)
block|{
comment|/* insert actual param */
name|ca
operator|=
name|actual
index|[
operator|*
operator|--
name|vp
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|ca
condition|)
block|{
if|if
condition|(
name|bob
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|outp
operator|=
name|inp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|unfill
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Actuals with newlines confuse line numbering */
if|if
condition|(
operator|*
name|ca
operator|==
literal|'\n'
operator|&&
name|actused
index|[
operator|*
name|vp
operator|-
literal|1
index|]
condition|)
if|if
condition|(
operator|*
operator|(
name|ca
operator|-
literal|1
operator|)
operator|==
literal|'\\'
condition|)
name|ca
operator|--
expr_stmt|;
else|else
operator|*
operator|--
name|p
operator|=
literal|' '
expr_stmt|;
else|else
block|{
operator|*
operator|--
name|p
operator|=
operator|*
name|ca
expr_stmt|;
if|if
condition|(
operator|*
name|ca
operator|==
literal|'\n'
condition|)
name|nlines
operator|--
expr_stmt|;
block|}
block|}
name|actused
index|[
operator|*
name|vp
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nlines
operator|>
literal|0
condition|)
while|while
condition|(
name|nlines
operator|--
operator|>
literal|0
condition|)
operator|*
operator|--
name|p
operator|=
literal|'\n'
expr_stmt|;
break|break;
block|}
block|}
name|outp
operator|=
name|inp
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|trmdir
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
operator|--
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|s
operator|&&
operator|*
operator|--
name|p
operator|!=
literal|'/'
condition|)
empty_stmt|;
if|#
directive|if
name|unix
if|if
condition|(
name|p
operator|==
name|s
condition|)
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
endif|#
directive|endif
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|copy
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|old
decl_stmt|;
name|old
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
block|{
name|pperror
argument_list|(
literal|"no space"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exfail
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|old
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|lastcopy
operator|=
name|old
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|strdex
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
name|c
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|c
condition|)
return|return
operator|(
operator|--
name|s
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|yywrap
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|tf
decl_stmt|,
modifier|*
modifier|*
name|cp2
decl_stmt|;
if|#
directive|if
name|gcos
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
condition|)
return|return
operator|(
name|exfail
operator|)
return|;
endif|#
directive|endif
name|p
operator|=
literal|"_$ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
operator|(
name|fastab
operator|+
name|COFF
operator|)
index|[
name|c
index|]
operator||=
name|IB
operator||
name|NB
operator||
name|SB
expr_stmt|;
operator|(
name|toktyp
operator|+
name|COFF
operator|)
index|[
name|c
index|]
operator|=
name|IDENT
expr_stmt|;
if|#
directive|if
name|scw2
comment|/* 53 == 63-10; digits rarely appear in identifiers, 			/* and can never be the first char of an identifier. 			/* 11 == 53*53/sizeof(macbit) . 			*/
operator|++
name|i
expr_stmt|;
operator|(
name|t21
operator|+
name|COFF
operator|)
index|[
name|c
index|]
operator|=
operator|(
literal|53
operator|*
name|i
operator|)
operator|/
literal|11
expr_stmt|;
operator|(
name|t22
operator|+
name|COFF
operator|)
index|[
name|c
index|]
operator|=
name|i
operator|%
literal|11
expr_stmt|;
endif|#
directive|endif
block|}
name|p
operator|=
literal|"0123456789."
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
operator|(
name|fastab
operator|+
name|COFF
operator|)
index|[
name|c
index|]
operator||=
name|NB
operator||
name|SB
expr_stmt|;
operator|(
name|toktyp
operator|+
name|COFF
operator|)
index|[
name|c
index|]
operator|=
name|NUMBR
expr_stmt|;
block|}
if|#
directive|if
name|gcos
name|p
operator|=
literal|"\n\"'`/\\"
expr_stmt|;
else|#
directive|else
name|p
operator|=
literal|"\n\"'/\\"
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
operator|(
name|fastab
operator|+
name|COFF
operator|)
index|[
name|c
index|]
operator||=
name|SB
expr_stmt|;
if|#
directive|if
name|gcos
name|p
operator|=
literal|"\n\"'`\\"
expr_stmt|;
else|#
directive|else
name|p
operator|=
literal|"\n\"'\\"
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
operator|(
name|fastab
operator|+
name|COFF
operator|)
index|[
name|c
index|]
operator||=
name|QB
expr_stmt|;
name|p
operator|=
literal|"*\n"
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
operator|(
name|fastab
operator|+
name|COFF
operator|)
index|[
name|c
index|]
operator||=
name|CB
expr_stmt|;
operator|(
name|fastab
operator|+
name|COFF
operator|)
index|[
name|warnc
index|]
operator||=
name|WB
expr_stmt|;
operator|(
name|fastab
operator|+
name|COFF
operator|)
index|[
literal|'\0'
index|]
operator||=
name|CB
operator||
name|QB
operator||
name|SB
operator||
name|WB
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ALFSIZ
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|slotab
index|[
name|i
index|]
operator|=
name|fastab
index|[
name|i
index|]
operator||
name|SB
expr_stmt|;
name|p
operator|=
literal|" \t\013\f\r"
expr_stmt|;
comment|/* note no \n;	\v not legal for vertical tab? */
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
operator|(
name|toktyp
operator|+
name|COFF
operator|)
index|[
name|c
index|]
operator|=
name|BLANK
expr_stmt|;
if|#
directive|if
name|scw2
for|for
control|(
operator|(
name|t23
operator|+
name|COFF
operator|)
index|[
name|i
operator|=
name|ALFSIZ
operator|+
literal|7
operator|-
name|COFF
index|]
operator|=
literal|1
init|;
operator|--
name|i
operator|>=
operator|-
name|COFF
condition|;
control|)
if|if
condition|(
operator|(
operator|(
name|t23
operator|+
name|COFF
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|t23
operator|+
name|COFF
operator|+
literal|1
operator|)
index|[
name|i
index|]
operator|<<
literal|1
operator|)
operator|==
literal|0
condition|)
operator|(
name|t23
operator|+
name|COFF
operator|)
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|unix
name|fnames
index|[
name|ifno
operator|=
literal|0
index|]
operator|=
literal|""
expr_stmt|;
name|dirnams
index|[
literal|0
index|]
operator|=
name|dirs
index|[
literal|0
index|]
operator|=
literal|"."
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ibm
name|fnames
index|[
name|ifno
operator|=
literal|0
index|]
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|gcos
if|if
condition|(
name|inquire
argument_list|(
name|stdin
argument_list|,
name|_TTY
argument_list|)
condition|)
name|freopen
argument_list|(
literal|"*src"
argument_list|,
literal|"rt"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|gimpel
operator|||
name|gcos
name|fnames
index|[
name|ifno
operator|=
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|inquire
argument_list|(
name|stdin
argument_list|,
name|_FILENAME
argument_list|)
expr_stmt|;
name|dirnams
index|[
literal|0
index|]
operator|=
name|dirs
index|[
literal|0
index|]
operator|=
name|trmdir
argument_list|(
name|copy
argument_list|(
name|fnames
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'-'
case|:
if|#
directive|if
name|gcos
switch|switch
condition|(
name|toupper
argument_list|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* case-independent on GCOS */
else|#
directive|else
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
endif|#
directive|endif
case|case
literal|'M'
case|:
name|mflag
operator|++
expr_stmt|;
case|case
literal|'P'
case|:
name|pflag
operator|++
expr_stmt|;
case|case
literal|'E'
case|:
continue|continue;
case|case
literal|'R'
case|:
operator|++
name|rflag
expr_stmt|;
continue|continue;
case|case
literal|'C'
case|:
name|passcom
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
if|if
condition|(
name|predef
operator|>
name|prespc
operator|+
name|NPREDEF
condition|)
block|{
name|pperror
argument_list|(
literal|"too many -D options, ignoring %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* ignore plain "-D" (no argument) */
if|if
condition|(
operator|*
operator|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
operator|)
condition|)
operator|*
name|predef
operator|++
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
continue|continue;
case|case
literal|'U'
case|:
if|if
condition|(
name|prund
operator|>
name|punspc
operator|+
name|NPREDEF
condition|)
block|{
name|pperror
argument_list|(
literal|"too many -U options, ignoring %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|prund
operator|++
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
continue|continue;
case|case
literal|'I'
case|:
if|if
condition|(
name|nd
operator|>
literal|8
condition|)
name|pperror
argument_list|(
literal|"excessive -I file (%s) ignored"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|dirs
index|[
name|nd
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
continue|continue;
case|case
literal|'\0'
case|:
continue|continue;
default|default:
name|pperror
argument_list|(
literal|"unknown flag %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
default|default:
if|if
condition|(
name|fin
operator|==
name|FIRSTOPEN
condition|)
block|{
if|if
condition|(
literal|0
operator|>
operator|(
name|fin
operator|=
name|open
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|READ
argument_list|)
operator|)
condition|)
block|{
name|pperror
argument_list|(
literal|"No source file %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
name|fnames
index|[
name|ifno
index|]
operator|=
name|copy
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|infile
operator|=
name|copy
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|=
name|dirnams
index|[
name|ifno
index|]
operator|=
name|trmdir
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|gcos
comment|/* too dangerous to have file name in same syntactic position    be input or output file depending on file redirections,    so force output to stdout, willy-nilly 	[i don't see what the problem is.  jfr] */
block|}
elseif|else
if|if
condition|(
name|fout
operator|==
name|stdout
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|fout
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|pperror
argument_list|(
literal|"Can't create %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|pperror
argument_list|(
literal|"extraneous name %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fin
operator|==
name|FIRSTOPEN
condition|)
name|fin
operator|=
name|STDIN
expr_stmt|;
if|if
condition|(
name|mflag
condition|)
block|{
if|if
condition|(
name|infile
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no input file specified with -M flag\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
name|tf
operator|=
operator|(
name|char
operator|*
operator|)
name|rindex
argument_list|(
name|infile
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"missing component name on %s\n"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
name|tf
index|[
literal|1
index|]
operator|=
literal|'o'
expr_stmt|;
name|tf
operator|=
operator|(
name|char
operator|*
operator|)
name|rindex
argument_list|(
name|infile
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|infile
operator|=
name|tf
operator|+
literal|1
expr_stmt|;
name|mout
operator|=
name|fout
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|fout
operator|=
name|fopen
argument_list|(
name|_PATH_DEVNULL
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cpp: can't open %s\n"
argument_list|,
name|_PATH_DEVNULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
name|fins
index|[
name|ifno
index|]
operator|=
name|fin
expr_stmt|;
name|exfail
operator|=
literal|0
expr_stmt|;
comment|/* after user -I files here are the standard include libraries */
if|#
directive|if
name|unix
name|dirs
index|[
name|nd
operator|++
index|]
operator|=
name|_PATH_INCLUDES
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|gcos
name|dirs
index|[
name|nd
operator|++
index|]
operator|=
literal|"cc/include"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ibm
ifndef|#
directive|ifndef
name|gimpel
name|dirs
index|[
name|nd
operator|++
index|]
operator|=
literal|"BTL$CLIB"
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|gimpel
name|dirs
index|[
name|nd
operator|++
index|]
operator|=
name|intss
argument_list|()
condition|?
literal|"SYS3.C."
else|:
literal|""
expr_stmt|;
endif|#
directive|endif
comment|/* dirs[nd++] = "/compool"; */
name|dirs
index|[
name|nd
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|defloc
operator|=
name|ppsym
argument_list|(
literal|"define"
argument_list|)
expr_stmt|;
name|udfloc
operator|=
name|ppsym
argument_list|(
literal|"undef"
argument_list|)
expr_stmt|;
name|incloc
operator|=
name|ppsym
argument_list|(
literal|"include"
argument_list|)
expr_stmt|;
name|elsloc
operator|=
name|ppsym
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|eifloc
operator|=
name|ppsym
argument_list|(
literal|"endif"
argument_list|)
expr_stmt|;
name|ifdloc
operator|=
name|ppsym
argument_list|(
literal|"ifdef"
argument_list|)
expr_stmt|;
name|ifnloc
operator|=
name|ppsym
argument_list|(
literal|"ifndef"
argument_list|)
expr_stmt|;
name|ifloc
operator|=
name|ppsym
argument_list|(
literal|"if"
argument_list|)
expr_stmt|;
name|lneloc
operator|=
name|ppsym
argument_list|(
literal|"line"
argument_list|)
expr_stmt|;
name|identloc
operator|=
name|ppsym
argument_list|(
literal|"ident"
argument_list|)
expr_stmt|;
comment|/* Sys 5r3 compatibility */
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|macbit
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|macbit
index|[
literal|0
index|]
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|macbit
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|unix
name|ysysloc
operator|=
name|stsym
argument_list|(
literal|"unix"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ysysloc
operator|=
name|stsym
argument_list|(
name|MACHINE
argument_list|)
expr_stmt|;
name|ulnloc
operator|=
name|stsym
argument_list|(
literal|"__LINE__"
argument_list|)
expr_stmt|;
name|uflloc
operator|=
name|stsym
argument_list|(
literal|"__FILE__"
argument_list|)
expr_stmt|;
name|tf
operator|=
name|fnames
index|[
name|ifno
index|]
expr_stmt|;
name|fnames
index|[
name|ifno
index|]
operator|=
literal|"command line"
expr_stmt|;
name|lineno
index|[
name|ifno
index|]
operator|=
literal|1
expr_stmt|;
name|cp2
operator|=
name|prespc
expr_stmt|;
while|while
condition|(
name|cp2
operator|<
name|predef
condition|)
name|stsym
argument_list|(
operator|*
name|cp2
operator|++
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|punspc
expr_stmt|;
while|while
condition|(
name|cp2
operator|<
name|prund
condition|)
block|{
if|if
condition|(
name|p
operator|=
name|strdex
argument_list|(
operator|*
name|cp2
argument_list|,
literal|'='
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|lookup
argument_list|(
operator|*
name|cp2
operator|++
argument_list|,
name|DROP
argument_list|)
expr_stmt|;
block|}
name|fnames
index|[
name|ifno
index|]
operator|=
name|tf
expr_stmt|;
name|pbeg
operator|=
name|buffer
operator|+
name|NCPS
expr_stmt|;
name|pbuf
operator|=
name|pbeg
operator|+
name|BUFSIZ
expr_stmt|;
name|pend
operator|=
name|pbuf
operator|+
name|BUFSIZ
expr_stmt|;
name|trulvl
operator|=
literal|0
expr_stmt|;
name|flslvl
operator|=
literal|0
expr_stmt|;
name|lineno
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|sayline
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|outp
operator|=
name|inp
operator|=
name|pend
expr_stmt|;
name|control
argument_list|(
name|pend
argument_list|)
expr_stmt|;
return|return
operator|(
name|exfail
operator|)
return|;
block|}
end_function

end_unit

