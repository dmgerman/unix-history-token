begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"	unixtraps.c	4.1	82/05/12	"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	Function to execute version 6 and version 7 UNIX system calls from  *	compatability mode on UNIX-32V.  *	Art Wetzel	August 1979  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|V6UNIX
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_define
define|#
directive|define
name|RTSNAME
value|"/../../../../usr/local/v6trc"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RTSNAME
value|"/../../../../usr/local/v6run"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"unix6sys.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_include
include|#
directive|include
file|"unix6sysn.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|V7UNIX
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_define
define|#
directive|define
name|RTSNAME
value|"/../../../../usr/local/v7trc"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RTSNAME
value|"/../../../../usr/local/v7run"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"unix7sys.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_include
include|#
directive|include
file|"unix7sysn.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_define
define|#
directive|define
name|CARRY
value|1
end_define

begin_define
define|#
directive|define
name|MAXSARGS
value|25
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|V6UNIX
end_ifdef

begin_define
define|#
directive|define
name|ARGVLEN
value|512
end_define

begin_define
define|#
directive|define
name|ENVLEN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|V7UNIX
end_ifdef

begin_define
define|#
directive|define
name|ARGVLEN
value|5120
end_define

begin_define
define|#
directive|define
name|ENVLEN
value|1000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|argvs
index|[
name|ARGVLEN
operator|+
name|ENVLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|args
index|[
name|MAXSARGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 32v type stat structure */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|stat
name|stat32v
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place for times data so we can reverse the longs */
end_comment

begin_struct
struct|struct
name|timebuf
block|{
name|long
name|t1
decl_stmt|;
name|long
name|t2
decl_stmt|;
name|long
name|t3
decl_stmt|;
name|long
name|t4
decl_stmt|;
block|}
name|timebuf
struct|;
end_struct

begin_comment
comment|/* place for pipe file descriptors */
end_comment

begin_decl_stmt
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wait status */
end_comment

begin_decl_stmt
name|int
name|wstatus
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|V6UNIX
end_ifdef

begin_comment
comment|/* version 6 style stat structure */
end_comment

begin_struct
struct|struct
name|v6nod
block|{
name|dev_t
name|majmin
decl_stmt|;
name|ino_t
name|inumber
decl_stmt|;
name|unsigned
name|short
name|flags
decl_stmt|;
name|unsigned
name|char
name|nlinks
decl_stmt|;
name|unsigned
name|char
name|uid
decl_stmt|;
name|unsigned
name|char
name|gid
decl_stmt|;
name|unsigned
name|char
name|size0
decl_stmt|;
name|unsigned
name|short
name|size1
decl_stmt|;
name|unsigned
name|short
name|addr
index|[
literal|8
index|]
decl_stmt|;
name|long
name|actime
decl_stmt|;
name|long
name|modtime
decl_stmt|;
block|}
modifier|*
name|v6stat
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* do the trap stuff for the trap with code */
end_comment

begin_macro
name|dotrap
argument_list|(
argument|code
argument_list|)
end_macro

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|short
modifier|*
name|argp
decl_stmt|,
modifier|*
name|savp
decl_stmt|,
modifier|*
name|savep
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|indirflg
decl_stmt|;
specifier|register
name|char
modifier|*
name|avp
decl_stmt|,
modifier|*
name|oavp
decl_stmt|;
extern|extern sigcatch(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern errno;
end_extern

begin_comment
comment|/* clear out condition codes of psl */
end_comment

begin_expr_stmt
name|psl
operator|&=
operator|~
literal|017
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* special case of indirect sys call */
end_comment

begin_if
if|if
condition|(
name|code
operator|==
literal|0
condition|)
block|{
comment|/* remember this was indirect */
name|indirflg
operator|=
literal|1
expr_stmt|;
comment|/* point to args */
name|argp
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|*
operator|(
name|pc
operator|++
operator|)
expr_stmt|;
comment|/* code for indirect sys call */
name|code
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
comment|/* is it legit */
if|if
condition|(
name|code
operator|>>
literal|8
operator|!=
name|TRAPS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad indirect sys call at 0x%x\n"
argument_list|,
name|pc
operator|-
literal|2
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
comment|/* set carry flag */
name|psl
operator||=
name|CARRY
expr_stmt|;
name|regs
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|code
operator|&=
literal|0377
expr_stmt|;
block|}
else|else
block|{
comment|/* remember this was not indirect */
name|indirflg
operator|=
literal|0
expr_stmt|;
comment|/* point to args */
name|argp
operator|=
name|pc
expr_stmt|;
block|}
end_if

begin_comment
comment|/* check if code too high or bad sys code */
end_comment

begin_if
if|if
condition|(
name|code
operator|>=
name|NSYSTRAPS
operator|||
name|sysargs
index|[
name|code
index|]
index|[
literal|0
index|]
operator|==
name|ILLSYS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unimplimented trap %d at 0x%x\n"
argument_list|,
name|code
argument_list|,
name|argp
argument_list|)
expr_stmt|;
comment|/* set carry bit */
name|psl
operator||=
name|CARRY
expr_stmt|;
name|regs
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_if

begin_comment
comment|/* copy args to known locations */
end_comment

begin_expr_stmt
name|i
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sysargs
index|[
name|code
index|]
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
name|args
index|[
name|i
operator|++
index|]
operator|=
name|regs
index|[
name|j
index|]
expr_stmt|;
end_for

begin_for
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|sysargs
index|[
name|code
index|]
index|[
literal|1
index|]
operator|)
condition|;
name|j
operator|++
control|)
name|args
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
end_for

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_expr_stmt
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pid %d "
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|indirflg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"indirect "
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s (%d) from 0%o with %d args"
argument_list|,
name|sysnames
index|[
name|code
index|]
argument_list|,
name|code
argument_list|,
name|pc
operator|-
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" 0%o"
argument_list|,
name|args
index|[
name|j
index|]
argument_list|)
expr_stmt|;
end_for

begin_if
if|if
condition|(
name|code
operator|==
name|OPEN
operator|||
name|code
operator|==
name|STAT
operator|||
name|code
operator|==
name|CREAT
operator|||
name|code
operator|==
name|EXEC
operator|||
name|code
operator|==
name|UNLNK
operator|||
name|code
operator|==
name|LINK
operator|||
name|code
operator|==
name|CHDIR
operator|||
name|code
operator|==
name|MKNOD
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%s)"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|V7UNIX
end_ifdef

begin_if
if|if
condition|(
name|code
operator|==
name|EXECE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%s)"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|code
operator|==
name|LINK
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%s)"
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* go do whatever sys call it is */
end_comment

begin_switch
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|FORK
case|:
comment|/* indirect forks return pids on both sides - must do here */
comment|/* this is possibly a bug in 32V */
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
break|break;
case|case
name|WAIT
case|:
name|i
operator|=
name|wait
argument_list|(
operator|&
name|wstatus
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|wstatus
expr_stmt|;
break|break;
case|case
name|EXEC
case|:
ifdef|#
directive|ifdef
name|V7UNIX
case|case
name|EXECE
case|:
endif|#
directive|endif
comment|/* 		 *  have to do a lot of junk here to fix up an argv 		 *  for execute since (1) the pdp-11 argv consists of 16 		 *  bit pointers and (2) the argv itself is in the 		 *  pdp-11 program space where it would get clobbered 		 *  when a new program is read in and before its 		 *  argv is set up. 		 */
name|avp
operator|=
operator|&
name|argvs
index|[
literal|0
index|]
expr_stmt|;
name|savp
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|args
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|V6UNIX
for|for
control|(
name|i
operator|=
literal|1
init|;
name|args
index|[
name|i
index|]
operator|=
operator|*
name|savp
operator|++
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|==
literal|0177777
condition|)
break|break;
ifdef|#
directive|ifdef
name|TRACE
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"argv[%d]%s "
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|V7UNIX
name|savep
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|args
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|args
index|[
name|i
index|]
operator|=
operator|*
name|savp
operator|++
condition|;
name|i
operator|++
control|)
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"argv[%d]%s "
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|stat
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|stat32v
argument_list|)
condition|)
block|{
comment|/* return error here if file does not exist */
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" does not exist\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* must have execute permission */
if|if
condition|(
name|stat32v
operator|.
name|st_mode
operator|&
operator|(
name|S_IEXEC
operator|>>
literal|6
operator|)
condition|)
goto|goto
name|experm
goto|;
if|if
condition|(
name|stat32v
operator|.
name|st_mode
operator|&
operator|(
name|S_IEXEC
operator|>>
literal|3
operator|)
condition|)
block|{
if|if
condition|(
name|stat32v
operator|.
name|st_gid
operator|==
name|getegid
argument_list|()
condition|)
goto|goto
name|experm
goto|;
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
goto|goto
name|experm
goto|;
block|}
if|if
condition|(
name|stat32v
operator|.
name|st_mode
operator|&
name|S_IEXEC
condition|)
block|{
if|if
condition|(
name|stat32v
operator|.
name|st_uid
operator|==
name|geteuid
argument_list|()
condition|)
goto|goto
name|experm
goto|;
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
goto|goto
name|experm
goto|;
block|}
comment|/* return failure if no exec permision allowed */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|experm
label|:
comment|/* can't exec a directory */
if|if
condition|(
name|stat32v
operator|.
name|st_mode
operator|&
name|S_IFDIR
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
break|break;
name|args
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|oavp
operator|=
operator|(
name|char
operator|*
operator|)
name|args
index|[
name|j
index|]
expr_stmt|;
name|args
index|[
name|j
index|]
operator|=
operator|(
name|int
operator|)
name|avp
expr_stmt|;
while|while
condition|(
operator|*
name|avp
operator|++
operator|=
operator|*
name|oavp
operator|++
condition|)
empty_stmt|;
block|}
ifdef|#
directive|ifdef
name|V7UNIX
if|if
condition|(
name|code
operator|==
name|EXECE
condition|)
block|{
for|for
control|(
name|j
operator|=
operator|++
name|i
init|;
name|args
index|[
name|j
index|]
operator|=
operator|*
name|savep
operator|++
condition|;
name|j
operator|++
control|)
empty_stmt|;
for|for
control|(
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
block|{
name|oavp
operator|=
operator|(
name|char
operator|*
operator|)
name|args
index|[
name|j
index|]
expr_stmt|;
name|args
index|[
name|j
index|]
operator|=
operator|(
name|int
operator|)
name|avp
expr_stmt|;
while|while
condition|(
operator|*
name|avp
operator|++
operator|=
operator|*
name|oavp
operator|++
condition|)
empty_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SETUID and SETGID files must be started with a fresh RTS */
if|if
condition|(
name|stat32v
operator|.
name|st_mode
operator|&
name|S_ISGID
operator|||
name|stat32v
operator|.
name|st_mode
operator|&
name|S_ISUID
condition|)
block|{
comment|/* should add a check here for good magic # in header */
name|args
index|[
literal|1
index|]
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|RTSNAME
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" SETUID-GID"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
index|[
name|i
index|]
condition|)
name|i
operator|=
name|execve
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|execv
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't exec %s\n"
argument_list|,
name|RTSNAME
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|execute
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|args
index|[
literal|1
index|]
argument_list|,
operator|&
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* shouldn't get here if exec works */
break|break;
case|case
name|SEEK
case|:
ifdef|#
directive|ifdef
name|V6UNIX
comment|/* fix up negative offsets */
if|if
condition|(
name|args
index|[
literal|2
index|]
operator|!=
literal|0
operator|&&
name|args
index|[
literal|2
index|]
operator|!=
literal|3
condition|)
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|>=
literal|32768
condition|)
name|args
index|[
literal|1
index|]
operator|-=
literal|65536
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|2
index|]
operator|<=
literal|2
condition|)
name|i
operator|=
name|lseek
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|lseek
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
operator|*
literal|512
argument_list|,
name|args
index|[
literal|2
index|]
operator|-
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
name|i
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|V7UNIX
name|i
operator|=
name|lseek
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|(
name|args
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|args
index|[
literal|2
index|]
operator|&
literal|0177777
operator|)
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|V6UNIX
case|case
name|MKNOD
case|:
comment|/* version 6 uses allocated bit which means regular file here */
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|&
name|S_IFBLK
condition|)
name|args
index|[
literal|1
index|]
operator|&=
operator|~
name|S_IFREG
expr_stmt|;
name|i
operator|=
name|mknod
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|PIPE
case|:
name|i
operator|=
name|pipe
argument_list|(
name|pipes
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|pipes
index|[
literal|0
index|]
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|pipes
index|[
literal|1
index|]
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|V6UNIX
case|case
name|TELL
case|:
name|i
operator|=
name|lseek
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|STAT
case|:
case|case
name|FSTAT
case|:
comment|/* do the syscall to a local stat buffer */
name|i
operator|=
name|syscall
argument_list|(
name|code
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|stat32v
argument_list|)
expr_stmt|;
comment|/* reverse the longs */
name|stat32v
operator|.
name|st_size
operator|=
name|longrev
argument_list|(
name|stat32v
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|stat32v
operator|.
name|st_atime
operator|=
name|longrev
argument_list|(
name|stat32v
operator|.
name|st_atime
argument_list|)
expr_stmt|;
name|stat32v
operator|.
name|st_mtime
operator|=
name|longrev
argument_list|(
name|stat32v
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|stat32v
operator|.
name|st_ctime
operator|=
name|longrev
argument_list|(
name|stat32v
operator|.
name|st_ctime
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|V7UNIX
comment|/* copy out otherwise unchanged stat buffer */
comment|/* in two pieces with st_size as the breaking point */
comment|/* note that st_rdev is a short but due to alingnmemt */
comment|/* problems the rest of the structure is out of sync */
name|j
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|stat32v
operator|.
name|st_size
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|stat32v
operator|.
name|st_dev
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|stat32v
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|stat32v
operator|.
name|st_size
argument_list|,
name|args
index|[
literal|1
index|]
operator|+
name|j
operator|-
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
operator|-
name|j
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|V6UNIX
comment|/* point to user area as v6stat structure */
name|v6stat
operator|=
operator|(
expr|struct
name|v6nod
operator|*
operator|)
name|args
index|[
literal|1
index|]
expr_stmt|;
comment|/* copy out piece by piece */
name|v6stat
operator|->
name|majmin
operator|=
name|stat32v
operator|.
name|st_dev
expr_stmt|;
name|v6stat
operator|->
name|inumber
operator|=
name|stat32v
operator|.
name|st_ino
expr_stmt|;
name|v6stat
operator|->
name|flags
operator|=
name|stat32v
operator|.
name|st_mode
expr_stmt|;
name|v6stat
operator|->
name|nlinks
operator|=
operator|(
name|unsigned
name|char
operator|)
name|stat32v
operator|.
name|st_nlink
expr_stmt|;
name|v6stat
operator|->
name|uid
operator|=
operator|(
name|unsigned
name|char
operator|)
name|stat32v
operator|.
name|st_uid
expr_stmt|;
name|v6stat
operator|->
name|gid
operator|=
operator|(
name|unsigned
name|char
operator|)
name|stat32v
operator|.
name|st_gid
expr_stmt|;
comment|/* note size already reversed */
name|v6stat
operator|->
name|size0
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|stat32v
operator|.
name|st_size
operator|&
literal|0377
argument_list|)
expr_stmt|;
name|v6stat
operator|->
name|size1
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|stat32v
operator|.
name|st_size
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|v6stat
operator|->
name|actime
operator|=
name|stat32v
operator|.
name|st_atime
expr_stmt|;
name|v6stat
operator|->
name|modtime
operator|=
name|stat32v
operator|.
name|st_mtime
expr_stmt|;
comment|/* patch up flags */
comment|/* for now just set 100000 bit if not a plain file */
if|if
condition|(
name|v6stat
operator|->
name|flags
operator|&
literal|060000
condition|)
name|v6stat
operator|->
name|flags
operator||=
literal|0100000
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|TIMES
case|:
name|i
operator|=
name|times
argument_list|(
operator|&
name|timebuf
argument_list|)
expr_stmt|;
name|timebuf
operator|.
name|t2
operator|=
name|longrev
argument_list|(
name|timebuf
operator|.
name|t2
argument_list|)
operator|+
name|timebuf
operator|.
name|t1
expr_stmt|;
name|timebuf
operator|.
name|t3
operator|=
name|longrev
argument_list|(
name|timebuf
operator|.
name|t3
argument_list|)
expr_stmt|;
name|timebuf
operator|.
name|t4
operator|=
name|longrev
argument_list|(
name|timebuf
operator|.
name|t4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|timebuf
operator|.
name|t2
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timebuf
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|V6UNIX
case|case
name|SLEEP
case|:
comment|/* do a sleep function - what about pwb which has alarm? */
name|sleep
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|GETUID
case|:
name|args
index|[
literal|0
index|]
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|geteuid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|V6UNIX
name|i
operator|=
name|args
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|args
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GETGID
case|:
name|args
index|[
literal|0
index|]
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|getegid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|V6UNIX
name|i
operator|=
name|args
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|args
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|V6UNIX
case|case
name|SETUID
case|:
case|case
name|SETGID
case|:
comment|/* uids and gids are 8 bits in version 6 */
name|i
operator|=
name|syscall
argument_list|(
name|code
argument_list|,
name|args
index|[
literal|0
index|]
operator|&
literal|0377
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIG
case|:
comment|/* if it is a good signal code */
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|<=
name|NSIG
condition|)
block|{
comment|/* get the current signal value */
name|i
operator|=
name|sigvals
index|[
name|args
index|[
literal|0
index|]
index|]
expr_stmt|;
comment|/* reset the signal to the new value */
name|sigvals
index|[
name|args
index|[
literal|0
index|]
index|]
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
comment|/* actually do signal except don't reset SIGILL */
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|!=
name|SIGILL
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
operator|(
name|int
operator|)
name|SIG_DFL
operator|||
name|args
index|[
literal|1
index|]
operator|&
operator|(
name|int
operator|)
name|SIG_IGN
condition|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|signal
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|signal
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|sigcatch
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|BRK
case|:
comment|/* brk is successful unless we run over the stack */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|>=
name|regs
index|[
literal|6
index|]
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|V6UNIX
case|case
name|PWBSYS
case|:
comment|/* ignore pwbsys for now */
switch|switch
condition|(
name|args
index|[
literal|2
index|]
condition|)
block|{
case|case
name|UNAME
case|:
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"UNAME with %d %d\n"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|"pwbname"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UDATA
case|:
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"UDATA with %d %d\n"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|USTAT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"USTAT with %d %d\n"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UTIME
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"UTIME with %d %d\n"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad PWBSYS %d\n"
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
default|default:
comment|/* 		 *	Many sys calls are easily done here since most 		 *	system call codes are the same on version 6 and 7 UNIX 		 *	as they are here. 		 */
name|i
operator|=
name|syscall
argument_list|(
name|code
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|,
name|args
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|V6UNIX
comment|/* allow read write access to created files for(IDIS v6 mod) */
if|if
condition|(
name|code
operator|==
name|CREAT
condition|)
block|{
comment|/* get actual file mode after create */
name|fstat
argument_list|(
name|i
argument_list|,
operator|&
name|stat32v
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* ensure read/write access to owner */
name|chmod
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
name|i
operator|=
name|open
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* change mode back the way it was */
name|chmod
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|stat32v
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
end_switch

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_expr_stmt
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" sys val -> 0%o\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* set carry bit if sys error */
end_comment

begin_if
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|psl
operator||=
name|CARRY
expr_stmt|;
end_if

begin_comment
comment|/* if not an indirect sys call, adjust the pc */
end_comment

begin_if
if|if
condition|(
name|indirflg
operator|==
literal|0
condition|)
name|pc
operator|=
name|argp
expr_stmt|;
end_if

begin_comment
comment|/* do alternate return on one side of fork */
end_comment

begin_if
if|if
condition|(
name|code
operator|==
name|FORK
operator|&&
name|i
operator|!=
literal|0
condition|)
name|pc
operator|++
expr_stmt|;
end_if

begin_comment
comment|/* do the various return value formats */
end_comment

begin_switch
switch|switch
condition|(
name|sysargs
index|[
name|code
index|]
index|[
literal|2
index|]
condition|)
block|{
case|case
name|NORMRET
case|:
comment|/* normal case only one return value in r0 */
name|regs
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|LONGRET
case|:
comment|/* return a long in r0 - r1 as in time */
name|regs
index|[
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|regs
index|[
literal|0
index|]
operator|=
name|i
operator|>>
literal|16
expr_stmt|;
break|break;
case|case
name|TWORET
case|:
comment|/* return two ints in r0 - r1 as in pipe */
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|regs
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
else|else
block|{
name|regs
index|[
literal|1
index|]
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|regs
index|[
literal|0
index|]
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
block|}
end_switch

begin_if
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|regs
index|[
literal|0
index|]
operator|=
name|errno
expr_stmt|;
end_if

begin_macro
unit|} long
name|longrev
argument_list|(
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|long
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* function to reverse the halves of a long */
union|union
block|{
name|long
name|lng
decl_stmt|;
name|short
name|s
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
specifier|register
name|short
name|t
decl_stmt|;
name|u
operator|.
name|lng
operator|=
name|l
expr_stmt|;
name|t
operator|=
name|u
operator|.
name|s
index|[
literal|0
index|]
expr_stmt|;
name|u
operator|.
name|s
index|[
literal|0
index|]
operator|=
name|u
operator|.
name|s
index|[
literal|1
index|]
expr_stmt|;
name|u
operator|.
name|s
index|[
literal|1
index|]
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|u
operator|.
name|lng
operator|)
return|;
block|}
end_block

end_unit

