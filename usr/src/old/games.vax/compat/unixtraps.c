begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)unixtraps.c	4.4 88/09/22"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From Lou Salkind: compat/RCS/unixtraps.c,v 1.2 84/01/31 13:34:34 */
end_comment

begin_comment
comment|/*  * Function to execute version 6 and version 7 UNIX system calls from  * compatability mode on UNIX-32V.  *	Art Wetzel	August 1979  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|V6UNIX
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_define
define|#
directive|define
name|RTSNAME
value|"/../../../../usr/local/v6trc"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RTSNAME
value|"/../../../../usr/local/v6run"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"unix6sys.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_include
include|#
directive|include
file|"unix6sysn.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|V7UNIX
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_define
define|#
directive|define
name|RTSNAME
value|"/../../../../usr/local/v7trc"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RTSNAME
value|"/../../../../usr/local/v7run"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"unix7sys.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_include
include|#
directive|include
file|"unix7sysn.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_define
define|#
directive|define
name|CARRY
value|1
end_define

begin_define
define|#
directive|define
name|MAXSARGS
value|100
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|V6UNIX
end_ifdef

begin_define
define|#
directive|define
name|ARGVLEN
value|512
end_define

begin_define
define|#
directive|define
name|ENVLEN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|V7UNIX
end_ifdef

begin_define
define|#
directive|define
name|ARGVLEN
value|5120
end_define

begin_define
define|#
directive|define
name|ENVLEN
value|1000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|argvs
index|[
name|ARGVLEN
operator|+
name|ENVLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|args
index|[
name|MAXSARGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 32v type stat structure */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|stat
name|stat32v
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place for times data so we can reverse the longs */
end_comment

begin_struct
struct|struct
name|timebuf
block|{
name|long
name|t1
decl_stmt|;
name|long
name|t2
decl_stmt|;
name|long
name|t3
decl_stmt|;
name|long
name|t4
decl_stmt|;
block|}
name|timebuf
struct|;
end_struct

begin_comment
comment|/* place for pipe file descriptors */
end_comment

begin_decl_stmt
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wait status */
end_comment

begin_decl_stmt
name|int
name|wstatus
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|V6UNIX
end_ifdef

begin_comment
comment|/* version 6 style stat structure */
end_comment

begin_struct
struct|struct
name|v6nod
block|{
name|dev_t
name|majmin
decl_stmt|;
name|ino_t
name|inumber
decl_stmt|;
name|unsigned
name|short
name|flags
decl_stmt|;
name|unsigned
name|char
name|nlinks
decl_stmt|;
name|unsigned
name|char
name|uid
decl_stmt|;
name|unsigned
name|char
name|gid
decl_stmt|;
name|unsigned
name|char
name|size0
decl_stmt|;
name|unsigned
name|short
name|size1
decl_stmt|;
name|unsigned
name|short
name|addr
index|[
literal|8
index|]
decl_stmt|;
name|long
name|actime
decl_stmt|;
name|long
name|modtime
decl_stmt|;
block|}
modifier|*
name|v6stat
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|V7UNIX
end_ifdef

begin_comment
comment|/* version 7 style stat structure */
end_comment

begin_struct
struct|struct
name|v7stat
block|{
name|dev_t
name|v7st_dev
decl_stmt|;
name|u_short
name|v7st_ino
decl_stmt|;
name|u_short
name|v7st_mode
decl_stmt|;
name|short
name|v7st_nlink
decl_stmt|;
name|short
name|v7st_uid
decl_stmt|;
name|short
name|v7st_gid
decl_stmt|;
name|dev_t
name|v7st_rdev
decl_stmt|;
name|int
name|v7st_size
decl_stmt|;
name|int
name|v7st_atime
decl_stmt|;
name|int
name|v7st_mtime
decl_stmt|;
name|int
name|v7st_ctime
decl_stmt|;
block|}
name|statv7
struct|;
end_struct

begin_struct
struct|struct
name|timeb
block|{
name|time_t
name|time
decl_stmt|;
name|u_short
name|millitm
decl_stmt|;
name|short
name|timezone
decl_stmt|;
name|short
name|dstflag
decl_stmt|;
block|}
name|timeb
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NFILES
value|20
end_define

begin_define
define|#
directive|define
name|ODSIZE
value|16
end_define

begin_function_decl
name|off_t
name|olseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|longrev
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
name|odirect
block|{
name|u_short
name|od_ino
decl_stmt|;
name|char
name|od_name
index|[
literal|14
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fdflags
block|{
name|DIR
modifier|*
name|fd_dirp
decl_stmt|;
name|struct
name|odirect
name|fd_od
decl_stmt|;
name|off_t
name|fd_offset
decl_stmt|;
block|}
name|fdflags
index|[
name|NFILES
index|]
struct|;
end_struct

begin_comment
comment|/* do the trap stuff for the trap with code */
end_comment

begin_macro
name|dotrap
argument_list|(
argument|code
argument_list|)
end_macro

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|short
modifier|*
name|argp
decl_stmt|,
modifier|*
name|savp
decl_stmt|,
modifier|*
name|savep
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|indirflg
decl_stmt|;
specifier|register
name|char
modifier|*
name|avp
decl_stmt|,
modifier|*
name|oavp
decl_stmt|;
extern|extern sigcatch(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern errno;
end_extern

begin_decl_stmt
specifier|extern
name|int
name|sigtrapped
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DIR
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|sigtrapped
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* clear out condition codes of psl */
end_comment

begin_expr_stmt
name|psl
operator|&=
operator|~
literal|017
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* special case of indirect sys call */
end_comment

begin_if
if|if
condition|(
name|code
operator|==
literal|0
condition|)
block|{
comment|/* remember this was indirect */
name|indirflg
operator|=
literal|1
expr_stmt|;
comment|/* point to args */
name|argp
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|*
operator|(
name|pc
operator|++
operator|)
expr_stmt|;
comment|/* code for indirect sys call */
name|code
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
comment|/* is it legit */
if|if
condition|(
name|code
operator|>>
literal|8
operator|!=
name|TRAPS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad indirect sys call at 0x%x\n"
argument_list|,
name|pc
operator|-
literal|2
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
comment|/* set carry flag */
name|psl
operator||=
name|CARRY
expr_stmt|;
name|regs
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|code
operator|&=
literal|0377
expr_stmt|;
block|}
else|else
block|{
comment|/* remember this was not indirect */
name|indirflg
operator|=
literal|0
expr_stmt|;
comment|/* point to args */
name|argp
operator|=
name|pc
expr_stmt|;
block|}
end_if

begin_comment
comment|/* check if code too high or bad sys code */
end_comment

begin_if
if|if
condition|(
name|code
operator|>=
name|NSYSTRAPS
operator|||
name|sysargs
index|[
name|code
index|]
index|[
literal|0
index|]
operator|==
name|ILLSYS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unimplimented trap %d at 0x%x\n"
argument_list|,
name|code
argument_list|,
name|argp
argument_list|)
expr_stmt|;
comment|/* set carry bit */
name|psl
operator||=
name|CARRY
expr_stmt|;
name|regs
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_if

begin_comment
comment|/* copy args to known locations */
end_comment

begin_expr_stmt
name|i
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sysargs
index|[
name|code
index|]
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
name|args
index|[
name|i
operator|++
index|]
operator|=
name|regs
index|[
name|j
index|]
expr_stmt|;
end_for

begin_for
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|sysargs
index|[
name|code
index|]
index|[
literal|1
index|]
operator|)
condition|;
name|j
operator|++
control|)
name|args
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
end_for

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_expr_stmt
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pid %d "
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|indirflg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"indirect "
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s (%d) from 0%o with %d args"
argument_list|,
name|sysnames
index|[
name|code
index|]
argument_list|,
name|code
argument_list|,
name|pc
operator|-
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" 0%o"
argument_list|,
name|args
index|[
name|j
index|]
argument_list|)
expr_stmt|;
end_for

begin_if
if|if
condition|(
name|code
operator|==
name|OPEN
operator|||
name|code
operator|==
name|STAT
operator|||
name|code
operator|==
name|CREAT
operator|||
name|code
operator|==
name|EXEC
operator|||
name|code
operator|==
name|UNLNK
operator|||
name|code
operator|==
name|LINK
operator|||
name|code
operator|==
name|CHDIR
operator|||
name|code
operator|==
name|MKNOD
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%s)"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|V7UNIX
end_ifdef

begin_if
if|if
condition|(
name|code
operator|==
name|EXECE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%s)"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|code
operator|==
name|LINK
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%s)"
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* go do whatever sys call it is */
end_comment

begin_switch
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|FORK
case|:
comment|/* indirect forks return pids on both sides - must do here */
comment|/* this is possibly a bug in 32V */
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
break|break;
case|case
name|WAIT
case|:
name|i
operator|=
name|wait
argument_list|(
operator|&
name|wstatus
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|wstatus
expr_stmt|;
break|break;
case|case
name|EXEC
case|:
ifdef|#
directive|ifdef
name|V7UNIX
case|case
name|EXECE
case|:
endif|#
directive|endif
comment|/* 		 *  have to do a lot of junk here to fix up an argv 		 *  for execute since (1) the pdp-11 argv consists of 16 		 *  bit pointers and (2) the argv itself is in the 		 *  pdp-11 program space where it would get clobbered 		 *  when a new program is read in and before its 		 *  argv is set up. 		 */
name|avp
operator|=
operator|&
name|argvs
index|[
literal|0
index|]
expr_stmt|;
name|savp
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|args
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|V6UNIX
for|for
control|(
name|i
operator|=
literal|1
init|;
name|args
index|[
name|i
index|]
operator|=
operator|*
name|savp
operator|++
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|args
index|[
name|i
index|]
operator|==
literal|0177777
condition|)
break|break;
ifdef|#
directive|ifdef
name|TRACE
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"argv[%d]%s "
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|V7UNIX
name|savep
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|args
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|args
index|[
name|i
index|]
operator|=
operator|*
name|savp
operator|++
condition|;
name|i
operator|++
control|)
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"argv[%d]%s "
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|stat
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|stat32v
argument_list|)
condition|)
block|{
comment|/* return error here if file does not exist */
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" does not exist\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* must have execute permission */
if|if
condition|(
name|stat32v
operator|.
name|st_mode
operator|&
operator|(
name|S_IEXEC
operator|>>
literal|6
operator|)
condition|)
goto|goto
name|experm
goto|;
if|if
condition|(
name|stat32v
operator|.
name|st_mode
operator|&
operator|(
name|S_IEXEC
operator|>>
literal|3
operator|)
condition|)
block|{
if|if
condition|(
name|stat32v
operator|.
name|st_gid
operator|==
name|getegid
argument_list|()
condition|)
goto|goto
name|experm
goto|;
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
goto|goto
name|experm
goto|;
block|}
if|if
condition|(
name|stat32v
operator|.
name|st_mode
operator|&
name|S_IEXEC
condition|)
block|{
if|if
condition|(
name|stat32v
operator|.
name|st_uid
operator|==
name|geteuid
argument_list|()
condition|)
goto|goto
name|experm
goto|;
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
goto|goto
name|experm
goto|;
block|}
comment|/* return failure if no exec permision allowed */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|experm
label|:
comment|/* can't exec a directory */
if|if
condition|(
operator|(
name|stat32v
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
break|break;
name|args
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|oavp
operator|=
operator|(
name|char
operator|*
operator|)
name|args
index|[
name|j
index|]
expr_stmt|;
name|args
index|[
name|j
index|]
operator|=
operator|(
name|int
operator|)
name|avp
expr_stmt|;
while|while
condition|(
operator|*
name|avp
operator|++
operator|=
operator|*
name|oavp
operator|++
condition|)
empty_stmt|;
block|}
ifdef|#
directive|ifdef
name|V7UNIX
if|if
condition|(
name|code
operator|==
name|EXECE
condition|)
block|{
for|for
control|(
name|j
operator|=
operator|++
name|i
init|;
name|args
index|[
name|j
index|]
operator|=
operator|*
name|savep
operator|++
condition|;
name|j
operator|++
control|)
empty_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|oavp
operator|=
operator|(
name|char
operator|*
operator|)
name|args
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
name|args
index|[
name|j
index|]
operator|=
operator|(
name|int
operator|)
name|avp
expr_stmt|;
while|while
condition|(
operator|*
name|avp
operator|++
operator|=
operator|*
name|oavp
operator|++
condition|)
empty_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SETUID and SETGID files must be started with a fresh RTS */
if|if
condition|(
name|stat32v
operator|.
name|st_mode
operator|&
name|S_ISGID
operator|||
name|stat32v
operator|.
name|st_mode
operator|&
name|S_ISUID
condition|)
block|{
comment|/* should add a check here for good magic # in header */
name|args
index|[
literal|1
index|]
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|RTSNAME
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" SETUID-GID"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
index|[
name|i
index|]
condition|)
name|i
operator|=
name|execve
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|execv
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't exec %s\n"
argument_list|,
name|RTSNAME
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|execute
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|args
index|[
literal|1
index|]
argument_list|,
operator|&
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* shouldn't get here if exec works */
break|break;
case|case
name|SEEK
case|:
ifdef|#
directive|ifdef
name|V6UNIX
comment|/* fix up negative offsets */
if|if
condition|(
name|args
index|[
literal|2
index|]
operator|!=
literal|0
operator|&&
name|args
index|[
literal|2
index|]
operator|!=
literal|3
condition|)
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|>=
literal|32768
condition|)
name|args
index|[
literal|1
index|]
operator|-=
literal|65536
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|2
index|]
operator|<=
literal|2
condition|)
name|i
operator|=
name|olseek
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|olseek
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
operator|*
literal|512
argument_list|,
name|args
index|[
literal|2
index|]
operator|-
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
name|i
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|V7UNIX
name|i
operator|=
name|olseek
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|(
name|args
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|args
index|[
literal|2
index|]
operator|&
literal|0177777
operator|)
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|MKNOD
case|:
if|if
condition|(
operator|(
name|args
index|[
literal|1
index|]
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
name|i
operator|=
name|mkdir
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
operator|&
literal|0777
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|V6UNIX
comment|/* 			 * version 6 uses allocated bit which 			 * means regular file here 			 */
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|&
name|S_IFBLK
condition|)
name|args
index|[
literal|1
index|]
operator|&=
operator|~
name|S_IFREG
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|mknod
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PIPE
case|:
name|i
operator|=
name|pipe
argument_list|(
name|pipes
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|pipes
index|[
literal|0
index|]
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|pipes
index|[
literal|1
index|]
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|V6UNIX
case|case
name|TELL
case|:
name|i
operator|=
name|lseek
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|STTY
case|:
name|i
operator|=
name|stty
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTTY
case|:
name|i
operator|=
name|gtty
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* HAVE TO FAKE THE SIZE OF DIRECTORIES */
case|case
name|STAT
case|:
name|i
operator|=
name|stat
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|stat32v
argument_list|)
expr_stmt|;
goto|goto
name|allstat
goto|;
case|case
name|FSTAT
case|:
comment|/* do the syscall to a local stat buffer */
name|i
operator|=
name|fstat
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|stat32v
argument_list|)
expr_stmt|;
name|allstat
label|:
comment|/* reverse the longs */
name|stat32v
operator|.
name|st_size
operator|=
name|longrev
argument_list|(
name|stat32v
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|stat32v
operator|.
name|st_atime
operator|=
name|longrev
argument_list|(
name|stat32v
operator|.
name|st_atime
argument_list|)
expr_stmt|;
name|stat32v
operator|.
name|st_mtime
operator|=
name|longrev
argument_list|(
name|stat32v
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|stat32v
operator|.
name|st_ctime
operator|=
name|longrev
argument_list|(
name|stat32v
operator|.
name|st_ctime
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|V7UNIX
name|statv7
operator|.
name|v7st_dev
operator|=
name|stat32v
operator|.
name|st_dev
expr_stmt|;
name|statv7
operator|.
name|v7st_ino
operator|=
name|stat32v
operator|.
name|st_ino
expr_stmt|;
name|statv7
operator|.
name|v7st_mode
operator|=
name|stat32v
operator|.
name|st_mode
expr_stmt|;
name|statv7
operator|.
name|v7st_nlink
operator|=
name|stat32v
operator|.
name|st_nlink
expr_stmt|;
name|statv7
operator|.
name|v7st_uid
operator|=
name|stat32v
operator|.
name|st_uid
expr_stmt|;
name|statv7
operator|.
name|v7st_gid
operator|=
name|stat32v
operator|.
name|st_gid
expr_stmt|;
name|statv7
operator|.
name|v7st_rdev
operator|=
name|stat32v
operator|.
name|st_rdev
expr_stmt|;
name|statv7
operator|.
name|v7st_size
operator|=
name|stat32v
operator|.
name|st_size
expr_stmt|;
name|statv7
operator|.
name|v7st_atime
operator|=
name|stat32v
operator|.
name|st_atime
expr_stmt|;
name|statv7
operator|.
name|v7st_mtime
operator|=
name|stat32v
operator|.
name|st_mtime
expr_stmt|;
name|statv7
operator|.
name|v7st_ctime
operator|=
name|stat32v
operator|.
name|st_ctime
expr_stmt|;
comment|/* copy out otherwise unchanged stat buffer */
comment|/* in two pieces with st_size as the breaking point */
comment|/* note that st_rdev is a short but due to alingnmemt */
comment|/* problems the rest of the structure is out of sync */
name|j
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|statv7
operator|.
name|v7st_size
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|statv7
operator|.
name|v7st_dev
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|statv7
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|statv7
operator|.
name|v7st_size
argument_list|,
name|args
index|[
literal|1
index|]
operator|+
name|j
operator|-
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|v7stat
argument_list|)
operator|-
name|j
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|V6UNIX
comment|/* point to user area as v6stat structure */
name|v6stat
operator|=
operator|(
expr|struct
name|v6nod
operator|*
operator|)
name|args
index|[
literal|1
index|]
expr_stmt|;
comment|/* copy out piece by piece */
name|v6stat
operator|->
name|majmin
operator|=
name|stat32v
operator|.
name|st_dev
expr_stmt|;
name|v6stat
operator|->
name|inumber
operator|=
name|stat32v
operator|.
name|st_ino
expr_stmt|;
name|v6stat
operator|->
name|flags
operator|=
name|stat32v
operator|.
name|st_mode
expr_stmt|;
name|v6stat
operator|->
name|nlinks
operator|=
operator|(
name|unsigned
name|char
operator|)
name|stat32v
operator|.
name|st_nlink
expr_stmt|;
name|v6stat
operator|->
name|uid
operator|=
operator|(
name|unsigned
name|char
operator|)
name|stat32v
operator|.
name|st_uid
expr_stmt|;
name|v6stat
operator|->
name|gid
operator|=
operator|(
name|unsigned
name|char
operator|)
name|stat32v
operator|.
name|st_gid
expr_stmt|;
comment|/* note size already reversed */
name|v6stat
operator|->
name|size0
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|stat32v
operator|.
name|st_size
operator|&
literal|0377
argument_list|)
expr_stmt|;
name|v6stat
operator|->
name|size1
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|stat32v
operator|.
name|st_size
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|v6stat
operator|->
name|actime
operator|=
name|stat32v
operator|.
name|st_atime
expr_stmt|;
name|v6stat
operator|->
name|modtime
operator|=
name|stat32v
operator|.
name|st_mtime
expr_stmt|;
comment|/* patch up flags */
comment|/* for now just set 100000 bit if not a plain file */
if|if
condition|(
name|v6stat
operator|->
name|flags
operator|&
literal|060000
condition|)
name|v6stat
operator|->
name|flags
operator||=
literal|0100000
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|TIMES
case|:
name|i
operator|=
name|times
argument_list|(
operator|&
name|timebuf
argument_list|)
expr_stmt|;
name|timebuf
operator|.
name|t2
operator|=
name|longrev
argument_list|(
name|timebuf
operator|.
name|t2
argument_list|)
operator|+
name|timebuf
operator|.
name|t1
expr_stmt|;
name|timebuf
operator|.
name|t3
operator|=
name|longrev
argument_list|(
name|timebuf
operator|.
name|t3
argument_list|)
expr_stmt|;
name|timebuf
operator|.
name|t4
operator|=
name|longrev
argument_list|(
name|timebuf
operator|.
name|t4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|timebuf
operator|.
name|t2
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timebuf
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|V6UNIX
case|case
name|SLEEP
case|:
comment|/* do a sleep function - what about pwb which has alarm? */
name|sleep
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|GETUID
case|:
name|args
index|[
literal|0
index|]
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|geteuid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|V6UNIX
name|i
operator|=
name|args
index|[
literal|1
index|]
operator|<<
literal|8
operator||
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GETGID
case|:
name|args
index|[
literal|0
index|]
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|getegid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|V6UNIX
name|i
operator|=
name|args
index|[
literal|1
index|]
operator|<<
literal|8
operator||
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* uids and gids are 8 bits in version 6 */
case|case
name|SETUID
case|:
case|case
name|SETGID
case|:
ifdef|#
directive|ifdef
name|V6UNIX
name|args
index|[
literal|0
index|]
operator|&=
literal|0377
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|code
operator|==
name|SETUID
condition|)
name|i
operator|=
name|setuid
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|setgid
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIG
case|:
comment|/* if it is a good signal code */
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|<=
name|NSIG
condition|)
block|{
comment|/* get the current signal value */
name|i
operator|=
name|sigvals
index|[
name|args
index|[
literal|0
index|]
index|]
expr_stmt|;
comment|/* reset the signal to the new value */
name|sigvals
index|[
name|args
index|[
literal|0
index|]
index|]
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
comment|/* actually do signal except don't reset SIGILL */
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|!=
name|SIGILL
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
operator|(
name|int
operator|)
name|SIG_DFL
operator|||
name|args
index|[
literal|1
index|]
operator|&
operator|(
name|int
operator|)
name|SIG_IGN
condition|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|signal
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|signal
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|sigcatch
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|BRK
case|:
comment|/* brk is successful unless we run over the stack */
comment|/* NB: this assumes register usage which need not be used */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|>=
name|regs
index|[
literal|6
index|]
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
comment|/* 	 * the next bunch are to cope with sys calls removed from 4.2 	 */
case|case
name|TIME
case|:
name|i
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|STIME
case|:
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|args
index|[
literal|1
index|]
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|i
operator|=
name|settimeofday
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NICE
case|:
name|i
operator|=
name|nice
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|V7UNIX
case|case
name|ALARM
case|:
name|i
operator|=
name|alarm
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAUSE
case|:
name|i
operator|=
name|pause
argument_list|()
expr_stmt|;
break|break;
case|case
name|UTIME
case|:
name|i
operator|=
name|utime
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTIME
case|:
name|i
operator|=
name|ftime
argument_list|(
operator|&
name|timeb
argument_list|)
expr_stmt|;
name|timeb
operator|.
name|time
operator|=
name|longrev
argument_list|(
name|timeb
operator|.
name|time
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|timeb
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
name|timeb
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOCTL
case|:
name|args
index|[
literal|1
index|]
operator|=
name|mapioctl
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|i
operator|=
name|ioctl
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|V6UNIX
case|case
name|PWBSYS
case|:
comment|/* ignore pwbsys for now */
switch|switch
condition|(
name|args
index|[
literal|2
index|]
condition|)
block|{
case|case
name|UNAME
case|:
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"UNAME with %d %d\n"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|"pwbname"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UDATA
case|:
ifdef|#
directive|ifdef
name|TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"UDATA with %d %d\n"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|USTAT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"USTAT with %d %d\n"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UTIME
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"UTIME with %d %d\n"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad PWBSYS %d\n"
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
default|default:
comment|/* 		 *	Many sys calls are easily done here since most 		 *	system call codes are the same on version 6 and 7 UNIX 		 *	as they are here. 		 */
name|i
operator|=
name|syscall
argument_list|(
name|code
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|,
name|args
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|V6UNIX
comment|/* allow read write access to created files for (IDIS v6 mod) */
if|if
condition|(
name|code
operator|==
name|CREAT
condition|)
block|{
comment|/* get actual file mode after create */
name|fstat
argument_list|(
name|i
argument_list|,
operator|&
name|stat32v
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* ensure read/write access to owner */
name|chmod
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
name|i
operator|=
name|open
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* change mode back the way it was */
name|chmod
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|stat32v
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|OPEN
case|:
comment|/* 		 * check if we are opening a directory 		 */
if|if
condition|(
name|stat
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|stat32v
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
operator|(
name|stat32v
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
operator|)
operator|&&
operator|(
operator|(
name|dp
operator|=
name|opendir
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DTRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"open directory fd %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|dp
operator|->
name|dd_fd
expr_stmt|;
name|fdflags
index|[
name|i
index|]
operator|.
name|fd_dirp
operator|=
name|dp
expr_stmt|;
name|fdflags
index|[
name|i
index|]
operator|.
name|fd_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|i
operator|=
name|open
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOSE
case|:
name|i
operator|=
name|close
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|fdflags
index|[
name|args
index|[
literal|0
index|]
index|]
operator|.
name|fd_dirp
condition|)
block|{
name|closedir
argument_list|(
name|fdflags
index|[
name|args
index|[
literal|0
index|]
index|]
operator|.
name|fd_dirp
argument_list|)
expr_stmt|;
name|fdflags
index|[
name|args
index|[
literal|0
index|]
index|]
operator|.
name|fd_dirp
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|READ
case|:
if|if
condition|(
operator|(
name|unsigned
operator|)
name|args
index|[
literal|0
index|]
operator|<
name|NFILES
operator|&&
name|fdflags
index|[
name|args
index|[
literal|0
index|]
index|]
operator|.
name|fd_dirp
condition|)
name|i
operator|=
name|oread
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|read
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
end_switch

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_expr_stmt
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" sys val -> 0%o\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* set carry bit if sys error */
end_comment

begin_if
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|psl
operator||=
name|CARRY
expr_stmt|;
end_if

begin_comment
comment|/* if not an indirect sys call, adjust the pc */
end_comment

begin_if
if|if
condition|(
operator|!
name|indirflg
operator|&&
operator|!
name|sigtrapped
condition|)
name|pc
operator|=
name|argp
expr_stmt|;
end_if

begin_comment
comment|/* do alternate return on one side of fork */
end_comment

begin_if
if|if
condition|(
name|code
operator|==
name|FORK
operator|&&
name|i
operator|!=
literal|0
condition|)
name|pc
operator|++
expr_stmt|;
end_if

begin_comment
comment|/* do the various return value formats */
end_comment

begin_switch
switch|switch
condition|(
name|sysargs
index|[
name|code
index|]
index|[
literal|2
index|]
condition|)
block|{
case|case
name|NORMRET
case|:
comment|/* normal case only one return value in r0 */
name|regs
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|LONGRET
case|:
comment|/* return a long in r0 - r1 as in time */
name|regs
index|[
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|regs
index|[
literal|0
index|]
operator|=
name|i
operator|>>
literal|16
expr_stmt|;
break|break;
case|case
name|TWORET
case|:
comment|/* return two ints in r0 - r1 as in pipe */
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|regs
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
else|else
block|{
name|regs
index|[
literal|1
index|]
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|regs
index|[
literal|0
index|]
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
block|}
end_switch

begin_if
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|regs
index|[
literal|0
index|]
operator|=
name|errno
expr_stmt|;
end_if

begin_macro
unit|}  long
name|longrev
argument_list|(
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|long
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* function to reverse the halves of a long */
union|union
block|{
name|long
name|lng
decl_stmt|;
name|short
name|s
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
specifier|register
name|short
name|t
decl_stmt|;
name|u
operator|.
name|lng
operator|=
name|l
expr_stmt|;
name|t
operator|=
name|u
operator|.
name|s
index|[
literal|0
index|]
expr_stmt|;
name|u
operator|.
name|s
index|[
literal|0
index|]
operator|=
name|u
operator|.
name|s
index|[
literal|1
index|]
expr_stmt|;
name|u
operator|.
name|s
index|[
literal|1
index|]
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|u
operator|.
name|lng
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Note: these tables are sorted by  * ioctl "code" (in ascending order).  */
end_comment

begin_decl_stmt
name|int
name|fctls
index|[]
init|=
block|{
name|FIOCLEX
block|,
name|FIONCLEX
block|,
name|FIOASYNC
block|,
name|FIONBIO
block|,
name|FIONREAD
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tctls
index|[]
init|=
block|{
name|TIOCGETD
block|,
name|TIOCSETD
block|,
name|TIOCHPCL
block|,
name|TIOCMODG
block|,
name|TIOCMODS
block|,
name|TIOCGETP
block|,
name|TIOCSETP
block|,
name|TIOCSETN
block|,
name|TIOCEXCL
block|,
name|TIOCNXCL
block|,
name|TIOCFLUSH
block|,
name|TIOCSETC
block|,
name|TIOCGETC
block|,
name|TIOCREMOTE
block|,
name|TIOCMGET
block|,
name|TIOCMBIC
block|,
name|TIOCMBIS
block|,
name|TIOCMSET
block|,
name|TIOCSTART
block|,
name|TIOCSTOP
block|,
name|TIOCPKT
block|,
name|TIOCNOTTY
block|,
name|TIOCSTI
block|,
name|TIOCOUTQ
block|,
name|TIOCGLTC
block|,
name|TIOCSLTC
block|,
name|TIOCSPGRP
block|,
name|TIOCGPGRP
block|,
name|TIOCCDTR
block|,
name|TIOCSDTR
block|,
name|TIOCCBRK
block|,
name|TIOCSBRK
block|,
name|TIOCLGET
block|,
name|TIOCLSET
block|,
name|TIOCLBIC
block|,
name|TIOCLBIS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Map an old style ioctl command to new.  */
end_comment

begin_macro
name|mapioctl
argument_list|(
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|map
decl_stmt|,
name|c
decl_stmt|;
switch|switch
condition|(
operator|(
name|cmd
operator|>>
literal|8
operator|)
operator|&
literal|0xff
condition|)
block|{
case|case
literal|'f'
case|:
name|map
operator|=
name|fctls
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|map
operator|=
name|tctls
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|map
operator|)
operator|&&
operator|(
name|c
operator|&
literal|0xff
operator|)
operator|<
operator|(
name|cmd
operator|&
literal|0xff
operator|)
condition|)
name|map
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|&&
operator|(
name|c
operator|&
literal|0xff
operator|)
operator|==
operator|(
name|cmd
operator|&
literal|0xff
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * emulate a read of n bytes on an old style directory  */
end_comment

begin_macro
name|oread
argument_list|(
argument|fd
argument_list|,
argument|buf
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|,
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|fdflags
modifier|*
name|fp
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|odirect
modifier|*
name|odp
decl_stmt|;
specifier|register
name|int
name|nleft
init|=
name|count
decl_stmt|;
name|int
name|dir_off
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fp
operator|=
operator|&
name|fdflags
index|[
name|fd
index|]
expr_stmt|;
name|dirp
operator|=
name|fp
operator|->
name|fd_dirp
expr_stmt|;
name|odp
operator|=
operator|&
name|fp
operator|->
name|fd_od
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|dir_off
operator|=
name|fp
operator|->
name|fd_offset
operator|%
name|ODSIZE
expr_stmt|;
if|if
condition|(
name|dir_off
condition|)
block|{
name|i
operator|=
name|ODSIZE
operator|-
name|dir_off
expr_stmt|;
if|if
condition|(
name|nleft
operator|<
name|i
condition|)
name|i
operator|=
name|nleft
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|odp
operator|+
name|dir_off
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fd_offset
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|nleft
condition|)
return|return
operator|(
name|i
operator|)
return|;
name|buf
operator|+=
name|i
expr_stmt|;
name|nleft
operator|-=
name|i
expr_stmt|;
block|}
while|while
condition|(
name|nleft
operator|>=
name|ODSIZE
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|count
operator|-
name|nleft
operator|)
return|;
name|odp
operator|->
name|od_ino
operator|=
name|dp
operator|->
name|d_ino
expr_stmt|;
name|strncpy
argument_list|(
name|odp
operator|->
name|od_name
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|odp
argument_list|,
name|buf
argument_list|,
name|ODSIZE
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fd_offset
operator|+=
name|ODSIZE
expr_stmt|;
name|buf
operator|+=
name|ODSIZE
expr_stmt|;
name|nleft
operator|-=
name|ODSIZE
expr_stmt|;
block|}
if|if
condition|(
name|nleft
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|count
operator|-
name|nleft
operator|)
return|;
name|odp
operator|->
name|od_ino
operator|=
name|dp
operator|->
name|d_ino
expr_stmt|;
name|strncpy
argument_list|(
name|odp
operator|->
name|od_name
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|odp
argument_list|,
name|buf
argument_list|,
name|nleft
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fd_offset
operator|+=
name|nleft
expr_stmt|;
comment|/* nleft = 0; */
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * emulate the lseek system call  */
end_comment

begin_function
name|off_t
name|olseek
parameter_list|(
name|fd
parameter_list|,
name|n
parameter_list|,
name|whence
parameter_list|)
name|int
name|fd
decl_stmt|,
name|whence
decl_stmt|;
name|off_t
name|n
decl_stmt|;
block|{
name|struct
name|fdflags
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|off_t
name|newpos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|fd
operator|>=
name|NFILES
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fp
operator|=
operator|&
name|fdflags
index|[
name|fd
index|]
expr_stmt|;
comment|/* 	 * the system can handle everything 	 * except directory files 	 */
if|if
condition|(
name|fp
operator|->
name|fd_dirp
operator|==
name|NULL
condition|)
return|return
operator|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|n
argument_list|,
name|whence
argument_list|)
operator|)
return|;
switch|switch
condition|(
name|whence
condition|)
block|{
case|case
literal|0
case|:
name|newpos
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|newpos
operator|=
name|fp
operator|->
name|fd_offset
operator|+
name|n
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* not yet implemented */
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|newpos
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|newpos
operator|<
name|fp
operator|->
name|fd_offset
condition|)
block|{
name|rewinddir
argument_list|(
name|fdflags
index|[
name|fd
index|]
operator|.
name|fd_dirp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fd_offset
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|=
name|newpos
operator|-
name|fp
operator|->
name|fd_offset
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|j
operator|=
name|i
operator|<
literal|512
condition|?
name|i
else|:
literal|512
expr_stmt|;
if|if
condition|(
name|oread
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|j
argument_list|)
operator|!=
name|j
condition|)
break|break;
name|i
operator|-=
name|j
expr_stmt|;
block|}
return|return
operator|(
name|fp
operator|->
name|fd_offset
operator|)
return|;
block|}
end_function

end_unit

