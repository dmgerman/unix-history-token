begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)fio.c 4.2 %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * sdb - a symbolic debugger for unix - source file access routines.  */
end_comment

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*  * These procedures manage the source files examined by sdb,  * providing access to lines by number and utilities for printing  * and scrolling.  One file is kept open by these routines, and  * line index tables are maintained for all files which have been  * ``current'' at any time so far.  This makes line access trivial,  * since the location of each line in the files is known,  * although we get ``burned'' if the file is changed.  * SHOULD WATCH THE MODTIME OF FILES AND REINDEX IF IT CHANGES.  */
end_comment

begin_comment
comment|/*  * Structure for files which have been ``indexed''.  * Contains a pointer to the file name, a pointer to an  * array of seek pointers for the lines in the file,  * and a next link in a chain of these for all files we have indexed,  * The currently open file is cinfo->; the chain of active files is finfo.  */
end_comment

begin_struct
struct|struct
name|finfo
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of this file w/o common pfx */
name|off_t
modifier|*
name|lines
decl_stmt|;
comment|/* array of seek pointers */
comment|/* line i stretches from lines[i-1] to lines[i] - 1, if first line is 1 */
name|int
name|nlines
decl_stmt|;
comment|/* number of lines in file */
comment|/* lines array actually has nlines+1 elements, so last line is bracketed */
name|struct
name|finfo
modifier|*
name|next
decl_stmt|;
comment|/* link in chain of known files */
block|}
modifier|*
name|finfo
struct|,
modifier|*
name|cfile
struct|;
end_struct

begin_decl_stmt
name|FILE
modifier|*
name|FIO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current open file (only 1 now) */
end_comment

begin_decl_stmt
name|char
name|fibuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We use stdio when first reading the file, but thereafter  * use our own routines, because we want to be able  * to read backwards efficiently and avoid a tell() system  * call on each line.  Fseekpt remebers where we are in the current  * file.  */
end_comment

begin_decl_stmt
name|off_t
name|fseekpt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Make ``name'' the current source file, if it isn't already.  * If we have never seen this file before, then we create a finfo  * structure for it indexing the lines (this requires reading the  * entire file and building an index, but is well worth it since  * we otherwise have to brute force search the files all the time.)  */
end_comment

begin_macro
name|finit
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|off_t
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|cfile
operator|&&
operator|!
name|strcmp
argument_list|(
name|cfile
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return;
comment|/* its already current, do nothing */
comment|/* IT WOULD BE BETTER TO HAVE A COUPLE OF FILE DESCRIPTORS, LRU */
if|if
condition|(
name|FIO
condition|)
block|{
name|fclose
argument_list|(
name|FIO
argument_list|)
expr_stmt|;
name|FIO
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Paste the given name onto the common prefix (directory path) 	 * to form the full name of the file to be opened. 	 */
name|strcpy
argument_list|(
name|fp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|FIO
operator|=
name|fopen
argument_list|(
name|filework
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nolines
operator|=
literal|1
expr_stmt|;
name|perror
argument_list|(
name|filework
argument_list|)
expr_stmt|;
return|return;
block|}
name|setbuf
argument_list|(
name|FIO
argument_list|,
name|fibuf
argument_list|)
expr_stmt|;
name|fseekpt
operator|=
operator|-
name|BUFSIZ
expr_stmt|;
comment|/* putatively illegal */
name|strcpy
argument_list|(
name|curfile
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * See if we have alread indexed this file. 	 * If so, nothing much to do. 	 */
for|for
control|(
name|cfile
operator|=
name|finfo
init|;
name|cfile
condition|;
name|cfile
operator|=
name|cfile
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cfile
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return;
comment|/* 	 * Create a structure for this (new) file. 	 * Lines array grows 100 lines at a time. 	 * 1 extra so last line is bracketed. 	 */
name|cfile
operator|=
operator|(
expr|struct
name|finfo
operator|*
operator|)
name|sbrk
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|finfo
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|=
name|cfile
operator|->
name|lines
operator|=
operator|(
name|off_t
operator|*
operator|)
name|sbrk
argument_list|(
literal|101
operator|*
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* line 1 starts at 0 ... */
name|cfile
operator|->
name|nlines
operator|=
literal|0
expr_stmt|;
comment|/* IT WOULD PROBABLY BE FASTER TO JUST USE GETC AND LOOK FOR \n */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|FIO
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|++
name|cfile
operator|->
name|nlines
operator|%
literal|100
operator|)
operator|==
literal|0
condition|)
name|sbrk
argument_list|(
literal|100
operator|*
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Mark end of the cfile->nlines'th line 		 */
name|lp
index|[
literal|0
index|]
operator|=
name|lp
index|[
operator|-
literal|1
index|]
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|lp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cfile
operator|->
name|nlines
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no lines in file\n"
argument_list|,
name|filework
argument_list|)
expr_stmt|;
name|cfile
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * Allocate space for the name, making sure to leave the 	 * break on a word boundary. 	 * IT WOULD BE MUCH BETTER TO USE MALLOC AND REALLOC IN SDB. 	 */
name|sbrk
argument_list|(
name|lp
operator|+
operator|(
operator|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cfile
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|lp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cfile
operator|->
name|next
operator|=
name|finfo
expr_stmt|;
name|finfo
operator|=
name|cfile
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get the current line (fline) into fbuf  */
end_comment

begin_macro
name|fgetline
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|off_t
modifier|*
name|op
init|=
operator|&
name|cfile
operator|->
name|lines
index|[
name|fline
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|o
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|op
index|[
literal|1
index|]
operator|-
name|op
index|[
literal|0
index|]
expr_stmt|;
name|fbuf
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Case 1.  Line begins in current buffer. 	 * 	 * Compute the number of characters into the buffer where 	 * the line starts.  If this offset plus its length is greater 	 * than BUFSIZ, then this line splits across a buffer boundary 	 * so take the rest of this buffer and the first part of the next. 	 * Otherwise just take a chunk of this buffer. 	 */
if|if
condition|(
operator|*
name|op
operator|>=
name|fseekpt
operator|&&
operator|*
name|op
operator|<
name|fseekpt
operator|+
name|BUFSIZ
condition|)
block|{
name|case1
label|:
name|o
operator|=
name|op
index|[
literal|0
index|]
operator|-
name|fseekpt
expr_stmt|;
if|if
condition|(
name|o
operator|+
name|n
operator|>
name|BUFSIZ
condition|)
block|{
name|strncpy
argument_list|(
name|fbuf
argument_list|,
name|fibuf
operator|+
name|o
argument_list|,
name|BUFSIZ
operator|-
name|o
argument_list|)
expr_stmt|;
name|fseekpt
operator|+=
name|BUFSIZ
expr_stmt|;
name|read
argument_list|(
name|fileno
argument_list|(
name|FIO
argument_list|)
argument_list|,
name|fibuf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fbuf
operator|+
name|BUFSIZ
operator|-
name|o
argument_list|,
name|fibuf
argument_list|,
name|n
operator|-
operator|(
name|BUFSIZ
operator|-
name|o
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|strncpy
argument_list|(
name|fbuf
argument_list|,
name|fibuf
operator|+
name|o
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Case 2.  Line ends in current buffer. 	 * 	 * If the line ends in this buffer (but doesn't begin in 	 * it or else we would have had case 1) take the beginning 	 * part of the buffer (end of the line) and then back up and 	 * get the rest of the line from the end of the previous block. 	 */
if|if
condition|(
name|op
index|[
literal|1
index|]
operator|-
literal|1
operator|>=
name|fseekpt
operator|&&
name|op
index|[
literal|1
index|]
operator|<=
name|fseekpt
operator|+
name|BUFSIZ
condition|)
block|{
name|o
operator|=
name|op
index|[
literal|1
index|]
operator|-
name|fseekpt
expr_stmt|;
name|strncpy
argument_list|(
name|fbuf
operator|+
name|n
operator|-
name|o
argument_list|,
name|fibuf
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|fseekpt
operator|-=
name|BUFSIZ
expr_stmt|;
name|lseek
argument_list|(
name|fileno
argument_list|(
name|FIO
argument_list|)
argument_list|,
name|fseekpt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fileno
argument_list|(
name|FIO
argument_list|)
argument_list|,
name|fibuf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fbuf
argument_list|,
name|fibuf
operator|+
name|op
index|[
literal|0
index|]
operator|-
name|fseekpt
argument_list|,
name|n
operator|-
name|o
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Case 3.  Line not in current buffer at all. 	 * 	 * Read in the buffer where the line starts and then go 	 * back and handle as case 1. 	 */
name|fseekpt
operator|=
operator|(
name|op
index|[
literal|0
index|]
operator|/
name|BUFSIZ
operator|)
operator|*
name|BUFSIZ
expr_stmt|;
name|lseek
argument_list|(
name|fileno
argument_list|(
name|FIO
argument_list|)
argument_list|,
name|fseekpt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fileno
argument_list|(
name|FIO
argument_list|)
argument_list|,
name|fibuf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
goto|goto
name|case1
goto|;
block|}
end_block

begin_comment
comment|/*  * Advance current line, end-around (like for / search).  */
end_comment

begin_macro
name|fnext
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|cfile
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fline
operator|==
name|cfile
operator|->
name|nlines
condition|)
block|{
name|fline
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|fline
operator|++
expr_stmt|;
name|fgetline
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Retreat the current line, end around.  */
end_comment

begin_macro
name|fprev
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|cfile
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fline
operator|==
literal|1
condition|)
name|fline
operator|=
name|cfile
operator|->
name|nlines
expr_stmt|;
else|else
name|fline
operator|--
expr_stmt|;
name|fgetline
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print the current line.  */
end_comment

begin_macro
name|fprint
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|cfile
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"No lines in file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%d: %s"
argument_list|,
name|fline
argument_list|,
name|fbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Make line `num' current.  */
end_comment

begin_expr_stmt
name|ffind
argument_list|(
name|num
argument_list|)
specifier|register
name|int
name|num
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|cfile
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|num
operator|>
name|cfile
operator|->
name|nlines
condition|)
name|error
argument_list|(
literal|"Not that many lines in file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"Zero or negative line?"
argument_list|)
expr_stmt|;
else|else
block|{
name|fline
operator|=
name|num
expr_stmt|;
name|fgetline
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Go back n lines.  */
end_comment

begin_macro
name|fback
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cfile
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|n
operator|>
name|fline
operator|-
literal|1
condition|)
name|n
operator|=
name|fline
operator|-
literal|1
expr_stmt|;
name|fline
operator|-=
name|n
expr_stmt|;
name|fgetline
argument_list|()
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Go forwards n lines.  */
end_comment

begin_macro
name|fforward
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fnext
decl_stmt|;
if|if
condition|(
name|cfile
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|fline
operator|+
name|n
operator|>
name|cfile
operator|->
name|nlines
condition|)
name|n
operator|=
name|cfile
operator|->
name|nlines
operator|-
name|fline
expr_stmt|;
name|fline
operator|+=
name|n
expr_stmt|;
name|fgetline
argument_list|()
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Print (upto) n lines, returning number printed.  */
end_comment

begin_macro
name|fprintn
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cfile
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"No lines in file"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|fprint
argument_list|()
expr_stmt|;
if|if
condition|(
name|fline
operator|==
name|cfile
operator|->
name|nlines
operator|||
name|i
operator|==
name|n
condition|)
return|return
operator|(
name|i
operator|)
return|;
name|fnext
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

end_unit

