begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)io.c	4.2 (Berkeley) 8/11/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * io.c: font file I/O subroutines for fed.  */
end_comment

begin_include
include|#
directive|include
file|"fed.h"
end_include

begin_macro
name|getglyph
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|windno
decl_stmt|;
name|int
name|vertoff
decl_stmt|,
name|horoff
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"\n\ngetglyph(%s)\n"
argument_list|,
name|rdchar
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disptable
index|[
name|c
index|]
operator|.
name|nbytes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"no such char: %s\n"
argument_list|,
name|rdchar
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"no such character: %s"
argument_list|,
name|rdchar
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
return|return;
block|}
name|curchar
operator|=
name|c
expr_stmt|;
name|turnofcurs
argument_list|()
expr_stmt|;
if|if
condition|(
name|cht
index|[
name|curchar
index|]
operator|.
name|wherewind
operator|>=
literal|0
condition|)
block|{
comment|/* It's already in a window.  Don't have to do much. */
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"already in %d\n"
argument_list|,
name|cht
index|[
name|curchar
index|]
operator|.
name|wherewind
argument_list|)
expr_stmt|;
name|windno
operator|=
name|cht
index|[
name|curchar
index|]
operator|.
name|wherewind
expr_stmt|;
comment|/* Put a box around the current window */
if|if
condition|(
name|windno
operator|!=
name|curwind
condition|)
block|{
name|drawbox
argument_list|(
name|base
index|[
name|curwind
index|]
operator|.
name|r
operator|-
literal|1
argument_list|,
name|base
index|[
name|curwind
index|]
operator|.
name|c
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|GLROW
operator|+
literal|2
argument_list|,
name|GLCOL
operator|+
literal|2
argument_list|)
expr_stmt|;
name|drawbox
argument_list|(
name|base
index|[
name|windno
index|]
operator|.
name|r
operator|-
literal|1
argument_list|,
name|base
index|[
name|windno
index|]
operator|.
name|c
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|GLROW
operator|+
literal|2
argument_list|,
name|GLCOL
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|curwind
operator|=
name|windno
expr_stmt|;
name|syncwind
argument_list|(
name|windno
argument_list|)
expr_stmt|;
comment|/* should center base */
block|}
else|else
block|{
comment|/* 		 * Not on screen.  First find a suitable window, 		 * using round robin. 		 */
name|windno
operator|=
name|nextwind
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"chose window %d\n"
argument_list|,
name|windno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|nextwind
operator|>=
name|NWIND
condition|)
name|nextwind
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TWOWIND
comment|/* 		 * This is for debugging what happens when we run out 		 * of windows. 		 */
if|if
condition|(
name|nextwind
operator|>=
literal|2
condition|)
name|nextwind
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Put a box around the current window */
if|if
condition|(
name|windno
operator|!=
name|curwind
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"drawbox (%d %d)\n"
argument_list|,
name|base
index|[
name|windno
index|]
operator|.
name|r
operator|-
literal|1
argument_list|,
name|base
index|[
name|windno
index|]
operator|.
name|c
operator|-
literal|1
argument_list|)
expr_stmt|;
name|drawbox
argument_list|(
name|base
index|[
name|curwind
index|]
operator|.
name|r
operator|-
literal|1
argument_list|,
name|base
index|[
name|curwind
index|]
operator|.
name|c
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|GLROW
operator|+
literal|2
argument_list|,
name|GLCOL
operator|+
literal|2
argument_list|)
expr_stmt|;
name|drawbox
argument_list|(
name|base
index|[
name|windno
index|]
operator|.
name|r
operator|-
literal|1
argument_list|,
name|base
index|[
name|windno
index|]
operator|.
name|c
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|GLROW
operator|+
literal|2
argument_list|,
name|GLCOL
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Print the char at the lower left of the window */
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"%s"
argument_list|,
name|rdchar
argument_list|(
name|curchar
argument_list|)
argument_list|)
expr_stmt|;
name|dispmsg
argument_list|(
name|msgbuf
argument_list|,
name|base
index|[
name|windno
index|]
operator|.
name|c
argument_list|,
name|base
index|[
name|windno
index|]
operator|.
name|r
operator|-
literal|11
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Now make room in the window */
if|if
condition|(
name|wind
index|[
name|windno
index|]
operator|.
name|onscreen
operator|==
name|NULL
condition|)
block|{
comment|/* Brand new window, have to allocate space */
name|wind
index|[
name|windno
index|]
operator|.
name|onscreen
operator|=
name|newmat
argument_list|(
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Save prev glyph for later */
name|cht
index|[
name|wind
index|[
name|windno
index|]
operator|.
name|used
index|]
operator|.
name|whereat
operator|=
name|wind
index|[
name|windno
index|]
operator|.
name|val
expr_stmt|;
name|cht
index|[
name|wind
index|[
name|windno
index|]
operator|.
name|used
index|]
operator|.
name|wherewind
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"windno=%s, wind[windno].used=%d, cht[..].wherewind set to -2\n"
argument_list|,
name|rdchar
argument_list|(
name|windno
argument_list|)
argument_list|,
name|wind
index|[
name|windno
index|]
operator|.
name|used
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wind
index|[
name|windno
index|]
operator|.
name|undval
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"getglyph frees undo: %x\n"
argument_list|,
name|wind
index|[
name|windno
index|]
operator|.
name|undval
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wind
index|[
name|windno
index|]
operator|.
name|undval
argument_list|)
expr_stmt|;
block|}
name|wind
index|[
name|windno
index|]
operator|.
name|undval
operator|=
name|NULL
expr_stmt|;
name|wind
index|[
name|windno
index|]
operator|.
name|used
operator|=
name|curchar
expr_stmt|;
comment|/* 		 * Vertical& horizontal offsets.  Line up the baseline 		 * of the char at BASELINE from bottom, but center 		 * horizontally. 		 */
name|vertoff
operator|=
name|GLROW
operator|-
name|BASELINE
operator|-
name|disptable
index|[
name|curchar
index|]
operator|.
name|up
expr_stmt|;
comment|/* Check to see if the glyph is being nosed off the edge. */
if|if
condition|(
name|vertoff
operator|<
literal|0
condition|)
block|{
name|vertoff
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vertoff
operator|+
name|disptable
index|[
name|curchar
index|]
operator|.
name|up
operator|+
name|disptable
index|[
name|curchar
index|]
operator|.
name|down
operator|>=
name|GLROW
condition|)
block|{
name|vertoff
operator|=
name|GLROW
operator|-
name|disptable
index|[
name|curchar
index|]
operator|.
name|up
operator|-
name|disptable
index|[
name|curchar
index|]
operator|.
name|down
expr_stmt|;
block|}
name|horoff
operator|=
operator|(
name|GLCOL
operator|-
operator|(
name|disptable
index|[
name|curchar
index|]
operator|.
name|left
operator|+
name|disptable
index|[
name|curchar
index|]
operator|.
name|right
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
name|wind
index|[
name|windno
index|]
operator|.
name|val
operator|=
name|findbits
argument_list|(
name|curchar
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|horoff
argument_list|,
name|vertoff
argument_list|,
operator|&
name|curs_r
argument_list|,
operator|&
name|curs_c
argument_list|)
expr_stmt|;
name|cht
index|[
name|curchar
index|]
operator|.
name|rcent
operator|=
name|curs_r
expr_stmt|;
name|cht
index|[
name|curchar
index|]
operator|.
name|ccent
operator|=
name|curs_c
expr_stmt|;
name|curwind
operator|=
name|windno
expr_stmt|;
name|cht
index|[
name|curchar
index|]
operator|.
name|wherewind
operator|=
name|windno
expr_stmt|;
name|syncwind
argument_list|(
name|windno
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * writeback: write the font back to the file at the end of editing.  * Also have to write width table.  */
end_comment

begin_macro
name|writeback
argument_list|()
end_macro

begin_block
block|{
name|writefont
argument_list|(
name|fontfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * writefont: write current font on file fname.  */
end_comment

begin_macro
name|writefont
argument_list|(
argument|fname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|fntout
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|bitmat
name|tmp
decl_stmt|;
name|int
name|nextoff
init|=
literal|0
decl_stmt|;
name|int
name|charcount
decl_stmt|,
name|bytecount
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"writefont(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* 	 * The following unlink is important because we are about to 	 * do an fopen( , "w") on fname.  We still have fontdes open 	 * for reading.  If we don't do the unlink the fopen will truncate 	 * the file and subsequent reads will fail.  If we do the unlink 	 * the file won't go away until it is closed, so we can still 	 * read from the old version. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
name|fontfile
argument_list|)
operator|==
literal|0
operator|&&
name|unlink
argument_list|(
name|fname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"unlink %s: %s"
argument_list|,
name|fname
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
block|}
name|fntout
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntout
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"%s: %s"
argument_list|,
name|fname
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"%s\n"
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"\"%s\""
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|FontHeader
argument_list|,
sizeof|sizeof
name|FontHeader
argument_list|,
literal|1
argument_list|,
name|fntout
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|disptable
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
name|disptable
argument_list|,
literal|1
argument_list|,
name|fntout
argument_list|)
expr_stmt|;
name|charcount
operator|=
literal|0
expr_stmt|;
name|bytecount
operator|=
name|fbase
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|disptable
index|[
name|c
index|]
operator|.
name|nbytes
operator|||
name|cht
index|[
name|c
index|]
operator|.
name|wherewind
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"char %s, nbytes %d, wherewind %d.. "
argument_list|,
name|rdchar
argument_list|(
name|c
argument_list|)
argument_list|,
name|disptable
index|[
name|c
index|]
operator|.
name|nbytes
argument_list|,
name|cht
index|[
name|c
index|]
operator|.
name|wherewind
argument_list|)
expr_stmt|;
name|packmat
argument_list|(
name|c
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
name|disptable
index|[
name|c
index|]
operator|.
name|addr
operator|=
name|nextoff
expr_stmt|;
name|disptable
index|[
name|c
index|]
operator|.
name|nbytes
operator|=
name|bytes
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"offset %d size %d\n"
argument_list|,
name|nextoff
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|nextoff
operator|+=
name|bytes
expr_stmt|;
name|fwrite
argument_list|(
name|tmp
argument_list|,
name|bytes
argument_list|,
literal|1
argument_list|,
name|fntout
argument_list|)
expr_stmt|;
name|charcount
operator|++
expr_stmt|;
name|bytecount
operator|+=
name|bytes
expr_stmt|;
block|}
name|FontHeader
operator|.
name|size
operator|=
name|nextoff
expr_stmt|;
name|fseek
argument_list|(
name|fntout
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|FontHeader
argument_list|,
sizeof|sizeof
name|FontHeader
argument_list|,
literal|1
argument_list|,
name|fntout
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|disptable
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
name|disptable
argument_list|,
literal|1
argument_list|,
name|fntout
argument_list|)
expr_stmt|;
comment|/* Should fix the width tables here */
name|fclose
argument_list|(
name|fntout
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"%s %d glyphs, %d bytes"
argument_list|,
name|fname
argument_list|,
name|charcount
argument_list|,
name|bytecount
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|changes
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * make a packed matrix of the bits for char c.  * return the matrix ptr in result and the size in bytes in nbytes.  */
end_comment

begin_macro
name|packmat
argument_list|(
argument|c
argument_list|,
argument|result
argument_list|,
argument|nbytes
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bitmat
modifier|*
name|result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|nbytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bitmat
name|wp
decl_stmt|;
name|int
name|nb
decl_stmt|,
name|nr
decl_stmt|,
name|nc
decl_stmt|;
name|int
name|rmin
decl_stmt|,
name|cmin
decl_stmt|,
name|rmax
decl_stmt|,
name|cmax
decl_stmt|;
specifier|static
name|char
name|tmp
index|[
name|WINDSIZE
index|]
decl_stmt|;
if|if
condition|(
name|cht
index|[
name|c
index|]
operator|.
name|wherewind
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* It has never been read from file.  Just copy from file. */
name|nb
operator|=
name|disptable
index|[
name|c
index|]
operator|.
name|nbytes
expr_stmt|;
name|fseek
argument_list|(
name|fontdes
argument_list|,
operator|(
name|long
operator|)
name|fbase
operator|+
name|disptable
index|[
name|c
index|]
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|tmp
argument_list|,
name|nb
argument_list|,
literal|1
argument_list|,
name|fontdes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cht
index|[
name|c
index|]
operator|.
name|wherewind
operator|==
operator|-
literal|2
condition|)
name|wp
operator|=
name|cht
index|[
name|c
index|]
operator|.
name|whereat
expr_stmt|;
else|else
name|wp
operator|=
name|wind
index|[
name|cht
index|[
name|c
index|]
operator|.
name|wherewind
index|]
operator|.
name|val
expr_stmt|;
name|minmax
argument_list|(
name|wp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
operator|&
name|rmin
argument_list|,
operator|&
name|cmin
argument_list|,
operator|&
name|rmax
argument_list|,
operator|&
name|cmax
argument_list|)
expr_stmt|;
name|nr
operator|=
name|rmax
operator|-
name|rmin
operator|+
literal|1
expr_stmt|;
name|nc
operator|=
name|cmax
operator|-
name|cmin
operator|+
literal|1
expr_stmt|;
name|zermat
argument_list|(
name|tmp
argument_list|,
name|nr
argument_list|,
name|nc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rmin
init|;
name|i
operator|<=
name|rmax
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|cmin
init|;
name|j
operator|<=
name|cmax
condition|;
name|j
operator|++
control|)
block|{
name|setmat
argument_list|(
name|tmp
argument_list|,
name|nr
argument_list|,
name|nc
argument_list|,
name|i
operator|-
name|rmin
argument_list|,
name|j
operator|-
name|cmin
argument_list|,
name|mat
argument_list|(
name|wp
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nb
operator|=
operator|(
operator|(
name|nc
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|*
name|nr
expr_stmt|;
name|disptable
index|[
name|c
index|]
operator|.
name|up
operator|=
name|cht
index|[
name|c
index|]
operator|.
name|rcent
operator|-
name|rmin
expr_stmt|;
name|disptable
index|[
name|c
index|]
operator|.
name|down
operator|=
name|rmax
operator|-
name|cht
index|[
name|c
index|]
operator|.
name|rcent
operator|+
literal|1
expr_stmt|;
name|disptable
index|[
name|c
index|]
operator|.
name|left
operator|=
name|cht
index|[
name|c
index|]
operator|.
name|ccent
operator|-
name|cmin
expr_stmt|;
name|disptable
index|[
name|c
index|]
operator|.
name|right
operator|=
name|cmax
operator|-
name|cht
index|[
name|c
index|]
operator|.
name|ccent
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"rmax=%d, rcent=%d, rmin=%d, cmax=%d, ccent=%d, cmin=%d, "
argument_list|,
name|rmax
argument_list|,
name|cht
index|[
name|c
index|]
operator|.
name|rcent
argument_list|,
name|rmin
argument_list|,
name|cmax
argument_list|,
name|cht
index|[
name|c
index|]
operator|.
name|ccent
argument_list|,
name|cmin
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"up=%d, down=%d, left=%d, right=%d\n"
argument_list|,
name|disptable
index|[
name|c
index|]
operator|.
name|up
argument_list|,
name|disptable
index|[
name|c
index|]
operator|.
name|down
argument_list|,
name|disptable
index|[
name|c
index|]
operator|.
name|left
argument_list|,
name|disptable
index|[
name|c
index|]
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|result
operator|=
name|tmp
expr_stmt|;
operator|*
name|nbytes
operator|=
name|nb
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"nbytes = %d, "
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * editfont: make the file fname be the current focus of attention,  * including reading it into the buffer.  */
end_comment

begin_macro
name|editfont
argument_list|(
argument|fname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|clearfont
argument_list|()
expr_stmt|;
name|editing
operator|=
literal|1
expr_stmt|;
name|truename
argument_list|(
name|fname
argument_list|,
name|fontfile
argument_list|)
expr_stmt|;
name|fontdes
operator|=
name|fopen
argument_list|(
name|fontfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|readfont
argument_list|(
name|fontfile
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out the point size, and make a guess as to the 	 * appropriate width of the heavy pen. 	 */
for|for
control|(
name|cp
operator|=
name|fontfile
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
condition|;
name|cp
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
block|{
name|pointsize
operator|=
name|atoi
argument_list|(
operator|++
name|cp
argument_list|)
expr_stmt|;
name|setpen
argument_list|(
name|pointsize
operator|>
literal|30
condition|?
literal|3
else|:
name|pointsize
operator|>
literal|15
condition|?
literal|2
else|:
name|pointsize
operator|>
literal|8
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pointsize
operator|=
literal|0
expr_stmt|;
name|setpen
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * readfont: read in a font, overlaying the current font.  * also used to edit a font by clearing first.  *  * Conflicts are handled interactively.  */
end_comment

begin_macro
name|readfont
argument_list|(
argument|fname
argument_list|,
argument|c1
argument_list|,
argument|c2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|dispatch
name|d
decl_stmt|;
name|char
name|choice
decl_stmt|,
name|mode
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|hold_fontdes
decl_stmt|;
name|int
name|horoff
decl_stmt|,
name|vertoff
decl_stmt|;
name|long
name|ftsave
decl_stmt|;
name|hold_fontdes
operator|=
name|fontdes
expr_stmt|;
name|fontdes
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontdes
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"%s not found"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fontdes
operator|=
name|hold_fontdes
expr_stmt|;
name|error
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
block|}
name|fread
argument_list|(
operator|&
name|FontHeader
argument_list|,
sizeof|sizeof
name|FontHeader
argument_list|,
literal|1
argument_list|,
name|fontdes
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fontdes
argument_list|,
name|c1
operator|*
sizeof|sizeof
name|d
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* skip over unread chars */
name|ftsave
operator|=
name|ftell
argument_list|(
name|fontdes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|c1
init|;
name|i
operator|<=
name|c2
condition|;
name|i
operator|++
control|)
block|{
name|fseek
argument_list|(
name|fontdes
argument_list|,
name|ftsave
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|d
argument_list|,
sizeof|sizeof
name|d
argument_list|,
literal|1
argument_list|,
name|fontdes
argument_list|)
expr_stmt|;
name|ftsave
operator|=
name|ftell
argument_list|(
name|fontdes
argument_list|)
expr_stmt|;
comment|/* Decide which of the two to take */
if|if
condition|(
name|d
operator|.
name|nbytes
operator|==
literal|0
condition|)
continue|continue;
comment|/* We take the one in the buffer */
if|if
condition|(
name|disptable
index|[
name|i
index|]
operator|.
name|nbytes
operator|>
literal|0
condition|)
block|{
comment|/* Conflict */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* fall through */
break|break;
case|case
literal|'b'
case|:
continue|continue;
default|default:
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"%s<file> or<buffer>"
argument_list|,
name|rdchar
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|choice
operator|=
name|inchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|choice
condition|)
block|{
case|case
literal|'F'
case|:
name|mode
operator|=
literal|'f'
expr_stmt|;
default|default:
case|case
literal|'f'
case|:
break|break;
case|case
literal|'B'
case|:
name|mode
operator|=
literal|'b'
expr_stmt|;
case|case
literal|'b'
case|:
continue|continue;
block|}
block|}
block|}
name|disptable
index|[
name|i
index|]
operator|=
name|d
expr_stmt|;
comment|/* We take the one in the file */
name|cht
index|[
name|i
index|]
operator|.
name|nrow
operator|=
name|d
operator|.
name|up
operator|+
name|d
operator|.
name|down
expr_stmt|;
name|cht
index|[
name|i
index|]
operator|.
name|ncol
operator|=
name|d
operator|.
name|left
operator|+
name|d
operator|.
name|right
expr_stmt|;
if|if
condition|(
operator|!
name|editing
operator|&&
name|disptable
index|[
name|i
index|]
operator|.
name|nbytes
condition|)
block|{
name|horoff
operator|=
operator|(
name|GLCOL
operator|-
operator|(
name|disptable
index|[
name|i
index|]
operator|.
name|left
operator|+
name|disptable
index|[
name|i
index|]
operator|.
name|right
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
name|vertoff
operator|=
name|GLROW
operator|-
name|BASELINE
operator|-
name|disptable
index|[
name|i
index|]
operator|.
name|up
expr_stmt|;
comment|/* Check to see if the glyph is being nosed off the edge. */
if|if
condition|(
name|vertoff
operator|<
literal|0
condition|)
block|{
name|vertoff
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vertoff
operator|+
name|disptable
index|[
name|curchar
index|]
operator|.
name|up
operator|+
name|disptable
index|[
name|curchar
index|]
operator|.
name|down
operator|>=
name|GLROW
condition|)
block|{
name|vertoff
operator|=
name|GLROW
operator|-
name|disptable
index|[
name|curchar
index|]
operator|.
name|up
operator|-
name|disptable
index|[
name|curchar
index|]
operator|.
name|down
expr_stmt|;
block|}
if|if
condition|(
name|cht
index|[
name|i
index|]
operator|.
name|wherewind
operator|>=
literal|0
condition|)
block|{
comment|/* The old glyph is in a window - destroy it */
name|wind
index|[
name|cht
index|[
name|i
index|]
operator|.
name|wherewind
index|]
operator|.
name|used
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|cht
index|[
name|i
index|]
operator|.
name|wherewind
operator|=
operator|-
literal|1
expr_stmt|;
name|cht
index|[
name|i
index|]
operator|.
name|whereat
operator|=
name|findbits
argument_list|(
name|i
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|horoff
argument_list|,
name|vertoff
argument_list|,
operator|&
name|cht
index|[
name|i
index|]
operator|.
name|rcent
argument_list|,
operator|&
name|cht
index|[
name|i
index|]
operator|.
name|ccent
argument_list|)
expr_stmt|;
name|cht
index|[
name|i
index|]
operator|.
name|wherewind
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"setting cht[%d].wherewind to -2 in readfont\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|cht
index|[
name|i
index|]
operator|.
name|wherewind
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|fbase
operator|=
sizeof|sizeof
name|FontHeader
operator|+
sizeof|sizeof
name|disptable
expr_stmt|;
comment|/* ftell(fontdes) */
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"\"%s\", raster data %d bytes, width %d, height %d, xtend %d"
argument_list|,
name|fname
argument_list|,
name|FontHeader
operator|.
name|size
argument_list|,
name|FontHeader
operator|.
name|maxx
argument_list|,
name|FontHeader
operator|.
name|maxy
argument_list|,
name|FontHeader
operator|.
name|xtend
argument_list|)
expr_stmt|;
name|fontdes
operator|=
name|hold_fontdes
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Figure out the true name of the font file, given that  * the abbreviated name is fname.  The result is placed  * in the provided buffer result.  */
end_comment

begin_macro
name|truename
argument_list|(
argument|fname
argument_list|,
argument|result
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|result
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|t
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|fopen
argument_list|(
name|result
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"/usr/lib/vfont/%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|fopen
argument_list|(
name|result
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|result
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Can't find %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * clearfont: delete all characters in the current font.  */
end_comment

begin_macro
name|clearfont
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fontdes
condition|)
name|fclose
argument_list|(
name|fontdes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|cht
index|[
name|i
index|]
operator|.
name|wherewind
operator|=
operator|-
literal|1
expr_stmt|;
name|disptable
index|[
name|i
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
name|disptable
index|[
name|i
index|]
operator|.
name|nbytes
operator|=
literal|0
expr_stmt|;
name|disptable
index|[
name|i
index|]
operator|.
name|up
operator|=
literal|0
expr_stmt|;
name|disptable
index|[
name|i
index|]
operator|.
name|down
operator|=
literal|0
expr_stmt|;
name|disptable
index|[
name|i
index|]
operator|.
name|left
operator|=
literal|0
expr_stmt|;
name|disptable
index|[
name|i
index|]
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|disptable
index|[
name|i
index|]
operator|.
name|width
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * fileiocmd: do a file I/O command.  These all take optional file  * names, defaulting to the current file.  */
end_comment

begin_macro
name|fileiocmd
argument_list|(
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|char
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|fname
index|[
literal|100
index|]
decl_stmt|,
name|truefname
index|[
literal|100
index|]
decl_stmt|;
name|readline
argument_list|(
literal|"file: "
argument_list|,
name|fname
argument_list|,
sizeof|sizeof
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|fname
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|strcpy
argument_list|(
name|fname
argument_list|,
name|fontfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|'E'
case|:
name|confirm
argument_list|()
expr_stmt|;
name|editfont
argument_list|(
name|fname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|changes
condition|)
name|writeback
argument_list|()
expr_stmt|;
name|editfont
argument_list|(
name|fname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|editing
operator|=
literal|0
expr_stmt|;
name|truename
argument_list|(
name|fname
argument_list|,
name|truefname
argument_list|)
expr_stmt|;
name|readfont
argument_list|(
name|truefname
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|changes
operator|++
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|editing
operator|=
literal|0
expr_stmt|;
name|writefont
argument_list|(
name|fname
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|editing
condition|)
name|changes
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * readchars: read in a partial font (the P command).  */
end_comment

begin_macro
name|readchars
argument_list|()
end_macro

begin_block
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|char
name|fnamebuf
index|[
literal|100
index|]
decl_stmt|;
name|char
name|truebuf
index|[
literal|100
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
name|message
argument_list|(
literal|"Partial read<firstchar>"
argument_list|)
expr_stmt|;
name|c1
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Partial read %s thru<lastchar>"
argument_list|,
name|rdchar
argument_list|(
name|c1
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|c2
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|rdchar
argument_list|(
name|c1
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Partial read %s thru %s from file: "
argument_list|,
name|buf
argument_list|,
name|rdchar
argument_list|(
name|c2
argument_list|)
argument_list|)
expr_stmt|;
name|readline
argument_list|(
name|msgbuf
argument_list|,
name|fnamebuf
argument_list|,
sizeof|sizeof
name|fnamebuf
argument_list|)
expr_stmt|;
name|editing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fnamebuf
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|fnamebuf
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|strcpy
argument_list|(
name|fnamebuf
argument_list|,
name|fontfile
argument_list|)
expr_stmt|;
name|truename
argument_list|(
name|fnamebuf
argument_list|,
name|truebuf
argument_list|)
expr_stmt|;
name|changes
operator|++
expr_stmt|;
name|readfont
argument_list|(
name|truebuf
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

