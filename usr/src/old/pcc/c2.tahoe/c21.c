begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)c21.c	1.9 (Berkeley/CCI) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * C object code improver-- second part  */
end_comment

begin_include
include|#
directive|include
file|"c2.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
name|int
name|bitsize
index|[]
init|=
block|{
literal|0
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|32
block|,
literal|64
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index by type codes */
end_comment

begin_expr_stmt
name|redun3
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* check for 3 addr instr which should be 2 addr */
if|if
condition|(
name|has3ops
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|equstr
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|regs
index|[
name|RT3
index|]
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|op
operator|==
name|ADD
operator|||
name|p
operator|->
name|op
operator|==
name|MUL
operator|||
name|p
operator|->
name|op
operator|==
name|AND
operator|||
name|p
operator|->
name|op
operator|==
name|OR
operator|||
name|p
operator|->
name|op
operator|==
name|XOR
operator|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|t
init|=
name|regs
index|[
name|RT1
index|]
decl_stmt|;
name|regs
index|[
name|RT1
index|]
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
name|regs
index|[
name|RT2
index|]
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|equstr
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|regs
index|[
name|RT3
index|]
argument_list|)
condition|)
block|{
name|p
operator|->
name|subop
operator|=
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator||
operator|(
name|OP2
operator|<<
literal|4
operator|)
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|lastrand
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
operator|*
name|regs
index|[
name|RT3
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|bmove
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
name|struct
name|node
modifier|*
name|flops
parameter_list|()
function_decl|;
name|refcount
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lastp
operator|=
operator|&
name|first
init|;
literal|0
operator|!=
operator|(
name|p
operator|=
name|p
operator|->
name|forw
operator|)
condition|;
name|lastp
operator|=
name|p
control|)
empty_stmt|;
name|clearreg
argument_list|()
expr_stmt|;
name|clearuse
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lastp
init|;
name|p
operator|!=
operator|&
name|first
condition|;
name|p
operator|=
name|p
operator|->
name|back
control|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"Uses: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|useacc
condition|)
name|printf
argument_list|(
literal|"acc: %s\n"
argument_list|,
name|useacc
operator|->
name|code
condition|?
name|useacc
operator|->
name|code
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|NUSE
init|;
operator|--
name|r
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|uses
index|[
name|r
index|]
condition|)
name|printf
argument_list|(
literal|"%d: %s\n"
argument_list|,
name|r
argument_list|,
name|uses
index|[
name|r
index|]
operator|->
name|code
condition|?
name|uses
index|[
name|r
index|]
operator|->
name|code
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-\n"
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
operator|(
name|p
operator|->
name|subop
operator|>>
literal|4
operator|)
operator|&
literal|0xF
expr_stmt|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP3
operator|==
name|r
operator|&&
literal|0
operator|!=
name|redun3
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
block|}
comment|/* ops that do nothing */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MOV
operator|&&
name|equstr
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
condition|)
if|if
condition|(
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|CBR
condition|)
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|TST
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|->
name|code
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
name|redunm
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cp1
operator|=
name|p
operator|->
name|code
operator|,
operator|*
name|cp1
operator|++
operator|)
operator|==
literal|'$'
operator|&&
operator|(
operator|*
name|cp1
operator|==
literal|'0'
operator|||
operator|*
name|cp1
operator|==
literal|'1'
operator|||
operator|*
name|cp1
operator|++
operator|==
literal|'-'
operator|&&
operator|*
name|cp1
operator|==
literal|'1'
operator|)
operator|&&
name|cp1
index|[
literal|1
index|]
operator|==
literal|','
condition|)
block|{
switch|switch
condition|(
operator|(
name|p
operator|->
name|code
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|p
operator|->
name|op
argument_list|)
condition|)
block|{
case|case
operator|(
operator|(
literal|'0'
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|ADD
argument_list|)
operator|)
case|:
case|case
operator|(
operator|(
literal|'0'
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|SUB
argument_list|)
operator|)
case|:
case|case
operator|(
operator|(
literal|'-'
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|AND
argument_list|)
operator|)
case|:
case|case
operator|(
operator|(
literal|'0'
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|OR
argument_list|)
operator|)
case|:
case|case
operator|(
operator|(
literal|'0'
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|XOR
argument_list|)
operator|)
case|:
case|case
operator|(
operator|(
literal|'1'
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|MUL
argument_list|)
operator|)
case|:
case|case
operator|(
operator|(
literal|'1'
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|DIV
argument_list|)
operator|)
case|:
case|case
operator|(
operator|(
literal|'0'
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|SHAL
argument_list|)
operator|)
case|:
case|case
operator|(
operator|(
literal|'0'
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|SHAR
argument_list|)
operator|)
case|:
case|case
operator|(
operator|(
literal|'0'
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|SHL
argument_list|)
operator|)
case|:
case|case
operator|(
operator|(
literal|'0'
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|SHR
argument_list|)
operator|)
case|:
if|if
condition|(
name|r
operator|==
name|OP2
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|CBR
condition|)
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|TST
expr_stmt|;
name|p
operator|->
name|subop
operator|&=
literal|0xF
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|->
name|code
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
name|redunm
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* OP3 or shift */
name|p
operator|->
name|op
operator|=
name|MOV
expr_stmt|;
name|p
operator|->
name|subop
operator|&=
literal|0xF
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|->
name|code
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
name|p
operator|=
name|p
operator|->
name|forw
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
operator|(
operator|(
literal|'0'
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|MUL
argument_list|)
operator|)
case|:
case|case
operator|(
operator|(
literal|'0'
operator|<<
literal|8
operator|)
operator||
name|ord
argument_list|(
name|AND
argument_list|)
operator|)
case|:
name|p
operator|->
name|op
operator|=
name|CLR
expr_stmt|;
name|p
operator|->
name|subop
operator|&=
literal|0xF
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|->
name|code
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
if|if
condition|(
name|r
operator|==
name|OP3
condition|)
while|while
condition|(
operator|*
name|p
operator|->
name|code
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
name|redunm
operator|++
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|LABEL
case|:
case|case
name|DLABEL
case|:
for|for
control|(
name|r
operator|=
name|NUSE
init|;
operator|--
name|r
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|uses
index|[
name|r
index|]
condition|)
name|p
operator|->
name|ref
operator|=
operator|(
expr|struct
name|node
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|p
operator|->
name|ref
operator|)
operator||
operator|(
literal|1
operator|<<
name|r
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|useacc
condition|)
name|p
operator|->
name|ref
operator|=
operator|(
expr|struct
name|node
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|p
operator|->
name|ref
operator|)
operator||
operator|(
literal|1
operator|<<
name|NUSE
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CALLS
case|:
case|case
name|CALLF
case|:
name|clearuse
argument_list|()
expr_stmt|;
goto|goto
name|std
goto|;
case|case
name|NIL
case|:
name|clearuse
argument_list|()
expr_stmt|;
break|break;
case|case
name|CVT
case|:
block|{
name|long
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator|!=
name|LONG
condition|)
goto|goto
name|std
goto|;
name|cp1
operator|=
name|p
operator|->
name|code
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|'$'
condition|)
goto|goto
name|std
goto|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|getnum
argument_list|(
operator|&
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|BYTE
operator|&&
operator|(
name|n
operator|<
operator|-
literal|128
operator|||
name|n
operator|>
literal|127
operator|)
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|r
operator|==
name|WORD
operator|&&
operator|(
name|n
operator|<
operator|-
literal|32768
operator|||
name|n
operator|>
literal|32767
operator|)
condition|)
goto|goto
name|std
goto|;
name|p
operator|->
name|op
operator|=
name|MOV
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|std
goto|;
case|case
name|SUB
case|:
if|if
condition|(
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator|!=
name|LONG
condition|)
goto|goto
name|std
goto|;
name|cp1
operator|=
name|p
operator|->
name|code
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|'$'
condition|)
goto|goto
name|std
goto|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MOVAFASTER
if|if
condition|(
name|equstr
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
literal|"fp"
argument_list|)
operator|&&
operator|!
name|indexa
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
block|{
comment|/* address comp. */
name|char
name|buf
index|[
name|C2_ASIZE
index|]
decl_stmt|;
name|cp2
operator|=
name|buf
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
literal|'-'
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
operator|--
name|cp2
expr_stmt|;
name|cp1
operator|=
literal|"(fp),"
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
operator|--
name|cp2
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|MOVA
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|BYTE
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
endif|MOVAFASTER
if|if
condition|(
operator|*
name|cp1
operator|++
operator|==
literal|'-'
operator|&&
literal|0
operator|==
operator|(
name|r
operator|=
name|getnum
argument_list|(
name|cp1
argument_list|)
operator|)
operator|&&
operator|!
name|checkexpr
argument_list|(
name|cp1
argument_list|)
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|ADD
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
operator|*
operator|--
name|cp1
operator|=
literal|'$'
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|cp1
expr_stmt|;
block|}
goto|goto
name|std
goto|;
case|case
name|ADD
case|:
if|if
condition|(
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator|!=
name|LONG
condition|)
goto|goto
name|std
goto|;
name|cp1
operator|=
name|p
operator|->
name|code
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|'$'
condition|)
goto|goto
name|std
goto|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|isstatic
argument_list|(
name|cp1
argument_list|)
operator|&&
name|tempreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|r
argument_list|)
operator|&&
name|uses
index|[
name|r
index|]
operator|==
name|p
operator|->
name|forw
condition|)
block|{
comment|/* address comp: 			**	addl2	$_foo,r0  \	movab	_foo[r0],bar 			**	movl	r0,bar	  / 			*/
specifier|register
name|struct
name|node
modifier|*
name|pnext
init|=
name|p
operator|->
name|forw
decl_stmt|;
name|char
name|buf
index|[
name|C2_ASIZE
index|]
decl_stmt|;
if|if
condition|(
name|pnext
operator|->
name|op
operator|==
name|MOV
operator|&&
name|pnext
operator|->
name|subop
operator|==
name|LONG
condition|)
block|{
name|cp1
operator|=
operator|&
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|cp2
operator|=
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
name|cp2
operator|--
expr_stmt|;
name|splitrand
argument_list|(
name|pnext
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|isreg
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|pnext
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|MOVA
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|BYTE
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
literal|'['
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
name|cp2
operator|--
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
literal|']'
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
literal|','
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
ifdef|#
directive|ifdef
name|MOVAFASTER
if|if
condition|(
name|equstr
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
literal|"fp"
argument_list|)
operator|&&
operator|!
name|indexa
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
block|{
comment|/* address comp. */
name|cp2
operator|=
name|cp1
operator|-
literal|1
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
operator|--
name|cp2
expr_stmt|;
name|cp1
operator|=
literal|"(fp)"
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
operator|*
operator|--
name|cp2
operator|=
literal|','
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|MOVA
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|BYTE
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
endif|MOVAFASTER
if|if
condition|(
operator|*
name|cp1
operator|++
operator|==
literal|'-'
operator|&&
literal|0
operator|==
operator|(
name|r
operator|=
name|getnum
argument_list|(
name|cp1
argument_list|)
operator|)
operator|&&
operator|!
name|checkexpr
argument_list|(
name|cp1
argument_list|)
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|SUB
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
operator|*
operator|--
name|cp1
operator|=
literal|'$'
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|cp1
expr_stmt|;
block|}
comment|/* fall thru ... */
case|case
name|CASE
case|:
default|default:
name|std
label|:
name|p
operator|=
name|bflow
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MUL
case|:
comment|/* 		** Change multiplication 		** by constant powers of 2 to shifts. 		*/
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
index|[
name|RT1
index|]
index|[
literal|0
index|]
operator|!=
literal|'$'
operator|||
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|r
operator|=
name|ispow2
argument_list|(
name|getnum
argument_list|(
operator|&
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|std
goto|;
comment|/* mull2 $2,x */
if|if
condition|(
name|r
operator|==
literal|1
operator|&&
name|p
operator|->
name|subop
operator|==
name|U
argument_list|(
name|LONG
argument_list|,
name|OP2
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|ADD
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|std
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|subop
operator|==
name|U
argument_list|(
name|LONG
argument_list|,
name|OP2
argument_list|)
condition|)
name|strcpy
argument_list|(
name|regs
index|[
name|RT3
index|]
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
literal|"$%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|SHL
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|LONG
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|std
goto|;
case|case
name|SHAL
case|:
case|case
name|SHL
case|:
block|{
comment|/* bit tests: 		**	shll	A,$1,rC    \ 		**	bitl	B,rC>	jbc	A,B,D 		**	jeql	D	   / 		** 		** address comp: 		**	shll	$1,bar,r0  \	movl	bar,r0 		**	movab	_foo[r0]   /	movaw	_foo[r0] 		** 		**	shll	$2,r0,r0   \	moval	_foo[r0] 		**	movab	_foo[r0]   / 		*/
specifier|register
name|struct
name|node
modifier|*
name|pf
decl_stmt|;
specifier|register
name|struct
name|node
modifier|*
name|pn
decl_stmt|;
specifier|register
name|int
name|shfrom
decl_stmt|,
name|shto
decl_stmt|;
name|long
name|shcnt
decl_stmt|;
name|char
modifier|*
name|regfrom
decl_stmt|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
index|[
name|RT1
index|]
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
block|{
if|if
condition|(
name|isreg
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|std
goto|;
comment|/* alignment */
if|if
condition|(
name|regs
index|[
name|RT2
index|]
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|getnum
argument_list|(
operator|&
name|regs
index|[
name|RT2
index|]
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|!
name|tempreg
argument_list|(
name|regs
index|[
name|RT3
index|]
argument_list|,
name|r
argument_list|)
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|pf
operator|=
name|p
operator|->
name|forw
operator|)
operator|->
name|op
operator|!=
name|BIT
operator|&&
name|pf
operator|->
name|op
operator|!=
name|AND
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|uses
index|[
name|r
index|]
operator|&&
name|uses
index|[
name|r
index|]
operator|!=
name|pf
condition|)
goto|goto
name|std
goto|;
name|splitrand
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|isreg
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
name|cp2
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
condition|)
name|cp2
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
else|else
goto|goto
name|std
goto|;
if|if
condition|(
operator|*
name|cp2
operator|==
literal|'$'
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|pn
operator|=
name|pf
operator|->
name|forw
operator|)
operator|->
name|op
operator|!=
name|CBR
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|pn
operator|->
name|subop
operator|!=
name|JEQ
operator|&&
name|pn
operator|->
name|subop
operator|!=
name|JNE
condition|)
goto|goto
name|std
goto|;
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|delnode
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|pn
operator|->
name|subop
operator|=
operator|(
name|pn
operator|->
name|subop
operator|==
name|JEQ
operator|)
condition|?
name|JBC
else|:
name|JBS
expr_stmt|;
for|for
control|(
name|cp1
operator|=
name|p
operator|->
name|code
init|;
operator|*
name|cp1
operator|++
operator|!=
literal|','
condition|;
control|)
empty_stmt|;
while|while
condition|(
operator|*
name|cp1
operator|++
operator|=
operator|*
name|cp2
operator|++
condition|)
empty_stmt|;
name|pn
operator|->
name|code
operator|=
name|p
operator|->
name|code
expr_stmt|;
name|pn
operator|->
name|pop
operator|=
name|NULL
expr_stmt|;
name|uses
index|[
name|r
index|]
operator|=
name|NULL
expr_stmt|;
name|nbj
operator|++
expr_stmt|;
name|p
operator|=
name|pn
expr_stmt|;
goto|goto
name|std
goto|;
block|}
if|if
condition|(
operator|(
name|shcnt
operator|=
name|getnum
argument_list|(
operator|&
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<
literal|1
operator|||
name|shcnt
operator|>
literal|2
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|shfrom
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|regfrom
operator|=
name|copy
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempreg
argument_list|(
name|regs
index|[
name|RT3
index|]
argument_list|,
name|shto
argument_list|)
condition|)
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|uses
index|[
name|shto
index|]
operator|!=
operator|(
name|pf
operator|=
name|p
operator|->
name|forw
operator|)
condition|)
goto|goto
name|ashadd
goto|;
if|if
condition|(
name|pf
operator|->
name|op
operator|!=
name|MOVA
operator|&&
name|pf
operator|->
name|op
operator|!=
name|PUSHA
condition|)
goto|goto
name|ashadd
goto|;
if|if
condition|(
name|pf
operator|->
name|subop
operator|!=
name|BYTE
condition|)
goto|goto
name|ashadd
goto|;
name|splitrand
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexa
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
goto|goto
name|std
goto|;
name|cp2
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|isstatic
argument_list|(
name|cp2
argument_list|)
condition|)
goto|goto
name|std
goto|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|!=
literal|'['
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|cp2
operator|++
operator|!=
literal|'r'
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|cp2
argument_list|)
condition|)
goto|goto
name|std
goto|;
name|regnum
operator|=
operator|*
name|cp2
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp2
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp2
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
goto|goto
name|std
goto|;
name|regnum
operator|*=
literal|10
expr_stmt|;
name|regnum
operator|+=
operator|*
name|cp2
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|!=
name|shto
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|shfrom
operator|>=
literal|0
condition|)
comment|/* shll $N,r*,r0 */
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|pf
expr_stmt|;
if|if
condition|(
name|shfrom
operator|!=
name|shto
condition|)
block|{
name|uses
index|[
name|shto
index|]
operator|=
name|NULL
expr_stmt|;
name|splitrand
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|!=
literal|'['
condition|)
empty_stmt|;
name|cp1
operator|=
name|regfrom
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
name|cp2
index|[
operator|-
literal|1
index|]
operator|=
literal|']'
expr_stmt|;
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|MOV
expr_stmt|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|regs
index|[
name|RT3
index|]
argument_list|)
expr_stmt|;
name|regs
index|[
name|RT3
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|shcnt
condition|)
block|{
case|case
literal|1
case|:
name|pf
operator|->
name|subop
operator|=
name|WORD
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pf
operator|->
name|subop
operator|=
name|LONG
expr_stmt|;
break|break;
block|}
name|pf
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
name|nsaddr
operator|++
expr_stmt|;
block|}
goto|goto
name|std
goto|;
name|ashadd
label|:
comment|/* at this point, RT2 and RT3 are guaranteed to be simple regs*/
if|if
condition|(
name|shcnt
operator|==
literal|1
condition|)
block|{
comment|/* 			** quickie: 			**	shll	$1,A,A>	addl2	A,A 			**	shll	$1,A,B>	addl3	A,A,B 			*/
name|p
operator|->
name|op
operator|=
name|ADD
expr_stmt|;
name|strcpy
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|equstr
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|regs
index|[
name|RT3
index|]
argument_list|)
condition|)
block|{
name|p
operator|->
name|subop
operator|=
name|U
argument_list|(
name|LONG
argument_list|,
name|OP2
argument_list|)
expr_stmt|;
name|regs
index|[
name|RT3
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|p
operator|->
name|subop
operator|=
name|U
argument_list|(
name|LONG
argument_list|,
name|OP3
argument_list|)
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
goto|goto
name|std
goto|;
block|}
case|case
name|SHAR
case|:
case|case
name|SHR
case|:
block|{
comment|/* bit tests: 		**	shrl	A,B,rC     \ 		**	bitl	$1,rC>	jbc	A,B,D 		**	jeql	D	   / 		*/
specifier|register
name|struct
name|node
modifier|*
name|pf
decl_stmt|;
comment|/* forward node */
specifier|register
name|struct
name|node
modifier|*
name|pn
decl_stmt|;
comment|/* next node (after pf) */
specifier|register
name|int
name|extreg
decl_stmt|;
comment|/* reg extracted to */
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|isreg
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|std
goto|;
comment|/* alignment */
if|if
condition|(
operator|!
name|tempreg
argument_list|(
name|regs
index|[
name|RT3
index|]
argument_list|,
name|extreg
argument_list|)
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|pf
operator|=
name|p
operator|->
name|forw
operator|)
operator|->
name|op
operator|!=
name|BIT
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|uses
index|[
name|extreg
index|]
operator|&&
name|uses
index|[
name|extreg
index|]
operator|!=
name|pf
condition|)
goto|goto
name|std
goto|;
name|splitrand
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
index|[
name|RT1
index|]
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|getnum
argument_list|(
operator|&
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|extreg
operator|!=
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|pn
operator|=
name|pf
operator|->
name|forw
operator|)
operator|->
name|op
operator|!=
name|CBR
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|pn
operator|->
name|subop
operator|!=
name|JEQ
operator|&&
name|pn
operator|->
name|subop
operator|!=
name|JNE
condition|)
goto|goto
name|std
goto|;
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|delnode
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|pn
operator|->
name|subop
operator|=
operator|(
name|pn
operator|->
name|subop
operator|==
name|JEQ
operator|)
condition|?
name|JBC
else|:
name|JBS
expr_stmt|;
for|for
control|(
name|cp1
operator|=
name|p
operator|->
name|code
init|;
operator|*
name|cp1
operator|++
operator|!=
literal|','
condition|;
control|)
empty_stmt|;
while|while
condition|(
operator|*
name|cp1
operator|!=
literal|','
condition|)
name|cp1
operator|++
expr_stmt|;
operator|*
name|cp1
operator|=
literal|'\0'
expr_stmt|;
name|pn
operator|->
name|code
operator|=
name|p
operator|->
name|code
expr_stmt|;
name|pn
operator|->
name|pop
operator|=
name|NULL
expr_stmt|;
name|uses
index|[
name|extreg
index|]
operator|=
name|NULL
expr_stmt|;
name|nbj
operator|++
expr_stmt|;
name|p
operator|=
name|pn
expr_stmt|;
goto|goto
name|std
goto|;
block|}
case|case
name|AND
case|:
block|{
comment|/* unsigned conversion: 		**	cvtbl	A,B;	andl2	$255,B> movzbl	A,B 		** 		** also byte- and word-size fields: 		**	shrl	$(3-n)*8,A,B; andl2	$255,B>	movzbl	n+A,B 		**	shrl	$(1-n)*16,A,B; andl2	$65535,B>	movzwl	n+A,B 		*/
name|char
name|src
index|[
name|C2_ASIZE
index|]
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
comment|/* field length */
specifier|register
name|struct
name|node
modifier|*
name|pb
init|=
name|p
operator|->
name|back
decl_stmt|;
comment|/* backward node */
if|if
condition|(
name|p
operator|->
name|subop
operator|!=
name|U
argument_list|(
name|LONG
argument_list|,
name|OP2
argument_list|)
condition|)
goto|goto
name|std
goto|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|'$'
operator|||
operator|(
name|f
operator|=
name|getnum
argument_list|(
name|cp1
argument_list|)
operator|)
operator|!=
literal|0xff
operator|&&
name|f
operator|!=
literal|0xffff
condition|)
goto|goto
name|std
goto|;
name|f
operator|=
name|f
operator|==
literal|0xff
condition|?
literal|8
else|:
literal|16
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|op
operator|!=
name|CVT
operator|&&
name|pb
operator|->
name|op
operator|!=
name|MOVZ
operator|&&
name|pb
operator|->
name|op
operator|!=
name|SHAR
operator|&&
name|pb
operator|->
name|op
operator|!=
name|SHR
condition|)
goto|goto
name|std
goto|;
comment|/* save source of ANDL in 'src' */
name|strcpy
argument_list|(
name|src
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
name|splitrand
argument_list|(
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|equstr
argument_list|(
name|src
argument_list|,
name|lastrand
argument_list|)
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|pb
operator|->
name|op
operator|==
name|CVT
operator|||
name|pb
operator|->
name|op
operator|==
name|MOVZ
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bitsize
index|[
name|pb
operator|->
name|subop
operator|&
literal|0xF
index|]
operator|==
name|f
operator|&&
name|bitsize
index|[
name|pb
operator|->
name|subop
operator|>>
literal|4
index|]
operator|>=
name|f
operator|)
condition|)
comment|/* good CVT */
goto|goto
name|std
goto|;
name|strcpy
argument_list|(
name|src
argument_list|,
name|regs
index|[
name|RT1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|boff
decl_stmt|;
comment|/* bit offset */
if|if
condition|(
name|regs
index|[
name|RT1
index|]
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|boff
operator|=
name|getnum
argument_list|(
operator|&
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
operator|>=
literal|0
operator|||
operator|!
name|natural
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
operator|(
name|boff
operator|&
operator|(
name|f
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|std
goto|;
name|boff
operator|=
operator|(
literal|32
operator|-
name|boff
operator|-
name|f
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|boff
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|src
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|src
argument_list|,
literal|"%d%s%s"
argument_list|,
name|boff
argument_list|,
name|regs
index|[
name|RT2
index|]
index|[
literal|0
index|]
operator|==
literal|'('
condition|?
literal|""
else|:
literal|"+"
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
block|}
name|delnode
argument_list|(
name|pb
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|MOVZ
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|U
argument_list|(
operator|(
name|f
operator|==
literal|8
condition|?
name|BYTE
else|:
name|WORD
operator|)
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s,%s"
argument_list|,
name|src
argument_list|,
name|lastrand
argument_list|)
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|line
argument_list|)
expr_stmt|;
goto|goto
name|std
goto|;
block|}
case|case
name|CMP
case|:
block|{
comment|/* comparison to -63 to -1: 		**	cmpl	r0,$-1>	incl	r0 		**	jeql	... 		** 		**	cmpl	r0,$-63>	addl2	$63,r0 		**	jeql	... 		*/
specifier|register
name|int
name|num
decl_stmt|;
specifier|register
name|int
name|reg
decl_stmt|;
specifier|register
name|struct
name|node
modifier|*
name|regp
init|=
name|p
operator|->
name|back
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|CBR
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|p
operator|->
name|forw
operator|->
name|subop
operator|!=
name|JEQ
operator|&&
name|p
operator|->
name|forw
operator|->
name|subop
operator|!=
name|JNE
condition|)
goto|goto
name|std
goto|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
literal|"$-"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|std
goto|;
name|reg
operator|=
name|r
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|r
operator|<
name|NUSE
operator|&&
name|uses
index|[
name|r
index|]
operator|!=
literal|0
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|r
operator|>=
name|NUSE
operator|&&
name|regp
operator|->
name|op
operator|==
name|MOV
operator|&&
name|p
operator|->
name|subop
operator|==
name|regp
operator|->
name|subop
condition|)
block|{
if|if
condition|(
operator|*
name|regp
operator|->
name|code
operator|!=
literal|'r'
condition|)
goto|goto
name|std
goto|;
name|reg
operator|=
name|regp
operator|->
name|code
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|regp
operator|->
name|code
index|[
literal|2
index|]
argument_list|)
operator|||
name|reg
operator|>=
name|NUSE
operator|||
name|uses
index|[
name|reg
index|]
condition|)
goto|goto
name|std
goto|;
block|}
if|if
condition|(
name|r
operator|>=
name|NUSE
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|reg
operator|!=
name|r
condition|)
name|sprintf
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
literal|"r%d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|num
operator|=
name|getnum
argument_list|(
operator|&
name|regs
index|[
name|RT2
index|]
index|[
literal|2
index|]
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|num
operator|>
literal|63
condition|)
goto|goto
name|std
goto|;
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|INC
expr_stmt|;
name|regs
index|[
name|RT2
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
name|regs
index|[
name|RT1
index|]
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
name|regs
index|[
name|RT2
index|]
operator|=
name|t
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|ADD
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|U
argument_list|(
name|p
operator|->
name|subop
argument_list|,
name|OP2
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|regs
index|[
name|RT1
index|]
index|[
literal|2
index|]
init|;
name|t
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|t
condition|;
name|t
operator|++
control|)
empty_stmt|;
block|}
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|std
goto|;
block|}
case|case
name|JBR
case|:
case|case
name|JMP
case|:
name|clearuse
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator|==
name|RET
condition|)
block|{
switch|switch
condition|(
operator|(
name|p
operator|->
name|subop
operator|>>
literal|4
operator|)
operator|&
literal|0xF
condition|)
block|{
case|case
literal|2
case|:
name|uses
index|[
literal|1
index|]
operator|=
name|p
expr_stmt|;
name|regs
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
case|case
literal|1
case|:
name|uses
index|[
literal|0
index|]
operator|=
name|p
expr_stmt|;
name|regs
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|p
operator|->
name|ref
operator|==
literal|0
condition|)
goto|goto
name|std
goto|;
comment|/* jmp (r0) */
comment|/* fall through */
case|case
name|CBR
case|:
if|if
condition|(
name|p
operator|->
name|ref
operator|->
name|ref
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|r
operator|=
name|NUSE
init|;
operator|--
name|r
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|r
operator|)
operator|&
operator|(
name|int
operator|)
name|p
operator|->
name|ref
operator|->
name|ref
condition|)
block|{
name|uses
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|1
operator|<<
name|NUSE
operator|)
operator|&
operator|(
name|int
operator|)
name|p
operator|->
name|ref
operator|->
name|ref
condition|)
name|useacc
operator|=
name|p
expr_stmt|;
block|}
break|break;
case|case
name|LNF
case|:
comment|/* lnf a; addf b ==> ldf b; subf a */
block|{
specifier|register
name|struct
name|node
modifier|*
name|pf
init|=
name|p
operator|->
name|forw
decl_stmt|;
if|if
condition|(
name|pf
operator|->
name|op
operator|==
name|ADDF
operator|&&
name|p
operator|->
name|subop
operator|==
name|pf
operator|->
name|subop
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|LDF
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|pf
operator|->
name|op
operator|=
name|SUBF
expr_stmt|;
name|pf
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|cp1
operator|=
name|p
operator|->
name|code
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|pf
operator|->
name|code
expr_stmt|;
name|pf
operator|->
name|code
operator|=
name|cp1
expr_stmt|;
name|p
operator|=
name|pf
operator|->
name|forw
expr_stmt|;
break|break;
block|}
block|}
case|case
name|LDF
case|:
case|case
name|LDFD
case|:
case|case
name|CVLF
case|:
comment|/* destroy acc */
name|useacc
operator|=
literal|0
expr_stmt|;
goto|goto
name|std
goto|;
case|case
name|STF
case|:
block|{
specifier|register
name|struct
name|node
modifier|*
name|pf
decl_stmt|;
if|if
condition|(
operator|(
name|pf
operator|=
name|flops
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|p
condition|)
block|{
name|p
operator|=
name|pf
expr_stmt|;
comment|/* usually p->forw; */
break|break;
block|}
block|}
if|if
condition|(
name|ldmov
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|forw
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|useacc
operator|==
literal|0
condition|)
name|useacc
operator|=
name|p
expr_stmt|;
goto|goto
name|std
goto|;
case|case
name|ADDF
case|:
case|case
name|MULF
case|:
comment|/* commutatives - create clients for flops */
comment|/* stf a; ldf b; addf a => stf a; ldf a; addf b */
block|{
specifier|register
name|struct
name|node
modifier|*
name|pb
init|=
name|p
operator|->
name|back
decl_stmt|;
specifier|register
name|struct
name|node
modifier|*
name|pbb
init|=
name|pb
operator|->
name|back
decl_stmt|;
if|if
condition|(
name|pb
operator|->
name|op
operator|==
name|LDF
operator|&&
name|pb
operator|->
name|subop
operator|==
name|p
operator|->
name|subop
operator|&&
name|pbb
operator|&&
name|pbb
operator|->
name|op
operator|==
name|STF
operator|&&
name|pbb
operator|->
name|subop
operator|==
name|p
operator|->
name|subop
operator|&&
name|equstr
argument_list|(
name|pbb
operator|->
name|code
argument_list|,
name|p
operator|->
name|code
argument_list|)
condition|)
block|{
name|cp1
operator|=
name|p
operator|->
name|code
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|pb
operator|->
name|code
expr_stmt|;
name|pb
operator|->
name|code
operator|=
name|cp1
expr_stmt|;
block|}
block|}
comment|/* use acc and regs */
case|case
name|CMPF
case|:
case|case
name|CVFL
case|:
case|case
name|SUBF
case|:
case|case
name|DIVF
case|:
if|if
condition|(
name|useacc
operator|==
literal|0
condition|)
name|useacc
operator|=
name|p
expr_stmt|;
goto|goto
name|std
goto|;
case|case
name|TSTF
case|:
break|break;
case|case
name|PUSHD
case|:
if|if
condition|(
name|ldmov
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|forw
expr_stmt|;
break|break;
block|}
case|case
name|CVDF
case|:
case|case
name|NEGF
case|:
comment|/* use only acc */
case|case
name|SINF
case|:
case|case
name|COSF
case|:
case|case
name|ATANF
case|:
case|case
name|LOGF
case|:
case|case
name|SQRTF
case|:
case|case
name|EXPF
case|:
if|if
condition|(
name|useacc
operator|==
literal|0
condition|)
name|useacc
operator|=
name|p
expr_stmt|;
case|case
name|EROU
case|:
case|case
name|JSW
case|:
case|case
name|TEXT
case|:
case|case
name|DATA
case|:
case|case
name|BSS
case|:
case|case
name|ALIGN
case|:
case|case
name|WGEN
case|:
case|case
name|END
case|:
empty_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
operator|&
name|first
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|LABEL
operator|||
name|p
operator|->
name|op
operator|==
name|DLABEL
condition|)
name|p
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
comment|/* erase our tracks */
block|}
end_block

begin_function
name|char
modifier|*
name|byondrd
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|;
block|{
comment|/* return pointer to register which is "beyond last read/modify operand" */
if|if
condition|(
name|has2ops
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|regs
index|[
name|RT3
index|]
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|MFPR
case|:
case|case
name|PUSHA
case|:
case|case
name|TST
case|:
case|case
name|INC
case|:
case|case
name|DEC
case|:
case|case
name|PUSH
case|:
case|case
name|LDF
case|:
case|case
name|LNF
case|:
case|case
name|CVLF
case|:
case|case
name|LDFD
case|:
case|case
name|ADDF
case|:
case|case
name|SUBF
case|:
case|case
name|MULF
case|:
case|case
name|DIVF
case|:
case|case
name|CMPF
case|:
return|return
operator|(
name|regs
index|[
name|RT2
index|]
operator|)
return|;
case|case
name|MTPR
case|:
ifndef|#
directive|ifndef
name|EMOD
case|case
name|EDIV
case|:
endif|#
directive|endif
endif|EMOD
case|case
name|CBR
case|:
comment|/* must be JBC/JBS */
case|case
name|BIT
case|:
case|case
name|CMP
case|:
case|case
name|CALLS
case|:
case|case
name|CALLF
case|:
case|case
name|CMPF2
case|:
return|return
operator|(
name|regs
index|[
name|RT3
index|]
operator|)
return|;
case|case
name|EMUL
case|:
case|case
name|PROBE
case|:
case|case
name|MOVBLK
case|:
case|case
name|CASE
case|:
return|return
operator|(
name|regs
index|[
name|RT4
index|]
operator|)
return|;
block|}
return|return
operator|(
name|lastrand
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|node
modifier|*
name|bflow
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
modifier|*
modifier|*
name|preg
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|fr
decl_stmt|,
name|dblflg
init|=
literal|0
decl_stmt|;
name|int
name|flow
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|node
modifier|*
name|olduse
init|=
literal|0
decl_stmt|,
modifier|*
name|olduse1
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|subop
operator|==
name|QUAD
operator|||
name|p
operator|->
name|subop
operator|==
name|DOUBLE
operator|||
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF0
operator|)
operator|==
name|DOUBLE
operator|<<
literal|4
operator|||
name|p
operator|->
name|op
operator|==
name|EMUL
condition|)
name|dblflg
operator||=
literal|1
expr_stmt|;
comment|/* double dest */
if|if
condition|(
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator|==
name|DOUBLE
operator|||
name|p
operator|->
name|subop
operator|==
name|QUAD
condition|)
name|dblflg
operator||=
literal|2
expr_stmt|;
comment|/* double src */
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|PUSH
operator|&&
ifndef|#
directive|ifndef
name|EMOD
name|p
operator|->
name|op
operator|!=
name|EDIV
operator|&&
endif|#
directive|endif
endif|EMOD
name|p
operator|->
name|op
operator|!=
name|EMUL
operator|&&
name|p
operator|->
name|subop
operator|&&
name|tempreg
argument_list|(
name|lastrand
argument_list|,
name|r
argument_list|)
operator|&&
name|uses
index|[
name|r
index|]
operator|==
name|p
operator|->
name|forw
condition|)
block|{
if|if
condition|(
name|equtype
argument_list|(
name|p
operator|->
name|subop
argument_list|,
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
argument_list|)
operator|||
operator|(
operator|(
name|p
operator|->
name|op
operator|==
name|CVT
operator|||
name|p
operator|->
name|op
operator|==
name|MOVZ
operator|||
name|p
operator|->
name|op
operator|==
name|CVFL
operator|)
operator|&&
operator|(
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
operator|&
literal|0xf
operator|)
operator|&&
name|compat
argument_list|(
operator|(
name|p
operator|->
name|subop
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|,
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
argument_list|)
operator|)
operator|||
name|p
operator|->
name|op
operator|==
name|MOVA
operator|&&
name|compat
argument_list|(
name|LONG
argument_list|,
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
specifier|register
name|int
name|r2
decl_stmt|;
if|if
condition|(
name|regs
index|[
name|r
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* send directly to destination */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|INC
operator|||
name|p
operator|->
name|op
operator|==
name|DEC
condition|)
block|{
name|p
operator|->
name|op
operator|=
operator|(
name|p
operator|->
name|op
operator|==
name|DEC
operator|)
condition|?
name|SUB
else|:
name|ADD
expr_stmt|;
comment|/* use 2 now, convert to 3 later */
name|p
operator|->
name|subop
operator|=
operator|(
name|OP2
operator|<<
literal|4
operator|)
operator|+
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|cp1
operator|=
name|lastrand
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
comment|/* copy reg */
empty_stmt|;
name|cp1
operator|=
name|lastrand
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
literal|'$'
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
literal|'1'
expr_stmt|;
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
block|}
name|cp1
operator|=
name|regs
index|[
name|r
index|]
operator|+
literal|1
expr_stmt|;
name|cp2
operator|=
name|lastrand
expr_stmt|;
if|if
condition|(
name|has2ops
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* use 3 operand form of instruction */
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|subop
operator|+=
operator|(
name|OP3
operator|-
name|OP2
operator|)
operator|<<
literal|4
expr_stmt|;
name|lastrand
operator|=
name|cp2
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MOVA
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|==
name|PUSH
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|PUSHA
expr_stmt|;
operator|*
name|regs
index|[
name|RT2
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|->
name|op
operator|==
name|MOV
operator|||
name|p
operator|->
name|op
operator|==
name|CVT
operator|)
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|==
name|PUSH
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|PUSH
expr_stmt|;
name|p
operator|->
name|subop
operator|&=
literal|0xF
expr_stmt|;
operator|*
name|regs
index|[
name|RT2
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
name|delnode
argument_list|(
name|p
operator|->
name|forw
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempreg
argument_list|(
name|lastrand
argument_list|,
name|r2
argument_list|)
condition|)
name|uses
index|[
name|r2
index|]
operator|=
name|uses
index|[
name|r
index|]
operator|,
name|uses
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|redun3
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
name|flow
operator|=
name|r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MOV
condition|)
block|{
comment|/* superfluous fetch */
name|int
name|nmatch
decl_stmt|;
name|char
name|src
index|[
name|C2_ASIZE
index|]
decl_stmt|;
name|movit
label|:
for|for
control|(
name|cp2
operator|=
name|src
operator|,
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
init|;
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|;
control|)
empty_stmt|;
name|splitrand
argument_list|(
name|p
operator|->
name|forw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|INC
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|DEC
condition|)
name|lastrand
operator|=
name|byondrd
argument_list|(
name|p
operator|->
name|forw
argument_list|)
expr_stmt|;
name|nmatch
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|preg
operator|=
name|regs
operator|+
name|RT1
init|;
operator|*
name|preg
operator|!=
name|lastrand
condition|;
name|preg
operator|++
control|)
if|if
condition|(
name|r
operator|==
name|isreg
argument_list|(
operator|*
name|preg
argument_list|)
condition|)
block|{
name|cp2
operator|=
operator|*
name|preg
expr_stmt|;
name|cp1
operator|=
name|src
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
operator|++
name|nmatch
expr_stmt|;
block|}
if|if
condition|(
name|nmatch
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|has2ops
argument_list|(
name|p
operator|->
name|forw
argument_list|)
operator|&&
name|equstr
argument_list|(
name|src
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
condition|)
block|{
name|p
operator|->
name|forw
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|forw
operator|->
name|subop
operator|+=
operator|(
name|OP3
operator|-
name|OP2
operator|)
operator|<<
literal|4
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
literal|'r'
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
name|r
operator|+
literal|'0'
expr_stmt|;
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
block|}
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|forw
expr_stmt|;
if|if
condition|(
name|tempreg
argument_list|(
name|src
argument_list|,
name|r2
argument_list|)
condition|)
name|uses
index|[
name|r2
index|]
operator|=
name|uses
index|[
name|r
index|]
operator|,
name|uses
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|redun3
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
comment|/* avoid stale uses[] data */
block|}
else|else
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MOV
operator|&&
operator|(
name|p
operator|->
name|forw
operator|->
name|op
operator|==
name|CVT
operator|||
name|p
operator|->
name|forw
operator|->
name|op
operator|==
name|MOVZ
operator|)
operator|&&
name|p
operator|->
name|forw
operator|->
name|subop
operator|&
literal|0xf
operator|&&
comment|/* if base or index, then forget it */
name|compat
argument_list|(
name|p
operator|->
name|subop
argument_list|,
name|p
operator|->
name|forw
operator|->
name|subop
argument_list|)
operator|&&
operator|!
name|indexa
argument_list|(
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
goto|goto
name|movit
goto|;
block|}
comment|/* adjust 'lastrand' past any 'read' or 'modify' operands. */
name|lastrand
operator|=
name|byondrd
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* a 'write' clobbers the register. */
if|if
condition|(
name|tempreg
argument_list|(
name|lastrand
argument_list|,
name|r
argument_list|)
operator|||
operator|(
name|has2ops
argument_list|(
name|p
argument_list|)
operator|&&
name|tempreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|r
argument_list|)
operator|&&
name|uses
index|[
name|r
index|]
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Writing a dead register is useless, 		 * but watch side effects 		 */
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
ifndef|#
directive|ifndef
name|EMOD
case|case
name|EDIV
case|:
endif|#
directive|endif
endif|EMOD
case|case
name|AOBLEQ
case|:
case|case
name|AOBLSS
case|:
break|break;
default|default:
comment|/* 			 * If no direct uses, check for 			 * use of condition codes 			 */
if|if
condition|(
name|uses
index|[
name|r
index|]
operator|==
literal|0
operator|&&
operator|(
operator|(
name|dblflg
operator|&
literal|1
operator|)
operator|==
literal|0
operator|||
name|uses
index|[
name|r
operator|+
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
specifier|register
name|struct
name|node
modifier|*
name|q
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|q
operator|=
name|nonlab
argument_list|(
name|q
operator|->
name|forw
argument_list|)
operator|)
operator|->
name|op
operator|==
name|JBR
operator|&&
name|q
operator|->
name|subop
operator|==
literal|0
condition|)
name|q
operator|=
name|q
operator|->
name|ref
expr_stmt|;
comment|/* cc unused, unchanged */
if|if
condition|(
name|q
operator|->
name|op
operator|!=
name|CBR
operator|&&
name|q
operator|->
name|op
operator|!=
name|ADDA
operator|&&
name|q
operator|->
name|op
operator|!=
name|SUBA
condition|)
block|{
comment|/* ... and destroyed */
name|preg
operator|=
name|regs
operator|+
name|RT1
expr_stmt|;
while|while
condition|(
name|cp1
operator|=
operator|*
name|preg
operator|++
condition|)
block|{
if|if
condition|(
name|cp1
operator|==
name|lastrand
operator|&&
name|p
operator|->
name|op
operator|!=
name|CLR
operator|&&
name|p
operator|->
name|op
operator|!=
name|CVFL
condition|)
block|{
name|redunm
operator|++
expr_stmt|;
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|forw
operator|)
return|;
block|}
if|if
condition|(
name|equstr
argument_list|(
name|cp1
argument_list|,
name|lastrand
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
name|flow
operator|=
name|r
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|flow
operator|)
operator|>=
literal|0
condition|)
block|{
name|olduse
operator|=
name|uses
index|[
name|r
index|]
operator|,
name|uses
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|regs
index|[
name|r
index|]
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* if r0 destroyed, dont keep r1 */
if|if
condition|(
name|dblflg
operator|&
literal|1
condition|)
block|{
name|olduse1
operator|=
name|uses
index|[
operator|++
name|r
index|]
operator|,
name|uses
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|regs
index|[
name|r
index|]
operator|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* now look for 'read' or 'modify' (read& write) uses */
name|preg
operator|=
name|regs
operator|+
name|RT1
expr_stmt|;
while|while
condition|(
operator|*
operator|(
name|cp1
operator|=
operator|*
name|preg
operator|++
operator|)
condition|)
block|{
comment|/* check for  r  */
if|if
condition|(
name|lastrand
operator|!=
name|cp1
operator|&&
name|tempreg
argument_list|(
name|cp1
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|int
name|isunused
decl_stmt|;
if|if
condition|(
name|isunused
operator|=
operator|(
name|uses
index|[
name|r
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|uses
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|r
index|]
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
name|p
operator|->
name|subop
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|op
operator|==
name|SHAL
operator|||
name|p
operator|->
name|op
operator|==
name|SHAR
operator|||
name|p
operator|->
name|op
operator|==
name|SHL
operator|||
name|p
operator|->
name|op
operator|==
name|SHR
operator|)
operator|&&
name|cp1
operator|==
name|regs
index|[
name|RT1
index|]
condition|)
name|cp2
index|[
operator|-
literal|1
index|]
operator|=
name|BYTE
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CBR
operator|&&
operator|(
name|p
operator|->
name|subop
operator|==
name|JBC
operator|||
name|p
operator|->
name|subop
operator|==
name|JBS
operator|)
condition|)
name|cp2
index|[
operator|-
literal|1
index|]
operator|=
name|LONG
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MOVA
operator|&&
name|cp1
operator|==
name|regs
index|[
name|RT2
index|]
condition|)
name|cp2
index|[
operator|-
literal|1
index|]
operator|=
name|LONG
expr_stmt|;
block|}
comment|/* ediv/emod's 2nd operand is quad */
if|if
condition|(
operator|(
operator|(
name|p
operator|->
name|op
operator|==
name|EDIV
ifdef|#
directive|ifdef
name|EMOD
operator|||
name|p
operator|->
name|op
operator|==
name|EMOD
endif|#
directive|endif
endif|EMOD
operator|)
operator|&&
name|cp1
operator|==
name|regs
index|[
name|RT2
index|]
operator|||
operator|(
name|dblflg
operator|&
literal|2
operator|)
operator|)
operator|&&
operator|++
name|r
operator|<
name|NUSE
operator|&&
name|uses
index|[
name|r
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isunused
condition|)
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
name|uses
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|r
index|]
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
name|p
operator|->
name|subop
expr_stmt|;
if|if
condition|(
operator|!
name|isunused
condition|)
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isunused
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MOV
operator|||
name|p
operator|->
name|op
operator|==
name|PUSH
operator|||
name|p
operator|->
name|op
operator|==
name|CVT
operator|||
name|p
operator|->
name|op
operator|==
name|MOVZ
operator|||
name|p
operator|->
name|op
operator|==
name|COM
operator|||
name|p
operator|->
name|op
operator|==
name|NEG
operator|||
name|p
operator|->
name|op
operator|==
name|STF
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|PUSH
condition|)
block|{
name|cp1
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
if|if
condition|(
name|tempreg
argument_list|(
name|cp1
argument_list|,
name|r
argument_list|)
condition|)
block|{
comment|/* 						 * reincarnation!! 						 * (as in  addl2 r0,r1; 						 *  movl r1,r0;  ret) 						 */
if|if
condition|(
name|uses
index|[
name|r
index|]
operator|==
literal|0
condition|)
name|uses
index|[
name|r
index|]
operator|=
name|olduse
expr_stmt|;
if|if
condition|(
operator|(
name|dblflg
operator|&
literal|1
operator|)
operator|&&
name|uses
index|[
name|r
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
name|uses
index|[
name|r
operator|+
literal|1
index|]
operator|=
name|olduse1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|MOV
condition|)
name|cp1
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cp1
operator|=
literal|"-(sp)"
expr_stmt|;
if|if
condition|(
name|cp1
condition|)
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
else|else
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* check for (r),[r] */
do|do
block|{
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'('
operator|||
operator|*
name|cp1
operator|==
literal|'['
condition|)
block|{
comment|/* get register number */
name|char
name|t
decl_stmt|;
for|for
control|(
name|cp2
operator|=
operator|++
name|cp1
init|;
operator|*
operator|++
name|cp1
operator|!=
literal|')'
operator|&&
operator|*
name|cp1
operator|!=
literal|']'
condition|;
control|)
empty_stmt|;
name|t
operator|=
operator|*
name|cp1
expr_stmt|;
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tempreg
argument_list|(
name|cp2
argument_list|,
name|r
argument_list|)
operator|&&
operator|(
name|uses
index|[
name|r
index|]
operator|==
literal|0
operator|||
name|uses
index|[
name|r
index|]
operator|==
name|p
operator|)
condition|)
block|{
name|uses
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
operator|=
operator|(
operator|*
operator|--
name|cp2
operator|==
literal|'['
condition|?
name|OPX
operator|<<
literal|4
else|:
name|OPB
operator|<<
literal|4
operator|)
expr_stmt|;
name|regs
index|[
name|r
index|]
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|cp1
operator|=
name|t
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
operator|++
name|cp1
condition|)
do|;
block|}
ifdef|#
directive|ifdef
name|MOVAFASTER
comment|/* pushax or movax possibility? */
name|cp1
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|==
literal|'$'
operator|&&
name|isstatic
argument_list|(
name|cp1
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|MOV
operator|&&
name|p
operator|->
name|subop
operator|==
name|LONG
condition|)
block|{
if|if
condition|(
name|regs
index|[
name|RT1
index|]
index|[
literal|1
index|]
operator|==
literal|'L'
operator|&&
literal|0
operator|!=
operator|(
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|regs
index|[
name|RT1
index|]
operator|+
literal|2
argument_list|)
operator|)
condition|)
block|{
name|cp1
operator|=
name|p
operator|->
name|code
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
name|p
operator|->
name|code
operator|=
operator|--
name|cp1
expr_stmt|;
block|}
name|p
operator|->
name|op
operator|=
name|MOVA
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|BYTE
expr_stmt|;
operator|++
name|p
operator|->
name|code
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|PUSH
operator|&&
name|p
operator|->
name|subop
operator|==
name|LONG
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|PUSHA
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|BYTE
expr_stmt|;
operator|++
name|p
operator|->
name|code
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ADD
operator|&&
name|p
operator|->
name|subop
operator|==
name|U
argument_list|(
name|LONG
argument_list|,
name|OP3
argument_list|)
operator|&&
literal|0
operator|<=
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
operator|)
condition|)
block|{
name|cp1
operator|=
name|cp2
operator|=
name|p
operator|->
name|code
expr_stmt|;
operator|++
name|cp1
expr_stmt|;
do|do
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
expr_stmt|;
do|while
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|','
condition|)
do|;
name|cp2
index|[
operator|-
literal|1
index|]
operator|=
literal|'['
expr_stmt|;
do|do
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
expr_stmt|;
do|while
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|','
condition|)
do|;
name|cp2
index|[
operator|-
literal|1
index|]
operator|=
literal|']'
expr_stmt|;
if|if
condition|(
operator|!
name|equstr
argument_list|(
name|regs
index|[
name|RT3
index|]
argument_list|,
literal|"-(sp)"
argument_list|)
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|MOVA
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|BYTE
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|PUSHA
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|BYTE
expr_stmt|;
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|uses
index|[
name|r
index|]
operator|==
literal|0
condition|)
block|{
name|uses
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
operator|=
name|OPX
operator|<<
literal|4
expr_stmt|;
block|}
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|MOVAFASTER
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* try to eliminate STF's */
end_comment

begin_function
name|struct
name|node
modifier|*
name|flops
parameter_list|(
name|q
parameter_list|)
specifier|register
name|struct
name|node
modifier|*
name|q
decl_stmt|;
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|op
operator|!=
name|STF
operator|||
operator|!
name|tempreg
argument_list|(
name|q
operator|->
name|code
argument_list|,
name|r
argument_list|)
condition|)
return|return
operator|(
name|q
operator|)
return|;
if|if
condition|(
name|uses
index|[
name|r
index|]
condition|)
block|{
comment|/* see if anyone destroys acc between us */
for|for
control|(
name|p
operator|=
name|q
operator|->
name|forw
init|;
name|p
operator|!=
name|uses
index|[
name|r
index|]
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|LABEL
case|:
case|case
name|LDF
case|:
case|case
name|LNF
case|:
case|case
name|CVLF
case|:
case|case
name|LDFD
case|:
case|case
name|CVDF
case|:
case|case
name|NEGF
case|:
case|case
name|ADDF
case|:
case|case
name|SUBF
case|:
case|case
name|MULF
case|:
case|case
name|DIVF
case|:
case|case
name|SINF
case|:
case|case
name|COSF
case|:
case|case
name|ATANF
case|:
case|case
name|LOGF
case|:
case|case
name|SQRTF
case|:
case|case
name|EXPF
case|:
return|return
operator|(
name|q
operator|)
return|;
block|}
name|again
label|:
if|if
condition|(
name|q
operator|->
name|subop
operator|==
name|p
operator|->
name|subop
condition|)
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
comment|/* do it in the accumulator */
case|case
name|LDF
case|:
comment|/* redundant load */
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nld
operator|++
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|forw
expr_stmt|;
break|break;
case|case
name|LNF
case|:
comment|/* stf r; lnf r ==> negf */
name|p
operator|->
name|op
operator|=
name|NEGF
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CMPF2
case|:
comment|/* stf r; cmpf2 r,x ==> cmpf x */
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|node
modifier|*
name|p1
init|=
name|p
operator|->
name|forw
decl_stmt|;
for|for
control|(
name|s
operator|=
name|p
operator|->
name|code
init|;
operator|*
name|s
operator|!=
literal|','
condition|;
name|s
operator|++
control|)
empty_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isreg
argument_list|(
name|p
operator|->
name|code
argument_list|)
operator|==
name|r
condition|)
name|p
operator|->
name|code
operator|=
name|s
operator|+
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p1
operator|->
name|op
operator|!=
name|CBR
operator|||
name|isreg
argument_list|(
name|s
operator|+
literal|1
argument_list|)
operator|!=
name|r
condition|)
block|{
operator|*
name|s
operator|=
literal|','
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
if|if
condition|(
name|p1
operator|->
name|subop
operator|>
name|JNE
condition|)
block|{
name|p1
operator|->
name|subop
operator|^=
literal|1
expr_stmt|;
name|p1
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|nrevbr
operator|++
expr_stmt|;
block|}
block|}
name|p
operator|->
name|op
operator|=
name|CMPF
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|(
name|q
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|subop
operator|==
name|LONG
condition|)
block|{
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|TST
case|:
comment|/* stf r; tstl r ==> tstf */
name|p
operator|->
name|op
operator|=
name|TSTF
expr_stmt|;
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* send directly to destination */
case|case
name|MOV
case|:
comment|/* stf r; movl r,x ==> stf x */
case|case
name|PUSH
case|:
comment|/* stf r; pushl r ==> stf -(sp)/pushd */
if|if
condition|(
name|q
operator|->
name|subop
operator|==
name|DOUBLE
condition|)
block|{
specifier|register
name|struct
name|node
modifier|*
name|b
init|=
name|p
operator|->
name|back
decl_stmt|;
comment|/* assume b's 2nd arg is ok */
if|if
condition|(
operator|!
operator|(
name|b
operator|==
name|uses
index|[
name|r
operator|+
literal|1
index|]
operator|&&
name|b
operator|->
name|op
operator|==
name|p
operator|->
name|op
operator|&&
name|b
operator|->
name|subop
operator|==
name|LONG
operator|)
condition|)
return|return
operator|(
name|q
operator|)
return|;
name|delnode
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|PUSH
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|subop
operator|==
name|DOUBLE
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|PUSHD
expr_stmt|;
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|q
operator|->
name|op
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
literal|"-(sp)"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|q
operator|->
name|op
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|->
name|code
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
block|}
break|break;
default|default:
return|return
operator|(
name|q
operator|)
return|;
block|}
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|q
operator|->
name|subop
expr_stmt|;
block|}
else|else
return|return
operator|(
name|q
operator|)
return|;
name|uses
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|subop
operator|==
name|DOUBLE
condition|)
name|uses
index|[
name|r
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|p
operator|->
name|back
init|;
name|p
operator|!=
name|q
operator|&&
operator|(
operator|!
name|uses
index|[
name|r
index|]
operator|||
operator|!
name|uses
index|[
name|r
operator|+
literal|1
index|]
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|back
control|)
block|{
name|int
name|xr
decl_stmt|;
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xr
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|uses
index|[
name|r
index|]
operator|&&
name|xr
operator|==
name|r
condition|)
name|uses
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|subop
operator|==
name|DOUBLE
operator|&&
operator|!
name|uses
index|[
name|r
operator|+
literal|1
index|]
operator|&&
name|xr
operator|==
name|r
operator|+
literal|1
condition|)
name|uses
index|[
name|r
operator|+
literal|1
index|]
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|=
name|uses
index|[
name|r
index|]
condition|)
goto|goto
name|again
goto|;
return|return
operator|(
name|q
operator|->
name|forw
operator|)
return|;
comment|/* DON'T re-scan code with dated uses[] */
block|}
comment|/* it's a store to reg which isnt used elsewhere */
if|if
condition|(
operator|(
name|p
operator|=
name|q
operator|->
name|forw
operator|)
operator|->
name|op
operator|==
name|CBR
condition|)
block|{
name|q
operator|->
name|op
operator|=
name|TSTF
expr_stmt|;
name|q
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|code
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|delnode
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|nst
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STF
operator|||
name|p
operator|->
name|op
operator|==
name|TSTF
operator|||
name|p
operator|->
name|op
operator|==
name|PUSHD
condition|)
block|{
if|if
condition|(
name|useacc
operator|==
name|p
condition|)
name|useacc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|forw
operator|)
return|;
comment|/* so ldmov can be used on p */
block|}
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* try to change load/store sequences to movl */
end_comment

begin_expr_stmt
name|ldmov
argument_list|(
name|q
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|pcod
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|dlsw
parameter_list|()
function_decl|;
name|p
operator|=
name|q
operator|->
name|back
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|useacc
operator|==
literal|0
operator|&&
operator|(
name|q
operator|->
name|op
operator|==
name|STF
operator|||
name|q
operator|->
name|op
operator|==
name|TSTF
operator|||
name|q
operator|->
name|op
operator|==
name|PUSHD
operator|)
operator|&&
operator|(
operator|(
name|p
operator|->
name|op
operator|==
name|LDF
operator|&&
name|p
operator|->
name|subop
operator|==
name|q
operator|->
name|subop
operator|)
operator|||
operator|(
name|p
operator|->
name|op
operator|==
name|LDFD
operator|&&
name|q
operator|->
name|subop
operator|==
name|DOUBLE
operator|)
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pcod
operator|=
name|p
operator|->
name|code
expr_stmt|;
name|cp
operator|=
name|p
operator|->
name|code
expr_stmt|;
comment|/* prepare args for movl/pushl */
if|if
condition|(
name|q
operator|->
name|op
operator|!=
name|TSTF
operator|&&
name|q
operator|->
name|subop
operator|==
name|DOUBLE
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|LDF
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|dlsw
argument_list|(
name|p
operator|->
name|code
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|op
operator|==
name|STF
condition|)
block|{
name|strcat
argument_list|(
name|line
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|dlsw
argument_list|(
name|q
operator|->
name|code
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|strcat
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|MOV
expr_stmt|;
block|}
else|else
name|p
operator|->
name|op
operator|=
name|PUSH
expr_stmt|;
block|}
else|else
block|{
comment|/* LDFD */
if|if
condition|(
name|q
operator|->
name|op
operator|==
name|STF
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|dlsw
argument_list|(
name|q
operator|->
name|code
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|s
operator|=
literal|"-(sp)"
expr_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|CLR
expr_stmt|;
block|}
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|LONG
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|op
operator|==
name|LDF
operator|)
operator|&&
operator|(
name|p
operator|->
name|subop
operator|==
name|DOUBLE
operator|)
operator|&&
operator|(
name|indexa
argument_list|(
name|cp
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|pcod
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|op
operator|==
name|STF
condition|)
block|{
comment|/* ldf x; stf y ==> movl x,y */
name|strcat
argument_list|(
name|line
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|line
argument_list|,
name|q
operator|->
name|code
argument_list|)
expr_stmt|;
name|q
operator|->
name|op
operator|=
name|MOV
expr_stmt|;
name|nst
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|op
operator|==
name|TSTF
condition|)
comment|/* ldf x; tstf ==> tstl x */
name|q
operator|->
name|op
operator|=
name|TST
expr_stmt|;
else|else
comment|/* ldd x; pushd ==> pushl x+4; pushl x */
name|q
operator|->
name|op
operator|=
name|PUSH
expr_stmt|;
name|q
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|subop
operator|=
name|LONG
expr_stmt|;
name|q
operator|->
name|code
operator|=
name|copy
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|nld
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* reconstruct the address of l.s.w. of a double operand */
end_comment

begin_function
name|char
modifier|*
name|dlsw
parameter_list|(
name|d
parameter_list|)
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|c
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
specifier|static
name|char
name|lsw
index|[
name|C2_ASIZE
index|]
decl_stmt|;
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|d
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|strncmp
argument_list|(
name|d
argument_list|,
literal|"(r"
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
literal|0
operator|)
operator|&&
name|isdigit
argument_list|(
name|d
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|t
operator|=
name|lsw
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|d
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"r%d"
argument_list|,
name|r
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|s
operator|=
name|d
init|;
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'('
condition|;
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'['
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|s
operator|!=
name|d
condition|)
operator|*
name|t
operator|++
operator|=
literal|'+'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'4'
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'['
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|lsw
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|checkexpr
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'-'
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

