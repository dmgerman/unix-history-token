begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)local.c	1.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"mfile1"
end_include

begin_comment
comment|/*	this file contains code which is dependent on the target machine */
end_comment

begin_function
name|NODE
modifier|*
name|cast
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
name|TWORD
name|t
decl_stmt|;
block|{
comment|/* cast node p to type t */
name|p
operator|=
name|buildtree
argument_list|(
name|CAST
argument_list|,
name|block
argument_list|(
name|NAME
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|right
operator|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|clocal
parameter_list|(
name|p
parameter_list|)
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* this is called to do local transformations on 	   an expression tree preparitory to its being 	   written out in intermediate code. 	*/
comment|/* the major essential job is rewriting the 	   automatic variables and arguments in terms of 	   REG and OREG nodes */
comment|/* conversion ops which are not necessary are also clobbered here */
comment|/* in addition, any special features (such as rewriting 	   exclusive or) are easily handled here as well */
specifier|register
name|struct
name|symtab
modifier|*
name|q
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|;
specifier|register
name|o
expr_stmt|;
specifier|register
name|m
operator|,
name|ml
expr_stmt|;
switch|switch
condition|(
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|NAME
case|:
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|<
literal|0
condition|)
block|{
comment|/* already processed; ignore... */
return|return
operator|(
name|p
operator|)
return|;
block|}
name|q
operator|=
operator|&
name|stab
index|[
name|p
operator|->
name|tn
operator|.
name|rval
index|]
expr_stmt|;
switch|switch
condition|(
name|q
operator|->
name|sclass
condition|)
block|{
case|case
name|AUTO
case|:
case|case
name|PARAM
case|:
comment|/* fake up a structure reference */
name|r
operator|=
name|block
argument_list|(
name|REG
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|PTR
operator|+
name|STRTY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|rval
operator|=
operator|(
name|q
operator|->
name|sclass
operator|==
name|AUTO
condition|?
name|STKREG
else|:
name|ARGREG
operator|)
expr_stmt|;
name|p
operator|=
name|stref
argument_list|(
name|block
argument_list|(
name|STREF
argument_list|,
name|r
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ULABEL
case|:
case|case
name|LABEL
case|:
case|case
name|STATIC
case|:
if|if
condition|(
name|q
operator|->
name|slevel
operator|==
literal|0
condition|)
break|break;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
operator|-
name|q
operator|->
name|offset
expr_stmt|;
break|break;
case|case
name|REGISTER
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|REG
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|q
operator|->
name|offset
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PCONV
case|:
comment|/* do pointer conversions for char and longs */
name|ml
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|ml
operator|==
name|CHAR
operator|||
name|ml
operator|==
name|UCHAR
operator|||
name|ml
operator|==
name|SHORT
operator|||
name|ml
operator|==
name|USHORT
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|!=
name|ICON
condition|)
break|break;
comment|/* pointers all have the same representation; the type is inherited */
name|inherit
label|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|fn
operator|.
name|cdim
operator|=
name|p
operator|->
name|fn
operator|.
name|cdim
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|fn
operator|.
name|csiz
operator|=
name|p
operator|->
name|fn
operator|.
name|csiz
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|)
return|;
case|case
name|SCONV
case|:
name|m
operator|=
operator|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|)
expr_stmt|;
name|ml
operator|=
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|ml
condition|)
break|break;
comment|/* now, look for conversions downwards */
name|m
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|ml
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
block|{
comment|/* simulate the conversion here */
name|CONSZ
name|val
decl_stmt|;
name|val
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
switch|switch
condition|(
name|m
condition|)
block|{
case|case
name|CHAR
case|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
break|break;
case|case
name|UCHAR
case|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
operator|=
name|val
operator|&
literal|0XFF
expr_stmt|;
break|break;
case|case
name|USHORT
case|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
operator|=
name|val
operator|&
literal|0XFFFFL
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
operator|=
operator|(
name|short
operator|)
name|val
expr_stmt|;
break|break;
case|case
name|UNSIGNED
case|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
operator|=
name|val
operator|&
literal|0xFFFFFFFFL
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
comment|/* meaningful ones are conversion of int to char, int to short, 			   and short to char, and unsigned version of them */
if|if
condition|(
name|m
operator|==
name|CHAR
operator|||
name|m
operator|==
name|UCHAR
condition|)
block|{
if|if
condition|(
name|ml
operator|!=
name|CHAR
operator|&&
name|ml
operator|!=
name|UCHAR
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|SHORT
operator|||
name|m
operator|==
name|USHORT
condition|)
block|{
if|if
condition|(
name|ml
operator|!=
name|CHAR
operator|&&
name|ml
operator|!=
name|UCHAR
operator|&&
name|ml
operator|!=
name|SHORT
operator|&&
name|ml
operator|!=
name|USHORT
condition|)
break|break;
block|}
block|}
comment|/* clobber conversion */
if|if
condition|(
name|tlen
argument_list|(
name|p
argument_list|)
operator|==
name|tlen
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
condition|)
goto|goto
name|inherit
goto|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|)
return|;
comment|/* conversion gets clobbered */
case|case
name|PVCONV
case|:
case|case
name|PMCONV
case|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|!=
name|ICON
condition|)
name|cerror
argument_list|(
literal|"bad conversion"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|buildtree
argument_list|(
name|o
operator|==
name|PMCONV
condition|?
name|MUL
else|:
name|DIV
argument_list|,
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
name|RS
case|:
case|case
name|ASG
name|RS
case|:
comment|/* convert>> to<< with negative shift count */
comment|/* only if type of left operand is not unsigned */
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
break|break;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|buildtree
argument_list|(
argument|UNARY MINUS
argument_list|,
argument|p->in.right
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|RS
condition|)
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|LS
expr_stmt|;
else|else
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ASG
name|LS
expr_stmt|;
break|break;
case|case
name|FLD
case|:
comment|/* make sure that the second pass does not make the 		   descendant of a FLD operator into a doubly indexed OREG */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
operator|&&
operator|(
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
operator|)
operator|->
name|in
operator|.
name|op
operator|==
name|PCONV
condition|)
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|PLUS
operator|||
name|r
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|MINUS
condition|)
if|if
condition|(
name|ISPTR
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|=
name|UCHAR
expr_stmt|;
else|else
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|=
name|CHAR
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|andable
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* all names can have& taken on them */
block|}
end_block

begin_macro
name|cendarg
argument_list|()
end_macro

begin_block
block|{
comment|/* at the end of the arguments of a ftn, set the automatic offset */
name|autooff
operator|=
name|AUTOINIT
expr_stmt|;
block|}
end_block

begin_macro
name|cisreg
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* is an automatic variable of type t OK for a register variable */
ifdef|#
directive|ifdef
name|TRUST_REG_CHAR_AND_REG_SHORT
if|if
condition|(
name|t
operator|==
name|INT
operator|||
name|t
operator|==
name|UNSIGNED
operator|||
name|t
operator|==
name|LONG
operator|||
name|t
operator|==
name|ULONG
comment|/* tbl */
operator|||
name|t
operator|==
name|CHAR
operator|||
name|t
operator|==
name|UCHAR
operator|||
name|t
operator|==
name|SHORT
comment|/* tbl */
operator|||
name|t
operator|==
name|USHORT
operator|||
name|ISPTR
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* tbl */
else|#
directive|else
if|if
condition|(
name|t
operator|==
name|INT
operator|||
name|t
operator|==
name|UNSIGNED
operator|||
name|t
operator|==
name|LONG
operator|||
name|t
operator|==
name|ULONG
comment|/* wnj */
operator|||
name|ISPTR
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* wnj */
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|NODE
modifier|*
name|offcon
parameter_list|(
name|off
parameter_list|,
name|t
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
name|OFFSZ
name|off
decl_stmt|;
name|TWORD
name|t
decl_stmt|;
block|{
comment|/* return a node, for structure references, which is suitable for 	   being added to a pointer of type t, in order to be off bits offset 	   into a structure */
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
comment|/* t, d, and s are the type, dimension offset, and sizeoffset */
comment|/* in general they  are necessary for offcon, but not on H'well */
name|p
operator|=
name|bcon
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|off
operator|/
name|SZCHAR
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|inwd
comment|/* current bit offsed in word */
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|word
comment|/* word being built from fields */
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|incode
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* generate initialization code for assigning a constant c 		to a field of width sz */
comment|/* we assume that the proper alignment has been obtained */
comment|/* inoff is updated to have the proper final value */
comment|/* we also assume sz< SZINT */
if|if
condition|(
operator|(
name|sz
operator|+
name|inwd
operator|)
operator|>
name|SZINT
condition|)
name|cerror
argument_list|(
literal|"incode: field> int"
argument_list|)
expr_stmt|;
name|word
operator||=
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|<<
operator|(
literal|32
operator|-
name|sz
operator|)
argument_list|)
operator|)
operator|>>
operator|(
literal|32
operator|-
name|sz
operator|-
name|inwd
operator|)
expr_stmt|;
name|inwd
operator|+=
name|sz
expr_stmt|;
name|inoff
operator|+=
name|sz
expr_stmt|;
if|if
condition|(
name|inoff
operator|%
name|SZINT
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"	.long	0x%x\n"
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|word
operator|=
name|inwd
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|fincode
argument_list|(
argument|d
argument_list|,
argument|sz
argument_list|)
end_macro

begin_decl_stmt
name|double
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* output code to initialize space of size sz to the value d */
comment|/* the proper alignment has been obtained */
comment|/* inoff is updated to have the proper final value */
comment|/* on the target machine, write it out in octal! */
name|printf
argument_list|(
literal|"	%s	0%c%.20e\n"
argument_list|,
name|sz
operator|==
name|SZDOUBLE
condition|?
literal|".double"
else|:
literal|".float"
argument_list|,
name|sz
operator|==
name|SZDOUBLE
condition|?
literal|'d'
else|:
literal|'f'
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|inoff
operator|+=
name|sz
expr_stmt|;
block|}
end_block

begin_macro
name|cinit
argument_list|(
argument|p
argument_list|,
argument|sz
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* arrange for the initialization of p into a space of 	size sz */
comment|/* the proper alignment has been opbtained */
comment|/* inoff is updated to have the proper final value */
name|ecode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|inoff
operator|+=
name|sz
expr_stmt|;
block|}
end_block

begin_macro
name|vfdzero
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* define n bits of zeros in a vfd */
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return;
name|inwd
operator|+=
name|n
expr_stmt|;
name|inoff
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|inoff
operator|%
name|ALINT
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"	.long	0x%x\n"
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|word
operator|=
name|inwd
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|exname
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
comment|/* make a name look like an external name in the local machine */
ifndef|#
directive|ifndef
name|FLEXNAMES
specifier|static
name|char
name|text
index|[
name|NCHNAM
operator|+
literal|1
index|]
decl_stmt|;
else|#
directive|else
specifier|static
name|char
name|text
index|[
name|BUFSIZ
operator|+
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
specifier|register
name|i
expr_stmt|;
name|text
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|*
name|p
operator|&&
name|i
operator|<
name|NCHNAM
condition|;
operator|++
name|i
control|)
block|{
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|*
name|p
condition|;
operator|++
name|i
control|)
block|{
endif|#
directive|endif
name|text
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
name|text
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|text
index|[
name|NCHNAM
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* truncate */
endif|#
directive|endif
return|return
operator|(
name|text
operator|)
return|;
block|}
name|ctype
argument_list|(
argument|type
argument_list|)
block|{
comment|/* map types which are not defined on the local machine */
switch|switch
condition|(
name|BTYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|LONG
case|:
name|MODTYPE
argument_list|(
name|type
argument_list|,
name|INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|ULONG
case|:
name|MODTYPE
argument_list|(
name|type
argument_list|,
name|UNSIGNED
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
name|noinit
argument_list|(
argument|t
argument_list|)
block|{
comment|/* curid is a variable which is defined but 	is not initialized (and not a function ); 	This routine returns the stroage class for an uninitialized declaration */
return|return
operator|(
name|EXTERN
operator|)
return|;
block|}
name|commdec
argument_list|(
argument|id
argument_list|)
block|{
comment|/* make a common declaration for id, if reasonable */
specifier|register
name|struct
name|symtab
modifier|*
name|q
decl_stmt|;
name|OFFSZ
name|off
decl_stmt|,
name|tsize
argument_list|()
decl_stmt|;
name|q
operator|=
operator|&
name|stab
index|[
name|id
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"	.comm	%s,"
argument_list|,
name|exname
argument_list|(
name|q
operator|->
name|sname
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|=
name|tsize
argument_list|(
name|q
operator|->
name|stype
argument_list|,
name|q
operator|->
name|dimoff
argument_list|,
name|q
operator|->
name|sizoff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|off
operator|/
name|SZCHAR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|isitlong
argument_list|(
argument|cb
argument_list|,
argument|ce
argument_list|)
block|{
comment|/* is lastcon to be long or short */
comment|/* cb is the first character of the representation, ce the last */
if|if
condition|(
name|ce
operator|==
literal|'l'
operator|||
name|ce
operator|==
literal|'L'
operator|||
name|lastcon
operator|>=
operator|(
literal|1L
operator|<<
operator|(
name|SZINT
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|isitfloat
argument_list|(
argument|s
argument_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|double
name|atof
parameter_list|()
function_decl|;
name|dcon
operator|=
name|atof
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|FCON
operator|)
return|;
block|}
name|ecode
argument_list|(
argument|p
argument_list|)
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* walk the tree and write out the nodes.. */
if|if
condition|(
name|nerrors
condition|)
return|return;
name|p2tree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p2compile
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
include|#
directive|include
file|<sys/types.h>
include|#
directive|include
file|<a.out.h>
include|#
directive|include
file|<stab.h>
specifier|extern
name|int
name|ddebug
decl_stmt|;
specifier|extern
name|int
name|gdebug
decl_stmt|;
name|fixarg
argument_list|(
argument|p
argument_list|)
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
block|{
name|pstab
argument_list|(
name|p
operator|->
name|sname
argument_list|,
name|N_PSYM
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdebug
condition|)
name|printf
argument_list|(
literal|"0,%d,%d\n"
argument_list|,
name|p
operator|->
name|stype
argument_list|,
name|argoff
operator|/
name|SZCHAR
argument_list|)
expr_stmt|;
name|poffs
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|int
name|stabLCSYM
decl_stmt|;
name|outstab
argument_list|(
argument|p
argument_list|)
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|TWORD
name|ptype
decl_stmt|;
specifier|register
name|char
modifier|*
name|pname
decl_stmt|;
specifier|register
name|char
name|pclass
decl_stmt|;
specifier|register
name|int
name|poffset
decl_stmt|;
if|if
condition|(
operator|!
name|gdebug
condition|)
return|return;
name|ptype
operator|=
name|p
operator|->
name|stype
expr_stmt|;
name|pname
operator|=
name|p
operator|->
name|sname
expr_stmt|;
name|pclass
operator|=
name|p
operator|->
name|sclass
expr_stmt|;
name|poffset
operator|=
name|p
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|ISFTN
argument_list|(
name|ptype
argument_list|)
condition|)
block|{
return|return;
block|}
switch|switch
condition|(
name|pclass
condition|)
block|{
case|case
name|AUTO
case|:
name|pstab
argument_list|(
name|pname
argument_list|,
name|N_LSYM
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0,%d,%d\n"
argument_list|,
name|ptype
argument_list|,
operator|(
operator|-
name|poffset
operator|)
operator|/
name|SZCHAR
argument_list|)
expr_stmt|;
name|poffs
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|EXTDEF
case|:
case|case
name|EXTERN
case|:
name|pstab
argument_list|(
name|pname
argument_list|,
name|N_GSYM
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0,%d,0\n"
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|poffs
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|STATIC
case|:
ifdef|#
directive|ifdef
name|LCOMM
comment|/* stabLCSYM is 1 during nidcl so we can get stab type right */
name|pstab
argument_list|(
name|pname
argument_list|,
name|stabLCSYM
condition|?
name|N_LCSYM
else|:
name|N_STSYM
argument_list|)
expr_stmt|;
else|#
directive|else
name|pstab
argument_list|(
name|pname
argument_list|,
name|N_STSYM
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|slevel
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"0,%d,L%d\n"
argument_list|,
name|ptype
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"0,%d,%s\n"
argument_list|,
name|ptype
argument_list|,
name|exname
argument_list|(
name|pname
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|poffs
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|REGISTER
case|:
name|pstab
argument_list|(
name|pname
argument_list|,
name|N_RSYM
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0,%d,%d\n"
argument_list|,
name|ptype
argument_list|,
name|poffset
argument_list|)
expr_stmt|;
name|poffs
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|MOS
case|:
case|case
name|MOU
case|:
name|pstab
argument_list|(
name|pname
argument_list|,
name|N_SSYM
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0,%d,%d\n"
argument_list|,
name|ptype
argument_list|,
name|poffset
operator|/
name|SZCHAR
argument_list|)
expr_stmt|;
name|poffs
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|PARAM
case|:
comment|/* parameter stab entries are processed in dclargs() */
return|return;
default|default:
ifndef|#
directive|ifndef
name|FLEXNAMES
if|if
condition|(
name|ddebug
condition|)
name|printf
argument_list|(
literal|"	No .stab for %.8s\n"
argument_list|,
name|pname
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ddebug
condition|)
name|printf
argument_list|(
literal|"	No .stab for %s\n"
argument_list|,
name|pname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|pstab
argument_list|(
argument|name
argument_list|,
argument|type
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|gdebug
condition|)
return|return;
comment|/* locctr(PROG);  /* .stabs must appear in .text for c2 */
ifdef|#
directive|ifdef
name|ASSTRINGS
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"\t.stabn\t"
argument_list|)
expr_stmt|;
else|else
ifndef|#
directive|ifndef
name|FLEXNAMES
name|printf
argument_list|(
literal|"\t.stabs\t\"%.8s\", "
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"\t.stabs\t\"%s\", "
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|printf
argument_list|(
literal|"	.stab	"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|c
operator|=
name|name
index|[
name|i
index|]
condition|)
name|printf
argument_list|(
literal|"'%c,"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0,"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"0%o,"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STABDOT
name|pstabdot
argument_list|(
argument|type
argument_list|,
argument|value
argument_list|)
name|int
name|type
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|gdebug
condition|)
return|return;
comment|/* locctr(PROG);  /* .stabs must appear in .text for c2 */
name|printf
argument_list|(
literal|"\t.stabd\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0%o,0,0%o\n"
argument_list|,
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|poffs
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|symtab
operator|*
name|p
expr_stmt|;
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|gdebug
condition|)
return|return;
if|if
condition|(
operator|(
name|s
operator|=
name|dimtab
index|[
name|p
operator|->
name|sizoff
index|]
operator|/
name|SZCHAR
operator|)
operator|>
literal|1
condition|)
block|{
name|pstab
argument_list|(
name|p
operator|->
name|sname
argument_list|,
name|N_LENG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"1,0,%d\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
specifier|extern
name|char
name|NULLNAME
index|[
literal|8
index|]
decl_stmt|;
specifier|extern
name|int
name|labelno
decl_stmt|;
specifier|extern
name|int
name|fdefflag
decl_stmt|;
name|psline
argument_list|()
block|{
specifier|static
name|int
name|lastlineno
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|gdebug
condition|)
return|return;
name|cq
operator|=
name|ititle
expr_stmt|;
name|cp
operator|=
name|ftitle
expr_stmt|;
while|while
condition|(
operator|*
name|cq
condition|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
operator|*
name|cq
operator|++
condition|)
goto|goto
name|neq
goto|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
goto|goto
name|eq
goto|;
name|neq
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
name|ititle
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|ftitle
expr_stmt|;
name|cq
operator|=
name|ititle
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
operator|*
name|cq
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|cq
operator|=
literal|'\0'
expr_stmt|;
operator|*
operator|--
name|cq
operator|=
literal|'\0'
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
for|for
control|(
name|cp
operator|=
name|ititle
operator|+
literal|1
init|;
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
condition|;
name|cp
operator|+=
literal|8
control|)
block|{
name|pstab
argument_list|(
name|cp
argument_list|,
name|N_SOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdebug
condition|)
name|printf
argument_list|(
literal|"0,0,LL%d\n"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|pstab
argument_list|(
name|ititle
operator|+
literal|1
argument_list|,
name|N_SOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdebug
condition|)
name|printf
argument_list|(
literal|"0,0,LL%d\n"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|cq
operator|=
literal|'"'
expr_stmt|;
name|printf
argument_list|(
literal|"LL%d:\n"
argument_list|,
name|labelno
operator|++
argument_list|)
expr_stmt|;
name|eq
label|:
if|if
condition|(
name|lineno
operator|==
name|lastlineno
condition|)
return|return;
name|lastlineno
operator|=
name|lineno
expr_stmt|;
if|if
condition|(
name|fdefflag
condition|)
block|{
ifdef|#
directive|ifdef
name|STABDOT
name|pstabdot
argument_list|(
name|N_SLINE
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|#
directive|else
name|pstab
argument_list|(
name|NULLNAME
argument_list|,
name|N_SLINE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0,%d,LL%d\n"
argument_list|,
name|lineno
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LL%d:\n"
argument_list|,
name|labelno
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|plcstab
argument_list|(
argument|level
argument_list|)
block|{
if|if
condition|(
operator|!
name|gdebug
condition|)
return|return;
ifdef|#
directive|ifdef
name|STABDOT
name|pstabdot
argument_list|(
name|N_LBRAC
argument_list|,
name|level
argument_list|)
expr_stmt|;
else|#
directive|else
name|pstab
argument_list|(
name|NULLNAME
argument_list|,
name|N_LBRAC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0,%d,LL%d\n"
argument_list|,
name|level
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LL%d:\n"
argument_list|,
name|labelno
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|prcstab
argument_list|(
argument|level
argument_list|)
block|{
if|if
condition|(
operator|!
name|gdebug
condition|)
return|return;
ifdef|#
directive|ifdef
name|STABDOT
name|pstabdot
argument_list|(
name|N_RBRAC
argument_list|,
name|level
argument_list|)
expr_stmt|;
else|#
directive|else
name|pstab
argument_list|(
name|NULLNAME
argument_list|,
name|N_RBRAC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0,%d,LL%d\n"
argument_list|,
name|level
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LL%d:\n"
argument_list|,
name|labelno
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|pfstab
argument_list|(
argument|sname
argument_list|)
name|char
modifier|*
name|sname
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|gdebug
condition|)
return|return;
name|pstab
argument_list|(
name|sname
argument_list|,
name|N_FUN
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|printf
argument_list|(
literal|"0,%d,_%.7s\n"
argument_list|,
name|lineno
argument_list|,
name|sname
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"0,%d,_%s\n"
argument_list|,
name|lineno
argument_list|,
name|sname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|ONEPASS
name|tlen
argument_list|(
argument|p
argument_list|)
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
name|DOUBLE
case|:
return|return
operator|(
literal|8
operator|)
return|;
default|default:
return|return
operator|(
literal|4
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

