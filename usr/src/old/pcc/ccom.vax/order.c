begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)order.c	1.18 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"pass2.h"
end_include

begin_decl_stmt
name|int
name|maxargs
init|=
block|{
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|stoasg
argument_list|(
argument|p
argument_list|,
argument|o
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* should the assignment op p be stored, 	   given that it lies as the right operand of o 	   (or the left, if o==UNARY MUL) */
block|}
end_block

begin_expr_stmt
name|deltest
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* should we delay the INCR or DECR operation p */
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|NAME
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
operator|)
return|;
block|}
end_block

begin_macro
name|autoincr
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|q
init|=
name|p
operator|->
name|in
operator|.
name|left
decl_stmt|;
specifier|register
name|TWORD
name|t
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|in
operator|.
name|op
operator|!=
name|INCR
operator|||
name|q
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|!=
name|REG
operator|||
operator|!
name|ISPTR
argument_list|(
name|q
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|t
operator|=
name|q
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|DECREF
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
argument_list|(
name|p
argument_list|)
operator|!=
name|tlen
argument_list|(
name|q
argument_list|)
condition|)
block|{
comment|/* side effects okay? */
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|t
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|tlen
argument_list|(
name|p
argument_list|)
operator|!=
name|q
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|mkadrs
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|o
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|su
operator|>=
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|su
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|SETSTO
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|FLD
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|SETSTO
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* should be only structure assignment */
name|SETSTO
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|SETSTO
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|su
operator|>
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|su
condition|)
block|{
name|SETSTO
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SETSTO
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|notoff
argument_list|(
argument|t
argument_list|,
argument|r
argument_list|,
argument|off
argument_list|,
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CONSZ
name|off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* is it legal to make an OREG or NAME entry which has an 	/* offset of off, (from a register of r), if the 	/* resulting thing had type t */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* YES */
block|}
end_block

begin_define
define|#
directive|define
name|max
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)<(y)?(y):(x))
end_define

begin_expr_stmt
name|sucomp
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* set the su field in the node to the sethi-ullman 	   number, or local equivalent */
specifier|register
name|int
name|o
decl_stmt|,
name|ty
decl_stmt|,
name|sul
decl_stmt|,
name|sur
decl_stmt|,
name|r
decl_stmt|;
name|int
name|szr
decl_stmt|;
name|NODE
modifier|*
name|temp
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|su
operator|=
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
comment|/* 2 for double, else 1 */
empty_stmt|;
if|if
condition|(
name|ty
operator|==
name|LTYPE
condition|)
block|{
if|if
condition|(
name|o
operator|==
name|OREG
condition|)
block|{
name|r
operator|=
name|p
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
comment|/* oreg cost is (worst case) 1 + number of temp registers used */
if|if
condition|(
name|R2TEST
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
operator|!=
literal|100
operator|&&
name|istreg
argument_list|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
argument_list|)
condition|)
operator|++
name|p
operator|->
name|in
operator|.
name|su
expr_stmt|;
if|if
condition|(
name|istreg
argument_list|(
name|R2UPK2
argument_list|(
name|r
argument_list|)
argument_list|)
condition|)
operator|++
name|p
operator|->
name|in
operator|.
name|su
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|istreg
argument_list|(
name|r
argument_list|)
condition|)
operator|++
name|p
operator|->
name|in
operator|.
name|su
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|su
operator|==
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|!=
name|REG
operator|||
operator|!
name|istreg
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|)
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|||
if|#
directive|if
name|defined
argument_list|(
name|FORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SPRECC
argument_list|)
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
endif|#
directive|endif
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|||
name|ISPTR
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|||
name|ISARY
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|)
condition|)
name|p
operator|->
name|in
operator|.
name|su
operator|=
literal|0
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ty
operator|==
name|UTYPE
condition|)
block|{
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|UNARY
name|CALL
case|:
case|case
name|UNARY
name|STCALL
case|:
name|p
operator|->
name|in
operator|.
name|su
operator|=
name|fregs
expr_stmt|;
comment|/* all regs needed */
return|return;
default|default:
name|p
operator|->
name|in
operator|.
name|su
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|su
operator|+
operator|(
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|>
literal|1
condition|?
literal|2
else|:
literal|0
operator|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If rhs needs n, lhs needs m, regular su computation */
name|sul
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|su
expr_stmt|;
name|sur
operator|=
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|su
expr_stmt|;
name|szr
operator|=
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|>
name|szr
operator|&&
name|szr
operator|>=
literal|1
condition|)
block|{
comment|/* implicit conversion in rhs */
name|szr
operator|=
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
name|sur
operator|=
name|max
argument_list|(
name|szr
argument_list|,
name|sur
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|==
name|ASSIGN
condition|)
block|{
comment|/* computed by doing right, then left (if not in mem), then doing it */
name|p
operator|->
name|in
operator|.
name|su
operator|=
name|max
argument_list|(
name|sur
argument_list|,
name|sul
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|o
operator|==
name|CALL
operator|||
name|o
operator|==
name|STCALL
condition|)
block|{
comment|/* in effect, takes all free registers */
name|p
operator|->
name|in
operator|.
name|su
operator|=
name|fregs
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|o
operator|==
name|STASG
condition|)
block|{
comment|/* right, then left */
name|p
operator|->
name|in
operator|.
name|su
operator|=
name|max
argument_list|(
name|max
argument_list|(
literal|1
operator|+
name|sul
argument_list|,
name|sur
argument_list|)
argument_list|,
name|fregs
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|DIV
case|:
case|case
name|ASG
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|ASG
name|MOD
case|:
comment|/* EDIV instructions require reg pairs */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|unsigned
operator|)
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|<
literal|0x80000000
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|su
operator|=
name|sul
operator|+
literal|2
expr_stmt|;
return|return;
block|}
break|break;
block|}
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
block|{
comment|/* computed by doing right, doing left address, doing left, op, and store */
name|p
operator|->
name|in
operator|.
name|su
operator|=
name|max
argument_list|(
name|sur
argument_list|,
name|sul
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
case|case
name|QUEST
case|:
case|case
name|COLON
case|:
case|case
name|COMOP
case|:
name|p
operator|->
name|in
operator|.
name|su
operator|=
name|max
argument_list|(
name|max
argument_list|(
name|sul
argument_list|,
name|sur
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS
case|:
case|case
name|MUL
case|:
case|case
name|OR
case|:
case|case
name|ER
case|:
comment|/* commutative ops; put harder on left */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|su
operator|>
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|su
operator|&&
operator|!
name|istnode
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
condition|)
block|{
name|temp
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|temp
expr_stmt|;
name|sul
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|su
expr_stmt|;
name|sur
operator|=
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|su
expr_stmt|;
name|szr
operator|=
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|>
name|szr
operator|&&
name|szr
operator|>=
literal|1
condition|)
block|{
comment|/* implicit conversion in rhs */
name|szr
operator|=
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
name|sur
operator|=
name|max
argument_list|(
name|szr
argument_list|,
name|sur
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* binary op, computed by left, then right, then do op */
name|p
operator|->
name|in
operator|.
name|su
operator|=
name|max
argument_list|(
name|sul
argument_list|,
name|szr
operator|+
name|sur
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|radebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|rallo
argument_list|(
argument|p
argument_list|,
argument|down
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* do register allocation */
specifier|register
name|int
name|o
decl_stmt|,
name|down1
decl_stmt|,
name|down2
decl_stmt|,
name|ty
decl_stmt|;
if|if
condition|(
name|radebug
condition|)
name|printf
argument_list|(
literal|"rallo( %o, %d )\n"
argument_list|,
name|p
argument_list|,
name|down
argument_list|)
expr_stmt|;
name|down2
operator|=
name|NOPREF
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|rall
operator|=
name|down
expr_stmt|;
name|down1
operator|=
operator|(
name|down
operator|&=
operator|~
name|MUSTDO
operator|)
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|ASSIGN
case|:
name|down1
operator|=
name|NOPREF
expr_stmt|;
name|down2
operator|=
name|down
expr_stmt|;
break|break;
case|case
name|CALL
case|:
case|case
name|STASG
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|NOT
case|:
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
name|down1
operator|=
name|NOPREF
expr_stmt|;
break|break;
case|case
name|FORCE
case|:
name|down1
operator|=
name|R0
operator||
name|MUSTDO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ty
operator|!=
name|LTYPE
condition|)
name|rallo
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|down1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|rallo
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|down2
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|offstar
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|PLUS
condition|)
block|{
comment|/* try to create index expressions */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|LS
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|!=
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|3
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
argument_list|,
name|INTAREG
operator||
name|INAREG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|su
operator|==
name|fregs
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|INTAREG
operator||
name|INAREG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|LS
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|!=
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|3
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|left
argument_list|,
name|INTAREG
operator||
name|INAREG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|su
operator|==
name|fregs
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|INTAREG
operator||
name|INAREG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
operator|(
name|PTR
operator||
name|CHAR
operator|)
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
operator|(
name|PTR
operator||
name|UCHAR
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|!=
name|REG
operator|||
name|tlen
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|!=
name|SZINT
operator|/
name|SZCHAR
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|INTAREG
operator||
name|INAREG
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|!=
name|REG
operator|||
name|tlen
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
operator|!=
name|SZINT
operator|/
name|SZCHAR
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|INTAREG
operator||
name|INAREG
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|PLUS
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|MINUS
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|order
argument_list|(
name|p
argument_list|,
name|INTAREG
operator||
name|INAREG
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
operator|&&
operator|!
name|canaddr
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return;
block|}
name|order
argument_list|(
name|p
argument_list|,
name|INTAREG
operator||
name|INAREG
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|setincr
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|setbin
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|ro
decl_stmt|,
name|rt
decl_stmt|;
name|rt
operator|=
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|ro
operator|=
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
expr_stmt|;
if|if
condition|(
name|canaddr
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|&&
operator|!
name|canaddr
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
condition|)
block|{
comment|/* address rhs */
if|if
condition|(
name|ro
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|INAREG
operator||
name|INTAREG
operator||
name|SOREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|istnode
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
condition|)
block|{
comment|/* try putting LHS into a reg */
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|INAREG
operator||
name|INTAREG
operator||
name|INBREG
operator||
name|INTBREG
operator||
name|SOREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ro
operator|==
name|UNARY
name|MUL
operator|&&
name|rt
operator|!=
name|CHAR
operator|&&
name|rt
operator|!=
name|UCHAR
condition|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|rt
operator|==
name|CHAR
operator|||
name|rt
operator|==
name|UCHAR
operator|||
name|rt
operator|==
name|SHORT
operator|||
name|rt
operator|==
name|USHORT
operator|||
ifndef|#
directive|ifndef
name|SPRECC
name|rt
operator|==
name|FLOAT
operator|||
endif|#
directive|endif
operator|(
name|ro
operator|!=
name|REG
operator|&&
name|ro
operator|!=
name|NAME
operator|&&
name|ro
operator|!=
name|OREG
operator|&&
name|ro
operator|!=
name|ICON
operator|)
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|INAREG
operator||
name|INBREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|setstr
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* structure assignment */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|!=
name|REG
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|INTAREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|!=
name|NAME
operator|&&
name|p
operator|->
name|in
operator|.
name|op
operator|!=
name|OREG
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|!=
name|UNARY
name|MUL
condition|)
name|cerror
argument_list|(
literal|"bad setstr"
argument_list|)
expr_stmt|;
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|INTAREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|setasg
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* setup for assignment operator */
if|if
condition|(
operator|!
name|canaddr
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
condition|)
name|offstar
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
else|else
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|INAREG
operator||
name|INBREG
operator||
name|SOREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|FLD
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* FLD patch */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|FLD
operator|&&
operator|!
operator|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|)
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|INAREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* end of FLD patch */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|setasop
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* setup for =ops */
specifier|register
name|int
name|rt
decl_stmt|,
name|ro
decl_stmt|;
name|rt
operator|=
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|ro
operator|=
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
expr_stmt|;
if|if
condition|(
name|ro
operator|==
name|UNARY
name|MUL
operator|&&
name|rt
operator|!=
name|CHAR
condition|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rt
operator|==
name|CHAR
operator|||
name|rt
operator|==
name|SHORT
operator|||
name|rt
operator|==
name|UCHAR
operator|||
name|rt
operator|==
name|USHORT
operator|||
ifndef|#
directive|ifndef
name|SPRECC
name|rt
operator|==
name|FLOAT
operator|||
endif|#
directive|endif
operator|(
name|ro
operator|!=
name|REG
operator|&&
name|ro
operator|!=
name|ICON
operator|&&
name|ro
operator|!=
name|NAME
operator|&&
name|ro
operator|!=
name|OREG
operator|)
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|INAREG
operator||
name|INBREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|FLD
condition|)
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|REG
case|:
case|case
name|ICON
case|:
case|case
name|NAME
case|:
case|case
name|OREG
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|UNARY
name|MUL
case|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
name|offstar
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cerror
argument_list|(
literal|"illegal setasop"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_block

begin_decl_stmt
name|int
name|crslab
init|=
literal|99999
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VAX */
end_comment

begin_macro
name|getlab
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|crslab
operator|--
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|deflab
end_ifndef

begin_macro
name|deflab
argument_list|(
argument|l
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"L%d:\n"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|genargs
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|pasg
decl_stmt|;
specifier|register
name|int
name|align
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* generate code for the arguments */
comment|/*  first, do the arguments on the right */
while|while
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|CM
condition|)
block|{
name|genargs
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STARG
condition|)
block|{
comment|/* structure valued argument */
name|size
operator|=
name|p
operator|->
name|stn
operator|.
name|stsize
expr_stmt|;
name|align
operator|=
name|p
operator|->
name|stn
operator|.
name|stalign
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
else|else
block|{
comment|/* make it look beautiful... */
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|UNARY
name|MUL
expr_stmt|;
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* turn it into an oreg */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|p
operator|->
name|in
operator|.
name|op
operator|!=
name|OREG
operator|&&
name|count
operator|<
literal|10
condition|;
operator|++
name|count
control|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|!=
name|OREG
condition|)
name|cerror
argument_list|(
literal|"stuck starg"
argument_list|)
expr_stmt|;
block|}
name|pasg
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|pasg
operator|->
name|in
operator|.
name|op
operator|=
name|STARG
expr_stmt|;
name|pasg
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|pasg
operator|->
name|stn
operator|.
name|stsize
operator|=
name|size
expr_stmt|;
name|pasg
operator|->
name|stn
operator|.
name|stalign
operator|=
name|align
expr_stmt|;
name|pasg
operator|->
name|in
operator|.
name|left
operator|=
name|p
expr_stmt|;
name|order
argument_list|(
name|pasg
argument_list|,
name|FORARG
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ordinary case */
name|order
argument_list|(
name|p
argument_list|,
name|FORARG
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|argsize
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|t
decl_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|CM
condition|)
block|{
name|t
operator|=
name|argsize
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
block|{
name|SETOFF
argument_list|(
name|t
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|+
literal|8
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STARG
condition|)
block|{
name|SETOFF
argument_list|(
name|t
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* alignment */
return|return
operator|(
name|t
operator|+
operator|(
operator|(
name|p
operator|->
name|stn
operator|.
name|stsize
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
literal|4
operator|)
return|;
comment|/* size */
block|}
else|else
block|{
name|SETOFF
argument_list|(
name|t
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|+
literal|4
operator|)
return|;
block|}
block|}
end_block

end_unit

