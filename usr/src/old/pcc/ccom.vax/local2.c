begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)local2.c	1.13 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pass2.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FORT
end_ifdef

begin_decl_stmt
name|int
name|ftlab1
decl_stmt|,
name|ftlab2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* a lot of the machine dependent parts of the second pass */
end_comment

begin_define
define|#
directive|define
name|putstr
parameter_list|(
name|s
parameter_list|)
value|fputs((s), stdout)
end_define

begin_define
define|#
directive|define
name|BITMASK
parameter_list|(
name|n
parameter_list|)
value|((1L<<n)-1)
end_define

begin_macro
name|where
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, line %d: "
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lineid
argument_list|(
argument|l
argument_list|,
argument|fn
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* identify line l and file fn */
name|printf
argument_list|(
literal|"#	line %d, file %s\n"
argument_list|,
name|l
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|eobl2
argument_list|()
end_macro

begin_block
block|{
name|OFFSZ
name|spoff
decl_stmt|;
comment|/* offset from stack pointer */
ifdef|#
directive|ifdef
name|FORT
name|spoff
operator|=
name|maxoff
expr_stmt|;
if|if
condition|(
name|spoff
operator|>=
name|AUTOINIT
condition|)
name|spoff
operator|-=
name|AUTOINIT
expr_stmt|;
name|spoff
operator|/=
name|SZCHAR
expr_stmt|;
name|SETOFF
argument_list|(
name|spoff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|printf
argument_list|(
literal|"	.set	.F%d,%ld\n"
argument_list|,
name|ftnno
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SHOULD BE L%d ... ftnno but must change pc/f77 */
name|printf
argument_list|(
literal|"	.set	LF%d,%ld\n"
argument_list|,
name|ftnno
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
specifier|extern
name|int
name|ftlab1
decl_stmt|,
name|ftlab2
decl_stmt|;
name|spoff
operator|=
name|maxoff
expr_stmt|;
if|if
condition|(
name|spoff
operator|>=
name|AUTOINIT
condition|)
name|spoff
operator|-=
name|AUTOINIT
expr_stmt|;
name|spoff
operator|/=
name|SZCHAR
expr_stmt|;
name|SETOFF
argument_list|(
name|spoff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:\n"
argument_list|,
name|ftlab1
argument_list|)
expr_stmt|;
if|if
condition|(
name|spoff
operator|!=
literal|0
condition|)
if|if
condition|(
name|spoff
operator|<
literal|64
condition|)
name|printf
argument_list|(
literal|"	subl2	$%ld,sp\n"
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"	movab	-%ld(sp),sp\n"
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	jbr 	L%d\n"
argument_list|,
name|ftlab2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maxargs
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|hoptab
block|{
name|int
name|opmask
decl_stmt|;
name|char
modifier|*
name|opstring
decl_stmt|;
block|}
name|ioptab
index|[]
init|=
block|{
name|ASG
name|PLUS
block|,
literal|"add"
block|,
name|ASG
name|MINUS
block|,
literal|"sub"
block|,
name|ASG
name|MUL
block|,
literal|"mul"
block|,
name|ASG
name|DIV
block|,
literal|"div"
block|,
name|ASG
name|OR
block|,
literal|"bis"
block|,
name|ASG
name|ER
block|,
literal|"xor"
block|,
name|ASG
name|AND
block|,
literal|"bic"
block|,
name|PLUS
block|,
literal|"add"
block|,
name|MINUS
block|,
literal|"sub"
block|,
name|MUL
block|,
literal|"mul"
block|,
name|DIV
block|,
literal|"div"
block|,
name|OR
block|,
literal|"bis"
block|,
name|ER
block|,
literal|"xor"
block|,
name|AND
block|,
literal|"bic"
block|,
operator|-
literal|1
block|,
literal|""
block|}
struct|;
end_struct

begin_macro
name|hopcode
argument_list|(
argument|f
argument_list|,
argument|o
argument_list|)
end_macro

begin_block
block|{
comment|/* output the appropriate string from the above table */
specifier|register
name|struct
name|hoptab
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|ioptab
init|;
name|q
operator|->
name|opmask
operator|>=
literal|0
condition|;
operator|++
name|q
control|)
block|{
if|if
condition|(
name|q
operator|->
name|opmask
operator|==
name|o
condition|)
block|{
name|putstr
argument_list|(
name|q
operator|->
name|opstring
argument_list|)
expr_stmt|;
comment|/* tbl 			if( f == 'F' ) putchar( 'e' ); 			else if( f == 'D' ) putchar( 'd' );    tbl */
comment|/* tbl */
switch|switch
condition|(
name|f
condition|)
block|{
case|case
literal|'L'
case|:
case|case
literal|'W'
case|:
case|case
literal|'B'
case|:
case|case
literal|'D'
case|:
case|case
literal|'F'
case|:
name|putchar
argument_list|(
name|tolower
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* tbl */
return|return;
block|}
block|}
name|cerror
argument_list|(
literal|"no hoptab for %s"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|rnames
index|[]
init|=
block|{
comment|/* keyed to register number tokens */
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"ap"
block|,
literal|"fp"
block|,
literal|"sp"
block|,
literal|"pc"
block|,  	}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rstatus
index|[]
init|=
block|{
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,  	}
decl_stmt|;
end_decl_stmt

begin_macro
name|tlen
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
name|DOUBLE
case|:
return|return
operator|(
literal|8
operator|)
return|;
default|default:
return|return
operator|(
literal|4
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|mixtypes
argument_list|(
argument|p
argument_list|,
argument|q
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|TWORD
name|tp
decl_stmt|,
name|tq
decl_stmt|;
name|tp
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|tq
operator|=
name|q
operator|->
name|in
operator|.
name|type
expr_stmt|;
return|return
operator|(
operator|(
name|tp
operator|==
name|FLOAT
operator|||
name|tp
operator|==
name|DOUBLE
operator|)
operator|!=
operator|(
name|tq
operator|==
name|FLOAT
operator|||
name|tq
operator|==
name|DOUBLE
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|prtype
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|n
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|DOUBLE
case|:
name|putchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
return|return;
case|case
name|FLOAT
case|:
name|putchar
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
return|return;
case|case
name|LONG
case|:
case|case
name|ULONG
case|:
case|case
name|INT
case|:
case|case
name|UNSIGNED
case|:
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
return|return;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
name|putchar
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
return|return;
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
name|putchar
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
operator|!
name|ISPTR
argument_list|(
name|n
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"zzzcode- bad type"
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|zzzcode
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|m
expr_stmt|;
name|CONSZ
name|val
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'N'
case|:
comment|/* logical ops, turned into 0-1 */
comment|/* use register given by register 1 */
name|cbgen
argument_list|(
literal|0
argument_list|,
name|m
operator|=
name|getlab
argument_list|()
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|p
operator|->
name|bn
operator|.
name|label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	clrl	%s\n"
argument_list|,
name|rnames
index|[
name|getlr
argument_list|(
name|p
argument_list|,
literal|'1'
argument_list|)
operator|->
name|tn
operator|.
name|rval
index|]
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
case|case
literal|'P'
case|:
name|cbgen
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|,
name|p
operator|->
name|bn
operator|.
name|label
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|eprint
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|r
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|ASSIGN
condition|)
name|l
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
condition|)
block|{
name|l
operator|=
name|resc
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SPRECC
argument_list|)
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|r
operator|->
name|in
operator|.
name|type
expr_stmt|;
else|#
directive|else
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|?
name|DOUBLE
else|:
name|r
operator|->
name|in
operator|.
name|type
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* OPLTYPE */
name|l
operator|=
name|resc
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SPRECC
argument_list|)
name|l
operator|->
name|in
operator|.
name|type
operator|=
operator|(
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|?
name|r
operator|->
name|in
operator|.
name|type
else|:
name|INT
operator|)
expr_stmt|;
else|#
directive|else
name|l
operator|->
name|in
operator|.
name|type
operator|=
operator|(
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|?
name|DOUBLE
else|:
name|INT
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|==
literal|0
condition|)
block|{
name|putstr
argument_list|(
literal|"clr"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<
literal|0
operator|&&
name|r
operator|->
name|tn
operator|.
name|lval
operator|>=
operator|-
literal|63
condition|)
block|{
name|putstr
argument_list|(
literal|"mneg"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
operator|-
name|r
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
goto|goto
name|ops
goto|;
block|}
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<
literal|0
condition|)
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|r
operator|->
name|tn
operator|.
name|lval
operator|>=
operator|-
literal|128
condition|?
name|CHAR
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|>=
operator|-
literal|32768
condition|?
name|SHORT
else|:
name|INT
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|63
condition|?
name|INT
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|127
condition|?
name|CHAR
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|32767
condition|?
name|SHORT
else|:
name|INT
operator|)
operator|)
expr_stmt|;
else|else
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|63
condition|?
name|INT
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|127
condition|?
name|CHAR
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|255
condition|?
name|UCHAR
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|32767
condition|?
name|SHORT
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|65535
condition|?
name|USHORT
else|:
name|INT
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|putstr
argument_list|(
literal|"moval"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|acon
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
operator|&&
operator|!
operator|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|)
operator|&&
operator|!
name|mixtypes
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
condition|)
block|{
comment|/* 			 * Because registers must always contain objects 			 * of the same width as INTs, we may have to 			 * perform two conversions to get an INT.  Can 			 * the conversions be collapsed into one? 			 */
if|if
condition|(
name|m
operator|=
name|collapsible
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
condition|)
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|m
expr_stmt|;
else|else
block|{
comment|/* 				 * Two steps are required. 				 */
name|NODE
modifier|*
name|x
init|=
operator|&
name|resc
index|[
literal|1
index|]
decl_stmt|;
operator|*
name|x
operator|=
operator|*
name|l
expr_stmt|;
if|if
condition|(
name|tlen
argument_list|(
name|x
argument_list|)
operator|>
name|tlen
argument_list|(
name|r
argument_list|)
operator|&&
name|ISUNSIGNED
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|putstr
argument_list|(
literal|"movz"
argument_list|)
expr_stmt|;
else|else
name|putstr
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|r
operator|=
name|x
expr_stmt|;
block|}
name|l
operator|->
name|in
operator|.
name|type
operator|=
operator|(
name|ISUNSIGNED
argument_list|(
name|l
operator|->
name|in
operator|.
name|type
argument_list|)
condition|?
name|UNSIGNED
else|:
name|INT
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|||
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|ULONG
operator|)
operator|&&
name|mixtypes
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|int
name|label1
decl_stmt|,
name|label2
decl_stmt|;
name|label1
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|label2
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|putstr
argument_list|(
literal|"movl\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\tbbsc\t$31,"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|",L%d\n\tcvtl"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\tjbr\tL%d\nL%d:\n\tcvtl"
argument_list|,
name|label2
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\tadd"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"2\t$0"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"2.147483648e9,"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nL%d:"
argument_list|,
name|label2
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|mixtypes
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|tlen
argument_list|(
name|l
argument_list|)
operator|==
name|tlen
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|putstr
argument_list|(
literal|"mov"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORT
if|if
condition|(
name|Oflag
condition|)
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
name|putchar
argument_list|(
literal|'q'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
else|else
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FORT
goto|goto
name|ops
goto|;
block|}
elseif|else
if|if
condition|(
name|tlen
argument_list|(
name|l
argument_list|)
operator|>
name|tlen
argument_list|(
name|r
argument_list|)
operator|&&
name|ISUNSIGNED
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|putstr
argument_list|(
literal|"movz"
argument_list|)
expr_stmt|;
else|else
name|putstr
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
block|}
else|else
name|putstr
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ops
label|:
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'G'
case|:
comment|/* i *= f; asgops with int lhs and float rhs */
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|rt
decl_stmt|;
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|s
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|rt
operator|=
name|r
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|op
operator|=
name|SCONV
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|type
operator|=
name|rt
expr_stmt|;
name|zzzcode
argument_list|(
name|s
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|hopcode
argument_list|(
name|rt
operator|==
name|FLOAT
condition|?
literal|'F'
else|:
literal|'D'
argument_list|,
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"2\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|resc
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|right
operator|=
name|resc
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|type
operator|=
name|l
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|zzzcode
argument_list|(
name|s
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
block|}
case|case
literal|'B'
case|:
comment|/* get oreg value in temp register for left shift */
block|{
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|eprint
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|tlen
argument_list|(
name|r
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|&&
name|r
operator|->
name|in
operator|.
name|type
operator|!=
name|FLOAT
condition|)
name|putstr
argument_list|(
literal|"movl"
argument_list|)
expr_stmt|;
else|else
block|{
name|putstr
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
literal|'C'
case|:
comment|/* num words pushed on arg stack */
block|{
specifier|extern
name|int
name|gc_numbytes
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|printf
argument_list|(
literal|"->%d<-"
argument_list|,
name|gc_numbytes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"$%d"
argument_list|,
name|gc_numbytes
operator|/
operator|(
name|SZLONG
operator|/
name|SZCHAR
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'D'
case|:
comment|/* INCR and DECR */
name|zzzcode
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
case|case
literal|'E'
case|:
comment|/* INCR and DECR, FOREFF */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|==
literal|1
condition|)
block|{
name|putstr
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
literal|"inc"
else|:
literal|"dec"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return;
block|}
name|putstr
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
literal|"add"
else|:
literal|"sub"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'2'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
comment|/* register type of right operand */
block|{
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
specifier|register
name|int
name|ty
decl_stmt|;
name|n
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
name|ty
operator|=
name|n
operator|->
name|in
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|printf
argument_list|(
literal|"->%d<-"
argument_list|,
name|ty
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|DOUBLE
condition|)
name|putchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ty
operator|==
name|FLOAT
condition|)
name|putchar
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'L'
case|:
comment|/* type of left operand */
case|case
literal|'R'
case|:
comment|/* type of right operand */
block|{
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
name|n
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|printf
argument_list|(
literal|"->%d<-"
argument_list|,
name|n
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'Z'
case|:
comment|/* complement mask for bit instr */
name|printf
argument_list|(
literal|"$%ld"
argument_list|,
operator|~
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'U'
case|:
comment|/* 32 - n, for unsigned right shifts */
name|printf
argument_list|(
literal|"$%d"
argument_list|,
literal|32
operator|-
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
comment|/* rounded structure length for arguments */
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
name|p
operator|->
name|stn
operator|.
name|stsize
expr_stmt|;
name|SETOFF
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"$%d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'S'
case|:
comment|/* structure assignment */
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|size
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STASG
condition|)
block|{
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STARG
condition|)
block|{
comment|/* store an arg into a temporary */
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
else|else
name|cerror
argument_list|(
literal|"STASG bad"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|NAME
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|!=
name|OREG
condition|)
name|cerror
argument_list|(
literal|"STASG-r"
argument_list|)
expr_stmt|;
name|size
operator|=
name|p
operator|->
name|stn
operator|.
name|stsize
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|>
literal|65535
condition|)
name|cerror
argument_list|(
literal|"structure size<0=0 or>65535"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|putstr
argument_list|(
literal|"	movb	"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|putstr
argument_list|(
literal|"	movw	"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|putstr
argument_list|(
literal|"	movl	"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|putstr
argument_list|(
literal|"	movq	"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"	movc3	$%d,"
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STASG
condition|)
block|{
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
name|putstr
argument_list|(
literal|",(sp)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|NAME
condition|)
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
condition|)
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|REG
expr_stmt|;
block|}
break|break;
default|default:
name|cerror
argument_list|(
literal|"illegal zzzcode"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * collapsible(dest, src) -- if a conversion with a register destination  *	can be accomplished in one instruction, return the type of src  *	that will do the job correctly; otherwise return 0.  Note that  *	a register must always end up having type INT or UNSIGNED.  */
end_comment

begin_function
name|int
name|collapsible
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|NODE
modifier|*
name|dest
decl_stmt|,
decl|*
name|src
decl_stmt|;
end_function

begin_block
block|{
name|int
name|st
init|=
name|src
operator|->
name|in
operator|.
name|type
decl_stmt|;
name|int
name|dt
init|=
name|dest
operator|->
name|in
operator|.
name|type
decl_stmt|;
name|int
name|newt
init|=
literal|0
decl_stmt|;
comment|/* 	 * Are there side effects of evaluating src? 	 * If the derived type will not be the same size as src, 	 * we may have to use two steps. 	 */
if|if
condition|(
name|tlen
argument_list|(
name|src
argument_list|)
operator|>
name|tlen
argument_list|(
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
name|tshape
argument_list|(
name|src
argument_list|,
name|STARREG
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|src
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
operator|&&
name|R2TEST
argument_list|(
name|src
operator|->
name|tn
operator|.
name|rval
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Can we get an object of dest's type by punning src? 	 * Praises be to great Cthulhu for little-endian machines... 	 */
if|if
condition|(
name|st
operator|==
name|CHAR
operator|&&
name|dt
operator|==
name|USHORT
condition|)
comment|/* 		 * Special case -- we must sign-extend to 16 bits. 		 */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tlen
argument_list|(
name|src
argument_list|)
operator|<
name|tlen
argument_list|(
name|dest
argument_list|)
condition|)
name|newt
operator|=
name|st
expr_stmt|;
else|else
name|newt
operator|=
name|dt
expr_stmt|;
return|return
operator|(
name|newt
operator|)
return|;
block|}
end_block

begin_macro
name|rmove
argument_list|(
argument|rt
argument_list|,
argument|rs
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"	%s	%s,%s\n"
argument_list|,
ifdef|#
directive|ifdef
name|FORT
operator|!
name|Oflag
condition|?
operator|(
name|t
operator|==
name|DOUBLE
condition|?
literal|"movq"
else|:
literal|"movl"
operator|)
else|:
endif|#
directive|endif
operator|(
name|t
operator|==
name|FLOAT
condition|?
literal|"movf"
else|:
operator|(
name|t
operator|==
name|DOUBLE
condition|?
literal|"movd"
else|:
literal|"movl"
operator|)
operator|)
argument_list|,
name|rnames
index|[
name|rs
index|]
argument_list|,
name|rnames
index|[
name|rt
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|struct
name|respref
name|respref
index|[]
init|=
block|{
name|INTAREG
operator||
name|INTBREG
block|,
name|INTAREG
operator||
name|INTBREG
block|,
name|INAREG
operator||
name|INBREG
block|,
name|INAREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|STARREG
operator||
name|STARNM
operator||
name|SNAME
operator||
name|SCON
block|,
name|INTEMP
block|,
name|INTEMP
block|,
name|FORARG
block|,
name|FORARG
block|,
name|INTEMP
block|,
name|INTAREG
operator||
name|INAREG
operator||
name|INTBREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|STARREG
operator||
name|STARNM
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|setregs
argument_list|()
end_macro

begin_block
block|{
comment|/* set up temporary registers */
name|fregs
operator|=
literal|6
expr_stmt|;
comment|/* tbl- 6 free regs on VAX (0-5) */
empty_stmt|;
block|}
end_block

begin_macro
name|rewfld
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|callreg
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|R0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|base
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
return|return
operator|(
literal|100
operator|)
return|;
comment|/* ie no base reg */
if|if
condition|(
name|o
operator|==
name|REG
condition|)
return|return
operator|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
operator|(
name|o
operator|==
name|PLUS
operator|||
name|o
operator|==
name|MINUS
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|OREG
operator|&&
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|||
name|ISPTR
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|+
literal|0200
operator|*
literal|1
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|INCR
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|+
literal|0200
operator|*
literal|2
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|ASG
name|MINUS
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|+
literal|0200
operator|*
literal|4
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|||
name|ISPTR
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|+
literal|0200
operator|*
operator|(
literal|1
operator|+
literal|2
operator|)
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|offset
argument_list|(
name|p
argument_list|,
name|tyl
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|tyl
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|tyl
operator|==
literal|1
operator|&&
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|LS
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
operator|(
literal|1
operator|<<
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|)
operator|==
name|tyl
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
name|tyl
operator|==
literal|2
operator|&&
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|PLUS
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|==
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|rval
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|makeor2
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|b
argument_list|,
name|o
argument_list|)
specifier|register
name|NODE
operator|*
name|p
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|b
decl_stmt|,
name|o
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|NODE
modifier|*
name|f
decl_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|f
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
comment|/* have to free this subtree later */
comment|/* init base */
switch|switch
condition|(
name|q
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ICON
case|:
case|case
name|REG
case|:
case|case
name|OREG
case|:
name|t
operator|=
name|q
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|q
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|=
operator|-
name|q
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
case|case
name|PLUS
case|:
name|t
operator|=
name|q
operator|->
name|in
operator|.
name|right
expr_stmt|;
break|break;
case|case
name|INCR
case|:
case|case
name|ASG
name|MINUS
case|:
name|t
operator|=
name|q
operator|->
name|in
operator|.
name|left
expr_stmt|;
break|break;
case|case
name|UNARY
name|MUL
case|:
name|t
operator|=
name|q
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"illegal makeor2"
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|t
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHNAM
condition|;
operator|++
name|i
control|)
name|p
operator|->
name|in
operator|.
name|name
index|[
name|i
index|]
operator|=
name|t
operator|->
name|in
operator|.
name|name
index|[
name|i
index|]
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|in
operator|.
name|name
operator|=
name|t
operator|->
name|in
operator|.
name|name
expr_stmt|;
endif|#
directive|endif
comment|/* init offset */
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|R2PACK
argument_list|(
operator|(
name|b
operator|&
literal|0177
operator|)
argument_list|,
name|o
argument_list|,
operator|(
name|b
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|tfree
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|canaddr
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|REG
operator|||
name|o
operator|==
name|ICON
operator|||
name|o
operator|==
name|OREG
operator|||
operator|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|flshape
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|NAME
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|||
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
operator|&&
operator|(
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|||
name|tlen
argument_list|(
name|p
argument_list|)
operator|==
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|shtemp
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STARG
condition|)
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|NAME
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
operator|||
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|shumul
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|o
expr_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
block|{
name|printf
argument_list|(
literal|"\nshumul:op=%d,lop=%d,rop=%d"
argument_list|,
name|p
operator|->
name|in
operator|.
name|op
argument_list|,
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" prname=%s,plty=%d, prlval=%D\n"
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
argument_list|,
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
block|}
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
operator|||
operator|(
name|o
operator|==
name|OREG
operator|&&
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|)
operator|||
name|o
operator|==
name|ICON
condition|)
return|return
operator|(
name|STARNM
operator|)
return|;
if|if
condition|(
operator|(
name|o
operator|==
name|INCR
operator|||
name|o
operator|==
name|ASG
name|MINUS
operator|)
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|CHAR
operator||
name|PTR
case|:
case|case
name|UCHAR
operator||
name|PTR
case|:
name|o
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SHORT
operator||
name|PTR
case|:
case|case
name|USHORT
operator||
name|PTR
case|:
name|o
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|INT
operator||
name|PTR
case|:
case|case
name|UNSIGNED
operator||
name|PTR
case|:
case|case
name|LONG
operator||
name|PTR
case|:
case|case
name|ULONG
operator||
name|PTR
case|:
case|case
name|FLOAT
operator||
name|PTR
case|:
name|o
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|DOUBLE
operator||
name|PTR
case|:
name|o
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ISPTR
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|&&
name|ISPTR
argument_list|(
name|DECREF
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|o
operator|=
literal|4
expr_stmt|;
break|break;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|==
name|o
condition|?
name|STARREG
else|:
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|adrcon
argument_list|(
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|CONSZ
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putchar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|conput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ICON
case|:
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|putstr
argument_list|(
name|rnames
index|[
name|p
operator|->
name|tn
operator|.
name|rval
index|]
argument_list|)
expr_stmt|;
return|return;
default|default:
name|cerror
argument_list|(
literal|"illegal conput"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|insput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|cerror
argument_list|(
literal|"insput"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|upput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|cerror
argument_list|(
literal|"upput"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|adrput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|r
decl_stmt|;
comment|/* output an address, with offsets, from p */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|FLD
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|NAME
case|:
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|ICON
case|:
comment|/* addressable value of the constant */
name|putchar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|putstr
argument_list|(
name|rnames
index|[
name|p
operator|->
name|tn
operator|.
name|rval
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|OREG
case|:
name|r
operator|=
name|p
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
if|if
condition|(
name|R2TEST
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* double indexing */
specifier|register
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|R2UPK3
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|4
condition|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|!=
literal|0
operator|||
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
operator|!=
literal|100
condition|)
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|rnames
index|[
name|R2UPK1
argument_list|(
name|r
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|2
condition|)
name|putchar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%s]"
argument_list|,
name|rnames
index|[
name|R2UPK2
argument_list|(
name|r
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r
operator|==
name|AP
condition|)
block|{
comment|/* in the argument region */
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|0
operator|||
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|werror
argument_list|(
literal|"bad arg temp"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"(ap)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|!=
literal|0
operator|||
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|rnames
index|[
name|p
operator|->
name|tn
operator|.
name|rval
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNARY
name|MUL
case|:
comment|/* STARNM or STARREG found */
if|if
condition|(
name|tshape
argument_list|(
name|p
argument_list|,
name|STARNM
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* STARREG - really auto inc or dec */
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
comment|/* tbl 			p = p->in.left; 			p->in.left->in.op = OREG; 			if( p->in.op == INCR ) { 				adrput( p->in.left ); 				putchar( '+' ); 				} 			else { 				putchar( '-' ); 				adrput( p->in.left ); 				}    tbl */
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|!=
name|tlen
argument_list|(
name|p
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"adrput: bad auto-increment/decrement"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s(%s)%s"
argument_list|,
operator|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
literal|""
else|:
literal|"-"
operator|)
argument_list|,
name|rnames
index|[
name|q
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
index|]
argument_list|,
operator|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
literal|"+"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|q
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
operator|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
operator|-
name|q
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
else|:
literal|0
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
name|tfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|cerror
argument_list|(
literal|"illegal address"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|acon
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* print out a constant */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|==
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|FLEXNAMES
name|printf
argument_list|(
literal|"%.8s"
argument_list|,
name|p
operator|->
name|in
operator|.
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|putstr
argument_list|(
name|p
operator|->
name|in
operator|.
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|FLEXNAMES
name|printf
argument_list|(
literal|"%.8s+"
argument_list|,
name|p
operator|->
name|in
operator|.
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%s+"
argument_list|,
name|p
operator|->
name|in
operator|.
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* aacon( p ) register NODE *p; { /* print out a constant */
end_comment

begin_comment
comment|/*  	if( p->in.name[0] == '\0' ){ 		printf( CONFMT, p->tn.lval); 		return( 0 ); 		} 	else if( p->tn.lval == 0 ) { #ifndef FLEXNAMES 		printf( "$%.8s", p->in.name ); #else 		printf( "$%s", p->in.name ); #endif 		return( 1 ); 		} 	else { 		printf( "$(" ); 		printf( CONFMT, p->tn.lval ); 		printf( "+" ); #ifndef FLEXNAMES 		printf( "%.8s)", p->in.name ); #else 		printf( "%s)", p->in.name ); #endif 		return(1); 		} 	}  */
end_comment

begin_expr_stmt
name|genscall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* structure valued call */
return|return
operator|(
name|gencall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* tbl */
end_comment

begin_decl_stmt
name|int
name|gc_numbytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tbl */
end_comment

begin_expr_stmt
name|gencall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* generate the call given by p */
specifier|register
name|NODE
modifier|*
name|p1
decl_stmt|;
specifier|register
name|temp
operator|,
name|temp1
expr_stmt|;
specifier|register
name|m
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
condition|)
name|temp
operator|=
name|argsize
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STCALL
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|STCALL
condition|)
block|{
comment|/* set aside room for structure return */
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stsize
operator|>
name|temp
condition|)
name|temp1
operator|=
name|p
operator|->
name|stn
operator|.
name|stsize
expr_stmt|;
else|else
name|temp1
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|>
name|maxargs
condition|)
name|maxargs
operator|=
name|temp
expr_stmt|;
name|SETOFF
argument_list|(
name|temp1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
condition|)
block|{
comment|/* make temp node, put offset in, and generate args */
name|genargs
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
name|p1
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|ICON
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|REG
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|OREG
operator|||
name|R2TEST
argument_list|(
name|p1
operator|->
name|tn
operator|.
name|rval
argument_list|)
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|NAME
condition|)
block|{
name|order
argument_list|(
name|p1
argument_list|,
name|INAREG
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	if( p1->in.op == REG&& p->tn.rval == R5 ){ 		cerror( "call register overwrite" ); 		}  */
comment|/* tbl 	setup gc_numbytes so reference to ZC works */
name|gc_numbytes
operator|=
name|temp
operator|&
operator|(
literal|0x3ff
operator|)
expr_stmt|;
comment|/* tbl */
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|UNARY
name|CALL
expr_stmt|;
name|m
operator|=
name|match
argument_list|(
name|p
argument_list|,
name|INTAREG
operator||
name|INTBREG
argument_list|)
expr_stmt|;
comment|/* compensate for deficiency in 'ret' instruction ... wah,kre */
comment|/* (plus in assignment to gc_numbytes above, for neatness only) */
if|if
condition|(
name|temp
operator|>=
literal|1024
condition|)
name|printf
argument_list|(
literal|"	addl2	$%d,sp\n"
argument_list|,
operator|(
name|temp
operator|&
operator|(
operator|~
literal|0x3ff
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* tbl 	switch( temp ) { 	case 0: 		break; 	case 2: 		printf( "	tst	(sp)+\n" ); 		break; 	case 4: 		printf( "	cmp	(sp)+,(sp)+\n" ); 		break; 	default: 		printf( "	add	$%d,sp\n", temp); 		}    tbl */
return|return
operator|(
name|m
operator|!=
name|MDONE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* tbl */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ccbranches
index|[]
init|=
block|{
literal|"	jeql	L%d\n"
block|,
literal|"	jneq	L%d\n"
block|,
literal|"	jleq	L%d\n"
block|,
literal|"	jlss	L%d\n"
block|,
literal|"	jgeq	L%d\n"
block|,
literal|"	jgtr	L%d\n"
block|,
literal|"	jlequ	L%d\n"
block|,
literal|"	jlssu	L%d\n"
block|,
literal|"	jgequ	L%d\n"
block|,
literal|"	jgtru	L%d\n"
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tbl */
end_comment

begin_macro
name|cbgen
argument_list|(
argument|o
argument_list|,
argument|lab
argument_list|,
argument|mode
argument_list|)
end_macro

begin_block
block|{
comment|/*   printf conditional and unconditional branches */
comment|/* tbl */
if|if
condition|(
name|o
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"	jbr	L%d\n"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
comment|/* tbl */
else|else
block|{
if|if
condition|(
name|o
operator|>
name|UGT
condition|)
name|cerror
argument_list|(
literal|"bad conditional branch: %s"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|ccbranches
index|[
name|o
operator|-
name|EQ
index|]
argument_list|,
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|nextcook
argument_list|(
argument|p
argument_list|,
argument|cookie
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* we have failed to match p with cookie; try another */
if|if
condition|(
name|cookie
operator|==
name|FORREW
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hopeless! */
if|if
condition|(
operator|!
operator|(
name|cookie
operator|&
operator|(
name|INTAREG
operator||
name|INTBREG
operator|)
operator|)
condition|)
return|return
operator|(
name|INTAREG
operator||
name|INTBREG
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|cookie
operator|&
name|INTEMP
operator|)
operator|&&
name|asgop
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
condition|)
return|return
operator|(
name|INTEMP
operator||
name|INAREG
operator||
name|INTAREG
operator||
name|INTBREG
operator||
name|INBREG
operator|)
return|;
return|return
operator|(
name|FORREW
operator|)
return|;
block|}
end_block

begin_macro
name|lastchance
argument_list|(
argument|p
argument_list|,
argument|cook
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* forget it! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|optim2
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* do local tree transformations and optimizations */
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|int
name|m
decl_stmt|,
name|ml
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|AND
case|:
comment|/* commute L and R to eliminate complements and constants */
if|if
condition|(
operator|(
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|)
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|l
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|l
operator|->
name|in
operator|.
name|op
operator|==
name|COMPL
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|l
expr_stmt|;
block|}
case|case
name|ASG
name|AND
case|:
comment|/* change meaning of AND to ~R&L - bic on pdp11 */
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|r
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* complement constant */
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
operator|~
name|r
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|COMPL
condition|)
block|{
comment|/* ~~A => A */
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|r
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
else|else
block|{
comment|/* insert complement node */
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|l
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|COMPL
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|r
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|left
operator|=
name|r
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|right
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|SCONV
case|:
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SPRECC
argument_list|)
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
return|return;
else|#
directive|else
if|if
condition|(
name|mixtypes
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|op
operator|==
name|PCONV
condition|)
return|return;
comment|/* Only trust it to get it right if the size is the same */
if|if
condition|(
name|tlen
argument_list|(
name|p
argument_list|)
operator|!=
name|tlen
argument_list|(
name|l
argument_list|)
condition|)
return|return;
comment|/* clobber conversion */
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|op
operator|!=
name|FLD
condition|)
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
break|break;
case|case
name|ASSIGN
case|:
comment|/* 		 * Conversions are equivalent to assignments; 		 * when the two operations are combined, 		 * we can sometimes zap the conversion. 		 */
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
operator|&&
operator|!
name|mixtypes
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
operator|&&
name|tlen
argument_list|(
name|l
argument_list|)
operator|==
name|tlen
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|r
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_function
name|NODE
modifier|*
name|addroreg
parameter_list|(
name|l
parameter_list|)
name|NODE
modifier|*
name|l
decl_stmt|;
comment|/* OREG was built in clocal() 				 * for an auto or formal parameter 				 * now its address is being taken 				 * local code must unwind it 				 * back to PLUS/MINUS REG ICON 				 * according to local conventions 				 */
block|{
name|cerror
argument_list|(
literal|"address of OREG taken"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ONEPASS
end_ifndef

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
return|return
operator|(
name|mainp2
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* added by jwf */
end_comment

begin_struct
struct|struct
name|functbl
block|{
name|int
name|fop
decl_stmt|;
name|TWORD
name|ftype
decl_stmt|;
name|char
modifier|*
name|func
decl_stmt|;
block|}
name|opfunc
index|[]
init|=
block|{
name|DIV
block|,
name|TANY
block|,
literal|"udiv"
block|,
name|MOD
block|,
name|TANY
block|,
literal|"urem"
block|,
name|ASG
name|DIV
block|,
name|TANY
block|,
literal|"audiv"
block|,
name|ASG
name|MOD
block|,
name|TANY
block|,
literal|"aurem"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_expr_stmt
name|hardops
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* change hard to do operators into function calls.  */
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|functbl
modifier|*
name|f
decl_stmt|;
specifier|register
name|o
expr_stmt|;
name|NODE
modifier|*
name|old
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|optype
argument_list|(
name|o
argument_list|)
operator|==
name|BITYPE
operator|&&
operator|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
operator|||
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
argument_list|)
operator|)
operator|)
condition|)
return|return;
for|for
control|(
name|f
operator|=
name|opfunc
init|;
name|f
operator|->
name|fop
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|o
operator|==
name|f
operator|->
name|fop
condition|)
goto|goto
name|convert
goto|;
block|}
return|return;
name|convert
label|:
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|old
operator|=
name|NIL
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|FLD
case|:
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
expr_stmt|;
comment|/* 			 * rewrite (lval.fld /= rval); as 			 *  ((*temp).fld = udiv((*(temp =&lval)).fld,rval)); 			 * else the compiler will evaluate lval twice. 			 */
if|if
condition|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
comment|/* first allocate a temp storage */
name|temp
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|temp
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|temp
operator|->
name|tn
operator|.
name|rval
operator|=
name|TMPREG
expr_stmt|;
name|temp
operator|->
name|tn
operator|.
name|lval
operator|=
name|BITOOR
argument_list|(
name|freetemp
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|in
operator|.
name|type
operator|=
name|INCREF
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|temp
operator|->
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
else|#
directive|else
name|temp
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|old
operator|=
name|q
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|temp
expr_stmt|;
block|}
comment|/* fall thru ... */
case|case
name|REG
case|:
case|case
name|NAME
case|:
case|case
name|OREG
case|:
comment|/* change ASG OP to a simple OP */
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|NOASG
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|tcopy
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|right
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|q
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
name|f
operator|-=
literal|2
expr_stmt|;
comment|/* Note: this depends on the table order */
comment|/* on the right side only - replace *temp with 			 *(temp =&lval), build the assignment node */
if|if
condition|(
name|old
condition|)
block|{
name|temp
operator|=
name|q
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
expr_stmt|;
comment|/* the "*" node */
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|temp
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|right
operator|=
name|old
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|old
operator|->
name|in
operator|.
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|q
operator|->
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|temp
operator|->
name|in
operator|.
name|left
operator|=
name|q
expr_stmt|;
block|}
break|break;
case|case
name|UNARY
name|MUL
case|:
comment|/* avoid doing side effects twice */
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|q
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"hardops: can't compute& LHS"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* build comma op for args to function */
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|CM
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|right
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|CALL
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|q
expr_stmt|;
comment|/* put function name in left node of call */
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|INCREF
argument_list|(
name|FTN
operator|+
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|strcpy
argument_list|(
name|q
operator|->
name|in
operator|.
name|name
argument_list|,
name|f
operator|->
name|func
argument_list|)
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|in
operator|.
name|name
operator|=
name|f
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|tn
operator|.
name|rval
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|zappost
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* look for ++ and -- operators and remove them */
specifier|register
name|o
operator|,
name|ty
expr_stmt|;
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|INCR
case|:
case|case
name|DECR
case|:
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
comment|/* zap constant */
name|ncopy
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|zappost
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|!=
name|LTYPE
condition|)
name|zappost
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fixpre
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|o
operator|,
name|ty
expr_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|ASG
name|PLUS
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|PLUS
expr_stmt|;
break|break;
case|case
name|ASG
name|MINUS
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|MINUS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|fixpre
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|!=
name|LTYPE
condition|)
name|fixpre
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|strip
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|NODE
modifier|*
name|q
decl_stmt|;
comment|/* strip nodes off the top when no side effects occur */
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|SCONV
case|:
comment|/* remove lint tidbits */
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
break|break;
comment|/* could probably add a few more here */
default|default:
return|return;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|myreader
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|strip
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* strip off operations with no side effects */
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* expands r-vals for fields */
name|walkf
argument_list|(
name|p
argument_list|,
name|hardops
argument_list|)
expr_stmt|;
comment|/* convert ops to function calls */
name|walkf
argument_list|(
name|p
argument_list|,
name|optim2
argument_list|)
expr_stmt|;
comment|/* jwf toff = 0;  /* stack offset swindle */
block|}
end_block

end_unit

