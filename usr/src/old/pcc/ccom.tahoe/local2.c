begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)local2.c	1.7 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pass2.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|putstr
parameter_list|(
name|s
parameter_list|)
value|fputs((s), stdout)
end_define

begin_define
define|#
directive|define
name|ISCHAR
parameter_list|(
name|p
parameter_list|)
value|(p->in.type == UCHAR || p->in.type == CHAR)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|FORT
end_ifdef

begin_decl_stmt
name|int
name|ftlab1
decl_stmt|,
name|ftlab2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* a lot of the machine dependent parts of the second pass */
end_comment

begin_define
define|#
directive|define
name|BITMASK
parameter_list|(
name|n
parameter_list|)
value|((1L<<n)-1)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ONEPASS
end_ifndef

begin_macro
name|where
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, line %d: "
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|lineid
argument_list|(
argument|l
argument_list|,
argument|fn
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* identify line l and file fn */
name|printf
argument_list|(
literal|"#	line %d, file %s\n"
argument_list|,
name|l
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|ent_mask
decl_stmt|;
end_decl_stmt

begin_macro
name|eobl2
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|OFFSZ
name|spoff
decl_stmt|;
comment|/* offset from stack pointer */
ifndef|#
directive|ifndef
name|FORT
specifier|extern
name|int
name|ftlab1
decl_stmt|,
name|ftlab2
decl_stmt|;
endif|#
directive|endif
name|spoff
operator|=
name|maxoff
expr_stmt|;
name|spoff
operator|/=
name|SZCHAR
expr_stmt|;
name|SETOFF
argument_list|(
name|spoff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORT
ifndef|#
directive|ifndef
name|FLEXNAMES
name|printf
argument_list|(
literal|"	.set	.F%d,%d\n"
argument_list|,
name|ftnno
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SHOULD BE L%d ... ftnno but must change pc/f77 */
name|printf
argument_list|(
literal|"	.set	LF%d,%d\n"
argument_list|,
name|ftnno
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"	.set	LWM%d,0x%x\n"
argument_list|,
name|ftnno
argument_list|,
name|ent_mask
operator|&
literal|0x1ffc
operator||
literal|0x1000
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"	.set	L%d,0x%x\n"
argument_list|,
name|ftnno
argument_list|,
name|ent_mask
operator|&
literal|0x1ffc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:\n"
argument_list|,
name|ftlab1
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxoff
operator|>
name|AUTOINIT
condition|)
name|printf
argument_list|(
literal|"	subl3	$%d,fp,sp\n"
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	jbr 	L%d\n"
argument_list|,
name|ftlab2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ent_mask
operator|=
literal|0
expr_stmt|;
name|maxargs
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|hoptab
block|{
name|int
name|opmask
decl_stmt|;
name|char
modifier|*
name|opstring
decl_stmt|;
block|}
name|ioptab
index|[]
init|=
block|{
name|PLUS
block|,
literal|"add"
block|,
name|MINUS
block|,
literal|"sub"
block|,
name|MUL
block|,
literal|"mul"
block|,
name|DIV
block|,
literal|"div"
block|,
name|MOD
block|,
literal|"div"
block|,
name|OR
block|,
literal|"or"
block|,
name|ER
block|,
literal|"xor"
block|,
name|AND
block|,
literal|"and"
block|,
operator|-
literal|1
block|,
literal|""
block|}
struct|;
end_struct

begin_macro
name|hopcode
argument_list|(
argument|f
argument_list|,
argument|o
argument_list|)
end_macro

begin_block
block|{
comment|/* output the appropriate string from the above table */
specifier|register
name|struct
name|hoptab
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
name|o
operator|=
name|NOASG
name|o
expr_stmt|;
for|for
control|(
name|q
operator|=
name|ioptab
init|;
name|q
operator|->
name|opmask
operator|>=
literal|0
condition|;
operator|++
name|q
control|)
block|{
if|if
condition|(
name|q
operator|->
name|opmask
operator|==
name|o
condition|)
block|{
if|if
condition|(
name|f
operator|==
literal|'E'
condition|)
name|printf
argument_list|(
literal|"e%s"
argument_list|,
name|q
operator|->
name|opstring
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|q
operator|->
name|opstring
argument_list|,
name|tolower
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|cerror
argument_list|(
literal|"no hoptab for %s"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|rnames
index|[]
init|=
block|{
comment|/* keyed to register number tokens */
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"fp"
block|,
literal|"sp"
block|,
literal|"pc"
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output register name and update entry mask */
end_comment

begin_function
name|char
modifier|*
name|rname
parameter_list|(
name|r
parameter_list|)
specifier|register
name|int
name|r
decl_stmt|;
block|{
name|ent_mask
operator||=
literal|1
operator|<<
name|r
expr_stmt|;
return|return
operator|(
name|rnames
index|[
name|r
index|]
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|rstatus
index|[]
init|=
block|{
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|, 	}
decl_stmt|;
end_decl_stmt

begin_macro
name|tlen
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
name|DOUBLE
case|:
return|return
operator|(
literal|8
operator|)
return|;
default|default:
return|return
operator|(
literal|4
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|prtype
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|n
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|DOUBLE
case|:
name|putchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
return|return;
case|case
name|FLOAT
case|:
name|putchar
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
return|return;
case|case
name|INT
case|:
case|case
name|UNSIGNED
case|:
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
return|return;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
name|putchar
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
return|return;
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
name|putchar
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
operator|!
name|ISPTR
argument_list|(
name|n
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"zzzcode- bad type"
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|zzzcode
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|m
decl_stmt|;
name|int
name|val
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'N'
case|:
comment|/* logical ops, turned into 0-1 */
comment|/* use register given by register 1 */
name|cbgen
argument_list|(
literal|0
argument_list|,
name|m
operator|=
name|getlab
argument_list|()
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|p
operator|->
name|bn
operator|.
name|label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	clrl	%s\n"
argument_list|,
name|rname
argument_list|(
name|getlr
argument_list|(
name|p
argument_list|,
literal|'1'
argument_list|)
operator|->
name|tn
operator|.
name|rval
argument_list|)
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'P'
case|:
name|cbgen
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|,
name|p
operator|->
name|bn
operator|.
name|label
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
comment|/* assignment and load (integer only) */
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|eprint
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|r
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
operator|==
name|LTYPE
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|l
operator|=
name|resc
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
block|}
else|else
name|l
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
name|cerror
argument_list|(
literal|"float in ZA"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|==
literal|0
condition|)
block|{
name|putstr
argument_list|(
literal|"clr"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<
literal|0
operator|&&
name|r
operator|->
name|tn
operator|.
name|lval
operator|>=
operator|-
literal|63
condition|)
block|{
name|putstr
argument_list|(
literal|"mneg"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
operator|-
name|r
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
goto|goto
name|ops
goto|;
block|}
ifdef|#
directive|ifdef
name|MOVAFASTER
block|}
else|else
block|{
name|putstr
argument_list|(
literal|"movab\t"
argument_list|)
expr_stmt|;
name|acon
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
endif|MOVAFASTER
block|}
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|tlen
argument_list|(
name|l
argument_list|)
operator|<
name|tlen
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|putstr
argument_list|(
operator|!
name|ISUNSIGNED
argument_list|(
name|l
operator|->
name|in
operator|.
name|type
argument_list|)
condition|?
literal|"cvt"
else|:
literal|"movz"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
goto|goto
name|ops
goto|;
block|}
else|else
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
block|}
if|if
condition|(
name|tlen
argument_list|(
name|l
argument_list|)
operator|==
name|tlen
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|putstr
argument_list|(
literal|"mov"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
goto|goto
name|ops
goto|;
block|}
elseif|else
if|if
condition|(
name|tlen
argument_list|(
name|l
argument_list|)
operator|>
name|tlen
argument_list|(
name|r
argument_list|)
operator|&&
name|ISUNSIGNED
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|putstr
argument_list|(
literal|"movz"
argument_list|)
expr_stmt|;
else|else
name|putstr
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ops
label|:
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'B'
case|:
comment|/* get oreg value in temp register for shift */
block|{
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|eprint
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|tlen
argument_list|(
name|r
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|&&
name|r
operator|->
name|in
operator|.
name|type
operator|!=
name|FLOAT
condition|)
name|putstr
argument_list|(
literal|"movl"
argument_list|)
expr_stmt|;
else|else
block|{
name|putstr
argument_list|(
name|ISUNSIGNED
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
condition|?
literal|"movz"
else|:
literal|"cvt"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
literal|'C'
case|:
comment|/* num bytes pushed on arg stack */
block|{
specifier|extern
name|int
name|gc_numbytes
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|printf
argument_list|(
literal|"->%d<-"
argument_list|,
name|gc_numbytes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"call%c	$%d"
argument_list|,
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|gc_numbytes
operator|<
literal|60
operator|)
condition|?
literal|'f'
else|:
literal|'s'
argument_list|,
name|gc_numbytes
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* dont change to double (here's the only place to catch it) */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
name|rtyflg
operator|=
literal|1
expr_stmt|;
return|return;
block|}
case|case
literal|'D'
case|:
comment|/* INCR and DECR */
name|zzzcode
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n	"
argument_list|)
expr_stmt|;
case|case
literal|'E'
case|:
comment|/* INCR and DECR, FOREFF */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|==
literal|1
condition|)
block|{
name|putstr
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
literal|"inc"
else|:
literal|"dec"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return;
block|}
name|putstr
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
literal|"add"
else|:
literal|"sub"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"2	"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
comment|/* masked constant for fields */
name|printf
argument_list|(
name|ACONFMT
argument_list|,
operator|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|&
operator|(
operator|(
literal|1
operator|<<
name|fldsz
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|fldshf
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
comment|/* opcode for shift */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|LS
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|ASG
name|LS
condition|)
name|putstr
argument_list|(
literal|"shll"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|putstr
argument_list|(
literal|"shrl"
argument_list|)
expr_stmt|;
else|else
name|putstr
argument_list|(
literal|"shar"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'L'
case|:
comment|/* type of left operand */
case|case
literal|'R'
case|:
comment|/* type of right operand */
block|{
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
name|n
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|printf
argument_list|(
literal|"->%d<-"
argument_list|,
name|n
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'M'
case|:
comment|/* initiate ediv for mod and unsigned div */
block|{
specifier|register
name|char
modifier|*
name|r
decl_stmt|;
name|m
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'1'
argument_list|)
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
name|r
operator|=
name|rname
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tclrl\t%s\n\tmovl\t"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|",%s\n"
argument_list|,
name|rname
argument_list|(
name|m
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
block|{
comment|/* should be MOD */
name|m
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\tjgeq\tL%d\n\tmnegl\t$1,%s\n"
argument_list|,
name|m
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
case|case
literal|'U'
case|:
comment|/* Truncate int for type conversions: 		    LONG|ULONG -> CHAR|UCHAR|SHORT|USHORT 		    SHORT|USHORT -> CHAR|UCHAR 		   increment offset to correct byte */
block|{
specifier|register
name|NODE
modifier|*
name|p1
decl_stmt|;
name|int
name|dif
decl_stmt|;
name|p1
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
switch|switch
condition|(
name|p1
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|NAME
case|:
case|case
name|OREG
case|:
name|dif
operator|=
name|tlen
argument_list|(
name|p1
argument_list|)
operator|-
name|tlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p1
operator|->
name|tn
operator|.
name|lval
operator|+=
name|dif
expr_stmt|;
name|adrput
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p1
operator|->
name|tn
operator|.
name|lval
operator|-=
name|dif
expr_stmt|;
return|return;
default|default:
name|cerror
argument_list|(
literal|"Illegal ZU type conversion"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
case|case
literal|'T'
case|:
comment|/* rounded structure length for arguments */
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
name|p
operator|->
name|stn
operator|.
name|stsize
expr_stmt|;
name|SETOFF
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"movab	-%d(sp),sp"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'S'
case|:
comment|/* structure assignment */
name|stasg
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* multiplication for short and char */
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\tmovz"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\tcvt"
argument_list|)
expr_stmt|;
name|zzzcode
argument_list|(
name|p
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"l\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
operator|&
name|resc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\tmovz"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\tcvt"
argument_list|)
expr_stmt|;
name|zzzcode
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"l\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
operator|&
name|resc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|cerror
argument_list|(
literal|"illegal zzzcode"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|MOVB
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|off
parameter_list|)
value|{ \ 	putstr("\tmovb\t"); upput(src, off); putchar(','); \ 	upput(dst, off); putchar('\n'); \ }
end_define

begin_define
define|#
directive|define
name|MOVW
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|off
parameter_list|)
value|{ \ 	putstr("\tmovw\t"); upput(src, off); putchar(','); \ 	upput(dst, off); putchar('\n'); \ }
end_define

begin_define
define|#
directive|define
name|MOVL
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|off
parameter_list|)
value|{ \ 	putstr("\tmovl\t"); upput(src, off); putchar(','); \ 	upput(dst, off); putchar('\n'); \ }
end_define

begin_comment
comment|/*  * Generate code for a structure assignment.  */
end_comment

begin_expr_stmt
name|stasg
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|STASG
case|:
comment|/* regular assignment */
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
break|break;
case|case
name|STARG
case|:
comment|/* place arg on the stack */
name|l
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"STASG bad"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* 	 * Pun source for use in code generation. 	 */
switch|switch
condition|(
name|r
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ICON
case|:
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|NAME
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"STASG-r"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|size
operator|=
name|p
operator|->
name|stn
operator|.
name|stsize
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|>
literal|65535
condition|)
name|cerror
argument_list|(
literal|"structure size out of range"
argument_list|)
expr_stmt|;
comment|/* 	 * Generate optimized code based on structure size 	 * and alignment properties.... 	 */
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|putstr
argument_list|(
literal|"\tmovb\t"
argument_list|)
expr_stmt|;
name|optimized
label|:
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stalign
operator|!=
literal|2
condition|)
block|{
name|MOVB
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
name|SZCHAR
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\tmovb\t"
argument_list|)
expr_stmt|;
block|}
else|else
name|putstr
argument_list|(
literal|"\tmovw\t"
argument_list|)
expr_stmt|;
goto|goto
name|optimized
goto|;
case|case
literal|4
case|:
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stalign
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stalign
operator|!=
literal|2
condition|)
block|{
name|MOVB
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
literal|3
operator|*
name|SZCHAR
argument_list|)
expr_stmt|;
name|MOVB
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
literal|2
operator|*
name|SZCHAR
argument_list|)
expr_stmt|;
name|MOVB
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
literal|1
operator|*
name|SZCHAR
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\tmovb\t"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MOVW
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
name|SZSHORT
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\tmovw\t"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|putstr
argument_list|(
literal|"\tmovl\t"
argument_list|)
expr_stmt|;
goto|goto
name|optimized
goto|;
case|case
literal|6
case|:
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stalign
operator|!=
literal|2
condition|)
goto|goto
name|movblk
goto|;
name|MOVW
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
literal|2
operator|*
name|SZSHORT
argument_list|)
expr_stmt|;
name|MOVW
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
literal|1
operator|*
name|SZSHORT
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\tmovw\t"
argument_list|)
expr_stmt|;
goto|goto
name|optimized
goto|;
case|case
literal|8
case|:
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stalign
operator|==
literal|4
condition|)
block|{
name|MOVL
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
name|SZLONG
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\tmovl\t"
argument_list|)
expr_stmt|;
goto|goto
name|optimized
goto|;
block|}
comment|/* fall thru...*/
default|default:
name|movblk
label|:
comment|/* 		 * Can we ever get a register conflict with R1 here? 		 */
name|putstr
argument_list|(
literal|"\tmovab\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|",r1\n\tmovab\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|",r0\n\tmovl\t$%d,r2\n\tmovblk\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|rname
argument_list|(
name|R2
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Reverse above pun for reclaim. 	 */
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|NAME
condition|)
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
condition|)
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|REG
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Output the address of the second item in the  * pair pointed to by p.  */
end_comment

begin_expr_stmt
name|upput
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CONSZ
name|save
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|FLD
condition|)
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|NAME
case|:
case|case
name|OREG
case|:
name|save
operator|=
name|p
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|+=
name|size
operator|/
name|SZCHAR
expr_stmt|;
name|adrput
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|save
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|size
operator|==
name|SZLONG
condition|)
block|{
name|putstr
argument_list|(
name|rname
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall thru... */
default|default:
name|cerror
argument_list|(
literal|"illegal upper address op %s size %d"
argument_list|,
name|opst
index|[
name|p
operator|->
name|tn
operator|.
name|op
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
end_block

begin_macro
name|rmove
argument_list|(
argument|rt
argument_list|,
argument|rs
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"	movl	%s,%s\n"
argument_list|,
name|rname
argument_list|(
name|rs
argument_list|)
argument_list|,
name|rname
argument_list|(
name|rt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|DOUBLE
condition|)
name|printf
argument_list|(
literal|"	movl	%s,%s\n"
argument_list|,
name|rname
argument_list|(
name|rs
operator|+
literal|1
argument_list|)
argument_list|,
name|rname
argument_list|(
name|rt
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|struct
name|respref
name|respref
index|[]
init|=
block|{
name|INTAREG
operator||
name|INTBREG
block|,
name|INTAREG
operator||
name|INTBREG
block|,
name|INAREG
operator||
name|INBREG
block|,
name|INAREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|STARREG
operator||
name|STARNM
operator||
name|SNAME
operator||
name|SCON
block|,
name|INTEMP
block|,
name|INTEMP
block|,
name|FORARG
block|,
name|FORARG
block|,
name|INTEMP
block|,
name|INTAREG
operator||
name|INAREG
operator||
name|INTBREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|STARREG
operator||
name|STARNM
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|setregs
argument_list|()
end_macro

begin_block
block|{
comment|/* set up temporary registers */
name|fregs
operator|=
literal|6
expr_stmt|;
comment|/* tbl- 6 free regs on Tahoe (0-5) */
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|szty
end_ifndef

begin_macro
name|szty
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* size, in registers, needed to hold thing of type t */
return|return
operator|(
name|t
operator|==
name|DOUBLE
condition|?
literal|2
else|:
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|rewfld
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|callreg
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|R0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|base
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
return|return
operator|(
literal|100
operator|)
return|;
comment|/* ie no base reg */
if|if
condition|(
name|o
operator|==
name|REG
condition|)
return|return
operator|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
operator|(
name|o
operator|==
name|PLUS
operator|||
name|o
operator|==
name|MINUS
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|OREG
operator|&&
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|||
name|ISPTR
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|+
literal|0200
operator|*
literal|1
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|offset
argument_list|(
name|p
argument_list|,
name|tyl
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|tyl
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|tyl
operator|>
literal|8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|tyl
operator|==
literal|1
operator|&&
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|LS
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|)
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
literal|1
operator|<<
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|)
operator|==
name|tyl
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|makeor2
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|b
argument_list|,
name|o
argument_list|)
specifier|register
name|NODE
operator|*
name|p
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|b
decl_stmt|,
name|o
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|NODE
modifier|*
name|f
decl_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|f
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
comment|/* have to free this subtree later */
comment|/* init base */
switch|switch
condition|(
name|q
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ICON
case|:
case|case
name|REG
case|:
case|case
name|OREG
case|:
name|t
operator|=
name|q
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|q
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|=
operator|-
name|q
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
case|case
name|PLUS
case|:
name|t
operator|=
name|q
operator|->
name|in
operator|.
name|right
expr_stmt|;
break|break;
case|case
name|UNARY
name|MUL
case|:
name|t
operator|=
name|q
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"illegal makeor2"
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|t
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHNAM
condition|;
operator|++
name|i
control|)
name|p
operator|->
name|in
operator|.
name|name
index|[
name|i
index|]
operator|=
name|t
operator|->
name|in
operator|.
name|name
index|[
name|i
index|]
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|in
operator|.
name|name
operator|=
name|t
operator|->
name|in
operator|.
name|name
expr_stmt|;
endif|#
directive|endif
comment|/* init offset */
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|R2PACK
argument_list|(
operator|(
name|b
operator|&
literal|0177
operator|)
argument_list|,
name|o
argument_list|,
operator|(
name|b
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|tfree
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|canaddr
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|REG
operator|||
name|o
operator|==
name|ICON
operator|||
name|o
operator|==
name|OREG
operator|||
operator|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|shltype
end_ifndef

begin_expr_stmt
name|shltype
argument_list|(
name|o
argument_list|,
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|o
operator|==
name|REG
operator|||
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|ICON
operator|||
name|o
operator|==
name|OREG
operator|||
operator|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|flshape
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|REG
operator|||
name|o
operator|==
name|ICON
operator|||
name|o
operator|==
name|OREG
operator|||
operator|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|shtemp
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STARG
condition|)
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|NAME
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
operator|||
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|shumul
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|o
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
block|{
name|printf
argument_list|(
literal|"\nshumul:op=%d,lop=%d,rop=%d"
argument_list|,
name|p
operator|->
name|in
operator|.
name|op
argument_list|,
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" prname=%s,plty=%d, prlval=%D\n"
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
argument_list|,
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
block|}
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|==
name|NAME
operator|||
operator|(
name|o
operator|==
name|OREG
operator|&&
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|)
operator|||
name|o
operator|==
name|ICON
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|type
operator|!=
name|PTR
operator|+
name|DOUBLE
condition|)
return|return
operator|(
name|STARNM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|special
argument_list|(
name|p
argument_list|,
name|shape
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|shape
operator|==
name|SIREG
operator|&&
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
operator|&&
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|adrcon
argument_list|(
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|CONSZ
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
name|ACONFMT
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|conput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ICON
case|:
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|putstr
argument_list|(
name|rname
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|cerror
argument_list|(
literal|"illegal conput"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|insput
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cerror
argument_list|(
literal|"insput"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|adrput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|r
decl_stmt|;
comment|/* output an address, with offsets, from p */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|FLD
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|NAME
case|:
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|ICON
case|:
comment|/* addressable value of the constant */
name|putchar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|putstr
argument_list|(
name|rname
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
comment|/* for entry mask */
operator|(
name|void
operator|)
name|rname
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|OREG
case|:
name|r
operator|=
name|p
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
if|if
condition|(
name|R2TEST
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* double indexing */
specifier|register
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|R2UPK3
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|!=
literal|0
operator|||
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
operator|!=
literal|100
condition|)
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|rname
argument_list|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%s]"
argument_list|,
name|rname
argument_list|(
name|R2UPK2
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r
operator|==
name|FP
operator|&&
name|p
operator|->
name|tn
operator|.
name|lval
operator|>
literal|0
condition|)
block|{
comment|/* in the argument region */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|werror
argument_list|(
literal|"bad arg temp"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"(fp)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|!=
literal|0
operator|||
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|rname
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNARY
name|MUL
case|:
comment|/* STARNM or STARREG found */
if|if
condition|(
name|tshape
argument_list|(
name|p
argument_list|,
name|STARNM
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|cerror
argument_list|(
literal|"illegal address"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|acon
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* print out a constant */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|FLEXNAMES
name|printf
argument_list|(
literal|"%.8s"
argument_list|,
name|p
operator|->
name|in
operator|.
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|putstr
argument_list|(
name|p
operator|->
name|in
operator|.
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|!=
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|genscall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* structure valued call */
return|return
operator|(
name|gencall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|genfcall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
specifier|static
name|char
modifier|*
name|funcops
index|[
literal|6
index|]
init|=
block|{
literal|"sin"
block|,
literal|"cos"
block|,
literal|"sqrt"
block|,
literal|"exp"
block|,
literal|"log"
block|,
literal|"atan"
block|}
decl_stmt|;
comment|/* generate function opcodes */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|FORTCALL
operator|&&
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|&&
operator|(
name|p1
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|)
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p1
operator|->
name|tn
operator|.
name|lval
operator|==
literal|0
operator|&&
name|p1
operator|->
name|in
operator|.
name|type
operator|==
name|INCREF
argument_list|(
name|FTN
operator||
name|FLOAT
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|FLEXNAMES
name|p1
operator|->
name|in
operator|.
name|name
operator|++
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|p1
operator|->
name|in
operator|.
name|name
argument_list|,
name|p1
operator|->
name|in
operator|.
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
literal|6
condition|;
name|m
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p1
operator|->
name|in
operator|.
name|name
argument_list|,
name|funcops
index|[
name|m
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|m
operator|>=
literal|6
condition|)
name|uerror
argument_list|(
literal|"no opcode for fortarn function %s"
argument_list|,
name|p1
operator|->
name|in
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|uerror
argument_list|(
literal|"illegal type of fortarn function"
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FORTCALL
expr_stmt|;
if|if
condition|(
operator|!
name|canaddr
argument_list|(
name|p1
argument_list|)
condition|)
name|order
argument_list|(
name|p1
argument_list|,
name|INAREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|STARREG
operator||
name|STARNM
argument_list|)
expr_stmt|;
name|m
operator|=
name|match
argument_list|(
name|p
argument_list|,
name|INTAREG
operator||
name|INTBREG
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|!=
name|MDONE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* tbl */
end_comment

begin_decl_stmt
name|int
name|gc_numbytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tbl */
end_comment

begin_expr_stmt
name|gencall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* generate the call given by p */
specifier|register
name|NODE
modifier|*
name|p1
decl_stmt|,
modifier|*
name|ptemp
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|,
name|temp1
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
condition|)
name|temp
operator|=
name|argsize
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STCALL
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|STCALL
condition|)
block|{
comment|/* set aside room for structure return */
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stsize
operator|>
name|temp
condition|)
name|temp1
operator|=
name|p
operator|->
name|stn
operator|.
name|stsize
expr_stmt|;
else|else
name|temp1
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|>
name|maxargs
condition|)
name|maxargs
operator|=
name|temp
expr_stmt|;
name|SETOFF
argument_list|(
name|temp1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
condition|)
block|{
comment|/* make temp node, put offset in, and generate args */
name|ptemp
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|ptemp
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|ptemp
operator|->
name|tn
operator|.
name|lval
operator|=
operator|-
literal|1
expr_stmt|;
name|ptemp
operator|->
name|tn
operator|.
name|rval
operator|=
name|SP
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|ptemp
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|ptemp
operator|->
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
name|ptemp
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|ptemp
operator|->
name|in
operator|.
name|su
operator|=
literal|0
expr_stmt|;
name|genargs
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|ptemp
argument_list|)
expr_stmt|;
name|ptemp
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
block|}
name|p1
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|ICON
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|REG
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|OREG
operator|||
name|R2TEST
argument_list|(
name|p1
operator|->
name|tn
operator|.
name|rval
argument_list|)
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|NAME
condition|)
block|{
name|order
argument_list|(
name|p1
argument_list|,
name|INAREG
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* tbl 	setup gc_numbytes so reference to ZC works */
name|gc_numbytes
operator|=
name|temp
operator|&
operator|(
literal|0x3ff
operator|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|UNARY
name|CALL
expr_stmt|;
name|m
operator|=
name|match
argument_list|(
name|p
argument_list|,
name|INTAREG
operator||
name|INTBREG
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|!=
name|MDONE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* tbl */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ccbranches
index|[]
init|=
block|{
literal|"eql"
block|,
literal|"neq"
block|,
literal|"leq"
block|,
literal|"lss"
block|,
literal|"geq"
block|,
literal|"gtr"
block|,
literal|"lequ"
block|,
literal|"lssu"
block|,
literal|"gequ"
block|,
literal|"gtru"
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tbl */
end_comment

begin_macro
name|cbgen
argument_list|(
argument|o
argument_list|,
argument|lab
argument_list|,
argument|mode
argument_list|)
end_macro

begin_block
block|{
comment|/*   printf conditional and unconditional branches */
if|if
condition|(
name|o
operator|!=
literal|0
operator|&&
operator|(
name|o
operator|<
name|EQ
operator|||
name|o
operator|>
name|UGT
operator|)
condition|)
name|cerror
argument_list|(
literal|"bad conditional branch: %s"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	j%s	L%d\n"
argument_list|,
name|o
operator|==
literal|0
condition|?
literal|"br"
else|:
name|ccbranches
index|[
name|o
operator|-
name|EQ
index|]
argument_list|,
name|lab
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|nextcook
argument_list|(
argument|p
argument_list|,
argument|cookie
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* we have failed to match p with cookie; try another */
if|if
condition|(
name|cookie
operator|==
name|FORREW
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hopeless! */
if|if
condition|(
operator|!
operator|(
name|cookie
operator|&
operator|(
name|INTAREG
operator||
name|INTBREG
operator|)
operator|)
condition|)
return|return
operator|(
name|INTAREG
operator||
name|INTBREG
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|cookie
operator|&
name|INTEMP
operator|)
operator|&&
name|asgop
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
condition|)
return|return
operator|(
name|INTEMP
operator||
name|INAREG
operator||
name|INTAREG
operator||
name|INTBREG
operator||
name|INBREG
operator|)
return|;
return|return
operator|(
name|FORREW
operator|)
return|;
block|}
end_block

begin_macro
name|lastchance
argument_list|(
argument|p
argument_list|,
argument|cook
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* forget it! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|optim2
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|ONEPASS
comment|/* do local tree transformations and optimizations */
define|#
directive|define
name|RV
parameter_list|(
name|p
parameter_list|)
value|p->in.right->tn.lval
define|#
directive|define
name|nncon
parameter_list|(
name|p
parameter_list|)
value|((p)->in.op == ICON&& (p)->in.name[0] == 0)
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* change unsigned mods and divs to logicals (mul is done in mip& c2) */
if|if
condition|(
name|optype
argument_list|(
name|o
argument_list|)
operator|==
name|BITYPE
operator|&&
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
operator|&&
name|nncon
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|ispow2
argument_list|(
name|RV
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|DIV
case|:
case|case
name|ASG
name|DIV
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|RS
expr_stmt|;
name|RV
argument_list|(
name|p
argument_list|)
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|MOD
case|:
case|case
name|ASG
name|MOD
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|AND
expr_stmt|;
name|RV
argument_list|(
name|p
argument_list|)
operator|--
expr_stmt|;
break|break;
default|default:
return|return;
block|}
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ASG
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_struct
struct|struct
name|functbl
block|{
name|int
name|fop
decl_stmt|;
name|char
modifier|*
name|func
decl_stmt|;
block|}
name|opfunc
index|[]
init|=
block|{
name|DIV
block|,
literal|"udiv"
block|,
name|ASG
name|DIV
block|,
literal|"udiv"
block|,
literal|0
block|}
struct|;
end_struct

begin_expr_stmt
name|hardops
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* change hard to do operators into function calls.  */
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|functbl
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|o
decl_stmt|;
specifier|register
name|TWORD
name|t
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
for|for
control|(
name|f
operator|=
name|opfunc
init|;
name|f
operator|->
name|fop
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|o
operator|==
name|f
operator|->
name|fop
condition|)
goto|goto
name|convert
goto|;
block|}
return|return;
name|convert
label|:
name|t
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|t1
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|t2
operator|=
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|ISUNSIGNED
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
operator|(
name|ISUNSIGNED
argument_list|(
name|t2
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|t2
operator|==
name|UNSIGNED
operator|)
operator|)
condition|)
return|return;
comment|/* need to rewrite tree for ASG OP */
comment|/* must change ASG OP to a simple OP */
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|NOASG
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|tcopy
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|right
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|q
expr_stmt|;
name|zappost
argument_list|(
name|q
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
comment|/* remove post-INCR(DECR) from new node */
name|fixpre
argument_list|(
name|q
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
comment|/* change pre-INCR(DECR) to +/-	*/
name|p
operator|=
name|q
expr_stmt|;
block|}
comment|/* turn logicals to compare 0 */
elseif|else
if|if
condition|(
name|logop
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|ncopy
argument_list|(
name|q
operator|=
name|talloc
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|q
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|tn
operator|.
name|rval
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
comment|/* build comma op for args to function */
name|t1
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|t2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|optype
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
operator|==
name|BITYPE
condition|)
block|{
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|CM
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|right
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|t2
operator|=
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
expr_stmt|;
block|}
else|else
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|CALL
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|q
expr_stmt|;
comment|/* put function name in left node of call */
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|INCREF
argument_list|(
name|FTN
operator|+
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|strcpy
argument_list|(
name|q
operator|->
name|in
operator|.
name|name
argument_list|,
name|f
operator|->
name|func
argument_list|)
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|in
operator|.
name|name
operator|=
name|f
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|tn
operator|.
name|rval
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|zappost
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* look for ++ and -- operators and remove them */
specifier|register
name|int
name|o
decl_stmt|,
name|ty
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|INCR
case|:
case|case
name|DECR
case|:
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
comment|/* zap constant */
name|ncopy
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|zappost
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|!=
name|LTYPE
condition|)
name|zappost
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fixpre
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|o
decl_stmt|,
name|ty
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|ASG
name|PLUS
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|PLUS
expr_stmt|;
break|break;
case|case
name|ASG
name|MINUS
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|MINUS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|fixpre
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|!=
name|LTYPE
condition|)
name|fixpre
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|NODE
modifier|*
name|addroreg
parameter_list|(
name|l
parameter_list|)
name|NODE
modifier|*
name|l
decl_stmt|;
comment|/* OREG was built in clocal() 				 * for an auto or formal parameter 				 * now its address is being taken 				 * local code must unwind it 				 * back to PLUS/MINUS REG ICON 				 * according to local conventions 				 */
block|{
name|cerror
argument_list|(
literal|"address of OREG taken"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ONEPASS
end_ifndef

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
return|return
operator|(
name|mainp2
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|myreader
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|walkf
argument_list|(
name|p
argument_list|,
name|hardops
argument_list|)
expr_stmt|;
comment|/* convert ops to function calls */
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* expands r-vals for fileds */
name|walkf
argument_list|(
name|p
argument_list|,
name|optim2
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

