begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)local.c	1.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pass1.h"
end_include

begin_comment
comment|/*	this file contains code which is dependent on the target machine */
end_comment

begin_function
name|NODE
modifier|*
name|clocal
parameter_list|(
name|p
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* this is called to do local transformations on 	   an expression tree preparitory to its being 	   written out in intermediate code. 	*/
comment|/* the major essential job is rewriting the 	   automatic variables and arguments in terms of 	   REG and OREG nodes */
comment|/* conversion ops which are not necessary are also clobbered here */
comment|/* in addition, any special features (such as rewriting 	   exclusive or) are easily handled here as well */
specifier|register
name|struct
name|symtab
modifier|*
name|q
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|;
specifier|register
name|int
name|o
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|,
name|ml
decl_stmt|;
switch|switch
condition|(
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|NAME
case|:
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|<
literal|0
condition|)
block|{
comment|/* already processed; ignore... */
return|return
operator|(
name|p
operator|)
return|;
block|}
name|q
operator|=
operator|&
name|stab
index|[
name|p
operator|->
name|tn
operator|.
name|rval
index|]
expr_stmt|;
switch|switch
condition|(
name|q
operator|->
name|sclass
condition|)
block|{
case|case
name|AUTO
case|:
case|case
name|PARAM
case|:
comment|/* fake up a structure reference */
name|r
operator|=
name|block
argument_list|(
name|REG
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|PTR
operator|+
name|STRTY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|rval
operator|=
name|STKREG
expr_stmt|;
name|p
operator|=
name|stref
argument_list|(
name|block
argument_list|(
name|STREF
argument_list|,
name|r
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ULABEL
case|:
case|case
name|LABEL
case|:
case|case
name|STATIC
case|:
if|if
condition|(
name|q
operator|->
name|slevel
operator|==
literal|0
condition|)
break|break;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
operator|-
name|q
operator|->
name|offset
expr_stmt|;
break|break;
case|case
name|REGISTER
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|REG
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|q
operator|->
name|offset
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_CHAR
name|m
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|CHAR
operator|||
name|m
operator|==
name|SHORT
condition|)
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|==
name|UCHAR
operator|||
name|m
operator|==
name|USHORT
condition|)
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|UNSIGNED
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
break|break;
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
if|if
condition|(
name|ISPTR
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
operator|||
name|ISPTR
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|op
operator|+=
operator|(
name|ULT
operator|-
name|LT
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|PCONV
case|:
comment|/* do pointer conversions for char and longs */
name|ml
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|ml
operator|==
name|CHAR
operator|||
name|ml
operator|==
name|UCHAR
operator|||
name|ml
operator|==
name|SHORT
operator|||
name|ml
operator|==
name|USHORT
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|!=
name|ICON
condition|)
break|break;
comment|/* pointers all have the same representation; the type is inherited */
name|inherit
label|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|fn
operator|.
name|cdim
operator|=
name|p
operator|->
name|fn
operator|.
name|cdim
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|fn
operator|.
name|csiz
operator|=
name|p
operator|->
name|fn
operator|.
name|csiz
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|)
return|;
case|case
name|SCONV
case|:
name|m
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|ml
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|FLOAT
operator|||
name|m
operator|==
name|DOUBLE
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
operator|&&
name|ml
operator|==
name|DOUBLE
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|m
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|FCON
condition|)
goto|goto
name|inherit
goto|;
break|break;
block|}
if|if
condition|(
name|ml
operator|==
name|FLOAT
operator|||
name|ml
operator|==
name|DOUBLE
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|FCON
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|fpn
operator|.
name|fval
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|NONAME
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
break|break;
block|}
comment|/* now, look for conversions downwards */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
block|{
comment|/* simulate the conversion here */
name|CONSZ
name|val
decl_stmt|;
name|val
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
switch|switch
condition|(
name|m
condition|)
block|{
case|case
name|CHAR
case|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
break|break;
case|case
name|UCHAR
case|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
operator|=
name|val
operator|&
literal|0XFF
expr_stmt|;
break|break;
case|case
name|USHORT
case|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
operator|=
name|val
operator|&
literal|0XFFFFL
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
operator|=
operator|(
name|short
operator|)
name|val
expr_stmt|;
break|break;
case|case
name|UNSIGNED
case|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
operator|=
name|val
operator|&
literal|0xFFFFFFFFL
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|lval
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
comment|/* meaningful ones are conversion of int to char, int to short, 			   and short to char, and unsigned versions thereof */
if|if
condition|(
name|m
operator|==
name|CHAR
operator|||
name|m
operator|==
name|UCHAR
condition|)
block|{
if|if
condition|(
name|ml
operator|!=
name|CHAR
operator|&&
name|ml
operator|!=
name|UCHAR
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|SHORT
operator|||
name|m
operator|==
name|USHORT
condition|)
block|{
if|if
condition|(
name|ml
operator|!=
name|CHAR
operator|&&
name|ml
operator|!=
name|UCHAR
operator|&&
name|ml
operator|!=
name|SHORT
operator|&&
name|ml
operator|!=
name|USHORT
condition|)
break|break;
block|}
block|}
comment|/* clobber conversion */
if|if
condition|(
name|tlen
argument_list|(
name|p
argument_list|)
operator|==
name|tlen
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
condition|)
goto|goto
name|inherit
goto|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|)
return|;
comment|/* conversion gets clobbered */
case|case
name|QUEST
case|:
comment|/* the right side should be COLON */
if|if
condition|(
operator|(
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
operator|)
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|r
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|r
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|left
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
name|p
operator|)
return|;
case|case
name|PVCONV
case|:
case|case
name|PMCONV
case|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|!=
name|ICON
condition|)
name|cerror
argument_list|(
literal|"bad conversion"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|buildtree
argument_list|(
name|o
operator|==
name|PMCONV
condition|?
name|MUL
else|:
name|DIV
argument_list|,
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
name|FLD
case|:
comment|/* make sure that the second pass does not make the 		   descendant of a FLD operator into a doubly indexed OREG */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
operator|&&
operator|(
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
operator|)
operator|->
name|in
operator|.
name|op
operator|==
name|PCONV
condition|)
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|PLUS
operator|||
name|r
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|MINUS
condition|)
if|if
condition|(
name|ISPTR
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|=
name|UNSIGNED
expr_stmt|;
else|else
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
block|}
break|break;
case|case
name|FORTCALL
case|:
comment|/* arg must be FLOAT */
if|if
condition|(
operator|(
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
operator|)
operator|->
name|in
operator|.
name|type
operator|!=
name|FLOAT
condition|)
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|clocal
argument_list|(
name|makety
argument_list|(
name|r
argument_list|,
name|FLOAT
argument_list|,
literal|0
argument_list|,
name|FLOAT
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* if both sides are FLOAT, so is the op */
if|if
condition|(
name|optype
argument_list|(
name|o
argument_list|)
operator|!=
name|LTYPE
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|&&
operator|(
name|o
operator|==
name|UNARY
name|MINUS
operator|||
name|optype
argument_list|(
name|o
argument_list|)
operator|==
name|BITYPE
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|)
condition|)
block|{
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
operator|&&
name|r
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
block|{
if|if
condition|(
name|optype
argument_list|(
name|o
argument_list|)
operator|==
name|BITYPE
condition|)
block|{
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
operator|&&
name|r
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
block|{
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|r
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|FCON
condition|)
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|FLOAT
expr_stmt|;
else|else
return|return
operator|(
name|p
operator|)
return|;
block|}
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|r
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype
argument_list|(
name|o
argument_list|)
operator|==
name|BITYPE
operator|&&
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|FCON
condition|)
block|{
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
operator|&&
name|r
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|r
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|=
name|FLOAT
expr_stmt|;
block|}
else|else
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|FLOAT
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|left
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
else|else
block|{
comment|/* usually logop */
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|andable
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* all names can have& taken on them */
block|}
end_block

begin_macro
name|cendarg
argument_list|()
end_macro

begin_block
block|{
comment|/* at the end of the arguments of a ftn, set the automatic offset */
name|autooff
operator|=
name|AUTOINIT
expr_stmt|;
block|}
end_block

begin_macro
name|cisreg
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* is an automatic variable of type t OK for a register variable */
if|if
condition|(
name|t
operator|==
name|INT
operator|||
name|t
operator|==
name|UNSIGNED
operator|||
name|t
operator|==
name|LONG
operator|||
name|t
operator|==
name|ULONG
comment|/* tbl */
ifdef|#
directive|ifdef
name|REG_CHAR
operator|||
name|t
operator|==
name|CHAR
operator|||
name|t
operator|==
name|UCHAR
operator|||
name|t
operator|==
name|SHORT
operator|||
name|t
operator|==
name|USHORT
comment|/* tbl */
endif|#
directive|endif
operator|||
name|ISPTR
argument_list|(
name|t
argument_list|)
operator|||
name|t
operator|==
name|FLOAT
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* wnj */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|NODE
modifier|*
name|offcon
parameter_list|(
name|off
parameter_list|,
name|t
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
name|OFFSZ
name|off
decl_stmt|;
name|TWORD
name|t
decl_stmt|;
block|{
comment|/* return a node, for structure references, which is suitable for 	   being added to a pointer of type t, in order to be off bits offset 	   into a structure */
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
comment|/* t, d, and s are the type, dimension offset, and sizeoffset */
comment|/* in general they  are necessary for offcon, but not on H'well */
name|p
operator|=
name|bcon
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|off
operator|/
name|SZCHAR
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|inwd
comment|/* current bit offsed in word */
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|CONSZ
name|word
comment|/* word being built from fields */
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|incode
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* generate initialization code for assigning a constant c 		to a field of width sz */
comment|/* we assume that the proper alignment has been obtained */
comment|/* inoff is updated to have the proper final value */
comment|/* we also assume sz< SZINT */
name|inwd
operator|+=
name|sz
expr_stmt|;
if|if
condition|(
name|inwd
operator|>
name|SZINT
condition|)
name|cerror
argument_list|(
literal|"incode: field> int"
argument_list|)
expr_stmt|;
name|word
operator||=
operator|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|&
operator|(
operator|(
literal|1L
operator|<<
name|sz
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|SZINT
operator|-
name|inwd
operator|)
expr_stmt|;
name|inoff
operator|+=
name|sz
expr_stmt|;
if|if
condition|(
name|inoff
operator|%
name|SZINT
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"	.long	0x%X\n"
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|word
operator|=
name|inwd
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|fincode
argument_list|(
argument|d
argument_list|,
argument|sz
argument_list|)
end_macro

begin_decl_stmt
name|double
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|sz
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * output code to initialize space of size sz to the value d 	 * the proper alignment has been obtained 	 * inoff is updated to have the proper final value. 	 */
specifier|register
struct|struct
name|sh4
block|{
name|unsigned
name|short
name|sh
index|[
literal|4
index|]
decl_stmt|;
block|}
modifier|*
name|x
struct|;
name|float
name|f
decl_stmt|;
if|if
condition|(
name|sz
operator|==
name|SZFLOAT
condition|)
block|{
comment|/* force rounding */
name|f
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|f
expr_stmt|;
block|}
name|x
operator|=
operator|(
expr|struct
name|sh4
operator|*
operator|)
operator|&
name|d
expr_stmt|;
name|printf
argument_list|(
literal|"	.long	0x%04x%04x"
argument_list|,
name|x
operator|->
name|sh
index|[
literal|0
index|]
argument_list|,
name|x
operator|->
name|sh
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|==
name|SZDOUBLE
condition|)
block|{
name|printf
argument_list|(
literal|", 0x%04x%04x"
argument_list|,
name|x
operator|->
name|sh
index|[
literal|2
index|]
argument_list|,
name|x
operator|->
name|sh
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" # .double %.17g\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|" # .float %.8g\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|inoff
operator|+=
name|sz
expr_stmt|;
block|}
end_block

begin_macro
name|cinit
argument_list|(
argument|p
argument_list|,
argument|sz
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|NODE
modifier|*
name|l
decl_stmt|;
comment|/* 	 * as a favor (?) to people who want to write 	 *     int i = 9600/134.5; 	 * we will, under the proper circumstances, do 	 * a coersion here. 	 */
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|INT
case|:
case|case
name|UNSIGNED
case|:
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|op
operator|!=
name|SCONV
operator|||
operator|(
name|l
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|op
operator|!=
name|DCON
operator|&&
name|l
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|op
operator|!=
name|FCON
operator|)
condition|)
break|break;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|l
operator|=
name|l
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|l
operator|->
name|tn
operator|.
name|lval
operator|=
name|l
operator|->
name|tn
operator|.
name|op
operator|==
name|DCON
condition|?
call|(
name|long
call|)
argument_list|(
name|l
operator|->
name|dpn
operator|.
name|dval
argument_list|)
else|:
call|(
name|long
call|)
argument_list|(
name|l
operator|->
name|fpn
operator|.
name|fval
argument_list|)
expr_stmt|;
name|l
operator|->
name|tn
operator|.
name|rval
operator|=
name|NONAME
expr_stmt|;
name|l
operator|->
name|tn
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
name|l
operator|->
name|tn
operator|.
name|type
operator|=
name|INT
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|l
expr_stmt|;
break|break;
block|}
comment|/* arrange for the initialization of p into a space of 	size sz */
comment|/* the proper alignment has been opbtained */
comment|/* inoff is updated to have the proper final value */
name|ecode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|inoff
operator|+=
name|sz
expr_stmt|;
block|}
end_block

begin_macro
name|vfdzero
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* define n bits of zeros in a vfd */
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return;
name|inwd
operator|+=
name|n
expr_stmt|;
name|inoff
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|inoff
operator|%
name|ALINT
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"	.long	0x%X\n"
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|word
operator|=
name|inwd
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|exname
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
comment|/* make a name look like an external name in the local machine */
ifndef|#
directive|ifndef
name|FLEXNAMES
specifier|static
name|char
name|text
index|[
name|NCHNAM
operator|+
literal|1
index|]
decl_stmt|;
else|#
directive|else
specifier|static
name|char
name|text
index|[
name|BUFSIZ
operator|+
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|i
decl_stmt|;
name|text
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|*
name|p
operator|&&
name|i
operator|<
name|NCHNAM
condition|;
operator|++
name|i
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|*
name|p
condition|;
operator|++
name|i
control|)
endif|#
directive|endif
name|text
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|text
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|text
index|[
name|NCHNAM
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* truncate */
endif|#
directive|endif
return|return
operator|(
name|text
operator|)
return|;
block|}
end_function

begin_macro
name|ctype
argument_list|(
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* map types which are not defined on the local machine */
switch|switch
condition|(
name|BTYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|LONG
case|:
name|MODTYPE
argument_list|(
name|type
argument_list|,
name|INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|ULONG
case|:
name|MODTYPE
argument_list|(
name|type
argument_list|,
name|UNSIGNED
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_block

begin_macro
name|noinit
argument_list|()
end_macro

begin_block
block|{
comment|/* curid is a variable which is defined but 	is not initialized (and not a function ); 	This routine returns the stroage class for an uninitialized declaration */
return|return
operator|(
name|EXTERN
operator|)
return|;
block|}
end_block

begin_macro
name|commdec
argument_list|(
argument|id
argument_list|)
end_macro

begin_block
block|{
comment|/* make a common declaration for id, if reasonable */
specifier|register
name|struct
name|symtab
modifier|*
name|q
decl_stmt|;
name|OFFSZ
name|off
decl_stmt|,
name|tsize
argument_list|()
decl_stmt|;
name|q
operator|=
operator|&
name|stab
index|[
name|id
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"	.comm	%s,"
argument_list|,
name|exname
argument_list|(
name|q
operator|->
name|sname
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|=
name|tsize
argument_list|(
name|q
operator|->
name|stype
argument_list|,
name|q
operator|->
name|dimoff
argument_list|,
name|q
operator|->
name|sizoff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d\n"
comment|/*CONFMT*/
argument_list|,
name|off
operator|/
name|SZCHAR
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|prtdcon
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|o
operator|!=
name|DCON
operator|&&
name|o
operator|!=
name|FCON
condition|)
return|return;
comment|/* 	 * Clobber constants of value zero so 	 * we can generate more efficient code. 	 */
if|if
condition|(
operator|(
name|o
operator|==
name|DCON
operator|&&
name|p
operator|->
name|dpn
operator|.
name|dval
operator|==
literal|0
operator|)
operator|||
operator|(
name|o
operator|==
name|FCON
operator|&&
name|p
operator|->
name|fpn
operator|.
name|fval
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|NONAME
expr_stmt|;
return|return;
block|}
name|locctr
argument_list|(
name|DATA
argument_list|)
expr_stmt|;
name|defalign
argument_list|(
name|o
operator|==
name|DCON
condition|?
name|ALDOUBLE
else|:
name|ALFLOAT
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|i
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|FCON
condition|)
name|fincode
argument_list|(
name|p
operator|->
name|fpn
operator|.
name|fval
argument_list|,
name|SZFLOAT
argument_list|)
expr_stmt|;
else|else
name|fincode
argument_list|(
name|p
operator|->
name|dpn
operator|.
name|dval
argument_list|,
name|SZDOUBLE
argument_list|)
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
operator|-
name|i
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|type
operator|=
operator|(
name|o
operator|==
name|DCON
condition|?
name|DOUBLE
else|:
name|FLOAT
operator|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|NAME
expr_stmt|;
block|}
end_block

begin_macro
name|isitfloat
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
union|union
name|cvt
block|{
name|double
name|d
decl_stmt|;
name|int
name|n
index|[
literal|2
index|]
decl_stmt|;
block|}
name|cvt
union|;
name|double
name|atof
parameter_list|()
function_decl|;
comment|/* avoid floating point exception for double -> float conversions */
name|dcon
operator|=
name|cvt
operator|.
name|d
operator|=
name|atof
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvt
operator|.
name|n
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|fcon
operator|=
name|dcon
expr_stmt|;
return|return
operator|(
name|FCON
operator|)
return|;
block|}
return|return
operator|(
name|DCON
operator|)
return|;
block|}
end_block

begin_macro
name|ecode
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* walk the tree and write out the nodes.. */
if|if
condition|(
name|nerrors
condition|)
return|return;
name|p2tree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p2compile
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|ONEPASS
end_ifndef

begin_macro
name|tlen
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
name|DOUBLE
case|:
return|return
operator|(
literal|8
operator|)
return|;
default|default:
return|return
operator|(
literal|4
operator|)
return|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

