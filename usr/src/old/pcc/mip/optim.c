begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)optim.c	4.5 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"pass1.h"
end_include

begin_define
define|#
directive|define
name|SWAP
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
value|{sp=p; p=q; q=sp;}
end_define

begin_define
define|#
directive|define
name|RCON
parameter_list|(
name|p
parameter_list|)
value|(p->in.right->in.op==ICON)
end_define

begin_define
define|#
directive|define
name|RO
parameter_list|(
name|p
parameter_list|)
value|p->in.right->in.op
end_define

begin_define
define|#
directive|define
name|RV
parameter_list|(
name|p
parameter_list|)
value|p->in.right->tn.lval
end_define

begin_define
define|#
directive|define
name|LCON
parameter_list|(
name|p
parameter_list|)
value|(p->in.left->in.op==ICON)
end_define

begin_define
define|#
directive|define
name|LO
parameter_list|(
name|p
parameter_list|)
value|p->in.left->in.op
end_define

begin_define
define|#
directive|define
name|LV
parameter_list|(
name|p
parameter_list|)
value|p->in.left->tn.lval
end_define

begin_decl_stmt
name|int
name|oflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|NODE
modifier|*
name|fortarg
parameter_list|(
name|p
parameter_list|)
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* fortran function arguments */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|CM
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|fortarg
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|fortarg
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
while|while
condition|(
name|ISPTR
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
block|{
name|p
operator|=
name|buildtree
argument_list|(
argument|UNARY MUL
argument_list|,
argument|p
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|optim
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mapping relationals when the sides are reversed */
end_comment

begin_decl_stmt
name|short
name|revrel
index|[]
init|=
block|{
name|EQ
block|,
name|NE
block|,
name|GE
block|,
name|GT
block|,
name|LE
block|,
name|LT
block|,
name|UGE
block|,
name|UGT
block|,
name|ULE
block|,
name|ULT
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|NODE
modifier|*
name|optim
parameter_list|(
name|p
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* local optimizations, most of which are probably machine independent */
specifier|register
name|o
operator|,
name|ty
expr_stmt|;
name|NODE
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TWORD
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|BTYPE
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|)
operator|==
name|ENUMTY
operator|||
name|t
operator|==
name|MOETY
condition|)
name|econvert
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|oflag
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|ty
operator|=
name|optype
argument_list|(
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|LTYPE
condition|)
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|optim
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|optim
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
comment|/* collect constants */
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|SCONV
case|:
case|case
name|PCONV
case|:
return|return
operator|(
name|clocal
argument_list|(
name|p
argument_list|)
operator|)
return|;
case|case
name|FORTCALL
case|:
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|fortarg
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNARY
name|AND
case|:
if|if
condition|(
name|LO
argument_list|(
name|p
argument_list|)
operator|!=
name|NAME
operator|||
operator|!
name|andable
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|LO
argument_list|(
name|p
argument_list|)
operator|=
name|ICON
expr_stmt|;
name|setuleft
label|:
comment|/* paint over the type of the left hand side with the type of the top */
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|fn
operator|.
name|cdim
operator|=
name|p
operator|->
name|fn
operator|.
name|cdim
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|fn
operator|.
name|csiz
operator|=
name|p
operator|->
name|fn
operator|.
name|csiz
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|)
return|;
case|case
name|UNARY
name|MUL
case|:
if|if
condition|(
name|LO
argument_list|(
name|p
argument_list|)
operator|!=
name|ICON
condition|)
break|break;
name|LO
argument_list|(
name|p
argument_list|)
operator|=
name|NAME
expr_stmt|;
goto|goto
name|setuleft
goto|;
case|case
name|MINUS
case|:
if|if
condition|(
operator|!
name|nncon
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
condition|)
break|break;
name|RV
argument_list|(
name|p
argument_list|)
operator|=
operator|-
name|RV
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|PLUS
expr_stmt|;
case|case
name|MUL
case|:
case|case
name|PLUS
case|:
case|case
name|AND
case|:
case|case
name|OR
case|:
case|case
name|ER
case|:
comment|/* commutative ops; for now, just collect constants */
comment|/* someday, do it right */
if|if
condition|(
name|nncon
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|||
operator|(
name|LCON
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|RCON
argument_list|(
name|p
argument_list|)
operator|)
condition|)
name|SWAP
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
comment|/* make ops tower to the left, not the right */
if|if
condition|(
name|RO
argument_list|(
name|p
argument_list|)
operator|==
name|o
condition|)
block|{
name|NODE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|,
modifier|*
name|t3
decl_stmt|;
name|t1
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|sp
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|t2
operator|=
name|sp
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|t3
operator|=
name|sp
operator|->
name|in
operator|.
name|right
expr_stmt|;
comment|/* now, put together again */
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|sp
expr_stmt|;
name|sp
operator|->
name|in
operator|.
name|left
operator|=
name|t1
expr_stmt|;
name|sp
operator|->
name|in
operator|.
name|right
operator|=
name|t2
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|t3
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|==
name|PLUS
operator|&&
name|LO
argument_list|(
name|p
argument_list|)
operator|==
name|MINUS
operator|&&
name|RCON
argument_list|(
name|p
argument_list|)
operator|&&
name|RCON
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|&&
name|conval
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|MINUS
argument_list|,
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|right
argument_list|)
condition|)
block|{
name|zapleft
label|:
name|RO
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|=
name|FREE
expr_stmt|;
name|LO
argument_list|(
name|p
argument_list|)
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
if|if
condition|(
name|RCON
argument_list|(
name|p
argument_list|)
operator|&&
name|LO
argument_list|(
name|p
argument_list|)
operator|==
name|o
operator|&&
name|RCON
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|&&
name|conval
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|o
argument_list|,
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|right
argument_list|)
condition|)
block|{
goto|goto
name|zapleft
goto|;
block|}
elseif|else
if|if
condition|(
name|LCON
argument_list|(
name|p
argument_list|)
operator|&&
name|RCON
argument_list|(
name|p
argument_list|)
operator|&&
name|conval
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|o
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
condition|)
block|{
name|zapright
label|:
name|RO
argument_list|(
name|p
argument_list|)
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|makety
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|p
operator|->
name|in
operator|.
name|type
argument_list|,
name|p
operator|->
name|fn
operator|.
name|cdim
argument_list|,
name|p
operator|->
name|fn
operator|.
name|csiz
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|clocal
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|)
return|;
block|}
comment|/* change muls to shifts */
if|if
condition|(
name|o
operator|==
name|MUL
operator|&&
name|nncon
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|ispow2
argument_list|(
name|RV
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* multiplication by 1 */
goto|goto
name|zapright
goto|;
block|}
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|LS
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|fn
operator|.
name|csiz
operator|=
name|INT
expr_stmt|;
name|RV
argument_list|(
name|p
argument_list|)
operator|=
name|i
expr_stmt|;
block|}
comment|/* change +'s of negative consts back to - */
if|if
condition|(
name|o
operator|==
name|PLUS
operator|&&
name|nncon
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
operator|&&
name|RV
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|RV
argument_list|(
name|p
argument_list|)
operator|=
operator|-
name|RV
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|MINUS
expr_stmt|;
block|}
comment|/*FALLTHROUGH*/
case|case
name|RS
case|:
case|case
name|LS
case|:
comment|/* Operations with zero -- DAS 1/20/85 */
if|if
condition|(
operator|(
name|o
operator|==
name|PLUS
operator|||
name|o
operator|==
name|MINUS
operator|||
name|o
operator|==
name|OR
operator|||
name|o
operator|==
name|ER
operator|||
name|o
operator|==
name|LS
operator|||
name|o
operator|==
name|RS
operator|)
operator|&&
name|nncon
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
operator|&&
name|RV
argument_list|(
name|p
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|zapright
goto|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|nncon
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|==
literal|1
condition|)
goto|goto
name|zapright
goto|;
comment|/* Unsigned division by a power of two -- DAS 1/13/85 */
if|if
condition|(
name|nncon
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|ispow2
argument_list|(
name|RV
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
block|{
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|RS
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|fn
operator|.
name|csiz
operator|=
name|INT
expr_stmt|;
name|RV
argument_list|(
name|p
argument_list|)
operator|=
name|i
expr_stmt|;
block|}
break|break;
case|case
name|MOD
case|:
comment|/* Unsigned mod by a power of two -- DAS 1/13/85 */
if|if
condition|(
name|nncon
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|ispow2
argument_list|(
name|RV
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
block|{
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|AND
expr_stmt|;
name|RV
argument_list|(
name|p
argument_list|)
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|ULT
case|:
case|case
name|ULE
case|:
case|case
name|UGT
case|:
case|case
name|UGE
case|:
if|if
condition|(
operator|!
name|LCON
argument_list|(
name|p
argument_list|)
condition|)
break|break;
comment|/* exchange operands */
name|sp
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|sp
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|revrel
index|[
name|p
operator|->
name|in
operator|.
name|op
operator|-
name|EQ
index|]
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|ispow2
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|CONSZ
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
operator|||
operator|(
name|c
operator|&
operator|(
name|c
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|>
literal|1
condition|;
operator|++
name|i
control|)
name|c
operator|>>=
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|nncon
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* is p a constant without a name */
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|tn
operator|.
name|rval
operator|==
name|NONAME
operator|)
return|;
block|}
end_block

end_unit

