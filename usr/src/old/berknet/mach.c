begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)mach.c	4.1	(Berkeley)	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sccs id variable */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mach_sid
init|=
literal|"@(#)mach.c	1.6"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*     This file is meant to handle all the machine    dependencies in the network code.    Everything is conditionally compiled.     It can be uses w/o network stuff to simulate    v7 for other programs, too. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"mach.h"
end_include

begin_decl_stmt
name|char
name|shomedir
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debugflg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the CC and SRC machines have the submit() call */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CC
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|SRC
end_ifndef

begin_macro
name|submit
argument_list|(
argument|a
argument_list|)
end_macro

begin_block
block|{}
end_block

begin_endif
endif|#
directive|endif
endif|SRC
end_endif

begin_endif
endif|#
directive|endif
endif|CC
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FUID
end_ifdef

begin_macro
name|setgid
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
endif|FUID
end_endif

begin_comment
comment|/*     Set the owner uid/gid of a file.    On v7, this is done by the chown command    with three args - (file, uid, gid).    On Vanilla V6 this is done using the    top byte of the second parameter as the gid byte.    On Berkeley Funny uids on V6, no gid is specified. */
end_comment

begin_macro
name|mchown
argument_list|(
argument|sfn
argument_list|,
argument|uid
argument_list|,
argument|gid
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sfn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gid
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|V6
name|chown
argument_list|(
name|sfn
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
else|#
directive|else
else|V6
ifndef|#
directive|ifndef
name|FUID
name|uid
operator|=
name|uidmask
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|uid
operator|=
operator|(
operator|(
name|gid
operator|&
literal|0377
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|uid
operator|&
literal|0377
operator|)
expr_stmt|;
endif|#
directive|endif
endif|FUID
name|chown
argument_list|(
name|sfn
argument_list|,
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugflg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"chown %s to %d(%o)\n"
argument_list|,
name|sfn
argument_list|,
name|uid
argument_list|,
name|uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|V6
block|}
end_block

begin_comment
comment|/* 	SnFromuid(uid)  	The login name corresponding to uid. 	Reads the password file. 	Successive calls overwrite the static string returned. 	Returns NULL if error. */
end_comment

begin_function
name|char
modifier|*
name|SnFromUid
parameter_list|(
name|uid
parameter_list|)
specifier|register
name|int
name|uid
decl_stmt|;
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
specifier|static
name|int
name|ouid
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|char
name|oresult
index|[
literal|20
index|]
init|=
literal|""
decl_stmt|;
name|uid
operator|=
name|uidmask
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|==
name|ouid
condition|)
return|return
operator|(
name|oresult
operator|)
return|;
ifdef|#
directive|ifdef
name|HPASSWD
if|if
condition|(
name|getname
argument_list|(
name|uid
argument_list|,
name|oresult
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ouid
operator|=
name|uid
expr_stmt|;
return|return
operator|(
name|oresult
operator|)
return|;
block|}
endif|#
directive|endif
endif|HPASSWD
name|pwd
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|oresult
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|ouid
operator|=
name|uid
expr_stmt|;
return|return
operator|(
name|oresult
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|uidfromsn
argument_list|(
name|sn
argument_list|)
specifier|register
name|char
operator|*
name|sn
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|him
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
ifdef|#
directive|ifdef
name|HPASSWD
name|him
operator|=
name|getuserid
argument_list|(
name|sn
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|HPASSWD
if|if
condition|(
name|him
operator|==
operator|-
literal|1
condition|)
block|{
name|pwd
operator|=
name|getpwnam
argument_list|(
name|sn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
name|him
operator|=
name|guid
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|him
operator|)
return|;
block|}
end_block

begin_comment
comment|/* handle the regular unix and local mods difference for user id's */
end_comment

begin_comment
comment|/* this call returns the 1 word uid = to what getuid will return */
end_comment

begin_macro
name|guid
argument_list|(
argument|uid
argument_list|,
argument|gid
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|uid
decl_stmt|,
name|gid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|uid
operator|=
name|uidmask
argument_list|(
name|uid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUID
return|return
operator|(
operator|(
name|uid
operator|&
literal|0377
operator|)
operator||
operator|(
name|gid
operator|<<
literal|8
operator|)
operator|)
return|;
else|#
directive|else
else|FUID
return|return
operator|(
name|uid
operator|)
return|;
endif|#
directive|endif
endif|FUID
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|OLDTTY
end_ifdef

begin_macro
name|isatty
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|ttyn
argument_list|(
name|i
argument_list|)
operator|!=
literal|'x'
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|ttyname
parameter_list|(
name|i
parameter_list|)
block|{
comment|/* return NULL if not TTY */
name|char
name|c
decl_stmt|;
specifier|static
name|char
name|ttystr
index|[]
init|=
literal|"/dev/ttyx"
decl_stmt|;
name|c
operator|=
name|ttyn
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ttystr
index|[
literal|8
index|]
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|c
operator|==
literal|'x'
condition|?
name|NULL
else|:
name|ttystr
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|OLDTTY
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CCTTY
end_ifdef

begin_undef
undef|#
directive|undef
name|ttyname
name|(
name|)
end_undef

begin_function
name|char
modifier|*
name|myttyname
parameter_list|(
name|i
parameter_list|)
block|{
comment|/* return NULL for non tty */
specifier|static
name|char
name|s
index|[
literal|15
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ttyname
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"/dev/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ttyname
parameter_list|(
name|S
parameter_list|)
value|myttyname(S)
end_define

begin_endif
endif|#
directive|endif
endif|CCTTY
end_endif

begin_comment
comment|/* expand control chars in string s */
end_comment

begin_expr_stmt
name|expandcc
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|stemp
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return;
name|strcpy
argument_list|(
name|stemp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
name|stemp
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
operator|+
literal|0140
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* get passwd from passwdf */
end_comment

begin_macro
name|getpwdf
argument_list|(
argument|pwd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|PASSWDF
ifndef|#
directive|ifndef
name|TESTING
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|found
decl_stmt|;
name|FILE
modifier|*
name|pw
decl_stmt|;
name|debug
argument_list|(
literal|"reading passwdf\n"
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_passwd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pw
operator|=
name|fopen
argument_list|(
literal|"/etc/passwdf"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
return|return;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf1
argument_list|,
name|BUFSIZ
argument_list|,
name|pw
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|p
operator|=
name|buf1
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf1
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|pw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
return|return;
name|q
operator|=
operator|++
name|p
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|pwd
operator|->
name|pw_passwd
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* 	debug("user %s passwd %s %s",pwd->pw_name,pwd->pw_passwd); 	*/
endif|#
directive|endif
endif|TESTING
endif|#
directive|endif
endif|PASSWDF
block|}
end_block

begin_comment
comment|/* 	getutmp() 	return a pointer to the system utmp structure associated with 	terminal sttyname, e.g. "/dev/tty3" 	Is version independent-- will work on v6 systems 	return NULL if error */
end_comment

begin_function
name|struct
name|utmp
modifier|*
name|getutmp
parameter_list|(
name|sttyname
parameter_list|)
name|char
modifier|*
name|sttyname
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OLDTTY
struct|struct
name|v6utmp
block|{
name|char
name|v6ut_name
index|[
literal|8
index|]
decl_stmt|;
name|char
name|v6ut_tty
decl_stmt|;
name|char
name|v6ut_fill
decl_stmt|;
name|long
name|v6ut_time
decl_stmt|;
name|int
name|v6ut_fl1
decl_stmt|;
block|}
name|v6utmpstr
struct|;
endif|#
directive|endif
endif|OLDTTY
specifier|static
name|struct
name|utmp
name|utmpstr
decl_stmt|;
name|FILE
modifier|*
name|fdutmp
decl_stmt|;
name|debug
argument_list|(
literal|"reading utmp\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sttyname
operator|==
name|NULL
operator|||
name|sttyname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|fdutmp
operator|=
name|fopen
argument_list|(
literal|"/etc/utmp"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdutmp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifndef|#
directive|ifndef
name|OLDTTY
while|while
condition|(
name|fread
argument_list|(
operator|&
name|utmpstr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|utmpstr
argument_list|,
name|fdutmp
argument_list|)
operator|==
sizeof|sizeof
name|utmpstr
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|utmpstr
operator|.
name|ut_line
argument_list|,
name|sttyname
operator|+
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|fdutmp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|utmpstr
operator|)
return|;
block|}
else|#
directive|else
else|OLDTTY
while|while
condition|(
name|fread
argument_list|(
operator|&
name|v6utmpstr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|v6utmpstr
argument_list|,
name|fdutmp
argument_list|)
operator|==
sizeof|sizeof
name|v6utmpstr
condition|)
if|if
condition|(
name|v6utmpstr
operator|.
name|v6ut_tty
operator|==
name|sttyname
index|[
literal|8
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|utmpstr
operator|.
name|ut_name
argument_list|,
name|v6utmpstr
operator|.
name|v6ut_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|utmpstr
operator|.
name|ut_line
argument_list|,
literal|"ttyx"
argument_list|)
expr_stmt|;
name|utmpstr
operator|.
name|ut_line
index|[
literal|3
index|]
operator|=
name|v6utmpstr
operator|.
name|v6ut_tty
expr_stmt|;
name|utmpstr
operator|.
name|ut_time
operator|=
name|v6utmpstr
operator|.
name|v6ut_time
expr_stmt|;
name|fclose
argument_list|(
name|fdutmp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|utmpstr
operator|)
return|;
block|}
endif|#
directive|endif
endif|OLDTTY
name|fclose
argument_list|(
name|fdutmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    these are all the v7 routines not available on the v6 machines */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_decl_stmt
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global environment pointer */
end_comment

begin_macro
name|ioctl
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* always succeeds */
block|}
end_block

begin_function
name|long
name|atol
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|long
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|*
name|s
operator|&&
operator|*
name|s
operator|<=
literal|'9'
condition|)
name|i
operator|=
name|i
operator|*
literal|10
operator|+
operator|(
operator|*
name|s
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
name|long
name|gettime
parameter_list|()
block|{
name|long
name|tt
decl_stmt|;
name|time
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
return|return
operator|(
name|tt
operator|)
return|;
block|}
end_function

begin_function
name|long
name|getsize
parameter_list|(
name|str
parameter_list|)
name|struct
name|stat
modifier|*
name|str
decl_stmt|;
block|{
name|long
name|wk
decl_stmt|;
name|wk
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
name|str
operator|->
name|st_size0
operator|&
literal|0377
argument_list|)
operator|)
operator|<<
literal|16
expr_stmt|;
name|wk
operator|+=
call|(
name|long
call|)
argument_list|(
operator|(
name|unsigned
operator|)
name|str
operator|->
name|st_size1
argument_list|)
expr_stmt|;
return|return
operator|(
name|wk
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 	getenv("HOME")  	always returns home directory. 	returns NULL if there is error. */
end_comment

begin_function
name|char
modifier|*
name|getenv
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|shdir
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
specifier|register
name|int
name|it
decl_stmt|;
if|if
condition|(
name|shomedir
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
name|shomedir
operator|)
return|;
ifdef|#
directive|ifdef
name|BERKELEY
comment|/* hget only works on Berkeley machines */
name|it
operator|=
name|ttyn
argument_list|(
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OLDTTY
if|if
condition|(
name|it
operator|==
literal|'x'
condition|)
name|it
operator|=
name|ttyn
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|==
literal|'x'
condition|)
name|it
operator|=
name|ttyn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
literal|'x'
operator|&&
name|hget
argument_list|(
name|it
argument_list|)
operator|==
literal|0
condition|)
name|shdir
operator|=
name|hgethome
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|OLDTTY
ifdef|#
directive|ifdef
name|CCTTY
if|if
condition|(
name|it
operator|==
operator|-
literal|1
condition|)
name|it
operator|=
name|ttyn
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|==
operator|-
literal|1
condition|)
name|it
operator|=
name|ttyn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
operator|-
literal|1
operator|&&
name|hget
argument_list|(
name|it
argument_list|)
operator|==
literal|0
condition|)
name|shdir
operator|=
name|hgethome
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|OLDTTY
endif|#
directive|endif
endif|BERKELEY
if|if
condition|(
name|shdir
operator|==
name|NULL
condition|)
block|{
name|pwd
operator|=
name|PwdCurrent
argument_list|()
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
name|shdir
operator|=
name|pwd
operator|->
name|pw_dir
expr_stmt|;
block|}
if|if
condition|(
name|shdir
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|shomedir
argument_list|,
name|shdir
argument_list|)
expr_stmt|;
return|return
operator|(
name|shdir
operator|)
return|;
block|}
end_function

begin_comment
comment|/* doesn't handle split passwd files */
end_comment

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|getpwuid
argument_list|(
name|uid
argument_list|)
decl|register
name|uid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
name|uid
operator|=
name|uidmask
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|setpwent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|getpwent
argument_list|()
operator|)
operator|&&
name|guid
argument_list|(
name|p
operator|->
name|pw_uid
argument_list|,
name|p
operator|->
name|pw_gid
argument_list|)
operator|!=
name|uid
condition|)
empty_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|PASSWD
index|[]
init|=
literal|"/etc/passwd"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|EMPTY
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|pwf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|line
index|[
name|BUFSIZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|passwd
name|passwd
decl_stmt|;
end_decl_stmt

begin_macro
name|setpwent
argument_list|()
end_macro

begin_block
block|{
name|debug
argument_list|(
literal|"reading passwd\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwf
operator|==
name|NULL
condition|)
name|pwf
operator|=
name|fopen
argument_list|(
name|PASSWD
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
name|rewind
argument_list|(
name|pwf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|endpwent
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|pwf
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|pwf
argument_list|)
expr_stmt|;
name|pwf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|pwskip
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|pwf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pwf
operator|=
name|fopen
argument_list|(
name|PASSWD
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|=
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|pwf
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|passwd
operator|.
name|pw_name
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|pwskip
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|passwd
operator|.
name|pw_passwd
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|pwskip
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|passwd
operator|.
name|pw_uid
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|passwd
operator|.
name|pw_uid
operator|=
name|uidmask
argument_list|(
name|passwd
operator|.
name|pw_uid
argument_list|)
expr_stmt|;
name|p
operator|=
name|pwskip
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|passwd
operator|.
name|pw_gid
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|passwd
operator|.
name|pw_quota
operator|=
literal|0
expr_stmt|;
name|passwd
operator|.
name|pw_comment
operator|=
name|EMPTY
expr_stmt|;
name|p
operator|=
name|pwskip
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|passwd
operator|.
name|pw_gecos
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|pwskip
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|passwd
operator|.
name|pw_dir
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|pwskip
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|passwd
operator|.
name|pw_shell
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
operator|&
name|passwd
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
name|setpwent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|getpwent
argument_list|()
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|pw_name
argument_list|)
condition|)
empty_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 	getlogin()  	Return current user name by looking at /etc/utmp (calls getutmp()). 	Returns NULL if not found. */
end_comment

begin_function
name|char
modifier|*
name|getlogin
parameter_list|()
block|{
specifier|register
name|struct
name|utmp
modifier|*
name|putmp
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|sttyname
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|2
argument_list|)
condition|)
name|strcpy
argument_list|(
name|sttyname
argument_list|,
name|ttyname
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|strcpy
argument_list|(
name|sttyname
argument_list|,
name|ttyname
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
name|strcpy
argument_list|(
name|sttyname
argument_list|,
name|ttyname
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
name|putmp
operator|=
name|getutmp
argument_list|(
name|sttyname
argument_list|)
expr_stmt|;
if|if
condition|(
name|putmp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|s
operator|=
name|putmp
operator|->
name|ut_name
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|0
operator|&&
operator|*
name|s
operator|!=
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|putmp
operator|->
name|ut_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|putmp
operator|->
name|ut_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unix routine to do an "fopen" on file descriptor  * The mode has to be repeated because you can't query its  * status  */
end_comment

begin_function
name|FILE
modifier|*
name|fdopen
parameter_list|(
name|fd
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|char
modifier|*
name|mode
decl_stmt|;
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|iop
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|_lastbuf
decl_stmt|;
for|for
control|(
name|iop
operator|=
name|_iob
init|;
name|iop
operator|->
name|_flag
operator|&
operator|(
name|_IOREAD
operator||
name|_IOWRT
operator|)
condition|;
name|iop
operator|++
control|)
if|if
condition|(
name|iop
operator|>=
name|_lastbuf
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|iop
operator|->
name|_cnt
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|_file
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|*
name|mode
operator|!=
literal|'r'
condition|)
block|{
name|iop
operator|->
name|_flag
operator||=
name|_IOWRT
expr_stmt|;
if|if
condition|(
operator|*
name|mode
operator|==
literal|'a'
condition|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|iop
operator|->
name|_flag
operator||=
name|_IOREAD
expr_stmt|;
return|return
operator|(
name|iop
operator|)
return|;
block|}
end_function

begin_macro
name|system
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|status
decl_stmt|,
name|pid
decl_stmt|,
name|w
decl_stmt|;
specifier|register
name|int
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|w
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
if|if
condition|(
name|w
operator|==
operator|-
literal|1
condition|)
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|getpass
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|struct
name|sgttyb
name|ttyb
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|FILE
modifier|*
name|fi
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
name|pbuf
index|[
literal|9
index|]
decl_stmt|;
name|int
argument_list|(
operator|*
name|signal
argument_list|()
argument_list|)
argument_list|()
expr_stmt|;
name|int
function_decl|(
modifier|*
name|sig
function_decl|)
parameter_list|()
function_decl|;
comment|/*	modified because Cory needs super-user to stty /dev/tty */
if|if
condition|(
operator|(
name|fi
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fi
operator|=
name|stdin
expr_stmt|;
else|else
name|setbuf
argument_list|(
name|fi
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtty
argument_list|(
name|fileno
argument_list|(
name|fi
argument_list|)
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|pbuf
operator|)
return|;
block|}
comment|/* 	if(gtty(0,&ttyb)>= 0)fi = stdin; 	else if(gtty(2,&ttyb)>= 0)fi = stderr; 	else { 		pbuf[0] = 0; 		return(pbuf); 		} 	*/
name|sig
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|flags
operator|=
name|ttyb
operator|.
name|sg_flags
expr_stmt|;
name|ttyb
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
if|if
condition|(
name|stty
argument_list|(
name|fileno
argument_list|(
name|fi
argument_list|)
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"stty:"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pbuf
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fi
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|<
operator|&
name|pbuf
index|[
literal|8
index|]
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ttyb
operator|.
name|sg_flags
operator|=
name|flags
expr_stmt|;
name|stty
argument_list|(
name|fileno
argument_list|(
name|fi
argument_list|)
argument_list|,
operator|&
name|ttyb
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|fi
argument_list|)
expr_stmt|;
return|return
operator|(
name|pbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare strings (at most n bytes):  s1>s2:>0  s1==s2: 0  s1<s2:<0  */
end_comment

begin_expr_stmt
name|strncmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
operator|&&
operator|*
name|s1
operator|==
operator|*
name|s2
operator|++
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|n
operator|<
literal|0
condition|?
literal|0
else|:
operator|*
name|s1
operator|-
operator|*
operator|--
name|s2
operator|)
return|;
block|}
end_block

begin_comment
comment|/* set the umask, ignore in v6 */
end_comment

begin_macro
name|umask
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{}
end_block

begin_comment
comment|/*  * Return the ptr in sp at which the character c appears;  * NULL if not found  */
end_comment

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_function
name|char
modifier|*
name|index
parameter_list|(
name|sp
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
name|c
decl_stmt|;
block|{
do|do
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|c
condition|)
return|return
operator|(
name|sp
operator|)
return|;
block|}
do|while
condition|(
operator|*
name|sp
operator|++
condition|)
do|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end of non-vax v7 routines */
end_comment

begin_endif
endif|#
directive|endif
endif|V6
end_endif

begin_comment
comment|/* 	PwdCurrent()  	Read the password file and return pwd to 	entry for current user. 	Return NULL if error.  	This code is a little screwed up because of the conventions 	regarding the state of the utmp file after someone su's-- 	either to root or to another person. 	The final decision was to return getpwuid(getuid) if 	the machine has one login name per userid, 	and if there are multiple login names per userid, to 	search the passwd file for the getlogin() name and return 	the passwd file entry for that. 	If there is no utmp entry, just use the userid. 	This means that people who su on machine with multiple 	user-id's will get the passwd entry for the account recorded 	in the utmp file, not their current userid. */
end_comment

begin_function
name|struct
name|passwd
modifier|*
name|PwdCurrent
parameter_list|()
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
specifier|register
name|char
modifier|*
name|sn
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTNAMS
name|sn
operator|=
name|getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|sn
operator|!=
name|NULL
operator|&&
name|sn
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|sn
index|[
literal|0
index|]
operator|!=
literal|' '
condition|)
block|{
name|pwd
operator|=
name|getpwnam
argument_list|(
name|sn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pwd
operator|)
return|;
block|}
endif|#
directive|endif
endif|MULTNAMS
return|return
operator|(
name|getpwuid
argument_list|(
name|uidmask
argument_list|(
name|getuid
argument_list|()
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*VARARGS0*/
end_comment

begin_macro
name|debug
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|,
argument|e
argument_list|,
argument|f
argument_list|,
argument|g
argument_list|,
argument|h
argument_list|,
argument|i
argument_list|,
argument|j
argument_list|,
argument|k
argument_list|,
argument|l
argument_list|,
argument|m
argument_list|,
argument|n
argument_list|,
argument|o
argument_list|,
argument|p
argument_list|,
argument|q
argument_list|,
argument|r
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|debugflg
condition|)
block|{
name|printf
argument_list|(
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|l
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|o
argument_list|,
name|p
argument_list|,
name|q
argument_list|,
name|r
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

