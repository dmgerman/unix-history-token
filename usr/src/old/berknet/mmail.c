begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)mmail.c	4.1	(Berkeley)	9/12/82"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* sccs id variable */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mmail_sid
init|=
literal|"@(#)mmail.c	1.2"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Mmail is a berkeley network internal command.    It is executed locally by the mwrite command,    and from a remote machine by the sendberkmail command.    Its purpose is to send mail to a user on this    machine using the system mail program.  Archaic Usage:     mmail [-commandsent -timesent] fromuser frommach touser  Correct Usage:    mmail [-c commandsent] [-e timesent] [-f fromaddress] [-t toaddress]  	[-h hopcnt] [-r rc] [-z]     The mwrite command uses all the options.    The sendberkmail command does not use the commandsend, timesent and rc     options.    Timesent is time in seconds since 1901 in decimal, as returned by time().    Frommach is a multi-character name, not a single letter.    Rc is the return code (exit code>>8) of the command.  Assumptions about the system mail command: 1. We assume there is an optional argument "-r" which can be added to mail.    Mail argument format (two choices):  	mail -r fromaddress toaddress     which becomes mail from "fromaddress" instead of "network".  2. We assume that mail accepts the "-h hopcnt" flag, and passes it thru    unchanged to the sendberkmail program.  The hopcnt is incremented everytime    it passes thru mmail, so inifinite mail forwarding is detected.    Since both the from and to addresses cycle, it there is infinite looping    we simply mail to root to that effect and throw away the mail.      If this argument scheme looks flakey it is because I screwed up    in the argument design.  With the network now up to 10 machines,    I can't add another parameter to the internal commands of the network    like mmail and mwrite.  If I had used labeled parms instead of    positional parms, I would be able to add more options/info    without having to recompile all code...     exit codes: 	normally returns the exit code from the mail program  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|hopcnt
init|=
literal|0
decl_stmt|,
name|pid
decl_stmt|;
name|char
modifier|*
name|sargv
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|cmdstr
init|=
name|NULL
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|timestr
decl_stmt|,
name|fromaddress
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|toaddress
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|src
index|[
literal|20
index|]
decl_stmt|,
name|snFrom
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|snto
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|mchFrom
decl_stmt|,
name|mchto
decl_stmt|,
name|stemp
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|fisresponse
init|=
literal|0
decl_stmt|;
name|long
name|timesent
init|=
name|TIMEBASE
decl_stmt|,
name|el
decl_stmt|;
name|FILE
modifier|*
name|fdm
decl_stmt|;
name|debugflg
operator|=
name|DBV
expr_stmt|;
name|src
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* parse old format positional parms */
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|cmdstr
operator|=
name|argv
index|[
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|timesent
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|2
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fromaddress
argument_list|,
literal|"%s:%s"
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|toaddress
argument_list|,
name|argv
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|fromaddress
argument_list|,
literal|"%s:%s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|toaddress
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
comment|/* parse labeled parameters */
comment|/*  prob because of -cmd in arg1 and arg2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|0
condition|)
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
name|strcpy
argument_list|(
name|fromaddress
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cmdstr
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|timesent
operator|=
name|atol
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|strcpy
argument_list|(
name|toaddress
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|hopcnt
operator|=
name|atoi
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|strcpy
argument_list|(
name|src
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|fisresponse
operator|++
expr_stmt|;
break|break;
comment|/* it is important there be no error if an unknown 		   flag is encountered */
block|}
block|}
name|mchFrom
operator|=
name|MchSFromAddr
argument_list|(
name|snFrom
argument_list|,
name|fromaddress
argument_list|)
expr_stmt|;
comment|/* compute time send */
name|timestr
operator|=
name|ctime
argument_list|(
operator|&
name|timesent
argument_list|)
expr_stmt|;
name|timestr
index|[
name|strlen
argument_list|(
name|timestr
argument_list|)
operator|-
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|el
operator|=
name|gettime
argument_list|()
operator|-
name|timesent
expr_stmt|;
comment|/* check the hopcnt */
name|hopcnt
operator|++
expr_stmt|;
if|if
condition|(
name|hopcnt
operator|>
name|MAXHOPS
condition|)
name|hopcnterr
argument_list|(
name|toaddress
argument_list|,
name|hopcnt
argument_list|)
expr_stmt|;
comment|/* analyze the dest, if local, strip off mach name, otherwise ok */
name|mchto
operator|=
name|MchSFromAddr
argument_list|(
name|snto
argument_list|,
name|toaddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|mchto
operator|==
name|local
condition|)
name|strcpy
argument_list|(
name|toaddress
argument_list|,
name|snto
argument_list|)
expr_stmt|;
comment|/* it is important to realize that mmail is executed 	   either as root, network, or the USER! 	   So the -r option must be accepted (and possibly ignored) 	   by the mail program if the user is a reandom user.  	*/
comment|/* now we fork off a mail command. if fisresponse, then 	we are "cautious" and don't use mail forwarders */
name|fdm
operator|=
name|mailopen
argument_list|(
name|toaddress
argument_list|,
name|fromaddress
argument_list|,
name|fisresponse
argument_list|,
name|hopcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdstr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|stemp
argument_list|,
literal|", R: %s"
argument_list|,
name|src
argument_list|)
expr_stmt|;
else|else
name|stemp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|fdm
argument_list|,
literal|"Subject: \"%s\"%s, sent %s, took %s\n"
argument_list|,
name|cmdstr
argument_list|,
name|stemp
argument_list|,
name|timestr
argument_list|,
name|comptime
argument_list|(
name|el
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|n
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|n
argument_list|,
name|fdm
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mailclose
argument_list|(
name|fdm
argument_list|)
expr_stmt|;
name|ret
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Non-zero return code (%d) from the mail program.\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 	hopcnterr()  	there appears to be infinite mail forwarding - 	as detected by the hop count.  Mail to root and give up. 	Both the from and to addresses are cycling, so mail  	can't be sent there. */
end_comment

begin_macro
name|hopcnterr
argument_list|(
argument|toaddress
argument_list|,
argument|hopcnt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|toaddress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hopcnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cmdstr
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|rcode
decl_stmt|;
name|sprintf
argument_list|(
name|cmdstr
argument_list|,
literal|"echo infinite mail loop for %s hops %d | mail root"
argument_list|,
name|toaddress
argument_list|,
name|hopcnt
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|system
argument_list|(
name|cmdstr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
comment|/*UNREACHED*/
block|}
end_block

end_unit

