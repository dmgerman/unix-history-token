begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)netdaemon.c	4.2	(Berkeley)	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sccs id variable */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|netdaemon_sid
init|=
literal|"@(#)netdaemon.c	1.10"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  	The daemon program that runs the network.  Usage: 	netdaemon -m mach [-r readfd] [-w writefd] [-d] [-h] 		[-os] [-or] [-ou num] [-p len] [-8] [-l]  Must be started by root. Options: 	-d		turn debugging on 	-h		use high-speed link (not implemented yet) 	-l		don't use net line discipline, even if available 	-m mach		remote machine is mach (required) 	-os		only send 	-or		only receive 	-ou num		only send things with uid = num 	-p num		length of packet 	-r num		if simulute w/pipes, read from num 	-w num		if simulate w/pipes, write on num */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* take a time, adjust to be in PST, and divide by no of secs in a day */
end_comment

begin_comment
comment|/* adjust by 10 mins, and day is considered to begin at 3AM */
end_comment

begin_comment
comment|/* (6*3600 = 21600) + 17400 = 39000 */
end_comment

begin_comment
comment|/* number of seconds in a day, usually 86400L */
end_comment

begin_define
define|#
directive|define
name|nsecday
value|86400L
end_define

begin_comment
comment|/* number of days since time began */
end_comment

begin_define
define|#
directive|define
name|numdays
parameter_list|(
name|S
parameter_list|)
value|((S - 39000L)/nsecday)
end_define

begin_comment
comment|/* set my priority to normal */
end_comment

begin_define
define|#
directive|define
name|RENICE0
parameter_list|()
value|{ if (getuid() == 0) { nice(-40); nice(20); nice(0); } }
end_define

begin_comment
comment|/* global variables */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dumpstruc
name|dump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bstruct
name|btable
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|daemonparms
name|netd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|userinfo
name|status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local variables */
end_comment

begin_decl_stmt
specifier|static
name|long
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DIR
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static char sheader[] = 		"ABCDE"; */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tempfile
index|[]
init|=
name|TEMPFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|publogfile
index|[]
init|=
name|PUBLOGFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stat
name|statbuf
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|handlekill
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|frommach
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|linechars
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|long
name|ltime
decl_stmt|,
name|t
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|nice
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|handlekill
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|handlekill
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handlekill
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|handlekill
argument_list|)
expr_stmt|;
name|debugflg
operator|=
name|DBV
expr_stmt|;
name|setupdaemon
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* now running alone as a daemon */
comment|/* 		for(i=0; i<15; i++)close(i); 		signal(SIGHUP,SIG_IGN); 		signal(SIGQUIT,SIG_IGN); 		signal(SIGINT,SIG_IGN); 		*/
comment|/* set the umask to a reasonable value */
name|umask
argument_list|(
literal|022
argument_list|)
expr_stmt|;
name|senddir
index|[
name|strlen
argument_list|(
name|senddir
argument_list|)
operator|-
literal|1
index|]
operator|=
name|remote
expr_stmt|;
comment|/* choose dir */
if|if
condition|(
name|chdir
argument_list|(
name|senddir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|senddir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSFILE
argument_list|)
expr_stmt|;
block|}
name|dir
operator|=
name|opendir
argument_list|(
name|senddir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|senddir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSFILE
argument_list|)
expr_stmt|;
block|}
name|mktemp
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|tempfile
index|[
name|strlen
argument_list|(
name|tempfile
argument_list|)
operator|-
literal|7
index|]
operator|=
name|remote
expr_stmt|;
name|ltime
operator|=
name|gettime
argument_list|()
expr_stmt|;
if|if
condition|(
name|ltime
operator|==
literal|0L
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The network says 'The clock is set wrong.'\n"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"net restarted to %s %d %s"
argument_list|,
name|longname
argument_list|(
name|remote
argument_list|)
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|ctime
argument_list|(
operator|&
name|ltime
argument_list|)
argument_list|)
expr_stmt|;
name|dump
operator|.
name|longtime
operator|=
name|ltime
expr_stmt|;
name|dump
operator|.
name|lastndays
operator|=
name|numdays
argument_list|(
name|ltime
argument_list|)
expr_stmt|;
name|addtolog
argument_list|(
name|remote
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|addtopublic
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|debugflg
condition|)
name|fclose
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|sendpurge
argument_list|()
expr_stmt|;
name|mainloop
argument_list|()
expr_stmt|;
comment|/* never returns */
block|}
end_function

begin_comment
comment|/* the main loop of the daemon, alternatively rcv then send, if poss.*/
end_comment

begin_macro
name|mainloop
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* begin reading file */
name|debug
argument_list|(
literal|"daemon %c %d\n"
argument_list|,
name|remote
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* first receive */
if|if
condition|(
name|netd
operator|.
name|dp_sndorcv
operator|>=
literal|0
condition|)
block|{
comment|/* if we can receive */
name|i
operator|=
name|netrcv
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|dump
operator|.
name|nabnormal
operator|++
expr_stmt|;
block|}
comment|/* now look to send */
if|if
condition|(
name|netd
operator|.
name|dp_sndorcv
operator|<=
literal|0
condition|)
comment|/* if we can send */
name|netsend
argument_list|()
expr_stmt|;
comment|/* print out statistics if the right time */
name|printstat
argument_list|()
expr_stmt|;
name|dump
operator|.
name|nloop
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* this code is a little strange because some machines 	   seem to have trouble having the date set, and time() 	   returns 0 until somebody remembers to set the date */
end_comment

begin_macro
name|printstat
argument_list|()
end_macro

begin_block
block|{
name|long
name|thisndays
decl_stmt|,
name|thistime
decl_stmt|;
name|thistime
operator|=
name|gettime
argument_list|()
expr_stmt|;
name|thisndays
operator|=
name|numdays
argument_list|(
name|thistime
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
operator|.
name|longtime
operator|==
literal|0L
condition|)
block|{
name|dump
operator|.
name|longtime
operator|=
name|thistime
expr_stmt|;
name|dump
operator|.
name|lastndays
operator|=
name|thisndays
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|thisndays
operator|==
name|dump
operator|.
name|lastndays
operator|+
literal|1L
condition|)
name|dumpit
argument_list|(
name|thistime
argument_list|)
expr_stmt|;
name|dump
operator|.
name|lastndays
operator|=
name|thisndays
expr_stmt|;
block|}
end_block

begin_comment
comment|/* look for files to send */
end_comment

begin_macro
name|netsend
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|long
name|lasttime
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|nleft
init|=
literal|1
decl_stmt|;
name|long
name|lFileLen
decl_stmt|,
name|diff
decl_stmt|;
name|double
name|drate
decl_stmt|;
specifier|register
name|unsigned
name|uid
decl_stmt|,
name|uidBest
decl_stmt|;
name|char
modifier|*
name|sdate
decl_stmt|,
modifier|*
name|sn
decl_stmt|,
modifier|*
name|swait
decl_stmt|;
name|long
name|ot
decl_stmt|,
name|nt
decl_stmt|,
name|filesize
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|stemp
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|char
name|jname
index|[
name|FNS
index|]
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|debug
argument_list|(
literal|"ck send"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|senddir
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s %s"
argument_list|,
name|senddir
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|statbuf
operator|.
name|st_mtime
operator|==
name|lasttime
operator|&&
name|nleft
operator|==
literal|0
condition|)
return|return;
comment|/* no need to search */
name|lasttime
operator|=
name|statbuf
operator|.
name|st_mtime
expr_stmt|;
name|rewinddir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|lFileLen
operator|=
literal|10000000L
expr_stmt|;
name|nleft
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'c'
operator|||
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'f'
operator|||
name|dp
operator|->
name|d_name
index|[
literal|2
index|]
operator|!=
name|remote
operator|||
name|stat
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
operator|||
name|statbuf
operator|.
name|st_mode
operator|==
literal|0
condition|)
continue|continue;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
operator|||
name|statbuf
operator|.
name|st_mode
operator|==
literal|0
condition|)
continue|continue;
name|uid
operator|=
name|guid
argument_list|(
name|statbuf
operator|.
name|st_uid
argument_list|,
name|statbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|netd
operator|.
name|dp_onlyuid
operator|!=
literal|0
operator|&&
name|uid
operator|!=
name|netd
operator|.
name|dp_onlyuid
operator|&&
name|uid
operator|!=
name|SUPERUSER
operator|&&
name|uid
operator|!=
name|NUID
condition|)
continue|continue;
name|nleft
operator|++
expr_stmt|;
name|filesize
operator|=
name|getsize
argument_list|(
operator|&
name|statbuf
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DONTHOLDBIG
if|if
condition|(
operator|(
name|filesize
operator|>
name|MAXDAYFILE
operator|)
operator|&&
name|day
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|debugflg
condition|)
continue|continue;
else|else
name|debug
argument_list|(
literal|"sending large file %s\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DONTHOLDBIG
if|if
condition|(
name|lFileLen
operator|>
name|filesize
condition|)
block|{
name|lFileLen
operator|=
name|filesize
expr_stmt|;
name|strcpy
argument_list|(
name|jname
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|uidBest
operator|=
name|uid
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAXSENDQ
if|if
condition|(
name|nleft
operator|>
name|MAXSENDQ
condition|)
break|break;
endif|#
directive|endif
endif|MAXSENDQ
block|}
if|if
condition|(
name|lFileLen
operator|==
literal|10000000L
condition|)
return|return;
name|strcpy
argument_list|(
name|stemp
argument_list|,
name|jname
argument_list|)
expr_stmt|;
name|stemp
index|[
literal|0
index|]
operator|=
literal|'c'
expr_stmt|;
name|sn
operator|=
name|SnFromUid
argument_list|(
name|uidBest
argument_list|)
expr_stmt|;
if|if
condition|(
name|sn
operator|==
name|NULL
condition|)
block|{
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"Unknown userid %d\n"
argument_list|,
name|uidBest
argument_list|)
expr_stmt|;
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"Removing %s\n"
argument_list|,
name|stemp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|stemp
argument_list|)
expr_stmt|;
return|return;
block|}
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"^S %s %c: %s "
argument_list|,
name|sn
argument_list|,
name|remote
argument_list|,
name|jname
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ot
operator|=
name|gettime
argument_list|()
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|jname
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|nt
operator|=
name|gettime
argument_list|()
expr_stmt|;
name|filesize
operator|=
name|getsize
argument_list|(
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|jname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|stemp
argument_list|)
expr_stmt|;
name|diff
operator|=
name|nt
operator|-
name|ot
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|1
condition|)
name|diff
operator|=
literal|1
expr_stmt|;
comment|/* avoid dividing by zero */
name|sdate
operator|=
name|ctime
argument_list|(
operator|&
name|nt
argument_list|)
operator|+
literal|4
expr_stmt|;
name|sdate
index|[
name|strlen
argument_list|(
name|sdate
argument_list|)
operator|-
literal|9
index|]
operator|=
literal|0
expr_stmt|;
name|swait
operator|=
name|comptime
argument_list|(
name|ot
operator|-
name|statbuf
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|jname
index|[
literal|3
index|]
operator|=
name|jname
index|[
literal|2
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|NOFP
name|drate
operator|=
operator|(
name|double
operator|)
name|filesize
operator|/
operator|(
name|double
operator|)
name|diff
expr_stmt|;
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"^T%c(%s, %ldb, %ldsec, %4.1fb/sec, w %s)\n"
argument_list|,
name|remote
argument_list|,
name|sdate
argument_list|,
name|filesize
argument_list|,
name|diff
argument_list|,
name|drate
argument_list|,
name|swait
argument_list|)
expr_stmt|;
else|#
directive|else
else|NOFP
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"^T%c(%s, %ldb, %ldsec, w %s)\n"
argument_list|,
name|remote
argument_list|,
name|sdate
argument_list|,
name|filesize
argument_list|,
name|diff
argument_list|,
name|swait
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NOFP
name|addtopublic
argument_list|(
literal|"%s: sent %-8s to %s (%s, %ld b, wait %s)\n"
argument_list|,
name|sdate
argument_list|,
name|sn
argument_list|,
name|longname
argument_list|(
name|remote
argument_list|)
argument_list|,
name|jname
operator|+
literal|3
argument_list|,
name|filesize
argument_list|,
name|swait
argument_list|)
expr_stmt|;
name|dump
operator|.
name|nsend
operator|++
expr_stmt|;
name|dump
operator|.
name|bytetot
operator|+=
name|filesize
expr_stmt|;
name|dump
operator|.
name|elaptot
operator|+=
name|diff
expr_stmt|;
block|}
end_block

begin_comment
comment|/*    day() returns 1 if the time is between 6AM and 12PM */
end_comment

begin_macro
name|day
argument_list|()
end_macro

begin_block
block|{
name|int
name|hour
decl_stmt|;
name|long
name|t
decl_stmt|;
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|,
literal|"%*s%*s%*s%2d"
argument_list|,
operator|&
name|hour
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hour
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|hour
operator|<
literal|6
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* night */
else|else
return|return
operator|(
literal|1
operator|)
return|;
comment|/* day */
block|}
end_block

begin_macro
name|send
argument_list|(
argument|jname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|jname
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* push those bytes */
comment|/* returns 0 if send fails, 1 otherwise */
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|lsize
decl_stmt|;
name|char
name|mbuf
index|[
literal|20
index|]
decl_stmt|,
name|buf
index|[
name|MAXNBUF
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|jfile
decl_stmt|;
name|debug
argument_list|(
literal|"send %s"
argument_list|,
name|jname
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|jname
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|sfail
goto|;
name|lsize
operator|=
name|getsize
argument_list|(
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsize
operator|<
name|MINSIZE
condition|)
block|{
comment|/* all files are at least this long */
name|unlink
argument_list|(
name|jname
argument_list|)
expr_stmt|;
name|jname
index|[
literal|0
index|]
operator|=
literal|'c'
expr_stmt|;
name|unlink
argument_list|(
name|jname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|jfile
operator|=
name|fopen
argument_list|(
name|jname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jfile
operator|==
name|NULL
condition|)
goto|goto
name|sfail
goto|;
comment|/* 	strcpy(mbuf,sheader); 	i = strlen(sheader); 	p = (char *)&lsize; 	lsize = fixuplong(lsize); 	mbuf[i] = *p++; 	mbuf[i+1] = *p++; 	mbuf[i+2] = *p++; 	mbuf[i+3] = *p++; 	i = i + 4; 	sendreset(); 	*/
name|initseqno
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|mbuf
argument_list|,
literal|"|%08ld|"
argument_list|,
name|lsize
argument_list|)
expr_stmt|;
name|i
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|xwrite
argument_list|(
name|mbuf
argument_list|,
name|i
argument_list|)
operator|==
name|WRITEFAIL
condition|)
goto|goto
name|bwrite
goto|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|jfile
argument_list|)
argument_list|,
name|buf
argument_list|,
name|MAXNBUF
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|xwrite
argument_list|(
name|buf
argument_list|,
name|n
argument_list|)
operator|==
name|WRITEFAIL
condition|)
goto|goto
name|bwrite
goto|;
name|fclose
argument_list|(
name|jfile
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"end send"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|bwrite
label|:
name|dump
operator|.
name|nsendfail
operator|++
expr_stmt|;
name|fclose
argument_list|(
name|jfile
argument_list|)
expr_stmt|;
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"^F%c\n"
argument_list|,
name|remote
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|sfail
label|:
name|error
argument_list|(
literal|"%s: %s"
argument_list|,
name|jname
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|dump
operator|.
name|nsendfail
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|netrcv
argument_list|()
end_macro

begin_block
block|{
comment|/* returns -2 in normal fail, -1 in abnormal fail,>= 0 otherwise */
name|char
name|sin
decl_stmt|;
name|char
name|mgetc
argument_list|()
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dummy
decl_stmt|,
name|pid
decl_stmt|;
name|unsigned
name|rcode
decl_stmt|;
name|long
name|otime
decl_stmt|,
name|olength
decl_stmt|,
name|diff
decl_stmt|,
name|rcvfinish
decl_stmt|,
name|nt
decl_stmt|;
name|double
name|r
decl_stmt|;
name|char
name|hbuf
index|[
literal|20
index|]
decl_stmt|,
name|buf
index|[
name|MAXNBUF
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|temp
decl_stmt|;
specifier|static
name|struct
name|header
name|hd
decl_stmt|;
name|initseqno
argument_list|()
expr_stmt|;
comment|/* 	n = nread(hbuf,strlen(sheader)); 	if(n == BROKENREAD)return(-2); 	if(n != strlen(sheader) || strcmp(sheader,hbuf) != 0){ 		error("wrong head %d %s",n,hbuf); 		return(-1); 		} 	n = nread(&length,4); 	length = fixuplong(length); 	*/
name|n
operator|=
name|nread
argument_list|(
name|hbuf
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|BROKENREAD
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
if|if
condition|(
name|n
operator|!=
literal|10
condition|)
block|{
name|error
argument_list|(
literal|"bad length nread %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|hbuf
index|[
literal|10
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hbuf
index|[
literal|0
index|]
operator|!=
literal|'|'
operator|||
name|hbuf
index|[
literal|9
index|]
operator|!=
literal|'|'
condition|)
block|{
name|error
argument_list|(
literal|"poor format %s"
argument_list|,
name|hbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|hbuf
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
name|length
operator|=
name|atol
argument_list|(
name|hbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
operator|||
name|length
operator|>
literal|100000000L
condition|)
block|{
name|error
argument_list|(
literal|"bad length %ld"
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dump
operator|.
name|braw
operator|=
literal|4
expr_stmt|;
name|olength
operator|=
name|length
expr_stmt|;
name|otime
operator|=
name|gettime
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"length = %ld\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/*  	begin parsing header  	from local to remote (requests) 	code	net option	reason 	q			normal request 	y	-y		simply skips login check (used by netlpr)  	from remote to local 	code	net option	reason 	w	-w		message to be written/mailed back 	s	-z		normal response */
name|i
operator|=
name|readhd
argument_list|(
operator|&
name|hd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|3
condition|)
goto|goto
name|forw
goto|;
comment|/* being forwarded thru us */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
name|strcpy
argument_list|(
name|status
operator|.
name|login
argument_list|,
name|hd
operator|.
name|hd_snto
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|status
operator|.
name|localname
argument_list|,
name|hd
operator|.
name|hd_snfrom
argument_list|)
expr_stmt|;
name|demask
argument_list|(
name|hd
operator|.
name|hd_spasswd
argument_list|)
expr_stmt|;
name|s
operator|=
name|hd
operator|.
name|hd_scmdvirt
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hd
operator|.
name|hd_scmdvirt
argument_list|,
literal|"netlpr"
argument_list|)
operator|==
literal|0
condition|)
name|dump
operator|.
name|nnetlpr
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|hd
operator|.
name|hd_scmdvirt
argument_list|,
literal|"netmail"
argument_list|)
operator|==
literal|0
condition|)
name|dump
operator|.
name|nnetmail
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|hd
operator|.
name|hd_scmdvirt
argument_list|,
literal|"mail"
argument_list|)
operator|==
literal|0
condition|)
name|dump
operator|.
name|nsmail
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|hd
operator|.
name|hd_scmdvirt
argument_list|,
literal|"netcp"
argument_list|)
operator|==
literal|0
condition|)
name|dump
operator|.
name|nnetcp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|hd
operator|.
name|hd_scmdvirt
argument_list|,
literal|"response"
argument_list|)
operator|==
literal|0
condition|)
name|dump
operator|.
name|nresp
operator|++
expr_stmt|;
else|else
name|dump
operator|.
name|nnet
operator|++
expr_stmt|;
operator|*
name|s
operator|=
name|c
expr_stmt|;
name|printhd
argument_list|(
operator|&
name|hd
argument_list|)
expr_stmt|;
comment|/* any chars left are data */
name|forw
label|:
name|sin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/* make a temp input file */
name|increment
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|temp
operator|=
name|fopen
argument_list|(
name|tempfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s %s"
argument_list|,
name|tempfile
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|chmod
argument_list|(
name|tempfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|hd
operator|.
name|hd_mchto
operator|!=
name|local
condition|)
block|{
name|fprintf
argument_list|(
name|temp
argument_list|,
literal|"%c :%c :"
argument_list|,
name|hd
operator|.
name|hd_code
argument_list|,
name|hd
operator|.
name|hd_mchto
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* this is the loop to read in all the data */
while|while
condition|(
operator|(
name|n
operator|=
name|mread
argument_list|(
name|buf
argument_list|,
name|MAXNBUF
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|fileno
argument_list|(
name|temp
argument_list|)
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|error
argument_list|(
literal|"%s %s"
argument_list|,
name|tempfile
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
empty_stmt|;
name|fclose
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|BROKENREAD
operator|||
name|length
operator|>
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|sin
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hd
operator|.
name|hd_mchto
operator|!=
name|local
condition|)
block|{
name|diff
operator|=
name|gettime
argument_list|()
operator|-
name|otime
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|1
condition|)
name|diff
operator|=
literal|1
expr_stmt|;
comment|/* avoid dividing by 0 */
ifndef|#
directive|ifndef
name|NOFP
name|r
operator|=
name|olength
expr_stmt|;
name|r
operator|=
name|r
operator|/
name|diff
expr_stmt|;
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"^P(to %c, %ldb, %ldsec, %4.1fb/sec)\n"
argument_list|,
name|hd
operator|.
name|hd_mchto
argument_list|,
name|olength
argument_list|,
name|diff
argument_list|,
name|r
argument_list|)
expr_stmt|;
else|#
directive|else
else|NOFP
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"^P(to %c, %ldb, %ldsec)\n"
argument_list|,
name|hd
operator|.
name|hd_mchto
argument_list|,
name|olength
argument_list|,
name|diff
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NOFP
name|dump
operator|.
name|npass
operator|++
expr_stmt|;
name|dump
operator|.
name|bytetot
operator|+=
name|olength
expr_stmt|;
name|dump
operator|.
name|elaptot
operator|+=
name|diff
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|V6
name|RENICE0
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|V6
ifdef|#
directive|ifdef
name|CCV7
comment|/* make sure the spawned child has it's own 					group process to avoid the nasty 					"try again" message 				*/
name|setpgrp
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|CCV7
name|execl
argument_list|(
name|netcmd
argument_list|,
literal|"net"
argument_list|,
literal|"-x"
argument_list|,
literal|"-m"
argument_list|,
name|longname
argument_list|(
name|hd
operator|.
name|hd_mchto
argument_list|)
argument_list|,
literal|"-s"
argument_list|,
name|tempfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%s: %s"
argument_list|,
name|netcmd
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
name|wait
argument_list|(
operator|&
name|rcode
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|rcode
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"pass-thru rcode %d"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"passthru to %c code %c rcode %d"
argument_list|,
name|hd
operator|.
name|hd_mchto
argument_list|,
name|hd
operator|.
name|hd_code
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"file too short"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rcvfinish
operator|=
name|gettime
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
name|wait
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* normal return */
block|}
comment|/* this is a child, who will go ahead and execute the command */
comment|/* running uid=0 at this point */
ifndef|#
directive|ifndef
name|V6
name|RENICE0
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|V6
comment|/* nice(0 set back to 0 */
ifdef|#
directive|ifdef
name|CCV7
comment|/* separate group process */
name|setpgrp
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|CCV7
while|while
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
comment|/* child process which forks and waits */
name|mktemp
argument_list|(
name|resfile
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* child */
name|strcpy
argument_list|(
name|status
operator|.
name|loginshell
argument_list|,
name|Bsh
argument_list|)
expr_stmt|;
name|frommach
operator|=
name|hd
operator|.
name|hd_mchfrom
expr_stmt|;
name|n
operator|=
name|check
argument_list|(
operator|&
name|hd
argument_list|,
operator|(
name|hd
operator|.
name|hd_code
operator|==
literal|'q'
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|errormsg
argument_list|(
name|TRUE
argument_list|,
operator|&
name|hd
argument_list|,
name|NULL
argument_list|,
literal|"Bad remote login/password '%s'"
argument_list|,
name|hd
operator|.
name|hd_snto
argument_list|)
expr_stmt|;
name|temp
operator|=
name|fopen
argument_list|(
name|resfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
name|errormsg
argument_list|(
name|TRUE
argument_list|,
operator|&
name|hd
argument_list|,
name|NULL
argument_list|,
literal|"Create file %s: %s"
argument_list|,
name|resfile
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|resfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|mchown
argument_list|(
name|resfile
argument_list|,
name|status
operator|.
name|muid
argument_list|,
name|status
operator|.
name|mgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
condition|)
name|mchown
argument_list|(
name|tempfile
argument_list|,
name|status
operator|.
name|muid
argument_list|,
name|status
operator|.
name|mgid
argument_list|)
expr_stmt|;
else|else
name|tempfile
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|setgid
argument_list|(
name|status
operator|.
name|mgid
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|status
operator|.
name|muid
argument_list|)
expr_stmt|;
comment|/* after this point our gid, uid is the target user's */
name|excmd
argument_list|(
operator|&
name|hd
argument_list|,
name|resfile
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
block|}
comment|/* parent */
name|wait
argument_list|(
operator|&
name|rcode
argument_list|)
expr_stmt|;
name|rcode
operator|=
operator|(
operator|(
operator|(
name|rcode
operator|&
literal|077400
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0177
operator|)
expr_stmt|;
comment|/* 	fclose(stdin); 	fclose(stdout); 	fclose(stderr); 	*/
if|if
condition|(
name|sin
condition|)
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
comment|/*  	   now send something back to the sender  	   unless this was a response (file or message) 	*/
if|if
condition|(
operator|(
name|hd
operator|.
name|hd_code
operator|==
literal|'q'
operator|||
name|hd
operator|.
name|hd_code
operator|==
literal|'y'
operator|)
operator|&&
operator|(
name|hd
operator|.
name|hd_srespfile
index|[
literal|0
index|]
operator|||
operator|!
name|hd
operator|.
name|hd_fnonotify
operator|)
condition|)
name|sndresponse
argument_list|(
operator|&
name|hd
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|resfile
argument_list|)
expr_stmt|;
name|s
operator|=
name|ctime
argument_list|(
operator|&
name|rcvfinish
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|diff
operator|=
name|rcvfinish
operator|-
name|otime
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|1
condition|)
name|diff
operator|=
literal|1
expr_stmt|;
comment|/* avoid dividing by zero */
name|dump
operator|.
name|bytetot
operator|+=
name|olength
expr_stmt|;
name|dump
operator|.
name|elaptot
operator|+=
name|diff
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s rcv  %c:%-8s (%s)"
argument_list|,
name|s
argument_list|,
name|hd
operator|.
name|hd_mchfrom
argument_list|,
name|hd
operator|.
name|hd_snfrom
argument_list|,
name|hd
operator|.
name|hd_snto
argument_list|)
expr_stmt|;
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"%s C: %s\n"
argument_list|,
name|buf
argument_list|,
name|hd
operator|.
name|hd_scmdvirt
argument_list|)
expr_stmt|;
name|addtopublic
argument_list|(
literal|"%s R: %d C: %s\n"
argument_list|,
name|buf
argument_list|,
name|rcode
argument_list|,
name|hd
operator|.
name|hd_scmdvirt
argument_list|)
expr_stmt|;
name|nt
operator|=
name|rcvfinish
operator|-
name|hd
operator|.
name|hd_ltimesent
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nt
operator|>
literal|0L
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|" took (%s)"
argument_list|,
name|comptime
argument_list|(
name|nt
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOFP
name|r
operator|=
name|olength
expr_stmt|;
name|r
operator|=
name|r
operator|/
name|diff
expr_stmt|;
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"\t\tR: %d%s %ldb %ldsec %4.1fb/sec\n"
argument_list|,
name|rcode
argument_list|,
name|buf
argument_list|,
name|olength
argument_list|,
name|diff
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|dump
operator|.
name|braw
expr_stmt|;
name|r
operator|=
name|r
operator|/
name|diff
expr_stmt|;
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"\t\t%4.1frb/sec %4.1f%% use\n"
argument_list|,
name|r
argument_list|,
operator|(
name|r
operator|/
name|linechars
argument_list|()
operator|)
operator|*
literal|100L
argument_list|)
expr_stmt|;
else|#
directive|else
else|NOFP
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"\t\tR: %d%s %ldb %ldsec\n"
argument_list|,
name|rcode
argument_list|,
name|buf
argument_list|,
name|olength
argument_list|,
name|diff
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NOFP
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
comment|/*UNREACHED*/
block|}
end_block

begin_function
name|long
name|linechars
parameter_list|()
block|{
if|if
condition|(
name|netd
operator|.
name|dp_inspeed
operator|==
literal|13
condition|)
return|return
operator|(
literal|960L
operator|)
return|;
else|else
return|return
operator|(
literal|120L
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  	execute the user's command 	this procedure is executed with uid, gid of the user */
end_comment

begin_expr_stmt
name|excmd
argument_list|(
name|phd
argument_list|,
name|tempresfile
argument_list|,
name|tempinfile
argument_list|)
specifier|register
expr|struct
name|header
operator|*
name|phd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|tempresfile
decl_stmt|,
modifier|*
name|tempinfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|uid
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
name|c
decl_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|uid
operator|=
name|uidmask
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|status
operator|.
name|muid
operator|=
name|uidmask
argument_list|(
name|status
operator|.
name|muid
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|!=
name|status
operator|.
name|muid
condition|)
name|error
argument_list|(
literal|"setuid fails"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"uid: %u, gid: %u\n"
argument_list|,
name|uid
argument_list|,
name|status
operator|.
name|mgid
argument_list|)
expr_stmt|;
comment|/* check for allowed root commands, for security reasons */
if|if
condition|(
name|uid
operator|==
name|SUPERUSER
condition|)
block|{
name|s
operator|=
name|phd
operator|->
name|hd_scmdact
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
comment|/* these are the only commands root may execute */
if|if
condition|(
name|strcmp
argument_list|(
name|phd
operator|->
name|hd_scmdact
argument_list|,
literal|"cat"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|phd
operator|->
name|hd_scmdact
argument_list|,
name|MWRITECMD
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|phd
operator|->
name|hd_scmdact
argument_list|,
literal|"/bin/cat"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|phd
operator|->
name|hd_scmdact
argument_list|,
literal|"netrm"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|phd
operator|->
name|hd_scmdact
argument_list|,
literal|"/usr/lib/tq"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|phd
operator|->
name|hd_scmdact
argument_list|,
literal|"/usr/cc/lib/tq"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|phd
operator|->
name|hd_scmdact
argument_list|,
literal|"/usr/lib/rtrrm"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|phd
operator|->
name|hd_scmdact
argument_list|,
literal|"/usr/cc/lib/rtrrm"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|phd
operator|->
name|hd_scmdact
argument_list|,
literal|"lpr"
argument_list|)
operator|!=
literal|0
condition|)
name|errormsg
argument_list|(
name|TRUE
argument_list|,
name|phd
argument_list|,
name|tempresfile
argument_list|,
literal|"Not allowed to execute '%s' as root"
argument_list|,
name|phd
operator|->
name|hd_scmdact
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|status
operator|.
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|errormsg
argument_list|(
name|TRUE
argument_list|,
name|phd
argument_list|,
name|tempresfile
argument_list|,
literal|"chdir %s: %s"
argument_list|,
name|status
operator|.
name|dir
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|status
operator|.
name|dir
argument_list|)
expr_stmt|;
comment|/* set up v7 environment */
if|if
condition|(
name|tempinfile
index|[
literal|0
index|]
condition|)
name|mreopen
argument_list|(
name|TRUE
argument_list|,
name|phd
argument_list|,
name|tempresfile
argument_list|,
name|tempinfile
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|phd
operator|->
name|hd_sinfile
index|[
literal|0
index|]
condition|)
name|mreopen
argument_list|(
name|TRUE
argument_list|,
name|phd
argument_list|,
name|tempresfile
argument_list|,
name|phd
operator|->
name|hd_sinfile
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
else|else
name|mreopen
argument_list|(
name|TRUE
argument_list|,
name|phd
argument_list|,
name|tempresfile
argument_list|,
literal|"/dev/null"
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|phd
operator|->
name|hd_code
operator|==
literal|'s'
operator|&&
name|phd
operator|->
name|hd_soutfile
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|phd
operator|->
name|hd_soutfile
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
operator|||
name|getsize
argument_list|(
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
name|errormsg
argument_list|(
name|FALSE
argument_list|,
name|phd
argument_list|,
name|tempresfile
argument_list|,
literal|"Bad result file '%s'"
argument_list|,
name|phd
operator|->
name|hd_soutfile
argument_list|)
expr_stmt|;
name|mreopen
argument_list|(
name|TRUE
argument_list|,
name|phd
argument_list|,
name|tempresfile
argument_list|,
name|phd
operator|->
name|hd_soutfile
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|phd
operator|->
name|hd_soutfile
index|[
literal|0
index|]
condition|)
block|{
name|fd
operator|=
name|fopen
argument_list|(
name|phd
operator|->
name|hd_soutfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
name|errormsg
argument_list|(
name|TRUE
argument_list|,
name|phd
argument_list|,
name|tempresfile
argument_list|,
literal|"Open file %s: %s"
argument_list|,
name|phd
operator|->
name|hd_soutfile
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|mreopen
argument_list|(
name|TRUE
argument_list|,
name|phd
argument_list|,
name|tempresfile
argument_list|,
name|phd
operator|->
name|hd_soutfile
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|mreopen
argument_list|(
name|TRUE
argument_list|,
name|phd
argument_list|,
name|tempresfile
argument_list|,
name|tempresfile
argument_list|,
literal|"a"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"exec '%s'\n"
argument_list|,
name|phd
operator|->
name|hd_scmdact
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugflg
operator|==
literal|0
condition|)
block|{
comment|/* cheat */
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 		mreopen(TRUE,phd,tempresfile,tempresfile,"a",stderr); 		*/
block|}
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|phd
operator|->
name|hd_scmdact
argument_list|,
literal|"cat"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|phd
operator|->
name|hd_scmdact
argument_list|,
literal|"/bin/cat"
argument_list|)
operator|==
literal|0
condition|)
name|excat
argument_list|()
expr_stmt|;
do|do
block|{
name|mexecl
argument_list|(
name|status
operator|.
name|loginshell
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|phd
operator|->
name|hd_scmdact
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|errno
operator|==
name|ETXTBSY
condition|)
do|;
name|perror
argument_list|(
name|status
operator|.
name|loginshell
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  	send back a response  	if errormsg was called the resfile should be unlinked, 	to avoid two messages being sent there */
end_comment

begin_macro
name|sndresponse
argument_list|(
argument|phd
argument_list|,
argument|rcode
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|rcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|header
modifier|*
name|phd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cmdstr
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|long
name|maxfile
init|=
name|MAXFILELARGE
decl_stmt|;
comment|/* send response back if a response file 	was given or if mail/write is allowed */
if|if
condition|(
name|stat
argument_list|(
name|resfile
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s %s"
argument_list|,
name|resfile
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getsize
argument_list|(
operator|&
name|statbuf
argument_list|)
operator|>=
name|maxfile
condition|)
block|{
name|errormsg
argument_list|(
name|TRUE
argument_list|,
name|phd
argument_list|,
literal|"Result file too large - not sent"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getsize
argument_list|(
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* response file specified, no output generated */
if|if
condition|(
name|phd
operator|->
name|hd_srespfile
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
return|return;
comment|/* quiet option - no output and a rcode of 0 */
if|if
condition|(
name|rcode
operator|==
literal|0
operator|&&
name|phd
operator|->
name|hd_fquiet
condition|)
return|return;
block|}
comment|/* use both old and new mwrite parm lists */
if|if
condition|(
name|phd
operator|->
name|hd_srespfile
index|[
literal|0
index|]
condition|)
name|sprintf
argument_list|(
name|cmdstr
argument_list|,
literal|"-o %s cat"
argument_list|,
name|phd
operator|->
name|hd_srespfile
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|cmdstr
argument_list|,
literal|"%s %s %s %lo %c %s \"'%s'\" %ld -t %s -f %s -x %ld -c \"'%s'\" -y %s -e %ld -r %d"
argument_list|,
name|MWRITECMD
argument_list|,
name|phd
operator|->
name|hd_snfrom
argument_list|,
name|phd
operator|->
name|hd_sttyname
argument_list|,
name|phd
operator|->
name|hd_lttytime
argument_list|,
name|phd
operator|->
name|hd_mchto
argument_list|,
name|phd
operator|->
name|hd_snto
argument_list|,
name|phd
operator|->
name|hd_scmdvirt
argument_list|,
name|phd
operator|->
name|hd_ltimesent
operator|-
name|TIMEBASE
argument_list|,
name|phd
operator|->
name|hd_addrfrom
argument_list|,
name|phd
operator|->
name|hd_addrto
argument_list|,
name|phd
operator|->
name|hd_lttytime
argument_list|,
name|phd
operator|->
name|hd_scmdvirt
argument_list|,
name|phd
operator|->
name|hd_sttyname
argument_list|,
name|phd
operator|->
name|hd_ltimesent
operator|-
name|TIMEBASE
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s -m%c -z -b -l %s -s %s -c response %s"
argument_list|,
name|netcmd
argument_list|,
name|phd
operator|->
name|hd_mchfrom
argument_list|,
name|phd
operator|->
name|hd_snfrom
argument_list|,
name|resfile
argument_list|,
name|cmdstr
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* execute command buf */
block|}
end_block

begin_comment
comment|/*  	excat 	does nothing more than copy standard input to standard 	output, like the cat command, but reports write errors. 	Uses getc and putc rather than fwrite and fread because 	the latter call getc and putc. */
end_comment

begin_macro
name|excat
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|perror
argument_list|(
literal|"filecat: stdout"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSFILE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errno
condition|)
block|{
name|perror
argument_list|(
literal|"filecat: stdin"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSFILE
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* returns errors for netrcv() */
end_comment

begin_expr_stmt
specifier|static
name|readhd
argument_list|(
name|phd
argument_list|)
specifier|register
expr|struct
name|header
operator|*
name|phd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|cflag
decl_stmt|,
name|sbuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|parmlist
index|[
name|PARMLIST
index|]
decl_stmt|,
modifier|*
name|cptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|code
decl_stmt|;
name|code
operator|=
name|mgetc
argument_list|()
expr_stmt|;
name|phd
operator|->
name|hd_mchto
operator|=
name|mgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|'q'
operator|&&
name|code
operator|!=
literal|'y'
operator|&&
name|code
operator|!=
literal|'w'
operator|&&
name|code
operator|!=
literal|'s'
condition|)
block|{
name|error
argument_list|(
literal|"bad code"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|phd
operator|->
name|hd_code
operator|=
name|code
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXINX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|phd
operator|->
name|hd_mchto
operator|==
name|inxtoch
argument_list|(
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|MAXINX
condition|)
block|{
name|error
argument_list|(
literal|"bad phd->hd_mchto"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|phd
operator|->
name|hd_mchto
operator|!=
name|local
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
comment|/* being forwarded through us */
name|phd
operator|->
name|hd_mchfrom
operator|=
name|mgetc
argument_list|()
expr_stmt|;
name|phd
operator|->
name|hd_vmajor
operator|=
name|mgetc
argument_list|()
expr_stmt|;
name|phd
operator|->
name|hd_vminor
operator|=
name|mgetc
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|i
operator|+=
name|mgets
argument_list|(
name|phd
operator|->
name|hd_snto
argument_list|,
name|NS
argument_list|)
expr_stmt|;
name|i
operator|+=
name|mgets
argument_list|(
name|phd
operator|->
name|hd_spasswd
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|i
operator|+=
name|mgets
argument_list|(
name|phd
operator|->
name|hd_sinfile
argument_list|,
name|FNS
argument_list|)
expr_stmt|;
name|i
operator|+=
name|mgets
argument_list|(
name|phd
operator|->
name|hd_soutfile
argument_list|,
name|FNS
argument_list|)
expr_stmt|;
name|i
operator|+=
name|mgets
argument_list|(
name|phd
operator|->
name|hd_srespfile
argument_list|,
name|FNS
argument_list|)
expr_stmt|;
name|i
operator|+=
name|mgets
argument_list|(
name|phd
operator|->
name|hd_snfrom
argument_list|,
name|NS
argument_list|)
expr_stmt|;
comment|/* addrfrom is the person who sent this to us, 	   addrto is the person who received the command, i.e. 	   addrto is on this machine */
if|if
condition|(
name|phd
operator|->
name|hd_snfrom
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|phd
operator|->
name|hd_snfrom
argument_list|,
literal|"root"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|phd
operator|->
name|hd_addrfrom
argument_list|,
literal|"%s:%s"
argument_list|,
name|longname
argument_list|(
name|phd
operator|->
name|hd_mchfrom
argument_list|)
argument_list|,
name|phd
operator|->
name|hd_snfrom
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|phd
operator|->
name|hd_addrto
argument_list|,
literal|"%s:%s"
argument_list|,
name|longname
argument_list|(
name|phd
operator|->
name|hd_mchto
argument_list|)
argument_list|,
name|phd
operator|->
name|hd_snto
argument_list|)
expr_stmt|;
name|i
operator|+=
name|mgets
argument_list|(
name|phd
operator|->
name|hd_sttyname
argument_list|,
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|phd
operator|->
name|hd_sttyname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|phd
operator|->
name|hd_sttyname
argument_list|,
literal|"/dev/ttyx"
argument_list|)
expr_stmt|;
name|cflag
operator|=
name|mgetc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|phd
operator|->
name|hd_mchfrom
operator|||
operator|!
name|phd
operator|->
name|hd_code
operator|||
operator|!
name|cflag
operator|||
operator|!
name|phd
operator|->
name|hd_vmajor
operator|||
operator|!
name|phd
operator|->
name|hd_vminor
condition|)
block|{
name|error
argument_list|(
literal|"mgetc fails"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cflag
operator|-=
literal|'a'
expr_stmt|;
name|phd
operator|->
name|hd_fnonotify
operator|=
operator|(
name|cflag
operator|&
name|F_NONOTIFY
operator|)
expr_stmt|;
name|phd
operator|->
name|hd_fquiet
operator|=
operator|(
name|cflag
operator|&
name|F_QUIET
operator|)
expr_stmt|;
name|phd
operator|->
name|hd_vmajor
operator|-=
literal|'a'
expr_stmt|;
name|phd
operator|->
name|hd_vminor
operator|-=
literal|'a'
expr_stmt|;
name|i
operator|+=
name|mgets
argument_list|(
name|sbuf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|phd
operator|->
name|hd_lttytime
operator|=
literal|0
expr_stmt|;
name|sscanf
argument_list|(
name|sbuf
argument_list|,
literal|"%lo"
argument_list|,
operator|&
name|phd
operator|->
name|hd_lttytime
argument_list|)
expr_stmt|;
name|i
operator|+=
name|mgets
argument_list|(
name|parmlist
argument_list|,
name|PARMLIST
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CRN
name|cptr
operator|=
name|parmlist
expr_stmt|;
while|while
condition|(
operator|*
name|cptr
operator|!=
literal|'('
condition|)
name|cptr
operator|++
expr_stmt|;
operator|*
name|cptr
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|phd
operator|->
name|hd_ijobno
argument_list|,
name|parmlist
argument_list|)
expr_stmt|;
operator|*
name|cptr
operator|=
literal|'('
expr_stmt|;
else|#
directive|else
else|CRN
name|strcpy
argument_list|(
name|phd
operator|->
name|hd_ijobno
argument_list|,
literal|"XYZZ"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|CRN
comment|/* keep variable parameter list in crn slot */
name|parseparmlist
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|i
operator|+=
name|mgets
argument_list|(
name|sbuf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
comment|/* time sent */
name|sscanf
argument_list|(
name|sbuf
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|phd
operator|->
name|hd_ltimesent
argument_list|)
expr_stmt|;
name|phd
operator|->
name|hd_ltimesent
operator|+=
name|TIMEBASE
expr_stmt|;
name|i
operator|+=
name|mgetcmd
argument_list|(
name|phd
operator|->
name|hd_scmdact
argument_list|)
expr_stmt|;
name|i
operator|+=
name|mgetcmd
argument_list|(
name|phd
operator|->
name|hd_scmdvirt
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"mgets fails"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|phd
operator|->
name|hd_scmdvirt
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|phd
operator|->
name|hd_scmdvirt
argument_list|,
name|phd
operator|->
name|hd_scmdact
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*     check() -- verify login name and password    phd    = login,passwd    fverify  = 1 if password must check    Returns 1 if password is ok, 0 if not. */
end_comment

begin_expr_stmt
name|check
argument_list|(
name|phd
argument_list|,
name|fverify
argument_list|)
comment|/* 1 if OK, 0 if not */
specifier|register
expr|struct
name|header
operator|*
name|phd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fverify
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|sencpasswd
decl_stmt|,
modifier|*
name|u
decl_stmt|,
modifier|*
name|nullstr
init|=
literal|""
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
ifdef|#
directive|ifdef
name|CRN
name|struct
name|gecos
modifier|*
name|gcos
decl_stmt|;
endif|#
directive|endif
endif|CRN
if|if
condition|(
name|phd
operator|->
name|hd_snto
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|!
name|fverify
operator|)
return|;
name|debug
argument_list|(
literal|"check: phd->hd_snto = %s\n"
argument_list|,
name|phd
operator|->
name|hd_snto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodacctname
argument_list|(
name|phd
operator|->
name|hd_snto
argument_list|)
condition|)
return|return
operator|(
operator|!
name|fverify
operator|)
return|;
name|pwd
operator|=
name|getpwnam
argument_list|(
name|phd
operator|->
name|hd_snto
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"got pwd=%d, pwd->pw_passwd = %s\n"
argument_list|,
name|pwd
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
return|return
operator|(
operator|!
name|fverify
operator|)
return|;
if|if
condition|(
operator|*
name|phd
operator|->
name|hd_spasswd
condition|)
name|sencpasswd
operator|=
name|crypt
argument_list|(
name|phd
operator|->
name|hd_spasswd
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
else|else
name|sencpasswd
operator|=
name|nullstr
expr_stmt|;
name|debug
argument_list|(
literal|"check: passwd(rcvd)=%s, passwd(file) = %s, passwd(encrypt)=%s\n"
argument_list|,
name|phd
operator|->
name|hd_spasswd
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|,
name|sencpasswd
argument_list|)
expr_stmt|;
name|status
operator|.
name|muid
operator|=
name|guid
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|status
operator|.
name|mgid
operator|=
name|pwd
operator|->
name|pw_gid
expr_stmt|;
ifdef|#
directive|ifdef
name|CRN
if|if
condition|(
operator|(
name|gcos
operator|=
name|pwgecos
argument_list|(
name|pwd
operator|->
name|pw_gecos
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|jobno
argument_list|,
name|MAGICCRN
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|status
operator|.
name|jobno
argument_list|,
name|gcos
operator|->
name|gc_crn
argument_list|)
expr_stmt|;
else|#
directive|else
else|CRN
name|strcpy
argument_list|(
name|status
operator|.
name|jobno
argument_list|,
literal|"XYZZ"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|CRN
name|strcpy
argument_list|(
name|status
operator|.
name|dir
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|status
operator|.
name|loginshell
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
name|u
operator|=
name|status
operator|.
name|loginshell
expr_stmt|;
if|if
condition|(
name|u
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"/bin/sbash"
argument_list|,
name|u
argument_list|)
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|u
argument_list|,
name|Bsh
argument_list|)
expr_stmt|;
name|getpwdf
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
comment|/* ignore network passwd */
comment|/* acct is not a pair, acct is not "network", passwd is incorrect, 	and verification is requested => passwd not ok */
if|if
condition|(
operator|!
name|facctpaircheck
argument_list|(
name|phd
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|phd
operator|->
name|hd_snto
argument_list|,
literal|"network"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_passwd
argument_list|,
name|sencpasswd
argument_list|)
operator|!=
literal|0
operator|&&
name|fverify
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* otherwise passwd ok */
block|}
end_block

begin_expr_stmt
name|mread
argument_list|(
name|b
argument_list|,
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|length
operator|<
name|n
condition|)
name|n
operator|=
name|length
expr_stmt|;
name|n
operator|=
name|nread
argument_list|(
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|BROKENREAD
condition|)
name|length
operator|-=
name|n
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_function
name|char
name|mgetc
parameter_list|()
block|{
comment|/* returns 0 if fail */
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|nread
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
operator|)
operator|==
name|BROKENREAD
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|n
operator|!=
literal|3
condition|)
block|{
name|error
argument_list|(
literal|"bad read %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|c
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|buf
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
block|{
name|error
argument_list|(
literal|"Bad char %c"
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|length
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"length wrong2 %ld"
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* read in string over the network wire */
end_comment

begin_comment
comment|/* put string in s, max length is maxlen */
end_comment

begin_macro
name|mgets
argument_list|(
argument|s
argument_list|,
argument|maxlen
argument_list|)
end_macro

begin_comment
comment|/* returns 0 if ok, 1 if not */
end_comment

begin_decl_stmt
name|int
name|maxlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
name|c
decl_stmt|;
name|q
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|nread
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|BROKENREAD
condition|)
block|{
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"mgets %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|nread
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|BROKENREAD
condition|)
block|{
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"mgets %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|maxlen
operator|--
operator|>
literal|0
condition|)
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nread
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
name|BROKENREAD
condition|)
block|{
name|error
argument_list|(
literal|"mgets %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|length
operator|-=
operator|(
name|s
operator|-
name|q
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"length wrong1 %ld %s"
argument_list|,
name|length
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|maxlen
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"mgets - string too long"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|mgetcmd
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* returns 0 if succeed, 1 otherwise */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|char
name|c
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|nread
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|BROKENREAD
condition|)
block|{
name|s
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"mgetcmd %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|<=
literal|0
operator|||
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|nread
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
name|BROKENREAD
condition|)
block|{
name|s
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"mgetcmd %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|length
operator|--
expr_stmt|;
block|}
name|s
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
name|s
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|length
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|increment
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|'9'
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|s
index|[
name|i
index|]
operator|<
literal|'0'
operator|||
name|s
index|[
name|i
index|]
operator|>
literal|'9'
condition|)
block|{
name|p
operator|=
name|s
operator|+
name|i
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
return|return;
block|}
operator|(
name|s
index|[
name|i
index|]
operator|)
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|s
index|[
name|i
index|]
condition|)
name|s
index|[
name|i
operator|++
index|]
operator|=
literal|'0'
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* gather 24-hour stats and  mail to STATADDR */
end_comment

begin_comment
comment|/* should also gather stats on # error msgs */
end_comment

begin_macro
name|dumpit
argument_list|(
argument|currt
argument_list|)
end_macro

begin_decl_stmt
name|long
name|currt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dumpstruc
modifier|*
name|p
init|=
operator|&
name|dump
decl_stmt|;
specifier|register
name|int
name|ntot
decl_stmt|;
name|long
name|elapt
decl_stmt|;
name|double
name|cputime
decl_stmt|,
name|utime
decl_stmt|,
name|stime
decl_stmt|,
name|bs
decl_stmt|,
name|rawbs
decl_stmt|;
name|char
modifier|*
name|sstartt
decl_stmt|;
name|FILE
modifier|*
name|fdm
decl_stmt|;
name|char
name|froma
index|[
literal|30
index|]
decl_stmt|;
name|struct
name|tms
name|tbf
decl_stmt|;
comment|/* if STATADDR is a file, the mail program this call will 	   ultimately execute must be able to deal with it, 	   and the remote mail program must be able to write on the 	   file, i.e. mode 666 */
name|sprintf
argument_list|(
name|froma
argument_list|,
literal|"%s=>"
argument_list|,
name|longname
argument_list|(
name|local
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|froma
argument_list|,
name|longname
argument_list|(
name|remote
argument_list|)
argument_list|)
expr_stmt|;
name|fdm
operator|=
name|mailopen
argument_list|(
name|STATADDR
argument_list|,
name|froma
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdm
operator|==
name|NULL
condition|)
return|return;
comment|/* calculate times */
name|elapt
operator|=
name|currt
operator|-
name|dump
operator|.
name|longtime
expr_stmt|;
name|ntot
operator|=
name|p
operator|->
name|nnetcp
operator|+
name|p
operator|->
name|nnetmail
operator|+
name|p
operator|->
name|nsmail
operator|+
name|p
operator|->
name|nnetlpr
operator|+
name|p
operator|->
name|nresp
operator|+
name|p
operator|->
name|nnet
expr_stmt|;
name|sstartt
operator|=
name|ctime
argument_list|(
operator|&
name|dump
operator|.
name|longtime
argument_list|)
operator|+
literal|4
expr_stmt|;
name|sstartt
index|[
name|strlen
argument_list|(
name|sstartt
argument_list|)
operator|-
literal|9
index|]
operator|=
literal|0
expr_stmt|;
name|times
argument_list|(
operator|&
name|tbf
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOFP
name|utime
operator|=
name|tbf
operator|.
name|tms_utime
operator|+
name|tbf
operator|.
name|tms_cutime
expr_stmt|;
name|stime
operator|=
name|tbf
operator|.
name|tms_stime
operator|+
name|tbf
operator|.
name|tms_cstime
expr_stmt|;
name|cputime
operator|=
name|utime
operator|+
name|stime
expr_stmt|;
if|if
condition|(
name|elapt
operator|>
literal|0
condition|)
name|cputime
operator|=
operator|(
name|cputime
operator|/
name|elapt
operator|)
operator|*
literal|100.0
expr_stmt|;
else|else
name|cputime
operator|=
literal|0.0
expr_stmt|;
name|utime
operator|=
name|utime
operator|/
literal|60.0
expr_stmt|;
name|stime
operator|=
name|stime
operator|/
literal|60.0
expr_stmt|;
name|cputime
operator|=
name|cputime
operator|/
literal|60.0
expr_stmt|;
name|bs
operator|=
name|p
operator|->
name|bytetot
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|elaptot
operator|>
literal|0
condition|)
name|bs
operator|=
name|bs
operator|/
name|p
operator|->
name|elaptot
expr_stmt|;
else|else
name|bs
operator|=
literal|0.0
expr_stmt|;
endif|#
directive|endif
endif|NOFP
comment|/* print out the statistics */
name|fprintf
argument_list|(
name|fdm
argument_list|,
literal|"Subject: %s, %s, time %s\n"
argument_list|,
name|froma
argument_list|,
name|sstartt
argument_list|,
name|comptime
argument_list|(
name|elapt
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdm
argument_list|,
literal|"Command summary:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdm
argument_list|,
literal|"\t# sent %d\t# pass_thru %d\t# rcv %d:\t# netcp %d\n"
argument_list|,
name|p
operator|->
name|nsend
argument_list|,
name|p
operator|->
name|npass
argument_list|,
name|ntot
argument_list|,
name|p
operator|->
name|nnetcp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdm
argument_list|,
literal|"\t# netlpr %d\t# netmail %d\t# sendbmail %d\t# resp %d\n"
argument_list|,
name|p
operator|->
name|nnetlpr
argument_list|,
name|p
operator|->
name|nnetmail
argument_list|,
name|p
operator|->
name|nsmail
argument_list|,
name|p
operator|->
name|nresp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdm
argument_list|,
literal|"Protocol summary:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdm
argument_list|,
literal|"\t# pk_sent %d\t# pk_rcv %d\t# b_sent %ld\t# b_rcv %ld\n"
argument_list|,
name|p
operator|->
name|npacksent
argument_list|,
name|p
operator|->
name|npackrcv
argument_list|,
name|p
operator|->
name|nbytesent
argument_list|,
name|p
operator|->
name|nbytercv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdm
argument_list|,
literal|"\t# send_fails %d\t# retrans %d\t# abn %d\t\t# cksum_errs %d\n"
argument_list|,
name|p
operator|->
name|nsendfail
argument_list|,
name|p
operator|->
name|nretrans
argument_list|,
name|p
operator|->
name|nabnormal
argument_list|,
name|p
operator|->
name|ncksum
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOFP
name|fprintf
argument_list|(
name|fdm
argument_list|,
literal|"Load:\tuser %4.1f\tsys %4.1f\tpct %5.2f\trate %6.1f\n"
argument_list|,
name|utime
argument_list|,
name|stime
argument_list|,
name|cputime
argument_list|,
name|bs
argument_list|)
expr_stmt|;
name|rawbs
operator|=
name|p
operator|->
name|brawtot
operator|*
literal|100L
expr_stmt|;
name|rawbs
operator|=
name|rawbs
operator|/
name|linechars
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|fdm
argument_list|,
literal|"\trawbytes %ld\tuse %4.1f\n"
argument_list|,
name|p
operator|->
name|brawtot
argument_list|,
name|rawbs
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NOFP
name|mailclose
argument_list|(
name|fdm
argument_list|)
expr_stmt|;
comment|/* reset counters */
name|p
operator|->
name|nbytesent
operator|=
name|p
operator|->
name|nbytercv
operator|=
name|p
operator|->
name|elaptot
operator|=
name|p
operator|->
name|bytetot
operator|=
literal|0L
expr_stmt|;
name|p
operator|->
name|nretrans
operator|=
name|p
operator|->
name|nloop
operator|=
name|p
operator|->
name|nabnormal
operator|=
name|p
operator|->
name|ncksum
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|npacksent
operator|=
name|p
operator|->
name|npackrcv
operator|=
name|p
operator|->
name|nnetcp
operator|=
name|p
operator|->
name|nnetmail
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|nsmail
operator|=
name|p
operator|->
name|nnetlpr
operator|=
name|p
operator|->
name|nnet
operator|=
name|p
operator|->
name|npass
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|nsend
operator|=
name|p
operator|->
name|nsendfail
operator|=
literal|0
expr_stmt|;
name|dump
operator|.
name|longtime
operator|=
name|currt
expr_stmt|;
block|}
end_block

begin_comment
comment|/* returns 1 if n is ok, 0 if not */
end_comment

begin_macro
name|goodacctname
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|btable
index|[
operator|++
name|i
index|]
operator|.
name|bname
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|btable
index|[
name|i
index|]
operator|.
name|bname
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|local
operator|==
name|btable
index|[
name|i
index|]
operator|.
name|bmach
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|demask
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 	static char buf[20]; 	char skey[30]; 	makeuukey(skey,status.login,local); 	strcpy(s,nbsdecrypt(s,skey,buf)); */
while|while
condition|(
operator|*
name|s
condition|)
block|{
operator|*
name|s
operator|&=
literal|0177
expr_stmt|;
comment|/* strip quote bites */
operator|*
name|s
operator|++
operator|^=
literal|040
expr_stmt|;
comment|/* invert upper-lower */
block|}
block|}
end_block

begin_comment
comment|/*VARARGS0*/
end_comment

begin_macro
name|mreopen
argument_list|(
argument|fsendtofmach
argument_list|,
argument|phd
argument_list|,
argument|sfn
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|)
end_macro

begin_block
block|{
comment|/* simply handles errors by giving error msg */
if|if
condition|(
name|freopen
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
operator|==
name|NULL
condition|)
name|errormsg
argument_list|(
name|fsendtofmach
argument_list|,
name|phd
argument_list|,
name|sfn
argument_list|,
literal|"%s: %s"
argument_list|,
name|a
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  	addtopub(string, args)  	add a message to the public logfile /usr/net/logfile. 	note that the file must be writeable by everyone 	if error messages from the netrcv subroutine 	such as chdir errors are to be noticed. */
end_comment

begin_comment
comment|/*VARARGS0*/
end_comment

begin_macro
name|addtopublic
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|,
argument|e
argument_list|,
argument|f
argument_list|,
argument|g
argument_list|,
argument|h
argument_list|,
argument|i
argument_list|,
argument|j
argument_list|,
argument|k
argument_list|,
argument|l
argument_list|,
argument|m
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|FILE
modifier|*
name|log
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|log
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|publogfile
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|log
operator|=
name|fopen
argument_list|(
name|publogfile
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|==
name|NULL
condition|)
return|return;
block|}
name|fseek
argument_list|(
name|log
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log
argument_list|,
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|l
argument_list|,
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* set up a dummy environment for v7 /bin/sh */
end_comment

begin_macro
name|setenv
argument_list|(
argument|home
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|home
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|env
index|[
literal|3
index|]
decl_stmt|,
name|benv
index|[
literal|2
index|]
index|[
literal|50
index|]
decl_stmt|;
name|env
index|[
literal|0
index|]
operator|=
name|benv
index|[
literal|0
index|]
expr_stmt|;
name|env
index|[
literal|1
index|]
operator|=
name|benv
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|CCV7
name|strcpy
argument_list|(
name|env
index|[
literal|0
index|]
argument_list|,
literal|"PATH=:.:/usr/cc/bin:/usr/ucb/bin"
argument_list|)
expr_stmt|;
else|#
directive|else
else|CCV7
name|strcpy
argument_list|(
name|env
index|[
literal|0
index|]
argument_list|,
literal|"PATH=:/bin:/usr/bin"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|CCV7
name|sprintf
argument_list|(
name|env
index|[
literal|1
index|]
argument_list|,
literal|"HOME=%s"
argument_list|,
name|home
argument_list|)
expr_stmt|;
name|env
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|environ
operator|=
name|env
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  	errormsg(fsendtofmach,phd,sfn,"string",arg(s)) 	 	Sends error message to user. 	If fsendtofmach=TRUE, send to phd->hd_mchfrom, otherwise 	send to phd->hd_mchto. 	Also, if error occured during return of a "response", 	send to local machine.  	Note that errormsg can be called by the netrcv subroutine 	after the setuid() call to the specific user, so the  	user must be able to get off an error msg back to him, 	and to write in the two log files. 	Can't use -w,-x,-y,-z for the net cmd because must be root for those.  	If sfn != NULL, then unlink sfn before exiting. */
end_comment

begin_comment
comment|/*VARARGS0*/
end_comment

begin_macro
name|errormsg
argument_list|(
argument|fsendtofmach
argument_list|,
argument|phd
argument_list|,
argument|sfn
argument_list|,
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|,
argument|e
argument_list|,
argument|f
argument_list|,
argument|g
argument_list|,
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|char
name|fsendtofmach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|header
modifier|*
name|phd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sfn
decl_stmt|,
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|rcode
decl_stmt|;
name|char
name|errstr
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|cmdstr
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|rcmd
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|toadd
index|[
name|FNS
index|]
decl_stmt|,
name|fromadd
index|[
name|FNS
index|]
decl_stmt|,
name|mchto
decl_stmt|,
name|mchfrom
decl_stmt|;
name|char
name|snto
index|[
name|FNS
index|]
decl_stmt|,
name|snfrom
index|[
name|FNS
index|]
decl_stmt|;
if|if
condition|(
name|phd
operator|->
name|hd_sttyname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|phd
operator|->
name|hd_sttyname
argument_list|,
literal|"/dev/ttyx"
argument_list|)
expr_stmt|;
comment|/* will send to toadd, from fromadd */
if|if
condition|(
operator|!
name|fsendtofmach
operator|||
name|strcmp
argument_list|(
name|phd
operator|->
name|hd_scmdvirt
argument_list|,
literal|"response"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* send to tomach mach, thus send to toaddr. */
comment|/* if this is an error during a response, send to local mach. */
name|strcpy
argument_list|(
name|toadd
argument_list|,
name|phd
operator|->
name|hd_addrto
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fromadd
argument_list|,
name|phd
operator|->
name|hd_addrfrom
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* send to remote mach, thus send back to addrfrom*/
name|strcpy
argument_list|(
name|toadd
argument_list|,
name|phd
operator|->
name|hd_addrfrom
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fromadd
argument_list|,
name|phd
operator|->
name|hd_addrto
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|errstr
argument_list|,
literal|"Error: "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cmdstr
argument_list|,
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|errstr
argument_list|,
name|cmdstr
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|errstr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|addtolog
argument_list|(
name|remote
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|addtopublic
argument_list|(
name|errstr
argument_list|)
expr_stmt|;
name|mchto
operator|=
name|MchSFromAddr
argument_list|(
name|snto
argument_list|,
name|toadd
argument_list|)
expr_stmt|;
name|mchfrom
operator|=
name|MchSFromAddr
argument_list|(
name|snfrom
argument_list|,
name|fromadd
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rcmd
argument_list|,
literal|"%s %s %s %lo %c %s \"'%s'\" %ld -t %s -f %s -x %ld -y %s -c \"'%s'\" -e %ld"
argument_list|,
name|MWRITECMD
argument_list|,
name|snto
argument_list|,
name|phd
operator|->
name|hd_sttyname
argument_list|,
name|phd
operator|->
name|hd_lttytime
argument_list|,
name|local
argument_list|,
name|snfrom
argument_list|,
name|phd
operator|->
name|hd_scmdvirt
argument_list|,
name|phd
operator|->
name|hd_ltimesent
operator|-
name|TIMEBASE
argument_list|,
name|toadd
argument_list|,
name|fromadd
argument_list|,
name|phd
operator|->
name|hd_lttytime
argument_list|,
name|phd
operator|->
name|hd_sttyname
argument_list|,
name|phd
operator|->
name|hd_scmdvirt
argument_list|,
name|phd
operator|->
name|hd_ltimesent
operator|-
name|TIMEBASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mchto
operator|==
name|local
condition|)
name|sprintf
argument_list|(
name|cmdstr
argument_list|,
literal|"echo \"%s\" | %s"
argument_list|,
name|errstr
argument_list|,
name|rcmd
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|cmdstr
argument_list|,
literal|"echo \"%s\" | %s -m%c -b -c errormessage -l network - %s"
argument_list|,
name|errstr
argument_list|,
name|netcmd
argument_list|,
name|mchto
argument_list|,
name|rcmd
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|system
argument_list|(
name|cmdstr
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"errormsg: cmdstr = %s\n"
argument_list|,
name|cmdstr
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"errormsg: rcode = %d\n"
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfn
operator|!=
name|NULL
condition|)
name|unlink
argument_list|(
name|sfn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|handlekill
argument_list|()
end_macro

begin_block
block|{
comment|/* SIGTERM signal */
name|long
name|t
decl_stmt|;
comment|/* 	t = gettime(); 	dumpit(t); 	*/
ifdef|#
directive|ifdef
name|NETLDISC
comment|/* turn off net line discipline if possible */
name|netd
operator|.
name|dp_linedis
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
name|netd
operator|.
name|dp_linefd
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|netd
operator|.
name|dp_linedis
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|netd
operator|.
name|dp_linefd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Network line discipline turned off.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NETLDISC
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
comment|/* kill myself */
block|}
end_block

begin_comment
comment|/* check a request to see if it is an acct pair */
end_comment

begin_comment
comment|/* returns 1 if it is, 0 if not */
end_comment

begin_expr_stmt
specifier|static
name|facctpaircheck
argument_list|(
name|phd
argument_list|)
specifier|register
expr|struct
name|header
operator|*
name|phd
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

