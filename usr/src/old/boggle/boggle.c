begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)boggle.c	5.3 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* basic parameters */
end_comment

begin_define
define|#
directive|define
name|N
value|4
end_define

begin_define
define|#
directive|define
name|SSIZE
value|200
end_define

begin_define
define|#
directive|define
name|MAXWORDS
value|1000
end_define

begin_define
define|#
directive|define
name|CWIDTH
value|10
end_define

begin_define
define|#
directive|define
name|LWIDTH
value|80
end_define

begin_comment
comment|/* parameters defined in terms of above */
end_comment

begin_define
define|#
directive|define
name|BSIZE
value|(N*N)
end_define

begin_define
define|#
directive|define
name|row
parameter_list|(
name|x
parameter_list|)
value|(x/N)
end_define

begin_define
define|#
directive|define
name|col
parameter_list|(
name|x
parameter_list|)
value|(x%N)
end_define

begin_comment
comment|/* word being searched for */
end_comment

begin_decl_stmt
name|int
name|wlength
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numsame
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|wbuff
index|[
name|BSIZE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tty and process control */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pipefd
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|super
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delct
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zero
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|master
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|column
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|timept
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|timeint
index|[]
init|=
block|{
literal|60
block|,
literal|60
block|,
literal|50
block|,
literal|7
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|timein
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|long
name|int
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|sgttyb
name|origttyb
decl_stmt|,
name|tempttyb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ctlecho
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lctlech
init|=
name|LCTLECH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* monitoring variables */
end_comment

begin_decl_stmt
name|int
name|games
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|logfile
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|logloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|logbuff
index|[
literal|100
index|]
init|=
block|{
literal|"inst\t"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ctime
argument_list|()
decl_stmt|,
modifier|*
name|getlogin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* dictionary interface */
end_comment

begin_decl_stmt
name|char
name|defname
index|[]
init|=
literal|"/usr/games/lib/bogdict"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dictname
init|=
operator|&
name|defname
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|dict
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* structures for doing matching */
end_comment

begin_struct
struct|struct
name|frame
block|{
name|struct
name|frame
modifier|*
name|parent
decl_stmt|;
name|int
name|place
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|frame
name|stack
index|[
name|SSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frame
modifier|*
name|level
index|[
name|BSIZE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the board and subsidiary structures */
end_comment

begin_decl_stmt
name|char
name|present
index|[
name|BSIZE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|board
index|[
name|BSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|olink
index|[
name|BSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|adj
index|[
name|BSIZE
operator|+
literal|1
index|]
index|[
name|BSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|occurs
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the boggle cubes */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cube
index|[
name|BSIZE
index|]
init|=
block|{
literal|"forixb"
block|,
literal|"moqabj"
block|,
literal|"gurilw"
block|,
literal|"setupl"
block|,
literal|"cmpdae"
block|,
literal|"acitao"
block|,
literal|"slcrae"
block|,
literal|"romash"
block|,
literal|"nodesw"
block|,
literal|"hefiye"
block|,
literal|"onudtk"
block|,
literal|"tevign"
block|,
literal|"anedvz"
block|,
literal|"pinesh"
block|,
literal|"abilyt"
block|,
literal|"gkyleu"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* storage for words found */
end_comment

begin_decl_stmt
name|int
name|ubotch
decl_stmt|,
name|ustart
decl_stmt|,
name|wcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|word
index|[
name|MAXWORDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|freesp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|space
index|[
literal|10000
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|endline
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|column
operator|!=
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|timeout
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|*
name|timept
operator|>
literal|0
condition|)
block|{
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
operator|*
name|timept
operator|++
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\007'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|interrupt
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt
argument_list|)
expr_stmt|;
if|if
condition|(
name|delct
operator|++
operator|>=
literal|1
condition|)
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|timept
operator|=
operator|&
name|zero
expr_stmt|;
block|}
end_block

begin_macro
name|goodbye
argument_list|(
argument|stat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|stat
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|master
operator|!=
literal|0
condition|)
block|{
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlecho
operator|&
name|LCTLECH
condition|)
block|{
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCLBIS
argument_list|,
operator|&
name|lctlech
argument_list|)
expr_stmt|;
block|}
name|stty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|origttyb
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|clearscreen
argument_list|()
end_macro

begin_block
block|{
name|stty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|tempttyb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\033\f\r"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|compare
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|wordcomp
argument_list|(
operator|*
name|a
argument_list|,
operator|*
name|b
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|wordcomp
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
specifier|register
name|char
operator|*
name|p
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
operator|&&
operator|*
name|q
operator|!=
literal|'0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
operator|&&
operator|*
name|q
operator|==
literal|'0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|*
operator|++
name|p
operator|==
operator|*
operator|++
name|q
operator|&&
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
operator|(
operator|-
name|isalpha
argument_list|(
operator|*
name|q
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|q
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
operator|*
name|p
operator|-
operator|*
name|q
operator|)
return|;
block|}
end_block

begin_macro
name|printinst
argument_list|()
end_macro

begin_block
block|{
name|stty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|tempttyb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"instructions?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getchar
argument_list|()
operator|==
literal|'y'
condition|)
block|{
name|clearscreen
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"     The object of Boggle (TM  Parker  Bros.)  is  to  find,  within  3\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"minutes,  as many words as possible in a 4 by 4 grid of letters.  Words\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"may be formed from any sequence of 3 or more adjacent  letters  in  the\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"grid.   The  letters  may join horizontally, vertically, or diagonally.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"However, no position in the grid may be used more than once within  any\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"one  word.   In  competitive  play amongst humans, each player is given\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"credit for those of his words which no other player has found.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     This program is intended  for  people  wishing  to  sharpen  their\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"skills  at  Boggle.   If  you  invoke the program with 4 arguments of 4\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"letters each, (e.g. \"boggle appl epie moth erhd\") the program forms the\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"obvious  Boggle grid and lists all the words from /usr/dict/words found\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"therein.  If you invoke the program without arguments, it will generate\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"a  board  for you, let you enter words for 3 minutes, and then tell you\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"how well you did relative to /usr/dict/words.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     In interactive play, enter your words separated by  spaces,  tabs,\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"or  newlines.   A  bell will ring when there is 2:00, 1:00, 0:10, 0:02,\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0:01, and 0:00 time left.  You may complete any word started before the\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"expiration  of  time.   You  can surrender before time is up by hitting\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"'break'.  While entering words, your erase character is only  effective\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"within the current word and your line kill character is ignored.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     Advanced players may wish to invoke the program with 1 or 2 +'s as\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"the  first argument.  The first + removes the restriction that positions\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"can only be used once in each word.  The second + causes a position  to\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"be  considered  adjacent  to itself as well as its (up to) 8 neighbors.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Hit any key to begin.\n"
argument_list|)
expr_stmt|;
name|stty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|tempttyb
argument_list|)
expr_stmt|;
name|getchar
argument_list|()
expr_stmt|;
block|}
name|stty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|tempttyb
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setup
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|rd
decl_stmt|,
name|cd
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BSIZE
condition|;
name|i
operator|++
control|)
block|{
name|adj
index|[
name|i
index|]
index|[
name|i
index|]
operator|=
name|super
operator|>=
literal|2
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|adj
index|[
name|BSIZE
index|]
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|rd
operator|=
name|row
argument_list|(
name|i
argument_list|)
operator|-
name|row
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|cd
operator|=
name|col
argument_list|(
name|i
argument_list|)
operator|-
name|col
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|rd
condition|)
block|{
case|case
operator|-
literal|1
case|:
case|case
literal|1
case|:
if|if
condition|(
operator|-
literal|1
operator|<=
name|cd
operator|&&
name|cd
operator|<=
literal|1
condition|)
name|k
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|cd
operator|==
operator|-
literal|1
operator|||
name|cd
operator|==
literal|1
condition|)
name|k
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|adj
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|adj
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
block|}
block|}
name|stack
index|[
literal|0
index|]
operator|.
name|parent
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
name|stack
index|[
literal|0
index|]
operator|.
name|place
operator|=
name|BSIZE
expr_stmt|;
name|level
index|[
literal|0
index|]
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
name|level
index|[
literal|1
index|]
operator|=
operator|&
name|stack
index|[
literal|1
index|]
expr_stmt|;
block|}
end_block

begin_macro
name|makelists
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
name|occurs
index|[
name|i
index|]
operator|=
name|BSIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BSIZE
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|board
index|[
name|i
index|]
expr_stmt|;
name|olink
index|[
name|i
index|]
operator|=
name|occurs
index|[
name|c
operator|-
literal|'a'
index|]
expr_stmt|;
name|occurs
index|[
name|c
operator|-
literal|'a'
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|genboard
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BSIZE
condition|;
name|i
operator|++
control|)
name|board
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BSIZE
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|rand
argument_list|()
operator|%
name|BSIZE
expr_stmt|;
while|while
condition|(
name|board
index|[
name|j
index|]
operator|!=
literal|0
condition|)
name|j
operator|=
operator|(
name|j
operator|+
literal|1
operator|)
operator|%
name|BSIZE
expr_stmt|;
name|board
index|[
name|j
index|]
operator|=
name|cube
index|[
name|i
index|]
index|[
name|rand
argument_list|()
operator|%
literal|6
index|]
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|printboard
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\t\t\t\t\b\b"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N
condition|;
name|j
operator|++
control|)
block|{
name|putchar
argument_list|(
operator|(
name|putchar
argument_list|(
name|board
index|[
name|i
operator|*
name|N
operator|+
name|j
index|]
argument_list|)
operator|==
literal|'q'
operator|)
condition|?
literal|'u'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getdword
argument_list|()
end_macro

begin_block
block|{
comment|/* input:  numsame = # chars same as last word   */
comment|/* output: numsame = # same chars for next word  */
comment|/*        word in wbuff[0]...wbuff[wlength-1]    */
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|numsame
operator|==
name|EOF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
operator|&
name|wbuff
index|[
name|numsame
index|]
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
name|c
operator|=
name|getc
argument_list|(
name|dict
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
empty_stmt|;
name|numsame
operator|=
name|c
expr_stmt|;
name|wlength
operator|=
name|p
operator|-
operator|&
name|wbuff
index|[
literal|2
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|getuword
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|numsame
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|timept
operator|>
literal|0
operator|&&
operator|(
name|isspace
argument_list|(
name|c
operator|=
name|getchar
argument_list|()
argument_list|)
operator|||
name|c
operator|==
name|EOF
operator|)
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|timept
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|word
index|[
name|wcount
operator|++
index|]
operator|=
name|freesp
expr_stmt|;
operator|*
name|freesp
operator|++
operator|=
literal|'0'
expr_stmt|;
name|r
operator|=
operator|&
name|wbuff
index|[
literal|1
index|]
expr_stmt|;
name|q
operator|=
name|p
operator|=
name|freesp
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
name|c
operator|=
name|getchar
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
name|origttyb
operator|.
name|sg_erase
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|q
condition|)
name|p
operator|--
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|freesp
operator|=
name|p
expr_stmt|;
for|for
control|(
name|p
operator|=
name|q
init|;
name|p
operator|<
name|freesp
operator|&&
name|r
operator|<
operator|&
name|wbuff
index|[
name|BSIZE
index|]
condition|;
control|)
if|if
condition|(
name|islower
argument_list|(
name|c
operator|=
operator|*
name|p
operator|++
argument_list|)
operator|&&
operator|(
operator|*
name|r
operator|++
operator|=
operator|*
name|q
operator|++
operator|=
name|c
operator|)
operator|==
literal|'q'
operator|&&
operator|*
name|p
operator|==
literal|'u'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
operator|(
name|freesp
operator|=
name|q
operator|)
operator|=
literal|'0'
expr_stmt|;
name|wlength
operator|=
name|r
operator|-
operator|&
name|wbuff
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|aputuword
argument_list|(
argument|ways
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ways
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|word
index|[
name|wcount
operator|-
literal|1
index|]
operator|=
name|ways
operator|>=
literal|10
condition|?
literal|'*'
else|:
literal|'0'
operator|+
name|ways
expr_stmt|;
block|}
end_block

begin_macro
name|aputword
argument_list|(
argument|ways
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ways
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* store (wbuff, ways) in next slot in space */
specifier|register
name|int
name|i
decl_stmt|;
operator|*
name|freesp
operator|++
operator|=
name|ways
operator|>=
literal|10
condition|?
literal|'*'
else|:
literal|'0'
operator|+
name|ways
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|wlength
condition|;
name|i
operator|++
control|)
operator|*
name|freesp
operator|++
operator|=
name|wbuff
index|[
name|i
index|]
expr_stmt|;
name|word
index|[
operator|++
name|wcount
index|]
operator|=
name|freesp
expr_stmt|;
block|}
end_block

begin_macro
name|tputword
argument_list|(
argument|ways
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ways
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* print (wbuff, ways) on terminal */
name|wbuff
index|[
name|wlength
operator|+
literal|1
index|]
operator|=
literal|'0'
expr_stmt|;
name|wbuff
index|[
literal|0
index|]
operator|=
name|ways
operator|>=
literal|10
condition|?
literal|'*'
else|:
literal|'0'
operator|+
name|ways
expr_stmt|;
name|outword
argument_list|(
operator|&
name|wbuff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|outword
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|newcol
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|+
literal|1
init|;
name|isalpha
argument_list|(
operator|*
name|q
argument_list|)
condition|;
control|)
block|{
name|putchar
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|++
operator|==
literal|'q'
condition|)
block|{
name|putchar
argument_list|(
literal|'u'
argument_list|)
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
block|}
name|column
operator|+=
name|q
operator|-
name|p
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|column
operator|>
name|LWIDTH
operator|-
name|CWIDTH
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|newcol
operator|=
operator|(
operator|(
name|column
operator|+
name|CWIDTH
operator|)
operator|/
name|CWIDTH
operator|)
operator|*
name|CWIDTH
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|column
operator|+
literal|8
operator|)
operator|/
literal|8
operator|)
operator|*
literal|8
operator|<=
name|newcol
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|column
operator|=
operator|(
operator|(
name|column
operator|+
literal|8
operator|)
operator|/
literal|8
operator|)
operator|*
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|column
operator|<
name|newcol
condition|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|printdiff
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|d
decl_stmt|,
name|u
decl_stmt|;
name|char
name|both
decl_stmt|,
name|donly
decl_stmt|,
name|uonly
decl_stmt|;
name|word
index|[
name|wcount
index|]
operator|=
name|freesp
expr_stmt|;
operator|*
name|freesp
operator|=
literal|'0'
expr_stmt|;
name|both
operator|=
name|donly
operator|=
name|uonly
operator|=
name|column
operator|=
name|d
operator|=
literal|0
expr_stmt|;
name|u
operator|=
name|ustart
expr_stmt|;
while|while
condition|(
name|d
operator|<
name|ubotch
condition|)
block|{
name|c
operator|=
name|u
operator|<
name|wcount
condition|?
name|wordcomp
argument_list|(
name|word
index|[
name|d
index|]
argument_list|,
name|word
index|[
name|u
index|]
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* dict and user found same word */
if|if
condition|(
name|both
operator|==
literal|0
condition|)
block|{
name|both
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t\t   we both found:\n"
argument_list|)
expr_stmt|;
block|}
name|outword
argument_list|(
name|word
index|[
name|d
index|]
argument_list|)
expr_stmt|;
name|word
index|[
name|d
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
name|word
index|[
name|u
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
comment|/* dict found it, user didn't */
name|donly
operator|=
literal|1
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* user found it, dict didn't */
name|uonly
operator|=
literal|1
expr_stmt|;
name|u
operator|++
expr_stmt|;
block|}
block|}
name|endline
argument_list|()
expr_stmt|;
if|if
condition|(
name|donly
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\t\tI alone found these:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|ubotch
condition|;
name|d
operator|++
control|)
if|if
condition|(
name|word
index|[
name|d
index|]
operator|!=
name|NULL
condition|)
name|outword
argument_list|(
name|word
index|[
name|d
index|]
argument_list|)
expr_stmt|;
name|endline
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|uonly
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\t\tyou alone found these:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|ustart
init|;
name|u
operator|<
name|wcount
condition|;
name|u
operator|++
control|)
if|if
condition|(
name|word
index|[
name|u
index|]
operator|!=
name|NULL
condition|)
name|outword
argument_list|(
name|word
index|[
name|u
index|]
argument_list|)
expr_stmt|;
name|endline
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ubotch
operator|<
name|ustart
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\t\t  you botched these:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|ubotch
init|;
name|u
operator|<
name|ustart
condition|;
name|u
operator|++
control|)
name|outword
argument_list|(
name|word
index|[
name|u
index|]
argument_list|)
expr_stmt|;
name|endline
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|numways
argument_list|(
name|leaf
argument_list|,
name|last
argument_list|)
specifier|register
expr|struct
name|frame
operator|*
name|leaf
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|frame
modifier|*
name|last
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|frame
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|super
operator|>
literal|0
condition|)
return|return
operator|(
name|last
operator|-
name|leaf
operator|)
return|;
name|count
operator|=
literal|0
expr_stmt|;
name|present
index|[
name|BSIZE
index|]
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|leaf
operator|<
name|last
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|present
index|[
literal|0
index|]
init|;
name|p
operator|<
operator|&
name|present
index|[
name|BSIZE
index|]
condition|;
operator|*
name|p
operator|++
operator|=
literal|0
control|)
empty_stmt|;
for|for
control|(
name|node
operator|=
name|leaf
init|;
name|present
index|[
name|node
operator|->
name|place
index|]
operator|++
operator|==
literal|0
condition|;
name|node
operator|=
name|node
operator|->
name|parent
control|)
empty_stmt|;
if|if
condition|(
name|node
operator|==
operator|&
name|stack
index|[
literal|0
index|]
condition|)
name|count
operator|++
expr_stmt|;
name|leaf
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_macro
name|evalboard
argument_list|(
argument|getword
argument_list|,
argument|putword
argument_list|)
end_macro

begin_decl_stmt
name|int
argument_list|(
operator|*
name|getword
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|putword
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|frame
modifier|*
name|top
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|,
name|q
decl_stmt|;
name|int
name|fo
decl_stmt|,
name|found
decl_stmt|;
name|struct
name|frame
modifier|*
name|parent
decl_stmt|,
modifier|*
name|lastparent
decl_stmt|;
name|char
modifier|*
name|padj
decl_stmt|;
name|numsame
operator|=
name|found
operator|=
literal|0
expr_stmt|;
name|makelists
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|l
operator|=
name|numsame
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|getword
call|)
argument_list|()
condition|)
break|break;
name|top
operator|=
name|level
index|[
name|l
operator|+
literal|1
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|level
index|[
name|l
operator|+
literal|1
index|]
operator|=
name|lastparent
operator|=
name|top
expr_stmt|;
comment|/* wbuff[1]...wbuff[l] have been matched */
comment|/* level[0],...,level[l] of tree built */
if|if
condition|(
name|l
operator|==
name|wlength
condition|)
block|{
if|if
condition|(
name|wlength
operator|>=
literal|3
operator|&&
operator|(
name|q
operator|=
name|numways
argument_list|(
name|level
index|[
name|l
index|]
argument_list|,
name|top
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|putword
call|)
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
name|l
operator|=
name|BSIZE
operator|+
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|fo
operator|=
name|occurs
index|[
name|wbuff
index|[
operator|++
name|l
index|]
operator|-
literal|'a'
index|]
operator|)
operator|==
name|BSIZE
condition|)
break|break;
comment|/* wbuff[1]...wbuff[l-1] have been matched */
comment|/* level[0],...,level[l-1] of tree built */
for|for
control|(
name|parent
operator|=
name|level
index|[
name|l
operator|-
literal|1
index|]
init|;
name|parent
operator|<
name|lastparent
condition|;
name|parent
operator|++
control|)
block|{
name|padj
operator|=
operator|&
name|adj
index|[
name|parent
operator|->
name|place
index|]
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|q
operator|=
name|fo
init|;
name|q
operator|!=
name|BSIZE
condition|;
name|q
operator|=
name|olink
index|[
name|q
index|]
control|)
if|if
condition|(
name|padj
index|[
name|q
index|]
condition|)
block|{
name|top
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|top
operator|->
name|place
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|++
name|top
operator|>=
operator|&
name|stack
index|[
name|SSIZE
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"stack overflow\n"
argument_list|)
expr_stmt|;
name|goodbye
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* were any nodes added? */
if|if
condition|(
name|top
operator|==
name|lastparent
condition|)
break|break;
block|}
comment|/* advance until first l characters of next word are different */
while|while
condition|(
name|numsame
operator|>=
name|l
operator|&&
call|(
modifier|*
name|getword
call|)
argument_list|()
condition|)
empty_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|gtty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|origttyb
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tempttyb
operator|=
name|origttyb
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|!=
literal|0
condition|)
name|goodbye
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt
argument_list|)
expr_stmt|;
name|timein
operator|=
name|time
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'a'
operator|&&
operator|(
name|logfile
operator|=
name|open
argument_list|(
literal|"/usr/games/boglog"
argument_list|,
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|p
operator|=
operator|&
name|logbuff
index|[
literal|5
index|]
expr_stmt|;
name|q
operator|=
name|getlogin
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
condition|)
empty_stmt|;
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\t'
expr_stmt|;
name|q
operator|=
name|ctime
argument_list|(
operator|&
name|timein
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
condition|)
empty_stmt|;
name|logloc
operator|=
name|lseek
argument_list|(
name|logfile
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|logfile
argument_list|,
operator|&
name|logbuff
index|[
literal|0
index|]
argument_list|,
name|p
operator|-
operator|&
name|logbuff
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dict
operator|=
name|fopen
argument_list|(
name|dictname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"can't open %s\n"
argument_list|,
name|dictname
argument_list|)
expr_stmt|;
name|goodbye
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
while|while
condition|(
operator|*
operator|(
name|argv
index|[
literal|1
index|]
operator|++
operator|)
operator|==
literal|'+'
condition|)
name|super
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|timeint
index|[
literal|0
index|]
operator|=
literal|60
operator|*
operator|(
name|atol
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|-
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|timeint
index|[
literal|0
index|]
operator|<=
literal|0
condition|)
block|{
name|timeint
index|[
literal|0
index|]
operator|=
literal|60
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
block|}
name|setup
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|argc
condition|)
block|{
default|default:
name|punt
label|:
name|printf
argument_list|(
literal|"usage: boggle [+[+]] [row1 row2 row3 row4]\n"
argument_list|)
expr_stmt|;
name|goodbye
argument_list|(
literal|3
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BSIZE
condition|;
name|i
operator|++
control|)
block|{
name|board
index|[
name|i
index|]
operator|=
name|c
operator|=
name|argv
index|[
name|row
argument_list|(
name|i
argument_list|)
operator|+
literal|1
index|]
index|[
name|col
argument_list|(
name|i
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|islower
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"bad board\n"
argument_list|)
expr_stmt|;
goto|goto
name|punt
goto|;
block|}
block|}
name|printboard
argument_list|()
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
name|evalboard
argument_list|(
name|getdword
argument_list|,
name|tputword
argument_list|)
expr_stmt|;
name|endline
argument_list|()
expr_stmt|;
if|if
condition|(
name|logfile
operator|>=
literal|0
condition|)
block|{
name|strncpy
argument_list|(
operator|&
name|logbuff
index|[
literal|0
index|]
argument_list|,
literal|"eval"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|logfile
argument_list|,
name|logloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|logfile
argument_list|,
operator|&
name|logbuff
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|goodbye
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|tempttyb
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|ctlecho
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ctlecho
operator|&
name|LCTLECH
condition|)
block|{
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCLBIC
argument_list|,
operator|&
name|lctlech
argument_list|)
expr_stmt|;
block|}
block|}
name|printinst
argument_list|()
expr_stmt|;
name|srand
argument_list|(
operator|(
name|int
operator|)
name|timein
argument_list|)
expr_stmt|;
while|while
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
operator|&
name|pipefd
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"can't create pipe\n"
argument_list|)
expr_stmt|;
name|goodbye
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|genboard
argument_list|()
expr_stmt|;
name|delct
operator|=
name|wcount
operator|=
literal|0
expr_stmt|;
name|word
index|[
literal|0
index|]
operator|=
name|freesp
operator|=
operator|&
name|space
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|master
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|clearscreen
argument_list|()
expr_stmt|;
name|printboard
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|timept
operator|=
operator|&
name|timeint
index|[
literal|0
index|]
expr_stmt|;
name|alarm
argument_list|(
operator|*
name|timept
operator|++
argument_list|)
expr_stmt|;
name|evalboard
argument_list|(
name|getuword
argument_list|,
name|aputuword
argument_list|)
expr_stmt|;
name|clearscreen
argument_list|()
expr_stmt|;
name|qsort
argument_list|(
operator|&
name|word
index|[
literal|0
index|]
argument_list|,
name|wcount
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|compare
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|wordcomp
argument_list|(
name|word
index|[
name|i
index|]
argument_list|,
name|word
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|word
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
operator|*
operator|++
name|p
argument_list|)
condition|)
empty_stmt|;
name|write
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|,
name|word
index|[
name|i
index|]
argument_list|,
name|p
operator|-
name|word
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|goodbye
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|dict
argument_list|)
expr_stmt|;
name|getc
argument_list|(
name|dict
argument_list|)
expr_stmt|;
name|evalboard
argument_list|(
name|getdword
argument_list|,
name|aputword
argument_list|)
expr_stmt|;
name|p
operator|=
name|freesp
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|,
name|freesp
argument_list|,
literal|512
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
break|break;
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|freesp
operator|+=
name|i
expr_stmt|;
block|}
name|close
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ustart
operator|=
name|ubotch
operator|=
name|wcount
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|freesp
condition|)
block|{
name|word
index|[
name|wcount
operator|++
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
name|ustart
operator|=
name|wcount
expr_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
operator|*
operator|++
name|p
argument_list|)
condition|)
empty_stmt|;
block|}
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|goodbye
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|delct
operator|=
literal|1
expr_stmt|;
name|printdiff
argument_list|()
expr_stmt|;
name|printboard
argument_list|()
expr_stmt|;
name|games
operator|++
expr_stmt|;
if|if
condition|(
name|logfile
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
operator|&
name|logbuff
index|[
literal|0
index|]
argument_list|,
literal|"%4d"
argument_list|,
name|games
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|logfile
argument_list|,
name|logloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|logfile
argument_list|,
operator|&
name|logbuff
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|stty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|tempttyb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nanother game?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getchar
argument_list|()
operator|!=
literal|'y'
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
name|stty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|tempttyb
argument_list|)
expr_stmt|;
block|}
name|goodbye
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

