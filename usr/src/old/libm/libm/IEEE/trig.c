begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
name|From
name|Prof
operator|.
name|Kahan
name|at
name|UC
name|at
name|Berkeley
comment|/*   * Copyright (c) 1985 Regents of the University of California.  *   * Use and reproduction of this software are granted  in  accordance  with  * the terms and conditions specified in  the  Berkeley  Software  License  * Agreement (in particular, this entails acknowledgement of the programs'  * source, and inclusion of this notice) with the additional understanding  * that  all  recipients  should regard themselves as participants  in  an  * ongoing  research  project and hence should  feel  obligated  to report  * their  experiences (good or bad) with these elementary function  codes,  * using "sendbug 4bsd-bugs@BERKELEY", to the authors.  */
ifndef|#
directive|ifndef
name|lint
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)trig.c	1.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/* SIN(X), COS(X), TAN(X)  * RETURN THE SINE, COSINE, AND TANGENT OF X RESPECTIVELY  * DOUBLE PRECISION (VAX D format 56 bits, IEEE DOUBLE 53 BITS)  * CODED IN C BY K.C. NG, 1/8/85;   * REVISED BY K.C. NG on 1/31/85, 3/17/85, 3/24/85.  *  * Required system supported functions:  *      copysign(x,y)  *      finite(x)  *      drem(x,p)  *  * Kernel functions:  *      sin__S(z)       ....sin__S(x*x) return (sin(x)-x)/x  *      cos__C(z)       ....cos__C(x*x) return cos(x)-1-x*x/2  *  * Method :  *      Let S and C denote the polynomial approximations to sin and cos   *      respectively on [-PI/4, +PI/4].  *      1. Reduce the argument into [-PI , +PI] by the remainder function.    *      2. For x in (-PI,+PI), let k=|x|*4/PI rounded. According to the value   *         of k,  sin, cos, and tan of x are computed by:  *  *         k         sin(x)      cos(x)       tan (x)        remark  *     -----------------------------------------------------------------------  *        k=0        S(x)         C(x)       S(x)/C(x)  *        k=1,2  sign(x)*C(y)     S(y)   sign(x)*C(y)/S(y)  y=PI/2-|x|  *        k=3        S(y)        -C(y)      S(-y)/C(-y)      y=sign(x)*(PI-|x|)  *     -----------------------------------------------------------------------  *  *   Notes:  *      1. S(y) and C(y) were computed by:  *              S(y) = y+y*sin__S(y*y)   *              C(y) = 1-(y*y/2-cos__C(x*x))              ... if y*y<  0.5,  *                   = 0.5-((y*y/2-0.5)-cos__C(x*x))      ... if y*y>= 0.5.  *  *      2. For better accuracy, we use the following formula for S/C for tan  *         (k=0,3): let ss=sin__S(y*y), and cc=cos__C(y*y), then  *  *                            y+y*ss             (y*y/2-cc)+ss  *             S(y)/C(y)   = -------- = y + y * ---------------.  *                               C                     C   *  *  * Special cases:  *      Let trig be any of sin, cos, or tan.  *      trig(+-INF) is NAN, with signals;  *      trig(NAN)   is that NAN;  *      trig(n*PI/2) is exact for any integer n, provided n*PI is representable;  *      otherwise, trig(x) is inexact.   *  * Accuracy:  *      trig(x) returns the exact trig(x*pi/PI) nearly rounded, where  *  *      Decimal:  *              pi = 3.141592653589793 23846264338327 .....   *    53 bits   PI = 3.141592653589793 115997963 ..... ,  *    56 bits   PI = 3.141592653589793 227020265 ..... ,    *  *      Hexadecimal:  *              pi = 3.243F6A8885A308D313198A2E....  *              pi = 3.243F6A8885A308D313198A2E....  *    53 bits   PI = 3.243F6A8885A30  =  2 * 1.921FB54442D18    error=.276ulps  *    56 bits   PI = 3.243F6A8885A308 =  4 * .C90FDAA22168C2    error=.206ulps  *  *      In a test run with 1,024,000 random arguments on a VAX, the maximum  *      observed errors (compared with the exact trig(x*pi/PI)) were  *                      tan(x) : 2.08 ulps (units in the last place)  *                      sin(x) : .861 ulps  *                      cos(x) : .857 ulps  *  * Constants:  * The hexadecimal values are the intended ones for the following constants.  * The decimal values may be used, provided that the compiler will convert  * from decimal to binary accurately enough to produce the hexadecimal values  * shown.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VAX
end_ifdef

begin_comment
comment|/*thresh =  5.2234479296242364299E-1    , Hex  2^  0   *  .85B8636B026EA0 */
end_comment

begin_comment
comment|/*ivPIo4 =  1.2732395447351626816E0     , Hex  2^  1   *  .A2F9836E4E4415 */
end_comment

begin_comment
comment|/*PIo2   =  1.5707963267948966135E0     , Hex  2^  1   *  .C90FDAA22168C2 */
end_comment

begin_comment
comment|/*PI     =  3.1415926535897932270E0     , Hex  2^  2   *  .C90FDAA22168C2 */
end_comment

begin_comment
comment|/*PI2    =  6.2831853071795864540E0     ; Hex  2^  3   *  .C90FDAA22168C2 */
end_comment

begin_decl_stmt
specifier|static
name|long
name|threshx
index|[]
init|=
block|{
literal|0xb8634005
block|,
literal|0x6ea06b02
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|thresh
value|(*(double*)threshx)
end_define

begin_decl_stmt
specifier|static
name|long
name|ivPIo4x
index|[]
init|=
block|{
literal|0xf98340a2
block|,
literal|0x44156e4e
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ivPIo4
value|(*(double*)ivPIo4x)
end_define

begin_decl_stmt
specifier|static
name|long
name|PIo2x
index|[]
init|=
block|{
literal|0x0fda40c9
block|,
literal|0x68c2a221
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PIo2
value|(*(double*)PIo2x)
end_define

begin_decl_stmt
specifier|static
name|long
name|PIx
index|[]
init|=
block|{
literal|0x0fda4149
block|,
literal|0x68c2a221
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PI
value|(*(double*)PIx)
end_define

begin_decl_stmt
specifier|static
name|long
name|PI2x
index|[]
init|=
block|{
literal|0x0fda41c9
block|,
literal|0x68c2a221
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PI2
value|(*(double*)PI2x)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IEEE double  */
end_comment

begin_decl_stmt
specifier|static
name|double
name|thresh
init|=
literal|5.2234479296242364299E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -1   *  1.0B70C6D604DD4 */
name|ivPIo4
init|=
literal|1.2732395447351627649E0
decl_stmt|,
comment|/*Hex  2^  0   *  1.45F306DC9C883 */
name|PIo2
init|=
literal|1.5707963267948965580E0
decl_stmt|,
comment|/*Hex  2^  0   *  1.921FB54442D18 */
name|PI
init|=
literal|3.1415926535897931160E0
decl_stmt|,
comment|/*Hex  2^  1   *  1.921FB54442D18 */
name|PI2
init|=
literal|6.2831853071795862320E0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Hex  2^  2   *  1.921FB54442D18 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|double
name|zero
init|=
literal|0
decl_stmt|,
name|one
init|=
literal|1
decl_stmt|,
name|negone
init|=
operator|-
literal|1
decl_stmt|,
name|half
init|=
literal|1.0
operator|/
literal|2.0
decl_stmt|,
name|small
init|=
literal|1E
operator|-
literal|9
decl_stmt|,
name|big
init|=
literal|1E20
decl_stmt|;
end_decl_stmt

begin_function
name|double
name|tan
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|copysign
argument_list|()
decl_stmt|,
name|drem
argument_list|()
decl_stmt|,
name|cos__C
argument_list|()
decl_stmt|,
name|sin__S
argument_list|()
decl_stmt|,
name|a
decl_stmt|,
name|z
decl_stmt|,
name|ss
decl_stmt|,
name|cc
decl_stmt|,
name|t
decl_stmt|;
name|int
name|finite
argument_list|()
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|x
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* tan(NAN) is NAN */
if|if
condition|(
name|finite
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|=
name|drem
argument_list|(
name|x
argument_list|,
name|PI2
argument_list|)
expr_stmt|;
comment|/* reduce x into [-PI, PI] */
name|a
operator|=
name|copysign
argument_list|(
name|x
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|k
operator|=
name|a
operator|*
name|ivPIo4
expr_stmt|;
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|a
operator|=
name|PIo2
operator|-
name|a
expr_stmt|;
name|z
operator|=
name|a
operator|*
name|a
expr_stmt|;
name|cc
operator|=
name|cos__C
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|ss
operator|=
name|copysign
argument_list|(
name|a
operator|+
name|a
operator|*
name|sin__S
argument_list|(
name|z
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* return C(y)/S(y), y=sign(x)*PI-x */
return|return
operator|(
operator|(
operator|(
name|z
operator|>=
name|thresh
operator|)
condition|?
name|half
operator|-
operator|(
operator|(
name|z
operator|*
name|half
operator|-
name|half
operator|)
operator|-
name|cc
operator|)
else|:
name|one
operator|-
operator|(
name|z
operator|*
name|half
operator|-
name|cc
operator|)
operator|)
operator|/
name|ss
operator|)
return|;
default|default :
name|x
operator|=
name|copysign
argument_list|(
name|PI
operator|-
name|a
argument_list|,
operator|-
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* return S/C */
if|if
condition|(
name|copysign
argument_list|(
name|x
argument_list|,
name|one
argument_list|)
operator|>
name|small
condition|)
block|{
name|z
operator|=
name|x
operator|*
name|x
expr_stmt|;
name|cc
operator|=
name|cos__C
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|ss
operator|=
name|sin__S
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|t
operator|=
name|z
operator|*
name|half
expr_stmt|;
return|return
operator|(
name|x
operator|+
operator|(
name|x
operator|*
operator|(
name|t
operator|-
operator|(
name|cc
operator|-
name|ss
operator|)
operator|)
operator|)
operator|/
operator|(
operator|(
name|z
operator|>=
name|thresh
operator|)
condition|?
name|half
operator|-
operator|(
operator|(
name|t
operator|-
name|half
operator|)
operator|-
name|cc
operator|)
else|:
name|one
operator|-
operator|(
name|t
operator|-
name|cc
operator|)
operator|)
operator|)
return|;
block|}
else|else
comment|/* tan(x) := x for small x (inexact if x is not zero) */
block|{
if|if
condition|(
name|x
operator|!=
name|zero
condition|)
name|big
operator|+
name|small
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
block|}
else|else
return|return
operator|(
name|zero
operator|/
name|zero
operator|)
return|;
comment|/* tan(INF) is NAN with signal */
block|}
end_function

begin_function
name|double
name|sin
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|copysign
argument_list|()
decl_stmt|,
name|drem
argument_list|()
decl_stmt|,
name|sin__S
argument_list|()
decl_stmt|,
name|cos__C
argument_list|()
decl_stmt|,
name|a
decl_stmt|,
name|c
decl_stmt|,
name|z
decl_stmt|;
name|int
name|finite
argument_list|()
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|x
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* sin(NAN) is NAN */
if|if
condition|(
name|finite
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|=
name|drem
argument_list|(
name|x
argument_list|,
name|PI2
argument_list|)
expr_stmt|;
comment|/* reduce x into [-PI, PI] */
name|a
operator|=
name|copysign
argument_list|(
name|x
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|k
operator|=
name|a
operator|*
name|ivPIo4
expr_stmt|;
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|a
operator|=
name|PIo2
operator|-
name|a
expr_stmt|;
name|z
operator|=
name|a
operator|*
name|a
expr_stmt|;
name|c
operator|=
name|cos__C
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|z
operator|>=
name|thresh
operator|)
condition|?
name|half
operator|-
operator|(
operator|(
name|z
operator|*
name|half
operator|-
name|half
operator|)
operator|-
name|c
operator|)
else|:
name|one
operator|-
operator|(
name|z
operator|*
name|half
operator|-
name|c
operator|)
expr_stmt|;
comment|/* return sign(x)*C(PI/2-|x|) */
return|return
operator|(
name|copysign
argument_list|(
name|a
argument_list|,
name|x
argument_list|)
operator|)
return|;
default|default:
name|x
operator|=
name|copysign
argument_list|(
name|PI
operator|-
name|a
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* return S(x) */
if|if
condition|(
name|copysign
argument_list|(
name|x
argument_list|,
name|one
argument_list|)
operator|>
name|small
condition|)
return|return
operator|(
name|x
operator|+
name|x
operator|*
name|sin__S
argument_list|(
name|x
operator|*
name|x
argument_list|)
operator|)
return|;
else|else
comment|/* sin(x) := x for small x (inexact if x is not zero) */
block|{
if|if
condition|(
name|x
operator|!=
name|zero
condition|)
name|big
operator|+
name|small
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
block|}
else|else
return|return
operator|(
name|zero
operator|/
name|zero
operator|)
return|;
comment|/* sin(INF) is NAN with signal */
block|}
end_function

begin_function
name|double
name|cos
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|copysign
argument_list|()
decl_stmt|,
name|drem
argument_list|()
decl_stmt|,
name|sin__S
argument_list|()
decl_stmt|,
name|cos__C
argument_list|()
decl_stmt|,
name|a
decl_stmt|,
name|c
decl_stmt|,
name|z
decl_stmt|;
name|int
name|finite
argument_list|()
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|x
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* cos(NAN) is NAN */
if|if
condition|(
name|finite
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|=
name|drem
argument_list|(
name|x
argument_list|,
name|PI2
argument_list|)
expr_stmt|;
comment|/* reduce x into [-PI, PI] */
name|a
operator|=
name|copysign
argument_list|(
name|x
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|k
operator|=
name|a
operator|*
name|ivPIo4
expr_stmt|;
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|0
case|:
name|x
operator|=
name|one
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|a
operator|=
name|PIo2
operator|-
name|a
expr_stmt|;
comment|/* return S(PI/2-|x|) */
return|return
operator|(
name|a
operator|+
name|a
operator|*
name|sin__S
argument_list|(
name|a
operator|*
name|a
argument_list|)
operator|)
return|;
default|default:
name|a
operator|=
name|PI
operator|-
name|a
expr_stmt|;
name|x
operator|=
name|negone
expr_stmt|;
block|}
comment|/* return C or -C */
if|if
condition|(
name|copysign
argument_list|(
name|a
argument_list|,
name|one
argument_list|)
operator|>
name|small
condition|)
block|{
name|z
operator|=
name|a
operator|*
name|a
expr_stmt|;
name|c
operator|=
name|cos__C
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
name|z
operator|>=
name|thresh
operator|)
condition|?
name|half
operator|-
operator|(
operator|(
name|z
operator|*
name|half
operator|-
name|half
operator|)
operator|-
name|c
operator|)
else|:
name|one
operator|-
operator|(
name|z
operator|*
name|half
operator|-
name|c
operator|)
expr_stmt|;
return|return
operator|(
name|copysign
argument_list|(
name|a
argument_list|,
name|x
argument_list|)
operator|)
return|;
block|}
else|else
comment|/* cos(x) := 1 for small x (inexact if x is not zero) */
block|{
if|if
condition|(
name|x
operator|!=
name|zero
condition|)
name|big
operator|+
name|small
expr_stmt|;
return|return
operator|(
name|copysign
argument_list|(
name|one
argument_list|,
name|x
argument_list|)
operator|)
return|;
block|}
block|}
else|else
return|return
operator|(
name|zero
operator|/
name|zero
operator|)
return|;
comment|/* cos(INF) is NAN with signal */
block|}
end_function

begin_comment
comment|/* sin__S(x*x)  * DOUBLE PRECISION (VAX D format 56 bits, IEEE DOUBLE 53 BITS)  * KERNEL FUNCTION OF SIN(X), COS(X), AND TAN(X)   * CODED IN C BY K.C. NG, 1/21/85;   * REVISED BY K.C. NG on 1/31/85, 3/7/85.  *  *	    sin(x*k) - x  * RETURN  --------------- on [-PI/4,PI/4] , where k=pi/PI, PI is the rounded  *	            x	  * value of pi in machine precision:  *  *	Decimal:  *		pi = 3.141592653589793 23846264338327 .....   *    53 bits   PI = 3.141592653589793 115997963 ..... ,  *    56 bits   PI = 3.141592653589793 227020265 ..... ,    *  *	Hexadecimal:  *		pi = 3.243F6A8885A308D313198A2E....  *    53 bits   PI = 3.243F6A8885A30  =  2 * 1.921FB54442D18  *    56 bits   PI = 3.243F6A8885A308 =  4 * .C90FDAA22168C2      *  * Method:  *	1. Let z=x*x. Create a polynomial approximation to   *	    (sin(k*x)-x)/x  =  z*(S0 + S1*z^1 + ... + S5*z^5).  *	Then  *      sin__S(x*x) = z*(S0 + S1*z^1 + ... + S5*z^5)  *  *	The coefficient S's are obtained by a special Remez algorithm.  *  * Accuracy:  *	In the absence of rounding error, the approximation has absolute error   *	less than 2**(-61.11) for VAX D FORMAT, 2**(-57.45) for IEEE DOUBLE.   *  * Constants:  * The hexadecimal values are the intended ones for the following constants.  * The decimal values may be used, provided that the compiler will convert  * from decimal to binary accurately enough to produce the hexadecimal values  * shown.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VAX
end_ifdef

begin_comment
comment|/*S0     = -1.6666666666666646660E-1    , Hex  2^ -2   * -.AAAAAAAAAAAA71 */
end_comment

begin_comment
comment|/*S1     =  8.3333333333297230413E-3    , Hex  2^ -6   *  .8888888888477F */
end_comment

begin_comment
comment|/*S2     = -1.9841269838362403710E-4    , Hex  2^-12   * -.D00D00CF8A1057 */
end_comment

begin_comment
comment|/*S3     =  2.7557318019967078930E-6    , Hex  2^-18   *  .B8EF1CA326BEDC */
end_comment

begin_comment
comment|/*S4     = -2.5051841873876551398E-8    , Hex  2^-25   * -.D73195374CE1D3 */
end_comment

begin_comment
comment|/*S5     =  1.6028995389845827653E-10   , Hex  2^-32   *  .B03D9C6D26CCCC */
end_comment

begin_comment
comment|/*S6     = -6.2723499671769283121E-13   ; Hex  2^-40   * -.B08D0B7561EA82 */
end_comment

begin_decl_stmt
specifier|static
name|long
name|S0x
index|[]
init|=
block|{
literal|0xaaaabf2a
block|,
literal|0xaa71aaaa
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S0
value|(*(double*)S0x)
end_define

begin_decl_stmt
specifier|static
name|long
name|S1x
index|[]
init|=
block|{
literal|0x88883d08
block|,
literal|0x477f8888
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S1
value|(*(double*)S1x)
end_define

begin_decl_stmt
specifier|static
name|long
name|S2x
index|[]
init|=
block|{
literal|0x0d00ba50
block|,
literal|0x1057cf8a
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S2
value|(*(double*)S2x)
end_define

begin_decl_stmt
specifier|static
name|long
name|S3x
index|[]
init|=
block|{
literal|0xef1c3738
block|,
literal|0xbedca326
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S3
value|(*(double*)S3x)
end_define

begin_decl_stmt
specifier|static
name|long
name|S4x
index|[]
init|=
block|{
literal|0x3195b3d7
block|,
literal|0xe1d3374c
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S4
value|(*(double*)S4x)
end_define

begin_decl_stmt
specifier|static
name|long
name|S5x
index|[]
init|=
block|{
literal|0x3d9c3030
block|,
literal|0xcccc6d26
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S5
value|(*(double*)S5x)
end_define

begin_decl_stmt
specifier|static
name|long
name|S6x
index|[]
init|=
block|{
literal|0x8d0bac30
block|,
literal|0xea827561
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S6
value|(*(double*)S6x)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IEEE double  */
end_comment

begin_decl_stmt
specifier|static
name|double
name|S0
init|=
operator|-
literal|1.6666666666666463126E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -3   * -1.555555555550C */
name|S1
init|=
literal|8.3333333332992771264E
operator|-
literal|3
decl_stmt|,
comment|/*Hex  2^ -7   *  1.111111110C461 */
name|S2
init|=
operator|-
literal|1.9841269816180999116E
operator|-
literal|4
decl_stmt|,
comment|/*Hex  2^-13   * -1.A01A019746345 */
name|S3
init|=
literal|2.7557309793219876880E
operator|-
literal|6
decl_stmt|,
comment|/*Hex  2^-19   *  1.71DE3209CDCD9 */
name|S4
init|=
operator|-
literal|2.5050225177523807003E
operator|-
literal|8
decl_stmt|,
comment|/*Hex  2^-26   * -1.AE5C0E319A4EF */
name|S5
init|=
literal|1.5868926979889205164E
operator|-
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Hex  2^-33   *  1.5CF61DF672B13 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|double
name|sin__S
parameter_list|(
name|z
parameter_list|)
name|double
name|z
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VAX
return|return
operator|(
name|z
operator|*
operator|(
name|S0
operator|+
name|z
operator|*
operator|(
name|S1
operator|+
name|z
operator|*
operator|(
name|S2
operator|+
name|z
operator|*
operator|(
name|S3
operator|+
name|z
operator|*
operator|(
name|S4
operator|+
name|z
operator|*
operator|(
name|S5
operator|+
name|z
operator|*
name|S6
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
return|;
else|#
directive|else
comment|/* IEEE double */
return|return
operator|(
name|z
operator|*
operator|(
name|S0
operator|+
name|z
operator|*
operator|(
name|S1
operator|+
name|z
operator|*
operator|(
name|S2
operator|+
name|z
operator|*
operator|(
name|S3
operator|+
name|z
operator|*
operator|(
name|S4
operator|+
name|z
operator|*
name|S5
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* cos__C(x*x)  * DOUBLE PRECISION (VAX D FORMAT 56 BITS, IEEE DOUBLE 53 BITS)  * KERNEL FUNCTION OF SIN(X), COS(X), AND TAN(X)   * CODED IN C BY K.C. NG, 1/21/85;   * REIVSED BY K.C. NG on 1/31/85, 3/7/85.  *  *	   		    x*x	  * RETURN   cos(k*x) - 1 + ----- on [-PI/4,PI/4],  where k = pi/PI,  *	  		     2	  * PI is the rounded value of pi in machine precision :  *  *	Decimal:  *		pi = 3.141592653589793 23846264338327 .....   *    53 bits   PI = 3.141592653589793 115997963 ..... ,  *    56 bits   PI = 3.141592653589793 227020265 ..... ,    *  *	Hexadecimal:  *		pi = 3.243F6A8885A308D313198A2E....  *    53 bits   PI = 3.243F6A8885A30  =  2 * 1.921FB54442D18  *    56 bits   PI = 3.243F6A8885A308 =  4 * .C90FDAA22168C2      *  *  * Method:  *	1. Let z=x*x. Create a polynomial approximation to   *	    cos(k*x)-1+z/2  =  z*z*(C0 + C1*z^1 + ... + C5*z^5)  *	then  *      cos__C(z) =  z*z*(C0 + C1*z^1 + ... + C5*z^5)  *  *	The coefficient C's are obtained by a special Remez algorithm.  *  * Accuracy:  *	In the absence of rounding error, the approximation has absolute error   *	less that 2**(-64) for VAX D FORMAT, 2**(-58.3) for IEEE DOUBLE.   *	  *  * Constants:  * The hexadecimal values are the intended ones for the following constants.  * The decimal values may be used, provided that the compiler will convert  * from decimal to binary accurately enough to produce the hexadecimal values  * shown.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VAX
end_ifdef

begin_comment
comment|/*C0     =  4.1666666666666504759E-2    , Hex  2^ -4   *  .AAAAAAAAAAA9F0 */
end_comment

begin_comment
comment|/*C1     = -1.3888888888865302059E-3    , Hex  2^ -9   * -.B60B60B60A0CCA */
end_comment

begin_comment
comment|/*C2     =  2.4801587285601038265E-5    , Hex  2^-15   *  .D00D00CDCD098F */
end_comment

begin_comment
comment|/*C3     = -2.7557313470902390219E-7    , Hex  2^-21   * -.93F27BB593E805 */
end_comment

begin_comment
comment|/*C4     =  2.0875623401082232009E-9    , Hex  2^-28   *  .8F74C8FA1E3FF0 */
end_comment

begin_comment
comment|/*C5     = -1.1355178117642986178E-11   ; Hex  2^-36   * -.C7C32D0A5C5A63 */
end_comment

begin_decl_stmt
specifier|static
name|long
name|C0x
index|[]
init|=
block|{
literal|0xaaaa3e2a
block|,
literal|0xa9f0aaaa
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C0
value|(*(double*)C0x)
end_define

begin_decl_stmt
specifier|static
name|long
name|C1x
index|[]
init|=
block|{
literal|0x0b60bbb6
block|,
literal|0x0ccab60a
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C1
value|(*(double*)C1x)
end_define

begin_decl_stmt
specifier|static
name|long
name|C2x
index|[]
init|=
block|{
literal|0x0d0038d0
block|,
literal|0x098fcdcd
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C2
value|(*(double*)C2x)
end_define

begin_decl_stmt
specifier|static
name|long
name|C3x
index|[]
init|=
block|{
literal|0xf27bb593
block|,
literal|0xe805b593
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C3
value|(*(double*)C3x)
end_define

begin_decl_stmt
specifier|static
name|long
name|C4x
index|[]
init|=
block|{
literal|0x74c8320f
block|,
literal|0x3ff0fa1e
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C4
value|(*(double*)C4x)
end_define

begin_decl_stmt
specifier|static
name|long
name|C5x
index|[]
init|=
block|{
literal|0xc32dae47
block|,
literal|0x5a630a5c
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C5
value|(*(double*)C5x)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IEEE double  */
end_comment

begin_decl_stmt
specifier|static
name|double
name|C0
init|=
literal|4.1666666666666504759E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -5   *  1.555555555553E */
name|C1
init|=
operator|-
literal|1.3888888888865301516E
operator|-
literal|3
decl_stmt|,
comment|/*Hex  2^-10   * -1.6C16C16C14199 */
name|C2
init|=
literal|2.4801587269650015769E
operator|-
literal|5
decl_stmt|,
comment|/*Hex  2^-16   *  1.A01A01971CAEB */
name|C3
init|=
operator|-
literal|2.7557304623183959811E
operator|-
literal|7
decl_stmt|,
comment|/*Hex  2^-22   * -1.27E4F1314AD1A */
name|C4
init|=
literal|2.0873958177697780076E
operator|-
literal|9
decl_stmt|,
comment|/*Hex  2^-29   *  1.1EE3B60DDDC8C */
name|C5
init|=
operator|-
literal|1.1250289076471311557E
operator|-
literal|11
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Hex  2^-37   * -1.8BD5986B2A52E */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|double
name|cos__C
parameter_list|(
name|z
parameter_list|)
name|double
name|z
decl_stmt|;
block|{
return|return
operator|(
name|z
operator|*
name|z
operator|*
operator|(
name|C0
operator|+
name|z
operator|*
operator|(
name|C1
operator|+
name|z
operator|*
operator|(
name|C2
operator|+
name|z
operator|*
operator|(
name|C3
operator|+
name|z
operator|*
operator|(
name|C4
operator|+
name|z
operator|*
name|C5
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

end_unit

