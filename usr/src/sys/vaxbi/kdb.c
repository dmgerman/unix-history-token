begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek.  *  * Redistribution is only permitted until one year after the first shipment  * of 4.4BSD by the Regents.  Otherwise, redistribution and use in source and  * binary forms are permitted provided that: (1) source distributions retain  * this entire copyright notice and comment, and (2) distributions including  * binaries display the following acknowledgement:  This product includes  * software developed by the University of California, Berkeley and its  * contributors'' in the documentation or other materials provided with the  * distribution and in all advertising materials mentioning features or use  * of this software.  Neither the name of the University nor the names of  * its contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)kdb.c	7.9 (Berkeley) 6/28/90  */
end_comment

begin_comment
comment|/*  * KDB50/MSCP device driver  */
end_comment

begin_comment
comment|/*  * TODO  *	rethink BI software interface  *	write bad block forwarding code  */
end_comment

begin_include
include|#
directive|include
file|"kra.h"
end_include

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|DRIVENAMES
value|"kra"
end_define

begin_comment
comment|/* XXX */
end_comment

begin_if
if|#
directive|if
name|NKDB
operator|>
literal|0
end_if

begin_comment
comment|/*  * CONFIGURATION OPTIONS.  The next three defines are tunable -- tune away!  *  * NRSPL2 and NCMDL2 control the number of response and command  * packets respectively.  They may be any value from 0 to 7, though  * setting them higher than 5 is unlikely to be of any value.  * If you get warnings about your command ring being too small,  * try increasing the values by one.  *  * MAXUNIT controls the maximum slave number (and hence number of drives  * per controller) we are prepared to handle.  */
end_comment

begin_define
define|#
directive|define
name|NRSPL2
value|5
end_define

begin_comment
comment|/* log2 number of response packets */
end_comment

begin_define
define|#
directive|define
name|NCMDL2
value|5
end_define

begin_comment
comment|/* log2 number of command packets */
end_comment

begin_define
define|#
directive|define
name|MAXUNIT
value|8
end_define

begin_comment
comment|/* maximum allowed unit number */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"dkstat.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_define
define|#
directive|define
name|NRSP
value|(1<< NRSPL2)
end_define

begin_define
define|#
directive|define
name|NCMD
value|(1<< NCMDL2)
end_define

begin_include
include|#
directive|include
file|"../vax/pte.h"
end_include

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mscp.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mscpvar.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"bireg.h"
end_include

begin_include
include|#
directive|include
file|"kdbreg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_comment
comment|/*  * Conversions from kernel virtual to physical and page table addresses.  * PHYS works only for kernel text and primary (compile time) data addresses.  */
end_comment

begin_define
define|#
directive|define
name|PHYS
parameter_list|(
name|cast
parameter_list|,
name|addr
parameter_list|)
define|\
value|((cast) ((int)(addr)& 0x7fffffff))
end_define

begin_comment
comment|/*  * KDB variables, per controller.  */
end_comment

begin_struct
struct|struct
name|kdbinfo
block|{
comment|/* software info, per KDB */
name|struct
name|kdb_regs
modifier|*
name|ki_kdb
decl_stmt|;
comment|/* KDB registers */
name|struct
name|kdb_regs
modifier|*
name|ki_physkdb
decl_stmt|;
comment|/* phys address of KDB registers */
name|short
name|ki_state
decl_stmt|;
comment|/* KDB50 state; see below */
name|short
name|ki_flags
decl_stmt|;
comment|/* flags; see below */
name|int
name|ki_micro
decl_stmt|;
comment|/* microcode revision */
name|short
name|ki_vec
decl_stmt|;
comment|/* scb vector offset */
name|short
name|ki_wticks
decl_stmt|;
comment|/* watchdog timer ticks */
comment|/* 	 * KDB PTEs must be contiguous.  Some I/O is done on addresses 	 * for which this is true (PTEs in Sysmap and Usrptmap), but 	 * other transfers may have PTEs that are scattered in physical 	 * space.  Ki_map maps a physically contiguous PTE space used 	 * for these transfers. 	 */
define|#
directive|define
name|KI_MAPSIZ
value|(NCMD + 2)
name|struct
name|map
modifier|*
name|ki_map
decl_stmt|;
comment|/* resource map */
define|#
directive|define
name|KI_PTES
value|256
name|struct
name|pte
name|ki_pte
index|[
name|KI_PTES
index|]
decl_stmt|;
comment|/* contiguous PTE space */
name|long
name|ki_ptephys
decl_stmt|;
comment|/* phys address of&ki_pte[0] */
name|struct
name|mscp_info
name|ki_mi
decl_stmt|;
comment|/* MSCP info (per mscpvar.h) */
name|struct
name|buf
name|ki_tab
decl_stmt|;
comment|/* controller queue */
comment|/* stuff read and written by hardware */
name|struct
name|kdbca
name|ki_ca
decl_stmt|;
comment|/* communications area */
name|struct
name|mscp
name|ki_rsp
index|[
name|NRSP
index|]
decl_stmt|;
comment|/* response packets */
name|struct
name|mscp
name|ki_cmd
index|[
name|NCMD
index|]
decl_stmt|;
comment|/* command packets */
block|}
name|kdbinfo
index|[
name|NKDB
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|ki_ctlr
value|ki_mi.mi_ctlr
end_define

begin_comment
comment|/*  * Controller states  */
end_comment

begin_define
define|#
directive|define
name|ST_IDLE
value|0
end_define

begin_comment
comment|/* uninitialised */
end_comment

begin_define
define|#
directive|define
name|ST_STEP1
value|1
end_define

begin_comment
comment|/* in `STEP 1' */
end_comment

begin_define
define|#
directive|define
name|ST_STEP2
value|2
end_define

begin_comment
comment|/* in `STEP 2' */
end_comment

begin_define
define|#
directive|define
name|ST_STEP3
value|3
end_define

begin_comment
comment|/* in `STEP 3' */
end_comment

begin_define
define|#
directive|define
name|ST_SETCHAR
value|4
end_define

begin_comment
comment|/* in `Set Controller Characteristics' */
end_comment

begin_define
define|#
directive|define
name|ST_RUN
value|5
end_define

begin_comment
comment|/* up and running */
end_comment

begin_comment
comment|/*  * Flags  */
end_comment

begin_define
define|#
directive|define
name|KDB_ALIVE
value|0x01
end_define

begin_comment
comment|/* this KDB50 exists */
end_comment

begin_define
define|#
directive|define
name|KDB_GRIPED
value|0x04
end_define

begin_comment
comment|/* griped about cmd ring too small */
end_comment

begin_define
define|#
directive|define
name|KDB_INSLAVE
value|0x08
end_define

begin_comment
comment|/* inside kdbslave() */
end_comment

begin_define
define|#
directive|define
name|KDB_DOWAKE
value|0x10
end_define

begin_comment
comment|/* wakeup when ctlr init done */
end_comment

begin_decl_stmt
name|struct
name|kdbstats
name|kdbstats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* statistics */
end_comment

begin_comment
comment|/*  * Device to unit number and partition:  */
end_comment

begin_define
define|#
directive|define
name|UNITSHIFT
value|3
end_define

begin_define
define|#
directive|define
name|UNITMASK
value|7
end_define

begin_define
define|#
directive|define
name|kdbunit
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>> UNITSHIFT)
end_define

begin_define
define|#
directive|define
name|kdbpart
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& UNITMASK)
end_define

begin_comment
comment|/* THIS SHOULD BE READ OFF THE PACK, PER DRIVE */
end_comment

begin_comment
comment|/* THESE SHOULD BE SHARED WITH uda.c (but not yet) */
end_comment

begin_struct
struct|struct
name|size
block|{
name|daddr_t
name|nblocks
decl_stmt|;
name|daddr_t
name|blkoff
decl_stmt|;
block|}
name|kra81_sizes
index|[
literal|8
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|MARYLAND
literal|67832
block|,
literal|0
block|,
comment|/* A=cyl    0 thru   94 + 2 sectors */
literal|67828
block|,
literal|67832
block|,
comment|/* B=cyl   95 thru  189 - 2 sectors */
operator|-
literal|1
block|,
literal|0
block|,
comment|/* C=cyl    0 thru 1247 */
operator|-
literal|1
block|,
literal|135660
block|,
comment|/* D=cyl  190 thru 1247 */
literal|449466
block|,
literal|49324
block|,
comment|/* E xxx */
literal|64260
block|,
literal|498790
block|,
comment|/* F xxx */
literal|328022
block|,
literal|563050
block|,
comment|/* G xxx */
literal|0
block|,
literal|0
block|,
else|#
directive|else
literal|15884
block|,
literal|0
block|,
comment|/* a */
literal|33440
block|,
literal|15884
block|,
comment|/* b */
operator|-
literal|1
block|,
literal|0
block|,
comment|/* c */
operator|-
literal|1
block|,
literal|49324
block|,
comment|/* d */
literal|449466
block|,
literal|49324
block|,
comment|/* e */
literal|64260
block|,
literal|498790
block|,
comment|/* f */
literal|328022
block|,
literal|563050
block|,
comment|/* g */
literal|0
block|,
literal|0
block|,
endif|#
directive|endif
block|}
struct|,
name|kra80_sizes
index|[
literal|8
index|]
init|=
block|{
literal|15884
block|,
literal|0
block|,
comment|/* A=blk 0 thru 15883 */
literal|33440
block|,
literal|15884
block|,
comment|/* B=blk 15884 thru 49323 */
operator|-
literal|1
block|,
literal|0
block|,
comment|/* C=blk 0 thru end */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|82080
block|,
literal|49324
block|,
comment|/* G=blk 49324 thru 131403 */
operator|-
literal|1
block|,
literal|131404
block|,
comment|/* H=blk 131404 thru end */
block|}
struct|,
name|kra60_sizes
index|[
literal|8
index|]
init|=
block|{
literal|15884
block|,
literal|0
block|,
comment|/* A=blk 0 thru 15883 */
literal|33440
block|,
literal|15884
block|,
comment|/* B=blk 15884 thru 49323 */
operator|-
literal|1
block|,
literal|0
block|,
comment|/* C=blk 0 thru end */
operator|-
literal|1
block|,
literal|49324
block|,
comment|/* D=blk 49324 thru end */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|82080
block|,
literal|49324
block|,
comment|/* G=blk 49324 thru 131403 */
operator|-
literal|1
block|,
literal|131404
block|,
comment|/* H=blk 131404 thru end */
block|}
struct|;
end_struct

begin_comment
comment|/* END OF STUFF WHICH SHOULD BE READ IN PER DISK */
end_comment

begin_comment
comment|/*  * Drive type index decoding table.  `ut_name' is null iff the  * type is not known.  */
end_comment

begin_struct
struct|struct
name|kdbtypes
block|{
name|char
modifier|*
name|ut_name
decl_stmt|;
comment|/* drive type name */
name|struct
name|size
modifier|*
name|ut_sizes
decl_stmt|;
comment|/* partition tables */
block|}
name|kdbtypes
index|[]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
literal|"ra80"
block|,
name|kra80_sizes
block|,
comment|/* 1 = ra80 */
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"ra60"
block|,
name|kra60_sizes
block|,
comment|/* 4 = ra60 */
literal|"ra81"
block|,
name|kra81_sizes
block|,
comment|/* 5 = ra81 */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NTYPES
value|6
end_define

begin_comment
comment|/*  * Definition of the driver for autoconf and generic MSCP code.  * SOME OF THIS IS BOGUS (must fix config)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/* not when driver is for kra disks */
end_comment

begin_comment
comment|/*  * Some of these variables (per-drive stuff) are shared  * with the UDA50 code (why not, they are the same drives).  * N.B.: kdbdinfo must not be shared.  */
end_comment

begin_define
define|#
directive|define
name|kdbutab
value|udautab
end_define

begin_comment
comment|/* shared */
end_comment

begin_define
define|#
directive|define
name|kdbslavereply
value|udaslavereply
end_define

begin_comment
comment|/* shared */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|kdbprobe
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|int
name|kdbslave
argument_list|()
decl_stmt|,
name|kdbattach
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kdbdgram
argument_list|()
decl_stmt|,
name|kdbctlrdone
argument_list|()
decl_stmt|,
name|kdbunconf
argument_list|()
decl_stmt|,
name|kdbiodone
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kdbonline
argument_list|()
decl_stmt|,
name|kdbgotstatus
argument_list|()
decl_stmt|,
name|kdbioerror
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|kdbdinfo
index|[
name|NKRA
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* uba_device indeed! */
end_comment

begin_decl_stmt
name|struct
name|buf
name|kdbutab
index|[
name|NKRA
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* per drive transfer queue */
end_comment

begin_decl_stmt
name|u_short
name|kdbstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|struct
name|uba_driver
name|kdbdriver
init|=
comment|/* XXX */
block|{
name|kdbprobe
block|,
name|kdbslave
block|,
name|kdbattach
block|,
literal|0
block|,
name|kdbstd
block|,
name|DRIVENAMES
block|,
name|kdbdinfo
block|,
literal|"kdb"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mscp_driver
name|kdbmscpdriver
init|=
block|{
name|MAXUNIT
block|,
name|NKRA
block|,
name|UNITSHIFT
block|,
name|kdbutab
block|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
literal|0
block|,
name|kdbdinfo
block|,
name|kdbdgram
block|,
name|kdbctlrdone
block|,
name|kdbunconf
block|,
name|kdbiodone
block|,
name|kdbonline
block|,
name|kdbgotstatus
block|,
name|NULL
block|,
name|kdbioerror
block|,
name|NULL
block|,
literal|"kdb"
block|,
name|DRIVENAMES
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Miscellaneous private variables.  */
end_comment

begin_decl_stmt
name|char
name|kdbsr_bits
index|[]
init|=
name|KDBSR_BITS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|kdbip
index|[
name|NKDB
index|]
index|[
name|MAXUNIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inverting pointers: ctlr& unit => `Unibus' 				   device pointer */
end_comment

begin_decl_stmt
name|daddr_t
name|ra_dsize
index|[
name|NKRA
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* drive sizes, from on line end packets */
end_comment

begin_decl_stmt
name|struct
name|mscp
name|kdbslavereply
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* get unit status response packet, set 				   for kdbslave by kdbunconf, via kdbintr */
end_comment

begin_decl_stmt
name|int
name|kdbwstart
decl_stmt|,
name|kdbwatch
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* watchdog timer */
end_comment

begin_function_decl
name|int
name|wakeup
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * If kdbprobe is called, return 0 to keep Unibus code from attempting  * to use this device.	XXX rethink  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|kdbprobe
argument_list|(
argument|reg
argument_list|,
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Configure in a KDB50 controller.  */
end_comment

begin_macro
name|kdbconfig
argument_list|(
argument|kdbnum
argument_list|,
argument|va
argument_list|,
argument|pa
argument_list|,
argument|vec
argument_list|)
end_macro

begin_decl_stmt
name|int
name|kdbnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|biiregs
modifier|*
name|va
decl_stmt|,
modifier|*
name|pa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vec
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|kdbinfo
modifier|*
name|ki
decl_stmt|;
define|#
directive|define
name|mi
value|(&ki->ki_mi)
ifdef|#
directive|ifdef
name|lint
specifier|extern
name|int
function_decl|(
modifier|*
name|kdbint0
index|[]
function_decl|)
parameter_list|()
function_decl|;
call|(
modifier|*
name|kdbint0
index|[
literal|0
index|]
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* this is a config botch */
name|kdbintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set up local KDB status. 	 */
name|ki
operator|=
operator|&
name|kdbinfo
index|[
name|kdbnum
index|]
expr_stmt|;
name|ki
operator|->
name|ki_kdb
operator|=
operator|(
expr|struct
name|kdb_regs
operator|*
operator|)
name|va
expr_stmt|;
name|ki
operator|->
name|ki_physkdb
operator|=
operator|(
expr|struct
name|kdb_regs
operator|*
operator|)
name|pa
expr_stmt|;
name|ki
operator|->
name|ki_vec
operator|=
name|vec
expr_stmt|;
name|ki
operator|->
name|ki_map
operator|=
operator|(
expr|struct
name|map
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|u_long
call|)
argument_list|(
name|KI_MAPSIZ
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|map
argument_list|)
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|ki_map
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"kdb%d: cannot get memory for ptes\n"
argument_list|,
name|kdbnum
argument_list|)
expr_stmt|;
return|return;
block|}
name|ki
operator|->
name|ki_ptephys
operator|=
name|PHYS
argument_list|(
name|long
argument_list|,
name|ki
operator|->
name|ki_pte
argument_list|)
expr_stmt|;
comment|/* kvtophys(ki->ki_pte) */
name|ki
operator|->
name|ki_flags
operator|=
name|KDB_ALIVE
expr_stmt|;
comment|/* THE FOLLOWING IS ONLY NEEDED TO CIRCUMVENT A BUG IN rminit */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ki
operator|->
name|ki_map
argument_list|,
name|KI_MAPSIZ
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|map
argument_list|)
argument_list|)
expr_stmt|;
name|rminit
argument_list|(
name|ki
operator|->
name|ki_map
argument_list|,
operator|(
name|long
operator|)
name|KI_PTES
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|"kdb"
argument_list|,
name|KI_MAPSIZ
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the generic MSCP structures. 	 */
name|mi
operator|->
name|mi_md
operator|=
operator|&
name|kdbmscpdriver
expr_stmt|;
name|mi
operator|->
name|mi_ctlr
operator|=
name|kdbnum
expr_stmt|;
comment|/* also sets ki->ki_ctlr */
name|mi
operator|->
name|mi_tab
operator|=
operator|&
name|ki
operator|->
name|ki_tab
expr_stmt|;
name|mi
operator|->
name|mi_ip
operator|=
name|kdbip
index|[
name|kdbnum
index|]
expr_stmt|;
name|mi
operator|->
name|mi_cmd
operator|.
name|mri_size
operator|=
name|NCMD
expr_stmt|;
name|mi
operator|->
name|mi_cmd
operator|.
name|mri_desc
operator|=
name|ki
operator|->
name|ki_ca
operator|.
name|ca_cmddsc
expr_stmt|;
name|mi
operator|->
name|mi_cmd
operator|.
name|mri_ring
operator|=
name|ki
operator|->
name|ki_cmd
expr_stmt|;
name|mi
operator|->
name|mi_rsp
operator|.
name|mri_size
operator|=
name|NRSP
expr_stmt|;
name|mi
operator|->
name|mi_rsp
operator|.
name|mri_desc
operator|=
name|ki
operator|->
name|ki_ca
operator|.
name|ca_rspdsc
expr_stmt|;
name|mi
operator|->
name|mi_rsp
operator|.
name|mri_ring
operator|=
name|ki
operator|->
name|ki_rsp
expr_stmt|;
name|mi
operator|->
name|mi_wtab
operator|.
name|av_forw
operator|=
name|mi
operator|->
name|mi_wtab
operator|.
name|av_back
operator|=
operator|&
name|mi
operator|->
name|mi_wtab
expr_stmt|;
undef|#
directive|undef
name|mi
block|}
end_block

begin_comment
comment|/*  * Find a slave.  * Note that by the time kdbslave is called, the interrupt vector  * for the KDB50 has been set up (so that kdbunconf() will be called).  */
end_comment

begin_expr_stmt
name|kdbslave
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|kdbinfo
modifier|*
name|ki
decl_stmt|;
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
name|int
name|next
init|=
literal|0
decl_stmt|,
name|type
decl_stmt|,
name|timeout
decl_stmt|,
name|tries
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|i
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Make sure the controller is fully initialised, by waiting 	 * for it if necessary. 	 */
name|ki
operator|=
operator|&
name|kdbinfo
index|[
name|ui
operator|->
name|ui_ctlr
index|]
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|ki_state
operator|==
name|ST_RUN
condition|)
goto|goto
name|findunit
goto|;
name|tries
operator|=
literal|0
expr_stmt|;
name|again
label|:
if|if
condition|(
name|kdbinit
argument_list|(
name|ki
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|timeout
operator|=
name|todr
argument_list|()
operator|+
literal|1000
expr_stmt|;
comment|/* 10 seconds */
while|while
condition|(
name|todr
argument_list|()
operator|<
name|timeout
condition|)
if|if
condition|(
name|ki
operator|->
name|ki_state
operator|==
name|ST_RUN
condition|)
comment|/* made it */
goto|goto
name|findunit
goto|;
if|if
condition|(
operator|++
name|tries
operator|<
literal|2
condition|)
goto|goto
name|again
goto|;
name|printf
argument_list|(
literal|"kdb%d: controller hung\n"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The controller is all set; go find the unit.  Grab an 	 * MSCP packet and send out a Get Unit Status command, with 	 * the `next unit' modifier if we are looking for a generic 	 * unit.  We set the `in slave' flag so that kdbunconf() 	 * knows to copy the response to `kdbslavereply'. 	 */
name|findunit
label|:
name|kdbslavereply
operator|.
name|mscp_opcode
operator|=
literal|0
expr_stmt|;
name|ki
operator|->
name|ki_flags
operator||=
name|KDB_INSLAVE
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|=
name|mscp_getcp
argument_list|(
operator|&
name|ki
operator|->
name|ki_mi
argument_list|,
name|MSCP_DONTWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"kdbslave"
argument_list|)
expr_stmt|;
comment|/* `cannot happen' */
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_GETUNITST
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|ui_slave
operator|==
literal|'?'
condition|)
block|{
name|mp
operator|->
name|mscp_unit
operator|=
name|next
expr_stmt|;
name|mp
operator|->
name|mscp_modifier
operator|=
name|M_GUM_NEXTUNIT
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|mp
operator|->
name|mscp_modifier
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|mp
operator|->
name|mscp_addr
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
name|i
operator|=
name|ki
operator|->
name|ki_kdb
operator|->
name|kdb_ip
expr_stmt|;
comment|/* initiate polling */
name|mp
operator|=
operator|&
name|kdbslavereply
expr_stmt|;
name|timeout
operator|=
name|todr
argument_list|()
operator|+
literal|1000
expr_stmt|;
while|while
condition|(
name|todr
argument_list|()
operator|<
name|timeout
condition|)
if|if
condition|(
name|mp
operator|->
name|mscp_opcode
condition|)
goto|goto
name|gotit
goto|;
name|printf
argument_list|(
literal|"kdb%d: no response to Get Unit Status request\n"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|)
expr_stmt|;
name|ki
operator|->
name|ki_flags
operator|&=
operator|~
name|KDB_INSLAVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|gotit
label|:
name|ki
operator|->
name|ki_flags
operator|&=
operator|~
name|KDB_INSLAVE
expr_stmt|;
comment|/* 	 * Got a slave response.  If the unit is there, use it. 	 */
switch|switch
condition|(
name|mp
operator|->
name|mscp_status
operator|&
name|M_ST_MASK
condition|)
block|{
case|case
name|M_ST_SUCCESS
case|:
comment|/* worked */
case|case
name|M_ST_AVAILABLE
case|:
comment|/* found another drive */
break|break;
comment|/* use it */
case|case
name|M_ST_OFFLINE
case|:
comment|/* 		 * Figure out why it is off line.  It may be because 		 * it is nonexistent, or because it is spun down, or 		 * for some other reason. 		 */
switch|switch
condition|(
name|mp
operator|->
name|mscp_status
operator|&
operator|~
name|M_ST_MASK
condition|)
block|{
case|case
name|M_OFFLINE_UNKNOWN
case|:
comment|/* 			 * No such drive, and there are none with 			 * higher unit numbers either, if we are 			 * using M_GUM_NEXTUNIT. 			 */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|M_OFFLINE_UNMOUNTED
case|:
comment|/* 			 * The drive is not spun up.  Use it anyway. 			 * 			 * N.B.: this seems to be a common occurrance 			 * after a power failure.  The first attempt 			 * to bring it on line seems to spin it up 			 * (and thus takes several minutes).  Perhaps 			 * we should note here that the on-line may 			 * take longer than usual. 			 */
break|break;
default|default:
comment|/* 			 * In service, or something else equally unusable. 			 */
name|printf
argument_list|(
literal|"kdb%d: unit %d off line:"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|)
expr_stmt|;
name|mscp_printevent
argument_list|(
name|mp
argument_list|)
expr_stmt|;
goto|goto
name|try_another
goto|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"kdb%d: unable to get unit status:"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|)
expr_stmt|;
name|mscp_printevent
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Does this ever happen?  What (if anything) does it mean? 	 */
if|if
condition|(
name|mp
operator|->
name|mscp_unit
operator|<
name|next
condition|)
block|{
name|printf
argument_list|(
literal|"kdb%d: unit %d, next %d\n"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|mp
operator|->
name|mscp_unit
operator|>=
name|MAXUNIT
condition|)
block|{
name|printf
argument_list|(
literal|"kdb%d: cannot handle unit number %d (max is %d)\n"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|MAXUNIT
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * See if we already handle this drive. 	 * (Only likely if ui->ui_slave=='?'.) 	 */
if|if
condition|(
name|kdbip
index|[
name|ki
operator|->
name|ki_ctlr
index|]
index|[
name|mp
operator|->
name|mscp_unit
index|]
operator|!=
name|NULL
condition|)
goto|goto
name|try_another
goto|;
comment|/* 	 * Make sure we know about this kind of drive. 	 * Others say we should treat unknowns as RA81s; I am 	 * not sure this is safe. 	 */
name|type
operator|=
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_drivetype
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|NTYPES
operator|||
name|kdbtypes
index|[
name|type
index|]
operator|.
name|ut_name
operator|==
literal|0
condition|)
block|{
specifier|register
name|long
name|id
init|=
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_mediaid
decl_stmt|;
name|printf
argument_list|(
literal|"kdb%d: unit %d: media ID `"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%c %c%c%c%d"
argument_list|,
name|MSCP_MID_CHAR
argument_list|(
literal|4
argument_list|,
name|id
argument_list|)
argument_list|,
name|MSCP_MID_CHAR
argument_list|(
literal|3
argument_list|,
name|id
argument_list|)
argument_list|,
name|MSCP_MID_CHAR
argument_list|(
literal|2
argument_list|,
name|id
argument_list|)
argument_list|,
name|MSCP_MID_CHAR
argument_list|(
literal|1
argument_list|,
name|id
argument_list|)
argument_list|,
name|MSCP_MID_CHAR
argument_list|(
literal|0
argument_list|,
name|id
argument_list|)
argument_list|,
name|MSCP_MID_NUM
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"' is of unknown type %d; ignored\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|try_another
label|:
if|if
condition|(
name|ui
operator|->
name|ui_slave
operator|!=
literal|'?'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|next
operator|=
name|mp
operator|->
name|mscp_unit
operator|+
literal|1
expr_stmt|;
goto|goto
name|findunit
goto|;
block|}
comment|/* 	 * Voila! 	 */
name|ui
operator|->
name|ui_type
operator|=
name|type
expr_stmt|;
name|ui
operator|->
name|ui_flags
operator|=
literal|0
expr_stmt|;
comment|/* not on line, nor anything else */
name|ui
operator|->
name|ui_slave
operator|=
name|mp
operator|->
name|mscp_unit
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Attach a found slave.  Make sure the watchdog timer is running.  * If this disk is being profiled, fill in the `wpms' value (used by  * what?).  Set up the inverting pointer, and attempt to bring the  * drive on line.  */
end_comment

begin_expr_stmt
name|kdbattach
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|kdbwstart
operator|==
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|kdbwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|kdbwstart
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ui
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
name|dk_wpms
index|[
name|ui
operator|->
name|ui_dk
index|]
operator|=
operator|(
literal|60
operator|*
literal|31
operator|*
literal|256
operator|)
expr_stmt|;
comment|/* approx */
name|kdbip
index|[
name|ui
operator|->
name|ui_ctlr
index|]
index|[
name|ui
operator|->
name|ui_slave
index|]
operator|=
name|ui
expr_stmt|;
operator|(
name|void
operator|)
name|kdb_bringonline
argument_list|(
name|ui
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* should we get its status too? */
block|}
end_block

begin_comment
comment|/*  * Initialise a KDB50.  Return true iff something goes wrong.  */
end_comment

begin_expr_stmt
name|kdbinit
argument_list|(
name|ki
argument_list|)
specifier|register
expr|struct
name|kdbinfo
operator|*
name|ki
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|kdb_regs
modifier|*
name|ka
init|=
name|ki
operator|->
name|ki_kdb
decl_stmt|;
name|int
name|timo
decl_stmt|;
comment|/* 	 * While we are thinking about it, reset the next command 	 * and response indicies. 	 */
name|ki
operator|->
name|ki_mi
operator|.
name|mi_cmd
operator|.
name|mri_next
operator|=
literal|0
expr_stmt|;
name|ki
operator|->
name|ki_mi
operator|.
name|mi_rsp
operator|.
name|mri_next
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Start up the hardware initialisation sequence. 	 */
define|#
directive|define
name|STEP0MASK
value|(KDB_ERR | KDB_STEP4 | KDB_STEP3 | KDB_STEP2 | KDB_STEP1)
name|ki
operator|->
name|ki_state
operator|=
name|ST_IDLE
expr_stmt|;
comment|/* in case init fails */
name|bi_reset
argument_list|(
operator|&
name|ka
operator|->
name|kdb_bi
argument_list|)
expr_stmt|;
comment|/* reset bi node (but not the BI itself) */
name|timo
operator|=
name|todr
argument_list|()
operator|+
literal|1000
expr_stmt|;
while|while
condition|(
operator|(
name|ka
operator|->
name|kdb_sa
operator|&
name|STEP0MASK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|todr
argument_list|()
operator|>
name|timo
condition|)
block|{
name|printf
argument_list|(
literal|"kdb%d: timeout during init\n"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|ka
operator|->
name|kdb_sa
operator|&
name|STEP0MASK
operator|)
operator|!=
name|KDB_STEP1
condition|)
block|{
name|printf
argument_list|(
literal|"kdb%d: init failed, sa=%b\n"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|,
name|ka
operator|->
name|kdb_sa
argument_list|,
name|kdbsr_bits
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Success!  Record new state, and start step 1 initialisation. 	 * The rest is done in the interrupt handler. 	 */
name|ki
operator|->
name|ki_state
operator|=
name|ST_STEP1
expr_stmt|;
name|ka
operator|->
name|kdb_bi
operator|.
name|bi_intrdes
operator|=
literal|1
operator|<<
name|mastercpu
expr_stmt|;
ifdef|#
directive|ifdef
name|unneeded
comment|/* is it? */
name|ka
operator|->
name|kdb_bi
operator|.
name|bi_csr
operator|=
operator|(
name|ka
operator|->
name|kdb_bi
operator|.
name|bi_csr
operator|&
operator|~
name|BICSR_ARB_MASK
operator|)
operator||
name|BICSR_ARB_
operator|???
expr_stmt|;
endif|#
directive|endif
name|ka
operator|->
name|kdb_bi
operator|.
name|bi_bcicsr
operator||=
name|BCI_STOPEN
operator||
name|BCI_IDENTEN
operator||
name|BCI_UINTEN
operator||
name|BCI_INTEN
expr_stmt|;
comment|/* I THINK THIS IS WRONG */
comment|/* Mach uses 0x601d0, which includes IPL16, but 1d0 is IPL17, nexzvec...? */
name|ka
operator|->
name|kdb_bi
operator|.
name|bi_eintrcsr
operator|=
name|BIEIC_IPL15
operator||
name|ki
operator|->
name|ki_vec
expr_stmt|;
comment|/* ??? */
comment|/* END I THINK WRONG */
name|ka
operator|->
name|kdb_bi
operator|.
name|bi_uintrcsr
operator|=
name|ki
operator|->
name|ki_vec
expr_stmt|;
name|ka
operator|->
name|kdb_sw
operator|=
name|KDB_ERR
operator||
operator|(
name|NCMDL2
operator|<<
literal|11
operator|)
operator||
operator|(
name|NRSPL2
operator|<<
literal|8
operator|)
operator||
name|KDB_IE
operator||
operator|(
name|ki
operator|->
name|ki_vec
operator|>>
literal|2
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Open a drive.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|kdbopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|kdbinfo
modifier|*
name|ki
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Make sure this is a reasonable open request. 	 */
name|unit
operator|=
name|kdbunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NKRA
operator|||
operator|(
name|ui
operator|=
name|kdbdinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Make sure the controller is running, by (re)initialising it if 	 * necessary. 	 */
name|ki
operator|=
operator|&
name|kdbinfo
index|[
name|ui
operator|->
name|ui_ctlr
index|]
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|ki_state
operator|!=
name|ST_RUN
condition|)
block|{
if|if
condition|(
name|ki
operator|->
name|ki_state
operator|==
name|ST_IDLE
operator|&&
name|kdbinit
argument_list|(
name|ki
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 		 * In case it does not come up, make sure we will be 		 * restarted in 10 seconds.  This corresponds to the 		 * 10 second timeouts in kdbprobe() and kdbslave(). 		 */
name|ki
operator|->
name|ki_flags
operator||=
name|KDB_DOWAKE
expr_stmt|;
name|timeout
argument_list|(
name|wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ki
operator|->
name|ki_flags
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ki
operator|->
name|ki_flags
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|ki_state
operator|!=
name|ST_RUN
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"kdb%d: controller hung\n"
argument_list|,
name|ui
operator|->
name|ui_ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|untimeout
argument_list|(
name|wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ki
operator|->
name|ki_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_ONLINE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Bring the drive on line so we can find out how 		 * big it is.  If it is not spun up, it will not 		 * come on line; this cannot really be considered 		 * an `error condition'. 		 */
if|if
condition|(
name|kdb_bringonline
argument_list|(
name|ui
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d: drive will not come on line\n"
argument_list|,
name|kdbdriver
operator|.
name|ud_dname
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Bring a drive on line.  In case it fails to respond, we set  * a timeout on it.  The `nosleep' parameter should be set if  * we are to spin-wait; otherwise this must be called at spl5().  */
end_comment

begin_expr_stmt
name|kdb_bringonline
argument_list|(
name|ui
argument_list|,
name|nosleep
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|nosleep
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|kdbinfo
modifier|*
name|ki
init|=
operator|&
name|kdbinfo
index|[
name|ui
operator|->
name|ui_ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nosleep
condition|)
block|{
name|mp
operator|=
name|mscp_getcp
argument_list|(
operator|&
name|ki
operator|->
name|ki_mi
argument_list|,
name|MSCP_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
name|mp
operator|=
name|mscp_getcp
argument_list|(
operator|&
name|ki
operator|->
name|ki_mi
argument_list|,
name|MSCP_WAIT
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_ONLINE
expr_stmt|;
name|mp
operator|->
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|mp
operator|->
name|mscp_cmdref
operator|=
operator|(
name|long
operator|)
operator|&
name|ui
operator|->
name|ui_flags
expr_stmt|;
operator|*
name|mp
operator|->
name|mscp_addr
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
name|i
operator|=
name|ki
operator|->
name|ki_kdb
operator|->
name|kdb_ip
expr_stmt|;
if|if
condition|(
name|nosleep
condition|)
block|{
name|i
operator|=
name|todr
argument_list|()
operator|+
literal|1000
expr_stmt|;
while|while
condition|(
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_ONLINE
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|todr
argument_list|()
operator|>
name|i
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|timeout
argument_list|(
name|wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ui
operator|->
name|ui_flags
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ui
operator|->
name|ui_flags
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_ONLINE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|untimeout
argument_list|(
name|wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ui
operator|->
name|ui_flags
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* made it */
block|}
end_block

begin_comment
comment|/*  * Queue a transfer request, and if possible, hand it to the controller.  *  * This routine is broken into two so that the internal version  * kdbstrat1() can be called by the (nonexistent, as yet) bad block  * revectoring routine.  */
end_comment

begin_expr_stmt
name|kdbstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|size
modifier|*
name|st
decl_stmt|;
name|daddr_t
name|sz
decl_stmt|,
name|maxsz
decl_stmt|;
comment|/* 	 * Make sure this is a reasonable drive to use. 	 */
if|if
condition|(
operator|(
name|unit
operator|=
name|kdbunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|)
operator|>=
name|NKRA
operator|||
operator|(
name|ui
operator|=
name|kdbdinfo
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Determine the size of the transfer, and make sure it is 	 * within the boundaries of the drive. 	 */
name|sz
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
literal|511
operator|)
operator|>>
literal|9
expr_stmt|;
name|st
operator|=
operator|&
name|kdbtypes
index|[
name|ui
operator|->
name|ui_type
index|]
operator|.
name|ut_sizes
index|[
name|kdbpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|maxsz
operator|=
name|st
operator|->
name|nblocks
operator|)
operator|<
literal|0
condition|)
name|maxsz
operator|=
name|ra_dsize
index|[
name|unit
index|]
operator|-
name|st
operator|->
name|blkoff
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|||
name|bp
operator|->
name|b_blkno
operator|+
name|sz
operator|>
name|maxsz
operator|||
name|st
operator|->
name|blkoff
operator|>=
name|ra_dsize
index|[
name|unit
index|]
condition|)
block|{
comment|/* if exactly at end of disk, return an EOF */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|maxsz
condition|)
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
else|else
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|kdbstrat1
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Work routine for kdbstrategy.  */
end_comment

begin_expr_stmt
name|kdbstrat1
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|kdbunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|kdbinfo
modifier|*
name|ki
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Append the buffer to the drive queue, and if it is not 	 * already there, the drive to the controller queue.  (However, 	 * if the drive queue is marked to be requeued, we must be 	 * awaiting an on line or get unit status command; in this 	 * case, leave it off the controller queue.) 	 */
name|ui
operator|=
name|kdbdinfo
index|[
name|unit
index|]
expr_stmt|;
name|ki
operator|=
operator|&
name|kdbinfo
index|[
name|ui
operator|->
name|ui_ctlr
index|]
expr_stmt|;
name|dp
operator|=
operator|&
name|kdbutab
index|[
name|unit
index|]
expr_stmt|;
name|s
operator|=
name|spl5
argument_list|()
expr_stmt|;
name|APPEND
argument_list|(
name|bp
argument_list|,
name|dp
argument_list|,
name|av_forw
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
operator|&&
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_REQUEUE
operator|)
operator|==
literal|0
condition|)
block|{
name|APPEND
argument_list|(
name|dp
argument_list|,
operator|&
name|ki
operator|->
name|ki_tab
argument_list|,
name|b_forw
argument_list|)
expr_stmt|;
name|dp
operator|->
name|b_active
operator|++
expr_stmt|;
block|}
comment|/* 	 * Start activity on the controller. 	 */
name|kdbstart
argument_list|(
name|ki
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Find the physical address of some contiguous PTEs that map the  * transfer described in `bp', creating them (by copying) if  * necessary.  Store the physical base address of the map through  * mapbase, and the page offset through offset, and any resource  * information in *info (or 0 if none).  *  * If we cannot allocate space, return a nonzero status.  */
end_comment

begin_function
name|int
name|kdbmap
parameter_list|(
name|ki
parameter_list|,
name|bp
parameter_list|,
name|mapbase
parameter_list|,
name|offset
parameter_list|,
name|info
parameter_list|)
name|struct
name|kdbinfo
modifier|*
name|ki
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|long
modifier|*
name|mapbase
decl_stmt|,
decl|*
name|offset
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|spte
decl_stmt|,
modifier|*
name|dpte
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|a
decl_stmt|,
name|o
decl_stmt|;
name|u_int
name|v
decl_stmt|;
name|int
name|npf
decl_stmt|;
name|o
operator|=
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|&
name|PGOFSET
expr_stmt|;
comment|/* handle contiguous cases */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|spte
operator|=
name|kvtopte
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
expr_stmt|;
name|kdbstats
operator|.
name|ks_sys
operator|++
expr_stmt|;
operator|*
name|mapbase
operator|=
name|PHYS
argument_list|(
name|long
argument_list|,
name|spte
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|o
expr_stmt|;
operator|*
name|info
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_PAGET
condition|)
block|{
name|spte
operator|=
operator|&
name|Usrptmap
index|[
name|btokmx
argument_list|(
operator|(
expr|struct
name|pte
operator|*
block|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
block|)
end_block

begin_empty_stmt
unit|]
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|spte
operator|->
name|pg_v
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"kdbmap"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|kdbstats
operator|.
name|ks_paget
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|mapbase
operator|=
name|PHYS
argument_list|(
name|long
argument_list|,
name|spte
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|offset
operator|=
name|o
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|info
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
unit|}
comment|/* potentially discontiguous or invalid ptes */
end_comment

begin_expr_stmt
unit|v
operator|=
name|btop
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rp
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_DIRTY
condition|?
operator|&
name|proc
index|[
literal|2
index|]
else|:
name|bp
operator|->
name|b_proc
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_UAREA
condition|)
name|spte
operator|=
operator|&
name|rp
operator|->
name|p_addr
index|[
name|v
index|]
expr_stmt|;
else|else
name|spte
operator|=
name|vtopte
argument_list|(
name|rp
argument_list|,
name|v
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|npf
operator|=
name|btoc
argument_list|(
name|bp
operator|->
name|b_bcount
operator|+
name|o
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/* 	 * The current implementation of the VM system requires 	 * that all of these be done with a copy.  Even if the 	 * PTEs could be used now, they may be snatched out from 	 * under us later.  It would be nice if we could stop that.... 	 */
end_comment

begin_comment
comment|/* check for invalid */
end_comment

begin_comment
comment|/* CONSIDER CHANGING VM TO VALIDATE PAGES EARLIER */
end_comment

begin_for
for|for
control|(
name|dpte
operator|=
name|spte
operator|,
name|i
operator|=
name|npf
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|dpte
operator|++
control|)
if|if
condition|(
name|dpte
operator|->
name|pg_v
operator|==
literal|0
condition|)
goto|goto
name|copy1
goto|;
end_for

begin_comment
comment|/* 	 * Check for discontiguous physical pte addresses.  It is 	 * not necessary to check each pte, since they come in clumps 	 * of pages. 	 */
end_comment

begin_expr_stmt
name|i
operator|=
name|howmany
argument_list|(
name|npf
operator|+
operator|(
operator|(
operator|(
name|int
operator|)
name|spte
operator|&
name|PGOFSET
operator|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|spte
argument_list|)
operator|)
argument_list|,
name|NPTEPG
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* often i==1, and we can avoid work */
end_comment

begin_if
if|if
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
block|{
name|dpte
operator|=
name|kvtopte
argument_list|(
name|spte
argument_list|)
expr_stmt|;
name|a
operator|=
name|dpte
operator|->
name|pg_pfnum
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
if|if
condition|(
operator|(
operator|++
name|dpte
operator|)
operator|->
name|pg_pfnum
operator|!=
operator|++
name|a
condition|)
goto|goto
name|copy2
goto|;
block|}
end_if

begin_comment
comment|/* made it */
end_comment

begin_expr_stmt
name|kdbstats
operator|.
name|ks_contig
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|mapbase
operator|=
name|kvtophys
argument_list|(
name|spte
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|offset
operator|=
name|o
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|info
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_label
name|copy1
label|:
end_label

begin_expr_stmt
name|kdbstats
operator|.
name|ks_inval
operator|++
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* temp */
end_comment

begin_label
name|copy2
label|:
end_label

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notdef */
end_comment

begin_expr_stmt
name|kdbstats
operator|.
name|ks_copies
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|i
operator|=
name|npf
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|a
operator|=
name|rmalloc
argument_list|(
name|ki
operator|->
name|ki_map
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|kdbstats
operator|.
name|ks_mapwait
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_if

begin_expr_stmt
operator|*
name|info
operator|=
operator|(
name|i
operator|<<
literal|16
operator|)
operator||
name|a
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|a
operator|--
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* if offset> PGOFSET, btop(offset) indexes mapbase */
end_comment

begin_expr_stmt
operator|*
name|mapbase
operator|=
name|ki
operator|->
name|ki_ptephys
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|offset
operator|=
operator|(
name|a
operator|<<
name|PGSHIFT
operator|)
operator||
name|o
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dpte
operator|=
operator|&
name|ki
operator|->
name|ki_pte
index|[
name|a
index|]
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|dpte
operator|++
operator|=
name|PG_V
operator||
operator|*
operator|(
name|int
operator|*
operator|)
name|spte
operator|++
expr_stmt|;
end_while

begin_expr_stmt
operator|*
operator|(
name|int
operator|*
operator|)
name|dpte
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_define
unit|}
define|#
directive|define
name|KDBFREE
parameter_list|(
name|ki
parameter_list|,
name|info
parameter_list|)
value|if (info) \ 	rmfree((ki)->ki_map, (long)((info)>> 16), (long)((info)& 0xffff))
end_define

begin_comment
comment|/*  * Start up whatever transfers we can find.  * Note that kdbstart() must be called at spl5().  */
end_comment

begin_expr_stmt
unit|kdbstart
operator|(
name|ki
operator|)
specifier|register
expr|struct
name|kdbinfo
operator|*
name|ki
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|long
name|mapbase
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|info
decl_stmt|,
name|ncmd
init|=
literal|0
decl_stmt|;
comment|/* 	 * If it is not running, try (again and again...) to initialise 	 * it.  If it is currently initialising just ignore it for now. 	 */
if|if
condition|(
name|ki
operator|->
name|ki_state
operator|!=
name|ST_RUN
condition|)
block|{
if|if
condition|(
name|ki
operator|->
name|ki_state
operator|==
name|ST_IDLE
operator|&&
name|kdbinit
argument_list|(
name|ki
argument_list|)
condition|)
name|printf
argument_list|(
literal|"kdb%d: still hung\n"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
name|loop
label|:
comment|/* if insufficient credit, avoid overhead */
if|if
condition|(
name|ki
operator|->
name|ki_mi
operator|.
name|mi_credits
operator|<=
name|MSCP_MINCREDITS
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Service the drive at the head of the queue.  It may not 	 * need anything; eventually this will finish up the close 	 * protocol, but that is yet to be implemented here. 	 */
if|if
condition|(
operator|(
name|dp
operator|=
name|ki
operator|->
name|ki_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|ki
operator|->
name|ki_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|ki
operator|->
name|ki_kdb
operator|->
name|kdb_sa
operator|&
name|KDB_ERR
condition|)
block|{
comment|/* ctlr fatal error */
name|kdbsaerror
argument_list|(
name|ki
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* find or create maps for this transfer */
if|if
condition|(
name|kdbmap
argument_list|(
name|ki
argument_list|,
name|bp
argument_list|,
operator|&
name|mapbase
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|info
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* effectively, resource wait */
comment|/* 	 * Get an MSCP packet, then figure out what to do.  If 	 * we cannot get a command packet, the command ring may 	 * be too small:  We should have at least as many command 	 * packets as credits, for best performance. 	 */
if|if
condition|(
operator|(
name|mp
operator|=
name|mscp_getcp
argument_list|(
operator|&
name|ki
operator|->
name|ki_mi
argument_list|,
name|MSCP_DONTWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ki
operator|->
name|ki_mi
operator|.
name|mi_credits
operator|>
name|MSCP_MINCREDITS
operator|&&
operator|(
name|ki
operator|->
name|ki_flags
operator|&
name|KDB_GRIPED
operator|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"kdb%d: command ring too small\n"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|)
expr_stmt|;
name|ki
operator|->
name|ki_flags
operator||=
name|KDB_GRIPED
expr_stmt|;
comment|/* complain only once */
block|}
name|KDBFREE
argument_list|(
name|ki
argument_list|,
name|info
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Bring the drive on line if it is not already.  Get its status 	 * if we do not already have it.  Otherwise just start the transfer. 	 */
name|ui
operator|=
name|kdbdinfo
index|[
name|kdbunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_ONLINE
operator|)
operator|==
literal|0
condition|)
block|{
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_ONLINE
expr_stmt|;
goto|goto
name|common
goto|;
block|}
if|if
condition|(
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_HAVESTATUS
operator|)
operator|==
literal|0
condition|)
block|{
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_GETUNITST
expr_stmt|;
name|common
label|:
if|if
condition|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_REQUEUE
condition|)
name|panic
argument_list|(
literal|"kdbstart"
argument_list|)
expr_stmt|;
comment|/* 		 * Take the drive off the controller queue.  When the 		 * command finishes, make sure the drive is requeued. 		 * Give up any mapping (not needed now).  This last is 		 * not efficient, but is rare. 		 */
name|KDBFREE
argument_list|(
name|ki
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|ki
operator|->
name|ki_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|ui_flags
operator||=
name|UNIT_REQUEUE
expr_stmt|;
name|mp
operator|->
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
operator|*
name|mp
operator|->
name|mscp_addr
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
name|ncmd
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|mp
operator|->
name|mscp_opcode
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|M_OP_READ
else|:
name|M_OP_WRITE
expr_stmt|;
name|mp
operator|->
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_lbn
operator|=
name|bp
operator|->
name|b_blkno
operator|+
name|kdbtypes
index|[
name|ui
operator|->
name|ui_type
index|]
operator|.
name|ut_sizes
index|[
name|kdbpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|blkoff
expr_stmt|;
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_bytecount
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_buffer
operator|=
name|offset
operator||
name|KDB_MAP
expr_stmt|;
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_mapbase
operator|=
name|mapbase
expr_stmt|;
comment|/* profile the drive */
if|if
condition|(
name|ui
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
block|{
name|dk_busy
operator||=
literal|1
operator|<<
name|ui
operator|->
name|ui_dk
expr_stmt|;
name|dk_xfer
index|[
name|ui
operator|->
name|ui_dk
index|]
operator|++
expr_stmt|;
name|dk_wds
index|[
name|ui
operator|->
name|ui_dk
index|]
operator|+=
name|bp
operator|->
name|b_bcount
operator|>>
literal|6
expr_stmt|;
block|}
comment|/* 	 * Fill in the rest of the MSCP packet and move the buffer to the 	 * I/O wait queue. 	 */
name|mscp_go
argument_list|(
operator|&
name|ki
operator|->
name|ki_mi
argument_list|,
name|mp
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|ncmd
operator|++
expr_stmt|;
comment|/* note the transfer */
name|ki
operator|->
name|ki_tab
operator|.
name|b_active
operator|++
expr_stmt|;
comment|/* another one going */
goto|goto
name|loop
goto|;
name|out
label|:
if|if
condition|(
name|ncmd
operator|>=
name|KS_MAXC
condition|)
name|ncmd
operator|=
name|KS_MAXC
operator|-
literal|1
expr_stmt|;
name|kdbstats
operator|.
name|ks_cmd
index|[
name|ncmd
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|ncmd
condition|)
comment|/* start some transfers */
name|ncmd
operator|=
name|ki
operator|->
name|ki_kdb
operator|->
name|kdb_ip
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|kdbiodone
argument_list|(
argument|mi
argument_list|,
argument|bp
argument_list|,
argument|info
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mscp_info
modifier|*
name|mi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|info
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|kdbinfo
modifier|*
name|ki
init|=
operator|&
name|kdbinfo
index|[
name|mi
operator|->
name|mi_ctlr
index|]
decl_stmt|;
name|KDBFREE
argument_list|(
name|ki
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ki
operator|->
name|ki_tab
operator|.
name|b_active
operator|--
expr_stmt|;
comment|/* another one done */
block|}
end_block

begin_comment
comment|/*  * The error bit was set in the controller status register.  Gripe,  * reset the controller, requeue pending transfers.  */
end_comment

begin_expr_stmt
name|kdbsaerror
argument_list|(
name|ki
argument_list|)
specifier|register
expr|struct
name|kdbinfo
operator|*
name|ki
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"kdb%d: controller error, sa=%b\n"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|,
name|ki
operator|->
name|ki_kdb
operator|->
name|kdb_sa
argument_list|,
name|kdbsr_bits
argument_list|)
expr_stmt|;
name|mscp_requeue
argument_list|(
operator|&
name|ki
operator|->
name|ki_mi
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kdbinit
argument_list|(
name|ki
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Interrupt routine.  Depending on the state of the controller,  * continue initialisation, or acknowledge command and response  * interrupts, and process responses.  */
end_comment

begin_macro
name|kdbintr
argument_list|(
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|kdbinfo
modifier|*
name|ki
init|=
operator|&
name|kdbinfo
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|kdb_regs
modifier|*
name|kdbaddr
init|=
name|ki
operator|->
name|ki_kdb
decl_stmt|;
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|ki
operator|->
name|ki_wticks
operator|=
literal|0
expr_stmt|;
comment|/* reset interrupt watchdog */
comment|/* 	 * Combinations during steps 1, 2, and 3: STEPnMASK 	 * corresponds to which bits should be tested; 	 * STEPnGOOD corresponds to the pattern that should 	 * appear after the interrupt from STEPn initialisation. 	 * All steps test the bits in ALLSTEPS. 	 */
define|#
directive|define
name|ALLSTEPS
value|(KDB_ERR|KDB_STEP4|KDB_STEP3|KDB_STEP2|KDB_STEP1)
define|#
directive|define
name|STEP1MASK
value|(ALLSTEPS | KDB_IE | KDB_NCNRMASK)
define|#
directive|define
name|STEP1GOOD
value|(KDB_STEP2 | KDB_IE | (NCMDL2<< 3) | NRSPL2)
define|#
directive|define
name|STEP2MASK
value|(ALLSTEPS | KDB_IE | KDB_IVECMASK)
define|#
directive|define
name|STEP2GOOD
value|(KDB_STEP3 | KDB_IE | (ki->ki_vec>> 2))
define|#
directive|define
name|STEP3MASK
value|ALLSTEPS
define|#
directive|define
name|STEP3GOOD
value|KDB_STEP4
switch|switch
condition|(
name|ki
operator|->
name|ki_state
condition|)
block|{
case|case
name|ST_IDLE
case|:
comment|/* 		 * Ignore unsolicited interrupts. 		 */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"kdb%d: stray intr\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return;
case|case
name|ST_STEP1
case|:
comment|/* 		 * Begin step two initialisation. 		 */
if|if
condition|(
operator|(
name|kdbaddr
operator|->
name|kdb_sa
operator|&
name|STEP1MASK
operator|)
operator|!=
name|STEP1GOOD
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
name|initfailed
label|:
name|printf
argument_list|(
literal|"kdb%d: init step %d failed, sa=%b\n"
argument_list|,
name|ctlr
argument_list|,
name|i
argument_list|,
name|kdbaddr
operator|->
name|kdb_sa
argument_list|,
name|kdbsr_bits
argument_list|)
expr_stmt|;
name|ki
operator|->
name|ki_state
operator|=
name|ST_IDLE
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|ki_flags
operator|&
name|KDB_DOWAKE
condition|)
block|{
name|ki
operator|->
name|ki_flags
operator|&=
operator|~
name|KDB_DOWAKE
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ki
operator|->
name|ki_flags
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|kdbaddr
operator|->
name|kdb_sw
operator|=
name|PHYS
argument_list|(
name|int
argument_list|,
operator|&
name|ki
operator|->
name|ki_ca
operator|.
name|ca_rspdsc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ki
operator|->
name|ki_state
operator|=
name|ST_STEP2
expr_stmt|;
return|return;
case|case
name|ST_STEP2
case|:
comment|/* 		 * Begin step 3 initialisation. 		 */
if|if
condition|(
operator|(
name|kdbaddr
operator|->
name|kdb_sa
operator|&
name|STEP2MASK
operator|)
operator|!=
name|STEP2GOOD
condition|)
block|{
name|i
operator|=
literal|2
expr_stmt|;
goto|goto
name|initfailed
goto|;
block|}
name|kdbaddr
operator|->
name|kdb_sw
operator|=
name|PHYS
argument_list|(
name|int
argument_list|,
operator|&
name|ki
operator|->
name|ki_ca
operator|.
name|ca_rspdsc
index|[
literal|0
index|]
argument_list|)
operator|>>
literal|16
expr_stmt|;
name|ki
operator|->
name|ki_state
operator|=
name|ST_STEP3
expr_stmt|;
return|return;
case|case
name|ST_STEP3
case|:
comment|/* 		 * Set controller characteristics (finish initialisation). 		 */
if|if
condition|(
operator|(
name|kdbaddr
operator|->
name|kdb_sa
operator|&
name|STEP3MASK
operator|)
operator|!=
name|STEP3GOOD
condition|)
block|{
name|i
operator|=
literal|3
expr_stmt|;
goto|goto
name|initfailed
goto|;
block|}
name|i
operator|=
name|kdbaddr
operator|->
name|kdb_sa
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ki
operator|->
name|ki_micro
condition|)
block|{
name|ki
operator|->
name|ki_micro
operator|=
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"kdb%d: version %d model %d\n"
argument_list|,
name|ctlr
argument_list|,
name|i
operator|&
literal|0xf
argument_list|,
name|i
operator|>>
literal|4
argument_list|)
expr_stmt|;
block|}
name|kdbaddr
operator|->
name|kdb_sw
operator|=
name|KDB_GO
expr_stmt|;
comment|/* initialise hardware data structures */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mp
operator|=
name|ki
operator|->
name|ki_rsp
init|;
name|i
operator|<
name|NRSP
condition|;
name|i
operator|++
operator|,
name|mp
operator|++
control|)
block|{
name|ki
operator|->
name|ki_ca
operator|.
name|ca_rspdsc
index|[
name|i
index|]
operator|=
name|MSCP_OWN
operator||
name|MSCP_INT
operator||
name|PHYS
argument_list|(
name|long
argument_list|,
operator|&
name|ki
operator|->
name|ki_rsp
index|[
name|i
index|]
operator|.
name|mscp_cmdref
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mscp_addr
operator|=
operator|&
name|ki
operator|->
name|ki_ca
operator|.
name|ca_rspdsc
index|[
name|i
index|]
expr_stmt|;
name|mp
operator|->
name|mscp_msglen
operator|=
name|MSCP_MSGLEN
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mp
operator|=
name|ki
operator|->
name|ki_cmd
init|;
name|i
operator|<
name|NCMD
condition|;
name|i
operator|++
operator|,
name|mp
operator|++
control|)
block|{
name|ki
operator|->
name|ki_ca
operator|.
name|ca_cmddsc
index|[
name|i
index|]
operator|=
name|MSCP_INT
operator||
name|PHYS
argument_list|(
name|long
argument_list|,
operator|&
name|ki
operator|->
name|ki_cmd
index|[
name|i
index|]
operator|.
name|mscp_cmdref
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mscp_addr
operator|=
operator|&
name|ki
operator|->
name|ki_ca
operator|.
name|ca_cmddsc
index|[
name|i
index|]
expr_stmt|;
name|mp
operator|->
name|mscp_msglen
operator|=
name|MSCP_MSGLEN
expr_stmt|;
block|}
comment|/* 		 * Before we can get a command packet, we need some 		 * credits.  Fake some up to keep mscp_getcp() happy, 		 * get a packet, and cancel all credits (the right 		 * number should come back in the response to the 		 * SCC packet). 		 */
name|ki
operator|->
name|ki_mi
operator|.
name|mi_credits
operator|=
name|MSCP_MINCREDITS
operator|+
literal|1
expr_stmt|;
name|mp
operator|=
name|mscp_getcp
argument_list|(
operator|&
name|ki
operator|->
name|ki_mi
argument_list|,
name|MSCP_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
comment|/* `cannot happen' */
name|panic
argument_list|(
literal|"kdbintr"
argument_list|)
expr_stmt|;
name|ki
operator|->
name|ki_mi
operator|.
name|mi_credits
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_opcode
operator|=
name|M_OP_SETCTLRC
expr_stmt|;
name|mp
operator|->
name|mscp_unit
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mscp_sccc
operator|.
name|sccc_ctlrflags
operator|=
name|M_CF_ATTN
operator||
name|M_CF_MISC
operator||
name|M_CF_THIS
expr_stmt|;
operator|*
name|mp
operator|->
name|mscp_addr
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
name|i
operator|=
name|kdbaddr
operator|->
name|kdb_ip
expr_stmt|;
name|ki
operator|->
name|ki_state
operator|=
name|ST_SETCHAR
expr_stmt|;
return|return;
case|case
name|ST_SETCHAR
case|:
case|case
name|ST_RUN
case|:
comment|/* 		 * Handle Set Ctlr Characteristics responses and operational 		 * responses (via mscp_dorsp). 		 */
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"kdb%d: driver bug, state %d\n"
argument_list|,
name|ctlr
argument_list|,
name|ki
operator|->
name|ki_state
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|kdbaddr
operator|->
name|kdb_sa
operator|&
name|KDB_ERR
condition|)
block|{
comment|/* ctlr fatal error */
name|kdbsaerror
argument_list|(
name|ki
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Handle buffer purge requests. 	 * KDB DOES NOT HAVE BDPs 	 */
if|if
condition|(
name|ki
operator|->
name|ki_ca
operator|.
name|ca_bdp
condition|)
block|{
name|printf
argument_list|(
literal|"kdb%d: purge bdp %d\n"
argument_list|,
name|ctlr
argument_list|,
name|ki
operator|->
name|ki_ca
operator|.
name|ca_bdp
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"kdb purge"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for response and command ring transitions. 	 */
if|if
condition|(
name|ki
operator|->
name|ki_ca
operator|.
name|ca_rspint
condition|)
block|{
name|ki
operator|->
name|ki_ca
operator|.
name|ca_rspint
operator|=
literal|0
expr_stmt|;
name|mscp_dorsp
argument_list|(
operator|&
name|ki
operator|->
name|ki_mi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ki
operator|->
name|ki_ca
operator|.
name|ca_cmdint
condition|)
block|{
name|ki
operator|->
name|ki_ca
operator|.
name|ca_cmdint
operator|=
literal|0
expr_stmt|;
name|MSCP_DOCMD
argument_list|(
operator|&
name|ki
operator|->
name|ki_mi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ki
operator|->
name|ki_tab
operator|.
name|b_actf
operator|!=
name|NULL
condition|)
name|kdbstart
argument_list|(
name|ki
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Handle an error datagram.  All we do now is decode it.  */
end_comment

begin_macro
name|kdbdgram
argument_list|(
argument|mi
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mscp_info
modifier|*
name|mi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mscp_decodeerror
argument_list|(
name|mi
operator|->
name|mi_md
operator|->
name|md_mname
argument_list|,
name|mi
operator|->
name|mi_ctlr
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The Set Controller Characteristics command finished.  * Record the new state of the controller.  */
end_comment

begin_macro
name|kdbctlrdone
argument_list|(
argument|mi
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mscp_info
modifier|*
name|mi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|kdbinfo
modifier|*
name|ki
init|=
operator|&
name|kdbinfo
index|[
name|mi
operator|->
name|mi_ctlr
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|mscp_status
operator|&
name|M_ST_MASK
operator|)
operator|==
name|M_ST_SUCCESS
condition|)
name|ki
operator|->
name|ki_state
operator|=
name|ST_RUN
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"kdb%d: SETCTLRC failed, status 0x%x\n"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|,
name|mp
operator|->
name|mscp_status
argument_list|)
expr_stmt|;
name|ki
operator|->
name|ki_state
operator|=
name|ST_IDLE
expr_stmt|;
block|}
if|if
condition|(
name|ki
operator|->
name|ki_flags
operator|&
name|KDB_DOWAKE
condition|)
block|{
name|ki
operator|->
name|ki_flags
operator|&=
operator|~
name|KDB_DOWAKE
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ki
operator|->
name|ki_flags
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Received a response from an as-yet unconfigured drive.  Configure it  * in, if possible.  */
end_comment

begin_macro
name|kdbunconf
argument_list|(
argument|mi
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mscp_info
modifier|*
name|mi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * If it is a slave response, copy it to kdbslavereply for 	 * kdbslave() to look at. 	 */
if|if
condition|(
name|mp
operator|->
name|mscp_opcode
operator|==
operator|(
name|M_OP_GETUNITST
operator||
name|M_OP_END
operator|)
operator|&&
operator|(
name|kdbinfo
index|[
name|mi
operator|->
name|mi_ctlr
index|]
operator|.
name|ki_flags
operator|&
name|KDB_INSLAVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|kdbslavereply
operator|=
operator|*
name|mp
expr_stmt|;
return|return
operator|(
name|MSCP_DONE
operator|)
return|;
block|}
comment|/* 	 * Otherwise, it had better be an available attention response. 	 */
if|if
condition|(
name|mp
operator|->
name|mscp_opcode
operator|!=
name|M_OP_AVAILATTN
condition|)
return|return
operator|(
name|MSCP_FAILED
operator|)
return|;
comment|/* do what autoconf does */
return|return
operator|(
name|MSCP_FAILED
operator|)
return|;
comment|/* not yet */
block|}
end_block

begin_comment
comment|/*  * A drive came on line.  Check its type and size.  Return DONE if  * we think the drive is truly on line.  In any case, awaken anyone  * sleeping on the drive on-line-ness.  */
end_comment

begin_expr_stmt
name|kdbonline
argument_list|(
name|ui
argument_list|,
name|mp
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|type
decl_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ui
operator|->
name|ui_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|mscp_status
operator|&
name|M_ST_MASK
operator|)
operator|!=
name|M_ST_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"kdb%d: attempt to bring %s%d on line failed:"
argument_list|,
name|ui
operator|->
name|ui_ctlr
argument_list|,
name|kdbdriver
operator|.
name|ud_dname
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
name|mscp_printevent
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|MSCP_FAILED
operator|)
return|;
block|}
name|type
operator|=
name|mp
operator|->
name|mscp_onle
operator|.
name|onle_drivetype
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|NTYPES
operator|||
name|kdbtypes
index|[
name|type
index|]
operator|.
name|ut_name
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"kdb%d: %s%d: unknown type %d\n"
argument_list|,
name|ui
operator|->
name|ui_ctlr
argument_list|,
name|kdbdriver
operator|.
name|ud_dname
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|MSCP_FAILED
operator|)
return|;
block|}
comment|/* 	 * Note any change of types.  Not sure if we should do 	 * something special about them, or if so, what.... 	 */
if|if
condition|(
name|type
operator|!=
name|ui
operator|->
name|ui_type
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: changed types! was %s\n"
argument_list|,
name|kdbdriver
operator|.
name|ud_dname
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|kdbtypes
index|[
name|ui
operator|->
name|ui_type
index|]
operator|.
name|ut_name
argument_list|)
expr_stmt|;
name|ui
operator|->
name|ui_type
operator|=
name|type
expr_stmt|;
block|}
name|ra_dsize
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|=
operator|(
name|daddr_t
operator|)
name|mp
operator|->
name|mscp_onle
operator|.
name|onle_unitsize
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d: %s, size = %d sectors\n"
argument_list|,
name|kdbdriver
operator|.
name|ud_dname
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|kdbtypes
index|[
name|type
index|]
operator|.
name|ut_name
argument_list|,
name|ra_dsize
index|[
name|ui
operator|->
name|ui_unit
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|MSCP_DONE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * We got some (configured) unit's status.  Return DONE if it succeeded.  */
end_comment

begin_expr_stmt
name|kdbgotstatus
argument_list|(
name|ui
argument_list|,
name|mp
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|mp
operator|->
name|mscp_status
operator|&
name|M_ST_MASK
operator|)
operator|!=
name|M_ST_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"kdb%d: attempt to get status for %s%d failed:"
argument_list|,
name|ui
operator|->
name|ui_ctlr
argument_list|,
name|kdbdriver
operator|.
name|ud_dname
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
name|mscp_printevent
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|MSCP_FAILED
operator|)
return|;
block|}
comment|/* need to record later for bad block forwarding - for now, print */
name|printf
argument_list|(
literal|"\ %s%d: unit %d, nspt %d, group %d, ngpc %d, rctsize %d, nrpt %d, nrct %d\n"
argument_list|,
name|kdbdriver
operator|.
name|ud_dname
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|mp
operator|->
name|mscp_unit
argument_list|,
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_nspt
argument_list|,
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_group
argument_list|,
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_ngpc
argument_list|,
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_rctsize
argument_list|,
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_nrpt
argument_list|,
name|mp
operator|->
name|mscp_guse
operator|.
name|guse_nrct
argument_list|)
expr_stmt|;
return|return
operator|(
name|MSCP_DONE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * A transfer failed.  We get a chance to fix or restart it.  * Need to write the bad block forwaring code first....  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|kdbioerror
argument_list|(
name|ui
argument_list|,
name|mp
argument_list|,
name|bp
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mscp
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|mp
operator|->
name|mscp_flags
operator|&
name|M_EF_BBLKR
condition|)
block|{
comment|/* 		 * A bad block report.  Eventually we will 		 * restart this transfer, but for now, just 		 * log it and give up. 		 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: bad block report: %d%s\n"
argument_list|,
name|kdbdriver
operator|.
name|ud_dname
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|mp
operator|->
name|mscp_seq
operator|.
name|seq_lbn
argument_list|,
name|mp
operator|->
name|mscp_flags
operator|&
name|M_EF_BBLKU
condition|?
literal|" + others"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * What the heck IS a `serious exception' anyway? 		 */
if|if
condition|(
name|mp
operator|->
name|mscp_flags
operator|&
name|M_EF_SEREX
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: serious exception reported\n"
argument_list|,
name|kdbdriver
operator|.
name|ud_dname
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|MSCP_FAILED
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*  * I/O controls.  Not yet!  */
end_comment

begin_macro
name|kdbioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|flag
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|,
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|kdbunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NKRA
operator|||
name|uddinfo
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|KDBIOCREPLACE
case|:
comment|/* 		 * Initiate bad block replacement for the given LBN. 		 * (Should we allow modifiers?) 		 */
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
case|case
name|KDBIOCGMICRO
case|:
comment|/* 		 * Return the microcode revision for the KDB50 running 		 * this drive. 		 */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|kdbinfo
index|[
name|kdbdinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
index|]
operator|.
name|ki_micro
expr_stmt|;
break|break;
case|case
name|KDBIOCGSIZE
case|:
comment|/* 		 * Return the size (in 512 byte blocks) of this 		 * disk drive. 		 */
operator|*
operator|(
name|daddr_t
operator|*
operator|)
name|data
operator|=
name|ra_dsize
index|[
name|unit
index|]
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*  * Reset a KDB50 (self test and all).  * What if it fails?  */
end_comment

begin_expr_stmt
name|kdbreset
argument_list|(
name|ki
argument_list|)
specifier|register
expr|struct
name|kdbinfo
operator|*
name|ki
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"reset kdb%d"
argument_list|,
name|ki
operator|->
name|ki_ctlr
argument_list|)
expr_stmt|;
name|bi_selftest
argument_list|(
operator|&
name|ki
operator|->
name|ki_kdb
operator|.
name|kdb_bi
argument_list|)
expr_stmt|;
name|ki
operator|->
name|ki_state
operator|=
name|ST_IDLE
expr_stmt|;
name|rminit
argument_list|(
name|ki
operator|->
name|ki_map
argument_list|,
operator|(
name|long
operator|)
name|KI_PTES
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|"kdb"
argument_list|,
name|KI_MAPSIZ
argument_list|)
expr_stmt|;
name|mscp_requeue
argument_list|(
operator|&
name|ki
operator|->
name|ki_mi
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdbinit
argument_list|(
name|ctlr
argument_list|)
condition|)
name|printf
argument_list|(
literal|" (hung)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Watchdog timer:  If the controller is active, and no interrupts  * have occurred for 30 seconds, assume it has gone away.  */
end_comment

begin_macro
name|kdbwatch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|kdbinfo
modifier|*
name|ki
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|timeout
argument_list|(
name|kdbwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* every second */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ki
operator|=
name|kdbinfo
init|;
name|i
operator|<
name|NKDB
condition|;
name|i
operator|++
operator|,
name|ki
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ki
operator|->
name|ki_flags
operator|&
name|KDB_ALIVE
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ki
operator|->
name|ki_state
operator|==
name|ST_IDLE
condition|)
continue|continue;
if|if
condition|(
name|ki
operator|->
name|ki_state
operator|==
name|ST_RUN
operator|&&
operator|!
name|ki
operator|->
name|ki_tab
operator|.
name|b_active
condition|)
name|ki
operator|->
name|ki_wticks
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|ki
operator|->
name|ki_wticks
operator|>=
literal|30
condition|)
block|{
name|ki
operator|->
name|ki_wticks
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"kdb%d: lost interrupt\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* kdbreset(ki); */
name|panic
argument_list|(
literal|"kdb lost interrupt"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Do a panic dump.  */
end_comment

begin_define
define|#
directive|define
name|DBSIZE
value|32
end_define

begin_comment
comment|/* dump 16K at a time */
end_comment

begin_struct
struct|struct
name|kdbdumpspace
block|{
name|struct
name|kdb1ca
name|kd_ca
decl_stmt|;
name|struct
name|mscp
name|kd_rsp
decl_stmt|;
name|struct
name|mscp
name|kd_cmd
decl_stmt|;
block|}
name|kdbdumpspace
struct|;
end_struct

begin_macro
name|kdbdump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|kdbdumpspace
modifier|*
name|kd
decl_stmt|;
specifier|register
name|struct
name|kdb_regs
modifier|*
name|k
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|num
decl_stmt|,
name|blk
decl_stmt|,
name|unit
decl_stmt|,
name|maxsz
decl_stmt|,
name|blkoff
decl_stmt|;
comment|/* 	 * Make sure the device is a reasonable place on which to dump. 	 */
name|unit
operator|=
name|kdbunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NKRA
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ui
operator|=
name|PHYS
argument_list|(
expr|struct
name|uba_device
operator|*
argument_list|,
name|kdbdinfo
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui
operator|==
name|NULL
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Find and initialise the KDB; get the physical address of the 	 * device registers, and of communications area and command and 	 * response packet. 	 */
name|k
operator|=
name|PHYS
argument_list|(
expr|struct
name|kdbinfo
operator|*
argument_list|,
operator|&
name|kdbinfo
index|[
name|ui
operator|->
name|ui_ctlr
index|]
argument_list|)
operator|->
name|ki_physkdb
expr_stmt|;
name|kd
operator|=
name|PHYS
argument_list|(
expr|struct
name|kdbdumpspace
operator|*
argument_list|,
operator|&
name|kdbdumpspace
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise the controller, with one command and one response 	 * packet. 	 */
name|bi_reset
argument_list|(
operator|&
name|k
operator|->
name|kdb_bi
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdbdumpwait
argument_list|(
name|k
argument_list|,
name|KDB_STEP1
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|k
operator|->
name|kdb_sw
operator|=
name|KDB_ERR
expr_stmt|;
if|if
condition|(
name|kdbdumpwait
argument_list|(
name|k
argument_list|,
name|KDB_STEP2
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|k
operator|->
name|kdb_sw
operator|=
operator|(
name|int
operator|)
operator|&
name|kd
operator|->
name|kd_ca
operator|.
name|ca_rspdsc
expr_stmt|;
if|if
condition|(
name|kdbdumpwait
argument_list|(
name|k
argument_list|,
name|KDB_STEP3
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|k
operator|->
name|kdb_sw
operator|=
operator|(
operator|(
name|int
operator|)
operator|&
name|kd
operator|->
name|kd_ca
operator|.
name|ca_rspdsc
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|kdbdumpwait
argument_list|(
name|k
argument_list|,
name|KDB_STEP4
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|k
operator|->
name|kdb_sw
operator|=
name|KDB_GO
expr_stmt|;
comment|/* 	 * Set up the command and response descriptor, then set the 	 * controller characteristics and bring the drive on line. 	 * Note that all uninitialised locations in kd_cmd are zero. 	 */
name|kd
operator|->
name|kd_ca
operator|.
name|ca_rspdsc
operator|=
operator|(
name|long
operator|)
operator|&
name|kd
operator|->
name|kd_rsp
operator|.
name|mscp_cmdref
expr_stmt|;
name|kd
operator|->
name|kd_ca
operator|.
name|ca_cmddsc
operator|=
operator|(
name|long
operator|)
operator|&
name|kd
operator|->
name|kd_cmd
operator|.
name|mscp_cmdref
expr_stmt|;
comment|/* kd->kd_cmd.mscp_sccc.sccc_ctlrflags = 0; */
comment|/* kd->kd_cmd.mscp_sccc.sccc_version = 0; */
if|if
condition|(
name|kdbdumpcmd
argument_list|(
name|M_OP_SETCTLRC
argument_list|,
name|k
argument_list|,
name|kd
argument_list|,
name|ui
operator|->
name|ui_ctlr
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|kd
operator|->
name|kd_cmd
operator|.
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
if|if
condition|(
name|kdbdumpcmd
argument_list|(
name|M_OP_ONLINE
argument_list|,
name|k
argument_list|,
name|kd
argument_list|,
name|ui
operator|->
name|ui_ctlr
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 	 * Pick up the drive type from the on line end packet; 	 * convert that to a dump area size and a disk offset. 	 * Note that the assembler uses pc-relative addressing 	 * to get at kdbtypes[], no need for PHYS(). 	 */
name|i
operator|=
name|kd
operator|->
name|kd_rsp
operator|.
name|mscp_onle
operator|.
name|onle_drivetype
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|NTYPES
operator|||
name|kdbtypes
index|[
name|i
index|]
operator|.
name|ut_name
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"disk type %d unknown\ndump "
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"on %s "
argument_list|,
name|kdbtypes
index|[
name|i
index|]
operator|.
name|ut_name
argument_list|)
expr_stmt|;
name|maxsz
operator|=
name|kdbtypes
index|[
name|i
index|]
operator|.
name|ut_sizes
index|[
name|kdbpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|nblocks
expr_stmt|;
name|blkoff
operator|=
name|kdbtypes
index|[
name|i
index|]
operator|.
name|ut_sizes
index|[
name|kdbpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|blkoff
expr_stmt|;
comment|/* 	 * Dump all of physical memory, or as much as will fit in the 	 * space provided. 	 */
name|start
operator|=
literal|0
expr_stmt|;
name|num
operator|=
name|maxfree
expr_stmt|;
if|if
condition|(
name|dumplo
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|dumplo
operator|+
name|num
operator|>=
name|maxsz
condition|)
name|num
operator|=
name|maxsz
operator|-
name|dumplo
expr_stmt|;
name|blkoff
operator|+=
name|dumplo
expr_stmt|;
comment|/* 	 * Write out memory, DBSIZE pages at a time. 	 * N.B.: this code depends on the fact that the sector 	 * size == the page size. 	 */
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|blk
operator|=
name|num
operator|>
name|DBSIZE
condition|?
name|DBSIZE
else|:
name|num
expr_stmt|;
name|kd
operator|->
name|kd_cmd
operator|.
name|mscp_unit
operator|=
name|ui
operator|->
name|ui_slave
expr_stmt|;
name|kd
operator|->
name|kd_cmd
operator|.
name|mscp_seq
operator|.
name|seq_lbn
operator|=
name|btop
argument_list|(
name|start
argument_list|)
operator|+
name|blkoff
expr_stmt|;
name|kd
operator|->
name|kd_cmd
operator|.
name|mscp_seq
operator|.
name|seq_bytecount
operator|=
name|blk
operator|<<
name|PGSHIFT
expr_stmt|;
name|kd
operator|->
name|kd_cmd
operator|.
name|mscp_seq
operator|.
name|seq_buffer
operator|=
operator|(
name|long
operator|)
name|start
operator||
name|KDB_PHYS
expr_stmt|;
if|if
condition|(
name|kdbdumpcmd
argument_list|(
name|M_OP_WRITE
argument_list|,
name|k
argument_list|,
name|kd
argument_list|,
name|ui
operator|->
name|ui_ctlr
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|start
operator|+=
name|blk
operator|<<
name|PGSHIFT
expr_stmt|;
name|num
operator|-=
name|blk
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* made it! */
block|}
end_block

begin_comment
comment|/*  * Wait for some of the bits in `bits' to come on.  If the error bit  * comes on, or ten seconds pass without response, return true (error).  */
end_comment

begin_expr_stmt
name|kdbdumpwait
argument_list|(
name|k
argument_list|,
name|bits
argument_list|)
specifier|register
expr|struct
name|kdb_regs
operator|*
name|k
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|bits
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|timo
init|=
name|todr
argument_list|()
operator|+
literal|1000
decl_stmt|;
while|while
condition|(
operator|(
name|k
operator|->
name|kdb_sa
operator|&
name|bits
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|k
operator|->
name|kdb_sa
operator|&
name|KDB_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"kdb_sa=%b\ndump "
argument_list|,
name|k
operator|->
name|kdb_sa
argument_list|,
name|kdbsr_bits
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|todr
argument_list|()
operator|>=
name|timo
condition|)
block|{
name|printf
argument_list|(
literal|"timeout\ndump "
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Feed a command to the KDB50, wait for its response, and return  * true iff something went wrong.  */
end_comment

begin_macro
name|kdbdumpcmd
argument_list|(
argument|op
argument_list|,
argument|k
argument_list|,
argument|kd
argument_list|,
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|kdb_regs
modifier|*
name|k
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|kdbdumpspace
modifier|*
name|kd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
define|#
directive|define
name|mp
value|(&kd->kd_rsp)
name|kd
operator|->
name|kd_cmd
operator|.
name|mscp_opcode
operator|=
name|op
expr_stmt|;
name|kd
operator|->
name|kd_cmd
operator|.
name|mscp_msglen
operator|=
name|MSCP_MSGLEN
expr_stmt|;
name|kd
operator|->
name|kd_rsp
operator|.
name|mscp_msglen
operator|=
name|MSCP_MSGLEN
expr_stmt|;
name|kd
operator|->
name|kd_ca
operator|.
name|ca_rspdsc
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
name|kd
operator|->
name|kd_ca
operator|.
name|ca_cmddsc
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|kdb_sa
operator|&
name|KDB_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"kdb_sa=%b\ndump "
argument_list|,
name|k
operator|->
name|kdb_sa
argument_list|,
name|kdbsr_bits
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|n
operator|=
name|k
operator|->
name|kdb_ip
expr_stmt|;
name|n
operator|=
name|todr
argument_list|()
operator|+
literal|1000
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|todr
argument_list|()
operator|>
name|n
condition|)
block|{
name|printf
argument_list|(
literal|"timeout\ndump "
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|kd
operator|->
name|kd_ca
operator|.
name|ca_cmdint
condition|)
name|kd
operator|->
name|kd_ca
operator|.
name|ca_cmdint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kd
operator|->
name|kd_ca
operator|.
name|ca_rspint
operator|==
literal|0
condition|)
continue|continue;
name|kd
operator|->
name|kd_ca
operator|.
name|ca_rspint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mscp_opcode
operator|==
operator|(
name|op
operator||
name|M_OP_END
operator|)
condition|)
break|break;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|MSCP_MSGTYPE
argument_list|(
name|mp
operator|->
name|mscp_msgtc
argument_list|)
condition|)
block|{
case|case
name|MSCPT_SEQ
case|:
name|printf
argument_list|(
literal|"sequential"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSCPT_DATAGRAM
case|:
name|mscp_decodeerror
argument_list|(
literal|"kdb"
argument_list|,
name|ctlr
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"datagram"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSCPT_CREDITS
case|:
name|printf
argument_list|(
literal|"credits"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSCPT_MAINTENANCE
case|:
name|printf
argument_list|(
literal|"maintenance"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown (type 0x%x)"
argument_list|,
name|MSCP_MSGTYPE
argument_list|(
name|mp
operator|->
name|mscp_msgtc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|" ignored\ndump "
argument_list|)
expr_stmt|;
name|kd
operator|->
name|kd_ca
operator|.
name|ca_rspdsc
operator||=
name|MSCP_OWN
operator||
name|MSCP_INT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mp
operator|->
name|mscp_status
operator|&
name|M_ST_MASK
operator|)
operator|!=
name|M_ST_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"error: op 0x%x => 0x%x status 0x%x\ndump "
argument_list|,
name|op
argument_list|,
name|mp
operator|->
name|mscp_opcode
argument_list|,
name|mp
operator|->
name|mscp_status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|mp
block|}
end_block

begin_comment
comment|/*  * Return the size of a partition, if known, or -1 if not.  */
end_comment

begin_macro
name|kdbsize
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|kdbunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|size
modifier|*
name|st
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NKRA
operator|||
operator|(
name|ui
operator|=
name|kdbdinfo
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|st
operator|=
operator|&
name|kdbtypes
index|[
name|ui
operator|->
name|ui_type
index|]
operator|.
name|ut_sizes
index|[
name|kdbpart
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|nblocks
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|s
init|=
name|spl5
argument_list|()
decl_stmt|;
comment|/* 		 * We need to have the drive on line to find the size 		 * of this particular partition. 		 * IS IT OKAY TO GO TO SLEEP IN THIS ROUTINE? 		 * (If not, better not page on one of these...) 		 */
if|if
condition|(
operator|(
name|ui
operator|->
name|ui_flags
operator|&
name|UNIT_ONLINE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|kdb_bringonline
argument_list|(
name|ui
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|blkoff
operator|>
name|ra_dsize
index|[
name|unit
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|ra_dsize
index|[
name|unit
index|]
operator|-
name|st
operator|->
name|blkoff
operator|)
return|;
block|}
return|return
operator|(
name|st
operator|->
name|nblocks
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|NKDB> 0
end_endif

end_unit

