begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)autoconf.c	7.11 (Berkeley) 7/10/88  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"reboot.h"
end_include

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../vax/nexus.h"
end_include

begin_include
include|#
directive|include
file|"../vax/pte.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxmba/mbareg.h"
end_include

begin_include
include|#
directive|include
file|"savax.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VAX8200
end_ifdef

begin_include
include|#
directive|include
file|"../vaxbi/bireg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|VAX8600
operator|||
name|VAX8200
operator|||
name|VAX780
end_if

begin_comment
comment|/*  * These are used on CPU's that do configuration.  */
end_comment

begin_decl_stmt
name|struct
name|uba_regs
modifier|*
name|ubaddrspace
index|[
name|MAXNUBA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|uioaddrspace
index|[
name|MAXNUBA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mba_regs
modifier|*
name|mbaddrspace
index|[
name|MAXNMBA
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|VAX750
end_if

begin_define
define|#
directive|define
name|UTR
parameter_list|(
name|i
parameter_list|)
value|((struct uba_regs *)(NEX750+(i)))
end_define

begin_define
define|#
directive|define
name|UMA
parameter_list|(
name|i
parameter_list|)
value|((caddr_t)UMEM750(i)+UBAIOADDR)
end_define

begin_define
define|#
directive|define
name|MTR
parameter_list|(
name|i
parameter_list|)
value|((struct mba_regs *)(NEX750+(i)))
end_define

begin_decl_stmt
name|struct
name|uba_regs
modifier|*
name|ubaddr750
index|[]
init|=
block|{
name|UTR
argument_list|(
literal|8
argument_list|)
block|,
name|UTR
argument_list|(
literal|9
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|uioaddr750
index|[]
init|=
block|{
name|UMA
argument_list|(
literal|0
argument_list|)
block|,
name|UMA
argument_list|(
literal|1
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mba_regs
modifier|*
name|mbaddr750
index|[]
init|=
block|{
name|MTR
argument_list|(
literal|4
argument_list|)
block|,
name|MTR
argument_list|(
literal|5
argument_list|)
block|,
name|MTR
argument_list|(
literal|6
argument_list|)
block|,
name|MTR
argument_list|(
literal|7
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|UTR
end_undef

begin_undef
undef|#
directive|undef
name|UMA
end_undef

begin_undef
undef|#
directive|undef
name|MTR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|VAX730
end_if

begin_define
define|#
directive|define
name|UTR
parameter_list|(
name|i
parameter_list|)
value|((struct uba_regs *)(NEX730+(i)))
end_define

begin_define
define|#
directive|define
name|UMA
value|((caddr_t)UMEM730+UBAIOADDR)
end_define

begin_decl_stmt
name|struct
name|uba_regs
modifier|*
name|ubaddr730
index|[]
init|=
block|{
name|UTR
argument_list|(
literal|3
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|uioaddr730
index|[]
init|=
block|{
name|UMA
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|UTR
end_undef

begin_undef
undef|#
directive|undef
name|UMA
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|VAX630
end_if

begin_comment
comment|/*  * The map registers start at 20088000 on the ka630, so  * subtract a 2k offset to make things work.  *  * This could stand serious cleanup.  */
end_comment

begin_decl_stmt
name|struct
name|uba_regs
modifier|*
name|ubaddr630
index|[]
init|=
block|{
operator|(
expr|struct
name|uba_regs
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|QBAMAP630
operator|-
literal|0x800
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|uioaddr630
index|[]
init|=
block|{
operator|(
name|caddr_t
operator|)
name|QIOPAGE630
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
argument_list|(
operator|*
name|v_getc
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|v_putc
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_comment
comment|/*  * Virtual console configuration tables.  */
end_comment

begin_extern
extern|extern qv_init(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|qd_init
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|vcons_init
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|qd_init
operator|,
function_decl|qv_init
operator|,
function_decl|0
end_function_decl

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|boothowto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|cpuspeed
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_macro
name|configure
argument_list|()
end_macro

begin_block
block|{
name|union
name|cpusid
name|cpusid
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|boothowto
operator|&
name|RB_KDB
condition|)
comment|/* XXX */
name|debug
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|cpusid
operator|.
name|cpusid
operator|=
name|mfpr
argument_list|(
name|SID
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|cpusid
operator|.
name|cpuany
operator|.
name|cp_type
expr_stmt|;
switch|switch
condition|(
name|cpu
condition|)
block|{
if|#
directive|if
name|VAX8600
case|case
name|VAX_8600
case|:
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"cpu: 8600\nsbia 0:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cpuspeed
operator|=
literal|6
expr_stmt|;
name|probenexi
argument_list|(
name|NEXA8600
argument_list|,
operator|(
name|caddr_t
operator|)
name|UMEMA8600
argument_list|(
literal|0
argument_list|)
operator|+
name|UBAIOADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|probenexi
argument_list|(
name|NEXB8600
argument_list|,
operator|(
name|caddr_t
operator|)
name|UMEMB8600
argument_list|(
literal|0
argument_list|)
operator|+
name|UBAIOADDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|VAX780
case|case
name|VAX_780
case|:
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"cpu: 780\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cpuspeed
operator|=
literal|2
expr_stmt|;
name|probenexi
argument_list|(
name|NEX780
argument_list|,
operator|(
name|caddr_t
operator|)
name|UMEM780
argument_list|(
literal|0
argument_list|)
operator|+
name|UBAIOADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|VAX8200
case|case
name|VAX_8200
case|:
block|{
specifier|register
name|struct
name|bi_node
modifier|*
name|bi
decl_stmt|;
name|cpuspeed
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bi
operator|=
name|BI_BASE
argument_list|(
literal|0
argument_list|)
init|;
name|i
operator|<
name|NNODEBI
condition|;
name|i
operator|++
operator|,
name|bi
operator|++
control|)
block|{
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|bi
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|notdef
comment|/* clear bus errors */
name|bi
operator|->
name|biic
operator|.
name|bi_ber
operator|=
operator|~
operator|(
name|BIBER_MBZ
operator||
name|BIBER_NMR
operator||
name|BIBER_UPEN
operator|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"node%d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|bi
operator|->
name|biic
operator|.
name|bi_dtype
condition|)
block|{
case|case
name|BIDT_DWBUA
case|:
if|if
condition|(
name|nuba
operator|>=
name|MAXNUBA
condition|)
comment|/* sorry */
break|break;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"uba%d\n"
argument_list|,
name|nuba
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ubaddrspace
index|[
name|nuba
index|]
operator|=
operator|(
expr|struct
name|uba_regs
operator|*
operator|)
name|bi
expr_stmt|;
name|uioaddrspace
index|[
name|nuba
index|]
operator|=
operator|(
name|caddr_t
operator|)
name|UMEM8200
argument_list|(
name|i
argument_list|)
operator|+
name|UBAIOADDR
expr_stmt|;
operator|(
operator|(
expr|struct
name|dwbua_regs
operator|*
operator|)
name|bi
operator|)
operator|->
name|bua_csr
operator||=
name|BUACSR_UPI
expr_stmt|;
name|nuba
operator|++
expr_stmt|;
break|break;
case|case
name|BIDT_KDB50
case|:
if|if
condition|(
name|nkdb
operator|<
name|MAXNKDB
condition|)
block|{
name|kdbaddr
index|[
name|nkdb
operator|++
index|]
operator|=
operator|(
name|caddr_t
operator|)
name|bi
expr_stmt|;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"kdb%d\n"
argument_list|,
name|nkdb
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
ifndef|#
directive|ifndef
name|SMALL
default|default:
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"unknown type %x\n"
argument_list|,
name|bi
operator|->
name|biic
operator|.
name|bi_dtype
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
name|ubaddr
operator|=
name|ubaddrspace
expr_stmt|;
name|uioaddr
operator|=
name|uioaddrspace
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
if|#
directive|if
name|VAX750
case|case
name|VAX_750
case|:
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"cpu: 750 -- assuming standard config\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mbaddr
operator|=
name|mbaddr750
expr_stmt|;
name|ubaddr
operator|=
name|ubaddr750
expr_stmt|;
name|uioaddr
operator|=
name|uioaddr750
expr_stmt|;
name|nmba
operator|=
sizeof|sizeof
argument_list|(
name|mbaddr750
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mbaddr750
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|nuba
operator|=
literal|2
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|VAX730
case|case
name|VAX_730
case|:
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"cpu: 730 -- assuming standard config\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ubaddr
operator|=
name|ubaddr730
expr_stmt|;
name|uioaddr
operator|=
name|uioaddr730
expr_stmt|;
name|nuba
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|VAX630
case|case
name|VAX_630
case|:
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"cpu: uVAX II\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ubaddr
operator|=
name|ubaddr630
expr_stmt|;
name|uioaddr
operator|=
name|uioaddr630
expr_stmt|;
name|nuba
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
comment|/* 	 * Forward into the past... 	 */
comment|/* 	for (i = 0; i< nmba; i++) 		if (!badaddr(mbaddr[i], sizeof(long))) 			mbaddr[i]->mba_cr = MBCR_INIT; */
switch|switch
condition|(
name|cpu
condition|)
block|{
if|#
directive|if
name|VAX750
operator|||
name|VAX730
case|case
name|VAX_750
case|:
case|case
name|VAX_730
case|:
name|mtpr
argument_list|(
name|IUR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|VAX630
case|case
name|VAX_630
case|:
name|mtpr
argument_list|(
name|IUR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|QIOPAGE630
operator|+
name|QIPCR
operator|)
operator|=
name|Q_LMEAE
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMALL
argument_list|)
comment|/* 		 * configure the console 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vcons_init
index|[
name|i
index|]
operator|&&
operator|!
call|(
modifier|*
name|vcons_init
index|[
name|i
index|]
call|)
argument_list|()
condition|;
name|i
operator|++
control|)
empty_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
comment|/* VAX630 */
block|}
comment|/* give unibus devices a chance to recover... */
if|if
condition|(
name|nuba
operator|>
literal|0
condition|)
name|DELAY
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|VAX8600
operator|||
name|VAX780
end_if

begin_expr_stmt
name|probenexi
argument_list|(
name|nxp
argument_list|,
name|umembase
argument_list|,
name|sbia
argument_list|)
specifier|register
expr|struct
name|nexus
operator|*
name|nxp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|umembase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sbia
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|union
name|nexcsr
name|nexcsr
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
operator|,
name|nxp
operator|++
control|)
block|{
if|if
condition|(
name|badaddr
argument_list|(
name|nxp
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
condition|)
continue|continue;
name|nexcsr
operator|=
name|nxp
operator|->
name|nexcsr
expr_stmt|;
if|if
condition|(
name|nexcsr
operator|.
name|nex_csr
operator|&
name|NEX_APD
condition|)
continue|continue;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|first
operator|&&
name|sbia
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"sbia %d:\n"
argument_list|,
name|sbia
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tr%d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|nexcsr
operator|.
name|nex_type
condition|)
block|{
default|default:
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nexid %2x\n"
argument_list|,
name|nexcsr
operator|.
name|nex_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|NEX_MEM4
case|:
case|case
name|NEX_MEM4I
case|:
case|case
name|NEX_MEM16
case|:
case|case
name|NEX_MEM16I
case|:
case|case
name|NEX_MEM64L
case|:
case|case
name|NEX_MEM64LI
case|:
case|case
name|NEX_MEM64U
case|:
case|case
name|NEX_MEM64UI
case|:
case|case
name|NEX_MEM64I
case|:
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"mem\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|NEX_CI
case|:
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ci\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|NEX_DR32
case|:
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"dr32\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|NEX_MPM0
case|:
case|case
name|NEX_MPM1
case|:
case|case
name|NEX_MPM2
case|:
case|case
name|NEX_MPM3
case|:
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"mpm\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|NEX_MBA
case|:
if|if
condition|(
name|nmba
operator|>=
name|MAXNMBA
condition|)
block|{
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"unsupported mba\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"mba%d\n"
argument_list|,
name|nmba
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mbaddrspace
index|[
name|nmba
index|]
operator|=
operator|(
expr|struct
name|mba_regs
operator|*
operator|)
name|nxp
expr_stmt|;
name|nmba
operator|++
expr_stmt|;
break|break;
case|case
name|NEX_UBA0
case|:
case|case
name|NEX_UBA1
case|:
case|case
name|NEX_UBA2
case|:
case|case
name|NEX_UBA3
case|:
if|if
condition|(
name|nuba
operator|>=
name|MAXNUBA
condition|)
block|{
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"unsupported uba\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"uba%d umem%d"
argument_list|,
name|nuba
argument_list|,
name|nexcsr
operator|.
name|nex_type
operator|&
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ubaddrspace
index|[
name|nuba
index|]
operator|=
operator|(
expr|struct
name|uba_regs
operator|*
operator|)
name|nxp
expr_stmt|;
name|uioaddrspace
index|[
name|nuba
index|]
operator|=
name|umembase
operator|+
operator|(
name|nexcsr
operator|.
name|nex_csr
operator|&
literal|3
operator|)
operator|*
operator|(
literal|512
operator|*
name|NBPG
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|" (%x)\n"
argument_list|,
name|uioaddrspace
index|[
name|nuba
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nuba
operator|++
expr_stmt|;
operator|(
operator|(
expr|struct
name|uba_regs
operator|*
operator|)
name|nxp
operator|)
operator|->
name|uba_cr
operator|=
name|UBACR_ADINIT
expr_stmt|;
break|break;
block|}
block|}
name|mbaddr
operator|=
name|mbaddrspace
expr_stmt|;
name|ubaddr
operator|=
name|ubaddrspace
expr_stmt|;
name|uioaddr
operator|=
name|uioaddrspace
expr_stmt|;
undef|#
directive|undef
name|UTR
undef|#
directive|undef
name|UMA
undef|#
directive|undef
name|MTR
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VAX780 || VAX8600 */
end_comment

end_unit

