begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1986 The Regents of the University of California.  * All rights reserved.  *  * Redistribution is only permitted until one year after the first shipment  * of 4.4BSD by the Regents.  Otherwise, redistribution and use in source and  * binary forms are permitted provided that: (1) source distributions retain  * this entire copyright notice and comment, and (2) distributions including  * binaries display the following acknowledgement:  This product includes  * software developed by the University of California, Berkeley and its  * contributors'' in the documentation or other materials provided with the  * distribution and in all advertising materials mentioning features or use  * of this software.  Neither the name of the University nor the names of  * its contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)ik.c	7.6 (Berkeley) 6/28/90  */
end_comment

begin_include
include|#
directive|include
file|"ik.h"
end_include

begin_if
if|#
directive|if
name|NIK
operator|>
literal|0
end_if

begin_comment
comment|/*  * PS300/IKON DR-11W Device Driver.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"dkstat.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/pte.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/ikreg.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/psreg.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/psproto.h"
end_include

begin_decl_stmt
name|int
name|ikprobe
argument_list|()
decl_stmt|,
name|ikattach
argument_list|()
decl_stmt|,
name|iktimer
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|ikinfo
index|[
name|NIK
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|ikstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|ikdriver
init|=
block|{
name|ikprobe
block|,
literal|0
block|,
name|ikattach
block|,
literal|0
block|,
name|ikstd
block|,
literal|"ik"
block|,
name|ikinfo
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|splik
parameter_list|()
value|spl4()
end_define

begin_comment
comment|/*  * Devices are organized in pairs with the odd valued  * device being used for ``diagnostic'' purposes.  That  * is diagnostic devices don't get auto-attach'd and  * detach'd on open-close.  */
end_comment

begin_define
define|#
directive|define
name|IKUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>> 1)
end_define

begin_define
define|#
directive|define
name|IKDIAG
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 01)
end_define

begin_comment
comment|/* is a diagnostic unit */
end_comment

begin_struct
struct|struct
name|ik_softc
block|{
name|uid_t
name|is_uid
decl_stmt|;
comment|/* uid of open processes */
name|u_short
name|is_timeout
decl_stmt|;
comment|/* current timeout (seconds) */
name|u_short
name|is_error
decl_stmt|;
comment|/* internal error codes */
name|u_short
name|is_flags
decl_stmt|;
define|#
directive|define
name|IKF_ATTACHED
value|0x1
comment|/* unit is attached (not used yet) */
union|union
block|{
name|u_short
name|w
index|[
literal|2
index|]
decl_stmt|;
name|u_long
name|l
decl_stmt|;
block|}
name|is_nameaddr
union|;
comment|/* address of last symbol lookup */
name|caddr_t
name|is_buf
index|[
name|PS_MAXDMA
index|]
decl_stmt|;
comment|/* i/o buffer XXX */
block|}
name|ik_softc
index|[
name|NIK
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|buf
name|iktab
index|[
name|NIK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* unit command queue headers */
end_comment

begin_decl_stmt
name|struct
name|buf
name|rikbuf
index|[
name|NIK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers for read/write operations */
end_comment

begin_decl_stmt
name|struct
name|buf
name|cikbuf
index|[
name|NIK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers for control operations */
end_comment

begin_comment
comment|/* buf overlay definitions */
end_comment

begin_define
define|#
directive|define
name|b_command
value|b_resid
end_define

begin_decl_stmt
name|int
name|ikdiotimo
init|=
name|PS_DIOTIMO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dio polling timeout */
end_comment

begin_decl_stmt
name|int
name|iktimeout
init|=
name|PS_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* attention/dma timeout (in hz) */
end_comment

begin_macro
name|ikprobe
argument_list|(
argument|reg
argument_list|,
argument|vi
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* r12, r11 */
specifier|register
name|struct
name|ikdevice
modifier|*
name|ik
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|ikintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|badaddr
argument_list|(
name|reg
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ik
operator|=
operator|(
expr|struct
name|ikdevice
operator|*
operator|)
name|reg
expr_stmt|;
name|ik
operator|->
name|ik_vec
operator|=
operator|--
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
expr_stmt|;
comment|/* 	 * Use extended non-privileged address modifier 	 * to avoid address overlap with 24-bit devices. 	 */
name|ik
operator|->
name|ik_mod
operator|=
literal|0xf1
expr_stmt|;
comment|/* address modifier */
comment|/* 	 * Try and reset the PS300.  Since this 	 * won't work if it's powered off, we 	 * can't use sucess/failure to decide 	 * if the device is present. 	 */
name|br
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|psreset
argument_list|(
name|ik
argument_list|,
name|IKCSR_IENA
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
literal|0
condition|)
comment|/* XXX */
name|br
operator|=
literal|0x18
operator|,
name|cvec
operator|=
name|ik
operator|->
name|ik_vec
expr_stmt|;
comment|/* XXX */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ikdevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Perform a ``hard'' reset.  */
end_comment

begin_expr_stmt
name|psreset
argument_list|(
name|ik
argument_list|,
name|iena
argument_list|)
specifier|register
expr|struct
name|ikdevice
operator|*
name|ik
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|ik
operator|->
name|ik_csr
operator|=
name|IKCSR_MCLR
operator||
name|iena
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|ik
operator|->
name|ik_csr
operator|=
name|IKCSR_FNC3
operator||
name|iena
expr_stmt|;
if|if
condition|(
operator|!
name|iena
condition|)
return|return
operator|(
name|dioread
argument_list|(
name|ik
argument_list|)
operator|==
name|PS_RESET
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|ikattach
argument_list|(
argument|vi
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ik_softc
index|[
name|vi
operator|->
name|ui_unit
index|]
operator|.
name|is_uid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Open a PS300 and attach.  We allow multiple  * processes with the same uid to share a unit.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|ikopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|IKUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|ik_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|struct
name|ikdevice
modifier|*
name|ik
decl_stmt|;
name|int
name|reset
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NIK
operator|||
operator|(
name|vi
operator|=
name|ikinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
operator|&
name|ik_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_uid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|sc
operator|->
name|is_uid
operator|!=
name|u
operator|.
name|u_uid
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|is_uid
operator|==
operator|(
name|uid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|sc
operator|->
name|is_timeout
operator|=
literal|0
expr_stmt|;
name|timeout
argument_list|(
name|iktimer
argument_list|,
operator|(
name|caddr_t
operator|)
name|unit
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* 		 * Perform PS300 attach for first process. 		 */
if|if
condition|(
operator|!
name|IKDIAG
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|reset
operator|=
literal|0
expr_stmt|;
name|again
label|:
if|if
condition|(
name|ikcommand
argument_list|(
name|dev
argument_list|,
name|PS_ATTACH
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* 				 * If attach fails, perform a hard 				 * reset once, then retry the command. 				 */
name|ik
operator|=
operator|(
expr|struct
name|ikdevice
operator|*
operator|)
name|ikinfo
index|[
name|unit
index|]
operator|->
name|ui_addr
expr_stmt|;
if|if
condition|(
operator|!
name|reset
operator|++
operator|&&
name|psreset
argument_list|(
name|ik
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|untimeout
argument_list|(
name|iktimer
argument_list|,
operator|(
name|caddr_t
operator|)
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|is_uid
operator|=
name|u
operator|.
name|u_uid
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|ikclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|IKUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|ik_softc
modifier|*
name|sc
init|=
operator|&
name|ik_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|IKDIAG
argument_list|(
name|dev
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ikcommand
argument_list|(
name|dev
argument_list|,
name|PS_DETACH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* auto detach */
name|sc
operator|->
name|is_uid
operator|=
operator|-
literal|1
expr_stmt|;
name|untimeout
argument_list|(
name|iktimer
argument_list|,
operator|(
name|caddr_t
operator|)
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|ikread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|ikrw
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|,
name|B_READ
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|ikwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|ikrw
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|,
name|B_WRITE
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Take read/write request and perform physical i/o  * transaction with PS300.  This involves constructing  * a physical i/o request vector based on the uio  * vector, performing the dma, and, finally, moving  * the data to it's final destination (because of CCI  * VERSAbus bogosities).  */
end_comment

begin_macro
name|ikrw
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|,
argument|rw
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rw
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|,
name|unit
init|=
name|IKUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|s
decl_stmt|,
name|wrcmd
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
specifier|register
name|struct
name|psalist
modifier|*
name|ap
decl_stmt|;
name|struct
name|ik_softc
modifier|*
name|sc
init|=
operator|&
name|ik_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NIK
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bp
operator|=
operator|&
name|rikbuf
index|[
name|unit
index|]
expr_stmt|;
name|error
operator|=
literal|0
operator|,
name|iov
operator|=
name|uio
operator|->
name|uio_iov
operator|,
name|wrcmd
operator|=
name|PS_WRPHY
expr_stmt|;
for|for
control|(
init|;
operator|!
name|error
operator|&&
name|uio
operator|->
name|uio_iovcnt
condition|;
name|iov
operator|++
operator|,
name|uio
operator|->
name|uio_iovcnt
operator|--
control|)
block|{
comment|/* 		 * Hack way to set PS300 address w/o doing an lseek 		 * and specify write physical w/ refresh synchronization. 		 */
if|if
condition|(
name|iov
operator|->
name|iov_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|iov
operator|->
name|iov_base
operator|&
name|PSIO_SYNC
condition|)
name|wrcmd
operator|=
name|PS_WRPHY_SYNC
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|=
operator|(
name|int
operator|)
name|iov
operator|->
name|iov_base
operator|&
operator|~
name|PSIO_SYNC
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|iov
operator|->
name|iov_len
operator|>
name|PS_MAXDMA
condition|)
block|{
name|sc
operator|->
name|is_error
operator|=
name|PSERROR_INVALBC
operator|,
name|error
operator|=
name|EINVAL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_offset
operator|&
literal|01
condition|)
block|{
name|sc
operator|->
name|is_error
operator|=
name|PSERROR_BADADDR
operator|,
name|error
operator|=
name|EINVAL
expr_stmt|;
continue|continue;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|rw
expr_stmt|;
comment|/* 		 * Construct address descriptor in buffer. 		 */
name|ap
operator|=
operator|(
expr|struct
name|psalist
operator|*
operator|)
name|sc
operator|->
name|is_buf
expr_stmt|;
name|ap
operator|->
name|nblocks
operator|=
literal|1
expr_stmt|;
comment|/* work-around dr300 word swapping */
name|ap
operator|->
name|addr
index|[
literal|0
index|]
operator|=
name|uio
operator|->
name|uio_offset
operator|&
literal|0xffff
expr_stmt|;
name|ap
operator|->
name|addr
index|[
literal|1
index|]
operator|=
name|uio
operator|->
name|uio_offset
operator|>>
literal|16
expr_stmt|;
name|ap
operator|->
name|wc
operator|=
operator|(
name|iov
operator|->
name|iov_len
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|B_WRITE
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|iov
operator|->
name|iov_base
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ap
index|[
literal|1
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|iov
operator|->
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|ikcommand
argument_list|(
name|dev
argument_list|,
name|wrcmd
argument_list|,
name|iov
operator|->
name|iov_len
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|caddr_t
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|error
operator|=
name|ikcommand
argument_list|(
name|dev
argument_list|,
name|PS_RDPHY
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ap
index|[
literal|1
index|]
operator|,
name|len
operator|=
name|iov
operator|->
name|iov_len
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|NBPG
operator|,
name|cp
operator|+=
name|NBPG
control|)
name|mtpr
argument_list|(
name|P1DC
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ap
index|[
literal|1
index|]
argument_list|,
name|iov
operator|->
name|iov_base
argument_list|,
operator|(
name|unsigned
operator|)
name|iov
operator|->
name|iov_len
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|-=
name|iov
operator|->
name|iov_len
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|+=
name|iov
operator|->
name|iov_len
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_BUSY
operator||
name|B_WANTED
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Perform a PS300 command.  */
end_comment

begin_macro
name|ikcommand
argument_list|(
argument|dev
argument_list|,
argument|com
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|com
decl_stmt|,
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bp
operator|=
operator|&
name|cikbuf
index|[
name|IKUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|s
operator|=
name|splik
argument_list|()
expr_stmt|;
while|while
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
condition|)
break|break;
name|bp
operator|->
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_command
operator|=
name|com
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|count
expr_stmt|;
name|ikstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
name|B_ERROR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Physio strategy routine  */
end_comment

begin_expr_stmt
name|ikstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
comment|/* 	 * Put request at end of controller queue. 	 */
name|dp
operator|=
operator|&
name|iktab
index|[
name|IKUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|splik
argument_list|()
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
operator|!=
name|NULL
condition|)
block|{
name|dp
operator|->
name|b_actl
operator|->
name|av_forw
operator|=
name|bp
expr_stmt|;
name|dp
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
block|}
else|else
name|dp
operator|->
name|b_actf
operator|=
name|dp
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
if|if
condition|(
operator|!
name|dp
operator|->
name|b_active
condition|)
name|ikstart
argument_list|(
name|dp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start the next command on the controller's queue.  */
end_comment

begin_expr_stmt
name|ikstart
argument_list|(
name|dp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|dp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|ikdevice
modifier|*
name|ik
decl_stmt|;
specifier|register
name|struct
name|ik_softc
modifier|*
name|sc
decl_stmt|;
name|u_short
name|bc
decl_stmt|,
name|csr
decl_stmt|;
name|u_int
name|addr
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|loop
label|:
comment|/* 	 * Pull a request off the controller queue 	 */
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * Mark controller busy and process this request. 	 */
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
name|unit
operator|=
name|IKUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|ik_softc
index|[
name|unit
index|]
expr_stmt|;
name|ik
operator|=
operator|(
expr|struct
name|ikdevice
operator|*
operator|)
name|ikinfo
index|[
name|unit
index|]
operator|->
name|ui_addr
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_command
condition|)
block|{
case|case
name|PS_ATTACH
case|:
comment|/* logical unit attach */
case|case
name|PS_DETACH
case|:
comment|/* logical unit detach */
case|case
name|PS_LOOKUP
case|:
comment|/* name lookup */
case|case
name|PS_RDPHY
case|:
comment|/* physical i/o read */
case|case
name|PS_WRPHY
case|:
comment|/* physical i/o write */
case|case
name|PS_WRPHY_SYNC
case|:
comment|/* physical i/o write w/ sync */
comment|/* 		 * Handshake command and, optionally, 		 * byte count and byte swap flag. 		 */
if|if
condition|(
name|sc
operator|->
name|is_error
operator|=
name|diowrite
argument_list|(
name|ik
argument_list|,
operator|(
name|u_short
operator|)
name|bp
operator|->
name|b_command
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|bp
operator|->
name|b_command
operator|<
name|PS_DETACH
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|is_error
operator|=
name|diowrite
argument_list|(
name|ik
argument_list|,
operator|(
name|u_short
operator|)
name|bp
operator|->
name|b_bcount
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|sc
operator|->
name|is_error
operator|=
name|diowrite
argument_list|(
name|ik
argument_list|,
operator|(
name|u_short
operator|)
literal|0
comment|/* !swab */
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Set timeout and wait for an attention interrupt. 		 */
name|sc
operator|->
name|is_timeout
operator|=
name|iktimeout
expr_stmt|;
return|return;
case|case
name|PS_DMAOUT
case|:
comment|/* dma data host->PS300 */
name|bc
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|csr
operator|=
name|IKCSR_CYCLE
expr_stmt|;
break|break;
case|case
name|PS_DMAIN
case|:
comment|/* dma data PS300->host */
name|bc
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|csr
operator|=
name|IKCSR_CYCLE
operator||
name|IKCSR_FNC1
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ik%d: bad cmd %x\n"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_command
argument_list|)
expr_stmt|;
name|sc
operator|->
name|is_error
operator|=
name|PSERROR_BADCMD
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* initiate dma transfer */
name|addr
operator|=
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|sc
operator|->
name|is_buf
argument_list|)
expr_stmt|;
name|ik
operator|->
name|ik_bahi
operator|=
name|addr
operator|>>
literal|17
expr_stmt|;
name|ik
operator|->
name|ik_balo
operator|=
operator|(
name|addr
operator|>>
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|ik
operator|->
name|ik_wc
operator|=
operator|(
operator|(
name|bc
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* round& convert */
name|ik
operator|->
name|ik_pulse
operator|=
name|IKPULSE_RATTF
operator||
name|IKPULSE_RDMAF
expr_stmt|;
name|sc
operator|->
name|is_timeout
operator|=
name|iktimeout
expr_stmt|;
name|ik
operator|->
name|ik_csr
operator|=
name|IKCSR_IENA
operator||
name|IKCSR_GO
operator||
name|csr
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
comment|/* remove from queue */
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_block

begin_define
define|#
directive|define
name|FETCHWORD
parameter_list|(
name|i
parameter_list|)
value|{ \ 	v = dioread(ik); \ 	if (v == -1) { \ 		sc->is_error = PSERROR_NAMETIMO; \ 		goto bad; \ 	} \ 	sc->is_nameaddr.w[i] = v; \ }
end_define

begin_comment
comment|/*  * Process a device interrupt.  */
end_comment

begin_macro
name|ikintr
argument_list|(
argument|ikon
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ikon
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ikdevice
modifier|*
name|ik
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|struct
name|ik_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|u_short
name|data
decl_stmt|;
name|int
name|v
decl_stmt|;
comment|/* should go by controller, but for now... */
if|if
condition|(
name|ikinfo
index|[
name|ikon
index|]
operator|==
literal|0
condition|)
return|return;
name|ik
operator|=
operator|(
expr|struct
name|ikdevice
operator|*
operator|)
name|ikinfo
index|[
name|ikon
index|]
operator|->
name|ui_addr
expr_stmt|;
comment|/* 	 * Discard all non-attention interrupts.  The 	 * interrupts we're throwing away should all be 	 * associated with DMA completion. 	 */
name|data
operator|=
name|ik
operator|->
name|ik_data
expr_stmt|;
if|if
condition|(
operator|(
name|ik
operator|->
name|ik_csr
operator|&
operator|(
name|IKCSR_ATTF
operator||
name|IKCSR_STATC
operator|)
operator|)
operator|!=
name|IKCSR_ATTF
condition|)
block|{
name|ik
operator|->
name|ik_pulse
operator|=
name|IKPULSE_RATTF
operator||
name|IKPULSE_RDMAF
operator||
name|IKPULSE_SIENA
expr_stmt|;
return|return;
block|}
comment|/* 	 * Fetch attention code immediately. 	 */
name|ik
operator|->
name|ik_csr
operator|=
name|IKCSR_RATTF
operator||
name|IKCSR_RDMAF
operator||
name|IKCSR_FNC1
expr_stmt|;
name|ik
operator|->
name|ik_pulse
operator|=
name|IKPULSE_FNC2
expr_stmt|;
comment|/* 	 * Get device and block structures, and a pointer 	 * to the vba_device for the device.  We receive an 	 * unsolicited interrupt whenever the PS300 is power 	 * cycled (so ignore it in that case). 	 */
name|dp
operator|=
operator|&
name|iktab
index|[
name|ikon
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|PS_CODE
argument_list|(
name|data
argument_list|)
operator|!=
name|PS_RESET
condition|)
comment|/* power failure */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"ik%d: spurious interrupt, code %x\n"
argument_list|,
name|ikon
argument_list|,
name|data
argument_list|)
expr_stmt|;
goto|goto
name|enable
goto|;
block|}
name|sc
operator|=
operator|&
name|ik_softc
index|[
name|IKUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|sc
operator|->
name|is_timeout
operator|=
literal|0
expr_stmt|;
comment|/* disable timer */
switch|switch
condition|(
name|PS_CODE
argument_list|(
name|data
argument_list|)
condition|)
block|{
case|case
name|PS_LOOKUP
case|:
comment|/* name lookup */
if|if
condition|(
name|data
operator|==
name|PS_LOOKUP
condition|)
block|{
comment|/* dma name */
name|bp
operator|->
name|b_command
operator|=
name|PS_DMAOUT
expr_stmt|;
goto|goto
name|opcont
goto|;
block|}
if|if
condition|(
name|data
operator|==
name|PS_DMAOK
argument_list|(
name|PS_LOOKUP
argument_list|)
condition|)
block|{
comment|/* reenable interrupt and wait for address */
name|sc
operator|->
name|is_timeout
operator|=
name|iktimeout
expr_stmt|;
goto|goto
name|enable
goto|;
block|}
comment|/* 		 * Address should be present, extract it one 		 * word at a time from the PS300 (yech). 		 */
if|if
condition|(
name|data
operator|!=
name|PS_ADROK
argument_list|(
name|PS_LOOKUP
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|FETCHWORD
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|FETCHWORD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|opdone
goto|;
case|case
name|PS_WRPHY_SYNC
case|:
comment|/* physical i/o write w/ sync */
if|if
condition|(
name|data
operator|==
name|PS_WRPHY_SYNC
condition|)
block|{
comment|/* start dma transfer */
name|bp
operator|->
name|b_command
operator|=
name|PS_DMAOUT
expr_stmt|;
goto|goto
name|opcont
goto|;
block|}
if|if
condition|(
name|data
operator|!=
name|PS_DMAOK
argument_list|(
name|PS_WRPHY_SYNC
argument_list|)
condition|)
goto|goto
name|bad
goto|;
goto|goto
name|opdone
goto|;
case|case
name|PS_WRPHY
case|:
comment|/* physical i/o write */
if|if
condition|(
name|data
operator|==
name|PS_WRPHY
condition|)
block|{
comment|/* start dma transfer */
name|bp
operator|->
name|b_command
operator|=
name|PS_DMAOUT
expr_stmt|;
goto|goto
name|opcont
goto|;
block|}
if|if
condition|(
name|data
operator|!=
name|PS_DMAOK
argument_list|(
name|PS_WRPHY
argument_list|)
condition|)
goto|goto
name|bad
goto|;
goto|goto
name|opdone
goto|;
case|case
name|PS_ATTACH
case|:
comment|/* attach unit */
case|case
name|PS_DETACH
case|:
comment|/* detach unit */
case|case
name|PS_ABORT
case|:
comment|/* abort code from ps300 */
if|if
condition|(
name|data
operator|!=
name|bp
operator|->
name|b_command
condition|)
goto|goto
name|bad
goto|;
goto|goto
name|opdone
goto|;
case|case
name|PS_RDPHY
case|:
comment|/* physical i/o read */
if|if
condition|(
name|data
operator|==
name|PS_RDPHY
condition|)
block|{
comment|/* dma address list */
name|bp
operator|->
name|b_command
operator|=
name|PS_DMAOUT
expr_stmt|;
goto|goto
name|opcont
goto|;
block|}
if|if
condition|(
name|data
operator|==
name|PS_ADROK
argument_list|(
name|PS_RDPHY
argument_list|)
condition|)
block|{
comment|/* collect read byte count and start dma */
name|bp
operator|->
name|b_bcount
operator|=
name|dioread
argument_list|(
name|ik
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
operator|-
literal|1
condition|)
goto|goto
name|bad
goto|;
name|bp
operator|->
name|b_command
operator|=
name|PS_DMAIN
expr_stmt|;
goto|goto
name|opcont
goto|;
block|}
if|if
condition|(
name|data
operator|==
name|PS_DMAOK
argument_list|(
name|PS_RDPHY
argument_list|)
condition|)
goto|goto
name|opdone
goto|;
goto|goto
name|bad
goto|;
block|}
name|bad
label|:
name|sc
operator|->
name|is_error
operator|=
name|data
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|opdone
label|:
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
comment|/* remove from queue */
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|opcont
label|:
name|ikstart
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|enable
label|:
name|ik
operator|->
name|ik_pulse
operator|=
name|IKPULSE_SIENA
expr_stmt|;
comment|/* explicitly reenable */
block|}
end_block

begin_comment
comment|/*  * Watchdog timer.  */
end_comment

begin_macro
name|iktimer
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ik_softc
modifier|*
name|sc
init|=
operator|&
name|ik_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_timeout
operator|&&
operator|--
name|sc
operator|->
name|is_timeout
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ik%d: timeout\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|s
operator|=
name|splik
argument_list|()
expr_stmt|;
comment|/* should abort current command */
name|dp
operator|=
operator|&
name|iktab
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
condition|)
block|{
name|sc
operator|->
name|is_error
operator|=
name|PSERROR_CMDTIMO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
comment|/* remove from queue */
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ikstart
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
name|iktimer
argument_list|,
operator|(
name|caddr_t
operator|)
name|unit
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Handshake read from DR300.  */
end_comment

begin_expr_stmt
name|dioread
argument_list|(
name|ik
argument_list|)
specifier|register
expr|struct
name|ikdevice
operator|*
name|ik
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|t
decl_stmt|;
name|u_short
name|data
decl_stmt|;
for|for
control|(
name|t
operator|=
name|ikdiotimo
init|;
name|t
operator|>
literal|0
condition|;
name|t
operator|--
control|)
if|if
condition|(
operator|(
name|ik
operator|->
name|ik_csr
operator|&
operator|(
name|IKCSR_ATTF
operator||
name|IKCSR_STATC
operator|)
operator|)
operator|==
name|IKCSR_ATTF
condition|)
block|{
name|data
operator|=
name|ik
operator|->
name|ik_data
expr_stmt|;
name|ik
operator|->
name|ik_csr
operator|=
name|IKCSR_RATTF
operator||
name|IKCSR_RDMAF
operator||
name|IKCSR_FNC1
expr_stmt|;
name|ik
operator|->
name|ik_pulse
operator|=
name|IKPULSE_FNC2
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Handshake write to DR300.   *  * Interrupts are enabled before completing the work  * so the caller should either be at splik or be  * prepared to take the interrupt immediately.  */
end_comment

begin_expr_stmt
name|diowrite
argument_list|(
name|ik
argument_list|,
name|v
argument_list|)
specifier|register
expr|struct
name|ikdevice
operator|*
name|ik
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_short
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|u_short
name|csr
decl_stmt|;
name|top
label|:
comment|/* 	 * Deposit data and generate dr300 attention 	 */
name|ik
operator|->
name|ik_data
operator|=
name|v
expr_stmt|;
name|ik
operator|->
name|ik_csr
operator|=
name|IKCSR_RDMAF
operator||
name|IKCSR_RATTF
expr_stmt|;
name|ik
operator|->
name|ik_pulse
operator|=
name|IKPULSE_FNC2
expr_stmt|;
for|for
control|(
name|t
operator|=
name|ikdiotimo
init|;
name|t
operator|>
literal|0
condition|;
name|t
operator|--
control|)
block|{
name|csr
operator|=
name|ik
operator|->
name|ik_csr
expr_stmt|;
define|#
directive|define
name|IKCSR_DONE
value|(IKCSR_STATA|IKCSR_STATC)
if|if
condition|(
operator|(
name|csr
operator|&
name|IKCSR_DONE
operator|)
operator|==
name|IKCSR_DONE
condition|)
block|{
comment|/*  			 * Done, complete handshake by notifying dr300. 			 */
name|ik
operator|->
name|ik_csr
operator|=
name|IKCSR_IENA
expr_stmt|;
comment|/* ~IKCSR_FNC1 */
name|ik
operator|->
name|ik_pulse
operator|=
name|IKPULSE_FNC2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* beware of potential deadlock with dioread */
if|if
condition|(
operator|(
name|csr
operator|&
operator|(
name|IKCSR_ATTF
operator||
name|IKCSR_STATC
operator|)
operator|)
operator|==
name|IKCSR_ATTF
condition|)
goto|goto
name|top
goto|;
block|}
name|ik
operator|->
name|ik_csr
operator|=
name|IKCSR_IENA
expr_stmt|;
return|return
operator|(
name|PSERROR_DIOTIMO
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|ikioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|,
name|unit
init|=
name|IKUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|s
decl_stmt|;
specifier|register
name|struct
name|ik_softc
modifier|*
name|sc
init|=
operator|&
name|ik_softc
index|[
name|unit
index|]
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PSIOGETERROR
case|:
comment|/* get error code for last operation */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|is_error
expr_stmt|;
break|break;
case|case
name|PSIOLOOKUP
case|:
block|{
comment|/* PS300 name lookup */
specifier|register
name|struct
name|pslookup
modifier|*
name|lp
init|=
operator|(
expr|struct
name|pslookup
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|lp
operator|->
name|pl_len
operator|>
name|PS_MAXNAMELEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bp
operator|=
operator|&
name|rikbuf
index|[
name|unit
index|]
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_WRITE
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|lp
operator|->
name|pl_name
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|is_buf
argument_list|,
operator|(
name|unsigned
operator|)
name|lp
operator|->
name|pl_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|pl_len
operator|&
literal|1
condition|)
name|sc
operator|->
name|is_buf
index|[
name|lp
operator|->
name|pl_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|ikcommand
argument_list|(
name|dev
argument_list|,
name|PS_LOOKUP
argument_list|,
name|lp
operator|->
name|pl_len
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_BUSY
operator||
name|B_WANTED
operator|)
expr_stmt|;
name|lp
operator|->
name|pl_addr
operator|=
name|sc
operator|->
name|is_nameaddr
operator|.
name|l
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

