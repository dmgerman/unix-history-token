begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)maps.c	1.7 (Berkeley/CCI) 6/7/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"vdfmt.h"
end_include

begin_comment
comment|/* ** */
end_comment

begin_function
name|boolean
name|align_buf
parameter_list|(
name|buf
parameter_list|,
name|sync
parameter_list|)
name|unsigned
name|long
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|sync
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|shift
decl_stmt|;
comment|/* find shift amount */
for|for
control|(
name|shift
operator|=
literal|0
init|;
name|shift
operator|<
literal|32
condition|;
name|shift
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|buf
operator|>>
name|shift
operator|)
operator|==
name|sync
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|(
literal|512
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|1
operator|)
operator||=
operator|*
operator|(
name|buf
operator|+
name|i
operator|)
operator|<<
operator|(
literal|32
operator|-
name|shift
operator|)
expr_stmt|;
operator|*
operator|(
name|buf
operator|+
name|i
operator|)
operator|=
operator|*
operator|(
name|buf
operator|+
name|i
operator|)
operator|>>
name|shift
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* **	Looks for two maps in a row that are the same. */
end_comment

begin_function
name|boolean
name|read_map
parameter_list|(
name|flags
parameter_list|)
name|short
name|flags
decl_stmt|;
block|{
specifier|register
name|int
name|trk
decl_stmt|,
name|i
decl_stmt|;
name|dskadr
name|dskaddr
decl_stmt|;
name|dskaddr
operator|.
name|cylinder
operator|=
operator|(
name|lab
operator|->
name|d_ncylinders
operator|-
literal|1
operator|)
operator||
name|flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
name|scratch
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|trk
operator|=
literal|0
init|;
name|trk
operator|<
name|lab
operator|->
name|d_ntracks
condition|;
name|trk
operator|++
control|)
block|{
name|dskaddr
operator|.
name|track
operator|=
name|trk
expr_stmt|;
name|dskaddr
operator|.
name|sector
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|access_dsk
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save
argument_list|,
operator|&
name|dskaddr
argument_list|,
name|VDOP_RD
argument_list|,
name|lab
operator|->
name|d_nsectors
argument_list|,
literal|1
argument_list|)
operator|&
name|VDERR_HARD
condition|)
continue|continue;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|scratch
argument_list|,
operator|(
name|char
operator|*
operator|)
name|save
argument_list|,
name|bytes_trk
argument_list|)
operator|==
name|true
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bad_map
argument_list|,
name|bytes_trk
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad_map
operator|->
name|bs_count
operator|<=
name|MAX_FLAWS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bad_map
operator|->
name|bs_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bad_map
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_cyl
operator|>=
name|lab
operator|->
name|d_ncylinders
condition|)
break|break;
if|if
condition|(
name|bad_map
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_trk
operator|>=
name|lab
operator|->
name|d_ntracks
condition|)
break|break;
if|if
condition|(
name|bad_map
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_offset
operator|>=
name|lab
operator|->
name|d_traksize
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|bad_map
operator|->
name|bs_count
condition|)
block|{
name|load_free_table
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
name|bzero
argument_list|(
name|bad_map
argument_list|,
name|bytes_trk
argument_list|)
expr_stmt|;
name|bad_map
operator|->
name|bs_id
operator|=
literal|0
expr_stmt|;
name|bad_map
operator|->
name|bs_max
operator|=
name|MAX_FLAWS
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save
argument_list|,
operator|(
name|char
operator|*
operator|)
name|scratch
argument_list|,
name|bytes_trk
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* ** */
end_comment

begin_function
name|boolean
name|read_bad_sector_map
parameter_list|()
block|{
name|dskadr
name|dskaddr
decl_stmt|;
name|dskaddr
operator|.
name|cylinder
operator|=
name|lab
operator|->
name|d_ncylinders
operator|-
literal|1
expr_stmt|;
name|dskaddr
operator|.
name|track
operator|=
literal|0
expr_stmt|;
name|dskaddr
operator|.
name|sector
operator|=
literal|0
expr_stmt|;
comment|/* start with nothing in map */
name|bzero
argument_list|(
name|bad_map
argument_list|,
name|bytes_trk
argument_list|)
expr_stmt|;
name|bad_map
operator|->
name|bs_id
operator|=
literal|0
expr_stmt|;
name|bad_map
operator|->
name|bs_max
operator|=
name|MAX_FLAWS
expr_stmt|;
if|if
condition|(
name|C_INFO
operator|->
name|type
operator|==
name|VDTYPE_SMDE
condition|)
block|{
name|access_dsk
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save
argument_list|,
operator|&
name|dskaddr
argument_list|,
name|VDOP_RDRAW
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_buf
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|save
argument_list|,
name|CDCSYNC
argument_list|)
operator|==
name|true
condition|)
block|{
name|read_flaw_map
argument_list|()
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|read_map
argument_list|(
name|NRM
argument_list|)
operator|==
name|true
condition|)
block|{
return|return
operator|(
name|true
operator|)
return|;
block|}
else|else
block|{
name|get_smde_relocations
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|read_map
argument_list|(
name|WPT
argument_list|)
operator|==
name|true
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
block|{
name|get_relocations_the_hard_way
argument_list|()
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** */
end_comment

begin_macro
name|get_relocations_the_hard_way
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|cyl
decl_stmt|,
name|trk
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
name|dskadr
name|dskaddr
decl_stmt|;
name|dskaddr
operator|.
name|sector
operator|=
literal|0
expr_stmt|;
comment|/* scan each sector to see if it is relocated and take note if it is */
for|for
control|(
name|cyl
operator|=
literal|0
init|;
name|cyl
operator|<
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMSYS
condition|;
name|cyl
operator|++
control|)
block|{
name|dskaddr
operator|.
name|cylinder
operator|=
name|cyl
expr_stmt|;
for|for
control|(
name|trk
operator|=
literal|0
init|;
name|trk
operator|<
name|lab
operator|->
name|d_ntracks
condition|;
name|trk
operator|++
control|)
block|{
name|dskaddr
operator|.
name|track
operator|=
name|trk
expr_stmt|;
name|status
operator|=
name|access_dsk
argument_list|(
operator|(
name|char
operator|*
operator|)
name|scratch
argument_list|,
operator|&
name|dskaddr
argument_list|,
name|VDOP_RD
argument_list|,
name|lab
operator|->
name|d_nsectors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|DCBS_ATA
condition|)
name|get_track_relocations
argument_list|(
name|dskaddr
argument_list|)
expr_stmt|;
block|}
block|}
name|load_free_table
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|get_track_relocations
argument_list|(
argument|dskaddr
argument_list|)
end_macro

begin_decl_stmt
name|dskadr
name|dskaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|status
decl_stmt|;
name|bs_entry
name|temp
decl_stmt|;
name|fmt_err
name|error
decl_stmt|;
for|for
control|(
name|dskaddr
operator|.
name|sector
operator|=
literal|0
init|;
name|dskaddr
operator|.
name|sector
operator|<
name|lab
operator|->
name|d_nsectors
condition|;
name|dskaddr
operator|.
name|sector
operator|++
control|)
block|{
name|status
operator|=
name|access_dsk
argument_list|(
operator|(
name|char
operator|*
operator|)
name|scratch
argument_list|,
operator|&
name|dskaddr
argument_list|,
name|VDOP_RD
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|DCBS_ATA
condition|)
block|{
name|error
operator|.
name|err_adr
operator|=
name|dskaddr
expr_stmt|;
name|error
operator|.
name|err_stat
operator|=
name|DATA_ERROR
expr_stmt|;
call|(
modifier|*
name|C_INFO
operator|->
name|code_pos
call|)
argument_list|(
operator|&
name|error
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|.
name|bs_how
operator|=
name|operator
expr_stmt|;
name|add_flaw
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|remove_user_relocations
argument_list|(
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|bs_entry
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fmt_err
name|temp
decl_stmt|;
name|fmt_err
name|error
decl_stmt|;
specifier|register
name|bs_entry
modifier|*
name|ptr
decl_stmt|;
call|(
modifier|*
name|C_INFO
operator|->
name|decode_pos
call|)
argument_list|(
name|entry
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|bad_map
operator|->
name|list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bad_map
operator|->
name|bs_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|bs_cyl
operator|!=
name|entry
operator|->
name|bs_cyl
operator|||
name|ptr
operator|->
name|bs_trk
operator|!=
name|entry
operator|->
name|bs_trk
condition|)
continue|continue;
call|(
modifier|*
name|C_INFO
operator|->
name|decode_pos
call|)
argument_list|(
name|ptr
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|->
name|bs_how
operator|!=
name|flaw_map
operator|)
operator|&&
operator|(
name|temp
operator|.
name|err_adr
operator|.
name|cylinder
operator|==
name|error
operator|.
name|err_adr
operator|.
name|cylinder
operator|)
operator|&&
operator|(
name|temp
operator|.
name|err_adr
operator|.
name|track
operator|==
name|error
operator|.
name|err_adr
operator|.
name|track
operator|)
operator|&&
operator|(
name|temp
operator|.
name|err_adr
operator|.
name|sector
operator|==
name|error
operator|.
name|err_adr
operator|.
name|sector
operator|)
condition|)
block|{
if|if
condition|(
name|temp
operator|.
name|err_stat
operator|&
name|HEADER_ERROR
condition|)
name|remove_track
argument_list|(
operator|&
name|temp
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|else
name|remove_sector
argument_list|(
operator|&
name|temp
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|bad_map
operator|->
name|bs_count
condition|;
name|j
operator|++
control|)
name|bad_map
operator|->
name|list
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|bad_map
operator|->
name|list
index|[
name|j
index|]
expr_stmt|;
name|bad_map
operator|->
name|bs_count
operator|--
expr_stmt|;
return|return;
block|}
name|ptr
operator|++
expr_stmt|;
block|}
name|indent
argument_list|()
expr_stmt|;
name|print
argument_list|(
literal|"Sector %d is not in bad sector map!\n"
argument_list|,
name|to_sector
argument_list|(
name|error
operator|.
name|err_adr
argument_list|)
argument_list|)
expr_stmt|;
name|exdent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|clear_relocations
argument_list|(
argument|reformat
argument_list|)
end_macro

begin_decl_stmt
name|boolean
name|reformat
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fmt_err
name|temp
decl_stmt|;
specifier|register
name|bs_entry
modifier|*
name|ptr1
decl_stmt|,
modifier|*
name|ptr2
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|oldsub
init|=
name|cur
operator|.
name|substate
decl_stmt|;
name|cur
operator|.
name|substate
operator|=
name|sub_rel
expr_stmt|;
name|ptr1
operator|=
name|bad_map
operator|->
name|list
expr_stmt|;
name|ptr2
operator|=
name|bad_map
operator|->
name|list
expr_stmt|;
name|end
operator|=
operator|&
name|bad_map
operator|->
name|list
index|[
name|bad_map
operator|->
name|bs_count
index|]
expr_stmt|;
for|for
control|(
init|;
name|ptr1
operator|<
name|end
condition|;
name|ptr1
operator|++
control|)
block|{
if|if
condition|(
name|ptr1
operator|->
name|bs_how
operator|!=
name|flaw_map
condition|)
block|{
if|if
condition|(
name|reformat
operator|==
name|true
condition|)
block|{
call|(
modifier|*
name|C_INFO
operator|->
name|decode_pos
call|)
argument_list|(
name|ptr1
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|.
name|err_stat
operator|&
name|HEADER_ERROR
condition|)
name|remove_track
argument_list|(
operator|&
name|temp
argument_list|,
name|ptr1
argument_list|)
expr_stmt|;
else|else
name|remove_sector
argument_list|(
operator|&
name|temp
argument_list|,
name|ptr1
argument_list|)
expr_stmt|;
block|}
name|bad_map
operator|->
name|bs_count
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ptr1
operator|!=
name|ptr2
condition|)
operator|*
name|ptr2
operator|=
operator|*
name|ptr1
expr_stmt|;
name|ptr2
operator|++
expr_stmt|;
block|}
block|}
name|cur
operator|.
name|substate
operator|=
name|oldsub
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|remove_sector
argument_list|(
argument|error
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|fmt_err
modifier|*
name|error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bs_entry
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|format_sectors
argument_list|(
operator|&
name|error
operator|->
name|err_adr
argument_list|,
operator|&
name|error
operator|->
name|err_adr
argument_list|,
name|NRM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|format_sectors
argument_list|(
operator|&
name|entry
operator|->
name|bs_alt
argument_list|,
operator|&
name|entry
operator|->
name|bs_alt
argument_list|,
name|NRM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|remove_track
argument_list|(
argument|error
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|fmt_err
modifier|*
name|error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bs_entry
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|format_sectors
argument_list|(
operator|&
name|error
operator|->
name|err_adr
argument_list|,
operator|&
name|error
operator|->
name|err_adr
argument_list|,
name|NRM
argument_list|,
operator|(
name|long
operator|)
name|lab
operator|->
name|d_nsectors
argument_list|)
expr_stmt|;
name|format_sectors
argument_list|(
operator|&
name|entry
operator|->
name|bs_alt
argument_list|,
operator|&
name|entry
operator|->
name|bs_alt
argument_list|,
name|NRM
argument_list|,
operator|(
name|long
operator|)
name|lab
operator|->
name|d_nsectors
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|write_bad_sector_map
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|trk
decl_stmt|,
name|sec
decl_stmt|;
name|dskadr
name|dskaddr
decl_stmt|;
name|dskaddr
operator|.
name|cylinder
operator|=
operator|(
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMMAP
operator|)
expr_stmt|;
for|for
control|(
name|trk
operator|=
literal|0
init|;
name|trk
operator|<
name|lab
operator|->
name|d_ntracks
condition|;
name|trk
operator|++
control|)
block|{
for|for
control|(
name|sec
operator|=
literal|0
init|;
name|sec
operator|<
name|lab
operator|->
name|d_nsectors
condition|;
name|sec
operator|++
control|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bs_map_space
operator|+
operator|(
name|sec
operator|*
name|lab
operator|->
name|d_secsize
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|scratch
argument_list|,
name|lab
operator|->
name|d_secsize
argument_list|)
expr_stmt|;
name|dskaddr
operator|.
name|track
operator|=
name|trk
expr_stmt|;
name|dskaddr
operator|.
name|sector
operator|=
name|sec
expr_stmt|;
name|format_sectors
argument_list|(
operator|&
name|dskaddr
argument_list|,
operator|&
name|dskaddr
argument_list|,
name|WPT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|zero_bad_sector_map
argument_list|()
end_macro

begin_block
block|{
name|bs_map
modifier|*
name|bm
init|=
name|bad_map
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|dskadr
name|zero
decl_stmt|;
name|zero
operator|.
name|cylinder
operator|=
literal|0
expr_stmt|;
name|zero
operator|.
name|track
operator|=
literal|0
expr_stmt|;
name|zero
operator|.
name|sector
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bm
operator|->
name|bs_count
condition|;
name|i
operator|++
control|)
name|bm
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_alt
operator|=
name|zero
expr_stmt|;
name|load_free_table
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|read_flaw_map
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|cyl
decl_stmt|,
name|trk
decl_stmt|;
name|dskadr
name|dskaddr
decl_stmt|;
name|flaw
name|buffer
decl_stmt|;
name|dskaddr
operator|.
name|sector
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cyl
operator|=
literal|0
init|;
name|cyl
operator|<
name|lab
operator|->
name|d_ncylinders
condition|;
name|cyl
operator|++
control|)
block|{
name|dskaddr
operator|.
name|cylinder
operator|=
name|cyl
expr_stmt|;
for|for
control|(
name|trk
operator|=
literal|0
init|;
name|trk
operator|<
name|lab
operator|->
name|d_ntracks
condition|;
name|trk
operator|++
control|)
block|{
name|dskaddr
operator|.
name|track
operator|=
name|trk
expr_stmt|;
name|access_dsk
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|dskaddr
argument_list|,
name|VDOP_RDRAW
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_buf
argument_list|(
operator|&
name|buffer
argument_list|,
name|CDCSYNC
argument_list|)
operator|==
name|true
condition|)
block|{
name|add_flaw_entries
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|load_free_table
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|get_smde_relocations
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|cyl
decl_stmt|,
name|trk
decl_stmt|,
name|sec
decl_stmt|;
name|smde_hdr
name|buffer
decl_stmt|;
name|dskadr
name|dskaddr
decl_stmt|;
name|fmt_err
name|bad
decl_stmt|;
name|bs_entry
name|temp
decl_stmt|;
name|boolean
name|bad_track
decl_stmt|;
comment|/* Read any old drive relocations */
for|for
control|(
name|cyl
operator|=
literal|0
init|;
name|cyl
operator|<
name|NUMREL
condition|;
name|cyl
operator|++
control|)
block|{
name|dskaddr
operator|.
name|cylinder
operator|=
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMSYS
operator|+
name|cyl
expr_stmt|;
for|for
control|(
name|trk
operator|=
literal|0
init|;
name|trk
operator|<
name|lab
operator|->
name|d_ntracks
condition|;
name|trk
operator|++
control|)
block|{
name|dskaddr
operator|.
name|track
operator|=
name|trk
expr_stmt|;
name|bad_track
operator|=
name|true
expr_stmt|;
for|for
control|(
name|sec
operator|=
literal|0
init|;
name|sec
operator|<
name|lab
operator|->
name|d_nsectors
condition|;
name|sec
operator|++
control|)
block|{
name|dskaddr
operator|.
name|sector
operator|=
name|sec
expr_stmt|;
name|access_dsk
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|dskaddr
argument_list|,
name|VDOP_RDRAW
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_buf
argument_list|(
operator|&
name|buffer
argument_list|,
name|SMDE1SYNC
argument_list|)
operator|==
name|false
condition|)
block|{
name|bad_track
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bad_track
operator|==
name|true
condition|)
block|{
name|dskaddr
operator|.
name|sector
operator|=
literal|0
expr_stmt|;
name|bad
operator|.
name|err_adr
operator|.
name|cylinder
operator|=
name|buffer
operator|.
name|alt_cyl
expr_stmt|;
name|bad
operator|.
name|err_adr
operator|.
name|track
operator|=
name|buffer
operator|.
name|alt_trk
expr_stmt|;
name|bad
operator|.
name|err_adr
operator|.
name|sector
operator|=
literal|0
expr_stmt|;
name|bad
operator|.
name|err_stat
operator|=
name|HEADER_ERROR
expr_stmt|;
call|(
modifier|*
name|C_INFO
operator|->
name|code_pos
call|)
argument_list|(
operator|&
name|bad
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|.
name|bs_alt
operator|=
name|dskaddr
expr_stmt|;
name|temp
operator|.
name|bs_how
operator|=
name|scanning
expr_stmt|;
name|add_flaw
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|sec
operator|=
literal|0
init|;
name|sec
operator|<
name|lab
operator|->
name|d_nsectors
condition|;
name|sec
operator|++
control|)
block|{
name|dskaddr
operator|.
name|sector
operator|=
name|sec
expr_stmt|;
name|access_dsk
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|dskaddr
argument_list|,
name|VDOP_RDRAW
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_buf
argument_list|(
operator|&
name|buffer
argument_list|,
name|SMDE1SYNC
argument_list|)
operator|==
name|true
condition|)
block|{
name|bad
operator|.
name|err_adr
operator|.
name|cylinder
operator|=
name|buffer
operator|.
name|alt_cyl
expr_stmt|;
name|bad
operator|.
name|err_adr
operator|.
name|track
operator|=
name|buffer
operator|.
name|alt_trk
expr_stmt|;
name|bad
operator|.
name|err_adr
operator|.
name|sector
operator|=
name|buffer
operator|.
name|alt_sec
expr_stmt|;
name|bad
operator|.
name|err_stat
operator|=
name|DATA_ERROR
expr_stmt|;
call|(
modifier|*
name|C_INFO
operator|->
name|code_pos
call|)
argument_list|(
operator|&
name|bad
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|.
name|bs_alt
operator|=
name|dskaddr
expr_stmt|;
name|temp
operator|.
name|bs_how
operator|=
name|scanning
expr_stmt|;
name|add_flaw
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|load_free_table
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|add_flaw_entries
argument_list|(
argument|buffer
argument_list|)
end_macro

begin_decl_stmt
name|flaw
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|bs_entry
name|temp
decl_stmt|;
name|temp
operator|.
name|bs_cyl
operator|=
name|buffer
operator|->
name|flaw_cyl
operator|&
literal|0x7fff
expr_stmt|;
comment|/* clear off bad track bit */
name|temp
operator|.
name|bs_trk
operator|=
name|buffer
operator|->
name|flaw_trk
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buffer
operator|->
name|flaw_pos
index|[
name|i
index|]
operator|.
name|flaw_length
operator|!=
literal|0
condition|)
block|{
name|temp
operator|.
name|bs_offset
operator|=
name|buffer
operator|->
name|flaw_pos
index|[
name|i
index|]
operator|.
name|flaw_offset
expr_stmt|;
name|temp
operator|.
name|bs_length
operator|=
name|buffer
operator|->
name|flaw_pos
index|[
name|i
index|]
operator|.
name|flaw_length
expr_stmt|;
name|temp
operator|.
name|bs_alt
operator|.
name|cylinder
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|bs_alt
operator|.
name|track
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|bs_alt
operator|.
name|sector
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|bs_how
operator|=
name|flaw_map
expr_stmt|;
name|add_flaw
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|cmp_entry
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|bs_entry
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bs_entry
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|a
operator|->
name|bs_cyl
operator|==
name|b
operator|->
name|bs_cyl
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|bs_trk
operator|==
name|b
operator|->
name|bs_trk
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|bs_offset
operator|==
name|b
operator|->
name|bs_offset
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|bs_offset
operator|<
name|b
operator|->
name|bs_offset
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|bs_trk
operator|<
name|b
operator|->
name|bs_trk
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|bs_cyl
operator|<
name|b
operator|->
name|bs_cyl
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Add flaw to map.  * Return value:  *   1	OK  *   0	sector was in map  *  -1	failure  */
end_comment

begin_macro
name|add_flaw
argument_list|(
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|bs_entry
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|cmp_entry
parameter_list|()
function_decl|;
name|bs_map
modifier|*
name|bm
init|=
name|bad_map
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bm
operator|->
name|bs_count
operator|>
name|MAX_FLAWS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|entry
operator|->
name|bs_cyl
operator|>=
name|lab
operator|->
name|d_ncylinders
operator|||
name|entry
operator|->
name|bs_trk
operator|>=
name|lab
operator|->
name|d_ntracks
operator|||
name|entry
operator|->
name|bs_offset
operator|>=
name|lab
operator|->
name|d_traksize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bm
operator|->
name|bs_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|bm
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_cyl
operator|==
name|entry
operator|->
name|bs_cyl
operator|)
operator|)
operator|&&
operator|(
name|bm
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_trk
operator|==
name|entry
operator|->
name|bs_trk
operator|)
operator|&&
operator|(
name|bm
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_offset
operator|==
name|entry
operator|->
name|bs_offset
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|bm
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_how
operator|>
operator|(
name|int
operator|)
name|entry
operator|->
name|bs_how
condition|)
name|bm
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_how
operator|=
name|entry
operator|->
name|bs_how
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|bm
operator|->
name|list
index|[
name|i
index|]
operator|=
operator|*
name|entry
expr_stmt|;
name|bm
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_alt
operator|.
name|cylinder
operator|=
literal|0
expr_stmt|;
name|bm
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_alt
operator|.
name|track
operator|=
literal|0
expr_stmt|;
name|bm
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_alt
operator|.
name|sector
operator|=
literal|0
expr_stmt|;
name|bm
operator|->
name|bs_count
operator|++
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|bm
operator|->
name|list
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|unsigned
operator|)
name|bm
operator|->
name|bs_count
argument_list|,
sizeof|sizeof
argument_list|(
name|bs_entry
argument_list|)
argument_list|,
name|cmp_entry
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* **	Is_in_map checks to see if a block is known to be bad already. */
end_comment

begin_function
name|boolean
name|is_in_map
parameter_list|(
name|dskaddr
parameter_list|)
name|dskadr
modifier|*
name|dskaddr
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fmt_err
name|temp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bad_map
operator|->
name|bs_count
condition|;
name|i
operator|++
control|)
block|{
call|(
modifier|*
name|C_INFO
operator|->
name|decode_pos
call|)
argument_list|(
operator|&
name|bad_map
operator|->
name|list
index|[
name|i
index|]
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|.
name|err_adr
operator|.
name|cylinder
operator|==
name|dskaddr
operator|->
name|cylinder
operator|)
operator|&&
operator|(
name|temp
operator|.
name|err_adr
operator|.
name|track
operator|==
name|dskaddr
operator|->
name|track
operator|)
operator|&&
operator|(
name|temp
operator|.
name|err_adr
operator|.
name|sector
operator|==
name|dskaddr
operator|->
name|sector
operator|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* ** */
end_comment

begin_macro
name|print_bad_sector_list
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fmt_err
name|errloc
decl_stmt|;
specifier|register
name|bs_entry
modifier|*
name|bad
decl_stmt|;
if|if
condition|(
name|bad_map
operator|->
name|bs_count
operator|==
literal|0
condition|)
block|{
name|print
argument_list|(
literal|"There are no bad sectors in bad sector map.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|print
argument_list|(
literal|"The following sector%s known to be bad:\n"
argument_list|,
operator|(
name|bad_map
operator|->
name|bs_count
operator|==
literal|1
operator|)
condition|?
literal|" is"
else|:
literal|"s are"
argument_list|)
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bad
operator|=
name|bad_map
operator|->
name|list
init|;
name|i
operator|<
name|bad_map
operator|->
name|bs_count
condition|;
name|i
operator|++
operator|,
name|bad
operator|++
control|)
block|{
call|(
modifier|*
name|C_INFO
operator|->
name|decode_pos
call|)
argument_list|(
name|bad
argument_list|,
operator|&
name|errloc
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|"%s %d cn %d tn %d sn %d pos %d len %d "
argument_list|,
name|errloc
operator|.
name|err_stat
operator|&
name|HEADER_ERROR
condition|?
literal|"Track@"
else|:
literal|"Sector"
argument_list|,
name|to_sector
argument_list|(
name|errloc
operator|.
name|err_adr
argument_list|)
argument_list|,
name|bad
operator|->
name|bs_cyl
argument_list|,
name|bad
operator|->
name|bs_trk
argument_list|,
name|errloc
operator|.
name|err_adr
operator|.
name|sector
argument_list|,
name|bad
operator|->
name|bs_offset
argument_list|,
name|bad
operator|->
name|bs_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|->
name|bs_how
operator|==
name|flaw_map
condition|)
name|printf
argument_list|(
literal|"(flawmap) "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bad
operator|->
name|bs_how
operator|==
name|scanning
condition|)
name|printf
argument_list|(
literal|"(verify) "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(operator) "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bad
operator|->
name|bs_alt
operator|.
name|cylinder
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bad
operator|->
name|bs_alt
operator|.
name|track
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bad
operator|->
name|bs_alt
operator|.
name|sector
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"-> "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cn %d tn %d sn %d"
argument_list|,
name|bad
operator|->
name|bs_alt
operator|.
name|cylinder
argument_list|,
name|bad
operator|->
name|bs_alt
operator|.
name|track
argument_list|,
name|bad
operator|->
name|bs_alt
operator|.
name|sector
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|exdent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	load_free_table checks each block in the bad block relocation area ** to see if it is used. If it is, the free relocation block table is updated. */
end_comment

begin_macro
name|load_free_table
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fmt_err
name|temp
decl_stmt|;
comment|/* Clear free table before starting */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|lab
operator|->
name|d_ntracks
operator|*
name|NUMREL
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lab
operator|->
name|d_nsectors
condition|;
name|j
operator|++
control|)
name|free_tbl
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|free_status
operator|=
name|NOTALLOCATED
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bad_map
operator|->
name|bs_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|bad_map
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_alt
operator|.
name|cylinder
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bad_map
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_alt
operator|.
name|track
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bad_map
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_alt
operator|.
name|sector
operator|!=
literal|0
operator|)
condition|)
block|{
call|(
modifier|*
name|C_INFO
operator|->
name|decode_pos
call|)
argument_list|(
operator|&
name|bad_map
operator|->
name|list
index|[
name|i
index|]
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|allocate
argument_list|(
operator|&
operator|(
name|bad_map
operator|->
name|list
index|[
name|i
index|]
operator|.
name|bs_alt
operator|)
argument_list|,
name|temp
operator|.
name|err_stat
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* **	allocate marks a replacement sector as used. */
end_comment

begin_macro
name|allocate
argument_list|(
argument|dskaddr
argument_list|,
argument|status
argument_list|)
end_macro

begin_decl_stmt
name|dskadr
modifier|*
name|dskaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|status
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|trk
decl_stmt|,
name|sec
decl_stmt|;
name|trk
operator|=
name|dskaddr
operator|->
name|cylinder
operator|-
operator|(
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMSYS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|trk
operator|<
literal|0
operator|)
operator|||
operator|(
name|trk
operator|>=
name|NUMREL
operator|)
condition|)
return|return;
name|trk
operator|*=
name|lab
operator|->
name|d_ntracks
expr_stmt|;
name|trk
operator|+=
name|dskaddr
operator|->
name|track
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|HEADER_ERROR
condition|)
for|for
control|(
name|sec
operator|=
literal|0
init|;
name|sec
operator|<
name|lab
operator|->
name|d_nsectors
condition|;
name|sec
operator|++
control|)
name|free_tbl
index|[
name|trk
index|]
index|[
name|sec
index|]
operator|.
name|free_status
operator|=
name|ALLOCATED
expr_stmt|;
else|else
name|free_tbl
index|[
name|trk
index|]
index|[
name|dskaddr
operator|->
name|sector
index|]
operator|.
name|free_status
operator|=
name|ALLOCATED
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_function
name|boolean
name|mapping_collision
parameter_list|(
name|entry
parameter_list|)
name|bs_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|int
name|trk
decl_stmt|,
name|sec
decl_stmt|;
name|fmt_err
name|temp
decl_stmt|;
name|trk
operator|=
name|entry
operator|->
name|bs_cyl
operator|-
operator|(
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMSYS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|trk
operator|<
literal|0
operator|)
operator|||
operator|(
name|trk
operator|>=
name|NUMREL
operator|)
condition|)
return|return
name|false
return|;
name|trk
operator|*=
name|lab
operator|->
name|d_ntracks
expr_stmt|;
name|trk
operator|+=
name|entry
operator|->
name|bs_trk
expr_stmt|;
call|(
modifier|*
name|C_INFO
operator|->
name|decode_pos
call|)
argument_list|(
name|entry
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
comment|/* if this relocation should take up the whole track */
if|if
condition|(
name|temp
operator|.
name|err_stat
operator|&
name|HEADER_ERROR
condition|)
block|{
for|for
control|(
name|sec
operator|=
literal|0
init|;
name|sec
operator|<
name|lab
operator|->
name|d_nsectors
condition|;
name|sec
operator|++
control|)
if|if
condition|(
name|free_tbl
index|[
name|trk
index|]
index|[
name|sec
index|]
operator|.
name|free_status
operator|==
name|ALLOCATED
condition|)
return|return
name|true
return|;
block|}
comment|/* else just check the current sector */
else|else
block|{
if|if
condition|(
name|free_tbl
index|[
name|trk
index|]
index|[
name|temp
operator|.
name|err_adr
operator|.
name|sector
index|]
operator|.
name|free_status
operator|==
name|ALLOCATED
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* ** */
end_comment

begin_macro
name|report_collision
argument_list|()
end_macro

begin_block
block|{
name|indent
argument_list|()
expr_stmt|;
name|print
argument_list|(
literal|"Sector resides in relocation area"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"but it has a sector mapped to it already.\n"
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|"Please reformat disk with 0 patterns to eliminate problem.\n"
argument_list|)
expr_stmt|;
name|exdent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|add_user_relocations
argument_list|(
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|bs_entry
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fmt_err
name|error
decl_stmt|;
call|(
modifier|*
name|C_INFO
operator|->
name|decode_pos
call|)
argument_list|(
name|entry
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_in_map
argument_list|(
operator|&
name|error
operator|.
name|err_adr
argument_list|)
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|mapping_collision
argument_list|(
name|entry
argument_list|)
operator|==
name|true
condition|)
name|report_collision
argument_list|()
expr_stmt|;
name|entry
operator|->
name|bs_how
operator|=
name|operator
expr_stmt|;
name|add_flaw
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent
argument_list|()
expr_stmt|;
name|print
argument_list|(
literal|"Sector %d is already mapped out!\n"
argument_list|,
name|to_sector
argument_list|(
name|error
operator|.
name|err_adr
argument_list|)
argument_list|)
expr_stmt|;
name|exdent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ** 	New_location allocates a replacement block given a bad block address. **  The algorithm is fairly simple; it simply searches for the first **  free sector that has the same sector number of the bad sector.  If no sector **  is found then the drive should be considered bad because of a microcode bug **  in the controller that forces us to use the same sector number as the bad **  sector for relocation purposes.  Using different tracks and cylinders is ok **  of course. */
end_comment

begin_function
name|dskadr
modifier|*
name|new_location
parameter_list|(
name|entry
parameter_list|)
name|bs_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|sec
decl_stmt|;
specifier|static
name|fmt_err
name|temp
decl_stmt|;
specifier|static
name|dskadr
name|newaddr
decl_stmt|;
name|newaddr
operator|.
name|cylinder
operator|=
literal|0
expr_stmt|;
name|newaddr
operator|.
name|track
operator|=
literal|0
expr_stmt|;
name|newaddr
operator|.
name|sector
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|C_INFO
operator|->
name|decode_pos
call|)
argument_list|(
name|entry
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
comment|/* If it is ouside of the user's data area */
if|if
condition|(
name|entry
operator|->
name|bs_cyl
operator|>=
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMSYS
condition|)
block|{
comment|/* if it is in the relocation area */
if|if
condition|(
name|entry
operator|->
name|bs_cyl
operator|<
operator|(
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMMAP
operator|-
name|NUMMNT
operator|)
condition|)
block|{
comment|/* mark space as allocated */
name|allocate
argument_list|(
operator|&
name|temp
operator|.
name|err_adr
argument_list|,
name|temp
operator|.
name|err_stat
argument_list|)
expr_stmt|;
return|return
operator|&
name|temp
operator|.
name|err_adr
return|;
block|}
comment|/* if it is in the map area forget about it */
if|if
condition|(
name|entry
operator|->
name|bs_cyl
operator|!=
operator|(
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMMAP
operator|-
name|NUMMNT
operator|)
condition|)
return|return
operator|&
name|temp
operator|.
name|err_adr
return|;
comment|/* otherwise treat maintainence cylinder normally */
block|}
if|if
condition|(
name|temp
operator|.
name|err_stat
operator|&
operator|(
name|HEADER_ERROR
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|lab
operator|->
name|d_ntracks
operator|*
name|NUMREL
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|sec
operator|=
literal|0
init|;
name|sec
operator|<
name|lab
operator|->
name|d_nsectors
condition|;
name|sec
operator|++
control|)
block|{
if|if
condition|(
name|free_tbl
index|[
name|i
index|]
index|[
name|sec
index|]
operator|.
name|free_status
operator|==
name|ALLOCATED
condition|)
break|break;
block|}
if|if
condition|(
name|sec
operator|==
name|lab
operator|->
name|d_nsectors
condition|)
block|{
for|for
control|(
name|sec
operator|=
literal|0
init|;
name|sec
operator|<
name|lab
operator|->
name|d_nsectors
condition|;
name|sec
operator|++
control|)
name|free_tbl
index|[
name|i
index|]
index|[
name|sec
index|]
operator|.
name|free_status
operator|=
name|ALLOCATED
expr_stmt|;
name|newaddr
operator|.
name|cylinder
operator|=
name|i
operator|/
name|lab
operator|->
name|d_ntracks
operator|+
operator|(
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMSYS
operator|)
expr_stmt|;
name|newaddr
operator|.
name|track
operator|=
name|i
operator|%
name|lab
operator|->
name|d_ntracks
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|C_INFO
operator|->
name|type
operator|==
name|VDTYPE_VDDC
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|lab
operator|->
name|d_ntracks
operator|*
name|NUMREL
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|free_tbl
index|[
name|i
index|]
index|[
name|temp
operator|.
name|err_adr
operator|.
name|sector
index|]
operator|.
name|free_status
operator|!=
name|ALLOCATED
condition|)
block|{
name|free_tbl
index|[
name|i
index|]
index|[
name|temp
operator|.
name|err_adr
operator|.
name|sector
index|]
operator|.
name|free_status
operator|=
name|ALLOCATED
expr_stmt|;
name|newaddr
operator|.
name|cylinder
operator|=
name|i
operator|/
name|lab
operator|->
name|d_ntracks
operator|+
operator|(
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMSYS
operator|)
expr_stmt|;
name|newaddr
operator|.
name|track
operator|=
name|i
operator|%
name|lab
operator|->
name|d_ntracks
expr_stmt|;
name|newaddr
operator|.
name|sector
operator|=
name|temp
operator|.
name|err_adr
operator|.
name|sector
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|lab
operator|->
name|d_ntracks
operator|*
name|NUMREL
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|sec
operator|=
literal|0
init|;
name|sec
operator|<
name|lab
operator|->
name|d_nsectors
condition|;
name|sec
operator|++
control|)
if|if
condition|(
name|free_tbl
index|[
name|i
index|]
index|[
name|sec
index|]
operator|.
name|free_status
operator|!=
name|ALLOCATED
condition|)
break|break;
if|if
condition|(
name|sec
operator|<
name|lab
operator|->
name|d_nsectors
condition|)
block|{
name|free_tbl
index|[
name|i
index|]
index|[
name|sec
index|]
operator|.
name|free_status
operator|=
name|ALLOCATED
expr_stmt|;
name|newaddr
operator|.
name|cylinder
operator|=
name|i
operator|/
name|lab
operator|->
name|d_ntracks
operator|+
operator|(
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMSYS
operator|)
expr_stmt|;
name|newaddr
operator|.
name|track
operator|=
name|i
operator|%
name|lab
operator|->
name|d_ntracks
expr_stmt|;
name|newaddr
operator|.
name|sector
operator|=
name|sec
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|&
name|newaddr
return|;
block|}
end_function

end_unit

