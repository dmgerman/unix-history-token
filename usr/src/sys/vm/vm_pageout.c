begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * The Mach Operating System project at Carnegie-Mellon University.  *  * %sccs.include.redist.c%  *  *	@(#)vm_pageout.c	7.11 (Berkeley) %G%  *  *  * Copyright (c) 1987, 1990 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Avadis Tevanian, Jr., Michael Wayne Young  *   * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND   * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  *	The proverbial page-out daemon.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_decl_stmt
name|int
name|vm_pages_needed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Event on which pageout daemon sleeps */
end_comment

begin_decl_stmt
name|int
name|vm_page_free_min_sanity
init|=
literal|40
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vm_page_max_wired
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX max # of wired pages system-wide */
end_comment

begin_comment
comment|/*  *	vm_pageout_scan does the dirty work for the pageout daemon.  */
end_comment

begin_function
name|void
name|vm_pageout_scan
parameter_list|()
block|{
specifier|register
name|vm_page_t
name|m
decl_stmt|;
specifier|register
name|int
name|page_shortage
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|int
name|pages_freed
decl_stmt|;
name|int
name|free
decl_stmt|;
comment|/* 	 *	Only continue when we want more pages to be "free" 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|free
operator|=
name|cnt
operator|.
name|v_free_count
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
operator|<
name|cnt
operator|.
name|v_free_target
condition|)
block|{
name|swapout_threads
argument_list|()
expr_stmt|;
comment|/* 		 *	Be sure the pmap system is updated so 		 *	we can scan the inactive queue. 		 */
name|pmap_update
argument_list|()
expr_stmt|;
block|}
comment|/* 	 *	Acquire the resident page system lock, 	 *	as we may be changing what's resident quite a bit. 	 */
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
comment|/* 	 *	Start scanning the inactive queue for pages we can free. 	 *	We keep scanning until we have enough free pages or 	 *	we have scanned through the entire queue.  If we 	 *	encounter dirty pages, we start cleaning them. 	 */
name|pages_freed
operator|=
literal|0
expr_stmt|;
name|m
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_first
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|queue_end
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|,
operator|(
name|queue_entry_t
operator|)
name|m
argument_list|)
condition|)
block|{
name|vm_page_t
name|next
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_pager_t
name|pager
decl_stmt|;
name|int
name|pageout_status
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|free
operator|=
name|cnt
operator|.
name|v_free_count
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
operator|>=
name|cnt
operator|.
name|v_free_target
condition|)
break|break;
comment|/* 		 * If the page has been referenced, move it back to the 		 * active queue. 		 */
if|if
condition|(
name|pmap_is_referenced
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|next
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_next
argument_list|(
operator|&
name|m
operator|->
name|pageq
argument_list|)
expr_stmt|;
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_reactivated
operator|++
expr_stmt|;
name|m
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If the page is clean, free it up. 		 */
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_CLEAN
condition|)
block|{
name|next
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_next
argument_list|(
operator|&
name|m
operator|->
name|pageq
argument_list|)
expr_stmt|;
name|object
operator|=
name|m
operator|->
name|object
expr_stmt|;
if|if
condition|(
name|vm_object_lock_try
argument_list|(
name|object
argument_list|)
condition|)
block|{
name|pmap_page_protect
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pages_freed
operator|++
expr_stmt|;
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If the page is dirty but already being washed, skip it. 		 */
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_LAUNDRY
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_next
argument_list|(
operator|&
name|m
operator|->
name|pageq
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Otherwise the page is dirty and still in the laundry, 		 * so we start the cleaning operation and remove it from 		 * the laundry. 		 * 		 * We set the busy bit to cause potential page faults on 		 * this page to block. 		 * 		 * We also set pageout-in-progress to keep the object from 		 * disappearing during pageout.  This guarantees that the 		 * page won't move from the inactive queue.  (However, any 		 * other page on the inactive queue may move!) 		 */
name|object
operator|=
name|m
operator|->
name|object
expr_stmt|;
if|if
condition|(
operator|!
name|vm_object_lock_try
argument_list|(
name|object
argument_list|)
condition|)
block|{
name|m
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_next
argument_list|(
operator|&
name|m
operator|->
name|pageq
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pmap_page_protect
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_BUSY
expr_stmt|;
name|cnt
operator|.
name|v_pageouts
operator|++
expr_stmt|;
comment|/* 		 * Try to collapse the object before making a pager for it. 		 * We must unlock the page queues first. 		 */
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|vm_object_collapse
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|->
name|paging_in_progress
operator|++
expr_stmt|;
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 		 * Do a wakeup here in case the following operations block. 		 */
name|thread_wakeup
argument_list|(
operator|(
name|int
operator|)
operator|&
name|cnt
operator|.
name|v_free_count
argument_list|)
expr_stmt|;
comment|/* 		 * If there is no pager for the page, use the default pager. 		 * If there is no place to put the page at the moment, 		 * leave it in the laundry and hope that there will be 		 * paging space later. 		 */
if|if
condition|(
operator|(
name|pager
operator|=
name|object
operator|->
name|pager
operator|)
operator|==
name|NULL
condition|)
block|{
name|pager
operator|=
name|vm_pager_allocate
argument_list|(
name|PG_DFLT
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|object
operator|->
name|size
argument_list|,
name|VM_PROT_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|!=
name|NULL
condition|)
name|vm_object_setpager
argument_list|(
name|object
argument_list|,
name|pager
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|pageout_status
operator|=
name|pager
condition|?
name|vm_pager_put
argument_list|(
name|pager
argument_list|,
name|m
argument_list|,
name|FALSE
argument_list|)
else|:
name|VM_PAGER_FAIL
expr_stmt|;
name|vm_object_lock
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|next
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_next
argument_list|(
operator|&
name|m
operator|->
name|pageq
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pageout_status
condition|)
block|{
case|case
name|VM_PAGER_OK
case|:
case|case
name|VM_PAGER_PEND
case|:
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_LAUNDRY
expr_stmt|;
break|break;
case|case
name|VM_PAGER_BAD
case|:
comment|/* 			 * Page outside of range of object.  Right now we 			 * essentially lose the changes by pretending it 			 * worked. 			 * 			 * XXX dubious, what should we do? 			 */
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_LAUNDRY
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_CLEAN
expr_stmt|;
name|pmap_clear_modify
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_PAGER_FAIL
case|:
case|case
name|VM_PAGER_ERROR
case|:
comment|/* 			 * If page couldn't be paged out, then reactivate 			 * the page so it doesn't clog the inactive list. 			 * (We will try paging out it again later). 			 */
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|pmap_clear_reference
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If the operation is still going, leave the page busy 		 * to block all other accesses.  Also, leave the paging 		 * in progress indicator set so that we don't attempt an 		 * object collapse. 		 */
if|if
condition|(
name|pageout_status
operator|!=
name|VM_PAGER_PEND
condition|)
block|{
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_BUSY
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|object
operator|->
name|paging_in_progress
operator|--
expr_stmt|;
block|}
name|thread_wakeup
argument_list|(
operator|(
name|int
operator|)
name|object
argument_list|)
expr_stmt|;
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|m
operator|=
name|next
expr_stmt|;
block|}
comment|/* 	 *	Compute the page shortage.  If we are still very low on memory 	 *	be sure that we will move a minimal amount of pages from active 	 *	to inactive. 	 */
name|page_shortage
operator|=
name|cnt
operator|.
name|v_inactive_target
operator|-
name|cnt
operator|.
name|v_inactive_count
expr_stmt|;
if|if
condition|(
name|page_shortage
operator|<=
literal|0
operator|&&
name|pages_freed
operator|==
literal|0
condition|)
name|page_shortage
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|page_shortage
operator|>
literal|0
condition|)
block|{
comment|/* 		 *	Move some more pages from active to inactive. 		 */
if|if
condition|(
name|queue_empty
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|)
condition|)
block|{
break|break;
block|}
name|m
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_first
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|)
expr_stmt|;
name|vm_page_deactivate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|page_shortage
operator|--
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_pageout is the high level pageout daemon.  */
end_comment

begin_function
name|void
name|vm_pageout
parameter_list|()
block|{
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
comment|/* 	 *	Initialize some paging parameters. 	 */
if|if
condition|(
name|cnt
operator|.
name|v_free_min
operator|==
literal|0
condition|)
block|{
name|cnt
operator|.
name|v_free_min
operator|=
name|cnt
operator|.
name|v_free_count
operator|/
literal|20
expr_stmt|;
if|if
condition|(
name|cnt
operator|.
name|v_free_min
operator|<
literal|3
condition|)
name|cnt
operator|.
name|v_free_min
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|cnt
operator|.
name|v_free_min
operator|>
name|vm_page_free_min_sanity
condition|)
name|cnt
operator|.
name|v_free_min
operator|=
name|vm_page_free_min_sanity
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|.
name|v_free_target
operator|==
literal|0
condition|)
name|cnt
operator|.
name|v_free_target
operator|=
operator|(
name|cnt
operator|.
name|v_free_min
operator|*
literal|4
operator|)
operator|/
literal|3
expr_stmt|;
if|if
condition|(
name|cnt
operator|.
name|v_free_target
operator|<=
name|cnt
operator|.
name|v_free_min
condition|)
name|cnt
operator|.
name|v_free_target
operator|=
name|cnt
operator|.
name|v_free_min
operator|+
literal|1
expr_stmt|;
comment|/* XXX does not really belong here */
if|if
condition|(
name|vm_page_max_wired
operator|==
literal|0
condition|)
name|vm_page_max_wired
operator|=
name|cnt
operator|.
name|v_free_count
operator|/
literal|3
expr_stmt|;
comment|/* 	 *	The pageout daemon is never done, so loop 	 *	forever. 	 */
name|simple_lock
argument_list|(
operator|&
name|vm_pages_needed_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|thread_sleep
argument_list|(
operator|(
name|int
operator|)
operator|&
name|vm_pages_needed
argument_list|,
operator|&
name|vm_pages_needed_lock
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 		 * Compute the inactive target for this scan. 		 * We need to keep a reasonable amount of memory in the 		 * inactive list to better simulate LRU behavior. 		 */
name|cnt
operator|.
name|v_inactive_target
operator|=
operator|(
name|cnt
operator|.
name|v_active_count
operator|+
name|cnt
operator|.
name|v_inactive_count
operator|)
operator|/
literal|3
expr_stmt|;
if|if
condition|(
name|cnt
operator|.
name|v_inactive_target
operator|<=
name|cnt
operator|.
name|v_free_target
condition|)
name|cnt
operator|.
name|v_inactive_target
operator|=
name|cnt
operator|.
name|v_free_target
operator|+
literal|1
expr_stmt|;
name|vm_pageout_scan
argument_list|()
expr_stmt|;
name|vm_pager_sync
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|vm_pages_needed_lock
argument_list|)
expr_stmt|;
name|thread_wakeup
argument_list|(
operator|(
name|int
operator|)
operator|&
name|cnt
operator|.
name|v_free_count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

