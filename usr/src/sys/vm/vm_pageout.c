begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 1985, Avadis Tevanian, Jr., Michael Wayne Young  * Copyright (c) 1987 Carnegie-Mellon University  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * The Mach Operating System project at Carnegie-Mellon University.  *  * The CMU software License Agreement specifies the terms and conditions  * for use and redistribution.  *  *	@(#)vm_pageout.c	7.1 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  *	The proverbial page-out daemon.  */
end_comment

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"../vm/vm_page.h"
end_include

begin_include
include|#
directive|include
file|"../vm/pmap.h"
end_include

begin_include
include|#
directive|include
file|"../vm/vm_object.h"
end_include

begin_include
include|#
directive|include
file|"../vm/vm_pageout.h"
end_include

begin_include
include|#
directive|include
file|"../vm/vm_statistics.h"
end_include

begin_include
include|#
directive|include
file|"../vm/vm_param.h"
end_include

begin_decl_stmt
name|int
name|vm_pages_needed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Event on which pageout daemon sleeps */
end_comment

begin_decl_stmt
name|int
name|vm_pageout_free_min
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stop pageout to wait for pagers at this free level */
end_comment

begin_decl_stmt
name|int
name|vm_page_free_min_sanity
init|=
literal|40
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	vm_pageout_scan does the dirty work for the pageout daemon.  */
end_comment

begin_macro
name|vm_pageout_scan
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|vm_page_t
name|m
decl_stmt|;
specifier|register
name|int
name|page_shortage
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|int
name|pages_freed
decl_stmt|;
name|int
name|free
decl_stmt|;
comment|/* 	 *	Only continue when we want more pages to be "free" 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|free
operator|=
name|vm_page_free_count
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
operator|<
name|vm_page_free_target
condition|)
block|{
name|swapout_threads
argument_list|()
expr_stmt|;
comment|/* 		 *	Be sure the pmap system is updated so 		 *	we can scan the inactive queue. 		 */
name|pmap_update
argument_list|()
expr_stmt|;
block|}
comment|/* 	 *	Acquire the resident page system lock, 	 *	as we may be changing what's resident quite a bit. 	 */
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
comment|/* 	 *	Start scanning the inactive queue for pages we can free. 	 *	We keep scanning until we have enough free pages or 	 *	we have scanned through the entire queue.  If we 	 *	encounter dirty pages, we start cleaning them. 	 */
name|pages_freed
operator|=
literal|0
expr_stmt|;
name|m
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_first
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|queue_end
argument_list|(
operator|&
name|vm_page_queue_inactive
argument_list|,
operator|(
name|queue_entry_t
operator|)
name|m
argument_list|)
condition|)
block|{
name|vm_page_t
name|next
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|free
operator|=
name|vm_page_free_count
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|vm_page_queue_free_lock
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
operator|>=
name|vm_page_free_target
condition|)
break|break;
if|if
condition|(
name|m
operator|->
name|clean
condition|)
block|{
name|next
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_next
argument_list|(
operator|&
name|m
operator|->
name|pageq
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_is_referenced
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_stat
operator|.
name|reactivations
operator|++
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|vm_object_t
name|object
decl_stmt|;
name|object
operator|=
name|m
operator|->
name|object
expr_stmt|;
if|if
condition|(
operator|!
name|vm_object_lock_try
argument_list|(
name|object
argument_list|)
condition|)
block|{
comment|/* 					 *	Can't lock object - 					 *	skip page. 					 */
name|m
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
name|pmap_remove_all
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* will dequeue */
name|pages_freed
operator|++
expr_stmt|;
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 *	If a page is dirty, then it is either 			 *	being washed (but not yet cleaned) 			 *	or it is still in the laundry.  If it is 			 *	still in the laundry, then we start the 			 *	cleaning operation. 			 */
if|if
condition|(
name|m
operator|->
name|laundry
condition|)
block|{
comment|/* 				 *	Clean the page and remove it from the 				 *	laundry. 				 * 				 *	We set the busy bit to cause 				 *	potential page faults on this page to 				 *	block. 				 * 				 *	And we set pageout-in-progress to keep 				 *	the object from disappearing during 				 *	pageout.  This guarantees that the 				 *	page won't move from the inactive 				 *	queue.  (However, any other page on 				 *	the inactive queue may move!) 				 */
specifier|register
name|vm_object_t
name|object
decl_stmt|;
specifier|register
name|vm_pager_t
name|pager
decl_stmt|;
name|int
name|pageout_status
decl_stmt|;
name|object
operator|=
name|m
operator|->
name|object
expr_stmt|;
if|if
condition|(
operator|!
name|vm_object_lock_try
argument_list|(
name|object
argument_list|)
condition|)
block|{
comment|/* 					 *	Skip page if we can't lock 					 *	its object 					 */
name|m
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_next
argument_list|(
operator|&
name|m
operator|->
name|pageq
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pmap_remove_all
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|busy
operator|=
name|TRUE
expr_stmt|;
name|vm_stat
operator|.
name|pageouts
operator|++
expr_stmt|;
comment|/* 				 *	Try to collapse the object before 				 *	making a pager for it.  We must 				 *	unlock the page queues first. 				 */
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|vm_object_collapse
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|->
name|paging_in_progress
operator|++
expr_stmt|;
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 				 *	Do a wakeup here in case the following 				 *	operations block. 				 */
name|thread_wakeup
argument_list|(
operator|(
name|int
operator|)
operator|&
name|vm_page_free_count
argument_list|)
expr_stmt|;
comment|/* 				 *	If there is no pager for the page, 				 *	use the default pager.  If there's 				 *	no place to put the page at the 				 *	moment, leave it in the laundry and 				 *	hope that there will be paging space 				 *	later. 				 */
if|if
condition|(
operator|(
name|pager
operator|=
name|object
operator|->
name|pager
operator|)
operator|==
name|vm_pager_null
condition|)
block|{
name|pager
operator|=
name|vm_pager_allocate
argument_list|(
name|PG_DFLT
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|object
operator|->
name|size
argument_list|,
name|VM_PROT_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|!=
name|vm_pager_null
condition|)
block|{
name|vm_object_setpager
argument_list|(
name|object
argument_list|,
name|pager
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|pageout_status
operator|=
name|pager
condition|?
name|vm_pager_put
argument_list|(
name|pager
argument_list|,
name|m
argument_list|,
name|FALSE
argument_list|)
else|:
name|VM_PAGER_FAIL
expr_stmt|;
name|vm_object_lock
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|next
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_next
argument_list|(
operator|&
name|m
operator|->
name|pageq
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pageout_status
condition|)
block|{
case|case
name|VM_PAGER_OK
case|:
case|case
name|VM_PAGER_PEND
case|:
name|m
operator|->
name|laundry
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|VM_PAGER_BAD
case|:
comment|/* 					 * Page outside of range of object. 					 * Right now we essentially lose the 					 * changes by pretending it worked. 					 * XXX dubious, what should we do? 					 */
name|m
operator|->
name|laundry
operator|=
name|FALSE
expr_stmt|;
name|m
operator|->
name|clean
operator|=
name|TRUE
expr_stmt|;
name|pmap_clear_modify
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_PAGER_FAIL
case|:
comment|/* 					 * If page couldn't be paged out, then 					 * reactivate the page so it doesn't 					 * clog the inactive list.  (We will 					 * try paging out it again later). 					 */
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|pmap_clear_reference
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|busy
operator|=
name|FALSE
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 				 * If the operation is still going, leave the 				 * paging in progress indicator set so that we 				 * don't attempt an object collapse. 				 */
if|if
condition|(
name|pageout_status
operator|!=
name|VM_PAGER_PEND
condition|)
name|object
operator|->
name|paging_in_progress
operator|--
expr_stmt|;
name|thread_wakeup
argument_list|(
operator|(
name|int
operator|)
name|object
argument_list|)
expr_stmt|;
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|m
operator|=
name|next
expr_stmt|;
block|}
else|else
name|m
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_next
argument_list|(
operator|&
name|m
operator|->
name|pageq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 *	Compute the page shortage.  If we are still very low on memory 	 *	be sure that we will move a minimal amount of pages from active 	 *	to inactive. 	 */
name|page_shortage
operator|=
name|vm_page_inactive_target
operator|-
name|vm_page_inactive_count
expr_stmt|;
name|page_shortage
operator|-=
name|vm_page_free_count
expr_stmt|;
if|if
condition|(
operator|(
name|page_shortage
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|pages_freed
operator|==
literal|0
operator|)
condition|)
name|page_shortage
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|page_shortage
operator|>
literal|0
condition|)
block|{
comment|/* 		 *	Move some more pages from active to inactive. 		 */
if|if
condition|(
name|queue_empty
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|)
condition|)
block|{
break|break;
block|}
name|m
operator|=
operator|(
name|vm_page_t
operator|)
name|queue_first
argument_list|(
operator|&
name|vm_page_queue_active
argument_list|)
expr_stmt|;
name|vm_page_deactivate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|page_shortage
operator|--
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	vm_pageout is the high level pageout daemon.  */
end_comment

begin_function
name|void
name|vm_pageout
parameter_list|()
block|{
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
comment|/* 	 *	Initialize some paging parameters. 	 */
if|if
condition|(
name|vm_page_free_min
operator|==
literal|0
condition|)
block|{
name|vm_page_free_min
operator|=
name|vm_page_free_count
operator|/
literal|20
expr_stmt|;
if|if
condition|(
name|vm_page_free_min
operator|<
literal|3
condition|)
name|vm_page_free_min
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|vm_page_free_min
operator|>
name|vm_page_free_min_sanity
condition|)
name|vm_page_free_min
operator|=
name|vm_page_free_min_sanity
expr_stmt|;
block|}
if|if
condition|(
name|vm_page_free_reserved
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|vm_page_free_reserved
operator|=
name|vm_page_free_min
operator|/
literal|2
operator|)
operator|<
literal|10
condition|)
name|vm_page_free_reserved
operator|=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|vm_pageout_free_min
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|vm_pageout_free_min
operator|=
name|vm_page_free_reserved
operator|/
literal|2
operator|)
operator|>
literal|10
condition|)
name|vm_pageout_free_min
operator|=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|vm_page_free_target
operator|==
literal|0
condition|)
name|vm_page_free_target
operator|=
operator|(
name|vm_page_free_min
operator|*
literal|4
operator|)
operator|/
literal|3
expr_stmt|;
if|if
condition|(
name|vm_page_inactive_target
operator|==
literal|0
condition|)
name|vm_page_inactive_target
operator|=
name|vm_page_free_min
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|vm_page_free_target
operator|<=
name|vm_page_free_min
condition|)
name|vm_page_free_target
operator|=
name|vm_page_free_min
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|vm_page_inactive_target
operator|<=
name|vm_page_free_target
condition|)
name|vm_page_inactive_target
operator|=
name|vm_page_free_target
operator|+
literal|1
expr_stmt|;
comment|/* 	 *	The pageout daemon is never done, so loop 	 *	forever. 	 */
name|simple_lock
argument_list|(
operator|&
name|vm_pages_needed_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|thread_sleep
argument_list|(
operator|(
name|int
operator|)
operator|&
name|vm_pages_needed
argument_list|,
operator|&
name|vm_pages_needed_lock
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|vm_pageout_scan
argument_list|()
expr_stmt|;
name|vm_pager_sync
argument_list|()
expr_stmt|;
name|simple_lock
argument_list|(
operator|&
name|vm_pages_needed_lock
argument_list|)
expr_stmt|;
name|thread_wakeup
argument_list|(
operator|(
name|int
operator|)
operator|&
name|vm_page_free_count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

