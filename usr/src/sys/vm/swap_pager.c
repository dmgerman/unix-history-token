begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990 University of Utah.  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: swap_pager.c 1.4 91/04/30$  *  *	@(#)swap_pager.c	8.7 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Quick hack to page to dedicated partition(s).  * TODO:  *	Add multiprocessor locks  *	Deal with async writes in a better fashion  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/map.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/swap_pager.h>
end_include

begin_define
define|#
directive|define
name|NSWSIZES
value|16
end_define

begin_comment
comment|/* size of swtab */
end_comment

begin_define
define|#
directive|define
name|MAXDADDRS
value|64
end_define

begin_comment
comment|/* max # of disk addrs for fixed allocations */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NPENDINGIO
end_ifndef

begin_define
define|#
directive|define
name|NPENDINGIO
value|64
end_define

begin_comment
comment|/* max # of pending cleans */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|swpagerdebug
init|=
literal|0x100
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SDB_FOLLOW
value|0x001
end_define

begin_define
define|#
directive|define
name|SDB_INIT
value|0x002
end_define

begin_define
define|#
directive|define
name|SDB_ALLOC
value|0x004
end_define

begin_define
define|#
directive|define
name|SDB_IO
value|0x008
end_define

begin_define
define|#
directive|define
name|SDB_WRITE
value|0x010
end_define

begin_define
define|#
directive|define
name|SDB_FAIL
value|0x020
end_define

begin_define
define|#
directive|define
name|SDB_ALLOCBLK
value|0x040
end_define

begin_define
define|#
directive|define
name|SDB_FULL
value|0x080
end_define

begin_define
define|#
directive|define
name|SDB_ANOM
value|0x100
end_define

begin_define
define|#
directive|define
name|SDB_ANOMPANIC
value|0x200
end_define

begin_define
define|#
directive|define
name|SDB_CLUSTER
value|0x400
end_define

begin_define
define|#
directive|define
name|SDB_PARANOIA
value|0x800
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|swpclean
argument_list|,
name|swpagerclean
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|swpagerclean
block|{
name|TAILQ_ENTRY
argument_list|(
argument|swpagerclean
argument_list|)
name|spc_list
expr_stmt|;
name|int
name|spc_flags
decl_stmt|;
name|struct
name|buf
modifier|*
name|spc_bp
decl_stmt|;
name|sw_pager_t
name|spc_swp
decl_stmt|;
name|vm_offset_t
name|spc_kva
decl_stmt|;
name|vm_page_t
name|spc_m
decl_stmt|;
name|int
name|spc_npages
decl_stmt|;
block|}
name|swcleanlist
index|[
name|NPENDINGIO
index|]
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|swpagerclean
modifier|*
name|swp_clean_t
typedef|;
end_typedef

begin_comment
comment|/* spc_flags values */
end_comment

begin_define
define|#
directive|define
name|SPC_FREE
value|0x00
end_define

begin_define
define|#
directive|define
name|SPC_BUSY
value|0x01
end_define

begin_define
define|#
directive|define
name|SPC_DONE
value|0x02
end_define

begin_define
define|#
directive|define
name|SPC_ERROR
value|0x04
end_define

begin_struct
struct|struct
name|swtab
block|{
name|vm_size_t
name|st_osize
decl_stmt|;
comment|/* size of object (bytes) */
name|int
name|st_bsize
decl_stmt|;
comment|/* vs. size of swap block (DEV_BSIZE units) */
ifdef|#
directive|ifdef
name|DEBUG
name|u_long
name|st_inuse
decl_stmt|;
comment|/* number in this range in use */
name|u_long
name|st_usecnt
decl_stmt|;
comment|/* total used of this size */
endif|#
directive|endif
block|}
name|swtab
index|[
name|NSWSIZES
operator|+
literal|1
index|]
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|swap_pager_poip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pageouts in progress */
end_comment

begin_decl_stmt
name|int
name|swap_pager_piip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pageins in progress */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|swap_pager_maxcluster
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum cluster size */
end_comment

begin_decl_stmt
name|int
name|swap_pager_npendingio
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pager clean structs */
end_comment

begin_decl_stmt
name|struct
name|swpclean
name|swap_pager_inuse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of pending page cleans */
end_comment

begin_decl_stmt
name|struct
name|swpclean
name|swap_pager_free
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of free pager clean structs */
end_comment

begin_decl_stmt
name|struct
name|pagerlst
name|swap_pager_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of "named" anon regions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|swap_pager_init
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_pager_t
name|swap_pager_alloc
name|__P
argument_list|(
operator|(
name|caddr_t
operator|,
name|vm_size_t
operator|,
name|vm_prot_t
operator|,
name|vm_offset_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_pager_clean
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|swap_pager_clean_check
name|__P
argument_list|(
operator|(
name|vm_page_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|swap_pager_cluster
name|__P
argument_list|(
operator|(
name|vm_pager_t
operator|,
name|vm_offset_t
operator|,
name|vm_offset_t
operator|*
operator|,
name|vm_offset_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_pager_dealloc
name|__P
argument_list|(
operator|(
name|vm_pager_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swap_pager_getpage
name|__P
argument_list|(
operator|(
name|vm_pager_t
operator|,
name|vm_page_t
operator|*
operator|,
name|int
operator|,
name|boolean_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean_t
name|swap_pager_haspage
name|__P
argument_list|(
operator|(
name|vm_pager_t
operator|,
name|vm_offset_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swap_pager_io
name|__P
argument_list|(
operator|(
name|sw_pager_t
operator|,
name|vm_page_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_pager_iodone
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swap_pager_putpage
name|__P
argument_list|(
operator|(
name|vm_pager_t
operator|,
name|vm_page_t
operator|*
operator|,
name|int
operator|,
name|boolean_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pagerops
name|swappagerops
init|=
block|{
name|swap_pager_init
block|,
name|swap_pager_alloc
block|,
name|swap_pager_dealloc
block|,
name|swap_pager_getpage
block|,
name|swap_pager_putpage
block|,
name|swap_pager_haspage
block|,
name|swap_pager_cluster
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|swap_pager_init
parameter_list|()
block|{
specifier|register
name|swp_clean_t
name|spc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|bsize
decl_stmt|;
specifier|extern
name|int
name|dmmin
decl_stmt|,
name|dmmax
decl_stmt|;
name|int
name|maxbsize
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_INIT
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_init()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dfltpagerops
operator|=
operator|&
name|swappagerops
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|swap_pager_list
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate async IO structures. 	 * 	 * XXX it would be nice if we could do this dynamically based on 	 * the value of nswbuf (since we are ultimately limited by that) 	 * but neither nswbuf or malloc has been initialized yet.  So the 	 * structs are statically allocated above. 	 */
name|swap_pager_npendingio
operator|=
name|NPENDINGIO
expr_stmt|;
comment|/* 	 * Initialize clean lists 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|swap_pager_free
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|spc
operator|=
name|swcleanlist
init|;
name|i
operator|<
name|swap_pager_npendingio
condition|;
name|i
operator|++
operator|,
name|spc
operator|++
control|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swap_pager_free
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
name|spc
operator|->
name|spc_flags
operator|=
name|SPC_FREE
expr_stmt|;
block|}
comment|/* 	 * Calculate the swap allocation constants. 	 */
if|if
condition|(
name|dmmin
operator|==
literal|0
condition|)
block|{
name|dmmin
operator|=
name|DMMIN
expr_stmt|;
if|if
condition|(
name|dmmin
operator|<
name|CLBYTES
operator|/
name|DEV_BSIZE
condition|)
name|dmmin
operator|=
name|CLBYTES
operator|/
name|DEV_BSIZE
expr_stmt|;
block|}
if|if
condition|(
name|dmmax
operator|==
literal|0
condition|)
name|dmmax
operator|=
name|DMMAX
expr_stmt|;
comment|/* 	 * Fill in our table of object size vs. allocation size 	 */
name|bsize
operator|=
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsize
operator|<
name|dmmin
condition|)
name|bsize
operator|=
name|dmmin
expr_stmt|;
name|maxbsize
operator|=
name|btodb
argument_list|(
sizeof|sizeof
argument_list|(
name|sw_bm_t
argument_list|)
operator|*
name|NBBY
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxbsize
operator|>
name|dmmax
condition|)
name|maxbsize
operator|=
name|dmmax
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSWSIZES
condition|;
name|i
operator|++
control|)
block|{
name|swtab
index|[
name|i
index|]
operator|.
name|st_osize
operator|=
call|(
name|vm_size_t
call|)
argument_list|(
name|MAXDADDRS
operator|*
name|dbtob
argument_list|(
name|bsize
argument_list|)
argument_list|)
expr_stmt|;
name|swtab
index|[
name|i
index|]
operator|.
name|st_bsize
operator|=
name|bsize
expr_stmt|;
if|if
condition|(
name|bsize
operator|<=
name|btodb
argument_list|(
name|MAXPHYS
argument_list|)
condition|)
name|swap_pager_maxcluster
operator|=
name|dbtob
argument_list|(
name|bsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_INIT
condition|)
name|printf
argument_list|(
literal|"swpg_init: ix %d, size %x, bsize %x\n"
argument_list|,
name|i
argument_list|,
name|swtab
index|[
name|i
index|]
operator|.
name|st_osize
argument_list|,
name|swtab
index|[
name|i
index|]
operator|.
name|st_bsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bsize
operator|>=
name|maxbsize
condition|)
break|break;
name|bsize
operator|*=
literal|2
expr_stmt|;
block|}
name|swtab
index|[
name|i
index|]
operator|.
name|st_osize
operator|=
literal|0
expr_stmt|;
name|swtab
index|[
name|i
index|]
operator|.
name|st_bsize
operator|=
name|bsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a pager structure and associated resources.  * Note that if we are called from the pageout daemon (handle == NULL)  * we should not wait for memory as it could resulting in deadlock.  */
end_comment

begin_function
specifier|static
name|vm_pager_t
name|swap_pager_alloc
parameter_list|(
name|handle
parameter_list|,
name|size
parameter_list|,
name|prot
parameter_list|,
name|foff
parameter_list|)
name|caddr_t
name|handle
decl_stmt|;
specifier|register
name|vm_size_t
name|size
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|vm_offset_t
name|foff
decl_stmt|;
block|{
specifier|register
name|vm_pager_t
name|pager
decl_stmt|;
specifier|register
name|sw_pager_t
name|swp
decl_stmt|;
name|struct
name|swtab
modifier|*
name|swt
decl_stmt|;
name|int
name|waitok
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_ALLOC
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_alloc(%x, %x, %x)\n"
argument_list|,
name|handle
argument_list|,
name|size
argument_list|,
name|prot
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If this is a "named" anonymous region, look it up and 	 * return the appropriate pager if it exists. 	 */
if|if
condition|(
name|handle
condition|)
block|{
name|pager
operator|=
name|vm_pager_lookup
argument_list|(
operator|&
name|swap_pager_list
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Use vm_object_lookup to gain a reference 			 * to the object and also to remove from the 			 * object cache. 			 */
if|if
condition|(
name|vm_object_lookup
argument_list|(
name|pager
argument_list|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"swap_pager_alloc: bad object"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pager
operator|)
return|;
block|}
block|}
comment|/* 	 * Pager doesn't exist, allocate swap management resources 	 * and initialize. 	 */
name|waitok
operator|=
name|handle
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
expr_stmt|;
name|pager
operator|=
operator|(
name|vm_pager_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|pager
argument_list|,
name|M_VMPAGER
argument_list|,
name|waitok
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|swp
operator|=
operator|(
name|sw_pager_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|swp
argument_list|,
name|M_VMPGDATA
argument_list|,
name|waitok
argument_list|)
expr_stmt|;
if|if
condition|(
name|swp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FAIL
condition|)
name|printf
argument_list|(
literal|"swpg_alloc: swpager malloc failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pager
argument_list|,
name|M_VMPAGER
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|swt
operator|=
name|swtab
init|;
name|swt
operator|->
name|st_osize
condition|;
name|swt
operator|++
control|)
if|if
condition|(
name|size
operator|<=
name|swt
operator|->
name|st_osize
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
name|swt
operator|->
name|st_inuse
operator|++
expr_stmt|;
name|swt
operator|->
name|st_usecnt
operator|++
expr_stmt|;
endif|#
directive|endif
name|swp
operator|->
name|sw_osize
operator|=
name|size
expr_stmt|;
name|swp
operator|->
name|sw_bsize
operator|=
name|swt
operator|->
name|st_bsize
expr_stmt|;
name|swp
operator|->
name|sw_nblocks
operator|=
operator|(
name|btodb
argument_list|(
name|size
argument_list|)
operator|+
name|swp
operator|->
name|sw_bsize
operator|-
literal|1
operator|)
operator|/
name|swp
operator|->
name|sw_bsize
expr_stmt|;
name|swp
operator|->
name|sw_blocks
operator|=
operator|(
name|sw_blk_t
operator|)
name|malloc
argument_list|(
name|swp
operator|->
name|sw_nblocks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|swp
operator|->
name|sw_blocks
argument_list|)
argument_list|,
name|M_VMPGDATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_blocks
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|swp
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pager
argument_list|,
name|M_VMPAGER
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FAIL
condition|)
name|printf
argument_list|(
literal|"swpg_alloc: sw_blocks malloc failed\n"
argument_list|)
expr_stmt|;
name|swt
operator|->
name|st_inuse
operator|--
expr_stmt|;
name|swt
operator|->
name|st_usecnt
operator|--
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|swp
operator|->
name|sw_blocks
argument_list|,
name|swp
operator|->
name|sw_nblocks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|swp
operator|->
name|sw_blocks
argument_list|)
argument_list|)
expr_stmt|;
name|swp
operator|->
name|sw_poip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|handle
condition|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|swp
operator|->
name|sw_flags
operator|=
name|SW_NAMED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swap_pager_list
argument_list|,
name|pager
argument_list|,
name|pg_list
argument_list|)
expr_stmt|;
comment|/* 		 * Consistant with other pagers: return with object 		 * referenced.  Can't do this with handle == NULL 		 * since it might be the pageout daemon calling. 		 */
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|vm_object_enter
argument_list|(
name|object
argument_list|,
name|pager
argument_list|)
expr_stmt|;
name|vm_object_setpager
argument_list|(
name|object
argument_list|,
name|pager
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|swp
operator|->
name|sw_flags
operator|=
literal|0
expr_stmt|;
name|pager
operator|->
name|pg_list
operator|.
name|tqe_next
operator|=
name|NULL
expr_stmt|;
name|pager
operator|->
name|pg_list
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
block|}
name|pager
operator|->
name|pg_handle
operator|=
name|handle
expr_stmt|;
name|pager
operator|->
name|pg_ops
operator|=
operator|&
name|swappagerops
expr_stmt|;
name|pager
operator|->
name|pg_type
operator|=
name|PG_SWAP
expr_stmt|;
name|pager
operator|->
name|pg_flags
operator|=
name|PG_CLUSTERPUT
expr_stmt|;
name|pager
operator|->
name|pg_data
operator|=
name|swp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_ALLOC
condition|)
name|printf
argument_list|(
literal|"swpg_alloc: pg_data %x, %x of %x at %x\n"
argument_list|,
name|swp
argument_list|,
name|swp
operator|->
name|sw_nblocks
argument_list|,
name|swp
operator|->
name|sw_bsize
argument_list|,
name|swp
operator|->
name|sw_blocks
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pager
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|swap_pager_dealloc
parameter_list|(
name|pager
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|sw_blk_t
name|bp
decl_stmt|;
specifier|register
name|sw_pager_t
name|swp
decl_stmt|;
name|struct
name|swtab
modifier|*
name|swt
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* save panic time state */
if|if
condition|(
operator|(
name|swpagerdebug
operator|&
name|SDB_ANOMPANIC
operator|)
operator|&&
name|panicstr
condition|)
return|return;
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_ALLOC
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_dealloc(%x)\n"
argument_list|,
name|pager
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Remove from list right away so lookups will fail if we 	 * block for pageout completion. 	 */
name|swp
operator|=
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_flags
operator|&
name|SW_NAMED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swap_pager_list
argument_list|,
name|pager
argument_list|,
name|pg_list
argument_list|)
expr_stmt|;
name|swp
operator|->
name|sw_flags
operator|&=
operator|~
name|SW_NAMED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|swt
operator|=
name|swtab
init|;
name|swt
operator|->
name|st_osize
condition|;
name|swt
operator|++
control|)
if|if
condition|(
name|swp
operator|->
name|sw_osize
operator|<=
name|swt
operator|->
name|st_osize
condition|)
break|break;
name|swt
operator|->
name|st_inuse
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Wait for all pageouts to finish and remove 	 * all entries from cleaning list. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
name|swp
operator|->
name|sw_poip
condition|)
block|{
name|swp
operator|->
name|sw_flags
operator||=
name|SW_WANTED
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
name|swp
argument_list|,
name|PVM
argument_list|,
literal|"swpgdealloc"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|swap_pager_clean
argument_list|(
name|B_WRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Free left over swap blocks 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bp
operator|=
name|swp
operator|->
name|sw_blocks
init|;
name|i
operator|<
name|swp
operator|->
name|sw_nblocks
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
if|if
condition|(
name|bp
operator|->
name|swb_block
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_ALLOCBLK
operator||
name|SDB_FULL
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_dealloc: blk %x\n"
argument_list|,
name|bp
operator|->
name|swb_block
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rmfree
argument_list|(
name|swapmap
argument_list|,
name|swp
operator|->
name|sw_bsize
argument_list|,
name|bp
operator|->
name|swb_block
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free swap management resources 	 */
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|swp
operator|->
name|sw_blocks
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|swp
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pager
argument_list|,
name|M_VMPAGER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|swap_pager_getpage
parameter_list|(
name|pager
parameter_list|,
name|mlist
parameter_list|,
name|npages
parameter_list|,
name|sync
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
name|vm_page_t
modifier|*
name|mlist
decl_stmt|;
name|int
name|npages
decl_stmt|;
name|boolean_t
name|sync
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"swpg_getpage(%x, %x, %x, %x)\n"
argument_list|,
name|pager
argument_list|,
name|mlist
argument_list|,
name|npages
argument_list|,
name|sync
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|swap_pager_io
argument_list|(
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
argument_list|,
name|mlist
argument_list|,
name|npages
argument_list|,
name|B_READ
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|swap_pager_putpage
parameter_list|(
name|pager
parameter_list|,
name|mlist
parameter_list|,
name|npages
parameter_list|,
name|sync
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
name|vm_page_t
modifier|*
name|mlist
decl_stmt|;
name|int
name|npages
decl_stmt|;
name|boolean_t
name|sync
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"swpg_putpage(%x, %x, %x, %x)\n"
argument_list|,
name|pager
argument_list|,
name|mlist
argument_list|,
name|npages
argument_list|,
name|sync
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pager
operator|==
name|NULL
condition|)
block|{
name|swap_pager_clean
argument_list|(
name|B_WRITE
argument_list|)
expr_stmt|;
return|return
operator|(
name|VM_PAGER_OK
operator|)
return|;
comment|/* ??? */
block|}
name|flags
operator|=
name|B_WRITE
expr_stmt|;
if|if
condition|(
operator|!
name|sync
condition|)
name|flags
operator||=
name|B_ASYNC
expr_stmt|;
return|return
operator|(
name|swap_pager_io
argument_list|(
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
argument_list|,
name|mlist
argument_list|,
name|npages
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|swap_pager_haspage
parameter_list|(
name|pager
parameter_list|,
name|offset
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
block|{
specifier|register
name|sw_pager_t
name|swp
decl_stmt|;
specifier|register
name|sw_blk_t
name|swb
decl_stmt|;
name|int
name|ix
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_ALLOCBLK
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_haspage(%x, %x) "
argument_list|,
name|pager
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|swp
operator|=
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
expr_stmt|;
name|ix
operator|=
name|offset
operator|/
name|dbtob
argument_list|(
name|swp
operator|->
name|sw_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_blocks
operator|==
name|NULL
operator|||
name|ix
operator|>=
name|swp
operator|->
name|sw_nblocks
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FAIL
operator||
name|SDB_FOLLOW
operator||
name|SDB_ALLOCBLK
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_haspage: %x bad offset %x, ix %x\n"
argument_list|,
name|swp
operator|->
name|sw_blocks
argument_list|,
name|offset
argument_list|,
name|ix
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|swb
operator|=
operator|&
name|swp
operator|->
name|sw_blocks
index|[
name|ix
index|]
expr_stmt|;
if|if
condition|(
name|swb
operator|->
name|swb_block
condition|)
name|ix
operator|=
name|atop
argument_list|(
name|offset
operator|%
name|dbtob
argument_list|(
name|swp
operator|->
name|sw_bsize
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_ALLOCBLK
condition|)
name|printf
argument_list|(
literal|"%x blk %x+%x "
argument_list|,
name|swp
operator|->
name|sw_blocks
argument_list|,
name|swb
operator|->
name|swb_block
argument_list|,
name|ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_ALLOCBLK
operator|)
condition|)
name|printf
argument_list|(
literal|"-> %c\n"
argument_list|,
literal|"FT"
index|[
name|swb
operator|->
name|swb_block
operator|&&
operator|(
name|swb
operator|->
name|swb_mask
operator|&
operator|(
literal|1
operator|<<
name|ix
operator|)
operator|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|swb
operator|->
name|swb_block
operator|&&
operator|(
name|swb
operator|->
name|swb_mask
operator|&
operator|(
literal|1
operator|<<
name|ix
operator|)
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|swap_pager_cluster
parameter_list|(
name|pager
parameter_list|,
name|offset
parameter_list|,
name|loffset
parameter_list|,
name|hoffset
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
name|vm_offset_t
modifier|*
name|loffset
decl_stmt|;
name|vm_offset_t
modifier|*
name|hoffset
decl_stmt|;
block|{
name|sw_pager_t
name|swp
decl_stmt|;
specifier|register
name|int
name|bsize
decl_stmt|;
name|vm_offset_t
name|loff
decl_stmt|,
name|hoff
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_CLUSTER
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_cluster(%x, %x) "
argument_list|,
name|pager
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|swp
operator|=
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
expr_stmt|;
name|bsize
operator|=
name|dbtob
argument_list|(
name|swp
operator|->
name|sw_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsize
operator|>
name|swap_pager_maxcluster
condition|)
name|bsize
operator|=
name|swap_pager_maxcluster
expr_stmt|;
name|loff
operator|=
name|offset
operator|-
operator|(
name|offset
operator|%
name|bsize
operator|)
expr_stmt|;
if|if
condition|(
name|loff
operator|>=
name|swp
operator|->
name|sw_osize
condition|)
name|panic
argument_list|(
literal|"swap_pager_cluster: bad offset"
argument_list|)
expr_stmt|;
name|hoff
operator|=
name|loff
operator|+
name|bsize
expr_stmt|;
if|if
condition|(
name|hoff
operator|>
name|swp
operator|->
name|sw_osize
condition|)
name|hoff
operator|=
name|swp
operator|->
name|sw_osize
expr_stmt|;
operator|*
name|loffset
operator|=
name|loff
expr_stmt|;
operator|*
name|hoffset
operator|=
name|hoff
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_CLUSTER
operator|)
condition|)
name|printf
argument_list|(
literal|"returns [%x-%x]\n"
argument_list|,
name|loff
argument_list|,
name|hoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Scaled down version of swap().  * Assumes that PAGE_SIZE< MAXPHYS; i.e. only one operation needed.  * BOGUS:  lower level IO routines expect a KVA so we have to map our  * provided physical page into the KVA to keep them happy.  */
end_comment

begin_function
specifier|static
name|int
name|swap_pager_io
parameter_list|(
name|swp
parameter_list|,
name|mlist
parameter_list|,
name|npages
parameter_list|,
name|flags
parameter_list|)
specifier|register
name|sw_pager_t
name|swp
decl_stmt|;
name|vm_page_t
modifier|*
name|mlist
decl_stmt|;
name|int
name|npages
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|sw_blk_t
name|swb
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|ix
decl_stmt|,
name|mask
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|vm_offset_t
name|kva
decl_stmt|,
name|off
decl_stmt|;
name|swp_clean_t
name|spc
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* save panic time state */
if|if
condition|(
operator|(
name|swpagerdebug
operator|&
name|SDB_ANOMPANIC
operator|)
operator|&&
name|panicstr
condition|)
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
comment|/* XXX: correct return? */
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_IO
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_io(%x, %x, %x, %x)\n"
argument_list|,
name|swp
argument_list|,
name|mlist
argument_list|,
name|npages
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|B_ASYNC
condition|)
name|panic
argument_list|(
literal|"swap_pager_io: cannot do ASYNC reads"
argument_list|)
expr_stmt|;
if|if
condition|(
name|npages
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"swap_pager_io: cannot do clustered reads"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * First determine if the page exists in the pager if this is 	 * a sync read.  This quickly handles cases where we are 	 * following shadow chains looking for the top level object 	 * with the page. 	 */
name|m
operator|=
operator|*
name|mlist
expr_stmt|;
name|off
operator|=
name|m
operator|->
name|offset
operator|+
name|m
operator|->
name|object
operator|->
name|paging_offset
expr_stmt|;
name|ix
operator|=
name|off
operator|/
name|dbtob
argument_list|(
name|swp
operator|->
name|sw_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_blocks
operator|==
name|NULL
operator|||
name|ix
operator|>=
name|swp
operator|->
name|sw_nblocks
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|&&
operator|(
name|swpagerdebug
operator|&
name|SDB_ANOM
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager_io: no swap block on write\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VM_PAGER_BAD
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
block|}
name|swb
operator|=
operator|&
name|swp
operator|->
name|sw_blocks
index|[
name|ix
index|]
expr_stmt|;
name|off
operator|=
name|off
operator|%
name|dbtob
argument_list|(
name|swp
operator|->
name|sw_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|B_READ
operator|)
operator|&&
operator|(
name|swb
operator|->
name|swb_block
operator|==
literal|0
operator|||
operator|(
name|swb
operator|->
name|swb_mask
operator|&
operator|(
literal|1
operator|<<
name|atop
argument_list|(
name|off
argument_list|)
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
comment|/* 	 * For reads (pageins) and synchronous writes, we clean up 	 * all completed async pageouts. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|swap_pager_clean
argument_list|(
name|flags
operator|&
name|B_READ
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_PARANOIA
condition|)
name|swap_pager_clean_check
argument_list|(
name|mlist
argument_list|,
name|npages
argument_list|,
name|flags
operator|&
name|B_READ
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For async writes (pageouts), we cleanup completed pageouts so 	 * that all available resources are freed.  Also tells us if this 	 * page is already being cleaned.  If it is, or no resources 	 * are available, we try again later. 	 */
else|else
block|{
name|swap_pager_clean
argument_list|(
name|B_WRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_PARANOIA
condition|)
name|swap_pager_clean_check
argument_list|(
name|mlist
argument_list|,
name|npages
argument_list|,
name|B_WRITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|swap_pager_free
operator|.
name|tqh_first
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FAIL
condition|)
name|printf
argument_list|(
literal|"%s: no available io headers\n"
argument_list|,
literal|"swap_pager_io"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|VM_PAGER_AGAIN
operator|)
return|;
block|}
block|}
comment|/* 	 * Allocate a swap block if necessary. 	 */
if|if
condition|(
name|swb
operator|->
name|swb_block
operator|==
literal|0
condition|)
block|{
name|swb
operator|->
name|swb_block
operator|=
name|rmalloc
argument_list|(
name|swapmap
argument_list|,
name|swp
operator|->
name|sw_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|swb
operator|->
name|swb_block
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FAIL
condition|)
name|printf
argument_list|(
literal|"swpg_io: rmalloc of %x failed\n"
argument_list|,
name|swp
operator|->
name|sw_bsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * XXX this is technically a resource shortage that 			 * should return AGAIN, but the situation isn't likely 			 * to be remedied just by delaying a little while and 			 * trying again (the pageout daemon's current response 			 * to AGAIN) so we just return FAIL. 			 */
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FULL
operator||
name|SDB_ALLOCBLK
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_io: %x alloc blk %x at ix %x\n"
argument_list|,
name|swp
operator|->
name|sw_blocks
argument_list|,
name|swb
operator|->
name|swb_block
argument_list|,
name|ix
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Allocate a kernel virtual address and initialize so that PTE 	 * is available for lower level IO drivers. 	 */
name|kva
operator|=
name|vm_pager_map_pages
argument_list|(
name|mlist
argument_list|,
name|npages
argument_list|,
operator|!
operator|(
name|flags
operator|&
name|B_ASYNC
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kva
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FAIL
condition|)
name|printf
argument_list|(
literal|"%s: no KVA space to map pages\n"
argument_list|,
literal|"swap_pager_io"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|VM_PAGER_AGAIN
operator|)
return|;
block|}
comment|/* 	 * Get a swap buffer header and initialize it. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
name|bswlist
operator|.
name|b_actf
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_ANOM
condition|)
name|printf
argument_list|(
literal|"swap_pager_io: wait on swbuf for %x (%d)\n"
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bswlist
operator|.
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|bswlist
argument_list|,
name|PSWP
operator|+
literal|1
argument_list|,
literal|"swpgiobuf"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bp
operator|=
name|bswlist
operator|.
name|b_actf
expr_stmt|;
name|bswlist
operator|.
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
operator|(
name|flags
operator|&
name|B_READ
operator|)
expr_stmt|;
name|bp
operator|->
name|b_proc
operator|=
operator|&
name|proc0
expr_stmt|;
comment|/* XXX (but without B_PHYS set this is ok) */
name|bp
operator|->
name|b_data
operator|=
operator|(
name|caddr_t
operator|)
name|kva
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|swb
operator|->
name|swb_block
operator|+
name|btodb
argument_list|(
name|off
argument_list|)
expr_stmt|;
name|VHOLD
argument_list|(
name|swapdev_vp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|=
name|swapdev_vp
expr_stmt|;
if|if
condition|(
name|swapdev_vp
operator|->
name|v_type
operator|==
name|VBLK
condition|)
name|bp
operator|->
name|b_dev
operator|=
name|swapdev_vp
operator|->
name|v_rdev
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|npages
operator|*
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * For writes we set up additional buffer fields, record a pageout 	 * in progress and mark that these swap blocks are now allocated. 	 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_dirtyoff
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_dirtyend
operator|=
name|npages
operator|*
name|PAGE_SIZE
expr_stmt|;
name|swapdev_vp
operator|->
name|v_numoutput
operator|++
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|swp
operator|->
name|sw_poip
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|~
operator|(
operator|~
literal|0
operator|<<
name|npages
operator|)
operator|)
operator|<<
name|atop
argument_list|(
name|off
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|swap_pager_poip
operator|++
expr_stmt|;
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_WRITE
condition|)
name|printf
argument_list|(
literal|"swpg_io: write: bp=%x swp=%x poip=%d\n"
argument_list|,
name|bp
argument_list|,
name|swp
argument_list|,
name|swp
operator|->
name|sw_poip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|swpagerdebug
operator|&
name|SDB_ALLOCBLK
operator|)
operator|&&
operator|(
name|swb
operator|->
name|swb_mask
operator|&
name|mask
operator|)
operator|!=
name|mask
condition|)
name|printf
argument_list|(
literal|"swpg_io: %x write %d pages at %x+%x\n"
argument_list|,
name|swp
operator|->
name|sw_blocks
argument_list|,
name|npages
argument_list|,
name|swb
operator|->
name|swb_block
argument_list|,
name|atop
argument_list|(
name|off
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_CLUSTER
condition|)
name|printf
argument_list|(
literal|"swpg_io: off=%x, npg=%x, mask=%x, bmask=%x\n"
argument_list|,
name|off
argument_list|,
name|npages
argument_list|,
name|mask
argument_list|,
name|swb
operator|->
name|swb_mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|swb
operator|->
name|swb_mask
operator||=
name|mask
expr_stmt|;
block|}
comment|/* 	 * If this is an async write we set up still more buffer fields 	 * and place a "cleaning" entry on the inuse queue. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|B_READ
operator||
name|B_ASYNC
operator|)
operator|)
operator|==
name|B_ASYNC
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swap_pager_free
operator|.
name|tqh_first
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"swpg_io: lost spc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|spc
operator|=
name|swap_pager_free
operator|.
name|tqh_first
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swap_pager_free
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|spc
operator|->
name|spc_flags
operator|!=
name|SPC_FREE
condition|)
name|panic
argument_list|(
literal|"swpg_io: bad free spc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|spc
operator|->
name|spc_flags
operator|=
name|SPC_BUSY
expr_stmt|;
name|spc
operator|->
name|spc_bp
operator|=
name|bp
expr_stmt|;
name|spc
operator|->
name|spc_swp
operator|=
name|swp
expr_stmt|;
name|spc
operator|->
name|spc_kva
operator|=
name|kva
expr_stmt|;
comment|/* 		 * Record the first page.  This allows swap_pager_finish 		 * to efficiently handle the common case of a single page. 		 * For clusters, it allows us to locate the object easily 		 * and we then reconstruct the rest of the mlist from spc_kva. 		 * 		 * XXX 		 * swap_pager_finish no longer exists. 		 */
name|spc
operator|->
name|spc_m
operator|=
name|m
expr_stmt|;
name|spc
operator|->
name|spc_npages
operator|=
name|npages
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_CALL
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|swap_pager_iodone
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Finally, start the IO operation. 	 * If it is async we are all done, otherwise we must wait for 	 * completion and cleanup afterwards. 	 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_IO
condition|)
name|printf
argument_list|(
literal|"swpg_io: IO start: bp %x, db %x, va %x, pa %x\n"
argument_list|,
name|bp
argument_list|,
name|swb
operator|->
name|swb_block
operator|+
name|btodb
argument_list|(
name|off
argument_list|)
argument_list|,
name|kva
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|B_READ
operator||
name|B_ASYNC
operator|)
operator|)
operator|==
name|B_ASYNC
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_IO
condition|)
name|printf
argument_list|(
literal|"swpg_io:  IO started: bp %x\n"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|VM_PAGER_PEND
operator|)
return|;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
name|swap_pager_piip
operator|++
expr_stmt|;
else|else
name|swap_pager_poip
operator|++
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
name|bp
argument_list|,
name|PVM
argument_list|,
literal|"swpgio"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
operator|--
name|swp
operator|->
name|sw_poip
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
operator|--
name|swap_pager_piip
expr_stmt|;
else|else
operator|--
name|swap_pager_poip
expr_stmt|;
endif|#
directive|endif
name|rv
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
condition|?
name|VM_PAGER_ERROR
else|:
name|VM_PAGER_OK
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_BUSY
operator||
name|B_WANTED
operator||
name|B_PHYS
operator||
name|B_PAGET
operator||
name|B_UAREA
operator||
name|B_DIRTY
operator|)
expr_stmt|;
name|bp
operator|->
name|b_actf
operator|=
name|bswlist
operator|.
name|b_actf
expr_stmt|;
name|bswlist
operator|.
name|b_actf
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|brelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bswlist
operator|.
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bswlist
operator|.
name|b_flags
operator|&=
operator|~
name|B_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|bswlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|&&
name|rv
operator|==
name|VM_PAGER_OK
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|PG_CLEAN
expr_stmt|;
name|pmap_clear_modify
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_IO
condition|)
name|printf
argument_list|(
literal|"swpg_io:  IO done: bp %x, rv %d\n"
argument_list|,
name|bp
argument_list|,
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|swpagerdebug
operator|&
name|SDB_FAIL
operator|)
operator|&&
name|rv
operator|==
name|VM_PAGER_ERROR
condition|)
name|printf
argument_list|(
literal|"swpg_io: IO error\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vm_pager_unmap_pages
argument_list|(
name|kva
argument_list|,
name|npages
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|swap_pager_clean
parameter_list|(
name|rw
parameter_list|)
name|int
name|rw
decl_stmt|;
block|{
specifier|register
name|swp_clean_t
name|spc
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* save panic time state */
if|if
condition|(
operator|(
name|swpagerdebug
operator|&
name|SDB_ANOMPANIC
operator|)
operator|&&
name|panicstr
condition|)
return|return;
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"swpg_clean(%x)\n"
argument_list|,
name|rw
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Look up and removal from inuse list must be done 		 * at splbio() to avoid conflicts with swap_pager_iodone. 		 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|spc
operator|=
name|swap_pager_inuse
operator|.
name|tqh_first
init|;
name|spc
operator|!=
name|NULL
condition|;
name|spc
operator|=
name|spc
operator|->
name|spc_list
operator|.
name|tqe_next
control|)
block|{
comment|/* 			 * If the operation is done, remove it from the 			 * list and process it. 			 * 			 * XXX if we can't get the object lock we also 			 * leave it on the list and try again later. 			 * Is there something better we could do? 			 */
if|if
condition|(
operator|(
name|spc
operator|->
name|spc_flags
operator|&
name|SPC_DONE
operator|)
operator|&&
name|vm_object_lock_try
argument_list|(
name|spc
operator|->
name|spc_m
operator|->
name|object
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * No operations done, thats all we can do for now. 		 */
if|if
condition|(
name|spc
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * Found a completed operation so finish it off. 		 * Note: no longer at splbio since entry is off the list. 		 */
name|m
operator|=
name|spc
operator|->
name|spc_m
expr_stmt|;
name|object
operator|=
name|m
operator|->
name|object
expr_stmt|;
comment|/* 		 * Process each page in the cluster. 		 * The first page is explicitly kept in the cleaning 		 * entry, others must be reconstructed from the KVA. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spc
operator|->
name|spc_npages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|m
operator|=
name|vm_pager_atop
argument_list|(
name|spc
operator|->
name|spc_kva
operator|+
name|ptoa
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * If no error mark as clean and inform the pmap 			 * system.  If there was an error, mark as dirty 			 * so we will try again. 			 * 			 * XXX could get stuck doing this, should give up 			 * after awhile. 			 */
if|if
condition|(
name|spc
operator|->
name|spc_flags
operator|&
name|SPC_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"%s: clean of page %x failed\n"
argument_list|,
literal|"swap_pager_clean"
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_LAUNDRY
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|flags
operator||=
name|PG_CLEAN
expr_stmt|;
name|pmap_clear_modify
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_BUSY
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Done with the object, decrement the paging count 		 * and unlock it. 		 */
if|if
condition|(
operator|--
name|object
operator|->
name|paging_in_progress
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|/* 		 * Free up KVM used and put the entry back on the list. 		 */
name|vm_pager_unmap_pages
argument_list|(
name|spc
operator|->
name|spc_kva
argument_list|,
name|spc
operator|->
name|spc_npages
argument_list|)
expr_stmt|;
name|spc
operator|->
name|spc_flags
operator|=
name|SPC_FREE
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|swap_pager_free
argument_list|,
name|spc
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_WRITE
condition|)
name|printf
argument_list|(
literal|"swpg_clean: free spc %x\n"
argument_list|,
name|spc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|swap_pager_clean_check
parameter_list|(
name|mlist
parameter_list|,
name|npages
parameter_list|,
name|rw
parameter_list|)
name|vm_page_t
modifier|*
name|mlist
decl_stmt|;
name|int
name|npages
decl_stmt|;
name|int
name|rw
decl_stmt|;
block|{
specifier|register
name|swp_clean_t
name|spc
decl_stmt|;
name|boolean_t
name|bad
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|s
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
if|if
condition|(
name|panicstr
condition|)
return|return;
name|bad
operator|=
name|FALSE
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|spc
operator|=
name|swap_pager_inuse
operator|.
name|tqh_first
init|;
name|spc
operator|!=
name|NULL
condition|;
name|spc
operator|=
name|spc
operator|->
name|spc_list
operator|.
name|tqe_next
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|spc
operator|->
name|spc_npages
condition|;
name|j
operator|++
control|)
block|{
name|m
operator|=
name|vm_pager_atop
argument_list|(
name|spc
operator|->
name|spc_kva
operator|+
name|ptoa
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|m
operator|==
name|mlist
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_ANOM
condition|)
name|printf
argument_list|(
literal|"swpg_clean_check: %s: page %x on list, flags %x\n"
argument_list|,
name|rw
operator|==
name|B_WRITE
condition|?
literal|"write"
else|:
literal|"read"
argument_list|,
name|mlist
index|[
name|i
index|]
argument_list|,
name|spc
operator|->
name|spc_flags
argument_list|)
expr_stmt|;
name|bad
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
condition|)
name|panic
argument_list|(
literal|"swpg_clean_check"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|swap_pager_iodone
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|swp_clean_t
name|spc
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* save panic time state */
if|if
condition|(
operator|(
name|swpagerdebug
operator|&
name|SDB_ANOMPANIC
operator|)
operator|&&
name|panicstr
condition|)
return|return;
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"swpg_iodone(%x)\n"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|spc
operator|=
name|swap_pager_inuse
operator|.
name|tqh_first
init|;
name|spc
operator|!=
name|NULL
condition|;
name|spc
operator|=
name|spc
operator|->
name|spc_list
operator|.
name|tqe_next
control|)
if|if
condition|(
name|spc
operator|->
name|spc_bp
operator|==
name|bp
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|spc
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"swap_pager_iodone: bp not found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|spc
operator|->
name|spc_flags
operator|&=
operator|~
name|SPC_BUSY
expr_stmt|;
name|spc
operator|->
name|spc_flags
operator||=
name|SPC_DONE
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
name|spc
operator|->
name|spc_flags
operator||=
name|SPC_ERROR
expr_stmt|;
name|spc
operator|->
name|spc_bp
operator|=
name|NULL
expr_stmt|;
name|blk
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|--
name|swap_pager_poip
expr_stmt|;
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_WRITE
condition|)
name|printf
argument_list|(
literal|"swpg_iodone: bp=%x swp=%x flags=%x spc=%x poip=%x\n"
argument_list|,
name|bp
argument_list|,
name|spc
operator|->
name|spc_swp
argument_list|,
name|spc
operator|->
name|spc_swp
operator|->
name|sw_flags
argument_list|,
name|spc
argument_list|,
name|spc
operator|->
name|spc_swp
operator|->
name|sw_poip
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|spc
operator|->
name|spc_swp
operator|->
name|sw_poip
operator|--
expr_stmt|;
if|if
condition|(
name|spc
operator|->
name|spc_swp
operator|->
name|sw_flags
operator|&
name|SW_WANTED
condition|)
block|{
name|spc
operator|->
name|spc_swp
operator|->
name|sw_flags
operator|&=
operator|~
name|SW_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|spc
operator|->
name|spc_swp
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_BUSY
operator||
name|B_WANTED
operator||
name|B_PHYS
operator||
name|B_PAGET
operator||
name|B_UAREA
operator||
name|B_DIRTY
operator|)
expr_stmt|;
name|bp
operator|->
name|b_actf
operator|=
name|bswlist
operator|.
name|b_actf
expr_stmt|;
name|bswlist
operator|.
name|b_actf
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|brelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bswlist
operator|.
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bswlist
operator|.
name|b_flags
operator|&=
operator|~
name|B_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|bswlist
argument_list|)
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|vm_pages_needed
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

