begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990 University of Utah.  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  *	@(#)swap_pager.c	7.1 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Quick hack to page to dedicated partition(s).  * TODO:  *	Add multiprocessor locks  *	Deal with async writes in a better fashion  */
end_comment

begin_include
include|#
directive|include
file|"swappager.h"
end_include

begin_if
if|#
directive|if
name|NSWAPPAGER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"specdev.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"queue.h"
end_include

begin_include
include|#
directive|include
file|"../vm/vm_param.h"
end_include

begin_include
include|#
directive|include
file|"../vm/vm_pager.h"
end_include

begin_include
include|#
directive|include
file|"../vm/vm_page.h"
end_include

begin_include
include|#
directive|include
file|"../vm/vm_pageout.h"
end_include

begin_include
include|#
directive|include
file|"../vm/swap_pager.h"
end_include

begin_define
define|#
directive|define
name|NSWSIZES
value|16
end_define

begin_comment
comment|/* size of swtab */
end_comment

begin_define
define|#
directive|define
name|NPENDINGIO
value|64
end_define

begin_comment
comment|/* max # of pending cleans */
end_comment

begin_define
define|#
directive|define
name|MAXDADDRS
value|64
end_define

begin_comment
comment|/* max # of disk addrs for fixed allocations */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|swpagerdebug
init|=
literal|0x100
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SDB_FOLLOW
value|0x001
end_define

begin_define
define|#
directive|define
name|SDB_INIT
value|0x002
end_define

begin_define
define|#
directive|define
name|SDB_ALLOC
value|0x004
end_define

begin_define
define|#
directive|define
name|SDB_IO
value|0x008
end_define

begin_define
define|#
directive|define
name|SDB_WRITE
value|0x010
end_define

begin_define
define|#
directive|define
name|SDB_FAIL
value|0x020
end_define

begin_define
define|#
directive|define
name|SDB_ALLOCBLK
value|0x040
end_define

begin_define
define|#
directive|define
name|SDB_FULL
value|0x080
end_define

begin_define
define|#
directive|define
name|SDB_ANOM
value|0x100
end_define

begin_define
define|#
directive|define
name|SDB_ANOMPANIC
value|0x200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|swpagerclean
block|{
name|queue_head_t
name|spc_list
decl_stmt|;
name|int
name|spc_flags
decl_stmt|;
name|struct
name|buf
modifier|*
name|spc_bp
decl_stmt|;
name|sw_pager_t
name|spc_swp
decl_stmt|;
name|vm_offset_t
name|spc_kva
decl_stmt|;
name|vm_page_t
name|spc_m
decl_stmt|;
block|}
name|swcleanlist
index|[
name|NPENDINGIO
index|]
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|swpagerclean
modifier|*
name|swp_clean_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SWP_CLEAN_NULL
value|((swp_clean_t)0)
end_define

begin_comment
comment|/* spc_flags values */
end_comment

begin_define
define|#
directive|define
name|SPC_FREE
value|0x00
end_define

begin_define
define|#
directive|define
name|SPC_BUSY
value|0x01
end_define

begin_define
define|#
directive|define
name|SPC_DONE
value|0x02
end_define

begin_define
define|#
directive|define
name|SPC_ERROR
value|0x04
end_define

begin_define
define|#
directive|define
name|SPC_DIRTY
value|0x08
end_define

begin_struct
struct|struct
name|swtab
block|{
name|vm_size_t
name|st_osize
decl_stmt|;
comment|/* size of object (bytes) */
name|int
name|st_bsize
decl_stmt|;
comment|/* vs. size of swap block (DEV_BSIZE units) */
ifdef|#
directive|ifdef
name|DEBUG
name|u_long
name|st_inuse
decl_stmt|;
comment|/* number in this range in use */
name|u_long
name|st_usecnt
decl_stmt|;
comment|/* total used of this size */
endif|#
directive|endif
block|}
name|swtab
index|[
name|NSWSIZES
operator|+
literal|1
index|]
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|swap_pager_pendingio
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max pending async "clean" ops */
end_comment

begin_decl_stmt
name|int
name|swap_pager_poip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pageouts in progress */
end_comment

begin_decl_stmt
name|int
name|swap_pager_piip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pageins in progress */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|queue_head_t
name|swap_pager_inuse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of pending page cleans */
end_comment

begin_decl_stmt
name|queue_head_t
name|swap_pager_free
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of free pager clean structs */
end_comment

begin_decl_stmt
name|queue_head_t
name|swap_pager_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of "named" anon regions */
end_comment

begin_function
name|void
name|swap_pager_init
parameter_list|()
block|{
specifier|register
name|swp_clean_t
name|spc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|bsize
decl_stmt|;
specifier|extern
name|int
name|dmmin
decl_stmt|,
name|dmmax
decl_stmt|;
name|int
name|maxbsize
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_INIT
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_init()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dfltpagerops
operator|=
operator|&
name|swappagerops
expr_stmt|;
name|queue_init
argument_list|(
operator|&
name|swap_pager_list
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize clean lists 	 */
name|queue_init
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|)
expr_stmt|;
name|queue_init
argument_list|(
operator|&
name|swap_pager_free
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|spc
operator|=
name|swcleanlist
init|;
name|i
operator|<
name|NPENDINGIO
condition|;
name|i
operator|++
operator|,
name|spc
operator|++
control|)
block|{
name|queue_enter
argument_list|(
operator|&
name|swap_pager_free
argument_list|,
name|spc
argument_list|,
name|swp_clean_t
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
name|spc
operator|->
name|spc_flags
operator|=
name|SPC_FREE
expr_stmt|;
block|}
comment|/* 	 * Calculate the swap allocation constants. 	 */
if|if
condition|(
name|dmmin
operator|==
literal|0
condition|)
block|{
name|dmmin
operator|=
name|DMMIN
expr_stmt|;
if|if
condition|(
name|dmmin
operator|<
name|CLBYTES
operator|/
name|DEV_BSIZE
condition|)
name|dmmin
operator|=
name|CLBYTES
operator|/
name|DEV_BSIZE
expr_stmt|;
block|}
if|if
condition|(
name|dmmax
operator|==
literal|0
condition|)
name|dmmax
operator|=
name|DMMAX
expr_stmt|;
comment|/* 	 * Fill in our table of object size vs. allocation size 	 */
name|bsize
operator|=
name|btodb
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsize
operator|<
name|dmmin
condition|)
name|bsize
operator|=
name|dmmin
expr_stmt|;
name|maxbsize
operator|=
name|btodb
argument_list|(
sizeof|sizeof
argument_list|(
name|sw_bm_t
argument_list|)
operator|*
name|NBBY
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxbsize
operator|>
name|dmmax
condition|)
name|maxbsize
operator|=
name|dmmax
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSWSIZES
condition|;
name|i
operator|++
control|)
block|{
name|swtab
index|[
name|i
index|]
operator|.
name|st_osize
operator|=
call|(
name|vm_size_t
call|)
argument_list|(
name|MAXDADDRS
operator|*
name|dbtob
argument_list|(
name|bsize
argument_list|)
argument_list|)
expr_stmt|;
name|swtab
index|[
name|i
index|]
operator|.
name|st_bsize
operator|=
name|bsize
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_INIT
condition|)
name|printf
argument_list|(
literal|"swpg_init: ix %d, size %x, bsize %x\n"
argument_list|,
name|i
argument_list|,
name|swtab
index|[
name|i
index|]
operator|.
name|st_osize
argument_list|,
name|swtab
index|[
name|i
index|]
operator|.
name|st_bsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bsize
operator|>=
name|maxbsize
condition|)
break|break;
name|bsize
operator|*=
literal|2
expr_stmt|;
block|}
name|swtab
index|[
name|i
index|]
operator|.
name|st_osize
operator|=
literal|0
expr_stmt|;
name|swtab
index|[
name|i
index|]
operator|.
name|st_bsize
operator|=
name|bsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a pager structure and associated resources.  * Note that if we are called from the pageout daemon (handle == NULL)  * we should not wait for memory as it could resulting in deadlock.  */
end_comment

begin_function
name|vm_pager_t
name|swap_pager_alloc
parameter_list|(
name|handle
parameter_list|,
name|size
parameter_list|,
name|prot
parameter_list|)
name|caddr_t
name|handle
decl_stmt|;
specifier|register
name|vm_size_t
name|size
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
block|{
specifier|register
name|vm_pager_t
name|pager
decl_stmt|;
specifier|register
name|sw_pager_t
name|swp
decl_stmt|;
name|struct
name|swtab
modifier|*
name|swt
decl_stmt|;
name|int
name|waitok
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_ALLOC
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_alloc(%x, %x, %x)\n"
argument_list|,
name|handle
argument_list|,
name|size
argument_list|,
name|prot
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If this is a "named" anonymous region, look it up and 	 * return the appropriate pager if it exists. 	 */
if|if
condition|(
name|handle
condition|)
block|{
name|pager
operator|=
name|vm_pager_lookup
argument_list|(
operator|&
name|swap_pager_list
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|!=
name|VM_PAGER_NULL
condition|)
block|{
comment|/* 			 * Use vm_object_lookup to gain a reference 			 * to the object and also to remove from the 			 * object cache. 			 */
if|if
condition|(
name|vm_object_lookup
argument_list|(
name|pager
argument_list|)
operator|==
name|VM_OBJECT_NULL
condition|)
name|panic
argument_list|(
literal|"swap_pager_alloc: bad object"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pager
operator|)
return|;
block|}
block|}
comment|/* 	 * Pager doesn't exist, allocate swap management resources 	 * and initialize. 	 */
name|waitok
operator|=
name|handle
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
expr_stmt|;
name|pager
operator|=
operator|(
name|vm_pager_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|pager
argument_list|,
name|M_VMPAGER
argument_list|,
name|waitok
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|==
name|VM_PAGER_NULL
condition|)
return|return
operator|(
name|VM_PAGER_NULL
operator|)
return|;
name|swp
operator|=
operator|(
name|sw_pager_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|swp
argument_list|,
name|M_VMPGDATA
argument_list|,
name|waitok
argument_list|)
expr_stmt|;
if|if
condition|(
name|swp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FAIL
condition|)
name|printf
argument_list|(
literal|"swpg_alloc: swpager malloc failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pager
argument_list|,
name|M_VMPAGER
argument_list|)
expr_stmt|;
return|return
operator|(
name|VM_PAGER_NULL
operator|)
return|;
block|}
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|swt
operator|=
name|swtab
init|;
name|swt
operator|->
name|st_osize
condition|;
name|swt
operator|++
control|)
if|if
condition|(
name|size
operator|<=
name|swt
operator|->
name|st_osize
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
name|swt
operator|->
name|st_inuse
operator|++
expr_stmt|;
name|swt
operator|->
name|st_usecnt
operator|++
expr_stmt|;
endif|#
directive|endif
name|swp
operator|->
name|sw_osize
operator|=
name|size
expr_stmt|;
name|swp
operator|->
name|sw_bsize
operator|=
name|swt
operator|->
name|st_bsize
expr_stmt|;
name|swp
operator|->
name|sw_nblocks
operator|=
operator|(
name|btodb
argument_list|(
name|size
argument_list|)
operator|+
name|swp
operator|->
name|sw_bsize
operator|-
literal|1
operator|)
operator|/
name|swp
operator|->
name|sw_bsize
expr_stmt|;
name|swp
operator|->
name|sw_blocks
operator|=
operator|(
name|sw_blk_t
operator|)
name|malloc
argument_list|(
name|swp
operator|->
name|sw_nblocks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|swp
operator|->
name|sw_blocks
argument_list|)
argument_list|,
name|M_VMPGDATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_blocks
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|swp
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pager
argument_list|,
name|M_VMPAGER
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FAIL
condition|)
name|printf
argument_list|(
literal|"swpg_alloc: sw_blocks malloc failed\n"
argument_list|)
expr_stmt|;
name|swt
operator|->
name|st_inuse
operator|--
expr_stmt|;
name|swt
operator|->
name|st_usecnt
operator|--
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|swp
operator|->
name|sw_blocks
argument_list|,
name|swp
operator|->
name|sw_nblocks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|swp
operator|->
name|sw_blocks
argument_list|)
argument_list|)
expr_stmt|;
name|swp
operator|->
name|sw_poip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|handle
condition|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|swp
operator|->
name|sw_flags
operator|=
name|SW_NAMED
expr_stmt|;
name|queue_enter
argument_list|(
operator|&
name|swap_pager_list
argument_list|,
name|pager
argument_list|,
name|vm_pager_t
argument_list|,
name|pg_list
argument_list|)
expr_stmt|;
comment|/* 		 * Consistant with other pagers: return with object 		 * referenced.  Can't do this with handle == NULL 		 * since it might be the pageout daemon calling. 		 */
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|vm_object_enter
argument_list|(
name|object
argument_list|,
name|pager
argument_list|)
expr_stmt|;
name|vm_object_setpager
argument_list|(
name|object
argument_list|,
name|pager
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|swp
operator|->
name|sw_flags
operator|=
literal|0
expr_stmt|;
name|queue_init
argument_list|(
operator|&
name|pager
operator|->
name|pg_list
argument_list|)
expr_stmt|;
block|}
name|pager
operator|->
name|pg_handle
operator|=
name|handle
expr_stmt|;
name|pager
operator|->
name|pg_ops
operator|=
operator|&
name|swappagerops
expr_stmt|;
name|pager
operator|->
name|pg_type
operator|=
name|PG_SWAP
expr_stmt|;
name|pager
operator|->
name|pg_data
operator|=
operator|(
name|caddr_t
operator|)
name|swp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_ALLOC
condition|)
name|printf
argument_list|(
literal|"swpg_alloc: pg_data %x, %x of %x at %x\n"
argument_list|,
name|swp
argument_list|,
name|swp
operator|->
name|sw_nblocks
argument_list|,
name|swp
operator|->
name|sw_bsize
argument_list|,
name|swp
operator|->
name|sw_blocks
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pager
operator|)
return|;
block|}
end_function

begin_function
name|void
name|swap_pager_dealloc
parameter_list|(
name|pager
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|sw_blk_t
name|bp
decl_stmt|;
specifier|register
name|sw_pager_t
name|swp
decl_stmt|;
name|struct
name|swtab
modifier|*
name|swt
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* save panic time state */
if|if
condition|(
operator|(
name|swpagerdebug
operator|&
name|SDB_ANOMPANIC
operator|)
operator|&&
name|panicstr
condition|)
return|return;
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_ALLOC
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_dealloc(%x)\n"
argument_list|,
name|pager
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Remove from list right away so lookups will fail if we 	 * block for pageout completion. 	 */
name|swp
operator|=
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_flags
operator|&
name|SW_NAMED
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|swap_pager_list
argument_list|,
name|pager
argument_list|,
name|vm_pager_t
argument_list|,
name|pg_list
argument_list|)
expr_stmt|;
name|swp
operator|->
name|sw_flags
operator|&=
operator|~
name|SW_NAMED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|swt
operator|=
name|swtab
init|;
name|swt
operator|->
name|st_osize
condition|;
name|swt
operator|++
control|)
if|if
condition|(
name|swp
operator|->
name|sw_osize
operator|<=
name|swt
operator|->
name|st_osize
condition|)
break|break;
name|swt
operator|->
name|st_inuse
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Wait for all pageouts to finish and remove 	 * all entries from cleaning list. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
name|swp
operator|->
name|sw_poip
condition|)
block|{
name|swp
operator|->
name|sw_flags
operator||=
name|SW_WANTED
expr_stmt|;
name|assert_wait
argument_list|(
operator|(
name|int
operator|)
name|swp
argument_list|)
expr_stmt|;
name|thread_block
argument_list|()
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|swap_pager_clean
argument_list|(
name|VM_PAGE_NULL
argument_list|,
name|B_WRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Free left over swap blocks 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bp
operator|=
name|swp
operator|->
name|sw_blocks
init|;
name|i
operator|<
name|swp
operator|->
name|sw_nblocks
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
if|if
condition|(
name|bp
operator|->
name|swb_block
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_ALLOCBLK
operator||
name|SDB_FULL
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_dealloc: blk %x\n"
argument_list|,
name|bp
operator|->
name|swb_block
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rmfree
argument_list|(
name|swapmap
argument_list|,
name|swp
operator|->
name|sw_bsize
argument_list|,
name|bp
operator|->
name|swb_block
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free swap management resources 	 */
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|swp
operator|->
name|sw_blocks
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|swp
argument_list|,
name|M_VMPGDATA
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pager
argument_list|,
name|M_VMPAGER
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|swap_pager_getpage
argument_list|(
argument|pager
argument_list|,
argument|m
argument_list|,
argument|sync
argument_list|)
end_macro

begin_decl_stmt
name|vm_pager_t
name|pager
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_page_t
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|sync
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"swpg_getpage(%x, %x, %d)\n"
argument_list|,
name|pager
argument_list|,
name|m
argument_list|,
name|sync
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|swap_pager_io
argument_list|(
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
argument_list|,
name|m
argument_list|,
name|B_READ
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|swap_pager_putpage
argument_list|(
argument|pager
argument_list|,
argument|m
argument_list|,
argument|sync
argument_list|)
end_macro

begin_decl_stmt
name|vm_pager_t
name|pager
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_page_t
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|sync
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|flags
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"swpg_putpage(%x, %x, %d)\n"
argument_list|,
name|pager
argument_list|,
name|m
argument_list|,
name|sync
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pager
operator|==
name|VM_PAGER_NULL
condition|)
block|{
operator|(
name|void
operator|)
name|swap_pager_clean
argument_list|(
name|VM_PAGE_NULL
argument_list|,
name|B_WRITE
argument_list|)
expr_stmt|;
return|return;
block|}
name|flags
operator|=
name|B_WRITE
expr_stmt|;
if|if
condition|(
operator|!
name|sync
condition|)
name|flags
operator||=
name|B_ASYNC
expr_stmt|;
return|return
operator|(
name|swap_pager_io
argument_list|(
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|boolean_t
name|swap_pager_haspage
parameter_list|(
name|pager
parameter_list|,
name|offset
parameter_list|)
name|vm_pager_t
name|pager
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
block|{
specifier|register
name|sw_pager_t
name|swp
decl_stmt|;
specifier|register
name|sw_blk_t
name|swb
decl_stmt|;
name|int
name|ix
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_ALLOCBLK
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_haspage(%x, %x) "
argument_list|,
name|pager
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|swp
operator|=
operator|(
name|sw_pager_t
operator|)
name|pager
operator|->
name|pg_data
expr_stmt|;
name|ix
operator|=
name|offset
operator|/
name|dbtob
argument_list|(
name|swp
operator|->
name|sw_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_blocks
operator|==
name|NULL
operator|||
name|ix
operator|>=
name|swp
operator|->
name|sw_nblocks
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FAIL
operator||
name|SDB_FOLLOW
operator||
name|SDB_ALLOCBLK
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_haspage: %x bad offset %x, ix %x\n"
argument_list|,
name|swp
operator|->
name|sw_blocks
argument_list|,
name|offset
argument_list|,
name|ix
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|swb
operator|=
operator|&
name|swp
operator|->
name|sw_blocks
index|[
name|ix
index|]
expr_stmt|;
if|if
condition|(
name|swb
operator|->
name|swb_block
condition|)
name|ix
operator|=
name|atop
argument_list|(
name|offset
operator|%
name|dbtob
argument_list|(
name|swp
operator|->
name|sw_bsize
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_ALLOCBLK
condition|)
name|printf
argument_list|(
literal|"%x blk %x+%x "
argument_list|,
name|swp
operator|->
name|sw_blocks
argument_list|,
name|swb
operator|->
name|swb_block
argument_list|,
name|ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_ALLOCBLK
operator|)
condition|)
name|printf
argument_list|(
literal|"-> %c\n"
argument_list|,
literal|"FT"
index|[
name|swb
operator|->
name|swb_block
operator|&&
operator|(
name|swb
operator|->
name|swb_mask
operator|&
operator|(
literal|1
operator|<<
name|ix
operator|)
operator|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|swb
operator|->
name|swb_block
operator|&&
operator|(
name|swb
operator|->
name|swb_mask
operator|&
operator|(
literal|1
operator|<<
name|ix
operator|)
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scaled down version of swap().  * Assumes that PAGE_SIZE< MAXPHYS; i.e. only one operation needed.  * BOGUS:  lower level IO routines expect a KVA so we have to map our  * provided physical page into the KVA to keep them happy.  */
end_comment

begin_expr_stmt
name|swap_pager_io
argument_list|(
name|swp
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
specifier|register
name|sw_pager_t
name|swp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|vm_page_t
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|sw_blk_t
name|swb
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|vm_offset_t
name|kva
decl_stmt|,
name|off
decl_stmt|;
name|swp_clean_t
name|spc
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* save panic time state */
if|if
condition|(
operator|(
name|swpagerdebug
operator|&
name|SDB_ANOMPANIC
operator|)
operator|&&
name|panicstr
condition|)
return|return;
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FOLLOW
operator||
name|SDB_IO
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_io(%x, %x, %x)\n"
argument_list|,
name|swp
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * For reads (pageins) and synchronous writes, we clean up 	 * all completed async pageouts and check to see if this 	 * page is currently being cleaned.  If it is, we just wait 	 * til the operation is done before continuing. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
name|swap_pager_clean
argument_list|(
name|m
argument_list|,
name|flags
operator|&
name|B_READ
argument_list|)
condition|)
block|{
name|swp
operator|->
name|sw_flags
operator||=
name|SW_WANTED
expr_stmt|;
name|assert_wait
argument_list|(
operator|(
name|int
operator|)
name|swp
argument_list|)
expr_stmt|;
name|thread_block
argument_list|()
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For async writes (pageouts), we cleanup completed pageouts so 	 * that all available resources are freed.  Also tells us if this 	 * page is already being cleaned.  If it is, or no resources 	 * are available, we try again later. 	 */
elseif|else
if|if
condition|(
name|swap_pager_clean
argument_list|(
name|m
argument_list|,
name|B_WRITE
argument_list|)
operator|||
name|queue_empty
argument_list|(
operator|&
name|swap_pager_free
argument_list|)
condition|)
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
comment|/* 	 * Determine swap block and allocate as necessary. 	 */
name|off
operator|=
name|m
operator|->
name|offset
operator|+
name|m
operator|->
name|object
operator|->
name|paging_offset
expr_stmt|;
name|ix
operator|=
name|off
operator|/
name|dbtob
argument_list|(
name|swp
operator|->
name|sw_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sw_blocks
operator|==
name|NULL
operator|||
name|ix
operator|>=
name|swp
operator|->
name|sw_nblocks
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FAIL
condition|)
name|printf
argument_list|(
literal|"swpg_io: bad offset %x+%x(%d) in %x\n"
argument_list|,
name|m
operator|->
name|offset
argument_list|,
name|m
operator|->
name|object
operator|->
name|paging_offset
argument_list|,
name|ix
argument_list|,
name|swp
operator|->
name|sw_blocks
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
block|}
name|swb
operator|=
operator|&
name|swp
operator|->
name|sw_blocks
index|[
name|ix
index|]
expr_stmt|;
name|off
operator|=
name|off
operator|%
name|dbtob
argument_list|(
name|swp
operator|->
name|sw_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
block|{
if|if
condition|(
name|swb
operator|->
name|swb_block
operator|==
literal|0
operator|||
operator|(
name|swb
operator|->
name|swb_mask
operator|&
operator|(
literal|1
operator|<<
name|atop
argument_list|(
name|off
argument_list|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_ALLOCBLK
operator||
name|SDB_FAIL
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_io: %x bad read: blk %x+%x, mask %x, off %x+%x\n"
argument_list|,
name|swp
operator|->
name|sw_blocks
argument_list|,
name|swb
operator|->
name|swb_block
argument_list|,
name|atop
argument_list|(
name|off
argument_list|)
argument_list|,
name|swb
operator|->
name|swb_mask
argument_list|,
name|m
operator|->
name|offset
argument_list|,
name|m
operator|->
name|object
operator|->
name|paging_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX: should we zero page here?? */
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|swb
operator|->
name|swb_block
operator|==
literal|0
condition|)
block|{
name|swb
operator|->
name|swb_block
operator|=
name|rmalloc
argument_list|(
name|swapmap
argument_list|,
name|swp
operator|->
name|sw_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|swb
operator|->
name|swb_block
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FAIL
condition|)
name|printf
argument_list|(
literal|"swpg_io: rmalloc of %x failed\n"
argument_list|,
name|swp
operator|->
name|sw_bsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|VM_PAGER_FAIL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
operator|(
name|SDB_FULL
operator||
name|SDB_ALLOCBLK
operator|)
condition|)
name|printf
argument_list|(
literal|"swpg_io: %x alloc blk %x at ix %x\n"
argument_list|,
name|swp
operator|->
name|sw_blocks
argument_list|,
name|swb
operator|->
name|swb_block
argument_list|,
name|ix
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Allocate a kernel virtual address and initialize so that PTE 	 * is available for lower level IO drivers. 	 */
name|kva
operator|=
name|vm_pager_map_page
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Get a swap buffer header and perform the IO 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
name|bswlist
operator|.
name|av_forw
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_ANOM
condition|)
name|printf
argument_list|(
literal|"swpg_io: wait on swbuf for %x (%d)\n"
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bswlist
operator|.
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|bswlist
argument_list|,
name|PSWP
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|bp
operator|=
name|bswlist
operator|.
name|av_forw
expr_stmt|;
name|bswlist
operator|.
name|av_forw
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
operator|(
name|flags
operator|&
name|B_READ
operator|)
expr_stmt|;
name|bp
operator|->
name|b_proc
operator|=
operator|&
name|proc
index|[
literal|0
index|]
expr_stmt|;
comment|/* XXX (but without B_PHYS set this is ok) */
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
operator|(
name|caddr_t
operator|)
name|kva
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|swb
operator|->
name|swb_block
operator|+
name|btodb
argument_list|(
name|off
argument_list|)
expr_stmt|;
name|VHOLD
argument_list|(
name|swapdev_vp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|=
name|swapdev_vp
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|swapdev_vp
operator|->
name|v_rdev
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
name|swapdev_vp
operator|->
name|v_numoutput
operator|++
expr_stmt|;
comment|/* 	 * If this is an async write we set up additional buffer fields 	 * and place a "cleaning" entry on the inuse queue. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|B_READ
operator||
name|B_ASYNC
operator|)
operator|)
operator|==
name|B_ASYNC
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|queue_empty
argument_list|(
operator|&
name|swap_pager_free
argument_list|)
condition|)
name|panic
argument_list|(
literal|"swpg_io: lost spc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|queue_remove_first
argument_list|(
operator|&
name|swap_pager_free
argument_list|,
name|spc
argument_list|,
name|swp_clean_t
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|spc
operator|->
name|spc_flags
operator|!=
name|SPC_FREE
condition|)
name|panic
argument_list|(
literal|"swpg_io: bad free spc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|spc
operator|->
name|spc_flags
operator|=
name|SPC_BUSY
expr_stmt|;
name|spc
operator|->
name|spc_bp
operator|=
name|bp
expr_stmt|;
name|spc
operator|->
name|spc_swp
operator|=
name|swp
expr_stmt|;
name|spc
operator|->
name|spc_kva
operator|=
name|kva
expr_stmt|;
name|spc
operator|->
name|spc_m
operator|=
name|m
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|m
operator|->
name|pagerowned
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|b_flags
operator||=
name|B_CALL
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
name|swap_pager_iodone
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|swp
operator|->
name|sw_poip
operator|++
expr_stmt|;
name|queue_enter
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|,
name|spc
argument_list|,
name|swp_clean_t
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|swap_pager_poip
operator|++
expr_stmt|;
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_WRITE
condition|)
name|printf
argument_list|(
literal|"swpg_io: write: bp=%x swp=%x spc=%x poip=%d\n"
argument_list|,
name|bp
argument_list|,
name|swp
argument_list|,
name|spc
argument_list|,
name|swp
operator|->
name|sw_poip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|swpagerdebug
operator|&
name|SDB_ALLOCBLK
operator|)
operator|&&
operator|(
name|swb
operator|->
name|swb_mask
operator|&
operator|(
literal|1
operator|<<
name|atop
argument_list|(
name|off
argument_list|)
operator|)
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"swpg_io: %x write blk %x+%x\n"
argument_list|,
name|swp
operator|->
name|sw_blocks
argument_list|,
name|swb
operator|->
name|swb_block
argument_list|,
name|atop
argument_list|(
name|off
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|swb
operator|->
name|swb_mask
operator||=
operator|(
literal|1
operator|<<
name|atop
argument_list|(
name|off
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * XXX: Block write faults til we are done. 		 */
name|m
operator|->
name|page_lock
operator|=
name|VM_PROT_WRITE
expr_stmt|;
name|m
operator|->
name|unlock_request
operator|=
name|VM_PROT_ALL
expr_stmt|;
name|pmap_copy_on_write
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_IO
condition|)
name|printf
argument_list|(
literal|"swpg_io: IO start: bp %x, db %x, va %x, pa %x\n"
argument_list|,
name|bp
argument_list|,
name|swb
operator|->
name|swb_block
operator|+
name|btodb
argument_list|(
name|off
argument_list|)
argument_list|,
name|kva
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|B_READ
operator||
name|B_ASYNC
operator|)
operator|)
operator|==
name|B_ASYNC
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_IO
condition|)
name|printf
argument_list|(
literal|"swpg_io:  IO started: bp %x\n"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|VM_PAGER_PEND
operator|)
return|;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
name|swap_pager_piip
operator|++
expr_stmt|;
else|else
name|swap_pager_poip
operator|++
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
block|{
name|assert_wait
argument_list|(
operator|(
name|int
operator|)
name|bp
argument_list|)
expr_stmt|;
name|thread_block
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
operator|--
name|swap_pager_piip
expr_stmt|;
else|else
operator|--
name|swap_pager_poip
expr_stmt|;
endif|#
directive|endif
name|rv
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
condition|?
name|VM_PAGER_FAIL
else|:
name|VM_PAGER_OK
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_BUSY
operator||
name|B_WANTED
operator||
name|B_PHYS
operator||
name|B_PAGET
operator||
name|B_UAREA
operator||
name|B_DIRTY
operator|)
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
name|bswlist
operator|.
name|av_forw
expr_stmt|;
name|bswlist
operator|.
name|av_forw
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|brelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bswlist
operator|.
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bswlist
operator|.
name|b_flags
operator|&=
operator|~
name|B_WANTED
expr_stmt|;
name|thread_wakeup
argument_list|(
operator|(
name|int
operator|)
operator|&
name|bswlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|&&
name|rv
operator|==
name|VM_PAGER_OK
condition|)
block|{
name|m
operator|->
name|clean
operator|=
literal|1
expr_stmt|;
name|pmap_clear_modify
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_IO
condition|)
name|printf
argument_list|(
literal|"swpg_io:  IO done: bp %x, rv %d\n"
argument_list|,
name|bp
argument_list|,
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|swpagerdebug
operator|&
name|SDB_FAIL
operator|)
operator|&&
name|rv
operator|==
name|VM_PAGER_FAIL
condition|)
name|printf
argument_list|(
literal|"swpg_io: IO error\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vm_pager_unmap_page
argument_list|(
name|kva
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_block

begin_function
name|boolean_t
name|swap_pager_clean
parameter_list|(
name|m
parameter_list|,
name|rw
parameter_list|)
name|vm_page_t
name|m
decl_stmt|;
name|int
name|rw
decl_stmt|;
block|{
specifier|register
name|swp_clean_t
name|spc
decl_stmt|,
name|tspc
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* save panic time state */
if|if
condition|(
operator|(
name|swpagerdebug
operator|&
name|SDB_ANOMPANIC
operator|)
operator|&&
name|panicstr
condition|)
return|return;
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"swpg_clean(%x, %d)\n"
argument_list|,
name|m
argument_list|,
name|rw
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tspc
operator|=
name|SWP_CLEAN_NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Look up and removal from inuse list must be done 		 * at splbio() to avoid conflicts with swap_pager_iodone. 		 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|spc
operator|=
operator|(
name|swp_clean_t
operator|)
name|queue_first
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|queue_end
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|,
operator|(
name|queue_entry_t
operator|)
name|spc
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|spc
operator|->
name|spc_flags
operator|&
name|SPC_DONE
operator|)
operator|&&
name|swap_pager_finish
argument_list|(
name|spc
argument_list|)
condition|)
block|{
name|queue_remove
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|,
name|spc
argument_list|,
name|swp_clean_t
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m
operator|&&
name|m
operator|==
name|spc
operator|->
name|spc_m
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_ANOM
condition|)
name|printf
argument_list|(
literal|"swpg_clean: %x on list, flags %x\n"
argument_list|,
name|m
argument_list|,
name|spc
operator|->
name|spc_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tspc
operator|=
name|spc
expr_stmt|;
block|}
name|spc
operator|=
operator|(
name|swp_clean_t
operator|)
name|queue_next
argument_list|(
operator|&
name|spc
operator|->
name|spc_list
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * No operations done, thats all we can do for now. 		 */
if|if
condition|(
name|queue_end
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|,
operator|(
name|queue_entry_t
operator|)
name|spc
argument_list|)
condition|)
break|break;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * The desired page was found to be busy earlier in 		 * the scan but has since completed. 		 */
if|if
condition|(
name|tspc
operator|&&
name|tspc
operator|==
name|spc
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_ANOM
condition|)
name|printf
argument_list|(
literal|"swpg_clean: %x done while looking\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tspc
operator|=
name|SWP_CLEAN_NULL
expr_stmt|;
block|}
name|spc
operator|->
name|spc_flags
operator|=
name|SPC_FREE
expr_stmt|;
name|vm_pager_unmap_page
argument_list|(
name|spc
operator|->
name|spc_kva
argument_list|)
expr_stmt|;
name|queue_enter
argument_list|(
operator|&
name|swap_pager_free
argument_list|,
name|spc
argument_list|,
name|swp_clean_t
argument_list|,
name|spc_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_WRITE
condition|)
name|printf
argument_list|(
literal|"swpg_clean: free spc %x\n"
argument_list|,
name|spc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * If we found that the desired page is already being cleaned 	 * mark it so that swap_pager_iodone() will not set the clean 	 * flag before the pageout daemon has another chance to clean it. 	 */
if|if
condition|(
name|tspc
operator|&&
name|rw
operator|==
name|B_WRITE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_ANOM
condition|)
name|printf
argument_list|(
literal|"swpg_clean: %x on clean list\n"
argument_list|,
name|tspc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tspc
operator|->
name|spc_flags
operator||=
name|SPC_DIRTY
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_WRITE
condition|)
name|printf
argument_list|(
literal|"swpg_clean: return %d\n"
argument_list|,
name|tspc
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|swpagerdebug
operator|&
name|SDB_ANOM
operator|)
operator|&&
name|tspc
condition|)
name|printf
argument_list|(
literal|"swpg_clean: %s of cleaning page %x\n"
argument_list|,
name|rw
operator|==
name|B_READ
condition|?
literal|"get"
else|:
literal|"put"
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|tspc
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|swap_pager_finish
argument_list|(
name|spc
argument_list|)
specifier|register
name|swp_clean_t
name|spc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|vm_object_t
name|object
init|=
name|spc
operator|->
name|spc_m
operator|->
name|object
decl_stmt|;
comment|/* 	 * Mark the paging operation as done. 	 * (XXX) If we cannot get the lock, leave it til later. 	 * (XXX) Also we are assuming that an async write is a 	 *       pageout operation that has incremented the counter. 	 */
if|if
condition|(
operator|!
name|vm_object_lock_try
argument_list|(
name|object
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|spc
operator|->
name|spc_m
operator|->
name|pagerowned
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|object
operator|->
name|paging_in_progress
operator|==
literal|0
condition|)
name|thread_wakeup
argument_list|(
operator|(
name|int
operator|)
name|object
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: this isn't even close to the right thing to do, 	 * introduces a variety of race conditions. 	 * 	 * If dirty, vm_pageout() has attempted to clean the page 	 * again.  In this case we do not do anything as we will 	 * see the page again shortly.  Otherwise, if no error mark 	 * as clean and inform the pmap system.  If error, mark as 	 * dirty so we will try again (XXX: could get stuck doing 	 * this, should give up after awhile). 	 */
if|if
condition|(
operator|(
name|spc
operator|->
name|spc_flags
operator|&
name|SPC_DIRTY
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|spc
operator|->
name|spc_flags
operator|&
name|SPC_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"swap_pager: clean of %x failed\n"
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|spc
operator|->
name|spc_m
argument_list|)
argument_list|)
expr_stmt|;
name|spc
operator|->
name|spc_m
operator|->
name|laundry
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|spc
operator|->
name|spc_m
operator|->
name|clean
operator|=
name|TRUE
expr_stmt|;
name|pmap_clear_modify
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|spc
operator|->
name|spc_m
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * XXX: allow blocked write faults to continue 	 */
name|spc
operator|->
name|spc_m
operator|->
name|page_lock
operator|=
name|spc
operator|->
name|spc_m
operator|->
name|unlock_request
operator|=
name|VM_PROT_NONE
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|spc
operator|->
name|spc_m
argument_list|)
expr_stmt|;
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|swap_pager_iodone
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|swp_clean_t
name|spc
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* save panic time state */
if|if
condition|(
operator|(
name|swpagerdebug
operator|&
name|SDB_ANOMPANIC
operator|)
operator|&&
name|panicstr
condition|)
return|return;
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"swpg_iodone(%x)\n"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|spc
operator|=
operator|(
name|swp_clean_t
operator|)
name|queue_first
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|queue_end
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|,
operator|(
name|queue_entry_t
operator|)
name|spc
argument_list|)
condition|)
block|{
if|if
condition|(
name|spc
operator|->
name|spc_bp
operator|==
name|bp
condition|)
break|break;
name|spc
operator|=
operator|(
name|swp_clean_t
operator|)
name|queue_next
argument_list|(
operator|&
name|spc
operator|->
name|spc_list
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|queue_end
argument_list|(
operator|&
name|swap_pager_inuse
argument_list|,
operator|(
name|queue_entry_t
operator|)
name|spc
argument_list|)
condition|)
name|panic
argument_list|(
literal|"swpg_iodone: bp not found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|spc
operator|->
name|spc_flags
operator|&=
operator|~
name|SPC_BUSY
expr_stmt|;
name|spc
operator|->
name|spc_flags
operator||=
name|SPC_DONE
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
name|spc
operator|->
name|spc_flags
operator||=
name|SPC_ERROR
expr_stmt|;
name|spc
operator|->
name|spc_bp
operator|=
name|NULL
expr_stmt|;
name|blk
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|--
name|swap_pager_poip
expr_stmt|;
if|if
condition|(
name|swpagerdebug
operator|&
name|SDB_WRITE
condition|)
name|printf
argument_list|(
literal|"swpg_iodone: bp=%x swp=%x flags=%x spc=%x poip=%x\n"
argument_list|,
name|bp
argument_list|,
name|spc
operator|->
name|spc_swp
argument_list|,
name|spc
operator|->
name|spc_swp
operator|->
name|sw_flags
argument_list|,
name|spc
argument_list|,
name|spc
operator|->
name|spc_swp
operator|->
name|sw_poip
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|spc
operator|->
name|spc_swp
operator|->
name|sw_poip
operator|--
expr_stmt|;
if|if
condition|(
name|spc
operator|->
name|spc_swp
operator|->
name|sw_flags
operator|&
name|SW_WANTED
condition|)
block|{
name|spc
operator|->
name|spc_swp
operator|->
name|sw_flags
operator|&=
operator|~
name|SW_WANTED
expr_stmt|;
name|thread_wakeup
argument_list|(
operator|(
name|int
operator|)
name|spc
operator|->
name|spc_swp
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_BUSY
operator||
name|B_WANTED
operator||
name|B_PHYS
operator||
name|B_PAGET
operator||
name|B_UAREA
operator||
name|B_DIRTY
operator|)
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
name|bswlist
operator|.
name|av_forw
expr_stmt|;
name|bswlist
operator|.
name|av_forw
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|brelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bswlist
operator|.
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bswlist
operator|.
name|b_flags
operator|&=
operator|~
name|B_WANTED
expr_stmt|;
name|thread_wakeup
argument_list|(
operator|(
name|int
operator|)
operator|&
name|bswlist
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * XXX: this isn't even close to the right thing to do, 	 * introduces a variety of race conditions. 	 * 	 * If dirty, vm_pageout() has attempted to clean the page 	 * again.  In this case we do not do anything as we will 	 * see the page again shortly.  Otherwise, if no error mark 	 * as clean and inform the pmap system.  If error, mark as 	 * dirty so we will try again (XXX: could get stuck doing 	 * this, should give up after awhile). 	 */
block|if ((spc->spc_flags& SPC_DIRTY) == 0) { 		if (spc->spc_flags& SPC_ERROR) { 			printf("swap_pager: clean of %x (block %x) failed\n", 			       VM_PAGE_TO_PHYS(spc->spc_m), blk); 			spc->spc_m->laundry = TRUE; 		} else { 			spc->spc_m->clean = TRUE; 			pmap_clear_modify(VM_PAGE_TO_PHYS(spc->spc_m)); 		} 	}
comment|/* 	 * XXX: allow blocked write faults to continue 	 */
block|spc->spc_m->page_lock = spc->spc_m->unlock_request = VM_PROT_NONE; 	PAGE_WAKEUP(spc->spc_m);
endif|#
directive|endif
name|thread_wakeup
argument_list|(
operator|(
name|int
operator|)
operator|&
name|vm_pages_needed
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

