begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * The Mach Operating System project at Carnegie-Mellon University.  *  * %sccs.include.redist.c%  *  *	@(#)vm_map.c	7.5 (Berkeley) %G%  *  *  * Copyright (c) 1987, 1990 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Avadis Tevanian, Jr., Michael Wayne Young  *   * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND   * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  *	Virtual memory mapping module.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"vm_page.h"
end_include

begin_include
include|#
directive|include
file|"vm_object.h"
end_include

begin_comment
comment|/*  *	Virtual memory maps provide for the mapping, protection,  *	and sharing of virtual memory objects.  In addition,  *	this module provides for an efficient virtual copy of  *	memory from one map to another.  *  *	Synchronization is required prior to most operations.  *  *	Maps consist of an ordered doubly-linked list of simple  *	entries; a single hint is used to speed up lookups.  *  *	In order to properly represent the sharing of virtual  *	memory regions among maps, the map structure is bi-level.  *	Top-level ("address") maps refer to regions of sharable  *	virtual memory.  These regions are implemented as  *	("sharing") maps, which then refer to the actual virtual  *	memory objects.  When two address maps "share" memory,  *	their top-level maps both have references to the same  *	sharing map.  When memory is virtual-copied from one  *	address map to another, the references in the sharing  *	maps are actually copied -- no copying occurs at the  *	virtual memory object level.  *  *	Since portions of maps are specified by start/end addreses,  *	which may not align with existing map entries, all  *	routines merely "clip" entries to these start/end values.  *	[That is, an entry is split into two, bordering at a  *	start or end value.]  Note that these clippings may not  *	always be necessary (as the two resulting entries are then  *	not changed); however, the clipping is done for convenience.  *	No attempt is currently made to "glue back together" two  *	abutting entries.  *  *	As mentioned above, virtual copy operations are performed  *	by copying VM object references from one sharing map to  *	another, and then marking both regions as copy-on-write.  *	It is important to note that only one writeable reference  *	to a VM object region exists in any map -- this means that  *	shadow object creation can be delayed until a write operation  *	occurs.  */
end_comment

begin_comment
comment|/*  *	vm_map_startup:  *  *	Initialize the vm_map module.  Must be called before  *	any other vm_map routines.  *  *	Map and entry structures are allocated from the general  *	purpose memory pool with some exceptions:  *  *	- The kernel map and kmem submap are allocated statically.  *	- Kernel map entries are allocated out of a static pool.  *  *	These restrictions are necessary since malloc() uses the  *	maps and requires map entries.  */
end_comment

begin_decl_stmt
name|vm_offset_t
name|kentry_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_size_t
name|kentry_data_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_map_entry_t
name|kentry_free
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_map_t
name|kmap_free
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|vm_map_startup
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|vm_map_entry_t
name|mep
decl_stmt|;
name|vm_map_t
name|mp
decl_stmt|;
comment|/* 	 * Static map structures for allocation before initialization of 	 * kernel map or kmem map.  vm_map_create knows how to deal with them. 	 */
name|kmap_free
operator|=
name|mp
operator|=
operator|(
name|vm_map_t
operator|)
name|kentry_data
expr_stmt|;
name|i
operator|=
name|MAX_KMAP
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
block|{
name|mp
operator|->
name|header
operator|.
name|next
operator|=
call|(
name|vm_map_entry_t
call|)
argument_list|(
name|mp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mp
operator|++
expr_stmt|;
block|}
name|mp
operator|++
operator|->
name|header
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Form a free list of statically allocated kernel map entries 	 * with the rest. 	 */
name|kentry_free
operator|=
name|mep
operator|=
operator|(
name|vm_map_entry_t
operator|)
name|mp
expr_stmt|;
name|i
operator|=
operator|(
name|kentry_data_size
operator|-
name|MAX_KMAP
operator|*
sizeof|sizeof
expr|*
name|mp
operator|)
operator|/
sizeof|sizeof
expr|*
name|mep
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
block|{
name|mep
operator|->
name|next
operator|=
name|mep
operator|+
literal|1
expr_stmt|;
name|mep
operator|++
expr_stmt|;
block|}
name|mep
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a vmspace structure, including a vm_map and pmap,  * and initialize those structures.  The refcnt is set to 1.  * The remaining fields must be initialized by the caller.  */
end_comment

begin_function
name|struct
name|vmspace
modifier|*
name|vmspace_alloc
parameter_list|(
name|min
parameter_list|,
name|max
parameter_list|,
name|pageable
parameter_list|)
name|vm_offset_t
name|min
decl_stmt|,
name|max
decl_stmt|;
name|int
name|pageable
decl_stmt|;
block|{
specifier|register
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|MALLOC
argument_list|(
name|vm
argument_list|,
expr|struct
name|vmspace
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmspace
argument_list|)
argument_list|,
name|M_VMMAP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|vm
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|vm
operator|->
name|vm_startcopy
operator|-
operator|(
name|caddr_t
operator|)
name|vm
argument_list|)
expr_stmt|;
name|vm_map_init
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|pageable
argument_list|)
expr_stmt|;
name|pmap_pinit
argument_list|(
operator|&
name|vm
operator|->
name|vm_pmap
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_map
operator|.
name|pmap
operator|=
operator|&
name|vm
operator|->
name|vm_pmap
expr_stmt|;
comment|/* XXX */
name|vm
operator|->
name|vm_refcnt
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|vm
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vmspace_free
parameter_list|(
name|vm
parameter_list|)
specifier|register
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
block|{
if|if
condition|(
operator|--
name|vm
operator|->
name|vm_refcnt
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Lock the map, to wait out all other references to it. 		 * Delete all of the mappings and pages they hold, 		 * then call the pmap module to reclaim anything left. 		 */
name|vm_map_lock
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_delete
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|vm
operator|->
name|vm_map
operator|.
name|min_offset
argument_list|,
name|vm
operator|->
name|vm_map
operator|.
name|max_offset
argument_list|)
expr_stmt|;
name|pmap_release
argument_list|(
operator|&
name|vm
operator|->
name|vm_pmap
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|vm
argument_list|,
name|M_VMMAP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_map_create:  *  *	Creates and returns a new empty VM map with  *	the given physical map structure, and having  *	the given lower and upper address bounds.  */
end_comment

begin_function
name|vm_map_t
name|vm_map_create
parameter_list|(
name|pmap
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|pageable
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|min
decl_stmt|,
name|max
decl_stmt|;
name|boolean_t
name|pageable
decl_stmt|;
block|{
specifier|register
name|vm_map_t
name|result
decl_stmt|;
specifier|extern
name|vm_map_t
name|kernel_map
decl_stmt|,
name|kmem_map
decl_stmt|;
if|if
condition|(
name|kmem_map
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|kmap_free
expr_stmt|;
name|kmap_free
operator|=
operator|(
name|vm_map_t
operator|)
name|result
operator|->
name|header
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"vm_map_create: out of maps"
argument_list|)
expr_stmt|;
block|}
else|else
name|MALLOC
argument_list|(
name|result
argument_list|,
name|vm_map_t
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map
argument_list|)
argument_list|,
name|M_VMMAP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|vm_map_init
argument_list|(
name|result
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|pageable
argument_list|)
expr_stmt|;
name|result
operator|->
name|pmap
operator|=
name|pmap
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize an existing vm_map structure  * such as that in the vmspace structure.  * The pmap is set elsewhere.  */
end_comment

begin_function
name|void
name|vm_map_init
parameter_list|(
name|map
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|pageable
parameter_list|)
specifier|register
name|struct
name|vm_map
modifier|*
name|map
decl_stmt|;
name|vm_offset_t
name|min
decl_stmt|,
name|max
decl_stmt|;
name|boolean_t
name|pageable
decl_stmt|;
block|{
name|map
operator|->
name|header
operator|.
name|next
operator|=
name|map
operator|->
name|header
operator|.
name|prev
operator|=
operator|&
name|map
operator|->
name|header
expr_stmt|;
name|map
operator|->
name|nentries
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|map
operator|->
name|is_main_map
operator|=
name|TRUE
expr_stmt|;
name|map
operator|->
name|min_offset
operator|=
name|min
expr_stmt|;
name|map
operator|->
name|max_offset
operator|=
name|max
expr_stmt|;
name|map
operator|->
name|entries_pageable
operator|=
name|pageable
expr_stmt|;
name|map
operator|->
name|first_free
operator|=
operator|&
name|map
operator|->
name|header
expr_stmt|;
name|map
operator|->
name|hint
operator|=
operator|&
name|map
operator|->
name|header
expr_stmt|;
name|map
operator|->
name|timestamp
operator|=
literal|0
expr_stmt|;
name|lock_init
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|simple_lock_init
argument_list|(
operator|&
name|map
operator|->
name|ref_lock
argument_list|)
expr_stmt|;
name|simple_lock_init
argument_list|(
operator|&
name|map
operator|->
name|hint_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_create:	[ internal use only ]  *  *	Allocates a VM map entry for insertion.  *	No entry fields are filled in.  This routine is  */
end_comment

begin_function
name|vm_map_entry_t
name|vm_map_entry_create
parameter_list|(
name|map
parameter_list|)
name|vm_map_t
name|map
decl_stmt|;
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
specifier|extern
name|vm_map_t
name|kernel_map
decl_stmt|,
name|kmem_map
decl_stmt|,
name|mb_map
decl_stmt|;
if|if
condition|(
name|map
operator|==
name|kernel_map
operator|||
name|map
operator|==
name|kmem_map
operator|||
name|map
operator|==
name|mb_map
condition|)
block|{
if|if
condition|(
name|entry
operator|=
name|kentry_free
condition|)
name|kentry_free
operator|=
name|kentry_free
operator|->
name|next
expr_stmt|;
block|}
else|else
name|MALLOC
argument_list|(
name|entry
argument_list|,
name|vm_map_entry_t
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm_map_entry
argument_list|)
argument_list|,
name|M_VMMAPENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"vm_map_entry_create: out of map entries"
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_dispose:	[ internal use only ]  *  *	Inverse of vm_map_entry_create.  */
end_comment

begin_function
name|void
name|vm_map_entry_dispose
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|)
name|vm_map_t
name|map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
block|{
specifier|extern
name|vm_map_t
name|kernel_map
decl_stmt|,
name|kmem_map
decl_stmt|,
name|mb_map
decl_stmt|;
if|if
condition|(
name|map
operator|==
name|kernel_map
operator|||
name|map
operator|==
name|kmem_map
operator|||
name|map
operator|==
name|mb_map
condition|)
block|{
name|entry
operator|->
name|next
operator|=
name|kentry_free
expr_stmt|;
name|kentry_free
operator|=
name|entry
expr_stmt|;
block|}
else|else
name|FREE
argument_list|(
name|entry
argument_list|,
name|M_VMMAPENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_{un,}link:  *  *	Insert/remove entries from maps.  */
end_comment

begin_define
define|#
directive|define
name|vm_map_entry_link
parameter_list|(
name|map
parameter_list|,
name|after_where
parameter_list|,
name|entry
parameter_list|)
define|\
value|{ \ 		(map)->nentries++; \ 		(entry)->prev = (after_where); \ 		(entry)->next = (after_where)->next; \ 		(entry)->prev->next = (entry); \ 		(entry)->next->prev = (entry); \ 		}
end_define

begin_define
define|#
directive|define
name|vm_map_entry_unlink
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|)
define|\
value|{ \ 		(map)->nentries--; \ 		(entry)->next->prev = (entry)->prev; \ 		(entry)->prev->next = (entry)->next; \ 		}
end_define

begin_comment
comment|/*  *	vm_map_reference:  *  *	Creates another valid reference to the given map.  *  */
end_comment

begin_function
name|void
name|vm_map_reference
parameter_list|(
name|map
parameter_list|)
specifier|register
name|vm_map_t
name|map
decl_stmt|;
block|{
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
return|return;
name|simple_lock
argument_list|(
operator|&
name|map
operator|->
name|ref_lock
argument_list|)
expr_stmt|;
name|map
operator|->
name|ref_count
operator|++
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|map
operator|->
name|ref_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_deallocate:  *  *	Removes a reference from the specified map,  *	destroying it if no references remain.  *	The map should not be locked.  */
end_comment

begin_function
name|void
name|vm_map_deallocate
parameter_list|(
name|map
parameter_list|)
specifier|register
name|vm_map_t
name|map
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
return|return;
name|simple_lock
argument_list|(
operator|&
name|map
operator|->
name|ref_lock
argument_list|)
expr_stmt|;
name|c
operator|=
operator|--
name|map
operator|->
name|ref_count
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|map
operator|->
name|ref_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
return|return;
block|}
comment|/* 	 *	Lock the map, to wait out all other references 	 *	to it. 	 */
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_delete
argument_list|(
name|map
argument_list|,
name|map
operator|->
name|min_offset
argument_list|,
name|map
operator|->
name|max_offset
argument_list|)
expr_stmt|;
name|pmap_destroy
argument_list|(
name|map
operator|->
name|pmap
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|map
argument_list|,
name|M_VMMAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_insert:	[ internal use only ]  *  *	Inserts the given whole VM object into the target  *	map at the specified address range.  The object's  *	size should match that of the address range.  *  *	Requires that the map be locked, and leaves it so.  */
end_comment

begin_macro
name|vm_map_insert
argument_list|(
argument|map
argument_list|,
argument|object
argument_list|,
argument|offset
argument_list|,
argument|start
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|vm_map_t
name|map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_object_t
name|object
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|vm_map_entry_t
name|new_entry
decl_stmt|;
specifier|register
name|vm_map_entry_t
name|prev_entry
decl_stmt|;
name|vm_map_entry_t
name|temp_entry
decl_stmt|;
comment|/* 	 *	Check that the start and end points are not bogus. 	 */
if|if
condition|(
operator|(
name|start
operator|<
name|map
operator|->
name|min_offset
operator|)
operator|||
operator|(
name|end
operator|>
name|map
operator|->
name|max_offset
operator|)
operator|||
operator|(
name|start
operator|>=
name|end
operator|)
condition|)
return|return
operator|(
name|KERN_INVALID_ADDRESS
operator|)
return|;
comment|/* 	 *	Find the entry prior to the proposed 	 *	starting address; if it's part of an 	 *	existing entry, this range is bogus. 	 */
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|temp_entry
argument_list|)
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
name|prev_entry
operator|=
name|temp_entry
expr_stmt|;
comment|/* 	 *	Assert that the next entry doesn't overlap the 	 *	end point. 	 */
if|if
condition|(
operator|(
name|prev_entry
operator|->
name|next
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|next
operator|->
name|start
operator|<
name|end
operator|)
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
comment|/* 	 *	See if we can avoid creating a new entry by 	 *	extending one of our neighbors. 	 */
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|prev_entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|end
operator|==
name|start
operator|)
operator|&&
operator|(
name|map
operator|->
name|is_main_map
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|is_a_map
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|is_sub_map
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|inheritance
operator|==
name|VM_INHERIT_DEFAULT
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|protection
operator|==
name|VM_PROT_DEFAULT
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|max_protection
operator|==
name|VM_PROT_DEFAULT
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|wired_count
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|vm_object_coalesce
argument_list|(
name|prev_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|NULL
argument_list|,
name|prev_entry
operator|->
name|offset
argument_list|,
operator|(
name|vm_offset_t
operator|)
literal|0
argument_list|,
call|(
name|vm_size_t
call|)
argument_list|(
name|prev_entry
operator|->
name|end
operator|-
name|prev_entry
operator|->
name|start
argument_list|)
argument_list|,
call|(
name|vm_size_t
call|)
argument_list|(
name|end
operator|-
name|prev_entry
operator|->
name|end
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 				 *	Coalesced the two objects - can extend 				 *	the previous map entry to include the 				 *	new range. 				 */
name|map
operator|->
name|size
operator|+=
operator|(
name|end
operator|-
name|prev_entry
operator|->
name|end
operator|)
expr_stmt|;
name|prev_entry
operator|->
name|end
operator|=
name|end
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 *	Create a new entry 	 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|new_entry
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|new_entry
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|new_entry
operator|->
name|is_a_map
operator|=
name|FALSE
expr_stmt|;
name|new_entry
operator|->
name|is_sub_map
operator|=
name|FALSE
expr_stmt|;
name|new_entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|object
expr_stmt|;
name|new_entry
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|new_entry
operator|->
name|copy_on_write
operator|=
name|FALSE
expr_stmt|;
name|new_entry
operator|->
name|needs_copy
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|is_main_map
condition|)
block|{
name|new_entry
operator|->
name|inheritance
operator|=
name|VM_INHERIT_DEFAULT
expr_stmt|;
name|new_entry
operator|->
name|protection
operator|=
name|VM_PROT_DEFAULT
expr_stmt|;
name|new_entry
operator|->
name|max_protection
operator|=
name|VM_PROT_DEFAULT
expr_stmt|;
name|new_entry
operator|->
name|wired_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *	Insert the new entry into the list 	 */
name|vm_map_entry_link
argument_list|(
name|map
argument_list|,
name|prev_entry
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
name|map
operator|->
name|size
operator|+=
name|new_entry
operator|->
name|end
operator|-
name|new_entry
operator|->
name|start
expr_stmt|;
comment|/* 	 *	Update the free space hint 	 */
if|if
condition|(
operator|(
name|map
operator|->
name|first_free
operator|==
name|prev_entry
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|end
operator|>=
name|new_entry
operator|->
name|start
operator|)
condition|)
name|map
operator|->
name|first_free
operator|=
name|new_entry
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	SAVE_HINT:  *  *	Saves the specified entry as the hint for  *	future lookups.  Performs necessary interlocks.  */
end_comment

begin_define
define|#
directive|define
name|SAVE_HINT
parameter_list|(
name|map
parameter_list|,
name|value
parameter_list|)
define|\
value|simple_lock(&(map)->hint_lock); \ 		(map)->hint = (value); \ 		simple_unlock(&(map)->hint_lock);
end_define

begin_comment
comment|/*  *	vm_map_lookup_entry:	[ internal use only ]  *  *	Finds the map entry containing (or  *	immediately preceding) the specified address  *	in the given map; the entry is returned  *	in the "entry" parameter.  The boolean  *	result indicates whether the address is  *	actually contained in the map.  */
end_comment

begin_function
name|boolean_t
name|vm_map_lookup_entry
parameter_list|(
name|map
parameter_list|,
name|address
parameter_list|,
name|entry
parameter_list|)
specifier|register
name|vm_map_t
name|map
decl_stmt|;
specifier|register
name|vm_offset_t
name|address
decl_stmt|;
name|vm_map_entry_t
modifier|*
name|entry
decl_stmt|;
comment|/* OUT */
block|{
specifier|register
name|vm_map_entry_t
name|cur
decl_stmt|;
specifier|register
name|vm_map_entry_t
name|last
decl_stmt|;
comment|/* 	 *	Start looking either from the head of the 	 *	list, or from the hint. 	 */
name|simple_lock
argument_list|(
operator|&
name|map
operator|->
name|hint_lock
argument_list|)
expr_stmt|;
name|cur
operator|=
name|map
operator|->
name|hint
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|map
operator|->
name|hint_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
operator|&
name|map
operator|->
name|header
condition|)
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|address
operator|>=
name|cur
operator|->
name|start
condition|)
block|{
comment|/* 		 *	Go from hint to end of list. 		 * 		 *	But first, make a quick check to see if 		 *	we are already looking at the entry we 		 *	want (which is usually the case). 		 *	Note also that we don't need to save the hint 		 *	here... it is the same hint (unless we are 		 *	at the header, in which case the hint didn't 		 *	buy us anything anyway). 		 */
name|last
operator|=
operator|&
name|map
operator|->
name|header
expr_stmt|;
if|if
condition|(
operator|(
name|cur
operator|!=
name|last
operator|)
operator|&&
operator|(
name|cur
operator|->
name|end
operator|>
name|address
operator|)
condition|)
block|{
operator|*
name|entry
operator|=
name|cur
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 *	Go from start to hint, *inclusively* 		 */
name|last
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|cur
operator|=
name|map
operator|->
name|header
operator|.
name|next
expr_stmt|;
block|}
comment|/* 	 *	Search linearly 	 */
while|while
condition|(
name|cur
operator|!=
name|last
condition|)
block|{
if|if
condition|(
name|cur
operator|->
name|end
operator|>
name|address
condition|)
block|{
if|if
condition|(
name|address
operator|>=
name|cur
operator|->
name|start
condition|)
block|{
comment|/* 				 *	Save this lookup for future 				 *	hints, and return 				 */
operator|*
name|entry
operator|=
name|cur
expr_stmt|;
name|SAVE_HINT
argument_list|(
name|map
argument_list|,
name|cur
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
break|break;
block|}
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|entry
operator|=
name|cur
operator|->
name|prev
expr_stmt|;
name|SAVE_HINT
argument_list|(
name|map
argument_list|,
operator|*
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find sufficient space for `length' bytes in the given map, starting at  * `start'.  The map must be locked.  Returns 0 on success, 1 on no space.  */
end_comment

begin_function
name|int
name|vm_map_findspace
parameter_list|(
name|map
parameter_list|,
name|start
parameter_list|,
name|length
parameter_list|,
name|addr
parameter_list|)
specifier|register
name|vm_map_t
name|map
decl_stmt|;
specifier|register
name|vm_offset_t
name|start
decl_stmt|;
name|vm_size_t
name|length
decl_stmt|;
name|vm_offset_t
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
name|vm_map_entry_t
name|entry
decl_stmt|,
name|next
decl_stmt|;
specifier|register
name|vm_offset_t
name|end
decl_stmt|;
if|if
condition|(
name|start
operator|<
name|map
operator|->
name|min_offset
condition|)
name|start
operator|=
name|map
operator|->
name|min_offset
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|map
operator|->
name|max_offset
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Look for the first possible address; if there's already 	 * something at this address, we have to start after it. 	 */
if|if
condition|(
name|start
operator|==
name|map
operator|->
name|min_offset
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|=
name|map
operator|->
name|first_free
operator|)
operator|!=
operator|&
name|map
operator|->
name|header
condition|)
name|start
operator|=
name|entry
operator|->
name|end
expr_stmt|;
block|}
else|else
block|{
name|vm_map_entry_t
name|tmp
decl_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
name|start
operator|=
name|tmp
operator|->
name|end
expr_stmt|;
name|entry
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* 	 * Look through the rest of the map, trying to fit a new region in 	 * the gap between existing regions, or after the very last region. 	 */
for|for
control|(
init|;
condition|;
name|start
operator|=
operator|(
name|entry
operator|=
name|next
operator|)
operator|->
name|end
control|)
block|{
comment|/* 		 * Find the end of the proposed new region.  Be sure we didn't 		 * go beyond the end of the map, or wrap around the address; 		 * if so, we lose.  Otherwise, if this is the last entry, or 		 * if the proposed new region fits before the next entry, we 		 * win. 		 */
name|end
operator|=
name|start
operator|+
name|length
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|map
operator|->
name|max_offset
operator|||
name|end
operator|<
name|start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|==
operator|&
name|map
operator|->
name|header
operator|||
name|next
operator|->
name|start
operator|>=
name|end
condition|)
break|break;
block|}
name|SAVE_HINT
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
name|start
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_find finds an unallocated region in the target address  *	map with the given length.  The search is defined to be  *	first-fit from the specified address; the region found is  *	returned in the same parameter.  *  */
end_comment

begin_macro
name|vm_map_find
argument_list|(
argument|map
argument_list|,
argument|object
argument_list|,
argument|offset
argument_list|,
argument|addr
argument_list|,
argument|length
argument_list|,
argument|find_space
argument_list|)
end_macro

begin_decl_stmt
name|vm_map_t
name|map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_object_t
name|object
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IN/OUT */
end_comment

begin_decl_stmt
name|vm_size_t
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|find_space
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|vm_offset_t
name|start
decl_stmt|;
name|int
name|result
decl_stmt|;
name|start
operator|=
operator|*
name|addr
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_space
condition|)
block|{
if|if
condition|(
name|vm_map_findspace
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
block|}
name|start
operator|=
operator|*
name|addr
expr_stmt|;
block|}
name|result
operator|=
name|vm_map_insert
argument_list|(
name|map
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|length
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	vm_map_simplify_entry:	[ internal use only ]  *  *	Simplify the given map entry by:  *		removing extra sharing maps  *		[XXX maybe later] merging with a neighbor  */
end_comment

begin_function
name|void
name|vm_map_simplify_entry
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|)
name|vm_map_t
name|map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|lint
name|map
operator|++
expr_stmt|;
endif|#
directive|endif
endif|lint
comment|/* 	 *	If this entry corresponds to a sharing map, then 	 *	see if we can remove the level of indirection. 	 *	If it's not a sharing map, then it points to 	 *	a VM object, so see if we can merge with either 	 *	of our neighbors. 	 */
if|if
condition|(
name|entry
operator|->
name|is_sub_map
condition|)
return|return;
if|if
condition|(
name|entry
operator|->
name|is_a_map
condition|)
block|{
if|#
directive|if
literal|0
block|vm_map_t	my_share_map; 		int		count;  		my_share_map = entry->object.share_map;	 		simple_lock(&my_share_map->ref_lock); 		count = my_share_map->ref_count; 		simple_unlock(&my_share_map->ref_lock); 		 		if (count == 1) {
comment|/* Can move the region from 			 * entry->start to entry->end (+ entry->offset) 			 * in my_share_map into place of entry. 			 * Later. 			 */
block|}
endif|#
directive|endif
endif|0
block|}
else|else
block|{
comment|/* 		 *	Try to merge with our neighbors. 		 * 		 *	Conditions for merge are: 		 * 		 *	1.  entries are adjacent. 		 *	2.  both entries point to objects 		 *	    with null pagers. 		 * 		 * 	If a merge is possible, we replace the two 		 *	entries with a single entry, then merge 		 *	the two objects into a single object. 		 * 		 *	Now, all that is left to do is write the 		 *	code! 		 */
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_map_clip_start:	[ internal use only ]  *  *	Asserts that the given entry begins at or after  *	the specified address; if necessary,  *	it splits the entry into two.  */
end_comment

begin_define
define|#
directive|define
name|vm_map_clip_start
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|,
name|startaddr
parameter_list|)
define|\
value|{ \ 	if (startaddr> entry->start) \ 		_vm_map_clip_start(map, entry, startaddr); \ }
end_define

begin_comment
comment|/*  *	This routine is called only when it is known that  *	the entry must be split.  */
end_comment

begin_function
name|void
name|_vm_map_clip_start
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|,
name|start
parameter_list|)
specifier|register
name|vm_map_t
name|map
decl_stmt|;
specifier|register
name|vm_map_entry_t
name|entry
decl_stmt|;
specifier|register
name|vm_offset_t
name|start
decl_stmt|;
block|{
specifier|register
name|vm_map_entry_t
name|new_entry
decl_stmt|;
comment|/* 	 *	See if we can simplify this entry first 	 */
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* 	 *	Split off the front portion -- 	 *	note that we must insert the new 	 *	entry BEFORE this one, so that 	 *	this entry has the specified starting 	 *	address. 	 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|map
argument_list|)
expr_stmt|;
operator|*
name|new_entry
operator|=
operator|*
name|entry
expr_stmt|;
name|new_entry
operator|->
name|end
operator|=
name|start
expr_stmt|;
name|entry
operator|->
name|offset
operator|+=
operator|(
name|start
operator|-
name|entry
operator|->
name|start
operator|)
expr_stmt|;
name|entry
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|vm_map_entry_link
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|prev
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|is_a_map
operator|||
name|entry
operator|->
name|is_sub_map
condition|)
name|vm_map_reference
argument_list|(
name|new_entry
operator|->
name|object
operator|.
name|share_map
argument_list|)
expr_stmt|;
else|else
name|vm_object_reference
argument_list|(
name|new_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_clip_end:	[ internal use only ]  *  *	Asserts that the given entry ends at or before  *	the specified address; if necessary,  *	it splits the entry into two.  */
end_comment

begin_function_decl
name|void
name|_vm_map_clip_end
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|vm_map_clip_end
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|,
name|endaddr
parameter_list|)
define|\
value|{ \ 	if (endaddr< entry->end) \ 		_vm_map_clip_end(map, entry, endaddr); \ }
end_define

begin_comment
comment|/*  *	This routine is called only when it is known that  *	the entry must be split.  */
end_comment

begin_function
name|void
name|_vm_map_clip_end
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|,
name|end
parameter_list|)
specifier|register
name|vm_map_t
name|map
decl_stmt|;
specifier|register
name|vm_map_entry_t
name|entry
decl_stmt|;
specifier|register
name|vm_offset_t
name|end
decl_stmt|;
block|{
specifier|register
name|vm_map_entry_t
name|new_entry
decl_stmt|;
comment|/* 	 *	Create a new entry and insert it 	 *	AFTER the specified entry 	 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|map
argument_list|)
expr_stmt|;
operator|*
name|new_entry
operator|=
operator|*
name|entry
expr_stmt|;
name|new_entry
operator|->
name|start
operator|=
name|entry
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|new_entry
operator|->
name|offset
operator|+=
operator|(
name|end
operator|-
name|entry
operator|->
name|start
operator|)
expr_stmt|;
name|vm_map_entry_link
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|is_a_map
operator|||
name|entry
operator|->
name|is_sub_map
condition|)
name|vm_map_reference
argument_list|(
name|new_entry
operator|->
name|object
operator|.
name|share_map
argument_list|)
expr_stmt|;
else|else
name|vm_object_reference
argument_list|(
name|new_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	VM_MAP_RANGE_CHECK:	[ internal use only ]  *  *	Asserts that the starting and ending region  *	addresses fall within the valid range of the map.  */
end_comment

begin_define
define|#
directive|define
name|VM_MAP_RANGE_CHECK
parameter_list|(
name|map
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
define|\
value|{					\ 		if (start< vm_map_min(map))		\ 			start = vm_map_min(map);	\ 		if (end> vm_map_max(map))		\ 			end = vm_map_max(map);		\ 		if (start> end)			\ 			start = end;			\ 		}
end_define

begin_comment
comment|/*  *	vm_map_submap:		[ kernel use only ]  *  *	Mark the given range as handled by a subordinate map.  *  *	This range must have been created with vm_map_find,  *	and no other operations may have been performed on this  *	range prior to calling vm_map_submap.  *  *	Only a limited number of operations can be performed  *	within this rage after calling vm_map_submap:  *		vm_fault  *	[Don't try vm_map_copy!]  *  *	To remove a submapping, one must first remove the  *	range from the superior map, and then destroy the  *	submap (if desired).  [Better yet, don't try it.]  */
end_comment

begin_expr_stmt
name|vm_map_submap
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|submap
argument_list|)
specifier|register
name|vm_map_t
name|map
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|vm_offset_t
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|vm_offset_t
name|end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_map_t
name|submap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
specifier|register
name|int
name|result
init|=
name|KERN_INVALID_ARGUMENT
decl_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|start
operator|==
name|start
operator|)
operator|&&
operator|(
name|entry
operator|->
name|end
operator|==
name|end
operator|)
operator|&&
operator|(
operator|!
name|entry
operator|->
name|is_a_map
operator|)
operator|&&
operator|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|!
name|entry
operator|->
name|copy_on_write
operator|)
condition|)
block|{
name|entry
operator|->
name|is_a_map
operator|=
name|FALSE
expr_stmt|;
name|entry
operator|->
name|is_sub_map
operator|=
name|TRUE
expr_stmt|;
name|vm_map_reference
argument_list|(
name|entry
operator|->
name|object
operator|.
name|sub_map
operator|=
name|submap
argument_list|)
expr_stmt|;
name|result
operator|=
name|KERN_SUCCESS
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	vm_map_protect:  *  *	Sets the protection of the specified address  *	region in the target map.  If "set_max" is  *	specified, the maximum protection is to be set;  *	otherwise, only the current protection is affected.  */
end_comment

begin_expr_stmt
name|vm_map_protect
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|new_prot
argument_list|,
name|set_max
argument_list|)
specifier|register
name|vm_map_t
name|map
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|vm_offset_t
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|vm_offset_t
name|end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|vm_prot_t
name|new_prot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|boolean_t
name|set_max
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|vm_map_entry_t
name|current
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
comment|/* 	 *	Make a first pass to check for protection 	 *	violations. 	 */
name|current
operator|=
name|entry
expr_stmt|;
while|while
condition|(
operator|(
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|current
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|is_sub_map
condition|)
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
if|if
condition|(
operator|(
name|new_prot
operator|&
name|current
operator|->
name|max_protection
operator|)
operator|!=
name|new_prot
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_PROTECTION_FAILURE
operator|)
return|;
block|}
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 *	Go back and fix up protections. 	 *	[Note that clipping is not necessary the second time.] 	 */
name|current
operator|=
name|entry
expr_stmt|;
while|while
condition|(
operator|(
name|current
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|current
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
name|vm_prot_t
name|old_prot
decl_stmt|;
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|current
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|old_prot
operator|=
name|current
operator|->
name|protection
expr_stmt|;
if|if
condition|(
name|set_max
condition|)
name|current
operator|->
name|protection
operator|=
operator|(
name|current
operator|->
name|max_protection
operator|=
name|new_prot
operator|)
operator|&
name|old_prot
expr_stmt|;
else|else
name|current
operator|->
name|protection
operator|=
name|new_prot
expr_stmt|;
comment|/* 		 *	Update physical map if necessary. 		 *	Worry about copy-on-write here -- CHECK THIS XXX 		 */
if|if
condition|(
name|current
operator|->
name|protection
operator|!=
name|old_prot
condition|)
block|{
define|#
directive|define
name|MASK
parameter_list|(
name|entry
parameter_list|)
value|((entry)->copy_on_write ? ~VM_PROT_WRITE : \ 							VM_PROT_ALL)
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
if|if
condition|(
name|current
operator|->
name|is_a_map
condition|)
block|{
name|vm_map_entry_t
name|share_entry
decl_stmt|;
name|vm_offset_t
name|share_end
decl_stmt|;
name|vm_map_lock
argument_list|(
name|current
operator|->
name|object
operator|.
name|share_map
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_lookup_entry
argument_list|(
name|current
operator|->
name|object
operator|.
name|share_map
argument_list|,
name|current
operator|->
name|offset
argument_list|,
operator|&
name|share_entry
argument_list|)
expr_stmt|;
name|share_end
operator|=
name|current
operator|->
name|offset
operator|+
operator|(
name|current
operator|->
name|end
operator|-
name|current
operator|->
name|start
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|share_entry
operator|!=
operator|&
name|current
operator|->
name|object
operator|.
name|share_map
operator|->
name|header
operator|)
operator|&&
operator|(
name|share_entry
operator|->
name|start
operator|<
name|share_end
operator|)
condition|)
block|{
name|pmap_protect
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
operator|(
name|max
argument_list|(
name|share_entry
operator|->
name|start
argument_list|,
name|current
operator|->
name|offset
argument_list|)
operator|-
name|current
operator|->
name|offset
operator|+
name|current
operator|->
name|start
operator|)
argument_list|,
name|min
argument_list|(
name|share_entry
operator|->
name|end
argument_list|,
name|share_end
argument_list|)
operator|-
name|current
operator|->
name|offset
operator|+
name|current
operator|->
name|start
argument_list|,
name|current
operator|->
name|protection
operator|&
name|MASK
argument_list|(
name|share_entry
argument_list|)
argument_list|)
expr_stmt|;
name|share_entry
operator|=
name|share_entry
operator|->
name|next
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|current
operator|->
name|object
operator|.
name|share_map
argument_list|)
expr_stmt|;
block|}
else|else
name|pmap_protect
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|current
operator|->
name|start
argument_list|,
name|current
operator|->
name|end
argument_list|,
name|current
operator|->
name|protection
operator|&
name|MASK
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|max
undef|#
directive|undef
name|MASK
block|}
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	vm_map_inherit:  *  *	Sets the inheritance of the specified address  *	range in the target map.  Inheritance  *	affects how the map will be shared with  *	child maps at the time of vm_map_fork.  */
end_comment

begin_expr_stmt
name|vm_map_inherit
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|new_inheritance
argument_list|)
specifier|register
name|vm_map_t
name|map
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|vm_offset_t
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|vm_offset_t
name|end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|vm_inherit_t
name|new_inheritance
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_entry_t
name|temp_entry
decl_stmt|;
switch|switch
condition|(
name|new_inheritance
condition|)
block|{
case|case
name|VM_INHERIT_NONE
case|:
case|case
name|VM_INHERIT_COPY
case|:
case|case
name|VM_INHERIT_SHARE
case|:
break|break;
default|default:
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
block|}
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|temp_entry
argument_list|)
condition|)
block|{
name|entry
operator|=
name|temp_entry
expr_stmt|;
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
name|entry
operator|=
name|temp_entry
operator|->
name|next
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|entry
operator|->
name|inheritance
operator|=
name|new_inheritance
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	vm_map_pageable:  *  *	Sets the pageability of the specified address  *	range in the target map.  Regions specified  *	as not pageable require locked-down physical  *	memory and physical page maps.  *  *	The map must not be locked, but a reference  *	must remain to the map throughout the call.  */
end_comment

begin_expr_stmt
name|vm_map_pageable
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|new_pageable
argument_list|)
specifier|register
name|vm_map_t
name|map
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|vm_offset_t
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|vm_offset_t
name|end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|boolean_t
name|new_pageable
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_entry_t
name|temp_entry
decl_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* 	 *	Only one pageability change may take place at one 	 *	time, since vm_fault assumes it will be called 	 *	only once for each wiring/unwiring.  Therefore, we 	 *	have to make sure we're actually changing the pageability 	 *	for the entire region.  We do so before making any changes. 	 */
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|temp_entry
argument_list|)
condition|)
block|{
name|entry
operator|=
name|temp_entry
expr_stmt|;
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
name|entry
operator|=
name|temp_entry
operator|->
name|next
expr_stmt|;
name|temp_entry
operator|=
name|entry
expr_stmt|;
comment|/* 	 *	Actions are rather different for wiring and unwiring, 	 *	so we have two separate cases. 	 */
if|if
condition|(
name|new_pageable
condition|)
block|{
comment|/* 		 *	Unwiring.  First ensure that the range to be 		 *	unwired is really wired down. 		 */
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|==
literal|0
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_INVALID_ARGUMENT
operator|)
return|;
block|}
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
comment|/* 		 *	Now decrement the wiring count for each region. 		 *	If a region becomes completely unwired, 		 *	unwire its physical pages and mappings. 		 */
name|lock_set_recursive
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|)
expr_stmt|;
name|entry
operator|=
name|temp_entry
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|entry
operator|->
name|wired_count
operator|--
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|==
literal|0
condition|)
name|vm_fault_unwire
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
name|lock_clear_recursive
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 *	Wiring.  We must do this in two passes: 		 * 		 *	1.  Holding the write lock, we increment the 		 *	    wiring count.  For any area that is not already 		 *	    wired, we create any shadow objects that need 		 *	    to be created. 		 * 		 *	2.  We downgrade to a read lock, and call 		 *	    vm_fault_wire to fault in the pages for any 		 *	    newly wired area (wired_count is 1). 		 * 		 *	Downgrading to a read lock for vm_fault_wire avoids 		 *	a possible deadlock with another thread that may have 		 *	faulted on one of the pages to be wired (it would mark 		 *	the page busy, blocking us, then in turn block on the 		 *	map lock that we hold).  Because of problems in the 		 *	recursive lock package, we cannot upgrade to a write 		 *	lock in vm_map_lookup.  Thus, any actions that require 		 *	the write lock must be done beforehand.  Because we 		 *	keep the read lock on the map, the copy-on-write status 		 *	of the entries we modify here cannot change. 		 */
comment|/* 		 *	Pass 1. 		 */
name|entry
operator|=
name|temp_entry
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|entry
operator|->
name|wired_count
operator|++
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|==
literal|1
condition|)
block|{
comment|/* 			 *	Perform actions of vm_map_lookup that need 			 *	the write lock on the map: create a shadow 			 *	object for a copy-on-write region, or an 			 *	object for a zero-fill region. 			 * 			 *	We don't have to do this for entries that 			 *	point to sharing maps, because we won't hold 			 *	the lock on the sharing map. 			 */
if|if
condition|(
operator|!
name|entry
operator|->
name|is_a_map
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|needs_copy
operator|&&
operator|(
operator|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|vm_object_shadow
argument_list|(
operator|&
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
call|(
name|vm_size_t
call|)
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|needs_copy
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
condition|)
block|{
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|vm_object_allocate
argument_list|(
call|(
name|vm_size_t
call|)
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
operator|(
name|vm_offset_t
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
comment|/* 		 *	Pass 2. 		 */
comment|/* 		 * HACK HACK HACK HACK 		 * 		 * If we are wiring in the kernel map or a submap of it, 		 * unlock the map to avoid deadlocks.  We trust that the 		 * kernel threads are well-behaved, and therefore will 		 * not do anything destructive to this region of the map 		 * while we have it unlocked.  We cannot trust user threads 		 * to do the same. 		 * 		 * HACK HACK HACK HACK 		 */
if|if
condition|(
name|vm_map_pmap
argument_list|(
name|map
argument_list|)
operator|==
name|kernel_pmap
condition|)
block|{
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
comment|/* trust me ... */
block|}
else|else
block|{
name|lock_set_recursive
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_write_to_read
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|entry
operator|=
name|temp_entry
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|&&
name|entry
operator|->
name|start
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|==
literal|1
condition|)
block|{
name|vm_fault_wire
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|vm_map_pmap
argument_list|(
name|map
argument_list|)
operator|==
name|kernel_pmap
condition|)
block|{
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lock_clear_recursive
argument_list|(
operator|&
name|map
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	vm_map_entry_unwire:	[ internal use only ]  *  *	Make the region specified by this entry pageable.  *  *	The map in question should be locked.  *	[This is the reason for this routine's existence.]  */
end_comment

begin_function
name|void
name|vm_map_entry_unwire
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|)
name|vm_map_t
name|map
decl_stmt|;
specifier|register
name|vm_map_entry_t
name|entry
decl_stmt|;
block|{
name|vm_fault_unwire
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
name|entry
operator|->
name|wired_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_entry_delete:	[ internal use only ]  *  *	Deallocate the given entry from the target map.  */
end_comment

begin_function
name|void
name|vm_map_entry_delete
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|)
specifier|register
name|vm_map_t
name|map
decl_stmt|;
specifier|register
name|vm_map_entry_t
name|entry
decl_stmt|;
block|{
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|!=
literal|0
condition|)
name|vm_map_entry_unwire
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|vm_map_entry_unlink
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|map
operator|->
name|size
operator|-=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|is_a_map
operator|||
name|entry
operator|->
name|is_sub_map
condition|)
name|vm_map_deallocate
argument_list|(
name|entry
operator|->
name|object
operator|.
name|share_map
argument_list|)
expr_stmt|;
else|else
name|vm_object_deallocate
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
name|vm_map_entry_dispose
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_delete:	[ internal use only ]  *  *	Deallocates the given address range from the target  *	map.  *  *	When called with a sharing map, removes pages from  *	that region from all physical maps.  */
end_comment

begin_expr_stmt
name|vm_map_delete
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
specifier|register
name|vm_map_t
name|map
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|vm_offset_t
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|vm_offset_t
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_entry_t
name|first_entry
decl_stmt|;
comment|/* 	 *	Find the start of the region, and clip it 	 */
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|first_entry
argument_list|)
condition|)
name|entry
operator|=
name|first_entry
operator|->
name|next
expr_stmt|;
else|else
block|{
name|entry
operator|=
name|first_entry
expr_stmt|;
name|vm_map_clip_start
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* 		 *	Fix the lookup hint now, rather than each 		 *	time though the loop. 		 */
name|SAVE_HINT
argument_list|(
name|map
argument_list|,
name|entry
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Save the free space hint 	 */
if|if
condition|(
name|map
operator|->
name|first_free
operator|->
name|start
operator|>=
name|start
condition|)
name|map
operator|->
name|first_free
operator|=
name|entry
operator|->
name|prev
expr_stmt|;
comment|/* 	 *	Step through all entries in this region 	 */
while|while
condition|(
operator|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|entry
operator|->
name|start
operator|<
name|end
operator|)
condition|)
block|{
name|vm_map_entry_t
name|next
decl_stmt|;
specifier|register
name|vm_offset_t
name|s
decl_stmt|,
name|e
decl_stmt|;
specifier|register
name|vm_object_t
name|object
decl_stmt|;
name|vm_map_clip_end
argument_list|(
name|map
argument_list|,
name|entry
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|s
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|e
operator|=
name|entry
operator|->
name|end
expr_stmt|;
comment|/* 		 *	Unwire before removing addresses from the pmap; 		 *	otherwise, unwiring will put the entries back in 		 *	the pmap. 		 */
name|object
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|!=
literal|0
condition|)
name|vm_map_entry_unwire
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* 		 *	If this is a sharing map, we must remove 		 *	*all* references to this data, since we can't 		 *	find all of the physical maps which are sharing 		 *	it. 		 */
if|if
condition|(
name|object
operator|==
name|kernel_object
operator|||
name|object
operator|==
name|kmem_object
condition|)
name|vm_object_page_remove
argument_list|(
name|object
argument_list|,
name|entry
operator|->
name|offset
argument_list|,
name|entry
operator|->
name|offset
operator|+
operator|(
name|e
operator|-
name|s
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|map
operator|->
name|is_main_map
condition|)
name|vm_object_pmap_remove
argument_list|(
name|object
argument_list|,
name|entry
operator|->
name|offset
argument_list|,
name|entry
operator|->
name|offset
operator|+
operator|(
name|e
operator|-
name|s
operator|)
argument_list|)
expr_stmt|;
else|else
name|pmap_remove
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* 		 *	Delete the entry (which may delete the object) 		 *	only after removing all pmap entries pointing 		 *	to its pages.  (Otherwise, its page frames may 		 *	be reallocated, and any modify bits will be 		 *	set in the wrong object!) 		 */
name|vm_map_entry_delete
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|next
expr_stmt|;
block|}
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	vm_map_remove:  *  *	Remove the given address range from the target map.  *	This is the exported form of vm_map_delete.  */
end_comment

begin_expr_stmt
name|vm_map_remove
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
specifier|register
name|vm_map_t
name|map
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|vm_offset_t
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|vm_offset_t
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|result
decl_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|VM_MAP_RANGE_CHECK
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|result
operator|=
name|vm_map_delete
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	vm_map_check_protection:  *  *	Assert that the target map allows the specified  *	privilege on the entire address region given.  *	The entire region must be allocated.  */
end_comment

begin_function
name|boolean_t
name|vm_map_check_protection
parameter_list|(
name|map
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|protection
parameter_list|)
specifier|register
name|vm_map_t
name|map
decl_stmt|;
specifier|register
name|vm_offset_t
name|start
decl_stmt|;
specifier|register
name|vm_offset_t
name|end
decl_stmt|;
specifier|register
name|vm_prot_t
name|protection
decl_stmt|;
block|{
specifier|register
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_map_entry_t
name|tmp_entry
decl_stmt|;
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|tmp_entry
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|entry
operator|=
name|tmp_entry
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|entry
operator|==
operator|&
name|map
operator|->
name|header
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 		 *	No holes allowed! 		 */
if|if
condition|(
name|start
operator|<
name|entry
operator|->
name|start
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 		 * Check protection associated with entry. 		 */
if|if
condition|(
operator|(
name|entry
operator|->
name|protection
operator|&
name|protection
operator|)
operator|!=
name|protection
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* go to next entry */
name|start
operator|=
name|entry
operator|->
name|end
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_copy_entry:  *  *	Copies the contents of the source entry to the destination  *	entry.  The entries *must* be aligned properly.  */
end_comment

begin_function
name|void
name|vm_map_copy_entry
parameter_list|(
name|src_map
parameter_list|,
name|dst_map
parameter_list|,
name|src_entry
parameter_list|,
name|dst_entry
parameter_list|)
name|vm_map_t
name|src_map
decl_stmt|,
name|dst_map
decl_stmt|;
specifier|register
name|vm_map_entry_t
name|src_entry
decl_stmt|,
name|dst_entry
decl_stmt|;
block|{
name|vm_object_t
name|temp_object
decl_stmt|;
if|if
condition|(
name|src_entry
operator|->
name|is_sub_map
operator|||
name|dst_entry
operator|->
name|is_sub_map
condition|)
return|return;
if|if
condition|(
name|dst_entry
operator|->
name|object
operator|.
name|vm_object
operator|!=
name|NULL
operator|&&
operator|(
name|dst_entry
operator|->
name|object
operator|.
name|vm_object
operator|->
name|flags
operator|&
name|OBJ_INTERNAL
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"vm_map_copy_entry: copying over permanent data!\n"
argument_list|)
expr_stmt|;
comment|/* 	 *	If our destination map was wired down, 	 *	unwire it now. 	 */
if|if
condition|(
name|dst_entry
operator|->
name|wired_count
operator|!=
literal|0
condition|)
name|vm_map_entry_unwire
argument_list|(
name|dst_map
argument_list|,
name|dst_entry
argument_list|)
expr_stmt|;
comment|/* 	 *	If we're dealing with a sharing map, we 	 *	must remove the destination pages from 	 *	all maps (since we cannot know which maps 	 *	this sharing map belongs in). 	 */
if|if
condition|(
name|dst_map
operator|->
name|is_main_map
condition|)
name|pmap_remove
argument_list|(
name|dst_map
operator|->
name|pmap
argument_list|,
name|dst_entry
operator|->
name|start
argument_list|,
name|dst_entry
operator|->
name|end
argument_list|)
expr_stmt|;
else|else
name|vm_object_pmap_remove
argument_list|(
name|dst_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|dst_entry
operator|->
name|offset
argument_list|,
name|dst_entry
operator|->
name|offset
operator|+
operator|(
name|dst_entry
operator|->
name|end
operator|-
name|dst_entry
operator|->
name|start
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_entry
operator|->
name|wired_count
operator|==
literal|0
condition|)
block|{
name|boolean_t
name|src_needs_copy
decl_stmt|;
comment|/* 		 *	If the source entry is marked needs_copy, 		 *	it is already write-protected. 		 */
if|if
condition|(
operator|!
name|src_entry
operator|->
name|needs_copy
condition|)
block|{
name|boolean_t
name|su
decl_stmt|;
comment|/* 			 *	If the source entry has only one mapping, 			 *	we can just protect the virtual address 			 *	range. 			 */
if|if
condition|(
operator|!
operator|(
name|su
operator|=
name|src_map
operator|->
name|is_main_map
operator|)
condition|)
block|{
name|simple_lock
argument_list|(
operator|&
name|src_map
operator|->
name|ref_lock
argument_list|)
expr_stmt|;
name|su
operator|=
operator|(
name|src_map
operator|->
name|ref_count
operator|==
literal|1
operator|)
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|src_map
operator|->
name|ref_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|su
condition|)
block|{
name|pmap_protect
argument_list|(
name|src_map
operator|->
name|pmap
argument_list|,
name|src_entry
operator|->
name|start
argument_list|,
name|src_entry
operator|->
name|end
argument_list|,
name|src_entry
operator|->
name|protection
operator|&
operator|~
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm_object_pmap_copy
argument_list|(
name|src_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|src_entry
operator|->
name|offset
argument_list|,
name|src_entry
operator|->
name|offset
operator|+
operator|(
name|src_entry
operator|->
name|end
operator|-
name|src_entry
operator|->
name|start
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 *	Make a copy of the object. 		 */
name|temp_object
operator|=
name|dst_entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
name|vm_object_copy
argument_list|(
name|src_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|src_entry
operator|->
name|offset
argument_list|,
call|(
name|vm_size_t
call|)
argument_list|(
name|src_entry
operator|->
name|end
operator|-
name|src_entry
operator|->
name|start
argument_list|)
argument_list|,
operator|&
name|dst_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
operator|&
name|dst_entry
operator|->
name|offset
argument_list|,
operator|&
name|src_needs_copy
argument_list|)
expr_stmt|;
comment|/* 		 *	If we didn't get a copy-object now, mark the 		 *	source map entry so that a shadow will be created 		 *	to hold its changed pages. 		 */
if|if
condition|(
name|src_needs_copy
condition|)
name|src_entry
operator|->
name|needs_copy
operator|=
name|TRUE
expr_stmt|;
comment|/* 		 *	The destination always needs to have a shadow 		 *	created. 		 */
name|dst_entry
operator|->
name|needs_copy
operator|=
name|TRUE
expr_stmt|;
comment|/* 		 *	Mark the entries copy-on-write, so that write-enabling 		 *	the entry won't make copy-on-write pages writable. 		 */
name|src_entry
operator|->
name|copy_on_write
operator|=
name|TRUE
expr_stmt|;
name|dst_entry
operator|->
name|copy_on_write
operator|=
name|TRUE
expr_stmt|;
comment|/* 		 *	Get rid of the old object. 		 */
name|vm_object_deallocate
argument_list|(
name|temp_object
argument_list|)
expr_stmt|;
name|pmap_copy
argument_list|(
name|dst_map
operator|->
name|pmap
argument_list|,
name|src_map
operator|->
name|pmap
argument_list|,
name|dst_entry
operator|->
name|start
argument_list|,
name|dst_entry
operator|->
name|end
operator|-
name|dst_entry
operator|->
name|start
argument_list|,
name|src_entry
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 *	Of course, wired down pages can't be set copy-on-write. 		 *	Cause wired pages to be copied into the new 		 *	map by simulating faults (the new pages are 		 *	pageable) 		 */
name|vm_fault_copy_entry
argument_list|(
name|dst_map
argument_list|,
name|src_map
argument_list|,
name|dst_entry
argument_list|,
name|src_entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	vm_map_copy:  *  *	Perform a virtual memory copy from the source  *	address map/range to the destination map/range.  *  *	If src_destroy or dst_alloc is requested,  *	the source and destination regions should be  *	disjoint, not only in the top-level map, but  *	in the sharing maps as well.  [The best way  *	to guarantee this is to use a new intermediate  *	map to make copies.  This also reduces map  *	fragmentation.]  */
end_comment

begin_macro
name|vm_map_copy
argument_list|(
argument|dst_map
argument_list|,
argument|src_map
argument_list|,
argument|dst_addr
argument_list|,
argument|len
argument_list|,
argument|src_addr
argument_list|,
argument|dst_alloc
argument_list|,
argument|src_destroy
argument_list|)
end_macro

begin_decl_stmt
name|vm_map_t
name|dst_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_map_t
name|src_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|dst_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_size_t
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|src_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|dst_alloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|src_destroy
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|vm_map_entry_t
name|src_entry
decl_stmt|;
specifier|register
name|vm_map_entry_t
name|dst_entry
decl_stmt|;
name|vm_map_entry_t
name|tmp_entry
decl_stmt|;
name|vm_offset_t
name|src_start
decl_stmt|;
name|vm_offset_t
name|src_end
decl_stmt|;
name|vm_offset_t
name|dst_start
decl_stmt|;
name|vm_offset_t
name|dst_end
decl_stmt|;
name|vm_offset_t
name|src_clip
decl_stmt|;
name|vm_offset_t
name|dst_clip
decl_stmt|;
name|int
name|result
decl_stmt|;
name|boolean_t
name|old_src_destroy
decl_stmt|;
comment|/* 	 *	XXX While we figure out why src_destroy screws up, 	 *	we'll do it by explicitly vm_map_delete'ing at the end. 	 */
name|old_src_destroy
operator|=
name|src_destroy
expr_stmt|;
name|src_destroy
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 *	Compute start and end of region in both maps 	 */
name|src_start
operator|=
name|src_addr
expr_stmt|;
name|src_end
operator|=
name|src_start
operator|+
name|len
expr_stmt|;
name|dst_start
operator|=
name|dst_addr
expr_stmt|;
name|dst_end
operator|=
name|dst_start
operator|+
name|len
expr_stmt|;
comment|/* 	 *	Check that the region can exist in both source 	 *	and destination. 	 */
if|if
condition|(
operator|(
name|dst_end
operator|<
name|dst_start
operator|)
operator|||
operator|(
name|src_end
operator|<
name|src_start
operator|)
condition|)
return|return
operator|(
name|KERN_NO_SPACE
operator|)
return|;
comment|/* 	 *	Lock the maps in question -- we avoid deadlock 	 *	by ordering lock acquisition by map value 	 */
if|if
condition|(
name|src_map
operator|==
name|dst_map
condition|)
block|{
name|vm_map_lock
argument_list|(
name|src_map
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|src_map
operator|<
operator|(
name|int
operator|)
name|dst_map
condition|)
block|{
name|vm_map_lock
argument_list|(
name|src_map
argument_list|)
expr_stmt|;
name|vm_map_lock
argument_list|(
name|dst_map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm_map_lock
argument_list|(
name|dst_map
argument_list|)
expr_stmt|;
name|vm_map_lock
argument_list|(
name|src_map
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|KERN_SUCCESS
expr_stmt|;
comment|/* 	 *	Check protections... source must be completely readable and 	 *	destination must be completely writable.  [Note that if we're 	 *	allocating the destination region, we don't have to worry 	 *	about protection, but instead about whether the region 	 *	exists.] 	 */
if|if
condition|(
name|src_map
operator|->
name|is_main_map
operator|&&
name|dst_map
operator|->
name|is_main_map
condition|)
block|{
if|if
condition|(
operator|!
name|vm_map_check_protection
argument_list|(
name|src_map
argument_list|,
name|src_start
argument_list|,
name|src_end
argument_list|,
name|VM_PROT_READ
argument_list|)
condition|)
block|{
name|result
operator|=
name|KERN_PROTECTION_FAILURE
expr_stmt|;
goto|goto
name|Return
goto|;
block|}
if|if
condition|(
name|dst_alloc
condition|)
block|{
comment|/* XXX Consider making this a vm_map_find instead */
if|if
condition|(
operator|(
name|result
operator|=
name|vm_map_insert
argument_list|(
name|dst_map
argument_list|,
name|NULL
argument_list|,
operator|(
name|vm_offset_t
operator|)
literal|0
argument_list|,
name|dst_start
argument_list|,
name|dst_end
argument_list|)
operator|)
operator|!=
name|KERN_SUCCESS
condition|)
goto|goto
name|Return
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|vm_map_check_protection
argument_list|(
name|dst_map
argument_list|,
name|dst_start
argument_list|,
name|dst_end
argument_list|,
name|VM_PROT_WRITE
argument_list|)
condition|)
block|{
name|result
operator|=
name|KERN_PROTECTION_FAILURE
expr_stmt|;
goto|goto
name|Return
goto|;
block|}
block|}
comment|/* 	 *	Find the start entries and clip. 	 * 	 *	Note that checking protection asserts that the 	 *	lookup cannot fail. 	 * 	 *	Also note that we wait to do the second lookup 	 *	until we have done the first clip, as the clip 	 *	may affect which entry we get! 	 */
operator|(
name|void
operator|)
name|vm_map_lookup_entry
argument_list|(
name|src_map
argument_list|,
name|src_addr
argument_list|,
operator|&
name|tmp_entry
argument_list|)
expr_stmt|;
name|src_entry
operator|=
name|tmp_entry
expr_stmt|;
name|vm_map_clip_start
argument_list|(
name|src_map
argument_list|,
name|src_entry
argument_list|,
name|src_start
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_lookup_entry
argument_list|(
name|dst_map
argument_list|,
name|dst_addr
argument_list|,
operator|&
name|tmp_entry
argument_list|)
expr_stmt|;
name|dst_entry
operator|=
name|tmp_entry
expr_stmt|;
name|vm_map_clip_start
argument_list|(
name|dst_map
argument_list|,
name|dst_entry
argument_list|,
name|dst_start
argument_list|)
expr_stmt|;
comment|/* 	 *	If both source and destination entries are the same, 	 *	retry the first lookup, as it may have changed. 	 */
if|if
condition|(
name|src_entry
operator|==
name|dst_entry
condition|)
block|{
operator|(
name|void
operator|)
name|vm_map_lookup_entry
argument_list|(
name|src_map
argument_list|,
name|src_addr
argument_list|,
operator|&
name|tmp_entry
argument_list|)
expr_stmt|;
name|src_entry
operator|=
name|tmp_entry
expr_stmt|;
block|}
comment|/* 	 *	If source and destination entries are still the same, 	 *	a null copy is being performed. 	 */
if|if
condition|(
name|src_entry
operator|==
name|dst_entry
condition|)
goto|goto
name|Return
goto|;
comment|/* 	 *	Go through entries until we get to the end of the 	 *	region. 	 */
while|while
condition|(
name|src_start
operator|<
name|src_end
condition|)
block|{
comment|/* 		 *	Clip the entries to the endpoint of the entire region. 		 */
name|vm_map_clip_end
argument_list|(
name|src_map
argument_list|,
name|src_entry
argument_list|,
name|src_end
argument_list|)
expr_stmt|;
name|vm_map_clip_end
argument_list|(
name|dst_map
argument_list|,
name|dst_entry
argument_list|,
name|dst_end
argument_list|)
expr_stmt|;
comment|/* 		 *	Clip each entry to the endpoint of the other entry. 		 */
name|src_clip
operator|=
name|src_entry
operator|->
name|start
operator|+
operator|(
name|dst_entry
operator|->
name|end
operator|-
name|dst_entry
operator|->
name|start
operator|)
expr_stmt|;
name|vm_map_clip_end
argument_list|(
name|src_map
argument_list|,
name|src_entry
argument_list|,
name|src_clip
argument_list|)
expr_stmt|;
name|dst_clip
operator|=
name|dst_entry
operator|->
name|start
operator|+
operator|(
name|src_entry
operator|->
name|end
operator|-
name|src_entry
operator|->
name|start
operator|)
expr_stmt|;
name|vm_map_clip_end
argument_list|(
name|dst_map
argument_list|,
name|dst_entry
argument_list|,
name|dst_clip
argument_list|)
expr_stmt|;
comment|/* 		 *	Both entries now match in size and relative endpoints. 		 * 		 *	If both entries refer to a VM object, we can 		 *	deal with them now. 		 */
if|if
condition|(
operator|!
name|src_entry
operator|->
name|is_a_map
operator|&&
operator|!
name|dst_entry
operator|->
name|is_a_map
condition|)
block|{
name|vm_map_copy_entry
argument_list|(
name|src_map
argument_list|,
name|dst_map
argument_list|,
name|src_entry
argument_list|,
name|dst_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|vm_map_t
name|new_dst_map
decl_stmt|;
name|vm_offset_t
name|new_dst_start
decl_stmt|;
name|vm_size_t
name|new_size
decl_stmt|;
name|vm_map_t
name|new_src_map
decl_stmt|;
name|vm_offset_t
name|new_src_start
decl_stmt|;
comment|/* 			 *	We have to follow at least one sharing map. 			 */
name|new_size
operator|=
operator|(
name|dst_entry
operator|->
name|end
operator|-
name|dst_entry
operator|->
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|src_entry
operator|->
name|is_a_map
condition|)
block|{
name|new_src_map
operator|=
name|src_entry
operator|->
name|object
operator|.
name|share_map
expr_stmt|;
name|new_src_start
operator|=
name|src_entry
operator|->
name|offset
expr_stmt|;
block|}
else|else
block|{
name|new_src_map
operator|=
name|src_map
expr_stmt|;
name|new_src_start
operator|=
name|src_entry
operator|->
name|start
expr_stmt|;
name|lock_set_recursive
argument_list|(
operator|&
name|src_map
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst_entry
operator|->
name|is_a_map
condition|)
block|{
name|vm_offset_t
name|new_dst_end
decl_stmt|;
name|new_dst_map
operator|=
name|dst_entry
operator|->
name|object
operator|.
name|share_map
expr_stmt|;
name|new_dst_start
operator|=
name|dst_entry
operator|->
name|offset
expr_stmt|;
comment|/* 				 *	Since the destination sharing entries 				 *	will be merely deallocated, we can 				 *	do that now, and replace the region 				 *	with a null object.  [This prevents 				 *	splitting the source map to match 				 *	the form of the destination map.] 				 *	Note that we can only do so if the 				 *	source and destination do not overlap. 				 */
name|new_dst_end
operator|=
name|new_dst_start
operator|+
name|new_size
expr_stmt|;
if|if
condition|(
name|new_dst_map
operator|!=
name|new_src_map
condition|)
block|{
name|vm_map_lock
argument_list|(
name|new_dst_map
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_delete
argument_list|(
name|new_dst_map
argument_list|,
name|new_dst_start
argument_list|,
name|new_dst_end
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_insert
argument_list|(
name|new_dst_map
argument_list|,
name|NULL
argument_list|,
operator|(
name|vm_offset_t
operator|)
literal|0
argument_list|,
name|new_dst_start
argument_list|,
name|new_dst_end
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|new_dst_map
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|new_dst_map
operator|=
name|dst_map
expr_stmt|;
name|new_dst_start
operator|=
name|dst_entry
operator|->
name|start
expr_stmt|;
name|lock_set_recursive
argument_list|(
operator|&
name|dst_map
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* 			 *	Recursively copy the sharing map. 			 */
operator|(
name|void
operator|)
name|vm_map_copy
argument_list|(
name|new_dst_map
argument_list|,
name|new_src_map
argument_list|,
name|new_dst_start
argument_list|,
name|new_size
argument_list|,
name|new_src_start
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_map
operator|==
name|new_dst_map
condition|)
name|lock_clear_recursive
argument_list|(
operator|&
name|dst_map
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_map
operator|==
name|new_src_map
condition|)
name|lock_clear_recursive
argument_list|(
operator|&
name|src_map
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *	Update variables for next pass through the loop. 		 */
name|src_start
operator|=
name|src_entry
operator|->
name|end
expr_stmt|;
name|src_entry
operator|=
name|src_entry
operator|->
name|next
expr_stmt|;
name|dst_start
operator|=
name|dst_entry
operator|->
name|end
expr_stmt|;
name|dst_entry
operator|=
name|dst_entry
operator|->
name|next
expr_stmt|;
comment|/* 		 *	If the source is to be destroyed, here is the 		 *	place to do it. 		 */
if|if
condition|(
name|src_destroy
operator|&&
name|src_map
operator|->
name|is_main_map
operator|&&
name|dst_map
operator|->
name|is_main_map
condition|)
name|vm_map_entry_delete
argument_list|(
name|src_map
argument_list|,
name|src_entry
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Update the physical maps as appropriate 	 */
if|if
condition|(
name|src_map
operator|->
name|is_main_map
operator|&&
name|dst_map
operator|->
name|is_main_map
condition|)
block|{
if|if
condition|(
name|src_destroy
condition|)
name|pmap_remove
argument_list|(
name|src_map
operator|->
name|pmap
argument_list|,
name|src_addr
argument_list|,
name|src_addr
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Unlock the maps 	 */
name|Return
label|:
empty_stmt|;
if|if
condition|(
name|old_src_destroy
condition|)
name|vm_map_delete
argument_list|(
name|src_map
argument_list|,
name|src_addr
argument_list|,
name|src_addr
operator|+
name|len
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|src_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_map
operator|!=
name|dst_map
condition|)
name|vm_map_unlock
argument_list|(
name|dst_map
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * vmspace_fork:  * Create a new process vmspace structure and vm_map  * based on those of an existing process.  The new map  * is based on the old map, according to the inheritance  * values on the regions in that map.  *  * The source map must not be locked.  */
end_comment

begin_function
name|struct
name|vmspace
modifier|*
name|vmspace_fork
parameter_list|(
name|vm1
parameter_list|)
specifier|register
name|struct
name|vmspace
modifier|*
name|vm1
decl_stmt|;
block|{
specifier|register
name|struct
name|vmspace
modifier|*
name|vm2
decl_stmt|;
name|vm_map_t
name|old_map
init|=
operator|&
name|vm1
operator|->
name|vm_map
decl_stmt|;
name|vm_map_t
name|new_map
decl_stmt|;
name|vm_map_entry_t
name|old_entry
decl_stmt|;
name|vm_map_entry_t
name|new_entry
decl_stmt|;
name|pmap_t
name|new_pmap
decl_stmt|;
name|vm_map_lock
argument_list|(
name|old_map
argument_list|)
expr_stmt|;
name|vm2
operator|=
name|vmspace_alloc
argument_list|(
name|old_map
operator|->
name|min_offset
argument_list|,
name|old_map
operator|->
name|max_offset
argument_list|,
name|old_map
operator|->
name|entries_pageable
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|vm1
operator|->
name|vm_startcopy
argument_list|,
operator|&
name|vm2
operator|->
name|vm_startcopy
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|vm1
operator|+
literal|1
argument_list|)
operator|-
operator|(
name|caddr_t
operator|)
operator|&
name|vm1
operator|->
name|vm_startcopy
argument_list|)
expr_stmt|;
name|new_pmap
operator|=
operator|&
name|vm2
operator|->
name|vm_pmap
expr_stmt|;
comment|/* XXX */
name|new_map
operator|=
operator|&
name|vm2
operator|->
name|vm_map
expr_stmt|;
comment|/* XXX */
name|old_entry
operator|=
name|old_map
operator|->
name|header
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|old_entry
operator|!=
operator|&
name|old_map
operator|->
name|header
condition|)
block|{
if|if
condition|(
name|old_entry
operator|->
name|is_sub_map
condition|)
name|panic
argument_list|(
literal|"vm_map_fork: encountered a submap"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|old_entry
operator|->
name|inheritance
condition|)
block|{
case|case
name|VM_INHERIT_NONE
case|:
break|break;
case|case
name|VM_INHERIT_SHARE
case|:
comment|/* 			 *	If we don't already have a sharing map: 			 */
if|if
condition|(
operator|!
name|old_entry
operator|->
name|is_a_map
condition|)
block|{
name|vm_map_t
name|new_share_map
decl_stmt|;
name|vm_map_entry_t
name|new_share_entry
decl_stmt|;
comment|/* 				 *	Create a new sharing map 				 */
name|new_share_map
operator|=
name|vm_map_create
argument_list|(
name|NULL
argument_list|,
name|old_entry
operator|->
name|start
argument_list|,
name|old_entry
operator|->
name|end
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|new_share_map
operator|->
name|is_main_map
operator|=
name|FALSE
expr_stmt|;
comment|/* 				 *	Create the only sharing entry from the 				 *	old task map entry. 				 */
name|new_share_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|new_share_map
argument_list|)
expr_stmt|;
operator|*
name|new_share_entry
operator|=
operator|*
name|old_entry
expr_stmt|;
comment|/* 				 *	Insert the entry into the new sharing 				 *	map 				 */
name|vm_map_entry_link
argument_list|(
name|new_share_map
argument_list|,
name|new_share_map
operator|->
name|header
operator|.
name|prev
argument_list|,
name|new_share_entry
argument_list|)
expr_stmt|;
comment|/* 				 *	Fix up the task map entry to refer 				 *	to the sharing map now. 				 */
name|old_entry
operator|->
name|is_a_map
operator|=
name|TRUE
expr_stmt|;
name|old_entry
operator|->
name|object
operator|.
name|share_map
operator|=
name|new_share_map
expr_stmt|;
name|old_entry
operator|->
name|offset
operator|=
name|old_entry
operator|->
name|start
expr_stmt|;
block|}
comment|/* 			 *	Clone the entry, referencing the sharing map. 			 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|new_map
argument_list|)
expr_stmt|;
operator|*
name|new_entry
operator|=
operator|*
name|old_entry
expr_stmt|;
name|vm_map_reference
argument_list|(
name|new_entry
operator|->
name|object
operator|.
name|share_map
argument_list|)
expr_stmt|;
comment|/* 			 *	Insert the entry into the new map -- we 			 *	know we're inserting at the end of the new 			 *	map. 			 */
name|vm_map_entry_link
argument_list|(
name|new_map
argument_list|,
name|new_map
operator|->
name|header
operator|.
name|prev
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
comment|/* 			 *	Update the physical map 			 */
name|pmap_copy
argument_list|(
name|new_map
operator|->
name|pmap
argument_list|,
name|old_map
operator|->
name|pmap
argument_list|,
name|new_entry
operator|->
name|start
argument_list|,
operator|(
name|old_entry
operator|->
name|end
operator|-
name|old_entry
operator|->
name|start
operator|)
argument_list|,
name|old_entry
operator|->
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_INHERIT_COPY
case|:
comment|/* 			 *	Clone the entry and link into the map. 			 */
name|new_entry
operator|=
name|vm_map_entry_create
argument_list|(
name|new_map
argument_list|)
expr_stmt|;
operator|*
name|new_entry
operator|=
operator|*
name|old_entry
expr_stmt|;
name|new_entry
operator|->
name|wired_count
operator|=
literal|0
expr_stmt|;
name|new_entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|NULL
expr_stmt|;
name|new_entry
operator|->
name|is_a_map
operator|=
name|FALSE
expr_stmt|;
name|vm_map_entry_link
argument_list|(
name|new_map
argument_list|,
name|new_map
operator|->
name|header
operator|.
name|prev
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_entry
operator|->
name|is_a_map
condition|)
block|{
name|int
name|check
decl_stmt|;
name|check
operator|=
name|vm_map_copy
argument_list|(
name|new_map
argument_list|,
name|old_entry
operator|->
name|object
operator|.
name|share_map
argument_list|,
name|new_entry
operator|->
name|start
argument_list|,
call|(
name|vm_size_t
call|)
argument_list|(
name|new_entry
operator|->
name|end
operator|-
name|new_entry
operator|->
name|start
argument_list|)
argument_list|,
name|old_entry
operator|->
name|offset
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|!=
name|KERN_SUCCESS
condition|)
name|printf
argument_list|(
literal|"vm_map_fork: copy in share_map region failed\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm_map_copy_entry
argument_list|(
name|old_map
argument_list|,
name|new_map
argument_list|,
name|old_entry
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|old_entry
operator|=
name|old_entry
operator|->
name|next
expr_stmt|;
block|}
name|new_map
operator|->
name|size
operator|=
name|old_map
operator|->
name|size
expr_stmt|;
name|vm_map_unlock
argument_list|(
name|old_map
argument_list|)
expr_stmt|;
return|return
operator|(
name|vm2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_lookup:  *  *	Finds the VM object, offset, and  *	protection for a given virtual address in the  *	specified map, assuming a page fault of the  *	type specified.  *  *	Leaves the map in question locked for read; return  *	values are guaranteed until a vm_map_lookup_done  *	call is performed.  Note that the map argument  *	is in/out; the returned map must be used in  *	the call to vm_map_lookup_done.  *  *	A handle (out_entry) is returned for use in  *	vm_map_lookup_done, to make that fast.  *  *	If a lookup is requested with "write protection"  *	specified, the map may be changed to perform virtual  *	copying operations, although the data referenced will  *	remain the same.  */
end_comment

begin_macro
name|vm_map_lookup
argument_list|(
argument|var_map
argument_list|,
argument|vaddr
argument_list|,
argument|fault_type
argument_list|,
argument|out_entry
argument_list|,
argument|object
argument_list|,
argument|offset
argument_list|,
argument|out_prot
argument_list|,
argument|wired
argument_list|,
argument|single_use
argument_list|)
end_macro

begin_decl_stmt
name|vm_map_t
modifier|*
name|var_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IN/OUT */
end_comment

begin_decl_stmt
specifier|register
name|vm_offset_t
name|vaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|vm_prot_t
name|fault_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_map_entry_t
modifier|*
name|out_entry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OUT */
end_comment

begin_decl_stmt
name|vm_object_t
modifier|*
name|object
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OUT */
end_comment

begin_decl_stmt
name|vm_offset_t
modifier|*
name|offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OUT */
end_comment

begin_decl_stmt
name|vm_prot_t
modifier|*
name|out_prot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OUT */
end_comment

begin_decl_stmt
name|boolean_t
modifier|*
name|wired
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OUT */
end_comment

begin_decl_stmt
name|boolean_t
modifier|*
name|single_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OUT */
end_comment

begin_block
block|{
name|vm_map_t
name|share_map
decl_stmt|;
name|vm_offset_t
name|share_offset
decl_stmt|;
specifier|register
name|vm_map_entry_t
name|entry
decl_stmt|;
specifier|register
name|vm_map_t
name|map
init|=
operator|*
name|var_map
decl_stmt|;
specifier|register
name|vm_prot_t
name|prot
decl_stmt|;
specifier|register
name|boolean_t
name|su
decl_stmt|;
name|RetryLookup
label|:
empty_stmt|;
comment|/* 	 *	Lookup the faulting address. 	 */
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
define|#
directive|define
name|RETURN
parameter_list|(
name|why
parameter_list|)
define|\
value|{ \ 		vm_map_unlock_read(map); \ 		return(why); \ 		}
comment|/* 	 *	If the map has an interesting hint, try it before calling 	 *	full blown lookup routine. 	 */
name|simple_lock
argument_list|(
operator|&
name|map
operator|->
name|hint_lock
argument_list|)
expr_stmt|;
name|entry
operator|=
name|map
operator|->
name|hint
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|map
operator|->
name|hint_lock
argument_list|)
expr_stmt|;
operator|*
name|out_entry
operator|=
name|entry
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|==
operator|&
name|map
operator|->
name|header
operator|)
operator|||
operator|(
name|vaddr
operator|<
name|entry
operator|->
name|start
operator|)
operator|||
operator|(
name|vaddr
operator|>=
name|entry
operator|->
name|end
operator|)
condition|)
block|{
name|vm_map_entry_t
name|tmp_entry
decl_stmt|;
comment|/* 		 *	Entry was either not a valid hint, or the vaddr 		 *	was not contained in the entry, so do a full lookup. 		 */
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|vaddr
argument_list|,
operator|&
name|tmp_entry
argument_list|)
condition|)
name|RETURN
argument_list|(
name|KERN_INVALID_ADDRESS
argument_list|)
expr_stmt|;
name|entry
operator|=
name|tmp_entry
expr_stmt|;
operator|*
name|out_entry
operator|=
name|entry
expr_stmt|;
block|}
comment|/* 	 *	Handle submaps. 	 */
if|if
condition|(
name|entry
operator|->
name|is_sub_map
condition|)
block|{
name|vm_map_t
name|old_map
init|=
name|map
decl_stmt|;
operator|*
name|var_map
operator|=
name|map
operator|=
name|entry
operator|->
name|object
operator|.
name|sub_map
expr_stmt|;
name|vm_map_unlock_read
argument_list|(
name|old_map
argument_list|)
expr_stmt|;
goto|goto
name|RetryLookup
goto|;
block|}
comment|/* 	 *	Check whether this task is allowed to have 	 *	this page. 	 */
name|prot
operator|=
name|entry
operator|->
name|protection
expr_stmt|;
if|if
condition|(
operator|(
name|fault_type
operator|&
operator|(
name|prot
operator|)
operator|)
operator|!=
name|fault_type
condition|)
name|RETURN
argument_list|(
name|KERN_PROTECTION_FAILURE
argument_list|)
expr_stmt|;
comment|/* 	 *	If this page is not pageable, we have to get 	 *	it for all possible accesses. 	 */
if|if
condition|(
operator|*
name|wired
operator|=
operator|(
name|entry
operator|->
name|wired_count
operator|!=
literal|0
operator|)
condition|)
name|prot
operator|=
name|fault_type
operator|=
name|entry
operator|->
name|protection
expr_stmt|;
comment|/* 	 *	If we don't already have a VM object, track 	 *	it down. 	 */
if|if
condition|(
name|su
operator|=
operator|!
name|entry
operator|->
name|is_a_map
condition|)
block|{
name|share_map
operator|=
name|map
expr_stmt|;
name|share_offset
operator|=
name|vaddr
expr_stmt|;
block|}
else|else
block|{
name|vm_map_entry_t
name|share_entry
decl_stmt|;
comment|/* 		 *	Compute the sharing map, and offset into it. 		 */
name|share_map
operator|=
name|entry
operator|->
name|object
operator|.
name|share_map
expr_stmt|;
name|share_offset
operator|=
operator|(
name|vaddr
operator|-
name|entry
operator|->
name|start
operator|)
operator|+
name|entry
operator|->
name|offset
expr_stmt|;
comment|/* 		 *	Look for the backing store object and offset 		 */
name|vm_map_lock_read
argument_list|(
name|share_map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|share_map
argument_list|,
name|share_offset
argument_list|,
operator|&
name|share_entry
argument_list|)
condition|)
block|{
name|vm_map_unlock_read
argument_list|(
name|share_map
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|KERN_INVALID_ADDRESS
argument_list|)
expr_stmt|;
block|}
name|entry
operator|=
name|share_entry
expr_stmt|;
block|}
comment|/* 	 *	If the entry was copy-on-write, we either ... 	 */
if|if
condition|(
name|entry
operator|->
name|needs_copy
condition|)
block|{
comment|/* 		 *	If we want to write the page, we may as well 		 *	handle that now since we've got the sharing 		 *	map locked. 		 * 		 *	If we don't need to write the page, we just 		 *	demote the permissions allowed. 		 */
if|if
condition|(
name|fault_type
operator|&
name|VM_PROT_WRITE
condition|)
block|{
comment|/* 			 *	Make a new object, and place it in the 			 *	object chain.  Note that no new references 			 *	have appeared -- one just moved from the 			 *	share map to the new object. 			 */
if|if
condition|(
name|lock_read_to_write
argument_list|(
operator|&
name|share_map
operator|->
name|lock
argument_list|)
condition|)
block|{
if|if
condition|(
name|share_map
operator|!=
name|map
condition|)
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
goto|goto
name|RetryLookup
goto|;
block|}
name|vm_object_shadow
argument_list|(
operator|&
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
call|(
name|vm_size_t
call|)
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|needs_copy
operator|=
name|FALSE
expr_stmt|;
name|lock_write_to_read
argument_list|(
operator|&
name|share_map
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 *	We're attempting to read a copy-on-write 			 *	page -- don't allow writes. 			 */
name|prot
operator|&=
operator|(
operator|~
name|VM_PROT_WRITE
operator|)
expr_stmt|;
block|}
block|}
comment|/* 	 *	Create an object if necessary. 	 */
if|if
condition|(
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lock_read_to_write
argument_list|(
operator|&
name|share_map
operator|->
name|lock
argument_list|)
condition|)
block|{
if|if
condition|(
name|share_map
operator|!=
name|map
condition|)
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
goto|goto
name|RetryLookup
goto|;
block|}
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|=
name|vm_object_allocate
argument_list|(
call|(
name|vm_size_t
call|)
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|lock_write_to_read
argument_list|(
operator|&
name|share_map
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Return the object/offset from this entry.  If the entry 	 *	was copy-on-write or empty, it has been fixed up. 	 */
operator|*
name|offset
operator|=
operator|(
name|share_offset
operator|-
name|entry
operator|->
name|start
operator|)
operator|+
name|entry
operator|->
name|offset
expr_stmt|;
operator|*
name|object
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
comment|/* 	 *	Return whether this is the only map sharing this data. 	 */
if|if
condition|(
operator|!
name|su
condition|)
block|{
name|simple_lock
argument_list|(
operator|&
name|share_map
operator|->
name|ref_lock
argument_list|)
expr_stmt|;
name|su
operator|=
operator|(
name|share_map
operator|->
name|ref_count
operator|==
literal|1
operator|)
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|share_map
operator|->
name|ref_lock
argument_list|)
expr_stmt|;
block|}
operator|*
name|out_prot
operator|=
name|prot
expr_stmt|;
operator|*
name|single_use
operator|=
name|su
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
undef|#
directive|undef
name|RETURN
block|}
end_block

begin_comment
comment|/*  *	vm_map_lookup_done:  *  *	Releases locks acquired by a vm_map_lookup  *	(according to the handle returned by that lookup).  */
end_comment

begin_function
name|void
name|vm_map_lookup_done
parameter_list|(
name|map
parameter_list|,
name|entry
parameter_list|)
specifier|register
name|vm_map_t
name|map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
block|{
comment|/* 	 *	If this entry references a map, unlock it first. 	 */
if|if
condition|(
name|entry
operator|->
name|is_a_map
condition|)
name|vm_map_unlock_read
argument_list|(
name|entry
operator|->
name|object
operator|.
name|share_map
argument_list|)
expr_stmt|;
comment|/* 	 *	Unlock the main-level map 	 */
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	vm_map_simplify  *	Purpose:  *		Attempt to simplify the map representation in  *		the vicinity of the given starting address.  *	Note:  *		This routine is intended primarily to keep the  *		kernel maps more compact -- they generally don't  *		benefit from the "expand a map entry" technology  *		at allocation time because the adjacent entry  *		is often wired down.  */
end_comment

begin_function
name|void
name|vm_map_simplify
parameter_list|(
name|map
parameter_list|,
name|start
parameter_list|)
name|vm_map_t
name|map
decl_stmt|;
name|vm_offset_t
name|start
decl_stmt|;
block|{
name|vm_map_entry_t
name|this_entry
decl_stmt|;
name|vm_map_entry_t
name|prev_entry
decl_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vm_map_lookup_entry
argument_list|(
name|map
argument_list|,
name|start
argument_list|,
operator|&
name|this_entry
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|prev_entry
operator|=
name|this_entry
operator|->
name|prev
operator|)
operator|!=
operator|&
name|map
operator|->
name|header
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|end
operator|==
name|start
operator|)
operator|&&
operator|(
name|map
operator|->
name|is_main_map
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|is_a_map
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|is_sub_map
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|this_entry
operator|->
name|is_a_map
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|this_entry
operator|->
name|is_sub_map
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|inheritance
operator|==
name|this_entry
operator|->
name|inheritance
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|protection
operator|==
name|this_entry
operator|->
name|protection
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|max_protection
operator|==
name|this_entry
operator|->
name|max_protection
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|wired_count
operator|==
name|this_entry
operator|->
name|wired_count
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|copy_on_write
operator|==
name|this_entry
operator|->
name|copy_on_write
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|needs_copy
operator|==
name|this_entry
operator|->
name|needs_copy
operator|)
operator|&&
operator|(
name|prev_entry
operator|->
name|object
operator|.
name|vm_object
operator|==
name|this_entry
operator|->
name|object
operator|.
name|vm_object
operator|)
operator|&&
operator|(
operator|(
name|prev_entry
operator|->
name|offset
operator|+
operator|(
name|prev_entry
operator|->
name|end
operator|-
name|prev_entry
operator|->
name|start
operator|)
operator|)
operator|==
name|this_entry
operator|->
name|offset
operator|)
condition|)
block|{
if|if
condition|(
name|map
operator|->
name|first_free
operator|==
name|this_entry
condition|)
name|map
operator|->
name|first_free
operator|=
name|prev_entry
expr_stmt|;
name|SAVE_HINT
argument_list|(
name|map
argument_list|,
name|prev_entry
argument_list|)
expr_stmt|;
name|vm_map_entry_unlink
argument_list|(
name|map
argument_list|,
name|this_entry
argument_list|)
expr_stmt|;
name|prev_entry
operator|->
name|end
operator|=
name|this_entry
operator|->
name|end
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|this_entry
operator|->
name|object
operator|.
name|vm_object
argument_list|)
expr_stmt|;
name|vm_map_entry_dispose
argument_list|(
name|map
argument_list|,
name|this_entry
argument_list|)
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	vm_map_print:	[ debug ]  */
end_comment

begin_function
name|void
name|vm_map_print
parameter_list|(
name|map
parameter_list|,
name|full
parameter_list|)
specifier|register
name|vm_map_t
name|map
decl_stmt|;
name|boolean_t
name|full
decl_stmt|;
block|{
specifier|register
name|vm_map_entry_t
name|entry
decl_stmt|;
specifier|extern
name|int
name|indent
decl_stmt|;
name|iprintf
argument_list|(
literal|"%s map 0x%x: pmap=0x%x,ref=%d,nentries=%d,version=%d\n"
argument_list|,
operator|(
name|map
operator|->
name|is_main_map
condition|?
literal|"Task"
else|:
literal|"Share"
operator|)
argument_list|,
operator|(
name|int
operator|)
name|map
argument_list|,
call|(
name|int
call|)
argument_list|(
name|map
operator|->
name|pmap
argument_list|)
argument_list|,
name|map
operator|->
name|ref_count
argument_list|,
name|map
operator|->
name|nentries
argument_list|,
name|map
operator|->
name|timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|full
operator|&&
name|indent
condition|)
return|return;
name|indent
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|map
operator|->
name|header
operator|.
name|next
init|;
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
name|iprintf
argument_list|(
literal|"map entry 0x%x: start=0x%x, end=0x%x, "
argument_list|,
operator|(
name|int
operator|)
name|entry
argument_list|,
operator|(
name|int
operator|)
name|entry
operator|->
name|start
argument_list|,
operator|(
name|int
operator|)
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|is_main_map
condition|)
block|{
specifier|static
name|char
modifier|*
name|inheritance_name
index|[
literal|4
index|]
init|=
block|{
literal|"share"
block|,
literal|"copy"
block|,
literal|"none"
block|,
literal|"donate_copy"
block|}
decl_stmt|;
name|printf
argument_list|(
literal|"prot=%x/%x/%s, "
argument_list|,
name|entry
operator|->
name|protection
argument_list|,
name|entry
operator|->
name|max_protection
argument_list|,
name|inheritance_name
index|[
name|entry
operator|->
name|inheritance
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"wired, "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|is_a_map
operator|||
name|entry
operator|->
name|is_sub_map
condition|)
block|{
name|printf
argument_list|(
literal|"share=0x%x, offset=0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|entry
operator|->
name|object
operator|.
name|share_map
argument_list|,
operator|(
name|int
operator|)
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|prev
operator|==
operator|&
name|map
operator|->
name|header
operator|)
operator|||
operator|(
operator|!
name|entry
operator|->
name|prev
operator|->
name|is_a_map
operator|)
operator|||
operator|(
name|entry
operator|->
name|prev
operator|->
name|object
operator|.
name|share_map
operator|!=
name|entry
operator|->
name|object
operator|.
name|share_map
operator|)
condition|)
block|{
name|indent
operator|+=
literal|2
expr_stmt|;
name|vm_map_print
argument_list|(
name|entry
operator|->
name|object
operator|.
name|share_map
argument_list|,
name|full
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"object=0x%x, offset=0x%x"
argument_list|,
operator|(
name|int
operator|)
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
operator|(
name|int
operator|)
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|copy_on_write
condition|)
name|printf
argument_list|(
literal|", copy (%s)"
argument_list|,
name|entry
operator|->
name|needs_copy
condition|?
literal|"needed"
else|:
literal|"done"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|prev
operator|==
operator|&
name|map
operator|->
name|header
operator|)
operator|||
operator|(
name|entry
operator|->
name|prev
operator|->
name|is_a_map
operator|)
operator|||
operator|(
name|entry
operator|->
name|prev
operator|->
name|object
operator|.
name|vm_object
operator|!=
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|)
condition|)
block|{
name|indent
operator|+=
literal|2
expr_stmt|;
name|vm_object_print
argument_list|(
name|entry
operator|->
name|object
operator|.
name|vm_object
argument_list|,
name|full
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
block|}
block|}
block|}
name|indent
operator|-=
literal|2
expr_stmt|;
block|}
end_function

end_unit

