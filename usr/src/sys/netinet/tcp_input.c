begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)tcp_input.c	7.15.1.3 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"in.h"
end_include

begin_include
include|#
directive|include
file|"in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"in_systm.h"
end_include

begin_include
include|#
directive|include
file|"ip.h"
end_include

begin_include
include|#
directive|include
file|"ip_var.h"
end_include

begin_include
include|#
directive|include
file|"tcp.h"
end_include

begin_include
include|#
directive|include
file|"tcp_fsm.h"
end_include

begin_include
include|#
directive|include
file|"tcp_seq.h"
end_include

begin_include
include|#
directive|include
file|"tcp_timer.h"
end_include

begin_include
include|#
directive|include
file|"tcp_var.h"
end_include

begin_include
include|#
directive|include
file|"tcpip.h"
end_include

begin_include
include|#
directive|include
file|"tcp_debug.h"
end_include

begin_decl_stmt
name|int
name|tcpprintfs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tcprexmtthresh
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tcpiphdr
name|tcp_saveti
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|tcpcb
modifier|*
name|tcp_newtcpcb
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Insert segment ti into reassembly queue of tcp with  * control block tp.  Return TH_FIN if reassembly now includes  * a segment with FIN.  The macro form does the common case inline  * (segment is the next to be received on an established connection,  * and the queue is empty), avoiding linkage into and removal  * from the queue and repetition of various conversions.  * Set DELACK for segments received in order, but ack immediately  * when segments are out of order (so fast retransmit can work).  */
end_comment

begin_define
define|#
directive|define
name|TCP_REASS
parameter_list|(
name|tp
parameter_list|,
name|ti
parameter_list|,
name|m
parameter_list|,
name|so
parameter_list|,
name|flags
parameter_list|)
value|{ \ 	if ((ti)->ti_seq == (tp)->rcv_nxt&& \ 	    (tp)->seg_next == (struct tcpiphdr *)(tp)&& \ 	    (tp)->t_state == TCPS_ESTABLISHED) { \ 		tp->t_flags |= TF_DELACK; \ 		(tp)->rcv_nxt += (ti)->ti_len; \ 		flags = (ti)->ti_flags& TH_FIN; \ 		tcpstat.tcps_rcvpack++;\ 		tcpstat.tcps_rcvbyte += (ti)->ti_len;\ 		sbappend(&(so)->so_rcv, (m)); \ 		sorwakeup(so); \ 	} else { \ 		(flags) = tcp_reass((tp), (ti)); \ 		tp->t_flags |= TF_ACKNOW; \ 	} \ }
end_define

begin_expr_stmt
name|tcp_reass
argument_list|(
name|tp
argument_list|,
name|ti
argument_list|)
specifier|register
expr|struct
name|tcpcb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|tcpiphdr
modifier|*
name|ti
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpiphdr
modifier|*
name|q
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|tp
operator|->
name|t_inpcb
operator|->
name|inp_socket
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* 	 * Call with ti==0 after become established to 	 * force pre-ESTABLISHED data up to user socket. 	 */
if|if
condition|(
name|ti
operator|==
literal|0
condition|)
goto|goto
name|present
goto|;
comment|/* 	 * Find a segment which begins after this one does. 	 */
for|for
control|(
name|q
operator|=
name|tp
operator|->
name|seg_next
init|;
name|q
operator|!=
operator|(
expr|struct
name|tcpiphdr
operator|*
operator|)
name|tp
condition|;
name|q
operator|=
operator|(
expr|struct
name|tcpiphdr
operator|*
operator|)
name|q
operator|->
name|ti_next
control|)
if|if
condition|(
name|SEQ_GT
argument_list|(
name|q
operator|->
name|ti_seq
argument_list|,
name|ti
operator|->
name|ti_seq
argument_list|)
condition|)
break|break;
comment|/* 	 * If there is a preceding segment, it may provide some of 	 * our data already.  If so, drop the data from the incoming 	 * segment.  If it provides all of our data, drop us. 	 */
if|if
condition|(
operator|(
expr|struct
name|tcpiphdr
operator|*
operator|)
name|q
operator|->
name|ti_prev
operator|!=
operator|(
expr|struct
name|tcpiphdr
operator|*
operator|)
name|tp
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|tcpiphdr
operator|*
operator|)
name|q
operator|->
name|ti_prev
expr_stmt|;
comment|/* conversion to int (in i) handles seq wraparound */
name|i
operator|=
name|q
operator|->
name|ti_seq
operator|+
name|q
operator|->
name|ti_len
operator|-
name|ti
operator|->
name|ti_seq
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|ti
operator|->
name|ti_len
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvduppack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvdupbyte
operator|+=
name|ti
operator|->
name|ti_len
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|m_adj
argument_list|(
name|dtom
argument_list|(
name|ti
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_len
operator|-=
name|i
expr_stmt|;
name|ti
operator|->
name|ti_seq
operator|+=
name|i
expr_stmt|;
block|}
name|q
operator|=
operator|(
expr|struct
name|tcpiphdr
operator|*
operator|)
operator|(
name|q
operator|->
name|ti_next
operator|)
expr_stmt|;
block|}
name|tcpstat
operator|.
name|tcps_rcvoopack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvoobyte
operator|+=
name|ti
operator|->
name|ti_len
expr_stmt|;
comment|/* 	 * While we overlap succeeding segments trim them or, 	 * if they are completely covered, dequeue them. 	 */
while|while
condition|(
name|q
operator|!=
operator|(
expr|struct
name|tcpiphdr
operator|*
operator|)
name|tp
condition|)
block|{
specifier|register
name|int
name|i
init|=
operator|(
name|ti
operator|->
name|ti_seq
operator|+
name|ti
operator|->
name|ti_len
operator|)
operator|-
name|q
operator|->
name|ti_seq
decl_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|q
operator|->
name|ti_len
condition|)
block|{
name|q
operator|->
name|ti_seq
operator|+=
name|i
expr_stmt|;
name|q
operator|->
name|ti_len
operator|-=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|q
operator|=
operator|(
expr|struct
name|tcpiphdr
operator|*
operator|)
name|q
operator|->
name|ti_next
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|q
operator|->
name|ti_prev
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|q
operator|->
name|ti_prev
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Stick new segment in its place. 	 */
name|insque
argument_list|(
name|ti
argument_list|,
name|q
operator|->
name|ti_prev
argument_list|)
expr_stmt|;
name|present
label|:
comment|/* 	 * Present data to user, advancing rcv_nxt through 	 * completed sequence space. 	 */
if|if
condition|(
name|TCPS_HAVERCVDSYN
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ti
operator|=
name|tp
operator|->
name|seg_next
expr_stmt|;
if|if
condition|(
name|ti
operator|==
operator|(
expr|struct
name|tcpiphdr
operator|*
operator|)
name|tp
operator|||
name|ti
operator|->
name|ti_seq
operator|!=
name|tp
operator|->
name|rcv_nxt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_SYN_RECEIVED
operator|&&
name|ti
operator|->
name|ti_len
condition|)
return|return
operator|(
literal|0
operator|)
return|;
do|do
block|{
name|tp
operator|->
name|rcv_nxt
operator|+=
name|ti
operator|->
name|ti_len
expr_stmt|;
name|flags
operator|=
name|ti
operator|->
name|ti_flags
operator|&
name|TH_FIN
expr_stmt|;
name|remque
argument_list|(
name|ti
argument_list|)
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|ti
argument_list|)
expr_stmt|;
name|ti
operator|=
operator|(
expr|struct
name|tcpiphdr
operator|*
operator|)
name|ti
operator|->
name|ti_next
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_CANTRCVMORE
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|sbappend
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ti
operator|!=
operator|(
expr|struct
name|tcpiphdr
operator|*
operator|)
name|tp
operator|&&
name|ti
operator|->
name|ti_seq
operator|==
name|tp
operator|->
name|rcv_nxt
condition|)
do|;
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|flags
operator|)
return|;
name|drop
label|:
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|ti
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * TCP input routine, follows pages 65-76 of the  * protocol specification dated September, 1981 very closely.  */
end_comment

begin_expr_stmt
name|tcp_input
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|iphlen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpiphdr
modifier|*
name|ti
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|om
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|,
name|tlen
decl_stmt|,
name|off
decl_stmt|;
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|tiflags
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|todrop
decl_stmt|,
name|acked
decl_stmt|,
name|ourfinisacked
decl_stmt|,
name|needoutput
init|=
literal|0
decl_stmt|;
name|short
name|ostate
decl_stmt|;
name|struct
name|in_addr
name|laddr
decl_stmt|;
name|int
name|dropsocket
init|=
literal|0
decl_stmt|;
name|int
name|iss
init|=
literal|0
decl_stmt|;
name|tcpstat
operator|.
name|tcps_rcvtotal
operator|++
expr_stmt|;
comment|/* 	 * Get IP and TCP header together in first mbuf. 	 * Note: IP leaves IP header in first mbuf. 	 */
name|ti
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tcpiphdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|iphlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
name|ip_stripoptions
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|||
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvshort
operator|++
expr_stmt|;
return|return;
block|}
name|ti
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tcpiphdr
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Checksum extended TCP header and data. 	 */
name|tlen
operator|=
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ti
operator|)
operator|->
name|ip_len
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|tlen
expr_stmt|;
name|ti
operator|->
name|ti_next
operator|=
name|ti
operator|->
name|ti_prev
operator|=
literal|0
expr_stmt|;
name|ti
operator|->
name|ti_x1
operator|=
literal|0
expr_stmt|;
name|ti
operator|->
name|ti_len
operator|=
operator|(
name|u_short
operator|)
name|tlen
expr_stmt|;
name|ti
operator|->
name|ti_len
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|ti
operator|->
name|ti_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|tcpprintfs
condition|)
name|printf
argument_list|(
literal|"tcp sum: src %x\n"
argument_list|,
name|ti
operator|->
name|ti_src
argument_list|)
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvbadsum
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * Check that TCP offset makes sense, 	 * pull out TCP options and adjust length. 	 */
name|off
operator|=
name|ti
operator|->
name|ti_off
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|off
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|||
name|off
operator|>
name|tlen
condition|)
block|{
if|if
condition|(
name|tcpprintfs
condition|)
name|printf
argument_list|(
literal|"tcp off: src %x off %d\n"
argument_list|,
name|ti
operator|->
name|ti_src
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvbadoff
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|tlen
operator|-=
name|off
expr_stmt|;
name|ti
operator|->
name|ti_len
operator|=
name|tlen
expr_stmt|;
if|if
condition|(
name|off
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|off
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|off
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvshort
operator|++
expr_stmt|;
return|return;
block|}
name|ti
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tcpiphdr
operator|*
argument_list|)
expr_stmt|;
block|}
name|om
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|om
operator|==
literal|0
condition|)
goto|goto
name|drop
goto|;
name|om
operator|->
name|m_len
operator|=
name|off
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
block|{
name|caddr_t
name|op
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|op
argument_list|,
name|mtod
argument_list|(
name|om
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|om
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|om
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|om
operator|->
name|m_len
expr_stmt|;
name|bcopy
argument_list|(
name|op
operator|+
name|om
operator|->
name|m_len
argument_list|,
name|op
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|m
operator|->
name|m_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|tiflags
operator|=
name|ti
operator|->
name|ti_flags
expr_stmt|;
comment|/* 	 * Drop TCP and IP headers; TCP options were dropped above. 	 */
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
expr_stmt|;
comment|/* 	 * Convert TCP protocol specific fields to host format. 	 */
name|ti
operator|->
name|ti_seq
operator|=
name|ntohl
argument_list|(
name|ti
operator|->
name|ti_seq
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_ack
operator|=
name|ntohl
argument_list|(
name|ti
operator|->
name|ti_ack
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_win
operator|=
name|ntohs
argument_list|(
name|ti
operator|->
name|ti_win
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_urp
operator|=
name|ntohs
argument_list|(
name|ti
operator|->
name|ti_urp
argument_list|)
expr_stmt|;
comment|/* 	 * Locate pcb for segment. 	 */
name|findpcb
label|:
name|inp
operator|=
name|in_pcblookup
argument_list|(
operator|&
name|tcb
argument_list|,
name|ti
operator|->
name|ti_src
argument_list|,
name|ti
operator|->
name|ti_sport
argument_list|,
name|ti
operator|->
name|ti_dst
argument_list|,
name|ti
operator|->
name|ti_dport
argument_list|,
name|INPLOOKUP_WILDCARD
argument_list|)
expr_stmt|;
comment|/* 	 * If the state is CLOSED (i.e., TCB does not exist) then 	 * all data in the incoming segment is discarded. 	 * If the TCB exists but is in CLOSED state, it is embryonic, 	 * but should either do a listen or a connect soon. 	 */
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
goto|goto
name|dropwithreset
goto|;
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
literal|0
condition|)
goto|goto
name|dropwithreset
goto|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|==
name|TCPS_CLOSED
condition|)
goto|goto
name|drop
goto|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
condition|)
block|{
name|ostate
operator|=
name|tp
operator|->
name|t_state
expr_stmt|;
name|tcp_saveti
operator|=
operator|*
name|ti
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
block|{
name|so
operator|=
name|sonewconn
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
literal|0
condition|)
goto|goto
name|drop
goto|;
comment|/* 		 * This is ugly, but .... 		 * 		 * Mark socket as temporary until we're 		 * committed to keeping it.  The code at 		 * ``drop'' and ``dropwithreset'' check the 		 * flag dropsocket to see if the temporary 		 * socket created here should be discarded. 		 * We mark the socket as discardable until 		 * we're committed to it below in TCPS_LISTEN. 		 */
name|dropsocket
operator|++
expr_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|inp
operator|->
name|inp_laddr
operator|=
name|ti
operator|->
name|ti_dst
expr_stmt|;
name|inp
operator|->
name|inp_lport
operator|=
name|ti
operator|->
name|ti_dport
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|43
name|inp
operator|->
name|inp_options
operator|=
name|ip_srcroute
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
block|}
comment|/* 	 * Segment received on connection. 	 * Reset idle time and keep-alive timer. 	 */
name|tp
operator|->
name|t_idle
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_timer
index|[
name|TCPT_KEEP
index|]
operator|=
name|tcp_keepidle
expr_stmt|;
comment|/* 	 * Process options if not in LISTEN state, 	 * else do it below (after getting remote address). 	 */
if|if
condition|(
name|om
operator|&&
name|tp
operator|->
name|t_state
operator|!=
name|TCPS_LISTEN
condition|)
block|{
name|tcp_dooptions
argument_list|(
name|tp
argument_list|,
name|om
argument_list|,
name|ti
argument_list|)
expr_stmt|;
name|om
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Calculate amount of space in receive window, 	 * and then do TCP input processing. 	 * Receive window is amount of space in rcv queue, 	 * but not less than advertised window. 	 */
block|{
name|int
name|win
decl_stmt|;
name|win
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|<
literal|0
condition|)
name|win
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|rcv_wnd
operator|=
name|max
argument_list|(
name|win
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tp
operator|->
name|rcv_adv
operator|-
name|tp
operator|->
name|rcv_nxt
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
comment|/* 	 * If the state is LISTEN then ignore segment if it contains an RST. 	 * If the segment contains an ACK then it is bad and send a RST. 	 * If it does not contain a SYN then it is not interesting; drop it. 	 * Don't bother responding if the destination was a broadcast. 	 * Otherwise initialize tp->rcv_nxt, and tp->irs, select an initial 	 * tp->iss, and send a segment: 	 *<SEQ=ISS><ACK=RCV_NXT><CTL=SYN,ACK> 	 * Also initialize tp->snd_nxt to tp->iss+1 and tp->snd_una to tp->iss. 	 * Fill in remote peer address fields if not previously specified. 	 * Enter SYN_RECEIVED state, and process any other fields of this 	 * segment in this state. 	 */
case|case
name|TCPS_LISTEN
case|:
block|{
name|struct
name|mbuf
modifier|*
name|am
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
if|if
condition|(
name|tiflags
operator|&
name|TH_RST
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
name|tiflags
operator|&
name|TH_ACK
condition|)
goto|goto
name|dropwithreset
goto|;
if|if
condition|(
operator|(
name|tiflags
operator|&
name|TH_SYN
operator|)
operator|==
literal|0
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_BCAST
condition|)
goto|goto
name|drop
goto|;
name|am
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|==
name|NULL
condition|)
goto|goto
name|drop
goto|;
name|am
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|=
name|mtod
argument_list|(
name|am
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|ti
operator|->
name|ti_src
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|ti
operator|->
name|ti_sport
expr_stmt|;
name|laddr
operator|=
name|inp
operator|->
name|inp_laddr
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|inp
operator|->
name|inp_laddr
operator|=
name|ti
operator|->
name|ti_dst
expr_stmt|;
if|if
condition|(
name|in_pcbconnect
argument_list|(
name|inp
argument_list|,
name|am
argument_list|)
condition|)
block|{
name|inp
operator|->
name|inp_laddr
operator|=
name|laddr
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|am
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|am
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_template
operator|=
name|tcp_template
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_template
operator|==
literal|0
condition|)
block|{
name|tp
operator|=
name|tcp_drop
argument_list|(
name|tp
argument_list|,
name|ENOBUFS
argument_list|)
expr_stmt|;
name|dropsocket
operator|=
literal|0
expr_stmt|;
comment|/* socket is already gone */
goto|goto
name|drop
goto|;
block|}
if|if
condition|(
name|om
condition|)
block|{
name|tcp_dooptions
argument_list|(
name|tp
argument_list|,
name|om
argument_list|,
name|ti
argument_list|)
expr_stmt|;
name|om
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|iss
condition|)
name|tp
operator|->
name|iss
operator|=
name|iss
expr_stmt|;
else|else
name|tp
operator|->
name|iss
operator|=
name|tcp_iss
expr_stmt|;
name|tcp_iss
operator|+=
name|TCP_ISSINCR
operator|/
literal|2
expr_stmt|;
name|tp
operator|->
name|irs
operator|=
name|ti
operator|->
name|ti_seq
expr_stmt|;
name|tcp_sendseqinit
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tcp_rcvseqinit
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TCPS_SYN_RECEIVED
expr_stmt|;
name|tp
operator|->
name|t_timer
index|[
name|TCPT_KEEP
index|]
operator|=
name|TCPTV_KEEP_INIT
expr_stmt|;
name|dropsocket
operator|=
literal|0
expr_stmt|;
comment|/* committed to socket */
name|tcpstat
operator|.
name|tcps_accepts
operator|++
expr_stmt|;
goto|goto
name|trimthenstep6
goto|;
block|}
comment|/* 	 * If the state is SYN_SENT: 	 *	if seg contains an ACK, but not for our SYN, drop the input. 	 *	if seg contains a RST, then drop the connection. 	 *	if seg does not contain SYN, then drop it. 	 * Otherwise this is an acceptable SYN segment 	 *	initialize tp->rcv_nxt and tp->irs 	 *	if seg contains ack then advance tp->snd_una 	 *	if SYN has been acked change to ESTABLISHED else SYN_RCVD state 	 *	arrange for segment to be acked (eventually) 	 *	continue processing rest of data/controls, beginning with URG 	 */
case|case
name|TCPS_SYN_SENT
case|:
if|if
condition|(
operator|(
name|tiflags
operator|&
name|TH_ACK
operator|)
operator|&&
operator|(
name|SEQ_LEQ
argument_list|(
name|ti
operator|->
name|ti_ack
argument_list|,
name|tp
operator|->
name|iss
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|ti
operator|->
name|ti_ack
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
operator|)
condition|)
goto|goto
name|dropwithreset
goto|;
if|if
condition|(
name|tiflags
operator|&
name|TH_RST
condition|)
block|{
if|if
condition|(
name|tiflags
operator|&
name|TH_ACK
condition|)
name|tp
operator|=
name|tcp_drop
argument_list|(
name|tp
argument_list|,
name|ECONNREFUSED
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
if|if
condition|(
operator|(
name|tiflags
operator|&
name|TH_SYN
operator|)
operator|==
literal|0
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
name|tiflags
operator|&
name|TH_ACK
condition|)
block|{
name|tp
operator|->
name|snd_una
operator|=
name|ti
operator|->
name|ti_ack
expr_stmt|;
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
condition|)
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|snd_una
expr_stmt|;
block|}
name|tp
operator|->
name|t_timer
index|[
name|TCPT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|irs
operator|=
name|ti
operator|->
name|ti_seq
expr_stmt|;
name|tcp_rcvseqinit
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
if|if
condition|(
name|tiflags
operator|&
name|TH_ACK
operator|&&
name|SEQ_GT
argument_list|(
name|tp
operator|->
name|snd_una
argument_list|,
name|tp
operator|->
name|iss
argument_list|)
condition|)
block|{
name|tcpstat
operator|.
name|tcps_connects
operator|++
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
name|tp
operator|->
name|t_maxseg
operator|=
name|min
argument_list|(
name|tp
operator|->
name|t_maxseg
argument_list|,
name|tcp_mss
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcp_reass
argument_list|(
name|tp
argument_list|,
operator|(
expr|struct
name|tcpiphdr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * if we didn't have to retransmit the SYN, 			 * use its rtt as our initial srtt& rtt var. 			 */
if|if
condition|(
name|tp
operator|->
name|t_rtt
condition|)
block|{
name|tp
operator|->
name|t_srtt
operator|=
name|tp
operator|->
name|t_rtt
operator|<<
literal|3
expr_stmt|;
name|tp
operator|->
name|t_rttvar
operator|=
name|tp
operator|->
name|t_rtt
operator|<<
literal|1
expr_stmt|;
name|TCPT_RANGESET
argument_list|(
name|tp
operator|->
name|t_rxtcur
argument_list|,
operator|(
operator|(
name|tp
operator|->
name|t_srtt
operator|>>
literal|2
operator|)
operator|+
name|tp
operator|->
name|t_rttvar
operator|)
operator|>>
literal|1
argument_list|,
name|TCPTV_MIN
argument_list|,
name|TCPTV_REXMTMAX
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|tp
operator|->
name|t_state
operator|=
name|TCPS_SYN_RECEIVED
expr_stmt|;
name|trimthenstep6
label|:
comment|/* 		 * Advance ti->ti_seq to correspond to first data byte. 		 * If data, trim to stay within window, 		 * dropping FIN if necessary. 		 */
name|ti
operator|->
name|ti_seq
operator|++
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_len
operator|>
name|tp
operator|->
name|rcv_wnd
condition|)
block|{
name|todrop
operator|=
name|ti
operator|->
name|ti_len
operator|-
name|tp
operator|->
name|rcv_wnd
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|43
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|todrop
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* XXX work around 4.2 m_adj bug */
if|if
condition|(
name|m
operator|->
name|m_len
condition|)
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|todrop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* skip tcp/ip header in first mbuf */
name|m_adj
argument_list|(
name|m
operator|->
name|m_next
argument_list|,
operator|-
name|todrop
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ti
operator|->
name|ti_len
operator|=
name|tp
operator|->
name|rcv_wnd
expr_stmt|;
name|tiflags
operator|&=
operator|~
name|TH_FIN
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvpackafterwin
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvbyteafterwin
operator|+=
name|todrop
expr_stmt|;
block|}
name|tp
operator|->
name|snd_wl1
operator|=
name|ti
operator|->
name|ti_seq
operator|-
literal|1
expr_stmt|;
name|tp
operator|->
name|rcv_up
operator|=
name|ti
operator|->
name|ti_seq
expr_stmt|;
goto|goto
name|step6
goto|;
block|}
comment|/* 	 * States other than LISTEN or SYN_SENT. 	 * First check that at least some bytes of segment are within  	 * receive window.  If segment begins before rcv_nxt, 	 * drop leading data (and SYN); if nothing left, just ack. 	 */
name|todrop
operator|=
name|tp
operator|->
name|rcv_nxt
operator|-
name|ti
operator|->
name|ti_seq
expr_stmt|;
if|if
condition|(
name|todrop
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tiflags
operator|&
name|TH_SYN
condition|)
block|{
name|tiflags
operator|&=
operator|~
name|TH_SYN
expr_stmt|;
name|ti
operator|->
name|ti_seq
operator|++
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_urp
operator|>
literal|1
condition|)
name|ti
operator|->
name|ti_urp
operator|--
expr_stmt|;
else|else
name|tiflags
operator|&=
operator|~
name|TH_URG
expr_stmt|;
name|todrop
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|todrop
operator|>
name|ti
operator|->
name|ti_len
operator|||
name|todrop
operator|==
name|ti
operator|->
name|ti_len
operator|&&
operator|(
name|tiflags
operator|&
name|TH_FIN
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvduppack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvdupbyte
operator|+=
name|ti
operator|->
name|ti_len
expr_stmt|;
comment|/* 			 * If segment is just one to the left of the window, 			 * check two special cases: 			 * 1. Don't toss RST in response to 4.2-style keepalive. 			 * 2. If the only thing to drop is a FIN, we can drop 			 *    it, but check the ACK or we will get into FIN 			 *    wars if our FINs crossed (both CLOSING). 			 * In either case, send ACK to resynchronize, 			 * but keep on processing for RST or ACK. 			 */
if|if
condition|(
operator|(
name|tiflags
operator|&
name|TH_FIN
operator|&&
name|todrop
operator|==
name|ti
operator|->
name|ti_len
operator|+
literal|1
operator|)
ifdef|#
directive|ifdef
name|TCP_COMPAT_42
operator|||
operator|(
name|tiflags
operator|&
name|TH_RST
operator|&&
name|ti
operator|->
name|ti_seq
operator|==
name|tp
operator|->
name|rcv_nxt
operator|-
literal|1
operator|)
endif|#
directive|endif
condition|)
block|{
name|todrop
operator|=
name|ti
operator|->
name|ti_len
expr_stmt|;
name|tiflags
operator|&=
operator|~
name|TH_FIN
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
block|}
else|else
goto|goto
name|dropafterack
goto|;
block|}
else|else
block|{
name|tcpstat
operator|.
name|tcps_rcvpartduppack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvpartdupbyte
operator|+=
name|todrop
expr_stmt|;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
name|todrop
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_seq
operator|+=
name|todrop
expr_stmt|;
name|ti
operator|->
name|ti_len
operator|-=
name|todrop
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_urp
operator|>
name|todrop
condition|)
name|ti
operator|->
name|ti_urp
operator|-=
name|todrop
expr_stmt|;
else|else
block|{
name|tiflags
operator|&=
operator|~
name|TH_URG
expr_stmt|;
name|ti
operator|->
name|ti_urp
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * If new data are received on a connection after the 	 * user processes are gone, then RST the other end. 	 */
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
operator|)
operator|&&
name|tp
operator|->
name|t_state
operator|>
name|TCPS_CLOSE_WAIT
operator|&&
name|ti
operator|->
name|ti_len
condition|)
block|{
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvafterclose
operator|++
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
comment|/* 	 * If segment ends after window, drop trailing data 	 * (and PUSH and FIN); if nothing left, just ACK. 	 */
name|todrop
operator|=
operator|(
name|ti
operator|->
name|ti_seq
operator|+
name|ti
operator|->
name|ti_len
operator|)
operator|-
operator|(
name|tp
operator|->
name|rcv_nxt
operator|+
name|tp
operator|->
name|rcv_wnd
operator|)
expr_stmt|;
if|if
condition|(
name|todrop
operator|>
literal|0
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvpackafterwin
operator|++
expr_stmt|;
if|if
condition|(
name|todrop
operator|>=
name|ti
operator|->
name|ti_len
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvbyteafterwin
operator|+=
name|ti
operator|->
name|ti_len
expr_stmt|;
comment|/* 			 * If a new connection request is received 			 * while in TIME_WAIT, drop the old connection 			 * and start over if the sequence numbers 			 * are above the previous ones. 			 */
if|if
condition|(
name|tiflags
operator|&
name|TH_SYN
operator|&&
name|tp
operator|->
name|t_state
operator|==
name|TCPS_TIME_WAIT
operator|&&
name|SEQ_GT
argument_list|(
name|ti
operator|->
name|ti_seq
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|)
condition|)
block|{
name|iss
operator|=
name|tp
operator|->
name|rcv_nxt
operator|+
name|TCP_ISSINCR
expr_stmt|;
operator|(
name|void
operator|)
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|findpcb
goto|;
block|}
comment|/* 			 * If window is closed can only take segments at 			 * window edge, and have to drop data and PUSH from 			 * incoming segments.  Continue processing, but 			 * remember to ack.  Otherwise, drop segment 			 * and ack. 			 */
if|if
condition|(
name|tp
operator|->
name|rcv_wnd
operator|==
literal|0
operator|&&
name|ti
operator|->
name|ti_seq
operator|==
name|tp
operator|->
name|rcv_nxt
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvwinprobe
operator|++
expr_stmt|;
block|}
else|else
goto|goto
name|dropafterack
goto|;
block|}
else|else
name|tcpstat
operator|.
name|tcps_rcvbyteafterwin
operator|+=
name|todrop
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|43
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|todrop
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* XXX work around m_adj bug */
if|if
condition|(
name|m
operator|->
name|m_len
condition|)
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|todrop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* skip tcp/ip header in first mbuf */
name|m_adj
argument_list|(
name|m
operator|->
name|m_next
argument_list|,
operator|-
name|todrop
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ti
operator|->
name|ti_len
operator|-=
name|todrop
expr_stmt|;
name|tiflags
operator|&=
operator|~
operator|(
name|TH_PUSH
operator||
name|TH_FIN
operator|)
expr_stmt|;
block|}
comment|/* 	 * If the RST bit is set examine the state: 	 *    SYN_RECEIVED STATE: 	 *	If passive open, return to LISTEN state. 	 *	If active open, inform user that connection was refused. 	 *    ESTABLISHED, FIN_WAIT_1, FIN_WAIT2, CLOSE_WAIT STATES: 	 *	Inform user that connection was reset, and close tcb. 	 *    CLOSING, LAST_ACK, TIME_WAIT STATES 	 *	Close the tcb. 	 */
if|if
condition|(
name|tiflags
operator|&
name|TH_RST
condition|)
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
case|case
name|TCPS_SYN_RECEIVED
case|:
name|so
operator|->
name|so_error
operator|=
name|ECONNREFUSED
expr_stmt|;
goto|goto
name|close
goto|;
case|case
name|TCPS_ESTABLISHED
case|:
case|case
name|TCPS_FIN_WAIT_1
case|:
case|case
name|TCPS_FIN_WAIT_2
case|:
case|case
name|TCPS_CLOSE_WAIT
case|:
name|so
operator|->
name|so_error
operator|=
name|ECONNRESET
expr_stmt|;
name|close
label|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_CLOSED
expr_stmt|;
name|tcpstat
operator|.
name|tcps_drops
operator|++
expr_stmt|;
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
case|case
name|TCPS_CLOSING
case|:
case|case
name|TCPS_LAST_ACK
case|:
case|case
name|TCPS_TIME_WAIT
case|:
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * If a SYN is in the window, then this is an 	 * error and we send an RST and drop the connection. 	 */
if|if
condition|(
name|tiflags
operator|&
name|TH_SYN
condition|)
block|{
name|tp
operator|=
name|tcp_drop
argument_list|(
name|tp
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
comment|/* 	 * If the ACK bit is off we drop the segment and return. 	 */
if|if
condition|(
operator|(
name|tiflags
operator|&
name|TH_ACK
operator|)
operator|==
literal|0
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Ack processing. 	 */
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
comment|/* 	 * In SYN_RECEIVED state if the ack ACKs our SYN then enter 	 * ESTABLISHED state and continue processing, otherwise 	 * send an RST. 	 */
case|case
name|TCPS_SYN_RECEIVED
case|:
if|if
condition|(
name|SEQ_GT
argument_list|(
name|tp
operator|->
name|snd_una
argument_list|,
name|ti
operator|->
name|ti_ack
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|ti
operator|->
name|ti_ack
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
condition|)
goto|goto
name|dropwithreset
goto|;
name|tcpstat
operator|.
name|tcps_connects
operator|++
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
name|tp
operator|->
name|t_maxseg
operator|=
name|min
argument_list|(
name|tp
operator|->
name|t_maxseg
argument_list|,
name|tcp_mss
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcp_reass
argument_list|(
name|tp
argument_list|,
operator|(
expr|struct
name|tcpiphdr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_wl1
operator|=
name|ti
operator|->
name|ti_seq
operator|-
literal|1
expr_stmt|;
comment|/* fall into ... */
comment|/* 	 * In ESTABLISHED state: drop duplicate ACKs; ACK out of range 	 * ACKs.  If the ack is in the range 	 *	tp->snd_una< ti->ti_ack<= tp->snd_max 	 * then advance tp->snd_una to ti->ti_ack and drop 	 * data from the retransmission queue.  If this ACK reflects 	 * more up to date window information we update our window information. 	 */
case|case
name|TCPS_ESTABLISHED
case|:
case|case
name|TCPS_FIN_WAIT_1
case|:
case|case
name|TCPS_FIN_WAIT_2
case|:
case|case
name|TCPS_CLOSE_WAIT
case|:
case|case
name|TCPS_CLOSING
case|:
case|case
name|TCPS_LAST_ACK
case|:
case|case
name|TCPS_TIME_WAIT
case|:
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|ti
operator|->
name|ti_ack
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
condition|)
block|{
if|if
condition|(
name|ti
operator|->
name|ti_len
operator|==
literal|0
operator|&&
name|ti
operator|->
name|ti_win
operator|==
name|tp
operator|->
name|snd_wnd
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvdupack
operator|++
expr_stmt|;
comment|/* 				 * If we have outstanding data (not a 				 * window probe), this is a completely 				 * duplicate ack (ie, window info didn't 				 * change), the ack is the biggest we've 				 * seen and we've seen exactly our rexmt 				 * threshhold of them, assume a packet 				 * has been dropped and retransmit it. 				 * Kludge snd_nxt& the congestion 				 * window so we send only this one 				 * packet.  If this packet fills the 				 * only hole in the receiver's seq. 				 * space, the next real ack will fully 				 * open our window.  This means we 				 * have to do the usual slow-start to 				 * not overwhelm an intermediate gateway 				 * with a burst of packets.  Leave 				 * here with the congestion window set 				 * to allow 2 packets on the next real 				 * ack and the exp-to-linear thresh 				 * set for half the current window 				 * size (since we know we're losing at 				 * the current window size). 				 */
if|if
condition|(
name|tp
operator|->
name|t_timer
index|[
name|TCPT_REXMT
index|]
operator|==
literal|0
operator|||
name|ti
operator|->
name|ti_ack
operator|!=
name|tp
operator|->
name|snd_una
condition|)
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|tp
operator|->
name|t_dupacks
operator|==
name|tcprexmtthresh
condition|)
block|{
name|tcp_seq
name|onxt
init|=
name|tp
operator|->
name|snd_nxt
decl_stmt|;
name|u_int
name|win
init|=
name|min
argument_list|(
name|tp
operator|->
name|snd_wnd
argument_list|,
name|tp
operator|->
name|snd_cwnd
argument_list|)
operator|/
literal|2
operator|/
name|tp
operator|->
name|t_maxseg
decl_stmt|;
if|if
condition|(
name|win
operator|<
literal|2
condition|)
name|win
operator|=
literal|2
expr_stmt|;
name|tp
operator|->
name|snd_ssthresh
operator|=
name|win
operator|*
name|tp
operator|->
name|t_maxseg
expr_stmt|;
name|tp
operator|->
name|t_timer
index|[
name|TCPT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_rtt
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|snd_nxt
operator|=
name|ti
operator|->
name|ti_ack
expr_stmt|;
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|t_maxseg
expr_stmt|;
operator|(
name|void
operator|)
name|tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|onxt
argument_list|,
name|tp
operator|->
name|snd_nxt
argument_list|)
condition|)
name|tp
operator|->
name|snd_nxt
operator|=
name|onxt
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
block|}
else|else
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|tp
operator|->
name|t_dupacks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|ti
operator|->
name|ti_ack
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvacktoomuch
operator|++
expr_stmt|;
goto|goto
name|dropafterack
goto|;
block|}
name|acked
operator|=
name|ti
operator|->
name|ti_ack
operator|-
name|tp
operator|->
name|snd_una
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvackpack
operator|++
expr_stmt|;
name|tcpstat
operator|.
name|tcps_rcvackbyte
operator|+=
name|acked
expr_stmt|;
comment|/* 		 * If transmit timer is running and timed sequence 		 * number was acked, update smoothed round trip time. 		 * Since we now have an rtt measurement, cancel the 		 * timer backoff (cf., Phil Karn's retransmit alg.). 		 * Recompute the initial retransmit timer. 		 */
if|if
condition|(
name|tp
operator|->
name|t_rtt
operator|&&
name|SEQ_GT
argument_list|(
name|ti
operator|->
name|ti_ack
argument_list|,
name|tp
operator|->
name|t_rtseq
argument_list|)
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rttupdated
operator|++
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_srtt
operator|!=
literal|0
condition|)
block|{
specifier|register
name|short
name|delta
decl_stmt|;
comment|/* 				 * srtt is stored as fixed point with 3 bits 				 * after the binary point (i.e., scaled by 8). 				 * The following magic is equivalent 				 * to the smoothing algorithm in rfc793 				 * with an alpha of .875 				 * (srtt = rtt/8 + srtt*7/8 in fixed point). 				 * Adjust t_rtt to origin 0. 				 */
name|delta
operator|=
name|tp
operator|->
name|t_rtt
operator|-
literal|1
operator|-
operator|(
name|tp
operator|->
name|t_srtt
operator|>>
literal|3
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_srtt
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|tp
operator|->
name|t_srtt
operator|=
literal|1
expr_stmt|;
comment|/* 				 * We accumulate a smoothed rtt variance 				 * (actually, a smoothed mean difference), 				 * then set the retransmit timer to smoothed 				 * rtt + 2 times the smoothed variance. 				 * rttvar is stored as fixed point 				 * with 2 bits after the binary point 				 * (scaled by 4).  The following is equivalent 				 * to rfc793 smoothing with an alpha of .75 				 * (rttvar = rttvar*3/4 + |delta| / 4). 				 * This replaces rfc793's wired-in beta. 				 */
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
name|delta
operator|-=
operator|(
name|tp
operator|->
name|t_rttvar
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_rttvar
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|tp
operator|->
name|t_rttvar
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/*  				 * No rtt measurement yet - use the 				 * unsmoothed rtt.  Set the variance 				 * to half the rtt (so our first 				 * retransmit happens at 2*rtt) 				 */
name|tp
operator|->
name|t_srtt
operator|=
name|tp
operator|->
name|t_rtt
operator|<<
literal|3
expr_stmt|;
name|tp
operator|->
name|t_rttvar
operator|=
name|tp
operator|->
name|t_rtt
operator|<<
literal|1
expr_stmt|;
block|}
name|tp
operator|->
name|t_rtt
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_rxtshift
operator|=
literal|0
expr_stmt|;
name|TCPT_RANGESET
argument_list|(
name|tp
operator|->
name|t_rxtcur
argument_list|,
operator|(
operator|(
name|tp
operator|->
name|t_srtt
operator|>>
literal|2
operator|)
operator|+
name|tp
operator|->
name|t_rttvar
operator|)
operator|>>
literal|1
argument_list|,
name|TCPTV_MIN
argument_list|,
name|TCPTV_REXMTMAX
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If all outstanding data is acked, stop retransmit 		 * timer and remember to restart (more output or persist). 		 * If there is more data to be acked, restart retransmit 		 * timer, using current (possibly backed-off) value. 		 */
if|if
condition|(
name|ti
operator|->
name|ti_ack
operator|==
name|tp
operator|->
name|snd_max
condition|)
block|{
name|tp
operator|->
name|t_timer
index|[
name|TCPT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|needoutput
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_timer
index|[
name|TCPT_PERSIST
index|]
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_timer
index|[
name|TCPT_REXMT
index|]
operator|=
name|tp
operator|->
name|t_rxtcur
expr_stmt|;
comment|/* 		 * When new data is acked, open the congestion window. 		 * If the window gives us less than ssthresh packets 		 * in flight, open exponentially (maxseg per packet). 		 * Otherwise open linearly (maxseg per window, 		 * or maxseg^2 / cwnd per packet). 		 */
block|{
name|u_int
name|incr
init|=
name|tp
operator|->
name|t_maxseg
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|snd_cwnd
operator|>
name|tp
operator|->
name|snd_ssthresh
condition|)
name|incr
operator|=
name|max
argument_list|(
name|incr
operator|*
name|incr
operator|/
name|tp
operator|->
name|snd_cwnd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_cwnd
operator|=
name|min
argument_list|(
name|tp
operator|->
name|snd_cwnd
operator|+
name|incr
argument_list|,
name|USHRT_MAX
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
if|if
condition|(
name|acked
operator|>
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
condition|)
block|{
name|tp
operator|->
name|snd_wnd
operator|-=
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
expr_stmt|;
name|sbdrop
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
operator|(
name|int
operator|)
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
name|ourfinisacked
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sbdrop
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|acked
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_wnd
operator|-=
name|acked
expr_stmt|;
name|ourfinisacked
operator|=
literal|0
expr_stmt|;
block|}
name|sowwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_una
operator|=
name|ti
operator|->
name|ti_ack
expr_stmt|;
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
condition|)
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|snd_una
expr_stmt|;
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
comment|/* 		 * In FIN_WAIT_1 STATE in addition to the processing 		 * for the ESTABLISHED state if our FIN is now acknowledged 		 * then enter FIN_WAIT_2. 		 */
case|case
name|TCPS_FIN_WAIT_1
case|:
if|if
condition|(
name|ourfinisacked
condition|)
block|{
comment|/* 				 * If we can't receive any more 				 * data, then closing user can proceed. 				 * Starting the timer is contrary to the 				 * specification, but if we don't get a FIN 				 * we'll hang forever. 				 */
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_CANTRCVMORE
condition|)
block|{
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_timer
index|[
name|TCPT_2MSL
index|]
operator|=
name|tcp_maxidle
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|=
name|TCPS_FIN_WAIT_2
expr_stmt|;
block|}
break|break;
comment|/* 		 * In CLOSING STATE in addition to the processing for 		 * the ESTABLISHED state if the ACK acknowledges our FIN 		 * then enter the TIME-WAIT state, otherwise ignore 		 * the segment. 		 */
case|case
name|TCPS_CLOSING
case|:
if|if
condition|(
name|ourfinisacked
condition|)
block|{
name|tp
operator|->
name|t_state
operator|=
name|TCPS_TIME_WAIT
expr_stmt|;
name|tcp_canceltimers
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_timer
index|[
name|TCPT_2MSL
index|]
operator|=
literal|2
operator|*
name|TCPTV_MSL
expr_stmt|;
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 		 * In LAST_ACK, we may still be waiting for data to drain 		 * and/or to be acked, as well as for the ack of our FIN. 		 * If our FIN is now acknowledged, delete the TCB, 		 * enter the closed state and return. 		 */
case|case
name|TCPS_LAST_ACK
case|:
if|if
condition|(
name|ourfinisacked
condition|)
block|{
name|tp
operator|=
name|tcp_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
break|break;
comment|/* 		 * In TIME_WAIT state the only thing that should arrive 		 * is a retransmission of the remote FIN.  Acknowledge 		 * it and restart the finack timer. 		 */
case|case
name|TCPS_TIME_WAIT
case|:
name|tp
operator|->
name|t_timer
index|[
name|TCPT_2MSL
index|]
operator|=
literal|2
operator|*
name|TCPTV_MSL
expr_stmt|;
goto|goto
name|dropafterack
goto|;
block|}
block|}
name|step6
label|:
comment|/* 	 * Update window information. 	 * Don't look at window if no ACK: TAC's send garbage on first SYN. 	 */
if|if
condition|(
operator|(
name|tiflags
operator|&
name|TH_ACK
operator|)
operator|&&
operator|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_wl1
argument_list|,
name|ti
operator|->
name|ti_seq
argument_list|)
operator|||
name|tp
operator|->
name|snd_wl1
operator|==
name|ti
operator|->
name|ti_seq
operator|&&
operator|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_wl2
argument_list|,
name|ti
operator|->
name|ti_ack
argument_list|)
operator|||
name|tp
operator|->
name|snd_wl2
operator|==
name|ti
operator|->
name|ti_ack
operator|&&
name|ti
operator|->
name|ti_win
operator|>
name|tp
operator|->
name|snd_wnd
operator|)
operator|)
condition|)
block|{
comment|/* keep track of pure window updates */
if|if
condition|(
name|ti
operator|->
name|ti_len
operator|==
literal|0
operator|&&
name|tp
operator|->
name|snd_wl2
operator|==
name|ti
operator|->
name|ti_ack
operator|&&
name|ti
operator|->
name|ti_win
operator|>
name|tp
operator|->
name|snd_wnd
condition|)
name|tcpstat
operator|.
name|tcps_rcvwinupd
operator|++
expr_stmt|;
name|tp
operator|->
name|snd_wnd
operator|=
name|ti
operator|->
name|ti_win
expr_stmt|;
name|tp
operator|->
name|snd_wl1
operator|=
name|ti
operator|->
name|ti_seq
expr_stmt|;
name|tp
operator|->
name|snd_wl2
operator|=
name|ti
operator|->
name|ti_ack
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|snd_wnd
operator|>
name|tp
operator|->
name|max_sndwnd
condition|)
name|tp
operator|->
name|max_sndwnd
operator|=
name|tp
operator|->
name|snd_wnd
expr_stmt|;
name|needoutput
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Process segments with URG. 	 */
if|if
condition|(
operator|(
name|tiflags
operator|&
name|TH_URG
operator|)
operator|&&
name|ti
operator|->
name|ti_urp
operator|&&
name|TCPS_HAVERCVDFIN
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This is a kludge, but if we receive and accept 		 * random urgent pointers, we'll crash in 		 * soreceive.  It's hard to imagine someone 		 * actually wanting to send this much urgent data. 		 */
if|if
condition|(
name|ti
operator|->
name|ti_urp
operator|+
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>
name|SB_MAX
condition|)
block|{
name|ti
operator|->
name|ti_urp
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|tiflags
operator|&=
operator|~
name|TH_URG
expr_stmt|;
comment|/* XXX */
goto|goto
name|dodata
goto|;
comment|/* XXX */
block|}
comment|/* 		 * If this segment advances the known urgent pointer, 		 * then mark the data stream.  This should not happen 		 * in CLOSE_WAIT, CLOSING, LAST_ACK or TIME_WAIT STATES since 		 * a FIN has been received from the remote side.  		 * In these states we ignore the URG. 		 * 		 * According to RFC961 (Assigned Protocols), 		 * the urgent pointer points to the last octet 		 * of urgent data.  We continue, however, 		 * to consider it to indicate the first octet 		 * of data past the urgent section 		 * as the original spec states. 		 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|ti
operator|->
name|ti_seq
operator|+
name|ti
operator|->
name|ti_urp
argument_list|,
name|tp
operator|->
name|rcv_up
argument_list|)
condition|)
block|{
name|tp
operator|->
name|rcv_up
operator|=
name|ti
operator|->
name|ti_seq
operator|+
name|ti
operator|->
name|ti_urp
expr_stmt|;
name|so
operator|->
name|so_oobmark
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|+
operator|(
name|tp
operator|->
name|rcv_up
operator|-
name|tp
operator|->
name|rcv_nxt
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_oobmark
operator|==
literal|0
condition|)
name|so
operator|->
name|so_state
operator||=
name|SS_RCVATMARK
expr_stmt|;
name|sohasoutofband
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_oobflags
operator|&=
operator|~
operator|(
name|TCPOOB_HAVEDATA
operator||
name|TCPOOB_HADDATA
operator|)
expr_stmt|;
block|}
comment|/* 		 * Remove out of band data so doesn't get presented to user. 		 * This can happen independent of advancing the URG pointer, 		 * but if two URG's are pending at once, some out-of-band 		 * data may creep in... ick. 		 */
if|if
condition|(
name|ti
operator|->
name|ti_urp
operator|<=
name|ti
operator|->
name|ti_len
ifdef|#
directive|ifdef
name|SO_OOBINLINE
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_OOBINLINE
operator|)
operator|==
literal|0
endif|#
directive|endif
condition|)
name|tcp_pulloutofband
argument_list|(
name|so
argument_list|,
name|ti
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* 		 * If no out of band data is expected, 		 * pull receive urgent pointer along 		 * with the receive window. 		 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|tp
operator|->
name|rcv_up
argument_list|)
condition|)
name|tp
operator|->
name|rcv_up
operator|=
name|tp
operator|->
name|rcv_nxt
expr_stmt|;
name|dodata
label|:
comment|/* XXX */
comment|/* 	 * Process the segment text, merging it into the TCP sequencing queue, 	 * and arranging for acknowledgment of receipt if necessary. 	 * This process logically involves adjusting tp->rcv_wnd as data 	 * is presented to the user (this happens in tcp_usrreq.c, 	 * case PRU_RCVD).  If a FIN has already been received on this 	 * connection then we just ignore the text. 	 */
if|if
condition|(
operator|(
name|ti
operator|->
name|ti_len
operator|||
operator|(
name|tiflags
operator|&
name|TH_FIN
operator|)
operator|)
operator|&&
name|TCPS_HAVERCVDFIN
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TCP_REASS
argument_list|(
name|tp
argument_list|,
name|ti
argument_list|,
name|m
argument_list|,
name|so
argument_list|,
name|tiflags
argument_list|)
expr_stmt|;
comment|/* 		 * Note the amount of data that peer has sent into 		 * our window, in order to estimate the sender's 		 * buffer size. 		 */
name|len
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|-
operator|(
name|tp
operator|->
name|rcv_adv
operator|-
name|tp
operator|->
name|rcv_nxt
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|tp
operator|->
name|max_rcvd
condition|)
name|tp
operator|->
name|max_rcvd
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|tiflags
operator|&=
operator|~
name|TH_FIN
expr_stmt|;
block|}
comment|/* 	 * If FIN is received ACK the FIN and let the user know 	 * that the connection is closing. 	 */
if|if
condition|(
name|tiflags
operator|&
name|TH_FIN
condition|)
block|{
if|if
condition|(
name|TCPS_HAVERCVDFIN
argument_list|(
name|tp
operator|->
name|t_state
argument_list|)
operator|==
literal|0
condition|)
block|{
name|socantrcvmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
name|tp
operator|->
name|rcv_nxt
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|tp
operator|->
name|t_state
condition|)
block|{
comment|/* 		 * In SYN_RECEIVED and ESTABLISHED STATES 		 * enter the CLOSE_WAIT state. 		 */
case|case
name|TCPS_SYN_RECEIVED
case|:
case|case
name|TCPS_ESTABLISHED
case|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_CLOSE_WAIT
expr_stmt|;
break|break;
comment|/* 		 * If still in FIN_WAIT_1 STATE FIN has not been acked so 		 * enter the CLOSING state. 		 */
case|case
name|TCPS_FIN_WAIT_1
case|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_CLOSING
expr_stmt|;
break|break;
comment|/* 		 * In FIN_WAIT_2 state enter the TIME_WAIT state, 		 * starting the time-wait timer, turning off the other  		 * standard timers. 		 */
case|case
name|TCPS_FIN_WAIT_2
case|:
name|tp
operator|->
name|t_state
operator|=
name|TCPS_TIME_WAIT
expr_stmt|;
name|tcp_canceltimers
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_timer
index|[
name|TCPT_2MSL
index|]
operator|=
literal|2
operator|*
name|TCPTV_MSL
expr_stmt|;
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * In TIME_WAIT state restart the 2 MSL time_wait timer. 		 */
case|case
name|TCPS_TIME_WAIT
case|:
name|tp
operator|->
name|t_timer
index|[
name|TCPT_2MSL
index|]
operator|=
literal|2
operator|*
name|TCPTV_MSL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
condition|)
name|tcp_trace
argument_list|(
name|TA_INPUT
argument_list|,
name|ostate
argument_list|,
name|tp
argument_list|,
operator|&
name|tcp_saveti
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Return any desired output. 	 */
if|if
condition|(
name|needoutput
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ACKNOW
operator|)
condition|)
operator|(
name|void
operator|)
name|tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
name|dropafterack
label|:
comment|/* 	 * Generate an ACK dropping incoming segment if it occupies 	 * sequence space, where the ACK reflects our state. 	 */
if|if
condition|(
name|tiflags
operator|&
name|TH_RST
condition|)
goto|goto
name|drop
goto|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
operator|(
name|void
operator|)
name|tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
name|dropwithreset
label|:
if|if
condition|(
name|om
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|om
argument_list|)
expr_stmt|;
name|om
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Generate a RST, dropping incoming segment. 	 * Make ACK acceptable to originator of segment. 	 * Don't bother to respond if destination was broadcast. 	 */
if|if
condition|(
operator|(
name|tiflags
operator|&
name|TH_RST
operator|)
operator|||
name|m
operator|->
name|m_flags
operator|&
name|M_BCAST
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
name|tiflags
operator|&
name|TH_ACK
condition|)
name|tcp_respond
argument_list|(
name|tp
argument_list|,
name|ti
argument_list|,
name|m
argument_list|,
operator|(
name|tcp_seq
operator|)
literal|0
argument_list|,
name|ti
operator|->
name|ti_ack
argument_list|,
name|TH_RST
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tiflags
operator|&
name|TH_SYN
condition|)
name|ti
operator|->
name|ti_len
operator|++
expr_stmt|;
name|tcp_respond
argument_list|(
name|tp
argument_list|,
name|ti
argument_list|,
name|m
argument_list|,
name|ti
operator|->
name|ti_seq
operator|+
name|ti
operator|->
name|ti_len
argument_list|,
operator|(
name|tcp_seq
operator|)
literal|0
argument_list|,
name|TH_RST
operator||
name|TH_ACK
argument_list|)
expr_stmt|;
block|}
comment|/* destroy temporarily created socket */
if|if
condition|(
name|dropsocket
condition|)
operator|(
name|void
operator|)
name|soabort
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return;
name|drop
label|:
if|if
condition|(
name|om
condition|)
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|om
argument_list|)
expr_stmt|;
comment|/* 	 * Drop space held by incoming segment and return. 	 */
if|if
condition|(
name|tp
operator|&&
operator|(
name|tp
operator|->
name|t_inpcb
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|)
condition|)
name|tcp_trace
argument_list|(
name|TA_DROP
argument_list|,
name|ostate
argument_list|,
name|tp
argument_list|,
operator|&
name|tcp_saveti
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* destroy temporarily created socket */
if|if
condition|(
name|dropsocket
condition|)
operator|(
name|void
operator|)
name|soabort
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|tcp_dooptions
argument_list|(
argument|tp
argument_list|,
argument|om
argument_list|,
argument|ti
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|om
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tcpiphdr
modifier|*
name|ti
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|optlen
decl_stmt|,
name|cnt
decl_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|om
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|om
operator|->
name|m_len
expr_stmt|;
for|for
control|(
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|-=
name|optlen
operator|,
name|cp
operator|+=
name|optlen
control|)
block|{
name|opt
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|TCPOPT_EOL
condition|)
break|break;
if|if
condition|(
name|opt
operator|==
name|TCPOPT_NOP
condition|)
name|optlen
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|optlen
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|optlen
operator|<=
literal|0
condition|)
break|break;
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
default|default:
break|break;
case|case
name|TCPOPT_MAXSEG
case|:
if|if
condition|(
name|optlen
operator|!=
literal|4
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|ti
operator|->
name|ti_flags
operator|&
name|TH_SYN
operator|)
condition|)
continue|continue;
name|tp
operator|->
name|t_maxseg
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|cp
operator|+
literal|2
operator|)
expr_stmt|;
name|tp
operator|->
name|t_maxseg
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|tp
operator|->
name|t_maxseg
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_maxseg
operator|=
name|min
argument_list|(
name|tp
operator|->
name|t_maxseg
argument_list|,
name|tcp_mss
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|om
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Pull out of band byte out of a segment so  * it doesn't appear in the user's data queue.  * It is still reflected in the segment length for  * sequencing purposes.  */
end_comment

begin_macro
name|tcp_pulloutofband
argument_list|(
argument|so
argument_list|,
argument|ti
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tcpiphdr
modifier|*
name|ti
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|cnt
init|=
name|ti
operator|->
name|ti_urp
operator|-
literal|1
decl_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|ti
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
name|cnt
condition|)
block|{
name|char
modifier|*
name|cp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|cnt
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|tp
operator|->
name|t_iobc
operator|=
operator|*
name|cp
expr_stmt|;
name|tp
operator|->
name|t_oobflags
operator||=
name|TCPOOB_HAVEDATA
expr_stmt|;
name|bcopy
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|cp
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|m
operator|->
name|m_len
operator|-
name|cnt
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|--
expr_stmt|;
return|return;
block|}
name|cnt
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
block|}
name|panic
argument_list|(
literal|"tcp_pulloutofband"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Determine a reasonable value for maxseg size.  *  If the route is known, use one that can be handled  *  on the given interface without forcing IP to fragment.  *  If bigger than an mbuf cluster (MCLBYTES), round down to nearest size  *  to utilize large mbufs.  *  If interface pointer is unavailable, or the destination isn't local,  *  use a conservative size (512 or the default IP max size, but no more  *  than the mtu of the interface through which we route),  *  as we can't discover anything about intervening gateways or networks.  *  We also initialize the congestion/slow start window to be a single  *  segment if the destination isn't local; this information should  *  probably all be saved with the routing entry at the transport level.  *  *  This is ugly, and doesn't belong at this level, but has to happen somehow.  */
end_comment

begin_expr_stmt
name|tcp_mss
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tcpcb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|mss
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
name|tp
operator|->
name|t_inpcb
expr_stmt|;
name|ro
operator|=
operator|&
name|inp
operator|->
name|inp_route
expr_stmt|;
if|if
condition|(
operator|(
name|ro
operator|->
name|ro_rt
operator|==
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
operator|)
operator|||
operator|(
name|ifp
operator|=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
operator|)
operator|==
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* No route yet, so try to acquire one */
if|if
condition|(
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
name|ro
operator|->
name|ro_dst
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
operator|)
operator|->
name|sin_addr
operator|=
name|inp
operator|->
name|inp_faddr
expr_stmt|;
name|rtalloc
argument_list|(
name|ro
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ro
operator|->
name|ro_rt
operator|==
literal|0
operator|)
operator|||
operator|(
name|ifp
operator|=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TCP_MSS
operator|)
return|;
block|}
name|mss
operator|=
name|ifp
operator|->
name|if_mtu
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|MCLBYTES
operator|&
operator|(
name|MCLBYTES
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
if|if
condition|(
name|mss
operator|>
name|MCLBYTES
condition|)
name|mss
operator|&=
operator|~
operator|(
name|MCLBYTES
operator|-
literal|1
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|mss
operator|>
name|MCLBYTES
condition|)
name|mss
operator|=
name|mss
operator|/
name|MCLBYTES
operator|*
name|MCLBYTES
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|in_localaddr
argument_list|(
name|inp
operator|->
name|inp_faddr
argument_list|)
condition|)
return|return
operator|(
name|mss
operator|)
return|;
name|mss
operator|=
name|min
argument_list|(
name|mss
argument_list|,
name|TCP_MSS
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_cwnd
operator|=
name|mss
expr_stmt|;
return|return
operator|(
name|mss
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
name|BSD
operator|<
literal|43
end_if

begin_comment
comment|/* XXX this belongs in netinet/in.c */
end_comment

begin_macro
name|in_localaddr
argument_list|(
argument|in
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|in_addr
name|in
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_long
name|i
init|=
name|ntohl
argument_list|(
name|in
operator|.
name|s_addr
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
specifier|register
name|u_long
name|mask
decl_stmt|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|i
argument_list|)
condition|)
name|mask
operator|=
name|IN_CLASSA_NET
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|i
argument_list|)
condition|)
name|mask
operator|=
name|IN_CLASSB_NET
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSC
argument_list|(
name|i
argument_list|)
condition|)
name|mask
operator|=
name|IN_CLASSC_NET
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|i
operator|&=
name|mask
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|if_next
control|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifp
operator|->
name|if_addr
expr_stmt|;
if|if
condition|(
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|&
name|mask
operator|)
operator|==
name|i
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

