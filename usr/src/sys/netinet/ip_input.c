begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ip_input.c 1.1 81/10/14 */
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/tcp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ucb.h"
end_include

begin_comment
comment|/***************************************************************************** *                                                                            * *         ip level input routine: called from 1822 level upon receipt        * *         of an internet datagram or fragment.  this routine does            * *         fragment reassembly, if necessary, and passes completed            * *         datagrams to higher level protocol processing routines on          * *         the basis of the ip header protocol field.  it is passed a         * *         pointer to an mbuf chain containing the datagram/fragment.         * *         the mbuf offset/length are set to point at the ip header.          * *                                                                            * *****************************************************************************/
end_comment

begin_decl_stmt
name|int
name|nosum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|ip_input
argument_list|(
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|struct
name|ip
modifier|*
name|p
decl_stmt|,
modifier|*
name|savq
decl_stmt|;
name|struct
name|ipq
modifier|*
name|ip_findf
parameter_list|()
function_decl|;
name|COUNT
argument_list|(
name|IP_INPUT
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|mp
operator|+
name|mp
operator|->
name|m_off
operator|)
expr_stmt|;
comment|/* ->ip hdr */
comment|/* make sure header does not overflow mbuf */
if|if
condition|(
operator|(
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|>
name|mp
operator|->
name|m_len
condition|)
block|{
name|printf
argument_list|(
literal|"ip header overflow\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
operator|(
name|unsigned
name|short
operator|)
name|ip
operator|->
name|ip_sum
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|unsigned
name|short
operator|)
name|cksum
argument_list|(
name|mp
argument_list|,
name|hlen
argument_list|)
condition|)
block|{
comment|/* verify checksum */
name|netstat
operator|.
name|ip_badsum
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|nosum
condition|)
block|{
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ip_bswap
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* byte-swap header */
name|netcb
operator|.
name|n_ip_lock
operator|++
expr_stmt|;
comment|/* lock frag reass.q */
name|fp
operator|=
name|ip_findf
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* look for chain on reass.q with this hdr */
comment|/* adjust message length to remove any padding */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|m
operator|=
name|mp
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|i
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|n
operator|=
name|m
expr_stmt|;
block|}
name|i
operator|-=
name|ip
operator|->
name|ip_len
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
if|if
condition|(
name|i
operator|>
operator|(
name|int
operator|)
name|n
operator|->
name|m_len
condition|)
name|m_adj
argument_list|(
name|mp
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
else|else
name|n
operator|->
name|m_len
operator|-=
name|i
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|-=
name|hlen
expr_stmt|;
comment|/* length of data */
name|ip
operator|->
name|ip_mff
operator|=
operator|(
operator|(
name|ip
operator|->
name|ip_off
operator|&
name|ip_mf
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|<<=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|ip_mff
operator|&&
name|ip
operator|->
name|ip_off
operator|==
literal|0
condition|)
block|{
comment|/* not fragmented */
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
comment|/* free existing reass.q chain */
name|q
operator|=
name|fp
operator|->
name|iqx
operator|.
name|ip_next
expr_stmt|;
comment|/* free mbufs assoc. w/chain */
while|while
condition|(
name|q
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
condition|)
block|{
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
block|}
name|ip_freef
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* free header */
block|}
name|netcb
operator|.
name|n_ip_lock
operator|=
literal|0
expr_stmt|;
name|ip_opt
argument_list|(
name|ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
comment|/* option processing */
name|i
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
comment|/* pass to next level */
if|if
condition|(
name|i
operator|==
name|TCPROTO
condition|)
name|tcp_input
argument_list|(
name|mp
argument_list|)
expr_stmt|;
else|else
name|raw_input
argument_list|(
name|mp
argument_list|,
name|i
argument_list|,
name|UIP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* fragmented */
comment|/* -> msg buf beyond ip hdr if not first fragment */
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|!=
literal|0
condition|)
block|{
name|mp
operator|->
name|m_off
operator|+=
name|hlen
expr_stmt|;
name|mp
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
comment|/* first fragment of datagram in */
comment|/* set up reass.q header: enq it, set up as head of frag 		   chain, set a timer value, and move in ip header */
if|if
condition|(
operator|(
name|m
operator|=
name|m_get
argument_list|(
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* allocate an mbuf */
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
name|fp
operator|=
operator|(
expr|struct
name|ipq
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|m
operator|+
name|MHEAD
operator|)
expr_stmt|;
name|fp
operator|->
name|iqx
operator|.
name|ip_next
operator|=
name|fp
operator|->
name|iqx
operator|.
name|ip_prev
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
expr_stmt|;
name|bcopy
argument_list|(
name|ip
argument_list|,
operator|&
name|fp
operator|->
name|iqh
argument_list|,
name|min
argument_list|(
name|MLEN
operator|-
literal|28
argument_list|,
name|hlen
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|iqh
operator|.
name|ip_ttl
operator|=
name|MAXTTL
expr_stmt|;
name|fp
operator|->
name|iq_next
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|iq_prev
operator|=
name|netcb
operator|.
name|n_ip_tail
expr_stmt|;
if|if
condition|(
name|netcb
operator|.
name|n_ip_head
operator|!=
name|NULL
condition|)
name|netcb
operator|.
name|n_ip_tail
operator|->
name|iq_next
operator|=
name|fp
expr_stmt|;
else|else
name|netcb
operator|.
name|n_ip_head
operator|=
name|fp
expr_stmt|;
name|netcb
operator|.
name|n_ip_tail
operator|=
name|fp
expr_stmt|;
block|}
comment|/***********************************************************                 *                                                          *                 *              merge fragment into reass.q                 *                 *    algorithm:   match  start  and  end  bytes  of new    *                 *    fragment  with  fragments  on  the  queue.   if   no  *                 *    overlaps  are  found,  add  new  frag. to the queue.  *                 *    otherwise, adjust start and end of new frag.  so  no  *                 *    overlap   and   add  remainder  to  queue.   if  any  *                 *    fragments are completely covered by the new one,  or  *                 *    if  the  new  one is completely duplicated, free the  *                 *    fragments.                                            *                 *                                                          *                 ***********************************************************/
name|q
operator|=
name|fp
operator|->
name|iqx
operator|.
name|ip_next
expr_stmt|;
comment|/* -> top of reass. chain */
name|ip
operator|->
name|ip_end
operator|=
name|ip
operator|->
name|ip_off
operator|+
name|ip
operator|->
name|ip_len
operator|-
literal|1
expr_stmt|;
comment|/* skip frags which new doesn't overlap at end */
while|while
condition|(
operator|(
name|q
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
operator|)
operator|&&
operator|(
name|ip
operator|->
name|ip_off
operator|>
name|q
operator|->
name|ip_end
operator|)
condition|)
name|q
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
if|if
condition|(
name|q
operator|==
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
condition|)
comment|/* frag at end of chain */
name|ip_enq
argument_list|(
name|ip
argument_list|,
name|fp
operator|->
name|iqx
operator|.
name|ip_prev
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ip
operator|->
name|ip_end
operator|<
name|q
operator|->
name|ip_off
condition|)
comment|/* frag doesn't overlap any on chain */
name|ip_enq
argument_list|(
name|ip
argument_list|,
name|q
operator|->
name|ip_prev
argument_list|)
expr_stmt|;
comment|/* new overlaps beginning of next frag only */
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_end
operator|<
name|q
operator|->
name|ip_end
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|ip
operator|->
name|ip_end
operator|-
name|q
operator|->
name|ip_off
operator|+
literal|1
operator|)
operator|<
name|ip
operator|->
name|ip_len
condition|)
block|{
name|ip
operator|->
name|ip_len
operator|-=
name|i
expr_stmt|;
name|ip
operator|->
name|ip_end
operator|-=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|mp
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
name|ip_enq
argument_list|(
name|ip
argument_list|,
name|q
operator|->
name|ip_prev
argument_list|)
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* new overlaps end of previous frag */
block|}
else|else
block|{
name|savq
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|<=
name|q
operator|->
name|ip_off
condition|)
block|{
comment|/* complete cover */
name|savq
operator|=
name|q
operator|->
name|ip_prev
expr_stmt|;
name|ip_deq
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* overlap */
if|if
condition|(
operator|(
name|i
operator|=
name|q
operator|->
name|ip_end
operator|-
name|ip
operator|->
name|ip_off
operator|+
literal|1
operator|)
operator|<
name|ip
operator|->
name|ip_len
condition|)
block|{
name|ip
operator|->
name|ip_off
operator|+=
name|i
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|-=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|mp
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|ip
operator|->
name|ip_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* new overlaps at beginning of successor frags */
name|q
operator|=
name|savq
operator|->
name|ip_next
expr_stmt|;
while|while
condition|(
operator|(
name|q
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
operator|)
operator|&&
operator|(
name|ip
operator|->
name|ip_len
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|q
operator|->
name|ip_off
operator|<
name|ip
operator|->
name|ip_end
operator|)
condition|)
comment|/* complete cover */
if|if
condition|(
name|q
operator|->
name|ip_end
operator|<=
name|ip
operator|->
name|ip_end
condition|)
block|{
name|p
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
name|ip_deq
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
comment|/* overlap */
if|if
condition|(
operator|(
name|i
operator|=
name|ip
operator|->
name|ip_end
operator|-
name|q
operator|->
name|ip_off
operator|+
literal|1
operator|)
operator|<
name|ip
operator|->
name|ip_len
condition|)
block|{
name|ip
operator|->
name|ip_len
operator|-=
name|i
expr_stmt|;
name|ip
operator|->
name|ip_end
operator|-=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|mp
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|ip
operator|->
name|ip_len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* enqueue whatever is left of new before successors */
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|!=
literal|0
condition|)
name|ip_enq
argument_list|(
name|ip
argument_list|,
name|savq
argument_list|)
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check for completed fragment reassembly */
if|if
condition|(
operator|(
name|i
operator|=
name|ip_done
argument_list|(
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|fp
operator|->
name|iqx
operator|.
name|ip_next
expr_stmt|;
comment|/* -> top mbuf */
name|m
operator|=
name|dtom
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|ip_len
operator|=
name|i
expr_stmt|;
comment|/* total data length */
name|ip_opt
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
comment|/* option processing */
name|ip_mergef
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* cleanup frag chain */
comment|/* copy src/dst internet address to header mbuf */
name|bcopy
argument_list|(
operator|&
name|fp
operator|->
name|iqh
operator|.
name|ip_src
argument_list|,
operator|&
name|p
operator|->
name|ip_src
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|socket
argument_list|)
argument_list|)
expr_stmt|;
name|ip_freef
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* dequeue header */
name|netcb
operator|.
name|n_ip_lock
operator|=
literal|0
expr_stmt|;
comment|/* call next level with completed datagram */
name|i
operator|=
name|p
operator|->
name|ip_p
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|TCPROTO
condition|)
name|tcp_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|raw_input
argument_list|(
name|m
argument_list|,
name|i
argument_list|,
name|UIP
argument_list|)
expr_stmt|;
block|}
else|else
name|netcb
operator|.
name|n_ip_lock
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|ip_done
argument_list|(
name|p
argument_list|)
comment|/* check to see if fragment reassembly is complete */
specifier|register
expr|struct
name|ip
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|q
decl_stmt|;
specifier|register
name|next
expr_stmt|;
name|COUNT
argument_list|(
name|IP_DONE
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|ip_next
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|ip_off
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
do|do
block|{
name|next
operator|=
name|q
operator|->
name|ip_end
operator|+
literal|1
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|q
operator|!=
name|p
operator|)
operator|&&
operator|(
name|q
operator|->
name|ip_off
operator|==
name|next
operator|)
condition|)
do|;
if|if
condition|(
operator|(
name|q
operator|==
name|p
operator|)
operator|&&
operator|!
operator|(
name|q
operator|->
name|ip_prev
operator|->
name|ip_mff
operator|)
condition|)
comment|/* all fragments in */
return|return
operator|(
name|next
operator|)
return|;
comment|/* total data length */
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|ip_mergef
argument_list|(
name|p
argument_list|)
comment|/* merge mbufs of fragments of completed datagram */
specifier|register
expr|struct
name|ip
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|q
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|COUNT
argument_list|(
name|IP_MERGEF
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|ip_next
expr_stmt|;
comment|/* -> bottom of reass chain */
name|n
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
operator|&
name|dummy
expr_stmt|;
comment|/* dummy for init assignment */
while|while
condition|(
name|q
operator|!=
name|p
condition|)
block|{
comment|/* through chain */
name|n
operator|->
name|m_next
operator|=
name|m
operator|=
name|dtom
argument_list|(
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
literal|0
condition|)
block|{
name|n
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
else|else
comment|/* free null mbufs */
name|n
operator|->
name|m_next
operator|=
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|ip_freef
argument_list|(
name|fp
argument_list|)
comment|/* deq and free reass.q header */
specifier|register
expr|struct
name|ipq
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|COUNT
argument_list|(
name|IP_FREEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|iq_prev
operator|!=
name|NULL
condition|)
operator|(
name|fp
operator|->
name|iq_prev
operator|)
operator|->
name|iq_next
operator|=
name|fp
operator|->
name|iq_next
expr_stmt|;
else|else
name|netcb
operator|.
name|n_ip_head
operator|=
name|fp
operator|->
name|iq_next
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|iq_next
operator|!=
name|NULL
condition|)
operator|(
name|fp
operator|->
name|iq_next
operator|)
operator|->
name|iq_prev
operator|=
name|fp
operator|->
name|iq_prev
expr_stmt|;
else|else
name|netcb
operator|.
name|n_ip_tail
operator|=
name|fp
operator|->
name|iq_prev
expr_stmt|;
name|m_free
argument_list|(
name|dtom
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|ipq
modifier|*
name|ip_findf
parameter_list|(
name|p
parameter_list|)
comment|/* does fragment reass chain w/this hdr exist? */
specifier|register
name|struct
name|ip
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
name|COUNT
argument_list|(
name|IP_FINDF
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|netcb
operator|.
name|n_ip_head
init|;
operator|(
name|fp
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|fp
operator|->
name|iqh
operator|.
name|ip_src
operator|.
name|s_addr
operator|||
name|p
operator|->
name|ip_dst
operator|.
name|s_addr
operator|!=
name|fp
operator|->
name|iqh
operator|.
name|ip_dst
operator|.
name|s_addr
operator|||
name|p
operator|->
name|ip_id
operator|!=
name|fp
operator|->
name|iqh
operator|.
name|ip_id
operator|||
name|p
operator|->
name|ip_p
operator|!=
name|fp
operator|->
name|iqh
operator|.
name|ip_p
operator|)
operator|)
condition|;
name|fp
operator|=
name|fp
operator|->
name|iq_next
control|)
empty_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_macro
name|ip_opt
argument_list|(
argument|ip
argument_list|,
argument|hlen
argument_list|)
end_macro

begin_comment
comment|/* process ip options */
end_comment

begin_decl_stmt
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hlen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|i
operator|,
name|len
expr_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|COUNT
argument_list|(
name|IP_OPT
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|ip
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
expr_stmt|;
comment|/* -> at options */
if|if
condition|(
operator|(
name|i
operator|=
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* any options */
comment|/*      *** IP OPTION PROCESSING ***  		while (i> 0)    			switch (*q++) { 			case 0:                  			case 1:                  				i--; 				break;  			default: 				i -= *q; 				q += *q; 			} */
name|q
operator|+=
name|i
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|int
operator|)
name|m
operator|+
name|m
operator|->
name|m_off
operator|+
name|m
operator|->
name|m_len
operator|-
operator|(
name|int
operator|)
name|q
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|q
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* remove options */
name|m
operator|->
name|m_len
operator|-=
name|i
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|ip_enq
argument_list|(
name|p
argument_list|,
name|prev
argument_list|)
specifier|register
expr|struct
name|ip
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|ip
modifier|*
name|prev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|COUNT
argument_list|(
name|IP_ENQ
argument_list|)
expr_stmt|;
name|p
operator|->
name|ip_prev
operator|=
name|prev
expr_stmt|;
name|p
operator|->
name|ip_next
operator|=
name|prev
operator|->
name|ip_next
expr_stmt|;
name|prev
operator|->
name|ip_next
operator|->
name|ip_prev
operator|=
name|p
expr_stmt|;
name|prev
operator|->
name|ip_next
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ip_deq
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|ip
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|COUNT
argument_list|(
name|IP_DEQ
argument_list|)
expr_stmt|;
name|p
operator|->
name|ip_prev
operator|->
name|ip_next
operator|=
name|p
operator|->
name|ip_next
expr_stmt|;
name|p
operator|->
name|ip_next
operator|->
name|ip_prev
operator|=
name|p
operator|->
name|ip_prev
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ip_bswap
argument_list|(
name|p
argument_list|)
comment|/* byte swap ip header */
specifier|register
expr|struct
name|ip
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|COUNT
argument_list|(
name|IP_BSWAP
argument_list|)
expr_stmt|;
name|p
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
name|p
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|p
operator|->
name|ip_id
operator|=
name|ntohs
argument_list|(
name|p
operator|->
name|ip_id
argument_list|)
expr_stmt|;
name|p
operator|->
name|ip_off
operator|=
name|ntohs
argument_list|(
name|p
operator|->
name|ip_off
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ip_timeo
argument_list|()
end_macro

begin_comment
comment|/* frag reass.q timeout routine */
end_comment

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
name|COUNT
argument_list|(
name|IP_TIMEO
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ip_timeo
argument_list|,
literal|0
argument_list|,
literal|60
argument_list|)
expr_stmt|;
comment|/* reschedule every second */
if|if
condition|(
name|netcb
operator|.
name|n_ip_lock
condition|)
comment|/* reass.q must not be in use */
return|return;
comment|/* search through reass.q */
for|for
control|(
name|fp
operator|=
name|netcb
operator|.
name|n_ip_head
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|iq_next
control|)
if|if
condition|(
operator|--
operator|(
name|fp
operator|->
name|iqx
operator|.
name|ip_ttl
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* time to die */
name|q
operator|=
name|fp
operator|->
name|iqx
operator|.
name|ip_next
expr_stmt|;
comment|/* free mbufs assoc. w/chain */
while|while
condition|(
name|q
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
condition|)
block|{
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
block|}
name|ip_freef
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* free header */
block|}
block|}
end_block

end_unit

