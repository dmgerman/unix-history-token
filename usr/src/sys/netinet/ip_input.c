begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ip_input.c 1.10 81/10/31 */
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/clock.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../inet/cksum.h"
end_include

begin_include
include|#
directive|include
file|"../inet/inet.h"
end_include

begin_include
include|#
directive|include
file|"../inet/inet_systm.h"
end_include

begin_include
include|#
directive|include
file|"../inet/imp.h"
end_include

begin_include
include|#
directive|include
file|"../inet/ip.h"
end_include

begin_comment
comment|/* belongs before inet.h */
end_comment

begin_include
include|#
directive|include
file|"../inet/ip_icmp.h"
end_include

begin_include
include|#
directive|include
file|"../inet/tcp.h"
end_include

begin_decl_stmt
name|int
name|nosum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|ip
modifier|*
name|ip_reass
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Ip input routines.  */
end_comment

begin_comment
comment|/*  * Ip input routine.  Checksum and byte swap header.  If fragmented  * try to reassamble.  If complete and fragment queue exists, discard.  * Process options.  Pass to next level.  */
end_comment

begin_macro
name|ip_input
argument_list|(
argument|m0
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
comment|/* known to be r11 in CKSUM below */
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|ipq
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|COUNT
argument_list|(
name|IP_INPUT
argument_list|)
expr_stmt|;
comment|/* 	 * Check header and byteswap. 	 */
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|>
name|m
operator|->
name|m_len
condition|)
block|{
name|printf
argument_list|(
literal|"ip hdr ovflo\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|CKSUM_IPCHK
argument_list|(
name|m
argument_list|,
name|ip
argument_list|,
name|r11
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_sum
condition|)
block|{
name|printf
argument_list|(
literal|"ip_sum %x\n"
argument_list|,
name|ip
operator|->
name|ip_sum
argument_list|)
expr_stmt|;
name|netstat
operator|.
name|ip_badsum
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|nosum
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ip
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_id
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the amount of data in the buffers 	 * is as at least much as the IP header would have us expect. 	 * Trim mbufs if longer than we expect. 	 * Drop packet if shorter than we expect. 	 */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|i
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ip
operator|->
name|ip_len
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|ip
operator|->
name|ip_len
condition|)
block|{
name|printf
argument_list|(
literal|"ip_input: short packet\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
name|ip
operator|->
name|ip_len
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Process options and, if not destined for us, 	 * ship it on. 	 */
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
name|ip_dooptions
argument_list|(
name|ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|!=
name|n_lhost
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
operator|--
name|ip
operator|->
name|ip_ttl
operator|==
literal|0
condition|)
block|{
name|icmp_error
argument_list|(
name|ip
argument_list|,
name|ICMP_TIMXCEED
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip_output
argument_list|(
name|dtom
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Look for queue of fragments 	 * of this datagram. 	 */
for|for
control|(
name|fp
operator|=
name|ipq
operator|.
name|next
init|;
name|fp
operator|!=
operator|&
name|ipq
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
if|if
condition|(
name|ip
operator|->
name|ip_id
operator|==
name|fp
operator|->
name|ipq_id
operator|&&
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|fp
operator|->
name|ipq_src
operator|.
name|s_addr
operator|&&
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|fp
operator|->
name|ipq_dst
operator|.
name|s_addr
operator|&&
name|ip
operator|->
name|ip_p
operator|==
name|fp
operator|->
name|ipq_p
condition|)
goto|goto
name|found
goto|;
name|fp
operator|=
literal|0
expr_stmt|;
name|found
label|:
comment|/* 	 * Adjust ip_len to not reflect header, 	 * set ip_mff if more fragments are expected, 	 * convert offset of this to bytes. 	 */
name|ip
operator|->
name|ip_len
operator|-=
name|hlen
expr_stmt|;
name|ip
operator|->
name|ip_mff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
name|IP_MF
condition|)
name|ip
operator|->
name|ip_mff
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|<<=
literal|3
expr_stmt|;
comment|/* 	 * If datagram marked as having more fragments 	 * or if this is not the first fragment, 	 * attempt reassembly; if it succeeds, proceed. 	 */
if|if
condition|(
name|ip
operator|->
name|ip_mff
operator|||
name|ip
operator|->
name|ip_off
condition|)
block|{
name|ip
operator|=
name|ip_reass
argument_list|(
name|ip
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
literal|0
condition|)
return|return;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
condition|)
operator|(
name|void
operator|)
name|ip_freef
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* 	 * Switch out to protocol specific routine. 	 * SHOULD GO THROUGH PROTOCOL SWITCH TABLE 	 */
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_ICMP
case|:
name|icmp_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
name|ip_stripoptions
argument_list|(
name|ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|tcp_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
name|ip_stripoptions
argument_list|(
name|ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|udp_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
default|default:
name|raw_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * Take incoming datagram fragment and try to  * reassamble it into whole datagram.  If a chain for  * reassembly of this datagram already exists, then it  * is given as fp; otherwise have to make a chain.  */
end_comment

begin_function
name|struct
name|ip
modifier|*
name|ip_reass
parameter_list|(
name|ip
parameter_list|,
name|fp
parameter_list|)
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|dtom
argument_list|(
name|ip
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|q
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|t
decl_stmt|;
name|int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|next
decl_stmt|;
comment|/* 	 * Presence of header sizes in mbufs 	 * would confuse code below. 	 */
name|m
operator|->
name|m_off
operator|+=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
comment|/* 	 * If first fragment to arrive, create a reassembly queue. 	 */
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|m_get
argument_list|(
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|dropfrag
goto|;
name|t
operator|->
name|m_off
operator|=
name|MMINOFF
expr_stmt|;
name|fp
operator|=
name|mtod
argument_list|(
name|t
argument_list|,
expr|struct
name|ipq
operator|*
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|fp
argument_list|,
operator|&
name|ipq
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ipq_ttl
operator|=
name|IPFRAGTTL
expr_stmt|;
name|fp
operator|->
name|ipq_p
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|fp
operator|->
name|ipq_id
operator|=
name|ip
operator|->
name|ip_id
expr_stmt|;
name|fp
operator|->
name|ipq_next
operator|=
name|fp
operator|->
name|ipq_prev
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
expr_stmt|;
name|fp
operator|->
name|ipq_src
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|fp
operator|->
name|ipq_dst
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
block|}
comment|/* 	 * Find a segment which begins after this one does. 	 */
for|for
control|(
name|q
operator|=
name|fp
operator|->
name|ipq_next
init|;
name|q
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
condition|;
name|q
operator|=
name|q
operator|->
name|ip_next
control|)
if|if
condition|(
name|q
operator|->
name|ip_off
operator|>
name|ip
operator|->
name|ip_off
condition|)
break|break;
comment|/* 	 * If there is a preceding segment, it may provide some of 	 * our data already.  If so, drop the data from the incoming 	 * segment.  If it provides all of our data, drop us. 	 */
if|if
condition|(
name|q
operator|->
name|ip_prev
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
condition|)
block|{
name|i
operator|=
name|q
operator|->
name|ip_prev
operator|->
name|ip_off
operator|+
name|q
operator|->
name|ip_prev
operator|->
name|ip_len
operator|-
name|ip
operator|->
name|ip_off
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|ip
operator|->
name|ip_len
condition|)
goto|goto
name|dropfrag
goto|;
name|m_adj
argument_list|(
name|dtom
argument_list|(
name|ip
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|+=
name|i
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|-=
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * While we overlap succeeding segments trim them or, 	 * if they are completely covered, dequeue them. 	 */
while|while
condition|(
name|q
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
operator|&&
name|ip
operator|->
name|ip_off
operator|+
name|ip
operator|->
name|ip_len
operator|>
name|q
operator|->
name|ip_off
condition|)
block|{
name|i
operator|=
operator|(
name|ip
operator|->
name|ip_off
operator|+
name|ip
operator|->
name|ip_len
operator|)
operator|-
name|q
operator|->
name|ip_off
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|q
operator|->
name|ip_len
condition|)
block|{
name|q
operator|->
name|ip_len
operator|-=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|q
operator|=
name|q
operator|->
name|ip_next
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
operator|->
name|ip_prev
argument_list|)
argument_list|)
expr_stmt|;
name|ip_deq
argument_list|(
name|q
operator|->
name|ip_prev
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Stick new segment in its place; 	 * check for complete reassembly. 	 */
name|ip_enq
argument_list|(
name|ip
argument_list|,
name|q
operator|->
name|ip_prev
argument_list|)
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|fp
operator|->
name|ipq_next
init|;
name|q
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
condition|;
name|q
operator|=
name|q
operator|->
name|ip_next
control|)
block|{
if|if
condition|(
name|q
operator|->
name|ip_off
operator|!=
name|next
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|next
operator|+=
name|q
operator|->
name|ip_len
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|ip_prev
operator|->
name|ip_mff
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Reassembly is complete; concatenate fragments. 	 */
name|q
operator|=
name|fp
operator|->
name|ipq_next
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|t
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|m_cat
argument_list|(
name|m
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|q
operator|=
name|q
operator|->
name|ip_next
operator|)
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
condition|)
name|m_cat
argument_list|(
name|m
argument_list|,
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create header for new ip packet by 	 * modifying header of first packet; 	 * dequeue and discard fragment reassembly header. 	 * Make header visible. 	 */
name|ip
operator|=
name|fp
operator|->
name|ipq_next
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|next
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|=
name|fp
operator|->
name|ipq_src
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|fp
operator|->
name|ipq_dst
expr_stmt|;
name|remque
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|dtom
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
name|dropfrag
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a fragment reassembly header and all  * associated datagrams.  */
end_comment

begin_function
name|struct
name|ipq
modifier|*
name|ip_freef
parameter_list|(
name|fp
parameter_list|)
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|struct
name|ip
modifier|*
name|q
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|q
operator|=
name|fp
operator|->
name|ipq_next
init|;
name|q
operator|!=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|fp
condition|;
name|q
operator|=
name|q
operator|->
name|ip_next
control|)
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fp
operator|->
name|next
expr_stmt|;
name|remque
argument_list|(
name|fp
operator|->
name|prev
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put an ip fragment on a reassembly chain.  * Like insque, but pointers in middle of structure.  */
end_comment

begin_expr_stmt
name|ip_enq
argument_list|(
name|p
argument_list|,
name|prev
argument_list|)
specifier|register
expr|struct
name|ip
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|ip
modifier|*
name|prev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|COUNT
argument_list|(
name|IP_ENQ
argument_list|)
expr_stmt|;
name|p
operator|->
name|ip_prev
operator|=
name|prev
expr_stmt|;
name|p
operator|->
name|ip_next
operator|=
name|prev
operator|->
name|ip_next
expr_stmt|;
name|prev
operator|->
name|ip_next
operator|->
name|ip_prev
operator|=
name|p
expr_stmt|;
name|prev
operator|->
name|ip_next
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * To ip_enq as remque is to insque.  */
end_comment

begin_expr_stmt
name|ip_deq
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|ip
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|COUNT
argument_list|(
name|IP_DEQ
argument_list|)
expr_stmt|;
name|p
operator|->
name|ip_prev
operator|->
name|ip_next
operator|=
name|p
operator|->
name|ip_next
expr_stmt|;
name|p
operator|->
name|ip_next
operator|->
name|ip_prev
operator|=
name|p
operator|->
name|ip_prev
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * IP timer processing;  * if a timer expires on a reassembly  * queue, discard it.  */
end_comment

begin_macro
name|ip_timeo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|ip
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|COUNT
argument_list|(
name|IP_TIMEO
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|ipq
operator|.
name|next
init|;
name|fp
operator|!=
operator|&
name|ipq
condition|;
control|)
if|if
condition|(
operator|--
name|fp
operator|->
name|ipq_ttl
operator|==
literal|0
condition|)
name|fp
operator|=
name|ip_freef
argument_list|(
name|fp
argument_list|)
expr_stmt|;
else|else
name|fp
operator|=
name|fp
operator|->
name|next
expr_stmt|;
name|timeout
argument_list|(
name|ip_timeo
argument_list|,
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do option processing on a datagram,  * possibly discarding it if bad options  * are encountered.  */
end_comment

begin_macro
name|ip_dooptions
argument_list|(
argument|ip
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|optlen
decl_stmt|,
name|cnt
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|socket
modifier|*
name|sp
decl_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
name|cnt
operator|=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|-=
name|optlen
operator|,
name|cp
operator|+=
name|optlen
control|)
block|{
name|opt
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|IPOPT_EOL
condition|)
break|break;
if|if
condition|(
name|opt
operator|==
name|IPOPT_NOP
condition|)
name|optlen
operator|=
literal|1
expr_stmt|;
else|else
name|optlen
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
default|default:
break|break;
case|case
name|IPOPT_LSRR
case|:
case|case
name|IPOPT_SSRR
case|:
if|if
condition|(
name|cp
index|[
literal|2
index|]
operator|<
literal|4
operator|||
name|cp
index|[
literal|2
index|]
operator|>
name|optlen
operator|-
literal|3
condition|)
break|break;
name|sp
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
operator|(
name|cp
operator|+
name|cp
index|[
literal|2
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|n_lhost
operator|.
name|s_addr
operator|==
operator|*
operator|(
name|u_long
operator|*
operator|)
name|sp
condition|)
block|{
if|if
condition|(
name|opt
operator|==
name|IPOPT_SSRR
condition|)
block|{
comment|/* make sure *sp directly accessible*/
block|}
name|ip
operator|->
name|ip_dst
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
name|n_lhost
expr_stmt|;
name|cp
index|[
literal|2
index|]
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|IPOPT_TS
case|:
if|if
condition|(
name|cp
index|[
literal|2
index|]
operator|<
literal|5
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|cp
index|[
literal|2
index|]
operator|>
name|cp
index|[
literal|1
index|]
operator|-
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|cp
index|[
literal|3
index|]
operator|&
literal|0xf0
operator|)
operator|==
literal|0xf0
condition|)
goto|goto
name|bad
goto|;
name|cp
index|[
literal|3
index|]
operator|+=
literal|0x10
expr_stmt|;
break|break;
block|}
name|sp
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
operator|(
name|cp
operator|+
name|cp
index|[
literal|2
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|cp
index|[
literal|3
index|]
operator|&
literal|0xf
condition|)
block|{
case|case
name|IPOPT_TS_TSONLY
case|:
break|break;
case|case
name|IPOPT_TS_TSANDADDR
case|:
if|if
condition|(
name|cp
index|[
literal|2
index|]
operator|>
name|cp
index|[
literal|1
index|]
operator|-
literal|7
condition|)
goto|goto
name|bad
goto|;
break|break;
case|case
name|IPOPT_TS_PRESPEC
case|:
if|if
condition|(
operator|*
operator|(
name|u_long
operator|*
operator|)
name|sp
operator|!=
name|n_lhost
operator|.
name|s_addr
condition|)
break|break;
if|if
condition|(
name|cp
index|[
literal|2
index|]
operator|>
name|cp
index|[
literal|1
index|]
operator|-
literal|7
condition|)
goto|goto
name|bad
goto|;
name|cp
index|[
literal|1
index|]
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
block|}
name|s
operator|=
name|spl6
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|sp
operator|=
operator|(
name|time
operator|%
name|SECDAY
operator|)
operator|*
literal|1000
operator|+
operator|(
name|lbolt
operator|*
literal|1000
operator|/
name|hz
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|+=
literal|4
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
comment|/* SHOULD FORCE ICMP MESSAGE */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Strip out IP options, e.g. before passing  * to higher level protocol in the kernel.  */
end_comment

begin_macro
name|ip_stripoptions
argument_list|(
argument|ip
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|;
name|int
name|olen
decl_stmt|;
name|COUNT
argument_list|(
name|IP_OPT
argument_list|)
expr_stmt|;
name|olen
operator|=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|op
operator|=
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|olen
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
operator|++
name|ip
argument_list|)
expr_stmt|;
name|i
operator|=
name|m
operator|->
name|m_len
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|olen
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|olen
argument_list|,
operator|(
name|caddr_t
operator|)
name|ip
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|i
expr_stmt|;
block|}
end_block

begin_comment
comment|/* stubs */
end_comment

begin_macro
name|icmp_error
argument_list|(
argument|ip
argument_list|,
argument|error
argument_list|)
end_macro

begin_block
block|{
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|icmp_input
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"icmp_input %x\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|udp_input
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"udp_input %x\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|raw_input
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"raw_input %x\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

