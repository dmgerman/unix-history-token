begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	if_ether.c	6.6	84/08/29	*/
end_comment

begin_comment
comment|/*  * Ethernet address resolution protocol.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"in.h"
end_include

begin_include
include|#
directive|include
file|"in_systm.h"
end_include

begin_include
include|#
directive|include
file|"ip.h"
end_include

begin_include
include|#
directive|include
file|"if_ether.h"
end_include

begin_define
define|#
directive|define
name|ARPTAB_BSIZ
value|5
end_define

begin_comment
comment|/* bucket size */
end_comment

begin_define
define|#
directive|define
name|ARPTAB_NB
value|19
end_define

begin_comment
comment|/* number of buckets */
end_comment

begin_define
define|#
directive|define
name|ARPTAB_SIZE
value|(ARPTAB_BSIZ * ARPTAB_NB)
end_define

begin_decl_stmt
name|struct
name|arptab
name|arptab
index|[
name|ARPTAB_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arptab_size
init|=
name|ARPTAB_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for arp command */
end_comment

begin_define
define|#
directive|define
name|ARPTAB_HASH
parameter_list|(
name|a
parameter_list|)
define|\
value|((short)((((a)>> 16) ^ (a))& 0x7fff) % ARPTAB_NB)
end_define

begin_define
define|#
directive|define
name|ARPTAB_LOOK
parameter_list|(
name|at
parameter_list|,
name|addr
parameter_list|)
value|{ \ 	register n; \ 	at =&arptab[ARPTAB_HASH(addr) * ARPTAB_BSIZ]; \ 	for (n = 0 ; n< ARPTAB_BSIZ ; n++,at++) \ 		if (at->at_iaddr.s_addr == addr) \ 			break; \ 	if (n>= ARPTAB_BSIZ) \ 		at = 0; }
end_define

begin_decl_stmt
name|int
name|arpt_age
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* aging timer */
end_comment

begin_comment
comment|/* timer values */
end_comment

begin_define
define|#
directive|define
name|ARPT_AGE
value|(60*1)
end_define

begin_comment
comment|/* aging timer, 1 min. */
end_comment

begin_define
define|#
directive|define
name|ARPT_KILLC
value|20
end_define

begin_comment
comment|/* kill completed entry in 20 mins. */
end_comment

begin_define
define|#
directive|define
name|ARPT_KILLI
value|3
end_define

begin_comment
comment|/* kill incomplete entry in 3 minutes */
end_comment

begin_decl_stmt
name|struct
name|ether_addr
name|etherbroadcastaddr
init|=
block|{
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ifnet
name|loif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local addresses in the range oldmap to infinity are  * mapped according to the old mapping scheme.  That is,  * mapping of Internet to Ethernet addresses is performed  * by taking the high three bytes of the network interface's  * address and the low three bytes of the local address part.  * This only allows boards from the same manufacturer to  * communicate unless the on-board address is overridden  * (not possible in many manufacture's hardware).  *  * NB: setting oldmap to zero completely disables ARP  *     (i.e. identical to setting IFF_NOARP with an ioctl).  */
end_comment

begin_decl_stmt
name|int
name|oldmap
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Timeout routine.  Age arp_tab entries once a minute.  */
end_comment

begin_macro
name|arptimer
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|arptab
modifier|*
name|at
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|timeout
argument_list|(
name|arptimer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|arpt_age
operator|>
name|ARPT_AGE
condition|)
block|{
name|arpt_age
operator|=
literal|0
expr_stmt|;
name|at
operator|=
operator|&
name|arptab
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARPTAB_SIZE
condition|;
name|i
operator|++
operator|,
name|at
operator|++
control|)
block|{
if|if
condition|(
name|at
operator|->
name|at_flags
operator|==
literal|0
operator|||
operator|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_PERM
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|++
name|at
operator|->
name|at_timer
operator|<
operator|(
operator|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_COM
operator|)
condition|?
name|ARPT_KILLC
else|:
name|ARPT_KILLI
operator|)
condition|)
continue|continue;
comment|/* timer has expired, clear entry */
name|arptfree
argument_list|(
name|at
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Broadcast an ARP packet, asking who has addr on interface ac.  */
end_comment

begin_expr_stmt
name|arpwhohas
argument_list|(
name|ac
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|arpcom
operator|*
name|ac
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|in_addr
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
specifier|register
name|struct
name|ether_arp
modifier|*
name|ea
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
expr|*
name|ea
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
name|ea
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_arp
operator|*
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|sa
operator|.
name|sa_data
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ea
argument_list|)
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_dhost
operator|=
name|etherbroadcastaddr
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|ETHERPUP_ARPTYPE
expr_stmt|;
comment|/* if_output will swap */
name|ea
operator|->
name|arp_hrd
operator|=
name|htons
argument_list|(
name|ARPHRD_ETHER
argument_list|)
expr_stmt|;
name|ea
operator|->
name|arp_pro
operator|=
name|htons
argument_list|(
name|ETHERPUP_IPTYPE
argument_list|)
expr_stmt|;
name|ea
operator|->
name|arp_hln
operator|=
sizeof|sizeof
name|arp_sha
operator|(
name|ea
operator|)
expr_stmt|;
comment|/* hardware address length */
name|ea
operator|->
name|arp_pln
operator|=
sizeof|sizeof
name|arp_spa
operator|(
name|ea
operator|)
expr_stmt|;
comment|/* protocol address length */
name|ea
operator|->
name|arp_op
operator|=
name|htons
argument_list|(
name|ARPOP_REQUEST
argument_list|)
expr_stmt|;
name|arp_sha
argument_list|(
name|ea
argument_list|)
operator|=
name|ac
operator|->
name|ac_enaddr
expr_stmt|;
name|arp_spa
argument_list|(
name|ea
argument_list|)
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ac
operator|->
name|ac_if
operator|.
name|if_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|arp_tpa
argument_list|(
name|ea
argument_list|)
operator|=
operator|*
name|addr
expr_stmt|;
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
return|return
operator|(
call|(
modifier|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
call|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|m
argument_list|,
operator|&
name|sa
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Resolve an IP address into an ethernet address.  If success,   * desten is filled in and 1 is returned.  If there is no entry  * in arptab, set one up and broadcast a request   * for the IP address;  return 0.  Hold onto this mbuf and   * resend it once the address is finally resolved.  *  * We do some (conservative) locking here at splimp, since  * arptab is also altered from input interrupt service (ecintr/ilintr  * calls arpinput when ETHERPUP_ARPTYPE packets come in).  */
end_comment

begin_expr_stmt
name|arpresolve
argument_list|(
name|ac
argument_list|,
name|m
argument_list|,
name|destip
argument_list|,
name|desten
argument_list|)
specifier|register
expr|struct
name|arpcom
operator|*
name|ac
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|in_addr
modifier|*
name|destip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ether_addr
modifier|*
name|desten
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|arptab
modifier|*
name|at
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|s
decl_stmt|,
name|lna
decl_stmt|;
name|lna
operator|=
name|in_lnaof
argument_list|(
operator|*
name|destip
argument_list|)
expr_stmt|;
if|if
condition|(
name|lna
operator|==
name|INADDR_ANY
condition|)
block|{
comment|/* broadcast address */
operator|*
name|desten
operator|=
name|etherbroadcastaddr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ifp
operator|=
operator|&
name|ac
operator|->
name|ac_if
expr_stmt|;
comment|/* if for us, then use software loopback driver */
if|if
condition|(
name|destip
operator|->
name|s_addr
operator|==
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifp
operator|->
name|if_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|&&
operator|(
name|loif
operator|.
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
operator|*
name|destip
expr_stmt|;
operator|(
name|void
operator|)
name|looutput
argument_list|(
operator|&
name|loif
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|)
expr_stmt|;
comment|/* 		 * We really don't want to indicate failure, 		 * but the packet has already been sent and freed. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ARPTAB_LOOK
argument_list|(
name|at
argument_list|,
name|destip
operator|->
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
literal|0
condition|)
block|{
comment|/* not found */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
operator|)
operator|||
name|lna
operator|>=
name|oldmap
condition|)
block|{
operator|*
name|desten
operator|=
name|ac
operator|->
name|ac_enaddr
expr_stmt|;
name|desten
operator|->
name|ether_addr_octet
index|[
literal|3
index|]
operator|=
operator|(
name|lna
operator|>>
literal|16
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|desten
operator|->
name|ether_addr_octet
index|[
literal|4
index|]
operator|=
operator|(
name|lna
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|desten
operator|->
name|ether_addr_octet
index|[
literal|5
index|]
operator|=
name|lna
operator|&
literal|0xff
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|at
operator|=
name|arptnew
argument_list|(
name|destip
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_hold
operator|=
name|m
expr_stmt|;
name|arpwhohas
argument_list|(
name|ac
argument_list|,
name|destip
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|at
operator|->
name|at_timer
operator|=
literal|0
expr_stmt|;
comment|/* restart the timer */
if|if
condition|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_COM
condition|)
block|{
comment|/* entry IS complete */
operator|*
name|desten
operator|=
name|at
operator|->
name|at_enaddr
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * There is an arptab entry, but no ethernet address 	 * response yet.  Replace the held mbuf with this 	 * latest one. 	 */
if|if
condition|(
name|at
operator|->
name|at_hold
condition|)
name|m_freem
argument_list|(
name|at
operator|->
name|at_hold
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_hold
operator|=
name|m
expr_stmt|;
name|arpwhohas
argument_list|(
name|ac
argument_list|,
name|destip
argument_list|)
expr_stmt|;
comment|/* ask again */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Called from ecintr/ilintr when ether packet type ETHERPUP_ARP  * is received.  Algorithm is that given in RFC 826.  * In addition, a sanity check is performed on the sender  * protocol address, to catch impersonators.  */
end_comment

begin_expr_stmt
name|arpinput
argument_list|(
name|ac
argument_list|,
name|m
argument_list|)
specifier|register
expr|struct
name|arpcom
operator|*
name|ac
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ether_arp
modifier|*
name|ea
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
specifier|register
name|struct
name|arptab
modifier|*
name|at
init|=
literal|0
decl_stmt|;
comment|/* same as "merge" flag */
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mhold
decl_stmt|;
name|struct
name|in_addr
name|isaddr
decl_stmt|,
name|itaddr
decl_stmt|,
name|myaddr
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
expr|*
name|ea
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ac
operator|->
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_NOARP
condition|)
goto|goto
name|out
goto|;
name|myaddr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ac
operator|->
name|ac_if
operator|.
name|if_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|ea
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_arp
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|ea
operator|->
name|arp_pro
argument_list|)
operator|!=
name|ETHERPUP_IPTYPE
condition|)
goto|goto
name|out
goto|;
name|isaddr
operator|=
name|arp_spa
argument_list|(
name|ea
argument_list|)
expr_stmt|;
name|itaddr
operator|=
name|arp_tpa
argument_list|(
name|ea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|arp_sha
argument_list|(
name|ea
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ac
operator|->
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ac
operator|->
name|ac_enaddr
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* it's from me, ignore it. */
if|if
condition|(
name|isaddr
operator|.
name|s_addr
operator|==
name|myaddr
operator|.
name|s_addr
condition|)
block|{
name|printf
argument_list|(
literal|"duplicate IP address!! sent from ethernet address: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x %x %x %x %x %x\n"
argument_list|,
name|ea
operator|->
name|arp_xsha
index|[
literal|0
index|]
argument_list|,
name|ea
operator|->
name|arp_xsha
index|[
literal|1
index|]
argument_list|,
name|ea
operator|->
name|arp_xsha
index|[
literal|2
index|]
argument_list|,
name|ea
operator|->
name|arp_xsha
index|[
literal|3
index|]
argument_list|,
name|ea
operator|->
name|arp_xsha
index|[
literal|4
index|]
argument_list|,
name|ea
operator|->
name|arp_xsha
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|itaddr
operator|=
name|myaddr
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|ea
operator|->
name|arp_op
argument_list|)
operator|==
name|ARPOP_REQUEST
condition|)
goto|goto
name|reply
goto|;
goto|goto
name|out
goto|;
block|}
name|ARPTAB_LOOK
argument_list|(
name|at
argument_list|,
name|isaddr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
condition|)
block|{
comment|/* XXX ? - can overwrite ATF_PERM */
name|at
operator|->
name|at_enaddr
operator|=
name|arp_sha
argument_list|(
name|ea
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_flags
operator||=
name|ATF_COM
expr_stmt|;
if|if
condition|(
name|at
operator|->
name|at_hold
condition|)
block|{
name|mhold
operator|=
name|at
operator|->
name|at_hold
expr_stmt|;
name|at
operator|->
name|at_hold
operator|=
literal|0
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|isaddr
expr_stmt|;
call|(
modifier|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
call|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|mhold
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|itaddr
operator|.
name|s_addr
operator|==
name|myaddr
operator|.
name|s_addr
condition|)
block|{
comment|/* ensure we have a table entry */
name|at
operator|=
name|arptnew
argument_list|(
operator|&
name|isaddr
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_enaddr
operator|=
name|arp_sha
argument_list|(
name|ea
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_flags
operator||=
name|ATF_COM
expr_stmt|;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|ea
operator|->
name|arp_op
argument_list|)
operator|!=
name|ARPOP_REQUEST
condition|)
goto|goto
name|out
goto|;
name|ARPTAB_LOOK
argument_list|(
name|at
argument_list|,
name|itaddr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|itaddr
operator|.
name|s_addr
operator|!=
name|myaddr
operator|.
name|s_addr
condition|)
goto|goto
name|out
goto|;
comment|/* if I am not the target */
name|at
operator|=
name|arptnew
argument_list|(
operator|&
name|myaddr
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_enaddr
operator|=
name|ac
operator|->
name|ac_enaddr
expr_stmt|;
name|at
operator|->
name|at_flags
operator||=
name|ATF_COM
expr_stmt|;
block|}
if|if
condition|(
name|itaddr
operator|.
name|s_addr
operator|!=
name|myaddr
operator|.
name|s_addr
operator|&&
operator|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_PUBL
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|reply
label|:
name|arp_tha
argument_list|(
name|ea
argument_list|)
operator|=
name|arp_sha
argument_list|(
name|ea
argument_list|)
expr_stmt|;
name|arp_tpa
argument_list|(
name|ea
argument_list|)
operator|=
name|arp_spa
argument_list|(
name|ea
argument_list|)
expr_stmt|;
name|arp_sha
argument_list|(
name|ea
argument_list|)
operator|=
name|at
operator|->
name|at_enaddr
expr_stmt|;
name|arp_spa
argument_list|(
name|ea
argument_list|)
operator|=
name|itaddr
expr_stmt|;
name|ea
operator|->
name|arp_op
operator|=
name|htons
argument_list|(
name|ARPOP_REPLY
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|sa
operator|.
name|sa_data
expr_stmt|;
name|eh
operator|->
name|ether_dhost
operator|=
name|arp_tha
argument_list|(
name|ea
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|ETHERPUP_ARPTYPE
expr_stmt|;
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
call|(
modifier|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
call|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|m
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
return|return;
name|out
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Free an arptab entry.  */
end_comment

begin_expr_stmt
name|arptfree
argument_list|(
name|at
argument_list|)
specifier|register
expr|struct
name|arptab
operator|*
name|at
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|at
operator|->
name|at_hold
condition|)
name|m_freem
argument_list|(
name|at
operator|->
name|at_hold
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_hold
operator|=
literal|0
expr_stmt|;
name|at
operator|->
name|at_timer
operator|=
name|at
operator|->
name|at_flags
operator|=
literal|0
expr_stmt|;
name|at
operator|->
name|at_iaddr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Enter a new address in arptab, pushing out the oldest entry   * from the bucket if there is no room.  * This always succeeds since no bucket can be completely filled  * with permanent entries (except from arpioctl when testing whether  * another permanent entry).  */
end_comment

begin_function
name|struct
name|arptab
modifier|*
name|arptnew
parameter_list|(
name|addr
parameter_list|)
name|struct
name|in_addr
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
name|n
expr_stmt|;
name|int
name|oldest
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|arptab
modifier|*
name|at
decl_stmt|,
modifier|*
name|ato
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|timeout
argument_list|(
name|arptimer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|at
operator|=
operator|&
name|arptab
index|[
name|ARPTAB_HASH
argument_list|(
name|addr
operator|->
name|s_addr
argument_list|)
operator|*
name|ARPTAB_BSIZ
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ARPTAB_BSIZ
condition|;
name|n
operator|++
operator|,
name|at
operator|++
control|)
block|{
if|if
condition|(
name|at
operator|->
name|at_flags
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* found an empty entry */
if|if
condition|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_PERM
condition|)
continue|continue;
if|if
condition|(
name|at
operator|->
name|at_timer
operator|>
name|oldest
condition|)
block|{
name|oldest
operator|=
name|at
operator|->
name|at_timer
expr_stmt|;
name|ato
operator|=
name|at
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ato
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|at
operator|=
name|ato
expr_stmt|;
name|arptfree
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|out
label|:
name|at
operator|->
name|at_iaddr
operator|=
operator|*
name|addr
expr_stmt|;
name|at
operator|->
name|at_flags
operator|=
name|ATF_INUSE
expr_stmt|;
return|return
operator|(
name|at
operator|)
return|;
block|}
end_function

begin_macro
name|arpioctl
argument_list|(
argument|cmd
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|arpreq
modifier|*
name|ar
init|=
operator|(
expr|struct
name|arpreq
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|struct
name|arptab
modifier|*
name|at
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|ar
operator|->
name|arp_pa
operator|.
name|sa_family
operator|!=
name|AF_INET
operator|||
name|ar
operator|->
name|arp_ha
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
condition|)
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ar
operator|->
name|arp_pa
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ARPTAB_LOOK
argument_list|(
name|at
argument_list|,
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
name|NULL
condition|)
block|{
comment|/* not found */
if|if
condition|(
name|cmd
operator|!=
name|SIOCSARP
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|if_ifwithnet
argument_list|(
operator|&
name|ar
operator|->
name|arp_pa
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETUNREACH
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSARP
case|:
comment|/* set entry */
if|if
condition|(
name|at
operator|==
name|NULL
condition|)
block|{
name|at
operator|=
name|arptnew
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|arp_flags
operator|&
name|ATF_PERM
condition|)
block|{
comment|/* never make all entries in a bucket permanent */
specifier|register
name|struct
name|arptab
modifier|*
name|tat
decl_stmt|;
comment|/* try to re-allocate */
name|tat
operator|=
name|arptnew
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tat
operator|==
name|NULL
condition|)
block|{
name|arptfree
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
name|arptfree
argument_list|(
name|tat
argument_list|)
expr_stmt|;
block|}
block|}
name|at
operator|->
name|at_enaddr
operator|=
operator|*
operator|(
expr|struct
name|ether_addr
operator|*
operator|)
name|ar
operator|->
name|arp_ha
operator|.
name|sa_data
expr_stmt|;
name|at
operator|->
name|at_flags
operator|=
name|ATF_COM
operator||
name|ATF_INUSE
operator||
operator|(
name|ar
operator|->
name|arp_flags
operator|&
operator|(
name|ATF_PERM
operator||
name|ATF_PUBL
operator|)
operator|)
expr_stmt|;
name|at
operator|->
name|at_timer
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCDARP
case|:
comment|/* delete entry */
name|arptfree
argument_list|(
name|at
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGARP
case|:
comment|/* get entry */
operator|*
operator|(
expr|struct
name|ether_addr
operator|*
operator|)
name|ar
operator|->
name|arp_ha
operator|.
name|sa_data
operator|=
name|at
operator|->
name|at_enaddr
expr_stmt|;
name|ar
operator|->
name|arp_flags
operator|=
name|at
operator|->
name|at_flags
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

