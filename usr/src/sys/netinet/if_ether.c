begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	if_ether.c	6.2	83/08/28	*/
end_comment

begin_comment
comment|/*  * Ethernet address resolution protocol.  */
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/time.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/if_ether.h"
end_include

begin_comment
comment|/*  * Internet to ethernet address resolution table.  */
end_comment

begin_struct
struct|struct
name|arptab
block|{
name|struct
name|in_addr
name|at_iaddr
decl_stmt|;
comment|/* internet address */
name|u_char
name|at_enaddr
index|[
literal|6
index|]
decl_stmt|;
comment|/* ethernet address */
name|struct
name|mbuf
modifier|*
name|at_hold
decl_stmt|;
comment|/* last packet until resolved/timeout */
name|u_char
name|at_timer
decl_stmt|;
comment|/* minutes since last reference */
name|u_char
name|at_flags
decl_stmt|;
comment|/* flags */
block|}
struct|;
end_struct

begin_comment
comment|/* at_flags field values */
end_comment

begin_define
define|#
directive|define
name|ATF_INUSE
value|1
end_define

begin_comment
comment|/* entry in use */
end_comment

begin_define
define|#
directive|define
name|ATF_COM
value|2
end_define

begin_comment
comment|/* completed entry (enaddr valid) */
end_comment

begin_define
define|#
directive|define
name|ARPTAB_BSIZ
value|5
end_define

begin_comment
comment|/* bucket size */
end_comment

begin_define
define|#
directive|define
name|ARPTAB_NB
value|19
end_define

begin_comment
comment|/* number of buckets */
end_comment

begin_define
define|#
directive|define
name|ARPTAB_SIZE
value|(ARPTAB_BSIZ * ARPTAB_NB)
end_define

begin_decl_stmt
name|struct
name|arptab
name|arptab
index|[
name|ARPTAB_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ARPTAB_HASH
parameter_list|(
name|a
parameter_list|)
define|\
value|((short)((((a)>> 16) ^ (a))& 0x7fff) % ARPTAB_NB)
end_define

begin_define
define|#
directive|define
name|ARPTAB_LOOK
parameter_list|(
name|at
parameter_list|,
name|addr
parameter_list|)
value|{ \ 	register n; \ 	at =&arptab[ARPTAB_HASH(addr) * ARPTAB_BSIZ]; \ 	for (n = 0 ; n< ARPTAB_BSIZ ; n++,at++) \ 		if (at->at_iaddr.s_addr == addr) \ 			break; \ 	if (n>= ARPTAB_BSIZ) \ 		at = 0; }
end_define

begin_decl_stmt
name|struct
name|arpcom
modifier|*
name|arpcom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* chain of active ether interfaces */
end_comment

begin_decl_stmt
name|int
name|arpt_age
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* aging timer */
end_comment

begin_comment
comment|/* timer values */
end_comment

begin_define
define|#
directive|define
name|ARPT_AGE
value|(60*1)
end_define

begin_comment
comment|/* aging timer, 1 min. */
end_comment

begin_define
define|#
directive|define
name|ARPT_KILLC
value|20
end_define

begin_comment
comment|/* kill completed entry in 20 mins. */
end_comment

begin_define
define|#
directive|define
name|ARPT_KILLI
value|3
end_define

begin_comment
comment|/* kill incomplete entry in 3 minutes */
end_comment

begin_decl_stmt
name|u_char
name|etherbroadcastaddr
index|[
literal|6
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ifnet
name|loif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local addresses in the range oldmap to infinity are  * mapped according to the old mapping scheme.  That is,  * mapping of Internet to Ethernet addresses is performed  * by taking the high three bytes of the network interface's  * address and the low three bytes of the local address part.  * This only allows boards from the same manufacturer to  * communicate unless the on-board address is overridden  * (not possible in many manufacture's hardware).  *  * NB: setting oldmap to zero completely disables ARP  *     (i.e. identical to setting IFF_NOARP with an ioctl).  */
end_comment

begin_decl_stmt
name|int
name|oldmap
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Attach an ethernet interface to the list "arpcom" where  * arptimer() can find it.  If first time   * initialization, start arptimer().  */
end_comment

begin_expr_stmt
name|arpattach
argument_list|(
name|ac
argument_list|)
specifier|register
expr|struct
name|arpcom
operator|*
name|ac
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|arpcom
modifier|*
name|acp
decl_stmt|;
for|for
control|(
name|acp
operator|=
name|arpcom
init|;
name|acp
operator|!=
operator|(
expr|struct
name|arpcom
operator|*
operator|)
literal|0
condition|;
name|acp
operator|=
name|acp
operator|->
name|ac_ac
control|)
if|if
condition|(
name|acp
operator|==
name|ac
condition|)
comment|/* if already on list */
return|return;
name|ac
operator|->
name|ac_ac
operator|=
name|arpcom
expr_stmt|;
name|arpcom
operator|=
name|ac
expr_stmt|;
if|if
condition|(
name|arpcom
operator|->
name|ac_ac
operator|==
literal|0
condition|)
comment|/* very first time */
name|arptimer
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Timeout routine.  Age arp_tab entries once a minute.  */
end_comment

begin_macro
name|arptimer
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|arptab
modifier|*
name|at
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|timeout
argument_list|(
name|arptimer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|++
name|arpt_sanity
operator|>
name|ARPT_SANITY
condition|)
block|{
specifier|register
name|struct
name|arpcom
modifier|*
name|ac
decl_stmt|;
comment|/* 		 * Randomize sanity timer based on my host address. 		 * Ask who has my own address;  if someone else replies, 		 * then they are impersonating me. 		 */
name|arpt_sanity
operator|=
name|arpcom
operator|->
name|ac_enaddr
index|[
literal|5
index|]
operator|&
literal|0x3f
expr_stmt|;
for|for
control|(
name|ac
operator|=
name|arpcom
init|;
name|ac
operator|!=
operator|(
expr|struct
name|arpcom
operator|*
operator|)
operator|-
literal|1
condition|;
name|ac
operator|=
name|ac
operator|->
name|ac_ac
control|)
name|arpwhohas
argument_list|(
name|ac
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ac
operator|->
name|ac_if
operator|.
name|if_addr
operator|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|++
name|arpt_age
operator|>
name|ARPT_AGE
condition|)
block|{
name|arpt_age
operator|=
literal|0
expr_stmt|;
name|at
operator|=
operator|&
name|arptab
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARPTAB_SIZE
condition|;
name|i
operator|++
operator|,
name|at
operator|++
control|)
block|{
if|if
condition|(
name|at
operator|->
name|at_flags
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|++
name|at
operator|->
name|at_timer
operator|<
operator|(
operator|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_COM
operator|)
condition|?
name|ARPT_KILLC
else|:
name|ARPT_KILLI
operator|)
condition|)
continue|continue;
comment|/* timer has expired, clear entry */
name|arptfree
argument_list|(
name|at
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Broadcast an ARP packet, asking who has addr on interface ac.  */
end_comment

begin_expr_stmt
name|arpwhohas
argument_list|(
name|ac
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|arpcom
operator|*
name|ac
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|in_addr
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
specifier|register
name|struct
name|ether_arp
modifier|*
name|ea
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
expr|*
name|ea
operator|+
sizeof|sizeof
expr|*
name|eh
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMAXOFF
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
name|ea
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_arp
operator|*
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|sa
operator|.
name|sa_data
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ea
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|etherbroadcastaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|eh
operator|->
name|ether_dhost
argument_list|,
sizeof|sizeof
argument_list|(
name|etherbroadcastaddr
argument_list|)
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|ETHERPUP_ARPTYPE
expr_stmt|;
comment|/* if_output will swap */
name|ea
operator|->
name|arp_hrd
operator|=
name|htons
argument_list|(
name|ARPHRD_ETHER
argument_list|)
expr_stmt|;
name|ea
operator|->
name|arp_pro
operator|=
name|htons
argument_list|(
name|ETHERPUP_IPTYPE
argument_list|)
expr_stmt|;
name|ea
operator|->
name|arp_hln
operator|=
sizeof|sizeof
name|ea
operator|->
name|arp_sha
expr_stmt|;
comment|/* hardware address length */
name|ea
operator|->
name|arp_pln
operator|=
sizeof|sizeof
name|ea
operator|->
name|arp_spa
expr_stmt|;
comment|/* protocol address length */
name|ea
operator|->
name|arp_op
operator|=
name|htons
argument_list|(
name|ARPOP_REQUEST
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ac
operator|->
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ac
operator|->
name|ac_if
operator|.
name|if_addr
operator|)
operator|->
name|sin_addr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_spa
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_spa
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tpa
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_tpa
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
argument_list|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|m
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Resolve an IP address into an ethernet address.  If success,   * desten is filled in and 1 is returned.  If there is no entry  * in arptab, set one up and broadcast a request   * for the IP address;  return 0.  Hold onto this mbuf and   * resend it once the address is finally resolved.  *  * We do some (conservative) locking here at splimp, since  * arptab is also altered from input interrupt service (ecintr/ilintr  * calls arpinput when ETHERPUP_ARPTYPE packets come in).  */
end_comment

begin_expr_stmt
name|arpresolve
argument_list|(
name|ac
argument_list|,
name|m
argument_list|,
name|destip
argument_list|,
name|desten
argument_list|)
specifier|register
expr|struct
name|arpcom
operator|*
name|ac
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|in_addr
modifier|*
name|destip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|u_char
modifier|*
name|desten
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|arptab
modifier|*
name|at
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|s
decl_stmt|,
name|lna
decl_stmt|;
name|lna
operator|=
name|in_lnaof
argument_list|(
operator|*
name|destip
argument_list|)
expr_stmt|;
if|if
condition|(
name|lna
operator|==
name|INADDR_ANY
condition|)
block|{
comment|/* broadcast address */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|etherbroadcastaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|desten
argument_list|,
sizeof|sizeof
argument_list|(
name|etherbroadcastaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ifp
operator|=
operator|&
name|ac
operator|->
name|ac_if
expr_stmt|;
comment|/* if for us, then use software loopback driver */
if|if
condition|(
name|destip
operator|->
name|s_addr
operator|==
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifp
operator|->
name|if_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
operator|*
name|destip
expr_stmt|;
return|return
operator|(
name|looutput
argument_list|(
operator|&
name|loif
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
operator|)
operator|||
name|lna
operator|>=
name|oldmap
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ac
operator|->
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|desten
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|desten
index|[
literal|3
index|]
operator|=
operator|(
name|lna
operator|>>
literal|16
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|desten
index|[
literal|4
index|]
operator|=
operator|(
name|lna
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|desten
index|[
literal|5
index|]
operator|=
name|lna
operator|&
literal|0xff
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ARPTAB_LOOK
argument_list|(
name|at
argument_list|,
name|destip
operator|->
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
literal|0
condition|)
block|{
comment|/* not found */
name|at
operator|=
name|arptnew
argument_list|(
name|destip
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_hold
operator|=
name|m
expr_stmt|;
name|arpwhohas
argument_list|(
name|ac
argument_list|,
name|destip
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|at
operator|->
name|at_timer
operator|=
literal|0
expr_stmt|;
comment|/* restart the timer */
if|if
condition|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_COM
condition|)
block|{
comment|/* entry IS complete */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|at
operator|->
name|at_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|desten
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * There is an arptab entry, but no ethernet address 	 * response yet.  Replace the held mbuf with this 	 * latest one. 	 */
if|if
condition|(
name|at
operator|->
name|at_hold
condition|)
name|m_freem
argument_list|(
name|at
operator|->
name|at_hold
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_hold
operator|=
name|m
expr_stmt|;
name|arpwhohas
argument_list|(
name|ac
argument_list|,
name|destip
argument_list|)
expr_stmt|;
comment|/* ask again */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Find my own IP address.  It will either be waiting for us in  * monitor RAM, or can be obtained via broadcast to the file/boot  * server (not necessarily using the ARP packet format).  *  * Unimplemented at present, return 0 and assume that the host  * will set his own IP address via the SIOCSIFADDR ioctl.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|struct
name|in_addr
name|arpmyaddr
parameter_list|(
name|ac
parameter_list|)
specifier|register
name|struct
name|arpcom
modifier|*
name|ac
decl_stmt|;
block|{
specifier|static
name|struct
name|in_addr
name|addr
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|ac
operator|=
name|ac
expr_stmt|;
endif|#
directive|endif
name|addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from ecintr/ilintr when ether packet type ETHERPUP_ARP  * is received.  Algorithm is exactly that given in RFC 826.  * In addition, a sanity check is performed on the sender  * protocol address, to catch impersonators.  */
end_comment

begin_expr_stmt
name|arpinput
argument_list|(
name|ac
argument_list|,
name|m
argument_list|)
specifier|register
expr|struct
name|arpcom
operator|*
name|ac
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ether_arp
modifier|*
name|ea
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
specifier|register
name|struct
name|arptab
modifier|*
name|at
init|=
literal|0
decl_stmt|;
comment|/* same as "merge" flag */
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mhold
decl_stmt|;
name|struct
name|in_addr
name|isaddr
decl_stmt|,
name|itaddr
decl_stmt|,
name|myaddr
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
expr|*
name|ea
condition|)
goto|goto
name|out
goto|;
name|myaddr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ac
operator|->
name|ac_if
operator|.
name|if_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|ea
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_arp
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|ea
operator|->
name|arp_pro
argument_list|)
operator|!=
name|ETHERPUP_IPTYPE
condition|)
goto|goto
name|out
goto|;
name|isaddr
operator|.
name|s_addr
operator|=
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|ea
operator|->
name|arp_spa
operator|)
operator|->
name|s_addr
expr_stmt|;
name|itaddr
operator|.
name|s_addr
operator|=
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|ea
operator|->
name|arp_tpa
operator|)
operator|->
name|s_addr
expr_stmt|;
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|ac
operator|->
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ac
operator|->
name|ac_enaddr
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* it's from me, ignore it. */
if|if
condition|(
name|isaddr
operator|.
name|s_addr
operator|==
name|myaddr
operator|.
name|s_addr
condition|)
block|{
name|printf
argument_list|(
literal|"duplicate IP address!! sent from ethernet address: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x %x %x %x %x %x\n"
argument_list|,
name|ea
operator|->
name|arp_sha
index|[
literal|0
index|]
argument_list|,
name|ea
operator|->
name|arp_sha
index|[
literal|1
index|]
argument_list|,
name|ea
operator|->
name|arp_sha
index|[
literal|2
index|]
argument_list|,
name|ea
operator|->
name|arp_sha
index|[
literal|3
index|]
argument_list|,
name|ea
operator|->
name|arp_sha
index|[
literal|4
index|]
argument_list|,
name|ea
operator|->
name|arp_sha
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|ea
operator|->
name|arp_op
argument_list|)
operator|==
name|ARPOP_REQUEST
condition|)
goto|goto
name|reply
goto|;
goto|goto
name|out
goto|;
block|}
name|ARPTAB_LOOK
argument_list|(
name|at
argument_list|,
name|isaddr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|at
operator|->
name|at_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_flags
operator||=
name|ATF_COM
expr_stmt|;
if|if
condition|(
name|at
operator|->
name|at_hold
condition|)
block|{
name|mhold
operator|=
name|at
operator|->
name|at_hold
expr_stmt|;
name|at
operator|->
name|at_hold
operator|=
literal|0
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|isaddr
expr_stmt|;
call|(
modifier|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
call|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|mhold
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|itaddr
operator|.
name|s_addr
operator|!=
name|myaddr
operator|.
name|s_addr
condition|)
goto|goto
name|out
goto|;
comment|/* if I am not the target */
if|if
condition|(
name|at
operator|==
literal|0
condition|)
block|{
comment|/* ensure we have a table entry */
name|at
operator|=
name|arptnew
argument_list|(
operator|&
name|isaddr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|at
operator|->
name|at_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_flags
operator||=
name|ATF_COM
expr_stmt|;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|ea
operator|->
name|arp_op
argument_list|)
operator|!=
name|ARPOP_REQUEST
condition|)
goto|goto
name|out
goto|;
name|reply
label|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tha
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_spa
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tpa
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_spa
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ac
operator|->
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|myaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_spa
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_spa
argument_list|)
argument_list|)
expr_stmt|;
name|ea
operator|->
name|arp_op
operator|=
name|htons
argument_list|(
name|ARPOP_REPLY
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|sa
operator|.
name|sa_data
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tha
argument_list|,
operator|(
name|caddr_t
operator|)
name|eh
operator|->
name|ether_dhost
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|ETHERPUP_ARPTYPE
expr_stmt|;
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
call|(
modifier|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
call|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|m
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
return|return;
name|out
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Free an arptab entry.  */
end_comment

begin_expr_stmt
name|arptfree
argument_list|(
name|at
argument_list|)
specifier|register
expr|struct
name|arptab
operator|*
name|at
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|at
operator|->
name|at_hold
condition|)
name|m_freem
argument_list|(
name|at
operator|->
name|at_hold
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_hold
operator|=
literal|0
expr_stmt|;
name|at
operator|->
name|at_timer
operator|=
name|at
operator|->
name|at_flags
operator|=
literal|0
expr_stmt|;
name|at
operator|->
name|at_iaddr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Enter a new address in arptab, pushing out the oldest entry   * from the bucket if there is no room.  */
end_comment

begin_function
name|struct
name|arptab
modifier|*
name|arptnew
parameter_list|(
name|addr
parameter_list|)
name|struct
name|in_addr
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
name|n
expr_stmt|;
name|int
name|oldest
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|arptab
modifier|*
name|at
decl_stmt|,
modifier|*
name|ato
decl_stmt|;
name|ato
operator|=
name|at
operator|=
operator|&
name|arptab
index|[
name|ARPTAB_HASH
argument_list|(
name|addr
operator|->
name|s_addr
argument_list|)
operator|*
name|ARPTAB_BSIZ
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ARPTAB_BSIZ
condition|;
name|n
operator|++
operator|,
name|at
operator|++
control|)
block|{
if|if
condition|(
name|at
operator|->
name|at_flags
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* found an empty entry */
if|if
condition|(
name|at
operator|->
name|at_timer
operator|>
name|oldest
condition|)
block|{
name|oldest
operator|=
name|at
operator|->
name|at_timer
expr_stmt|;
name|ato
operator|=
name|at
expr_stmt|;
block|}
block|}
name|at
operator|=
name|ato
expr_stmt|;
name|arptfree
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|out
label|:
name|at
operator|->
name|at_iaddr
operator|=
operator|*
name|addr
expr_stmt|;
name|at
operator|->
name|at_flags
operator|=
name|ATF_INUSE
expr_stmt|;
return|return
operator|(
name|at
operator|)
return|;
block|}
end_function

end_unit

