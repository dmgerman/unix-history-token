begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)if_ether.c	7.14 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Ethernet address resolution protocol.  * TODO:  *	run at splnet (add ARP protocol intr.)  *	link entries onto hash chains, keep free list  *	add "inuse/lock" bit (or ref. count) along with valid bit  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/if_dl.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"in.h"
end_include

begin_include
include|#
directive|include
file|"in_systm.h"
end_include

begin_include
include|#
directive|include
file|"in_var.h"
end_include

begin_include
include|#
directive|include
file|"ip.h"
end_include

begin_include
include|#
directive|include
file|"if_ether.h"
end_include

begin_define
define|#
directive|define
name|SIN
parameter_list|(
name|s
parameter_list|)
value|((struct sockaddr_in *)s)
end_define

begin_define
define|#
directive|define
name|SDL
parameter_list|(
name|s
parameter_list|)
value|((struct sockaddr_dl *)s)
end_define

begin_define
define|#
directive|define
name|SRP
parameter_list|(
name|s
parameter_list|)
value|((struct sockaddr_inarp *)s)
end_define

begin_comment
comment|/*  * ARP trailer negotiation.  Trailer protocol is not IP specific,  * but ARP request/response use IP addresses.  */
end_comment

begin_define
define|#
directive|define
name|ETHERTYPE_IPTRAILERS
value|ETHERTYPE_TRAIL
end_define

begin_comment
comment|/* timer values */
end_comment

begin_decl_stmt
name|int
name|arpt_prune
init|=
operator|(
literal|5
operator|*
literal|60
operator|*
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* walk list every 5 minutes */
end_comment

begin_decl_stmt
name|int
name|arpt_keep
init|=
operator|(
literal|20
operator|*
literal|60
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* once resolved, good for 20 more minutes */
end_comment

begin_decl_stmt
name|int
name|arpt_down
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* once declared down, don't send for 20 secs */
end_comment

begin_define
define|#
directive|define
name|RTF_USETRAILERS
value|RTF_PROTO1
end_define

begin_define
define|#
directive|define
name|rt_expire
value|rt_rmx.rmx_expire
end_define

begin_decl_stmt
specifier|extern
name|struct
name|ifnet
name|loif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|timeval
name|time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|llinfo_arp
modifier|*
name|arplookup
argument_list|()
decl_stmt|,
name|llinfo_arp
init|=
block|{
operator|&
name|llinfo_arp
block|,
operator|&
name|llinfo_arp
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifqueue
name|arpintrq
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|50
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arp_inuse
decl_stmt|,
name|arp_allocated
decl_stmt|,
name|arp_intimer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arp_maxtries
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|useloopback
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use loopback interface for local traffic */
end_comment

begin_decl_stmt
name|int
name|arpinit_done
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Timeout routine.  Age arp_tab entries periodically.  */
end_comment

begin_macro
name|arptimer
argument_list|()
end_macro

begin_block
block|{
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
specifier|register
name|struct
name|llinfo_arp
modifier|*
name|la
init|=
name|llinfo_arp
operator|.
name|la_next
decl_stmt|;
name|timeout
argument_list|(
name|arptimer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|arpt_prune
operator|*
name|hz
argument_list|)
expr_stmt|;
while|while
condition|(
name|la
operator|!=
operator|&
name|llinfo_arp
condition|)
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|la
operator|->
name|la_rt
decl_stmt|;
name|la
operator|=
name|la
operator|->
name|la_next
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_expire
operator|&&
name|rt
operator|->
name|rt_expire
operator|<=
name|time
operator|.
name|tv_sec
condition|)
name|arptfree
argument_list|(
name|la
operator|->
name|la_prev
argument_list|)
expr_stmt|;
comment|/* timer has expired, clear */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Parallel to llc_rtrequest.   */
end_comment

begin_macro
name|arp_rtrequest
argument_list|(
argument|req
argument_list|,
argument|rt
argument_list|,
argument|sa
argument_list|)
end_macro

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sockaddr
modifier|*
name|gate
init|=
name|rt
operator|->
name|rt_gateway
decl_stmt|;
specifier|register
name|struct
name|llinfo_arp
modifier|*
name|la
init|=
operator|(
expr|struct
name|llinfo_arp
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
decl_stmt|;
specifier|static
name|struct
name|sockaddr_dl
name|null_sdl
init|=
block|{
sizeof|sizeof
argument_list|(
name|null_sdl
argument_list|)
block|,
name|AF_LINK
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|arpinit_done
condition|)
block|{
name|arpinit_done
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|arptimer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
return|return;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|RTM_ADD
case|:
case|case
name|RTM_RESOLVE
case|:
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_CLONING
condition|)
block|{
comment|/* 			 * Case 1: This route should come from a route to iface. 			 */
name|rt_setgate
argument_list|(
name|rt
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|&
name|null_sdl
argument_list|)
expr_stmt|;
name|gate
operator|=
name|rt
operator|->
name|rt_gateway
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_type
operator|=
name|rt
operator|->
name|rt_ifp
operator|->
name|if_type
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_index
operator|=
name|rt
operator|->
name|rt_ifp
operator|->
name|if_index
expr_stmt|;
name|rt
operator|->
name|rt_expire
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gate
operator|->
name|sa_family
operator|!=
name|AF_LINK
operator|||
name|gate
operator|->
name|sa_len
operator|<
sizeof|sizeof
argument_list|(
name|null_sdl
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"arp_rtrequest: bad gateway value"
argument_list|)
expr_stmt|;
break|break;
block|}
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_type
operator|=
name|rt
operator|->
name|rt_ifp
operator|->
name|if_type
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_index
operator|=
name|rt
operator|->
name|rt_ifp
operator|->
name|if_index
expr_stmt|;
if|if
condition|(
name|la
operator|!=
literal|0
condition|)
break|break;
comment|/* This happens on a route change */
comment|/* 		 * Case 2:  This route may come from cloning, or a manual route 		 * add with a LL address. 		 */
name|R_Malloc
argument_list|(
name|la
argument_list|,
expr|struct
name|llinfo_arp
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|la
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
operator|(
name|caddr_t
operator|)
name|la
expr_stmt|;
if|if
condition|(
name|la
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"arp_rtrequest: malloc failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|arp_inuse
operator|++
operator|,
name|arp_allocated
operator|++
expr_stmt|;
name|Bzero
argument_list|(
name|la
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|la
argument_list|)
argument_list|)
expr_stmt|;
name|la
operator|->
name|la_rt
operator|=
name|rt
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator||=
name|RTF_LLINFO
expr_stmt|;
name|insque
argument_list|(
name|la
argument_list|,
operator|&
name|llinfo_arp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIN
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
operator|(
name|IA_SIN
argument_list|(
name|rt
operator|->
name|rt_ifa
argument_list|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* 		     * This test used to be 		     *	if (loif.if_flags& IFF_UP) 		     * It allowed local traffic to be forced 		     * through the hardware by configuring the loopback down. 		     * However, it causes problems during network configuration 		     * for boards that can't receive packets they send. 		     * It is now necessary to clear "useloopback" and remove 		     * the route to force traffic out to the hardware. 		     */
name|rt
operator|->
name|rt_expire
operator|=
literal|0
expr_stmt|;
name|Bcopy
argument_list|(
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|rt
operator|->
name|rt_ifp
operator|)
operator|->
name|ac_enaddr
argument_list|,
name|LLADDR
argument_list|(
name|SDL
argument_list|(
name|gate
argument_list|)
argument_list|)
argument_list|,
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_alen
operator|=
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|useloopback
condition|)
name|rt
operator|->
name|rt_ifp
operator|=
operator|&
name|loif
expr_stmt|;
block|}
break|break;
case|case
name|RTM_DELETE
case|:
if|if
condition|(
name|la
operator|==
literal|0
condition|)
break|break;
name|arp_inuse
operator|--
expr_stmt|;
name|remque
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_LLINFO
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|la_hold
condition|)
name|m_freem
argument_list|(
name|la
operator|->
name|la_hold
argument_list|)
expr_stmt|;
name|Free
argument_list|(
operator|(
name|caddr_t
operator|)
name|la
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Broadcast an ARP packet, asking who has addr on interface ac.  */
end_comment

begin_expr_stmt
name|arpwhohas
argument_list|(
name|ac
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|arpcom
operator|*
name|ac
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|inaddr
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
specifier|register
name|struct
name|ether_arp
modifier|*
name|ea
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ea
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ea
argument_list|)
expr_stmt|;
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ea
argument_list|)
argument_list|)
expr_stmt|;
name|ea
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_arp
operator|*
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|sa
operator|.
name|sa_data
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ea
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|etherbroadcastaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|eh
operator|->
name|ether_dhost
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|ETHERTYPE_ARP
expr_stmt|;
comment|/* if_output will swap */
name|ea
operator|->
name|arp_hrd
operator|=
name|htons
argument_list|(
name|ARPHRD_ETHER
argument_list|)
expr_stmt|;
name|ea
operator|->
name|arp_pro
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
name|ea
operator|->
name|arp_hln
operator|=
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
expr_stmt|;
comment|/* hardware address length */
name|ea
operator|->
name|arp_pln
operator|=
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_spa
argument_list|)
expr_stmt|;
comment|/* protocol address length */
name|ea
operator|->
name|arp_op
operator|=
name|htons
argument_list|(
name|ARPOP_REQUEST
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ac
operator|->
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ac
operator|->
name|ac_ipaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_spa
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_spa
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tpa
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_tpa
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|sa
operator|.
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
call|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|m
argument_list|,
operator|&
name|sa
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|useloopback
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use loopback interface for local traffic */
end_comment

begin_comment
comment|/*  * Resolve an IP address into an ethernet address.  If success,   * desten is filled in.  If there is no entry in arptab,  * set one up and broadcast a request for the IP address.  * Hold onto this mbuf and resend it once the address  * is finally resolved.  A return value of 1 indicates  * that desten has been filled in and the packet should be sent  * normally; a 0 return indicates that the packet has been  * taken over here, either now or for later transmission.  */
end_comment

begin_expr_stmt
name|arpresolve
argument_list|(
name|ac
argument_list|,
name|rt
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|desten
argument_list|,
name|usetrailers
argument_list|)
specifier|register
expr|struct
name|arpcom
operator|*
name|ac
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|u_char
modifier|*
name|desten
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|usetrailers
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|llinfo_arp
modifier|*
name|la
decl_stmt|;
specifier|register
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
operator|*
name|usetrailers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_BCAST
condition|)
block|{
comment|/* broadcast */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|etherbroadcastaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|desten
argument_list|,
sizeof|sizeof
argument_list|(
name|etherbroadcastaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rt
condition|)
name|la
operator|=
operator|(
expr|struct
name|llinfo_arp
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
expr_stmt|;
else|else
block|{
if|if
condition|(
name|la
operator|=
name|arplookup
argument_list|(
name|SIN
argument_list|(
name|dst
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
name|rt
operator|=
name|la
operator|->
name|la_rt
expr_stmt|;
block|}
if|if
condition|(
name|la
operator|==
literal|0
operator|||
name|rt
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"arpresolve: can't allocate llinfo"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sdl
operator|=
name|SDL
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
comment|/* 	 * Check the address family and length is valid, the address 	 * is resolved; otherwise, try to resolve. 	 */
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_expire
operator|==
literal|0
operator|||
name|rt
operator|->
name|rt_expire
operator|>
name|time
operator|.
name|tv_sec
operator|)
operator|&&
name|sdl
operator|->
name|sdl_family
operator|==
name|AF_LINK
operator|&&
name|sdl
operator|->
name|sdl_alen
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|desten
argument_list|,
name|sdl
operator|->
name|sdl_alen
argument_list|)
expr_stmt|;
operator|*
name|usetrailers
operator|=
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_USETRAILERS
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * There is an arptab entry, but no ethernet address 	 * response yet.  Replace the held mbuf with this 	 * latest one. 	 */
if|if
condition|(
name|la
operator|->
name|la_hold
condition|)
name|m_freem
argument_list|(
name|la
operator|->
name|la_hold
argument_list|)
expr_stmt|;
name|la
operator|->
name|la_hold
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_expire
condition|)
block|{
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_REJECT
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|la_asked
operator|==
literal|0
operator|||
name|rt
operator|->
name|rt_expire
operator|!=
name|time
operator|.
name|tv_sec
condition|)
block|{
name|rt
operator|->
name|rt_expire
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|la_asked
operator|++
operator|<
name|arp_maxtries
condition|)
name|arpwhohas
argument_list|(
name|ac
argument_list|,
operator|&
operator|(
name|SIN
argument_list|(
name|dst
argument_list|)
operator|->
name|sin_addr
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|rt
operator|->
name|rt_flags
operator||=
name|RTF_REJECT
expr_stmt|;
name|rt
operator|->
name|rt_expire
operator|+=
name|arpt_down
expr_stmt|;
name|la
operator|->
name|la_asked
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Common length and type checks are done here,  * then the protocol-specific routine is called.  */
end_comment

begin_macro
name|arpintr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|arphdr
modifier|*
name|ar
decl_stmt|;
name|int
name|s
decl_stmt|;
while|while
condition|(
name|arpintrq
operator|.
name|ifq_head
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|arpintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
operator|||
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"arpintr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|arphdr
argument_list|)
operator|&&
operator|(
name|ar
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arphdr
operator|*
argument_list|)
operator|)
operator|&&
name|ntohs
argument_list|(
name|ar
operator|->
name|ar_hrd
argument_list|)
operator|==
name|ARPHRD_ETHER
operator|&&
name|m
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|arphdr
argument_list|)
operator|+
literal|2
operator|*
name|ar
operator|->
name|ar_hln
operator|+
literal|2
operator|*
name|ar
operator|->
name|ar_pln
condition|)
switch|switch
condition|(
name|ntohs
argument_list|(
name|ar
operator|->
name|ar_pro
argument_list|)
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
case|case
name|ETHERTYPE_IPTRAILERS
case|:
name|in_arpinput
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * ARP for Internet protocols on 10 Mb/s Ethernet.  * Algorithm is that given in RFC 826.  * In addition, a sanity check is performed on the sender  * protocol address, to catch impersonators.  * We also handle negotiations for use of trailer protocol:  * ARP replies for protocol type ETHERTYPE_TRAIL are sent  * along with IP replies if we want trailers sent to us,  * and also send them in response to IP replies.  * This allows either end to announce the desire to receive  * trailer packets.  * We reply to requests for ETHERTYPE_TRAIL protocol as well,  * but don't normally send requests.  */
end_comment

begin_macro
name|in_arpinput
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ether_arp
modifier|*
name|ea
decl_stmt|;
specifier|register
name|struct
name|arpcom
modifier|*
name|ac
init|=
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
specifier|register
name|struct
name|llinfo_arp
modifier|*
name|la
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|,
modifier|*
name|maybe_ia
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mcopy
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|in_addr
name|isaddr
decl_stmt|,
name|itaddr
decl_stmt|,
name|myaddr
decl_stmt|;
name|int
name|proto
decl_stmt|,
name|op
decl_stmt|,
name|completed
init|=
literal|0
decl_stmt|,
name|sendtrailers
decl_stmt|;
if|if
condition|(
name|ac
operator|->
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_NOARP
condition|)
goto|goto
name|out
goto|;
name|ea
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_arp
operator|*
argument_list|)
expr_stmt|;
name|proto
operator|=
name|ntohs
argument_list|(
name|ea
operator|->
name|arp_pro
argument_list|)
expr_stmt|;
name|op
operator|=
name|ntohs
argument_list|(
name|ea
operator|->
name|arp_op
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_spa
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|isaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|isaddr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tpa
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|itaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|itaddr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ia
operator|=
name|in_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
if|if
condition|(
name|ia
operator|->
name|ia_ifp
operator|==
operator|&
name|ac
operator|->
name|ac_if
condition|)
block|{
name|maybe_ia
operator|=
name|ia
expr_stmt|;
if|if
condition|(
operator|(
name|itaddr
operator|.
name|s_addr
operator|==
name|ia
operator|->
name|ia_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
operator|||
operator|(
name|isaddr
operator|.
name|s_addr
operator|==
name|ia
operator|->
name|ia_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|maybe_ia
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|myaddr
operator|=
name|ia
condition|?
name|ia
operator|->
name|ia_addr
operator|.
name|sin_addr
else|:
name|maybe_ia
operator|->
name|ia_addr
operator|.
name|sin_addr
expr_stmt|;
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|ac
operator|->
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* it's from me, ignore it. */
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"arp: ether address is broadcast for IP address %x!\n"
argument_list|,
name|ntohl
argument_list|(
name|isaddr
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|isaddr
operator|.
name|s_addr
operator|==
name|myaddr
operator|.
name|s_addr
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"duplicate IP address %x!! sent from ethernet address: %s\n"
argument_list|,
name|ntohl
argument_list|(
name|isaddr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ether_sprintf
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|itaddr
operator|=
name|myaddr
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|ARPOP_REQUEST
condition|)
goto|goto
name|reply
goto|;
goto|goto
name|out
goto|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|la
operator|=
name|arplookup
argument_list|(
name|isaddr
operator|.
name|s_addr
argument_list|,
name|itaddr
operator|.
name|s_addr
operator|==
name|myaddr
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|&&
operator|(
name|rt
operator|=
name|la
operator|->
name|la_rt
operator|)
operator|&&
operator|(
name|sdl
operator|=
name|SDL
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|sdl
operator|->
name|sdl_alen
operator|&&
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|sdl
operator|->
name|sdl_alen
argument_list|)
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"arp info overwritten for %x by %s\n"
argument_list|,
name|isaddr
operator|.
name|s_addr
argument_list|,
name|ether_sprintf
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|completed
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|sdl
operator|->
name|sdl_alen
operator|=
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_expire
condition|)
name|rt
operator|->
name|rt_expire
operator|=
name|time
operator|.
name|tv_sec
operator|+
name|arpt_keep
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_REJECT
expr_stmt|;
name|la
operator|->
name|la_asked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|la_hold
condition|)
block|{
call|(
modifier|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
call|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|la
operator|->
name|la_hold
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|la
operator|->
name|la_hold
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|reply
label|:
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|ETHERTYPE_IPTRAILERS
case|:
comment|/* partner says trailers are OK */
if|if
condition|(
name|la
condition|)
name|la
operator|->
name|la_rt
operator|->
name|rt_flags
operator||=
name|RTF_USETRAILERS
expr_stmt|;
comment|/* 		 * Reply to request iff we want trailers. 		 */
if|if
condition|(
name|op
operator|!=
name|ARPOP_REQUEST
operator|||
name|ac
operator|->
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_NOTRAILERS
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|ETHERTYPE_IP
case|:
comment|/* 		 * Reply if this is an IP request, 		 * or if we want to send a trailer response. 		 * Send the latter only to the IP response 		 * that completes the current ARP entry. 		 */
if|if
condition|(
name|op
operator|!=
name|ARPOP_REQUEST
operator|&&
operator|(
name|completed
operator|==
literal|0
operator|||
name|ac
operator|->
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_NOTRAILERS
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|itaddr
operator|.
name|s_addr
operator|==
name|myaddr
operator|.
name|s_addr
condition|)
block|{
comment|/* I am the target */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tha
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ac
operator|->
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|sendtrailers
operator|=
operator|!
operator|(
name|ac
operator|->
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_NOTRAILERS
operator|)
expr_stmt|;
block|}
else|else
block|{
name|la
operator|=
name|arplookup
argument_list|(
name|itaddr
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|,
name|SIN_PROXY
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tha
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|sdl
operator|=
name|SDL
argument_list|(
name|la
operator|->
name|la_rt
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|sendtrailers
operator|=
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_USETRAILERS
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_spa
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tpa
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_spa
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|itaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_spa
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_spa
argument_list|)
argument_list|)
expr_stmt|;
name|ea
operator|->
name|arp_op
operator|=
name|htons
argument_list|(
name|ARPOP_REPLY
argument_list|)
expr_stmt|;
comment|/* 	 * If incoming packet was an IP reply, 	 * we are sending a reply for type IPTRAILERS. 	 * If we are sending a reply for type IP 	 * and we want to receive trailers, 	 * send a trailer reply as well. 	 */
if|if
condition|(
name|op
operator|==
name|ARPOP_REPLY
condition|)
name|ea
operator|->
name|arp_pro
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IPTRAILERS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|proto
operator|==
name|ETHERTYPE_IP
operator|&&
name|sendtrailers
condition|)
name|mcopy
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|sa
operator|.
name|sa_data
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tha
argument_list|,
operator|(
name|caddr_t
operator|)
name|eh
operator|->
name|ether_dhost
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|ETHERTYPE_ARP
expr_stmt|;
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|sa
operator|.
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
call|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|m
argument_list|,
operator|&
name|sa
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcopy
condition|)
block|{
name|ea
operator|=
name|mtod
argument_list|(
name|mcopy
argument_list|,
expr|struct
name|ether_arp
operator|*
argument_list|)
expr_stmt|;
name|ea
operator|->
name|arp_pro
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IPTRAILERS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
call|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|mcopy
argument_list|,
operator|&
name|sa
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
name|out
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Free an arp entry.  */
end_comment

begin_expr_stmt
name|arptfree
argument_list|(
name|la
argument_list|)
specifier|register
expr|struct
name|llinfo_arp
operator|*
name|la
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|la
operator|->
name|la_rt
decl_stmt|;
specifier|register
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"arptfree"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_refcnt
operator|>
literal|0
operator|&&
operator|(
name|sdl
operator|=
name|SDL
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|)
operator|)
operator|&&
name|sdl
operator|->
name|sdl_family
operator|==
name|AF_LINK
condition|)
block|{
name|sdl
operator|->
name|sdl_alen
operator|=
literal|0
expr_stmt|;
name|la
operator|->
name|la_asked
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_REJECT
expr_stmt|;
return|return;
block|}
name|rtrequest
argument_list|(
name|RTM_DELETE
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
name|rt_mask
argument_list|(
name|rt
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|arpdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Lookup or enter a new address in arptab.  */
end_comment

begin_function
name|struct
name|llinfo_arp
modifier|*
name|arplookup
parameter_list|(
name|addr
parameter_list|,
name|create
parameter_list|,
name|proxy
parameter_list|)
name|u_long
name|addr
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
specifier|static
name|struct
name|sockaddr_inarp
name|sin
init|=
block|{
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
block|,
name|AF_INET
block|}
decl_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
name|sin
operator|.
name|sin_other
operator|=
name|proxy
condition|?
name|SIN_PROXY
else|:
literal|0
expr_stmt|;
name|rt
operator|=
name|rtalloc1
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|||
operator|!
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
operator|)
operator|||
name|rt
operator|->
name|rt_gateway
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
block|{
name|arpcatchme
argument_list|()
expr_stmt|;
if|if
condition|(
name|arpdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"arptnew failed on %x\n"
argument_list|,
name|ntohl
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|(
expr|struct
name|llinfo_arp
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
operator|)
return|;
block|}
end_function

begin_macro
name|arpcatchme
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|arpioctl
argument_list|(
argument|cmd
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_block

end_unit

