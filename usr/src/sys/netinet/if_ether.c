begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)if_ether.c	7.9 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Ethernet address resolution protocol.  * TODO:  *	run at splnet (add ARP protocol intr.)  *	link entries onto hash chains, keep free list  *	add "inuse/lock" bit (or ref. count) along with valid bit  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"in.h"
end_include

begin_include
include|#
directive|include
file|"in_systm.h"
end_include

begin_include
include|#
directive|include
file|"ip.h"
end_include

begin_include
include|#
directive|include
file|"if_ether.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GATEWAY
end_ifdef

begin_define
define|#
directive|define
name|ARPTAB_BSIZ
value|16
end_define

begin_comment
comment|/* bucket size */
end_comment

begin_define
define|#
directive|define
name|ARPTAB_NB
value|37
end_define

begin_comment
comment|/* number of buckets */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ARPTAB_BSIZ
value|9
end_define

begin_comment
comment|/* bucket size */
end_comment

begin_define
define|#
directive|define
name|ARPTAB_NB
value|19
end_define

begin_comment
comment|/* number of buckets */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ARPTAB_SIZE
value|(ARPTAB_BSIZ * ARPTAB_NB)
end_define

begin_decl_stmt
name|struct
name|arptab
name|arptab
index|[
name|ARPTAB_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arptab_size
init|=
name|ARPTAB_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for arp command */
end_comment

begin_comment
comment|/*  * ARP trailer negotiation.  Trailer protocol is not IP specific,  * but ARP request/response use IP addresses.  */
end_comment

begin_define
define|#
directive|define
name|ETHERTYPE_IPTRAILERS
value|ETHERTYPE_TRAIL
end_define

begin_define
define|#
directive|define
name|ARPTAB_HASH
parameter_list|(
name|a
parameter_list|)
define|\
value|((u_long)(a) % ARPTAB_NB)
end_define

begin_define
define|#
directive|define
name|ARPTAB_LOOK
parameter_list|(
name|at
parameter_list|,
name|addr
parameter_list|)
value|{ \ 	register n; \ 	at =&arptab[ARPTAB_HASH(addr) * ARPTAB_BSIZ]; \ 	for (n = 0 ; n< ARPTAB_BSIZ ; n++,at++) \ 		if (at->at_iaddr.s_addr == addr) \ 			break; \ 	if (n>= ARPTAB_BSIZ) \ 		at = 0; \ }
end_define

begin_comment
comment|/* timer values */
end_comment

begin_define
define|#
directive|define
name|ARPT_AGE
value|(60*1)
end_define

begin_comment
comment|/* aging timer, 1 min. */
end_comment

begin_define
define|#
directive|define
name|ARPT_KILLC
value|20
end_define

begin_comment
comment|/* kill completed entry in 20 mins. */
end_comment

begin_define
define|#
directive|define
name|ARPT_KILLI
value|3
end_define

begin_comment
comment|/* kill incomplete entry in 3 minutes */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|ifnet
name|loif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Timeout routine.  Age arp_tab entries once a minute.  */
end_comment

begin_macro
name|arptimer
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|arptab
modifier|*
name|at
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|timeout
argument_list|(
name|arptimer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ARPT_AGE
operator|*
name|hz
argument_list|)
expr_stmt|;
name|at
operator|=
operator|&
name|arptab
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARPTAB_SIZE
condition|;
name|i
operator|++
operator|,
name|at
operator|++
control|)
block|{
if|if
condition|(
name|at
operator|->
name|at_flags
operator|==
literal|0
operator|||
operator|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_PERM
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|++
name|at
operator|->
name|at_timer
operator|<
operator|(
operator|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_COM
operator|)
condition|?
name|ARPT_KILLC
else|:
name|ARPT_KILLI
operator|)
condition|)
continue|continue;
comment|/* timer has expired, clear entry */
name|arptfree
argument_list|(
name|at
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Broadcast an ARP packet, asking who has addr on interface ac.  */
end_comment

begin_expr_stmt
name|arpwhohas
argument_list|(
name|ac
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|arpcom
operator|*
name|ac
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|in_addr
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
specifier|register
name|struct
name|ether_arp
modifier|*
name|ea
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ea
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ea
argument_list|)
expr_stmt|;
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ea
argument_list|)
argument_list|)
expr_stmt|;
name|ea
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_arp
operator|*
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|sa
operator|.
name|sa_data
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ea
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|etherbroadcastaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|eh
operator|->
name|ether_dhost
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|ETHERTYPE_ARP
expr_stmt|;
comment|/* if_output will swap */
name|ea
operator|->
name|arp_hrd
operator|=
name|htons
argument_list|(
name|ARPHRD_ETHER
argument_list|)
expr_stmt|;
name|ea
operator|->
name|arp_pro
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
name|ea
operator|->
name|arp_hln
operator|=
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
expr_stmt|;
comment|/* hardware address length */
name|ea
operator|->
name|arp_pln
operator|=
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_spa
argument_list|)
expr_stmt|;
comment|/* protocol address length */
name|ea
operator|->
name|arp_op
operator|=
name|htons
argument_list|(
name|ARPOP_REQUEST
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ac
operator|->
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ac
operator|->
name|ac_ipaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_spa
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_spa
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tpa
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_tpa
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|sa
operator|.
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
call|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|m
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|useloopback
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use loopback interface for local traffic */
end_comment

begin_decl_stmt
name|int
name|useloopback
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use loopback interface for local traffic */
end_comment

begin_comment
comment|/*  * Resolve an IP address into an ethernet address.  If success,   * desten is filled in.  If there is no entry in arptab,  * set one up and broadcast a request for the IP address.  * Hold onto this mbuf and resend it once the address  * is finally resolved.  A return value of 1 indicates  * that desten has been filled in and the packet should be sent  * normally; a 0 return indicates that the packet has been  * taken over here, either now or for later transmission.  *  * We do some (conservative) locking here at splimp, since  * arptab is also altered from input interrupt service (ecintr/ilintr  * calls arpinput when ETHERTYPE_ARP packets come in).  */
end_comment

begin_expr_stmt
name|arpresolve
argument_list|(
name|ac
argument_list|,
name|m
argument_list|,
name|destip
argument_list|,
name|desten
argument_list|,
name|usetrailers
argument_list|)
specifier|register
expr|struct
name|arpcom
operator|*
name|ac
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|in_addr
modifier|*
name|destip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|u_char
modifier|*
name|desten
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|usetrailers
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|arptab
modifier|*
name|at
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|u_long
name|lna
decl_stmt|;
name|int
name|s
decl_stmt|;
operator|*
name|usetrailers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_BCAST
condition|)
block|{
comment|/* broadcast */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|etherbroadcastaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|desten
argument_list|,
sizeof|sizeof
argument_list|(
name|etherbroadcastaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lna
operator|=
name|in_lnaof
argument_list|(
operator|*
name|destip
argument_list|)
expr_stmt|;
comment|/* if for us, use software loopback driver if up */
if|if
condition|(
name|destip
operator|->
name|s_addr
operator|==
name|ac
operator|->
name|ac_ipaddr
operator|.
name|s_addr
condition|)
block|{
comment|/* 		 * This test used to be 		 *	if (loif.if_flags& IFF_UP) 		 * It allowed local traffic to be forced 		 * through the hardware by configuring the loopback down. 		 * However, it causes problems during network configuration 		 * for boards that can't receive packets they send. 		 * It is now necessary to clear "useloopback" 		 * to force traffic out to the hardware. 		 */
if|if
condition|(
name|useloopback
condition|)
block|{
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
operator|*
name|destip
expr_stmt|;
operator|(
name|void
operator|)
name|looutput
argument_list|(
operator|&
name|loif
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|)
expr_stmt|;
comment|/* 			 * The packet has already been sent and freed. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ac
operator|->
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|desten
argument_list|,
sizeof|sizeof
argument_list|(
name|ac
operator|->
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ARPTAB_LOOK
argument_list|(
name|at
argument_list|,
name|destip
operator|->
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
literal|0
condition|)
block|{
comment|/* not found */
if|if
condition|(
name|ac
operator|->
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_NOARP
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ac
operator|->
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|desten
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|desten
index|[
literal|3
index|]
operator|=
operator|(
name|lna
operator|>>
literal|16
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|desten
index|[
literal|4
index|]
operator|=
operator|(
name|lna
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|desten
index|[
literal|5
index|]
operator|=
name|lna
operator|&
literal|0xff
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|at
operator|=
name|arptnew
argument_list|(
name|destip
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"arpresolve: no free entry"
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_hold
operator|=
name|m
expr_stmt|;
name|arpwhohas
argument_list|(
name|ac
argument_list|,
name|destip
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|at
operator|->
name|at_timer
operator|=
literal|0
expr_stmt|;
comment|/* restart the timer */
if|if
condition|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_COM
condition|)
block|{
comment|/* entry IS complete */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|at
operator|->
name|at_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|desten
argument_list|,
sizeof|sizeof
argument_list|(
name|at
operator|->
name|at_enaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_USETRAILERS
condition|)
operator|*
name|usetrailers
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * There is an arptab entry, but no ethernet address 	 * response yet.  Replace the held mbuf with this 	 * latest one. 	 */
if|if
condition|(
name|at
operator|->
name|at_hold
condition|)
name|m_freem
argument_list|(
name|at
operator|->
name|at_hold
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_hold
operator|=
name|m
expr_stmt|;
name|arpwhohas
argument_list|(
name|ac
argument_list|,
name|destip
argument_list|)
expr_stmt|;
comment|/* ask again */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Called from 10 Mb/s Ethernet interrupt handlers  * when ether packet type ETHERTYPE_ARP  * is received.  Common length and type checks are done here,  * then the protocol-specific routine is called.  */
end_comment

begin_macro
name|arpinput
argument_list|(
argument|ac
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|arpcom
modifier|*
name|ac
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|arphdr
modifier|*
name|ar
decl_stmt|;
if|if
condition|(
name|ac
operator|->
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_NOARP
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|arphdr
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|ar
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arphdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|ar
operator|->
name|ar_hrd
argument_list|)
operator|!=
name|ARPHRD_ETHER
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|arphdr
argument_list|)
operator|+
literal|2
operator|*
name|ar
operator|->
name|ar_hln
operator|+
literal|2
operator|*
name|ar
operator|->
name|ar_pln
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|ntohs
argument_list|(
name|ar
operator|->
name|ar_pro
argument_list|)
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
case|case
name|ETHERTYPE_IPTRAILERS
case|:
name|in_arpinput
argument_list|(
name|ac
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|out
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * ARP for Internet protocols on 10 Mb/s Ethernet.  * Algorithm is that given in RFC 826.  * In addition, a sanity check is performed on the sender  * protocol address, to catch impersonators.  * We also handle negotiations for use of trailer protocol:  * ARP replies for protocol type ETHERTYPE_TRAIL are sent  * along with IP replies if we want trailers sent to us,  * and also send them in response to IP replies.  * This allows either end to announce the desire to receive  * trailer packets.  * We reply to requests for ETHERTYPE_TRAIL protocol as well,  * but don't normally send requests.  */
end_comment

begin_expr_stmt
name|in_arpinput
argument_list|(
name|ac
argument_list|,
name|m
argument_list|)
specifier|register
expr|struct
name|arpcom
operator|*
name|ac
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ether_arp
modifier|*
name|ea
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
specifier|register
name|struct
name|arptab
modifier|*
name|at
decl_stmt|;
comment|/* same as "merge" flag */
name|struct
name|mbuf
modifier|*
name|mcopy
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|in_addr
name|isaddr
decl_stmt|,
name|itaddr
decl_stmt|,
name|myaddr
decl_stmt|;
name|int
name|proto
decl_stmt|,
name|op
decl_stmt|,
name|s
decl_stmt|,
name|completed
init|=
literal|0
decl_stmt|;
name|myaddr
operator|=
name|ac
operator|->
name|ac_ipaddr
expr_stmt|;
name|ea
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_arp
operator|*
argument_list|)
expr_stmt|;
name|proto
operator|=
name|ntohs
argument_list|(
name|ea
operator|->
name|arp_pro
argument_list|)
expr_stmt|;
name|op
operator|=
name|ntohs
argument_list|(
name|ea
operator|->
name|arp_op
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_spa
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|isaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|isaddr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tpa
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|itaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|itaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|ac
operator|->
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* it's from me, ignore it. */
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"arp: ether address is broadcast for IP address %x!\n"
argument_list|,
name|ntohl
argument_list|(
name|isaddr
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|isaddr
operator|.
name|s_addr
operator|==
name|myaddr
operator|.
name|s_addr
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"duplicate IP address %x!! sent from ethernet address: %s\n"
argument_list|,
name|ntohl
argument_list|(
name|isaddr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ether_sprintf
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|itaddr
operator|=
name|myaddr
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|ARPOP_REQUEST
condition|)
goto|goto
name|reply
goto|;
goto|goto
name|out
goto|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ARPTAB_LOOK
argument_list|(
name|at
argument_list|,
name|isaddr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|at
operator|->
name|at_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_COM
operator|)
operator|==
literal|0
condition|)
name|completed
operator|=
literal|1
expr_stmt|;
name|at
operator|->
name|at_flags
operator||=
name|ATF_COM
expr_stmt|;
if|if
condition|(
name|at
operator|->
name|at_hold
condition|)
block|{
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|isaddr
expr_stmt|;
call|(
modifier|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
call|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|at
operator|->
name|at_hold
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_hold
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|at
operator|==
literal|0
operator|&&
name|itaddr
operator|.
name|s_addr
operator|==
name|myaddr
operator|.
name|s_addr
condition|)
block|{
comment|/* ensure we have a table entry */
if|if
condition|(
name|at
operator|=
name|arptnew
argument_list|(
operator|&
name|isaddr
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|at
operator|->
name|at_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|completed
operator|=
literal|1
expr_stmt|;
name|at
operator|->
name|at_flags
operator||=
name|ATF_COM
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|reply
label|:
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|ETHERTYPE_IPTRAILERS
case|:
comment|/* partner says trailers are OK */
if|if
condition|(
name|at
condition|)
name|at
operator|->
name|at_flags
operator||=
name|ATF_USETRAILERS
expr_stmt|;
comment|/* 		 * Reply to request iff we want trailers. 		 */
if|if
condition|(
name|op
operator|!=
name|ARPOP_REQUEST
operator|||
name|ac
operator|->
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_NOTRAILERS
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|ETHERTYPE_IP
case|:
comment|/* 		 * Reply if this is an IP request, 		 * or if we want to send a trailer response. 		 * Send the latter only to the IP response 		 * that completes the current ARP entry. 		 */
if|if
condition|(
name|op
operator|!=
name|ARPOP_REQUEST
operator|&&
operator|(
name|completed
operator|==
literal|0
operator|||
name|ac
operator|->
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_NOTRAILERS
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|itaddr
operator|.
name|s_addr
operator|==
name|myaddr
operator|.
name|s_addr
condition|)
block|{
comment|/* I am the target */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tha
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ac
operator|->
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ARPTAB_LOOK
argument_list|(
name|at
argument_list|,
name|itaddr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
name|NULL
operator|||
operator|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_PUBL
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tha
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|at
operator|->
name|at_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_sha
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_sha
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_spa
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tpa
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_spa
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|itaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_spa
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
operator|->
name|arp_spa
argument_list|)
argument_list|)
expr_stmt|;
name|ea
operator|->
name|arp_op
operator|=
name|htons
argument_list|(
name|ARPOP_REPLY
argument_list|)
expr_stmt|;
comment|/* 	 * If incoming packet was an IP reply, 	 * we are sending a reply for type IPTRAILERS. 	 * If we are sending a reply for type IP 	 * and we want to receive trailers, 	 * send a trailer reply as well. 	 */
if|if
condition|(
name|op
operator|==
name|ARPOP_REPLY
condition|)
name|ea
operator|->
name|arp_pro
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IPTRAILERS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|proto
operator|==
name|ETHERTYPE_IP
operator|&&
operator|(
name|ac
operator|->
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_NOTRAILERS
operator|)
operator|==
literal|0
condition|)
name|mcopy
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|sa
operator|.
name|sa_data
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ea
operator|->
name|arp_tha
argument_list|,
operator|(
name|caddr_t
operator|)
name|eh
operator|->
name|ether_dhost
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|ETHERTYPE_ARP
expr_stmt|;
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|sa
operator|.
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
call|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|m
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcopy
condition|)
block|{
name|ea
operator|=
name|mtod
argument_list|(
name|mcopy
argument_list|,
expr|struct
name|ether_arp
operator|*
argument_list|)
expr_stmt|;
name|ea
operator|->
name|arp_pro
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IPTRAILERS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ac
operator|->
name|ac_if
operator|.
name|if_output
call|)
argument_list|(
operator|&
name|ac
operator|->
name|ac_if
argument_list|,
name|mcopy
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
block|}
return|return;
name|out
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Free an arptab entry.  */
end_comment

begin_expr_stmt
name|arptfree
argument_list|(
name|at
argument_list|)
specifier|register
expr|struct
name|arptab
operator|*
name|at
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|at
operator|->
name|at_hold
condition|)
name|m_freem
argument_list|(
name|at
operator|->
name|at_hold
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_hold
operator|=
literal|0
expr_stmt|;
name|at
operator|->
name|at_timer
operator|=
name|at
operator|->
name|at_flags
operator|=
literal|0
expr_stmt|;
name|at
operator|->
name|at_iaddr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Enter a new address in arptab, pushing out the oldest entry   * from the bucket if there is no room.  * This always succeeds since no bucket can be completely filled  * with permanent entries (except from arpioctl when testing whether  * another permanent entry will fit).  * MUST BE CALLED AT SPLIMP.  */
end_comment

begin_function
name|struct
name|arptab
modifier|*
name|arptnew
parameter_list|(
name|addr
parameter_list|)
name|struct
name|in_addr
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
name|n
expr_stmt|;
name|int
name|oldest
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|struct
name|arptab
modifier|*
name|at
decl_stmt|,
modifier|*
name|ato
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|timeout
argument_list|(
name|arptimer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|at
operator|=
operator|&
name|arptab
index|[
name|ARPTAB_HASH
argument_list|(
name|addr
operator|->
name|s_addr
argument_list|)
operator|*
name|ARPTAB_BSIZ
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ARPTAB_BSIZ
condition|;
name|n
operator|++
operator|,
name|at
operator|++
control|)
block|{
if|if
condition|(
name|at
operator|->
name|at_flags
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* found an empty entry */
if|if
condition|(
name|at
operator|->
name|at_flags
operator|&
name|ATF_PERM
condition|)
continue|continue;
if|if
condition|(
operator|(
name|int
operator|)
name|at
operator|->
name|at_timer
operator|>
name|oldest
condition|)
block|{
name|oldest
operator|=
name|at
operator|->
name|at_timer
expr_stmt|;
name|ato
operator|=
name|at
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ato
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|at
operator|=
name|ato
expr_stmt|;
name|arptfree
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|out
label|:
name|at
operator|->
name|at_iaddr
operator|=
operator|*
name|addr
expr_stmt|;
name|at
operator|->
name|at_flags
operator|=
name|ATF_INUSE
expr_stmt|;
return|return
operator|(
name|at
operator|)
return|;
block|}
end_function

begin_macro
name|arpioctl
argument_list|(
argument|cmd
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|arpreq
modifier|*
name|ar
init|=
operator|(
expr|struct
name|arpreq
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|struct
name|arptab
modifier|*
name|at
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ar
operator|->
name|arp_ha
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|&&
name|BYTE_ORDER
operator|!=
name|BIG_ENDIAN
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|==
literal|0
operator|&&
name|sin
operator|->
name|sin_len
operator|<
literal|16
condition|)
name|sin
operator|->
name|sin_family
operator|=
name|sin
operator|->
name|sin_len
expr_stmt|;
endif|#
directive|endif
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|arp_ha
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ar
operator|->
name|arp_pa
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|&&
name|BYTE_ORDER
operator|!=
name|BIG_ENDIAN
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|==
literal|0
operator|&&
name|sin
operator|->
name|sin_len
operator|<
literal|16
condition|)
name|sin
operator|->
name|sin_family
operator|=
name|sin
operator|->
name|sin_len
expr_stmt|;
endif|#
directive|endif
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|arp_pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|arp_pa
operator|.
name|sa_family
operator|!=
name|AF_INET
operator|||
name|ar
operator|->
name|arp_ha
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
condition|)
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ARPTAB_LOOK
argument_list|(
name|at
argument_list|,
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
name|NULL
condition|)
block|{
comment|/* not found */
if|if
condition|(
name|cmd
operator|!=
name|SIOCSARP
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|ifa_ifwithnet
argument_list|(
operator|&
name|ar
operator|->
name|arp_pa
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETUNREACH
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSARP
case|:
comment|/* set entry */
if|if
condition|(
name|at
operator|==
name|NULL
condition|)
block|{
name|at
operator|=
name|arptnew
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
if|if
condition|(
name|ar
operator|->
name|arp_flags
operator|&
name|ATF_PERM
condition|)
block|{
comment|/* never make all entries in a bucket permanent */
specifier|register
name|struct
name|arptab
modifier|*
name|tat
decl_stmt|;
comment|/* try to re-allocate */
name|tat
operator|=
name|arptnew
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tat
operator|==
name|NULL
condition|)
block|{
name|arptfree
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
name|arptfree
argument_list|(
name|tat
argument_list|)
expr_stmt|;
block|}
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ar
operator|->
name|arp_ha
operator|.
name|sa_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|at
operator|->
name|at_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|at
operator|->
name|at_enaddr
argument_list|)
argument_list|)
expr_stmt|;
name|at
operator|->
name|at_flags
operator|=
name|ATF_COM
operator||
name|ATF_INUSE
operator||
operator|(
name|ar
operator|->
name|arp_flags
operator|&
operator|(
name|ATF_PERM
operator||
name|ATF_PUBL
operator||
name|ATF_USETRAILERS
operator|)
operator|)
expr_stmt|;
name|at
operator|->
name|at_timer
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCDARP
case|:
comment|/* delete entry */
name|arptfree
argument_list|(
name|at
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGARP
case|:
comment|/* get entry */
case|case
name|OSIOCGARP
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|at
operator|->
name|at_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ar
operator|->
name|arp_ha
operator|.
name|sa_data
argument_list|,
sizeof|sizeof
argument_list|(
name|at
operator|->
name|at_enaddr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_43
if|if
condition|(
name|cmd
operator|==
name|OSIOCGARP
condition|)
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|ar
operator|->
name|arp_ha
operator|=
name|ar
operator|->
name|arp_ha
operator|.
name|sa_family
expr_stmt|;
endif|#
directive|endif
name|ar
operator|->
name|arp_flags
operator|=
name|at
operator|->
name|at_flags
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

