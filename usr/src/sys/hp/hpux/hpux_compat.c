begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: hpux_compat.c 1.33 89/08/23$  *  *	@(#)hpux_compat.c	7.3 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Various HPUX compatibility routines  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HPUXCOMPAT
end_ifdef

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"syscontext.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"ptrace.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"ipc.h"
end_include

begin_include
include|#
directive|include
file|"machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"machine/reg.h"
end_include

begin_include
include|#
directive|include
file|"machine/psl.h"
end_include

begin_include
include|#
directive|include
file|"machine/vmparam.h"
end_include

begin_include
include|#
directive|include
file|"hpux.h"
end_include

begin_include
include|#
directive|include
file|"hpux_termio.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|unimpresponse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* "tick" value for HZ==50 */
end_comment

begin_decl_stmt
name|int
name|hpuxtick
init|=
literal|1000000
operator|/
literal|50
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SYS5 style UTSNAME info */
end_comment

begin_decl_stmt
name|struct
name|hpuxutsname
name|protoutsname
init|=
block|{
literal|"4.4bsd"
block|,
literal|""
block|,
literal|"2.0"
block|,
literal|"B"
block|,
literal|"9000/3?0"
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6.0 and later style context */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FPCOPROC
end_ifdef

begin_decl_stmt
name|char
name|hpuxcontext
index|[]
init|=
literal|"standalone HP-MC68881 HP-MC68020 HP-MC68010 localroot default"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|hpuxcontext
index|[]
init|=
literal|"standalone HP-MC68020 HP-MC68010 localroot default"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YP domainname */
end_comment

begin_decl_stmt
name|char
name|domainname
index|[
name|MAXHOSTNAMELEN
index|]
init|=
literal|"unknown"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|domainnamelen
init|=
literal|7
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NERR
value|79
end_define

begin_define
define|#
directive|define
name|BERR
value|1000
end_define

begin_comment
comment|/* indexed by BSD errno */
end_comment

begin_decl_stmt
name|short
name|bsdtohpuxerrnomap
index|[
name|NERR
index|]
init|=
block|{
comment|/*00*/
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
comment|/*10*/
literal|10
block|,
literal|45
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
comment|/*20*/
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
comment|/*30*/
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|246
block|,
literal|245
block|,
literal|244
block|,
literal|216
block|,
literal|217
block|,
comment|/*40*/
literal|218
block|,
literal|219
block|,
literal|220
block|,
literal|221
block|,
literal|222
block|,
literal|223
block|,
literal|224
block|,
literal|225
block|,
literal|226
block|,
literal|227
block|,
comment|/*50*/
literal|228
block|,
literal|229
block|,
literal|230
block|,
literal|231
block|,
literal|232
block|,
literal|233
block|,
literal|234
block|,
literal|235
block|,
literal|236
block|,
literal|237
block|,
comment|/*60*/
literal|238
block|,
literal|239
block|,
literal|249
block|,
literal|248
block|,
literal|241
block|,
literal|242
block|,
literal|247
block|,
name|BERR
block|,
name|BERR
block|,
name|BERR
block|,
comment|/*70*/
literal|70
block|,
literal|71
block|,
name|BERR
block|,
name|BERR
block|,
name|BERR
block|,
name|BERR
block|,
name|BERR
block|,
literal|46
block|,
name|BERR
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|notimp
argument_list|(
argument|code
argument_list|,
argument|nargs
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|int
modifier|*
name|argp
init|=
name|u
operator|.
name|u_ap
decl_stmt|;
specifier|extern
name|char
modifier|*
name|hpuxsyscallnames
index|[]
decl_stmt|;
name|printf
argument_list|(
literal|"HPUX %s("
argument_list|,
name|hpuxsyscallnames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
condition|)
while|while
condition|(
name|nargs
operator|--
condition|)
name|printf
argument_list|(
literal|"%x%c"
argument_list|,
operator|*
name|argp
operator|++
argument_list|,
name|nargs
condition|?
literal|','
else|:
literal|')'
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|unimpresponse
condition|)
block|{
case|case
literal|0
case|:
name|nosys
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|nosys
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|uprintf
argument_list|(
literal|"HPUX system call %d not implemented\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * HPUX versions of wait and wait3 actually pass the parameters  * (status pointer, options, rusage) into the kernel rather than  * handling it in the C library stub.  We also need to map any  * termination signal from BSD to HPUX.  */
end_comment

begin_macro
name|hpuxwait3
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|options
decl_stmt|;
name|int
name|rusage
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
comment|/* rusage pointer must be zero */
if|if
condition|(
name|uap
operator|->
name|rusage
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|u
operator|.
name|u_ar0
index|[
name|PS
index|]
operator|=
name|PSL_ALLCC
expr_stmt|;
name|u
operator|.
name|u_ar0
index|[
name|R0
index|]
operator|=
name|uap
operator|->
name|options
expr_stmt|;
name|u
operator|.
name|u_ar0
index|[
name|R1
index|]
operator|=
name|uap
operator|->
name|rusage
expr_stmt|;
name|hpuxwait
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|hpuxwait
argument_list|()
end_macro

begin_block
block|{
name|int
name|sig
decl_stmt|,
modifier|*
name|statp
decl_stmt|;
struct|struct
name|a
block|{
name|int
modifier|*
name|status
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|statp
operator|=
name|uap
operator|->
name|status
expr_stmt|;
comment|/* owait clobbers first arg */
name|owait
argument_list|()
expr_stmt|;
comment|/* 	 * HP-UX wait always returns EINTR when interrupted by a signal 	 * (well, unless its emulating a BSD process, but we don't bother...) 	 */
if|if
condition|(
name|u
operator|.
name|u_eosys
operator|==
name|RESTARTSYS
condition|)
block|{
name|u
operator|.
name|u_eosys
operator|=
name|NORMALRETURN
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|EINTR
expr_stmt|;
block|}
if|if
condition|(
name|u
operator|.
name|u_error
condition|)
return|return;
name|sig
operator|=
name|u
operator|.
name|u_r
operator|.
name|r_val2
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|WSTOPPED
condition|)
block|{
name|sig
operator|=
operator|(
name|u
operator|.
name|u_r
operator|.
name|r_val2
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|r_val2
operator|=
operator|(
name|bsdtohpuxsig
argument_list|(
name|sig
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|WSTOPPED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sig
condition|)
name|u
operator|.
name|u_r
operator|.
name|r_val2
operator|=
operator|(
name|u
operator|.
name|u_r
operator|.
name|r_val2
operator|&
literal|0xFF00
operator|)
operator||
name|bsdtohpuxsig
argument_list|(
name|sig
operator|&
literal|0x7F
argument_list|)
operator||
operator|(
name|sig
operator|&
literal|0x80
operator|)
expr_stmt|;
if|if
condition|(
name|statp
condition|)
if|if
condition|(
name|suword
argument_list|(
operator|(
name|caddr_t
operator|)
name|statp
argument_list|,
name|u
operator|.
name|u_r
operator|.
name|r_val2
argument_list|)
condition|)
name|u
operator|.
name|u_error
operator|=
name|EFAULT
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Must remap some bits in the mode mask.  * O_CREAT, O_TRUNC, and O_EXCL must be remapped,  * O_SYNCIO (0100000) is removed entirely.  */
end_comment

begin_expr_stmt
name|hpuxopen
argument_list|(
name|scp
argument_list|)
specifier|register
expr|struct
name|syscontext
operator|*
name|scp
expr_stmt|;
end_expr_stmt

begin_block
block|{
struct|struct
name|a
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|crtmode
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|scp
operator|->
name|sc_ap
struct|;
name|struct
name|nameidata
modifier|*
name|ndp
init|=
operator|&
name|scp
operator|->
name|sc_nd
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|mode
operator|=
name|uap
operator|->
name|mode
expr_stmt|;
name|uap
operator|->
name|mode
operator|&=
operator|~
operator|(
name|HPUXFSYNCIO
operator||
name|HPUXFEXCL
operator||
name|HPUXFTRUNC
operator||
name|HPUXFCREAT
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|HPUXFCREAT
condition|)
block|{
comment|/* 		 * simulate the pre-NFS behavior that opening a 		 * file for READ+CREATE ignores the CREATE (unless 		 * EXCL is set in which case we will return the 		 * proper error). 		 */
if|if
condition|(
operator|(
name|mode
operator|&
name|HPUXFEXCL
operator|)
operator|||
operator|(
operator|(
name|mode
operator|-
name|FOPEN
operator|)
operator|&
name|FWRITE
operator|)
condition|)
name|uap
operator|->
name|mode
operator||=
name|FCREAT
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|HPUXFTRUNC
condition|)
name|uap
operator|->
name|mode
operator||=
name|FTRUNC
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|HPUXFEXCL
condition|)
name|uap
operator|->
name|mode
operator||=
name|FEXCL
expr_stmt|;
name|ndp
operator|->
name|ni_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|ndp
operator|->
name|ni_dirp
operator|=
name|uap
operator|->
name|fname
expr_stmt|;
name|RETURN
argument_list|(
name|copen
argument_list|(
name|scp
argument_list|,
name|uap
operator|->
name|mode
operator|-
name|FOPEN
argument_list|,
name|uap
operator|->
name|crtmode
operator|&
operator|~
name|scp
operator|->
name|sc_cmask
argument_list|,
name|ndp
argument_list|,
operator|&
name|scp
operator|->
name|sc_retval1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hpuxfcntl
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|int
name|fdes
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|arg
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|int
name|mode
decl_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|F_SETFL
case|:
name|uap
operator|->
name|arg
operator|&=
operator|~
operator|(
name|HPUXFSYNCIO
operator||
name|HPUXFREMOTE
operator||
name|FUSECACHE
operator|)
expr_stmt|;
break|break;
case|case
name|F_GETFL
case|:
case|case
name|F_DUPFD
case|:
case|case
name|F_GETFD
case|:
case|case
name|F_SETFD
case|:
break|break;
default|default:
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|fcntl
argument_list|()
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
operator|==
literal|0
operator|&&
name|uap
operator|->
name|arg
operator|==
name|F_GETFL
condition|)
block|{
name|mode
operator|=
name|u
operator|.
name|u_r
operator|.
name|r_val1
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|&=
operator|~
operator|(
name|FCREAT
operator||
name|FTRUNC
operator||
name|FEXCL
operator||
name|FUSECACHE
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|FCREAT
condition|)
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator||=
name|HPUXFCREAT
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|FTRUNC
condition|)
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator||=
name|HPUXFTRUNC
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|FEXCL
condition|)
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator||=
name|HPUXFEXCL
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Read and write should return a 0 count when an operation  * on a VNODE would block, not an error.  Sockets appear to  * return EWOULDBLOCK (at least in 6.2).  This is probably  * not entirely correct, since the behavior is only defined  * for pipes and tty type devices.  */
end_comment

begin_macro
name|hpuxread
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|int
name|fd
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
operator|==
name|EWOULDBLOCK
operator|&&
name|u
operator|.
name|u_ofile
index|[
name|uap
operator|->
name|fd
index|]
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|hpuxwrite
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|int
name|fd
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|write
argument_list|()
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
operator|==
name|EWOULDBLOCK
operator|&&
name|u
operator|.
name|u_ofile
index|[
name|uap
operator|->
name|fd
index|]
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|hpuxreadv
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|int
name|fd
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|readv
argument_list|()
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
operator|==
name|EWOULDBLOCK
operator|&&
name|u
operator|.
name|u_ofile
index|[
name|uap
operator|->
name|fd
index|]
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|hpuxwritev
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|int
name|fd
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|writev
argument_list|()
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
operator|==
name|EWOULDBLOCK
operator|&&
name|u
operator|.
name|u_ofile
index|[
name|uap
operator|->
name|fd
index|]
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * 4.3bsd dup allows dup2 to come in on the same syscall entry  * and hence allows two arguments.  HPUX dup has only one arg.  */
end_comment

begin_macro
name|hpuxdup
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|int
name|i
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|i
operator|>=
name|NOFILE
operator|||
operator|(
name|fp
operator|=
name|u
operator|.
name|u_ofile
index|[
name|uap
operator|->
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EBADF
expr_stmt|;
return|return;
block|}
name|u
operator|.
name|u_error
operator|=
name|ufalloc
argument_list|(
literal|0
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
condition|)
return|return;
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
name|j
expr_stmt|;
name|dupit
argument_list|(
name|j
argument_list|,
name|fp
argument_list|,
name|u
operator|.
name|u_pofile
index|[
name|uap
operator|->
name|i
index|]
operator|&
operator|~
name|UF_EXCLOSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hpuxuname
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|struct
name|hpuxutsname
modifier|*
name|uts
decl_stmt|;
name|int
name|dev
decl_stmt|;
name|int
name|request
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
specifier|register
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|request
condition|)
block|{
comment|/* uname */
case|case
literal|0
case|:
comment|/* fill in machine type */
switch|switch
condition|(
name|machineid
condition|)
block|{
case|case
name|HP_320
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'2'
expr_stmt|;
break|break;
comment|/* includes 318 and 319 */
case|case
name|HP_330
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'3'
expr_stmt|;
break|break;
case|case
name|HP_340
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'4'
expr_stmt|;
break|break;
case|case
name|HP_350
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'5'
expr_stmt|;
break|break;
case|case
name|HP_360
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'6'
expr_stmt|;
break|break;
case|case
name|HP_370
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'7'
expr_stmt|;
break|break;
block|}
comment|/* copy hostname (sans domain) to nodename */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
operator|&&
name|hostname
index|[
name|i
index|]
operator|!=
literal|'.'
condition|;
name|i
operator|++
control|)
name|protoutsname
operator|.
name|nodename
index|[
name|i
index|]
operator|=
name|hostname
index|[
name|i
index|]
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|protoutsname
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|uts
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpuxutsname
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* ustat - who cares? */
case|case
literal|2
case|:
default|default:
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|hpuxstat
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|hpuxstat
modifier|*
name|hsb
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|u
operator|.
name|u_error
operator|=
name|hpuxstat1
argument_list|(
name|uap
operator|->
name|fname
argument_list|,
name|uap
operator|->
name|hsb
argument_list|,
name|FOLLOW
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hpuxlstat
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|hpuxstat
modifier|*
name|hsb
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|u
operator|.
name|u_error
operator|=
name|hpuxstat1
argument_list|(
name|uap
operator|->
name|fname
argument_list|,
name|uap
operator|->
name|hsb
argument_list|,
name|NOFOLLOW
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hpuxfstat
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
specifier|register
struct|struct
name|a
block|{
name|int
name|fdes
decl_stmt|;
name|struct
name|hpuxstat
modifier|*
name|hsb
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|fdes
operator|>=
name|NOFILE
operator|||
operator|(
name|fp
operator|=
name|u
operator|.
name|u_ofile
index|[
name|uap
operator|->
name|fdes
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EBADF
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|fp
operator|->
name|f_type
condition|)
block|{
case|case
name|DTYPE_VNODE
case|:
name|u
operator|.
name|u_error
operator|=
name|vn_stat
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTYPE_SOCKET
case|:
name|u
operator|.
name|u_error
operator|=
name|soo_stat
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
name|fp
operator|->
name|f_data
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"fstat"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* is this right for sockets?? */
if|if
condition|(
name|u
operator|.
name|u_error
operator|==
literal|0
condition|)
name|u
operator|.
name|u_error
operator|=
name|bsdtohpuxstat
argument_list|(
operator|&
name|sb
argument_list|,
name|uap
operator|->
name|hsb
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hpuxulimit
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|int
name|cmd
decl_stmt|;
name|long
name|newlimit
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|struct
name|rlimit
modifier|*
name|limp
decl_stmt|;
name|limp
operator|=
operator|&
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_FSIZE
index|]
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
literal|2
case|:
name|uap
operator|->
name|newlimit
operator|*=
literal|512
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|newlimit
operator|>
name|limp
operator|->
name|rlim_max
operator|&&
operator|(
name|u
operator|.
name|u_error
operator|=
name|suser
argument_list|(
name|u
operator|.
name|u_cred
argument_list|,
operator|&
name|u
operator|.
name|u_acflag
argument_list|)
operator|)
condition|)
break|break;
name|limp
operator|->
name|rlim_cur
operator|=
name|limp
operator|->
name|rlim_max
operator|=
name|uap
operator|->
name|newlimit
expr_stmt|;
comment|/* else fall into... */
case|case
literal|1
case|:
name|u
operator|.
name|u_r
operator|.
name|r_off
operator|=
name|limp
operator|->
name|rlim_max
operator|/
literal|512
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|limp
operator|=
operator|&
name|u
operator|.
name|u_rlimit
index|[
name|RLIMIT_DATA
index|]
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|r_off
operator|=
name|ctob
argument_list|(
name|u
operator|.
name|u_tsize
argument_list|)
operator|+
name|limp
operator|->
name|rlim_max
expr_stmt|;
break|break;
default|default:
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * Map "real time" priorities 0 (high) thru 127 (low) into nice  * values -16 (high) thru -1 (low).  */
end_comment

begin_macro
name|hpuxrtprio
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|int
name|pid
decl_stmt|;
name|int
name|prio
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|nice
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|prio
operator|<
name|RTPRIO_MIN
operator|&&
name|uap
operator|->
name|prio
operator|>
name|RTPRIO_MAX
operator|&&
name|uap
operator|->
name|prio
operator|!=
name|RTPRIO_NOCHG
operator|&&
name|uap
operator|->
name|prio
operator|!=
name|RTPRIO_RTOFF
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
name|p
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ESRCH
expr_stmt|;
return|return;
block|}
name|nice
operator|=
name|p
operator|->
name|p_nice
expr_stmt|;
if|if
condition|(
name|nice
operator|<
name|NZERO
condition|)
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
operator|(
name|nice
operator|+
literal|16
operator|)
operator|<<
literal|3
expr_stmt|;
else|else
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
name|RTPRIO_RTOFF
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|prio
condition|)
block|{
case|case
name|RTPRIO_NOCHG
case|:
return|return;
case|case
name|RTPRIO_RTOFF
case|:
if|if
condition|(
name|nice
operator|>=
name|NZERO
condition|)
return|return;
name|nice
operator|=
name|NZERO
expr_stmt|;
break|break;
default|default:
name|nice
operator|=
operator|(
name|uap
operator|->
name|prio
operator|>>
literal|3
operator|)
operator|-
literal|16
expr_stmt|;
break|break;
block|}
name|donice
argument_list|(
name|p
argument_list|,
name|nice
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
operator|==
name|EACCES
condition|)
name|u
operator|.
name|u_error
operator|=
name|EPERM
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Kudos to HP folks for using such mnemonic names so I could figure  * out what this guy does.  */
end_comment

begin_macro
name|hpuxadvise
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|int
name|arg
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
switch|switch
condition|(
name|uap
operator|->
name|arg
condition|)
block|{
case|case
literal|0
case|:
name|u
operator|.
name|u_pcb
operator|.
name|pcb_flags
operator||=
name|PCB_HPUXMMAP
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ICIA
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|DCIA
argument_list|()
expr_stmt|;
break|break;
default|default:
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|hpuxptrace
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|int
name|req
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|addr
decl_stmt|;
name|int
name|data
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
if|if
condition|(
name|uap
operator|->
name|req
operator|==
name|PT_STEP
operator|||
name|uap
operator|->
name|req
operator|==
name|PT_CONTINUE
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|data
condition|)
block|{
name|uap
operator|->
name|data
operator|=
name|hpuxtobsdsig
argument_list|(
name|uap
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|data
operator|==
literal|0
condition|)
name|uap
operator|->
name|data
operator|=
name|NSIG
expr_stmt|;
block|}
block|}
name|ptrace
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|hpuxgetdomainname
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|char
modifier|*
name|domainname
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
if|if
condition|(
name|uap
operator|->
name|len
operator|>
name|domainnamelen
operator|+
literal|1
condition|)
name|uap
operator|->
name|len
operator|=
name|domainnamelen
operator|+
literal|1
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|copyout
argument_list|(
name|domainname
argument_list|,
name|uap
operator|->
name|domainname
argument_list|,
name|uap
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hpuxsetdomainname
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|char
modifier|*
name|domainname
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
if|if
condition|(
name|u
operator|.
name|u_error
operator|=
name|suser
argument_list|(
name|u
operator|.
name|u_cred
argument_list|,
operator|&
name|u
operator|.
name|u_acflag
argument_list|)
condition|)
return|return;
if|if
condition|(
name|uap
operator|->
name|len
operator|>
sizeof|sizeof
argument_list|(
name|domainname
argument_list|)
operator|-
literal|1
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|domainnamelen
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|domainname
argument_list|,
name|domainname
argument_list|,
name|uap
operator|->
name|len
argument_list|)
expr_stmt|;
name|domainname
index|[
name|domainnamelen
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVSHM
end_ifdef

begin_macro
name|hpuxshmat
argument_list|()
end_macro

begin_block
block|{
name|shmat
argument_list|(
name|u
operator|.
name|u_ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hpuxshmctl
argument_list|()
end_macro

begin_block
block|{
name|shmctl
argument_list|(
name|u
operator|.
name|u_ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hpuxshmdt
argument_list|()
end_macro

begin_block
block|{
name|shmdt
argument_list|(
name|u
operator|.
name|u_ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hpuxshmget
argument_list|()
end_macro

begin_block
block|{
name|shmget
argument_list|(
name|u
operator|.
name|u_ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Fake semaphore routines, just don't return an error.  * Should be adequate for starbase to run.  */
end_comment

begin_macro
name|hpuxsemctl
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|int
name|semid
decl_stmt|;
name|u_int
name|semnum
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|arg
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
comment|/* XXX: should do something here */
block|}
end_block

begin_macro
name|hpuxsemget
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|key_t
name|key
decl_stmt|;
name|int
name|nsems
decl_stmt|;
name|int
name|semflg
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
comment|/* XXX: should do something here */
block|}
end_block

begin_macro
name|hpuxsemop
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|int
name|semid
decl_stmt|;
name|struct
name|sembuf
modifier|*
name|sops
decl_stmt|;
name|u_int
name|nsops
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
comment|/* XXX: should do something here */
block|}
end_block

begin_comment
comment|/* convert from BSD to HPUX errno */
end_comment

begin_macro
name|bsdtohpuxerrno
argument_list|(
argument|err
argument_list|)
end_macro

begin_decl_stmt
name|int
name|err
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|err
operator|<
literal|0
operator|||
name|err
operator|>=
name|NERR
condition|)
return|return
operator|(
name|BERR
operator|)
return|;
return|return
operator|(
operator|(
name|int
operator|)
name|bsdtohpuxerrnomap
index|[
name|err
index|]
operator|)
return|;
block|}
end_block

begin_macro
name|hpuxstat1
argument_list|(
argument|fname
argument_list|,
argument|hsb
argument_list|,
argument|follow
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxstat
modifier|*
name|hsb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|follow
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nameidata
modifier|*
name|ndp
init|=
operator|&
name|u
operator|.
name|u_nd
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ndp
operator|->
name|ni_nameiop
operator|=
name|LOOKUP
operator||
name|LOCKLEAF
operator||
name|follow
expr_stmt|;
name|ndp
operator|->
name|ni_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|ndp
operator|->
name|ni_dirp
operator|=
name|fname
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|namei
argument_list|(
name|ndp
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|vn_stat
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|bsdtohpuxstat
argument_list|(
operator|&
name|sb
argument_list|,
name|hsb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_include
include|#
directive|include
file|"grf.h"
end_include

begin_macro
name|bsdtohpuxstat
argument_list|(
argument|sb
argument_list|,
argument|hsb
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|stat
modifier|*
name|sb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxstat
modifier|*
name|hsb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|hpuxstat
name|ds
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|.
name|hst_dev
operator|=
name|sb
operator|->
name|st_dev
expr_stmt|;
name|ds
operator|.
name|hst_ino
operator|=
operator|(
name|u_long
operator|)
name|sb
operator|->
name|st_ino
expr_stmt|;
name|ds
operator|.
name|hst_mode
operator|=
name|sb
operator|->
name|st_mode
expr_stmt|;
name|ds
operator|.
name|hst_nlink
operator|=
name|sb
operator|->
name|st_nlink
expr_stmt|;
name|ds
operator|.
name|hst_uid
operator|=
operator|(
name|u_short
operator|)
name|sb
operator|->
name|st_uid
expr_stmt|;
name|ds
operator|.
name|hst_gid
operator|=
operator|(
name|u_short
operator|)
name|sb
operator|->
name|st_gid
expr_stmt|;
if|#
directive|if
name|NGRF
operator|>
literal|0
comment|/* XXX: I don't want to talk about it... */
if|if
condition|(
operator|(
name|sb
operator|->
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
operator|&&
name|major
argument_list|(
name|sb
operator|->
name|st_rdev
argument_list|)
operator|==
literal|10
condition|)
name|ds
operator|.
name|hst_rdev
operator|=
name|grfdevno
argument_list|(
name|sb
operator|->
name|st_rdev
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ds
operator|.
name|hst_rdev
operator|=
name|bsdtohpuxdev
argument_list|(
name|sb
operator|->
name|st_rdev
argument_list|)
expr_stmt|;
name|ds
operator|.
name|hst_size
operator|=
name|sb
operator|->
name|st_size
expr_stmt|;
name|ds
operator|.
name|hst_atime
operator|=
name|sb
operator|->
name|st_atime
expr_stmt|;
name|ds
operator|.
name|hst_mtime
operator|=
name|sb
operator|->
name|st_mtime
expr_stmt|;
name|ds
operator|.
name|hst_ctime
operator|=
name|sb
operator|->
name|st_ctime
expr_stmt|;
name|ds
operator|.
name|hst_blksize
operator|=
name|sb
operator|->
name|st_blksize
expr_stmt|;
name|ds
operator|.
name|hst_blocks
operator|=
name|sb
operator|->
name|st_blocks
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ds
argument_list|,
operator|(
name|caddr_t
operator|)
name|hsb
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|hpuxtobsdioctl
argument_list|(
argument|com
argument_list|)
end_macro

begin_decl_stmt
name|int
name|com
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|com
condition|)
block|{
case|case
name|HPUXTIOCSLTC
case|:
name|com
operator|=
name|TIOCSLTC
expr_stmt|;
break|break;
case|case
name|HPUXTIOCGLTC
case|:
name|com
operator|=
name|TIOCGLTC
expr_stmt|;
break|break;
case|case
name|HPUXTIOCSPGRP
case|:
name|com
operator|=
name|TIOCSPGRP
expr_stmt|;
break|break;
case|case
name|HPUXTIOCGPGRP
case|:
name|com
operator|=
name|TIOCGPGRP
expr_stmt|;
break|break;
case|case
name|HPUXTIOCLBIS
case|:
name|com
operator|=
name|TIOCLBIS
expr_stmt|;
break|break;
case|case
name|HPUXTIOCLBIC
case|:
name|com
operator|=
name|TIOCLBIC
expr_stmt|;
break|break;
case|case
name|HPUXTIOCLSET
case|:
name|com
operator|=
name|TIOCLSET
expr_stmt|;
break|break;
case|case
name|HPUXTIOCLGET
case|:
name|com
operator|=
name|TIOCLGET
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|com
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * HPUX ioctl system call.  The differences here are:  *	IOC_IN also means IOC_VOID if the size portion is zero.  *	no FIOCLEX/FIONCLEX/FIONBIO/FIOASYNC/FIOGETOWN/FIOSETOWN  *	the sgttyb struct is 2 bytes longer  */
end_comment

begin_macro
name|hpuxioctl
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
struct|struct
name|a
block|{
name|int
name|fdes
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|cmarg
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
specifier|register
name|int
name|com
decl_stmt|;
specifier|register
name|u_int
name|size
decl_stmt|;
name|caddr_t
name|memp
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|STK_PARAMS
value|128
name|char
name|stkbuf
index|[
name|STK_PARAMS
index|]
decl_stmt|;
name|caddr_t
name|data
init|=
name|stkbuf
decl_stmt|;
name|com
operator|=
name|uap
operator|->
name|cmd
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|com
operator|==
name|HPUXTIOCGETP
operator|||
name|com
operator|==
name|HPUXTIOCSETP
condition|)
block|{
name|getsettty
argument_list|(
name|uap
operator|->
name|fdes
argument_list|,
name|com
argument_list|,
name|uap
operator|->
name|cmarg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|fdes
operator|>=
name|NOFILE
operator|||
operator|(
name|fp
operator|=
name|u
operator|.
name|u_ofile
index|[
name|uap
operator|->
name|fdes
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EBADF
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EBADF
expr_stmt|;
return|return;
block|}
comment|/* 	 * Interpret high order word to find 	 * amount of data to be copied to/from the 	 * user's address space. 	 */
name|size
operator|=
name|IOCPARM_LEN
argument_list|(
name|com
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|IOCPARM_MAX
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
name|stkbuf
argument_list|)
condition|)
block|{
name|memp
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
operator|(
name|u_long
operator|)
name|IOCPARM_MAX
argument_list|,
name|M_IOCTLOPS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|data
operator|=
name|memp
expr_stmt|;
block|}
if|if
condition|(
name|com
operator|&
name|IOC_IN
condition|)
block|{
if|if
condition|(
name|size
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|cmarg
argument_list|,
name|data
argument_list|,
operator|(
name|u_int
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
condition|)
block|{
if|if
condition|(
name|memp
condition|)
name|free
argument_list|(
name|memp
argument_list|,
name|M_IOCTLOPS
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|data
operator|=
name|uap
operator|->
name|cmarg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|com
operator|&
name|IOC_OUT
operator|)
operator|&&
name|size
condition|)
comment|/* 		 * Zero the buffer on the stack so the user 		 * always gets back something deterministic. 		 */
name|bzero
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|com
operator|&
name|IOC_VOID
condition|)
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|data
operator|=
name|uap
operator|->
name|cmarg
expr_stmt|;
switch|switch
condition|(
name|com
condition|)
block|{
case|case
name|HPUXTIOCCONS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|1
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_ops
operator|->
name|fo_ioctl
call|)
argument_list|(
name|fp
argument_list|,
name|TIOCCONS
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
comment|/* BSD-style job control ioctls */
case|case
name|HPUXTIOCLBIS
case|:
case|case
name|HPUXTIOCLBIC
case|:
case|case
name|HPUXTIOCLSET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&=
name|HPUXLTOSTOP
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|HPUXLTOSTOP
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|LTOSTOP
expr_stmt|;
comment|/* fall into */
case|case
name|HPUXTIOCLGET
case|:
case|case
name|HPUXTIOCSLTC
case|:
case|case
name|HPUXTIOCGLTC
case|:
case|case
name|HPUXTIOCSPGRP
case|:
case|case
name|HPUXTIOCGPGRP
case|:
name|u
operator|.
name|u_error
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_ops
operator|->
name|fo_ioctl
call|)
argument_list|(
name|fp
argument_list|,
name|hpuxtobsdioctl
argument_list|(
name|com
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
operator|==
literal|0
operator|&&
name|com
operator|==
name|HPUXTIOCLGET
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&=
name|LTOSTOP
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|LTOSTOP
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|HPUXLTOSTOP
expr_stmt|;
block|}
break|break;
comment|/* SYS 5 termio */
case|case
name|HPUXTCGETA
case|:
case|case
name|HPUXTCSETA
case|:
case|case
name|HPUXTCSETAW
case|:
case|case
name|HPUXTCSETAF
case|:
name|u
operator|.
name|u_error
operator|=
name|hpuxtermio
argument_list|(
name|fp
argument_list|,
name|com
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|u
operator|.
name|u_error
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_ops
operator|->
name|fo_ioctl
call|)
argument_list|(
name|fp
argument_list|,
name|com
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Copy any data to user, size was 	 * already set and checked above. 	 */
if|if
condition|(
name|u
operator|.
name|u_error
operator|==
literal|0
operator|&&
operator|(
name|com
operator|&
name|IOC_OUT
operator|)
operator|&&
name|size
condition|)
name|u
operator|.
name|u_error
operator|=
name|copyout
argument_list|(
name|data
argument_list|,
name|uap
operator|->
name|cmarg
argument_list|,
operator|(
name|u_int
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|memp
condition|)
name|free
argument_list|(
name|memp
argument_list|,
name|M_IOCTLOPS
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Man page lies, behaviour here is based on observed behaviour.  */
end_comment

begin_macro
name|hpuxgetcontext
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|uap
operator|->
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|hpuxcontext
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|hpuxcontext
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
operator|(
name|u_int
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
sizeof|sizeof
argument_list|(
name|hpuxcontext
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * XXX: simple recognition hack to see if we can make grmd work.  */
end_comment

begin_macro
name|hpuxlockf
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|int
name|fd
decl_stmt|;
name|int
name|func
decl_stmt|;
name|long
name|size
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
ifdef|#
directive|ifdef
name|DEBUG
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%d: lockf(%d, %d, %d)\n"
argument_list|,
name|u
operator|.
name|u_procp
operator|->
name|p_pid
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
name|uap
operator|->
name|func
argument_list|,
name|uap
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * This is the equivalent of BSD getpgrp but with more restrictions.  * Note we do not check the real uid or "saved" uid.  */
end_comment

begin_macro
name|hpuxgetpgrp2
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
struct|struct
name|a
block|{
name|int
name|pid
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
name|uap
operator|->
name|pid
operator|=
name|u
operator|.
name|u_procp
operator|->
name|p_pid
expr_stmt|;
name|p
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ESRCH
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|u
operator|.
name|u_uid
operator|&&
name|p
operator|->
name|p_uid
operator|!=
name|u
operator|.
name|u_uid
operator|&&
operator|!
name|inferior
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EPERM
expr_stmt|;
return|return;
block|}
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
name|p
operator|->
name|p_pgid
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This is the equivalent of BSD setpgrp but with more restrictions.  * Note we do not check the real uid or "saved" uid or pgrp.  */
end_comment

begin_macro
name|hpuxsetpgrp2
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|a
block|{
name|int
name|pid
decl_stmt|;
name|int
name|pgrp
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
comment|/* empirically determined */
if|if
condition|(
name|uap
operator|->
name|pgrp
operator|<
literal|0
operator|||
name|uap
operator|->
name|pgrp
operator|>=
literal|30000
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|setpgrp
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Brutal hack!  Map HPUX u-area offsets into BSD u offsets.  * No apologies offered, if you don't like it, rewrite it!  */
end_comment

begin_define
define|#
directive|define
name|UOFF
parameter_list|(
name|f
parameter_list|)
value|((int)&((struct user *)0)->f)
end_define

begin_define
define|#
directive|define
name|HPUOFF
parameter_list|(
name|f
parameter_list|)
value|((int)&((struct hpuxuser *)0)->f)
end_define

begin_comment
comment|/* simplified FP structure */
end_comment

begin_struct
struct|struct
name|bsdfp
block|{
name|int
name|save
index|[
literal|54
index|]
decl_stmt|;
name|int
name|reg
index|[
literal|24
index|]
decl_stmt|;
name|int
name|ctrl
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxtobsduoff
argument_list|(
argument|off
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|off
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|hpuxfp
modifier|*
name|hp
decl_stmt|;
name|struct
name|bsdfp
modifier|*
name|bp
decl_stmt|;
specifier|register
name|u_int
name|raddr
decl_stmt|;
comment|/* u_ar0 field */
if|if
condition|(
operator|(
name|int
operator|)
name|off
operator|==
name|HPUOFF
argument_list|(
name|hpuxu_ar0
argument_list|)
condition|)
return|return
operator|(
name|UOFF
argument_list|(
name|u_ar0
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|FPCOPROC
comment|/* 68881 registers from PCB */
name|hp
operator|=
operator|(
expr|struct
name|hpuxfp
operator|*
operator|)
name|HPUOFF
argument_list|(
name|hpuxu_fp
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|bsdfp
operator|*
operator|)
name|UOFF
argument_list|(
name|u_pcb
operator|.
name|pcb_fpregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|hp
operator|->
name|hpfp_ctrl
operator|&&
name|off
operator|<
operator|&
name|hp
operator|->
name|hpfp_ctrl
index|[
literal|3
index|]
condition|)
return|return
operator|(
operator|(
name|int
operator|)
operator|&
name|bp
operator|->
name|ctrl
index|[
name|off
operator|-
name|hp
operator|->
name|hpfp_ctrl
index|]
operator|)
return|;
if|if
condition|(
name|off
operator|>=
name|hp
operator|->
name|hpfp_reg
operator|&&
name|off
operator|<
operator|&
name|hp
operator|->
name|hpfp_reg
index|[
literal|24
index|]
condition|)
return|return
operator|(
operator|(
name|int
operator|)
operator|&
name|bp
operator|->
name|reg
index|[
name|off
operator|-
name|hp
operator|->
name|hpfp_reg
index|]
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * Everything else we recognize comes from the kernel stack, 	 * so we convert off to an absolute address (if not already) 	 * for simplicity. 	 */
if|if
condition|(
name|off
operator|<
operator|(
name|int
operator|*
operator|)
name|ctob
argument_list|(
name|UPAGES
argument_list|)
condition|)
name|off
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|u_int
operator|)
name|off
operator|+
operator|(
name|u_int
operator|)
operator|&
name|u
operator|)
expr_stmt|;
comment|/* 	 * 68020 registers. 	 * We know that the HPUX registers are in the same order as ours. 	 * The only difference is that their PS is 2 bytes instead of a 	 * padded 4 like ours throwing the alignment off. 	 */
if|if
condition|(
name|off
operator|>=
name|u
operator|.
name|u_ar0
operator|&&
name|off
operator|<
operator|&
name|u
operator|.
name|u_ar0
index|[
literal|18
index|]
condition|)
block|{
comment|/* 		 * PS: return low word and high word of PC as HP-UX would 		 * (e.g.&u.u_ar0[16.5]). 		 */
if|if
condition|(
name|off
operator|==
operator|&
name|u
operator|.
name|u_ar0
index|[
name|PS
index|]
condition|)
name|raddr
operator|=
operator|(
name|u_int
operator|)
operator|&
operator|(
operator|(
name|short
operator|*
operator|)
name|u
operator|.
name|u_ar0
operator|)
index|[
name|PS
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
comment|/* 		 * PC: off will be&u.u_ar0[16.5] 		 */
elseif|else
if|if
condition|(
name|off
operator|==
operator|(
name|int
operator|*
operator|)
operator|&
operator|(
operator|(
operator|(
name|short
operator|*
operator|)
name|u
operator|.
name|u_ar0
operator|)
index|[
name|PS
operator|*
literal|2
operator|+
literal|1
index|]
operator|)
condition|)
name|raddr
operator|=
operator|(
name|u_int
operator|)
operator|&
name|u
operator|.
name|u_ar0
index|[
name|PC
index|]
expr_stmt|;
comment|/* 		 * D0-D7, A0-A7: easy 		 */
else|else
name|raddr
operator|=
operator|(
name|u_int
operator|)
operator|&
name|u
operator|.
name|u_ar0
index|[
call|(
name|int
call|)
argument_list|(
name|off
operator|-
name|u
operator|.
name|u_ar0
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|raddr
operator|-
operator|(
name|u_int
operator|)
operator|&
name|u
argument_list|)
operator|)
return|;
block|}
comment|/* everything else */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Kludge up a uarea dump so that HPUX debuggers can find out  * what they need.  IMPORTANT NOTE: we do not EVEN attempt to  * convert the entire user struct.  */
end_comment

begin_macro
name|hpuxdumpu
argument_list|(
argument|vp
argument_list|,
argument|cred
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|struct
name|hpuxuser
modifier|*
name|faku
decl_stmt|;
name|struct
name|bsdfp
modifier|*
name|bp
decl_stmt|;
name|short
modifier|*
name|foop
decl_stmt|;
name|faku
operator|=
operator|(
expr|struct
name|hpuxuser
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|u_long
operator|)
name|ctob
argument_list|(
literal|1
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure there is no mistake about this 	 * being a real user structure. 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|faku
argument_list|,
name|ctob
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the process sizes. 	 */
name|faku
operator|->
name|hpuxu_tsize
operator|=
name|u
operator|.
name|u_tsize
expr_stmt|;
name|faku
operator|->
name|hpuxu_dsize
operator|=
name|u
operator|.
name|u_dsize
expr_stmt|;
name|faku
operator|->
name|hpuxu_ssize
operator|=
name|u
operator|.
name|u_ssize
expr_stmt|;
comment|/* 	 * Fill in the exec header for CDB. 	 * This was saved back in exec().  As far as I can tell CDB 	 * only uses this information to verify that a particular 	 * core file goes with a particular binary. 	 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|u
operator|.
name|u_pcb
operator|.
name|pcb_exec
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|faku
operator|->
name|hpuxu_exdata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpux_exec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Adjust user's saved registers (on kernel stack) to reflect 	 * HPUX order.  Note that HPUX saves the SR as 2 bytes not 4 	 * so we have to move it up. 	 */
name|faku
operator|->
name|hpuxu_ar0
operator|=
name|u
operator|.
name|u_ar0
expr_stmt|;
name|foop
operator|=
operator|(
name|short
operator|*
operator|)
name|u
operator|.
name|u_ar0
expr_stmt|;
name|foop
index|[
literal|32
index|]
operator|=
name|foop
index|[
literal|33
index|]
expr_stmt|;
name|foop
index|[
literal|33
index|]
operator|=
name|foop
index|[
literal|34
index|]
expr_stmt|;
name|foop
index|[
literal|34
index|]
operator|=
name|foop
index|[
literal|35
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|FPCOPROC
comment|/* 	 * Copy 68881 registers from our PCB format to HPUX format 	 */
name|bp
operator|=
operator|(
expr|struct
name|bsdfp
operator|*
operator|)
operator|&
name|u
operator|.
name|u_pcb
operator|.
name|pcb_fpregs
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
operator|->
name|save
argument_list|,
operator|(
name|caddr_t
operator|)
name|faku
operator|->
name|hpuxu_fp
operator|.
name|hpfp_save
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
operator|->
name|ctrl
argument_list|,
operator|(
name|caddr_t
operator|)
name|faku
operator|->
name|hpuxu_fp
operator|.
name|hpfp_ctrl
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|ctrl
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
operator|->
name|reg
argument_list|,
operator|(
name|caddr_t
operator|)
name|faku
operator|->
name|hpuxu_fp
operator|.
name|hpfp_reg
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|reg
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Slay the dragon 	 */
name|faku
operator|->
name|hpuxu_dragon
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Dump this artfully constructed page in place of the 	 * user struct page. 	 */
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
operator|(
name|caddr_t
operator|)
name|faku
argument_list|,
name|ctob
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
operator||
name|IO_UNIT
argument_list|,
name|cred
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Dump the remaining UPAGES-1 pages normally 	 */
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
operator|(
operator|(
name|caddr_t
operator|)
operator|&
name|u
operator|)
operator|+
name|ctob
argument_list|(
literal|1
argument_list|)
argument_list|,
name|ctob
argument_list|(
name|UPAGES
operator|-
literal|1
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
name|ctob
argument_list|(
literal|1
argument_list|)
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
operator||
name|IO_UNIT
argument_list|,
name|cred
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|faku
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * The remaining routines are essentially the same as those in kern_xxx.c  * and vfs_xxx.c as defined under "#ifdef COMPAT".  We replicate them here  * to avoid HPUXCOMPAT dependencies in those files and to make sure that  * HP-UX compatibility still works even when COMPAT is not defined.  */
end_comment

begin_comment
comment|/* #ifdef COMPAT */
end_comment

begin_include
include|#
directive|include
file|"../sys/times.h"
end_include

begin_comment
comment|/* from old timeb.h */
end_comment

begin_struct
struct|struct
name|hpuxtimeb
block|{
name|time_t
name|time
decl_stmt|;
name|u_short
name|millitm
decl_stmt|;
name|short
name|timezone
decl_stmt|;
name|short
name|dstflag
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ye ole stat structure */
end_comment

begin_struct
struct|struct
name|ohpuxstat
block|{
name|dev_t
name|ohst_dev
decl_stmt|;
name|u_short
name|ohst_ino
decl_stmt|;
name|u_short
name|ohst_mode
decl_stmt|;
name|short
name|ohst_nlink
decl_stmt|;
name|short
name|ohst_uid
decl_stmt|;
name|short
name|ohst_gid
decl_stmt|;
name|dev_t
name|ohst_rdev
decl_stmt|;
name|int
name|ohst_size
decl_stmt|;
name|int
name|ohst_atime
decl_stmt|;
name|int
name|ohst_mtime
decl_stmt|;
name|int
name|ohst_ctime
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Right now the following two routines are the same as the 4.3  * osetuid/osetgid calls.  Eventually they need to be changed to  * implement the notion of "saved" ids (whatever that means).  */
end_comment

begin_macro
name|ohpuxsetuid
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|uid
expr_stmt|;
specifier|register
struct|struct
name|a
block|{
name|int
name|uid
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|uid
operator|=
name|uap
operator|->
name|uid
expr_stmt|;
if|if
condition|(
name|uid
operator|!=
name|u
operator|.
name|u_procp
operator|->
name|p_ruid
operator|&&
name|uid
operator|!=
name|u
operator|.
name|u_cred
operator|->
name|cr_uid
operator|&&
operator|(
name|u
operator|.
name|u_error
operator|=
name|suser
argument_list|(
name|u
operator|.
name|u_cred
argument_list|,
operator|&
name|u
operator|.
name|u_acflag
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|u
operator|.
name|u_cred
operator|->
name|cr_ref
operator|>
literal|1
condition|)
name|u
operator|.
name|u_cred
operator|=
name|crcopy
argument_list|(
name|u
operator|.
name|u_cred
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_cred
operator|->
name|cr_uid
operator|=
name|uid
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_uid
operator|=
name|uid
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_ruid
operator|=
name|uid
expr_stmt|;
block|}
end_block

begin_macro
name|ohpuxsetgid
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|gid
expr_stmt|;
specifier|register
struct|struct
name|a
block|{
name|int
name|gid
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|gid
operator|=
name|uap
operator|->
name|gid
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_procp
operator|->
name|p_rgid
operator|!=
name|gid
operator|&&
name|u
operator|.
name|u_cred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|gid
operator|&&
operator|(
name|u
operator|.
name|u_error
operator|=
name|suser
argument_list|(
name|u
operator|.
name|u_cred
argument_list|,
operator|&
name|u
operator|.
name|u_acflag
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|u
operator|.
name|u_cred
operator|->
name|cr_ref
operator|>
literal|1
condition|)
name|u
operator|.
name|u_cred
operator|=
name|crcopy
argument_list|(
name|u
operator|.
name|u_cred
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_rgid
operator|=
name|gid
expr_stmt|;
name|u
operator|.
name|u_cred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|=
name|gid
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * SYS V style setpgrp()  */
end_comment

begin_macro
name|ohpuxsetpgrp
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|u
operator|.
name|u_procp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_pid
operator|!=
name|p
operator|->
name|p_pgid
condition|)
name|pgmv
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
name|p
operator|->
name|p_pgid
expr_stmt|;
block|}
end_block

begin_macro
name|ohpuxtime
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|long
modifier|*
name|tp
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
if|if
condition|(
name|uap
operator|->
name|tp
condition|)
name|u
operator|.
name|u_error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|time
operator|.
name|tv_sec
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|r_time
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
block|}
end_block

begin_macro
name|ohpuxstime
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|int
name|time
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|s
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|uap
operator|->
name|time
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|suser
argument_list|(
name|u
operator|.
name|u_cred
argument_list|,
operator|&
name|u
operator|.
name|u_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
condition|)
return|return;
comment|/* WHAT DO WE DO ABOUT PENDING REAL-TIME TIMEOUTS??? */
name|boottime
operator|.
name|tv_sec
operator|+=
name|tv
operator|.
name|tv_sec
operator|-
name|time
operator|.
name|tv_sec
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|time
operator|=
name|tv
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|resettodr
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ohpuxftime
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|struct
name|hpuxtimeb
modifier|*
name|tp
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
name|struct
name|hpuxtimeb
name|tb
decl_stmt|;
name|int
name|s
decl_stmt|;
name|uap
operator|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|tb
operator|.
name|time
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|tb
operator|.
name|millitm
operator|=
name|time
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tb
operator|.
name|timezone
operator|=
name|tz
operator|.
name|tz_minuteswest
expr_stmt|;
name|tb
operator|.
name|dstflag
operator|=
name|tz
operator|.
name|tz_dsttime
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tb
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
name|tb
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ohpuxalarm
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|int
name|deltat
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|u
operator|.
name|u_procp
decl_stmt|;
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|untimeout
argument_list|(
name|realitexpire
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
argument_list|)
expr_stmt|;
name|timerclear
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_interval
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|timerisset
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
argument_list|)
operator|&&
name|timercmp
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
argument_list|,
operator|&
name|time
argument_list|,
operator|>
argument_list|)
condition|)
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|-
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|deltat
operator|==
literal|0
condition|)
block|{
name|timerclear
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
operator|=
name|time
expr_stmt|;
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|+=
name|uap
operator|->
name|deltat
expr_stmt|;
name|timeout
argument_list|(
name|realitexpire
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
name|hzto
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ohpuxnice
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|int
name|niceness
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|u
operator|.
name|u_procp
decl_stmt|;
name|donice
argument_list|(
name|p
argument_list|,
operator|(
name|p
operator|->
name|p_nice
operator|-
name|NZERO
operator|)
operator|+
name|uap
operator|->
name|niceness
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
name|p
operator|->
name|p_nice
operator|-
name|NZERO
expr_stmt|;
block|}
end_block

begin_macro
name|ohpuxtimes
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|struct
name|tms
modifier|*
name|tmsb
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|struct
name|tms
name|atms
decl_stmt|;
name|atms
operator|.
name|tms_utime
operator|=
name|scale50
argument_list|(
operator|&
name|u
operator|.
name|u_ru
operator|.
name|ru_utime
argument_list|)
expr_stmt|;
name|atms
operator|.
name|tms_stime
operator|=
name|scale50
argument_list|(
operator|&
name|u
operator|.
name|u_ru
operator|.
name|ru_stime
argument_list|)
expr_stmt|;
name|atms
operator|.
name|tms_cutime
operator|=
name|scale50
argument_list|(
operator|&
name|u
operator|.
name|u_cru
operator|.
name|ru_utime
argument_list|)
expr_stmt|;
name|atms
operator|.
name|tms_cstime
operator|=
name|scale50
argument_list|(
operator|&
name|u
operator|.
name|u_cru
operator|.
name|ru_stime
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|atms
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tmsb
argument_list|,
sizeof|sizeof
argument_list|(
name|atms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
operator|==
literal|0
condition|)
name|u
operator|.
name|u_r
operator|.
name|r_time
operator|=
name|scale50
argument_list|(
operator|&
name|time
argument_list|)
operator|-
name|scale50
argument_list|(
operator|&
name|boottime
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|scale50
argument_list|(
name|tvp
argument_list|)
specifier|register
expr|struct
name|timeval
operator|*
name|tvp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|int
name|hpuxtick
decl_stmt|;
comment|/* 	 * Doesn't exactly do what the documentation says. 	 * What we really do is return 50th of a second since that 	 * is what HZ is on all bobcats I know of. 	 */
return|return
operator|(
operator|(
name|tvp
operator|->
name|tv_sec
operator|*
literal|50
operator|+
name|tvp
operator|->
name|tv_usec
operator|/
name|hpuxtick
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Set IUPD and IACC times on file.  * Can't set ICHG.  */
end_comment

begin_macro
name|ohpuxutime
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|time_t
modifier|*
name|tptr
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|time_t
name|tv
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|nameidata
modifier|*
name|ndp
init|=
operator|&
name|u
operator|.
name|u_nd
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|tptr
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
condition|)
return|return;
block|}
else|else
name|tv
index|[
literal|0
index|]
operator|=
name|tv
index|[
literal|1
index|]
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|ndp
operator|->
name|ni_nameiop
operator|=
name|LOOKUP
operator||
name|FOLLOW
operator||
name|LOCKLEAF
expr_stmt|;
name|ndp
operator|->
name|ni_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|ndp
operator|->
name|ni_dirp
operator|=
name|uap
operator|->
name|fname
expr_stmt|;
name|vattr_null
argument_list|(
operator|&
name|vattr
argument_list|)
expr_stmt|;
name|vattr
operator|.
name|va_atime
operator|.
name|tv_sec
operator|=
name|tv
index|[
literal|0
index|]
expr_stmt|;
name|vattr
operator|.
name|va_atime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|vattr
operator|.
name|va_mtime
operator|.
name|tv_sec
operator|=
name|tv
index|[
literal|1
index|]
expr_stmt|;
name|vattr
operator|.
name|va_mtime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
operator|=
name|namei
argument_list|(
name|ndp
argument_list|)
condition|)
return|return;
name|vp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
name|u
operator|.
name|u_error
operator|=
name|EROFS
expr_stmt|;
else|else
name|u
operator|.
name|u_error
operator|=
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ndp
operator|->
name|ni_cred
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ohpuxpause
argument_list|()
end_macro

begin_block
block|{
for|for
control|(
init|;
condition|;
control|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|u
argument_list|,
name|PSLEP
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The old fstat system call.  */
end_comment

begin_macro
name|ohpuxfstat
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|ohpuxstat
modifier|*
name|sb
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
specifier|extern
name|struct
name|file
modifier|*
name|getinode
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|fd
operator|>=
name|NOFILE
operator|||
operator|(
name|fp
operator|=
name|u
operator|.
name|u_ofile
index|[
name|uap
operator|->
name|fd
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EBADF
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_VNODE
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|u
operator|.
name|u_error
operator|=
name|ohpuxstat1
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
argument_list|,
name|uap
operator|->
name|sb
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Old stat system call.  This version follows links.  */
end_comment

begin_macro
name|ohpuxstat
argument_list|()
end_macro

begin_block
block|{
specifier|register
struct|struct
name|a
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|ohpuxstat
modifier|*
name|sb
decl_stmt|;
block|}
modifier|*
name|uap
init|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
struct|;
specifier|register
name|struct
name|nameidata
modifier|*
name|ndp
init|=
operator|&
name|u
operator|.
name|u_nd
decl_stmt|;
name|ndp
operator|->
name|ni_nameiop
operator|=
name|LOOKUP
operator||
name|LOCKLEAF
operator||
name|FOLLOW
expr_stmt|;
name|ndp
operator|->
name|ni_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|ndp
operator|->
name|ni_dirp
operator|=
name|uap
operator|->
name|fname
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
operator|=
name|namei
argument_list|(
name|ndp
argument_list|)
condition|)
return|return;
name|u
operator|.
name|u_error
operator|=
name|ohpuxstat1
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|,
name|uap
operator|->
name|sb
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|ohpuxstat1
parameter_list|(
name|vp
parameter_list|,
name|ub
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|ohpuxstat
modifier|*
name|ub
decl_stmt|;
block|{
name|struct
name|ohpuxstat
name|ds
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|u
operator|.
name|u_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Copy from inode table 	 */
name|ds
operator|.
name|ohst_dev
operator|=
name|vattr
operator|.
name|va_fsid
expr_stmt|;
name|ds
operator|.
name|ohst_ino
operator|=
operator|(
name|short
operator|)
name|vattr
operator|.
name|va_fileid
expr_stmt|;
name|ds
operator|.
name|ohst_mode
operator|=
operator|(
name|u_short
operator|)
name|vattr
operator|.
name|va_mode
expr_stmt|;
name|ds
operator|.
name|ohst_nlink
operator|=
name|vattr
operator|.
name|va_nlink
expr_stmt|;
name|ds
operator|.
name|ohst_uid
operator|=
operator|(
name|short
operator|)
name|vattr
operator|.
name|va_uid
expr_stmt|;
name|ds
operator|.
name|ohst_gid
operator|=
operator|(
name|short
operator|)
name|vattr
operator|.
name|va_gid
expr_stmt|;
name|ds
operator|.
name|ohst_rdev
operator|=
operator|(
name|dev_t
operator|)
name|vattr
operator|.
name|va_rdev
expr_stmt|;
name|ds
operator|.
name|ohst_size
operator|=
operator|(
name|int
operator|)
name|vattr
operator|.
name|va_size
expr_stmt|;
name|ds
operator|.
name|ohst_atime
operator|=
operator|(
name|int
operator|)
name|vattr
operator|.
name|va_atime
operator|.
name|tv_sec
expr_stmt|;
name|ds
operator|.
name|ohst_mtime
operator|=
operator|(
name|int
operator|)
name|vattr
operator|.
name|va_mtime
operator|.
name|tv_sec
expr_stmt|;
name|ds
operator|.
name|ohst_ctime
operator|=
operator|(
name|int
operator|)
name|vattr
operator|.
name|va_ctime
operator|.
name|tv_sec
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ds
argument_list|,
operator|(
name|caddr_t
operator|)
name|ub
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* #endif */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

