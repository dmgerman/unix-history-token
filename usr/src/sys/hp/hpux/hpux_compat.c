begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: hpux_compat.c 1.43 92/04/23$  *  *	@(#)hpux_compat.c	7.29 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Various HP-UX compatibility routines  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HPUXCOMPAT
end_ifdef

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"signalvar.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"filedesc.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"namei.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"ptrace.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"ipc.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"machine/reg.h"
end_include

begin_include
include|#
directive|include
file|"machine/psl.h"
end_include

begin_include
include|#
directive|include
file|"machine/vmparam.h"
end_include

begin_include
include|#
directive|include
file|"hpux.h"
end_include

begin_include
include|#
directive|include
file|"hpux_termio.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|unimpresponse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS5 style UTSNAME info */
end_comment

begin_decl_stmt
name|struct
name|hpuxutsname
name|protoutsname
init|=
block|{
literal|"4.4bsd"
block|,
literal|""
block|,
literal|"2.0"
block|,
literal|"B"
block|,
literal|"9000/3?0"
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6.0 and later style context */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
end_if

begin_decl_stmt
name|char
name|hpux040context
index|[]
init|=
literal|"standalone HP-MC68040 HP-MC68881 HP-MC68020 HP-MC68010 localroot default"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FPCOPROC
end_ifdef

begin_decl_stmt
name|char
name|hpuxcontext
index|[]
init|=
literal|"standalone HP-MC68881 HP-MC68020 HP-MC68010 localroot default"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|hpuxcontext
index|[]
init|=
literal|"standalone HP-MC68020 HP-MC68010 localroot default"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YP domainname */
end_comment

begin_decl_stmt
name|char
name|domainname
index|[
name|MAXHOSTNAMELEN
index|]
init|=
literal|"unknown"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|domainnamelen
init|=
literal|7
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NERR
value|79
end_define

begin_define
define|#
directive|define
name|BERR
value|1000
end_define

begin_comment
comment|/* indexed by BSD errno */
end_comment

begin_decl_stmt
name|short
name|bsdtohpuxerrnomap
index|[
name|NERR
index|]
init|=
block|{
comment|/*00*/
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
comment|/*10*/
literal|10
block|,
literal|45
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
comment|/*20*/
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
comment|/*30*/
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|246
block|,
literal|245
block|,
literal|244
block|,
literal|216
block|,
literal|217
block|,
comment|/*40*/
literal|218
block|,
literal|219
block|,
literal|220
block|,
literal|221
block|,
literal|222
block|,
literal|223
block|,
literal|224
block|,
literal|225
block|,
literal|226
block|,
literal|227
block|,
comment|/*50*/
literal|228
block|,
literal|229
block|,
literal|230
block|,
literal|231
block|,
literal|232
block|,
literal|233
block|,
literal|234
block|,
literal|235
block|,
literal|236
block|,
literal|237
block|,
comment|/*60*/
literal|238
block|,
literal|239
block|,
literal|249
block|,
literal|248
block|,
literal|241
block|,
literal|242
block|,
literal|247
block|,
name|BERR
block|,
name|BERR
block|,
name|BERR
block|,
comment|/*70*/
literal|70
block|,
literal|71
block|,
name|BERR
block|,
name|BERR
block|,
name|BERR
block|,
name|BERR
block|,
name|BERR
block|,
literal|46
block|,
name|BERR
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|notimp
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|,
argument|code
argument_list|,
argument|nargs
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|uap
decl_stmt|,
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|code
decl_stmt|,
name|nargs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
specifier|register
name|int
modifier|*
name|argp
init|=
name|uap
decl_stmt|;
specifier|extern
name|char
modifier|*
name|hpuxsyscallnames
index|[]
decl_stmt|;
name|printf
argument_list|(
literal|"HP-UX %s("
argument_list|,
name|hpuxsyscallnames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
condition|)
while|while
condition|(
name|nargs
operator|--
condition|)
name|printf
argument_list|(
literal|"%x%c"
argument_list|,
operator|*
name|argp
operator|++
argument_list|,
name|nargs
condition|?
literal|','
else|:
literal|')'
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|unimpresponse
condition|)
block|{
case|case
literal|0
case|:
name|error
operator|=
name|nosys
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|error
operator|=
name|nosys
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uprintf
argument_list|(
literal|"HP-UX system call %d not implemented\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxexecv_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxexecv
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxexecv_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|execve
parameter_list|()
function_decl|;
name|uap
operator|->
name|envp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|execve
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * HP-UX versions of wait and wait3 actually pass the parameters  * (status pointer, options, rusage) into the kernel rather than  * handling it in the C library stub.  We also need to map any  * termination signal from BSD to HP-UX.  */
end_comment

begin_struct
struct|struct
name|hpuxwait3_args
block|{
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|options
decl_stmt|;
name|int
name|rusage
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxwait3
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxwait3_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* rusage pointer must be zero */
if|if
condition|(
name|uap
operator|->
name|rusage
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
index|[
name|PS
index|]
operator|=
name|PSL_ALLCC
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
index|[
name|R0
index|]
operator|=
name|uap
operator|->
name|options
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
index|[
name|R1
index|]
operator|=
name|uap
operator|->
name|rusage
expr_stmt|;
return|return
operator|(
name|hpuxwait
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxwait_args
block|{
name|int
modifier|*
name|status
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxwait
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxwait_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|sig
decl_stmt|,
modifier|*
name|statp
decl_stmt|,
name|error
decl_stmt|;
name|statp
operator|=
name|uap
operator|->
name|status
expr_stmt|;
comment|/* owait clobbers first arg */
name|error
operator|=
name|owait
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* 	 * HP-UX wait always returns EINTR when interrupted by a signal 	 * (well, unless its emulating a BSD process, but we don't bother...) 	 */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sig
operator|=
name|retval
index|[
literal|1
index|]
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|WSTOPPED
condition|)
block|{
name|sig
operator|=
operator|(
name|retval
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|retval
index|[
literal|1
index|]
operator|=
operator|(
name|bsdtohpuxsig
argument_list|(
name|sig
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|WSTOPPED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sig
condition|)
name|retval
index|[
literal|1
index|]
operator|=
operator|(
name|retval
index|[
literal|1
index|]
operator|&
literal|0xFF00
operator|)
operator||
name|bsdtohpuxsig
argument_list|(
name|sig
operator|&
literal|0x7F
argument_list|)
operator||
operator|(
name|sig
operator|&
literal|0x80
operator|)
expr_stmt|;
if|if
condition|(
name|statp
condition|)
if|if
condition|(
name|suword
argument_list|(
operator|(
name|caddr_t
operator|)
name|statp
argument_list|,
name|retval
index|[
literal|1
index|]
argument_list|)
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxwaitpid_args
block|{
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|options
decl_stmt|;
name|struct
name|rusage
modifier|*
name|rusage
decl_stmt|;
comment|/* wait4 arg */
block|}
struct|;
end_struct

begin_macro
name|hpuxwaitpid
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxwaitpid_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|sig
decl_stmt|,
modifier|*
name|statp
decl_stmt|,
name|error
decl_stmt|;
name|uap
operator|->
name|rusage
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|wait4
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* 	 * HP-UX wait always returns EINTR when interrupted by a signal 	 * (well, unless its emulating a BSD process, but we don't bother...) 	 */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sig
operator|=
name|retval
index|[
literal|1
index|]
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|WSTOPPED
condition|)
block|{
name|sig
operator|=
operator|(
name|retval
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|retval
index|[
literal|1
index|]
operator|=
operator|(
name|bsdtohpuxsig
argument_list|(
name|sig
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|WSTOPPED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sig
condition|)
name|retval
index|[
literal|1
index|]
operator|=
operator|(
name|retval
index|[
literal|1
index|]
operator|&
literal|0xFF00
operator|)
operator||
name|bsdtohpuxsig
argument_list|(
name|sig
operator|&
literal|0x7F
argument_list|)
operator||
operator|(
name|sig
operator|&
literal|0x80
operator|)
expr_stmt|;
if|if
condition|(
name|statp
condition|)
if|if
condition|(
name|suword
argument_list|(
operator|(
name|caddr_t
operator|)
name|statp
argument_list|,
name|retval
index|[
literal|1
index|]
argument_list|)
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Must remap some bits in the mode mask.  * O_CREAT, O_TRUNC, and O_EXCL must be remapped,  * O_SYNCIO (0100000) is removed entirely.  */
end_comment

begin_struct
struct|struct
name|hpuxopen_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|crtmode
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxopen
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|hpuxopen_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|mode
decl_stmt|;
name|mode
operator|=
name|uap
operator|->
name|mode
expr_stmt|;
name|uap
operator|->
name|mode
operator|&=
operator|~
operator|(
name|HPUXFSYNCIO
operator||
name|HPUXFEXCL
operator||
name|HPUXFTRUNC
operator||
name|HPUXFCREAT
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|HPUXFCREAT
condition|)
block|{
comment|/* 		 * simulate the pre-NFS behavior that opening a 		 * file for READ+CREATE ignores the CREATE (unless 		 * EXCL is set in which case we will return the 		 * proper error). 		 */
if|if
condition|(
operator|(
name|mode
operator|&
name|HPUXFEXCL
operator|)
operator|||
operator|(
name|FFLAGS
argument_list|(
name|mode
argument_list|)
operator|&
name|FWRITE
operator|)
condition|)
name|uap
operator|->
name|mode
operator||=
name|O_CREAT
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|HPUXFTRUNC
condition|)
name|uap
operator|->
name|mode
operator||=
name|O_TRUNC
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|HPUXFEXCL
condition|)
name|uap
operator|->
name|mode
operator||=
name|O_EXCL
expr_stmt|;
return|return
operator|(
name|open
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|UF_FNDELAY_ON
value|0x20
end_define

begin_define
define|#
directive|define
name|UF_FIONBIO_ON
value|0x40
end_define

begin_comment
comment|/* XXX */
end_comment

begin_struct
struct|struct
name|hpuxfcntl_args
block|{
name|int
name|fdes
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxfcntl
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|hpuxfcntl_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|mode
decl_stmt|,
name|error
decl_stmt|;
name|char
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|cmd
operator|==
name|F_GETFL
operator|||
name|uap
operator|->
name|cmd
operator|==
name|F_SETFL
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|fdes
operator|>=
name|p
operator|->
name|p_fd
operator|->
name|fd_nfiles
operator|||
name|p
operator|->
name|p_fd
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|fdes
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|fp
operator|=
operator|&
name|p
operator|->
name|p_fd
operator|->
name|fd_ofileflags
index|[
name|uap
operator|->
name|fdes
index|]
expr_stmt|;
block|}
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|F_SETFL
case|:
if|if
condition|(
name|uap
operator|->
name|arg
operator|&
name|FNONBLOCK
condition|)
operator|*
name|fp
operator||=
name|UF_FNDELAY_ON
expr_stmt|;
else|else
block|{
operator|*
name|fp
operator|&=
operator|~
name|UF_FNDELAY_ON
expr_stmt|;
if|if
condition|(
operator|*
name|fp
operator|&
name|UF_FIONBIO_ON
condition|)
name|uap
operator|->
name|arg
operator||=
name|FNONBLOCK
expr_stmt|;
block|}
name|uap
operator|->
name|arg
operator|&=
operator|~
operator|(
name|HPUXFSYNCIO
operator||
name|HPUXFREMOTE
operator||
name|FUSECACHE
operator|)
expr_stmt|;
break|break;
case|case
name|F_GETFL
case|:
case|case
name|F_DUPFD
case|:
case|case
name|F_GETFD
case|:
case|case
name|F_SETFD
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|fcntl
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|uap
operator|->
name|cmd
operator|==
name|F_GETFL
condition|)
block|{
name|mode
operator|=
operator|*
name|retval
expr_stmt|;
operator|*
name|retval
operator|&=
operator|~
operator|(
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_EXCL
operator||
name|FUSECACHE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|FNONBLOCK
operator|)
operator|&&
operator|(
operator|*
name|fp
operator|&
name|UF_FNDELAY_ON
operator|)
operator|==
literal|0
condition|)
operator|*
name|retval
operator|&=
operator|~
name|FNONBLOCK
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|O_CREAT
condition|)
operator|*
name|retval
operator||=
name|HPUXFCREAT
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|O_TRUNC
condition|)
operator|*
name|retval
operator||=
name|HPUXFTRUNC
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|O_EXCL
condition|)
operator|*
name|retval
operator||=
name|HPUXFEXCL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Read and write should return a 0 count when an operation  * on a VNODE would block, not an error.  *  * In 6.2 and 6.5 sockets appear to return EWOULDBLOCK.  * In 7.0 the behavior for sockets depends on whether FNONBLOCK is in effect.  */
end_comment

begin_struct
struct|struct
name|hpuxread_args
block|{
name|int
name|fd
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxread
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxread_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|read
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
operator|(
name|p
operator|->
name|p_fd
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|fd
index|]
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
operator|||
name|p
operator|->
name|p_fd
operator|->
name|fd_ofileflags
index|[
name|uap
operator|->
name|fd
index|]
operator|&
name|UF_FNDELAY_ON
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxwrite_args
block|{
name|int
name|fd
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxwrite
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxwrite_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|write
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
operator|(
name|p
operator|->
name|p_fd
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|fd
index|]
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
operator|||
name|p
operator|->
name|p_fd
operator|->
name|fd_ofileflags
index|[
name|uap
operator|->
name|fd
index|]
operator|&
name|UF_FNDELAY_ON
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxreadv_args
block|{
name|int
name|fd
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxreadv
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxreadv_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|readv
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
operator|(
name|p
operator|->
name|p_fd
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|fd
index|]
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
operator|||
name|p
operator|->
name|p_fd
operator|->
name|fd_ofileflags
index|[
name|uap
operator|->
name|fd
index|]
operator|&
name|UF_FNDELAY_ON
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxwritev_args
block|{
name|int
name|fd
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxwritev
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxwritev_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|writev
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
operator|(
name|p
operator|->
name|p_fd
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|fd
index|]
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
operator|||
name|p
operator|->
name|p_fd
operator|->
name|fd_ofileflags
index|[
name|uap
operator|->
name|fd
index|]
operator|&
name|UF_FNDELAY_ON
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * 4.3bsd dup allows dup2 to come in on the same syscall entry  * and hence allows two arguments.  HP-UX dup has only one arg.  */
end_comment

begin_struct
struct|struct
name|hpuxdup_args
block|{
name|int
name|i
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxdup
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|hpuxdup_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|i
operator|)
operator|>=
name|fdp
operator|->
name|fd_nfiles
operator|||
operator|(
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|fdalloc
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|fd
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
operator|=
name|fp
expr_stmt|;
name|fdp
operator|->
name|fd_ofileflags
index|[
name|fd
index|]
operator|=
name|fdp
operator|->
name|fd_ofileflags
index|[
name|uap
operator|->
name|i
index|]
operator|&
operator|~
name|UF_EXCLOSE
expr_stmt|;
name|fp
operator|->
name|f_count
operator|++
expr_stmt|;
if|if
condition|(
name|fd
operator|>
name|fdp
operator|->
name|fd_lastfile
condition|)
name|fdp
operator|->
name|fd_lastfile
operator|=
name|fd
expr_stmt|;
operator|*
name|retval
operator|=
name|fd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxutssys_args
block|{
name|struct
name|hpuxutsname
modifier|*
name|uts
decl_stmt|;
name|int
name|dev
decl_stmt|;
name|int
name|request
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxutssys
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|hpuxutssys_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|request
condition|)
block|{
comment|/* uname */
case|case
literal|0
case|:
comment|/* fill in machine type */
switch|switch
condition|(
name|machineid
condition|)
block|{
case|case
name|HP_320
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'2'
expr_stmt|;
break|break;
comment|/* includes 318 and 319 */
case|case
name|HP_330
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'3'
expr_stmt|;
break|break;
case|case
name|HP_340
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'4'
expr_stmt|;
break|break;
case|case
name|HP_350
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'5'
expr_stmt|;
break|break;
case|case
name|HP_360
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'6'
expr_stmt|;
break|break;
case|case
name|HP_370
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'7'
expr_stmt|;
break|break;
comment|/* includes 345 */
case|case
name|HP_375
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'7'
expr_stmt|;
name|protoutsname
operator|.
name|machine
index|[
literal|7
index|]
operator|=
literal|'5'
expr_stmt|;
break|break;
comment|/* includes 425 */
case|case
name|HP_380
case|:
name|protoutsname
operator|.
name|machine
index|[
literal|6
index|]
operator|=
literal|'8'
expr_stmt|;
break|break;
block|}
comment|/* copy hostname (sans domain) to nodename */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
operator|&&
name|hostname
index|[
name|i
index|]
operator|!=
literal|'.'
condition|;
name|i
operator|++
control|)
name|protoutsname
operator|.
name|nodename
index|[
name|i
index|]
operator|=
name|hostname
index|[
name|i
index|]
expr_stmt|;
name|protoutsname
operator|.
name|nodename
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|protoutsname
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|uts
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpuxutsname
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* gethostname */
case|case
literal|5
case|:
comment|/* uap->dev is length */
if|if
condition|(
name|uap
operator|->
name|dev
operator|>
name|hostnamelen
operator|+
literal|1
condition|)
name|uap
operator|->
name|dev
operator|=
name|hostnamelen
operator|+
literal|1
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|hostname
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|uts
argument_list|,
name|uap
operator|->
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* ?? */
case|case
literal|2
case|:
comment|/* ustat */
case|case
literal|3
case|:
comment|/* ?? */
case|case
literal|4
case|:
comment|/* sethostname */
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxsysconf_args
block|{
name|int
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxsysconf
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxsysconf_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|uap
operator|->
name|name
condition|)
block|{
comment|/* open files */
case|case
name|HPUX_SYSCONF_OPENMAX
case|:
operator|*
name|retval
operator|=
name|NOFILE
expr_stmt|;
break|break;
comment|/* architecture */
case|case
name|HPUX_SYSCONF_CPUTYPE
case|:
switch|switch
condition|(
name|machineid
condition|)
block|{
case|case
name|HP_320
case|:
case|case
name|HP_330
case|:
case|case
name|HP_350
case|:
operator|*
name|retval
operator|=
name|HPUX_SYSCONF_CPUM020
expr_stmt|;
break|break;
case|case
name|HP_340
case|:
case|case
name|HP_360
case|:
case|case
name|HP_370
case|:
case|case
name|HP_375
case|:
operator|*
name|retval
operator|=
name|HPUX_SYSCONF_CPUM030
expr_stmt|;
break|break;
case|case
name|HP_380
case|:
operator|*
name|retval
operator|=
name|HPUX_SYSCONF_CPUM040
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|uprintf
argument_list|(
literal|"HP-UX sysconf(%d) not implemented\n"
argument_list|,
name|uap
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxstat_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|hpuxstat
modifier|*
name|hsb
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxstat
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxstat_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|hpuxstat1
argument_list|(
name|uap
operator|->
name|fname
argument_list|,
name|uap
operator|->
name|hsb
argument_list|,
name|FOLLOW
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxlstat_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|hpuxstat
modifier|*
name|hsb
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxlstat
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxlstat_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|hpuxstat1
argument_list|(
name|uap
operator|->
name|fname
argument_list|,
name|uap
operator|->
name|hsb
argument_list|,
name|NOFOLLOW
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxfstat_args
block|{
name|int
name|fdes
decl_stmt|;
name|struct
name|hpuxstat
modifier|*
name|hsb
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxfstat
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|hpuxfstat_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|fdes
operator|)
operator|>=
name|fdp
operator|->
name|fd_nfiles
operator|||
operator|(
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|fdes
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
switch|switch
condition|(
name|fp
operator|->
name|f_type
condition|)
block|{
case|case
name|DTYPE_VNODE
case|:
name|error
operator|=
name|vn_stat
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTYPE_SOCKET
case|:
name|error
operator|=
name|soo_stat
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
name|fp
operator|->
name|f_data
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"fstat"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* is this right for sockets?? */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|bsdtohpuxstat
argument_list|(
operator|&
name|sb
argument_list|,
name|uap
operator|->
name|hsb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxulimit_args
block|{
name|int
name|cmd
decl_stmt|;
name|long
name|newlimit
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxulimit
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|hpuxulimit_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|rlimit
modifier|*
name|limp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|limp
operator|=
operator|&
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_FSIZE
index|]
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
literal|2
case|:
name|uap
operator|->
name|newlimit
operator|*=
literal|512
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|newlimit
operator|>
name|limp
operator|->
name|rlim_max
operator|&&
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
break|break;
name|limp
operator|->
name|rlim_cur
operator|=
name|limp
operator|->
name|rlim_max
operator|=
name|uap
operator|->
name|newlimit
expr_stmt|;
comment|/* else fall into... */
case|case
literal|1
case|:
operator|*
name|retval
operator|=
name|limp
operator|->
name|rlim_max
operator|/
literal|512
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|limp
operator|=
operator|&
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_DATA
index|]
expr_stmt|;
operator|*
name|retval
operator|=
name|ctob
argument_list|(
name|p
operator|->
name|p_vmspace
operator|->
name|vm_tsize
argument_list|)
operator|+
name|limp
operator|->
name|rlim_max
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Map "real time" priorities 0 (high) thru 127 (low) into nice  * values -16 (high) thru -1 (low).  */
end_comment

begin_struct
struct|struct
name|hpuxrtprio_args
block|{
name|int
name|pid
decl_stmt|;
name|int
name|prio
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxrtprio
argument_list|(
argument|cp
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|hpuxrtprio_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|nice
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|prio
operator|<
name|RTPRIO_MIN
operator|&&
name|uap
operator|->
name|prio
operator|>
name|RTPRIO_MAX
operator|&&
name|uap
operator|->
name|prio
operator|!=
name|RTPRIO_NOCHG
operator|&&
name|uap
operator|->
name|prio
operator|!=
name|RTPRIO_RTOFF
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
name|p
operator|=
name|cp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|nice
operator|=
name|p
operator|->
name|p_nice
expr_stmt|;
if|if
condition|(
name|nice
operator|<
name|NZERO
condition|)
operator|*
name|retval
operator|=
operator|(
name|nice
operator|+
literal|16
operator|)
operator|<<
literal|3
expr_stmt|;
else|else
operator|*
name|retval
operator|=
name|RTPRIO_RTOFF
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|prio
condition|)
block|{
case|case
name|RTPRIO_NOCHG
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RTPRIO_RTOFF
case|:
if|if
condition|(
name|nice
operator|>=
name|NZERO
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nice
operator|=
name|NZERO
expr_stmt|;
break|break;
default|default:
name|nice
operator|=
operator|(
name|uap
operator|->
name|prio
operator|>>
literal|3
operator|)
operator|-
literal|16
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|donice
argument_list|(
name|cp
argument_list|,
name|p
argument_list|,
name|nice
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EACCES
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxadvise_args
block|{
name|int
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxadvise
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxadvise_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|arg
condition|)
block|{
case|case
literal|0
case|:
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_flags
operator||=
name|PCB_HPUXMMAP
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ICIA
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|DCIA
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxptrace_args
block|{
name|int
name|req
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|addr
decl_stmt|;
name|int
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxptrace
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxptrace_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|req
operator|==
name|PT_STEP
operator|||
name|uap
operator|->
name|req
operator|==
name|PT_CONTINUE
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|data
condition|)
block|{
name|uap
operator|->
name|data
operator|=
name|hpuxtobsdsig
argument_list|(
name|uap
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|data
operator|==
literal|0
condition|)
name|uap
operator|->
name|data
operator|=
name|NSIG
expr_stmt|;
block|}
block|}
name|error
operator|=
name|ptrace
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxgetdomainname_args
block|{
name|char
modifier|*
name|domainname
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxgetdomainname
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|hpuxgetdomainname_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|uap
operator|->
name|len
operator|>
name|domainnamelen
operator|+
literal|1
condition|)
name|uap
operator|->
name|len
operator|=
name|domainnamelen
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
name|domainname
argument_list|,
name|uap
operator|->
name|domainname
argument_list|,
name|uap
operator|->
name|len
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxsetdomainname_args
block|{
name|char
modifier|*
name|domainname
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxsetdomainname
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|hpuxsetdomainname_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|len
operator|>
sizeof|sizeof
argument_list|(
name|domainname
argument_list|)
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|domainnamelen
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|domainname
argument_list|,
name|domainname
argument_list|,
name|uap
operator|->
name|len
argument_list|)
expr_stmt|;
name|domainname
index|[
name|domainnamelen
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVSHM
end_ifdef

begin_include
include|#
directive|include
file|"shm.h"
end_include

begin_macro
name|hpuxshmat
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|uap
decl_stmt|,
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|shmat
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|hpuxshmdt
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|uap
decl_stmt|,
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|shmdt
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|hpuxshmget
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|uap
decl_stmt|,
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|shmget
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Handle HP-UX specific commands.  */
end_comment

begin_struct
struct|struct
name|hpuxshmctl_args
block|{
name|int
name|shmid
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxshmctl
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxshmctl_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
specifier|register
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|shmvalid
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|uap
operator|->
name|shmid
operator|%
name|SHMMMNI
index|]
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|cmd
operator|==
name|SHM_LOCK
operator|||
name|uap
operator|->
name|cmd
operator|==
name|SHM_UNLOCK
condition|)
block|{
comment|/* don't really do anything, but make them think we did */
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|cuid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|shmctl
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Fake semaphore routines, just don't return an error.  * Should be adequate for starbase to run.  */
end_comment

begin_struct
struct|struct
name|hpuxsemctl_args
block|{
name|int
name|semid
decl_stmt|;
name|u_int
name|semnum
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxsemctl
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxsemctl_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* XXX: should do something here */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxsemget_args
block|{
name|key_t
name|key
decl_stmt|;
name|int
name|nsems
decl_stmt|;
name|int
name|semflg
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxsemget
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxsemget_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* XXX: should do something here */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxsemop_args
block|{
name|int
name|semid
decl_stmt|;
name|struct
name|sembuf
modifier|*
name|sops
decl_stmt|;
name|u_int
name|nsops
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxsemop
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxsemop_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* XXX: should do something here */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* convert from BSD to HP-UX errno */
end_comment

begin_macro
name|bsdtohpuxerrno
argument_list|(
argument|err
argument_list|)
end_macro

begin_decl_stmt
name|int
name|err
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|err
operator|<
literal|0
operator|||
name|err
operator|>=
name|NERR
condition|)
return|return
operator|(
name|BERR
operator|)
return|;
return|return
operator|(
operator|(
name|int
operator|)
name|bsdtohpuxerrnomap
index|[
name|err
index|]
operator|)
return|;
block|}
end_block

begin_macro
name|hpuxstat1
argument_list|(
argument|fname
argument_list|,
argument|hsb
argument_list|,
argument|follow
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxstat
modifier|*
name|hsb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|follow
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|follow
operator||
name|LOCKLEAF
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|fname
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|vn_stat
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|bsdtohpuxstat
argument_list|(
operator|&
name|sb
argument_list|,
name|hsb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_include
include|#
directive|include
file|"grf.h"
end_include

begin_if
if|#
directive|if
name|NGRF
operator|>
literal|0
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
specifier|extern
name|int
name|grfopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|int
name|grfopen
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NHIL
value|1
end_define

begin_comment
comment|/* XXX */
end_comment

begin_if
if|#
directive|if
name|NHIL
operator|>
literal|0
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
specifier|extern
name|int
name|hilopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|int
name|hilopen
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_macro
name|bsdtohpuxstat
argument_list|(
argument|sb
argument_list|,
argument|hsb
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|stat
modifier|*
name|sb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxstat
modifier|*
name|hsb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|hpuxstat
name|ds
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|.
name|hst_dev
operator|=
operator|(
name|u_short
operator|)
name|sb
operator|->
name|st_dev
expr_stmt|;
name|ds
operator|.
name|hst_ino
operator|=
operator|(
name|u_long
operator|)
name|sb
operator|->
name|st_ino
expr_stmt|;
name|ds
operator|.
name|hst_mode
operator|=
name|sb
operator|->
name|st_mode
expr_stmt|;
name|ds
operator|.
name|hst_nlink
operator|=
name|sb
operator|->
name|st_nlink
expr_stmt|;
name|ds
operator|.
name|hst_uid
operator|=
operator|(
name|u_short
operator|)
name|sb
operator|->
name|st_uid
expr_stmt|;
name|ds
operator|.
name|hst_gid
operator|=
operator|(
name|u_short
operator|)
name|sb
operator|->
name|st_gid
expr_stmt|;
comment|/* XXX: I don't want to talk about it... */
if|if
condition|(
operator|(
name|sb
operator|->
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
condition|)
block|{
if|#
directive|if
name|NGRF
operator|>
literal|0
if|if
condition|(
name|cdevsw
index|[
name|major
argument_list|(
name|sb
operator|->
name|st_rdev
argument_list|)
index|]
operator|.
name|d_open
operator|==
name|grfopen
condition|)
name|ds
operator|.
name|hst_rdev
operator|=
name|grfdevno
argument_list|(
name|sb
operator|->
name|st_rdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NHIL
operator|>
literal|0
if|if
condition|(
name|cdevsw
index|[
name|major
argument_list|(
name|sb
operator|->
name|st_rdev
argument_list|)
index|]
operator|.
name|d_open
operator|==
name|hilopen
condition|)
name|ds
operator|.
name|hst_rdev
operator|=
name|hildevno
argument_list|(
name|sb
operator|->
name|st_rdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
empty_stmt|;
block|}
else|else
name|ds
operator|.
name|hst_rdev
operator|=
name|bsdtohpuxdev
argument_list|(
name|sb
operator|->
name|st_rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|st_size
operator|<
operator|(
name|quad_t
operator|)
literal|1
operator|<<
literal|32
condition|)
name|ds
operator|.
name|hst_size
operator|=
operator|(
name|long
operator|)
name|sb
operator|->
name|st_size
expr_stmt|;
else|else
name|ds
operator|.
name|hst_size
operator|=
operator|-
literal|2
expr_stmt|;
name|ds
operator|.
name|hst_atime
operator|=
name|sb
operator|->
name|st_atime
expr_stmt|;
name|ds
operator|.
name|hst_mtime
operator|=
name|sb
operator|->
name|st_mtime
expr_stmt|;
name|ds
operator|.
name|hst_ctime
operator|=
name|sb
operator|->
name|st_ctime
expr_stmt|;
name|ds
operator|.
name|hst_blksize
operator|=
name|sb
operator|->
name|st_blksize
expr_stmt|;
name|ds
operator|.
name|hst_blocks
operator|=
name|sb
operator|->
name|st_blocks
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ds
argument_list|,
operator|(
name|caddr_t
operator|)
name|hsb
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|hpuxtobsdioctl
argument_list|(
argument|com
argument_list|)
end_macro

begin_decl_stmt
name|int
name|com
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|com
condition|)
block|{
case|case
name|HPUXTIOCSLTC
case|:
name|com
operator|=
name|TIOCSLTC
expr_stmt|;
break|break;
case|case
name|HPUXTIOCGLTC
case|:
name|com
operator|=
name|TIOCGLTC
expr_stmt|;
break|break;
case|case
name|HPUXTIOCSPGRP
case|:
name|com
operator|=
name|TIOCSPGRP
expr_stmt|;
break|break;
case|case
name|HPUXTIOCGPGRP
case|:
name|com
operator|=
name|TIOCGPGRP
expr_stmt|;
break|break;
case|case
name|HPUXTIOCLBIS
case|:
name|com
operator|=
name|TIOCLBIS
expr_stmt|;
break|break;
case|case
name|HPUXTIOCLBIC
case|:
name|com
operator|=
name|TIOCLBIC
expr_stmt|;
break|break;
case|case
name|HPUXTIOCLSET
case|:
name|com
operator|=
name|TIOCLSET
expr_stmt|;
break|break;
case|case
name|HPUXTIOCLGET
case|:
name|com
operator|=
name|TIOCLGET
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|com
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * HP-UX ioctl system call.  The differences here are:  *	IOC_IN also means IOC_VOID if the size portion is zero.  *	no FIOCLEX/FIONCLEX/FIOASYNC/FIOGETOWN/FIOSETOWN  *	the sgttyb struct is 2 bytes longer  */
end_comment

begin_struct
struct|struct
name|hpuxioctl_args
block|{
name|int
name|fdes
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|cmarg
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxioctl
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|hpuxioctl_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|com
decl_stmt|,
name|error
decl_stmt|;
specifier|register
name|u_int
name|size
decl_stmt|;
name|caddr_t
name|memp
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|STK_PARAMS
value|128
name|char
name|stkbuf
index|[
name|STK_PARAMS
index|]
decl_stmt|;
name|caddr_t
name|data
init|=
name|stkbuf
decl_stmt|;
name|com
operator|=
name|uap
operator|->
name|cmd
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|com
operator|==
name|HPUXTIOCGETP
operator|||
name|com
operator|==
name|HPUXTIOCSETP
condition|)
return|return
operator|(
name|getsettty
argument_list|(
name|p
argument_list|,
name|uap
operator|->
name|fdes
argument_list|,
name|com
argument_list|,
name|uap
operator|->
name|cmarg
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|fdes
operator|)
operator|>=
name|fdp
operator|->
name|fd_nfiles
operator|||
operator|(
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|fdes
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
comment|/* 	 * Interpret high order word to find 	 * amount of data to be copied to/from the 	 * user's address space. 	 */
name|size
operator|=
name|IOCPARM_LEN
argument_list|(
name|com
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|IOCPARM_MAX
condition|)
return|return
operator|(
name|ENOTTY
operator|)
return|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
name|stkbuf
argument_list|)
condition|)
block|{
name|memp
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
operator|(
name|u_long
operator|)
name|size
argument_list|,
name|M_IOCTLOPS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|data
operator|=
name|memp
expr_stmt|;
block|}
if|if
condition|(
name|com
operator|&
name|IOC_IN
condition|)
block|{
if|if
condition|(
name|size
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|cmarg
argument_list|,
name|data
argument_list|,
operator|(
name|u_int
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|memp
condition|)
name|free
argument_list|(
name|memp
argument_list|,
name|M_IOCTLOPS
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|data
operator|=
name|uap
operator|->
name|cmarg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|com
operator|&
name|IOC_OUT
operator|)
operator|&&
name|size
condition|)
comment|/* 		 * Zero the buffer so the user always 		 * gets back something deterministic. 		 */
name|bzero
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|com
operator|&
name|IOC_VOID
condition|)
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|data
operator|=
name|uap
operator|->
name|cmarg
expr_stmt|;
switch|switch
condition|(
name|com
condition|)
block|{
case|case
name|HPUXFIOSNBIO
case|:
block|{
name|char
modifier|*
name|ofp
init|=
operator|&
name|fdp
operator|->
name|fd_ofileflags
index|[
name|uap
operator|->
name|fdes
index|]
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
operator|*
name|ofp
operator||=
name|UF_FIONBIO_ON
expr_stmt|;
else|else
operator|*
name|ofp
operator|&=
operator|~
name|UF_FIONBIO_ON
expr_stmt|;
comment|/* 		 * Only set/clear if FNONBLOCK not in effect 		 */
if|if
condition|(
operator|(
operator|*
name|ofp
operator|&
name|UF_FNDELAY_ON
operator|)
operator|==
literal|0
condition|)
block|{
name|tmp
operator|=
name|fp
operator|->
name|f_flag
operator|&
name|FNONBLOCK
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_ops
operator|->
name|fo_ioctl
call|)
argument_list|(
name|fp
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tmp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HPUXTIOCCONS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|1
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_ops
operator|->
name|fo_ioctl
call|)
argument_list|(
name|fp
argument_list|,
name|TIOCCONS
argument_list|,
name|data
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
comment|/* BSD-style job control ioctls */
case|case
name|HPUXTIOCLBIS
case|:
case|case
name|HPUXTIOCLBIC
case|:
case|case
name|HPUXTIOCLSET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&=
name|HPUXLTOSTOP
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|HPUXLTOSTOP
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|LTOSTOP
expr_stmt|;
comment|/* fall into */
case|case
name|HPUXTIOCLGET
case|:
case|case
name|HPUXTIOCSLTC
case|:
case|case
name|HPUXTIOCGLTC
case|:
case|case
name|HPUXTIOCSPGRP
case|:
case|case
name|HPUXTIOCGPGRP
case|:
name|error
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_ops
operator|->
name|fo_ioctl
call|)
argument_list|(
name|fp
argument_list|,
name|hpuxtobsdioctl
argument_list|(
name|com
argument_list|)
argument_list|,
name|data
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|com
operator|==
name|HPUXTIOCLGET
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&=
name|LTOSTOP
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|LTOSTOP
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|HPUXLTOSTOP
expr_stmt|;
block|}
break|break;
comment|/* SYS 5 termio */
case|case
name|HPUXTCGETA
case|:
case|case
name|HPUXTCSETA
case|:
case|case
name|HPUXTCSETAW
case|:
case|case
name|HPUXTCSETAF
case|:
name|error
operator|=
name|hpuxtermio
argument_list|(
name|fp
argument_list|,
name|com
argument_list|,
name|data
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_ops
operator|->
name|fo_ioctl
call|)
argument_list|(
name|fp
argument_list|,
name|com
argument_list|,
name|data
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Copy any data to user, size was 	 * already set and checked above. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|com
operator|&
name|IOC_OUT
operator|)
operator|&&
name|size
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|data
argument_list|,
name|uap
operator|->
name|cmarg
argument_list|,
operator|(
name|u_int
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|memp
condition|)
name|free
argument_list|(
name|memp
argument_list|,
name|M_IOCTLOPS
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Man page lies, behaviour here is based on observed behaviour.  */
end_comment

begin_struct
struct|struct
name|hpuxgetcontext_args
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxgetcontext
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxgetcontext_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
if|if
condition|(
name|machineid
operator|==
name|HP_380
condition|)
block|{
name|len
operator|=
name|min
argument_list|(
name|uap
operator|->
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|hpux040context
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|hpux040context
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|retval
operator|=
sizeof|sizeof
argument_list|(
name|hpux040context
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
name|len
operator|=
name|min
argument_list|(
name|uap
operator|->
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|hpuxcontext
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|hpuxcontext
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
operator|(
name|u_int
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|retval
operator|=
sizeof|sizeof
argument_list|(
name|hpuxcontext
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * This is the equivalent of BSD getpgrp but with more restrictions.  * Note we do not check the real uid or "saved" uid.  */
end_comment

begin_struct
struct|struct
name|hpuxgetpgrp2_args
block|{
name|int
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxgetpgrp2
argument_list|(
argument|cp
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|hpuxgetpgrp2_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
name|uap
operator|->
name|pid
operator|=
name|cp
operator|->
name|p_pid
expr_stmt|;
name|p
operator|=
name|pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
name|cp
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
name|cp
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|&&
operator|!
name|inferior
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
operator|*
name|retval
operator|=
name|p
operator|->
name|p_pgid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * This is the equivalent of BSD setpgrp but with more restrictions.  * Note we do not check the real uid or "saved" uid or pgrp.  */
end_comment

begin_struct
struct|struct
name|hpuxsetpgrp2_args
block|{
name|int
name|pid
decl_stmt|;
name|int
name|pgrp
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxsetpgrp2
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxsetpgrp2_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* empirically determined */
if|if
condition|(
name|uap
operator|->
name|pgrp
operator|<
literal|0
operator|||
name|uap
operator|->
name|pgrp
operator|>=
literal|30000
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|setpgid
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * XXX Same as old BSD setre[ug]id right now.  Need to consider saved ids.  */
end_comment

begin_struct
struct|struct
name|hpuxsetresuid_args
block|{
name|int
name|ruid
decl_stmt|;
name|int
name|euid
decl_stmt|;
name|int
name|suid
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
name|hpuxsetresuid
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|hpuxsetresuid_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
specifier|register
name|uid_t
name|ruid
decl_stmt|,
name|euid
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|ruid
operator|==
operator|-
literal|1
condition|)
name|ruid
operator|=
name|pc
operator|->
name|p_ruid
expr_stmt|;
else|else
name|ruid
operator|=
name|uap
operator|->
name|ruid
expr_stmt|;
comment|/* 	 * Allow setting real uid to previous effective, for swapping real and 	 * effective.  This should be: 	 * 	 * if (ruid != pc->p_ruid&& 	 *     (error = suser(pc->pc_ucred,&p->p_acflag))) 	 */
if|if
condition|(
name|ruid
operator|!=
name|pc
operator|->
name|p_ruid
operator|&&
name|ruid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
comment|/* XXX */
operator|&&
operator|(
name|error
operator|=
name|suser
argument_list|(
name|pc
operator|->
name|pc_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|euid
operator|==
operator|-
literal|1
condition|)
name|euid
operator|=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
expr_stmt|;
else|else
name|euid
operator|=
name|uap
operator|->
name|euid
expr_stmt|;
if|if
condition|(
name|euid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|&&
name|euid
operator|!=
name|pc
operator|->
name|p_ruid
operator|&&
name|euid
operator|!=
name|pc
operator|->
name|p_svuid
operator|&&
operator|(
name|error
operator|=
name|suser
argument_list|(
name|pc
operator|->
name|pc_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Everything's okay, do it.  Copy credentials so other references do 	 * not see our changes. 	 */
name|pc
operator|->
name|pc_ucred
operator|=
name|crcopy
argument_list|(
name|pc
operator|->
name|pc_ucred
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_uid
operator|=
name|euid
expr_stmt|;
name|pc
operator|->
name|p_ruid
operator|=
name|ruid
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|SUGID
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxsetresgid_args
block|{
name|int
name|rgid
decl_stmt|;
name|int
name|egid
decl_stmt|;
name|int
name|sgid
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
name|hpuxsetresgid
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|hpuxsetresgid_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pcred
modifier|*
name|pc
init|=
name|p
operator|->
name|p_cred
decl_stmt|;
specifier|register
name|gid_t
name|rgid
decl_stmt|,
name|egid
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|rgid
operator|==
operator|-
literal|1
condition|)
name|rgid
operator|=
name|pc
operator|->
name|p_rgid
expr_stmt|;
else|else
name|rgid
operator|=
name|uap
operator|->
name|rgid
expr_stmt|;
comment|/* 	 * Allow setting real gid to previous effective, for swapping real and 	 * effective.  This didn't really work correctly in 4.[23], but is 	 * preserved so old stuff doesn't fail.  This should be: 	 * 	 * if (rgid != pc->p_rgid&& 	 *     (error = suser(pc->pc_ucred,&p->p_acflag))) 	 */
if|if
condition|(
name|rgid
operator|!=
name|pc
operator|->
name|p_rgid
operator|&&
name|rgid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
comment|/* XXX */
operator|&&
operator|(
name|error
operator|=
name|suser
argument_list|(
name|pc
operator|->
name|pc_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|egid
operator|==
operator|-
literal|1
condition|)
name|egid
operator|=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
else|else
name|egid
operator|=
name|uap
operator|->
name|egid
expr_stmt|;
if|if
condition|(
name|egid
operator|!=
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|&&
name|egid
operator|!=
name|pc
operator|->
name|p_rgid
operator|&&
name|egid
operator|!=
name|pc
operator|->
name|p_svgid
operator|&&
operator|(
name|error
operator|=
name|suser
argument_list|(
name|pc
operator|->
name|pc_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pc
operator|->
name|pc_ucred
operator|=
name|crcopy
argument_list|(
name|pc
operator|->
name|pc_ucred
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|=
name|egid
expr_stmt|;
name|pc
operator|->
name|p_rgid
operator|=
name|rgid
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|SUGID
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * XXX: simple recognition hack to see if we can make grmd work.  */
end_comment

begin_struct
struct|struct
name|hpuxlockf_args
block|{
name|int
name|fd
decl_stmt|;
name|int
name|func
decl_stmt|;
name|long
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxlockf
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hpuxlockf_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%d: lockf(%d, %d, %d)\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
name|uap
operator|->
name|func
argument_list|,
name|uap
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|hpuxgetaccess_args
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|int
name|ngroups
decl_stmt|;
name|int
modifier|*
name|gidset
decl_stmt|;
name|void
modifier|*
name|label
decl_stmt|;
name|void
modifier|*
name|privs
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|hpuxgetaccess
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hpuxgetaccess_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|lgroups
index|[
name|NGROUPS
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
comment|/* 	 * Build an appropriate credential structure 	 */
name|cred
operator|=
name|crdup
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|uid
condition|)
block|{
case|case
literal|65502
case|:
comment|/* UID_EUID */
break|break;
case|case
literal|65503
case|:
comment|/* UID_RUID */
name|cred
operator|->
name|cr_uid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
expr_stmt|;
break|break;
case|case
literal|65504
case|:
comment|/* UID_SUID */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|uap
operator|->
name|uid
operator|>
literal|65504
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|cred
operator|->
name|cr_uid
operator|=
name|uap
operator|->
name|uid
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|uap
operator|->
name|ngroups
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* NGROUPS_EGID */
name|cred
operator|->
name|cr_ngroups
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|-
literal|5
case|:
comment|/* NGROUPS_EGID_SUPP */
break|break;
case|case
operator|-
literal|2
case|:
comment|/* NGROUPS_RGID */
name|cred
operator|->
name|cr_ngroups
operator|=
literal|1
expr_stmt|;
name|cred
operator|->
name|cr_gid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_rgid
expr_stmt|;
break|break;
case|case
operator|-
literal|6
case|:
comment|/* NGROUPS_RGID_SUPP */
name|cred
operator|->
name|cr_gid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_rgid
expr_stmt|;
break|break;
case|case
operator|-
literal|3
case|:
comment|/* NGROUPS_SGID */
case|case
operator|-
literal|7
case|:
comment|/* NGROUPS_SGID_SUPP */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
operator|-
literal|4
case|:
comment|/* NGROUPS_SUPP */
if|if
condition|(
name|cred
operator|->
name|cr_ngroups
operator|>
literal|1
condition|)
name|cred
operator|->
name|cr_gid
operator|=
name|cred
operator|->
name|cr_groups
index|[
literal|1
index|]
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|uap
operator|->
name|ngroups
operator|>
literal|0
operator|&&
name|uap
operator|->
name|ngroups
operator|<=
name|NGROUPS
condition|)
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|gidset
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|lgroups
index|[
literal|0
index|]
argument_list|,
name|uap
operator|->
name|ngroups
operator|*
sizeof|sizeof
argument_list|(
name|lgroups
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|int
name|gid
decl_stmt|;
for|for
control|(
name|gid
operator|=
literal|0
init|;
name|gid
operator|<
name|uap
operator|->
name|ngroups
condition|;
name|gid
operator|++
control|)
name|cred
operator|->
name|cr_groups
index|[
name|gid
index|]
operator|=
name|lgroups
index|[
name|gid
index|]
expr_stmt|;
name|cred
operator|->
name|cr_ngroups
operator|=
name|uap
operator|->
name|ngroups
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	 * Lookup file using caller's effective IDs. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Use the constructed credentials for access checks. 	 */
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VREAD
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|retval
operator||=
name|R_OK
expr_stmt|;
if|if
condition|(
name|vn_writechk
argument_list|(
name|vp
argument_list|)
operator|==
literal|0
operator|&&
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VWRITE
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|retval
operator||=
name|W_OK
expr_stmt|;
comment|/* XXX we return X_OK for root on VREG even if not */
if|if
condition|(
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VEXEC
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|retval
operator||=
name|X_OK
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Brutal hack!  Map HP-UX u-area offsets into BSD u offsets.  * No apologies offered, if you don't like it, rewrite it!  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|kstack
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UOFF
parameter_list|(
name|f
parameter_list|)
value|((int)&((struct user *)0)->f)
end_define

begin_define
define|#
directive|define
name|HPUOFF
parameter_list|(
name|f
parameter_list|)
value|((int)&((struct hpuxuser *)0)->f)
end_define

begin_comment
comment|/* simplified FP structure */
end_comment

begin_struct
struct|struct
name|bsdfp
block|{
name|int
name|save
index|[
literal|54
index|]
decl_stmt|;
name|int
name|reg
index|[
literal|24
index|]
decl_stmt|;
name|int
name|ctrl
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|hpuxtobsduoff
argument_list|(
argument|off
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|off
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|ar0
init|=
name|curproc
operator|->
name|p_md
operator|.
name|md_regs
decl_stmt|;
name|struct
name|hpuxfp
modifier|*
name|hp
decl_stmt|;
name|struct
name|bsdfp
modifier|*
name|bp
decl_stmt|;
specifier|register
name|u_int
name|raddr
decl_stmt|;
comment|/* u_ar0 field; procxmt puts in U_ar0 */
if|if
condition|(
operator|(
name|int
operator|)
name|off
operator|==
name|HPUOFF
argument_list|(
name|hpuxu_ar0
argument_list|)
condition|)
return|return
operator|(
name|UOFF
argument_list|(
name|U_ar0
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|FPCOPROC
comment|/* 68881 registers from PCB */
name|hp
operator|=
operator|(
expr|struct
name|hpuxfp
operator|*
operator|)
name|HPUOFF
argument_list|(
name|hpuxu_fp
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|bsdfp
operator|*
operator|)
name|UOFF
argument_list|(
name|u_pcb
operator|.
name|pcb_fpregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|hp
operator|->
name|hpfp_ctrl
operator|&&
name|off
operator|<
operator|&
name|hp
operator|->
name|hpfp_ctrl
index|[
literal|3
index|]
condition|)
return|return
operator|(
operator|(
name|int
operator|)
operator|&
name|bp
operator|->
name|ctrl
index|[
name|off
operator|-
name|hp
operator|->
name|hpfp_ctrl
index|]
operator|)
return|;
if|if
condition|(
name|off
operator|>=
name|hp
operator|->
name|hpfp_reg
operator|&&
name|off
operator|<
operator|&
name|hp
operator|->
name|hpfp_reg
index|[
literal|24
index|]
condition|)
return|return
operator|(
operator|(
name|int
operator|)
operator|&
name|bp
operator|->
name|reg
index|[
name|off
operator|-
name|hp
operator|->
name|hpfp_reg
index|]
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * Everything else we recognize comes from the kernel stack, 	 * so we convert off to an absolute address (if not already) 	 * for simplicity. 	 */
if|if
condition|(
name|off
operator|<
operator|(
name|int
operator|*
operator|)
name|ctob
argument_list|(
name|UPAGES
argument_list|)
condition|)
name|off
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|u_int
operator|)
name|off
operator|+
operator|(
name|u_int
operator|)
name|kstack
operator|)
expr_stmt|;
comment|/* 	 * 68020 registers. 	 * We know that the HP-UX registers are in the same order as ours. 	 * The only difference is that their PS is 2 bytes instead of a 	 * padded 4 like ours throwing the alignment off. 	 */
if|if
condition|(
name|off
operator|>=
name|ar0
operator|&&
name|off
operator|<
operator|&
name|ar0
index|[
literal|18
index|]
condition|)
block|{
comment|/* 		 * PS: return low word and high word of PC as HP-UX would 		 * (e.g.&u.u_ar0[16.5]). 		 */
if|if
condition|(
name|off
operator|==
operator|&
name|ar0
index|[
name|PS
index|]
condition|)
name|raddr
operator|=
operator|(
name|u_int
operator|)
operator|&
operator|(
operator|(
name|short
operator|*
operator|)
name|ar0
operator|)
index|[
name|PS
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
comment|/* 		 * PC: off will be&u.u_ar0[16.5] 		 */
elseif|else
if|if
condition|(
name|off
operator|==
operator|(
name|int
operator|*
operator|)
operator|&
operator|(
operator|(
operator|(
name|short
operator|*
operator|)
name|ar0
operator|)
index|[
name|PS
operator|*
literal|2
operator|+
literal|1
index|]
operator|)
condition|)
name|raddr
operator|=
operator|(
name|u_int
operator|)
operator|&
name|ar0
index|[
name|PC
index|]
expr_stmt|;
comment|/* 		 * D0-D7, A0-A7: easy 		 */
else|else
name|raddr
operator|=
operator|(
name|u_int
operator|)
operator|&
name|ar0
index|[
call|(
name|int
call|)
argument_list|(
name|off
operator|-
name|ar0
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|raddr
operator|-
operator|(
name|u_int
operator|)
name|kstack
argument_list|)
operator|)
return|;
block|}
comment|/* everything else */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Kludge up a uarea dump so that HP-UX debuggers can find out  * what they need.  IMPORTANT NOTE: we do not EVEN attempt to  * convert the entire user struct.  */
end_comment

begin_macro
name|hpuxdumpu
argument_list|(
argument|vp
argument_list|,
argument|cred
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|hpuxuser
modifier|*
name|faku
decl_stmt|;
name|struct
name|bsdfp
modifier|*
name|bp
decl_stmt|;
name|short
modifier|*
name|foop
decl_stmt|;
name|faku
operator|=
operator|(
expr|struct
name|hpuxuser
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|u_long
operator|)
name|ctob
argument_list|(
literal|1
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure there is no mistake about this 	 * being a real user structure. 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|faku
argument_list|,
name|ctob
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the process sizes. 	 */
name|faku
operator|->
name|hpuxu_tsize
operator|=
name|p
operator|->
name|p_vmspace
operator|->
name|vm_tsize
expr_stmt|;
name|faku
operator|->
name|hpuxu_dsize
operator|=
name|p
operator|->
name|p_vmspace
operator|->
name|vm_dsize
expr_stmt|;
name|faku
operator|->
name|hpuxu_ssize
operator|=
name|p
operator|->
name|p_vmspace
operator|->
name|vm_ssize
expr_stmt|;
comment|/* 	 * Fill in the exec header for CDB. 	 * This was saved back in exec().  As far as I can tell CDB 	 * only uses this information to verify that a particular 	 * core file goes with a particular binary. 	 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_exec
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|faku
operator|->
name|hpuxu_exdata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpux_exec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Adjust user's saved registers (on kernel stack) to reflect 	 * HP-UX order.  Note that HP-UX saves the SR as 2 bytes not 4 	 * so we have to move it up. 	 */
name|faku
operator|->
name|hpuxu_ar0
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_regs
expr_stmt|;
name|foop
operator|=
operator|(
name|short
operator|*
operator|)
name|p
operator|->
name|p_md
operator|.
name|md_regs
expr_stmt|;
name|foop
index|[
literal|32
index|]
operator|=
name|foop
index|[
literal|33
index|]
expr_stmt|;
name|foop
index|[
literal|33
index|]
operator|=
name|foop
index|[
literal|34
index|]
expr_stmt|;
name|foop
index|[
literal|34
index|]
operator|=
name|foop
index|[
literal|35
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|FPCOPROC
comment|/* 	 * Copy 68881 registers from our PCB format to HP-UX format 	 */
name|bp
operator|=
operator|(
expr|struct
name|bsdfp
operator|*
operator|)
operator|&
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_fpregs
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
operator|->
name|save
argument_list|,
operator|(
name|caddr_t
operator|)
name|faku
operator|->
name|hpuxu_fp
operator|.
name|hpfp_save
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|save
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
operator|->
name|ctrl
argument_list|,
operator|(
name|caddr_t
operator|)
name|faku
operator|->
name|hpuxu_fp
operator|.
name|hpfp_ctrl
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|ctrl
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
operator|->
name|reg
argument_list|,
operator|(
name|caddr_t
operator|)
name|faku
operator|->
name|hpuxu_fp
operator|.
name|hpfp_reg
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|reg
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Slay the dragon 	 */
name|faku
operator|->
name|hpuxu_dragon
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Dump this artfully constructed page in place of the 	 * user struct page. 	 */
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
operator|(
name|caddr_t
operator|)
name|faku
argument_list|,
name|ctob
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
operator||
name|IO_UNIT
argument_list|,
name|cred
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Dump the remaining UPAGES-1 pages normally 	 */
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
name|kstack
operator|+
name|ctob
argument_list|(
literal|1
argument_list|)
argument_list|,
name|ctob
argument_list|(
name|UPAGES
operator|-
literal|1
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
name|ctob
argument_list|(
literal|1
argument_list|)
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
operator||
name|IO_UNIT
argument_list|,
name|cred
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|faku
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * The remaining routines are essentially the same as those in kern_xxx.c  * and vfs_xxx.c as defined under "#ifdef COMPAT".  We replicate them here  * to avoid HPUXCOMPAT dependencies in those files and to make sure that  * HP-UX compatibility still works even when COMPAT is not defined.  */
end_comment

begin_define
define|#
directive|define
name|HPUX_HZ
value|50
end_define

begin_include
include|#
directive|include
file|"sys/times.h"
end_include

begin_comment
comment|/* from old timeb.h */
end_comment

begin_struct
struct|struct
name|hpuxtimeb
block|{
name|time_t
name|time
decl_stmt|;
name|u_short
name|millitm
decl_stmt|;
name|short
name|timezone
decl_stmt|;
name|short
name|dstflag
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ye ole stat structure */
end_comment

begin_struct
struct|struct
name|ohpuxstat
block|{
name|u_short
name|ohst_dev
decl_stmt|;
name|u_short
name|ohst_ino
decl_stmt|;
name|u_short
name|ohst_mode
decl_stmt|;
name|short
name|ohst_nlink
decl_stmt|;
name|short
name|ohst_uid
decl_stmt|;
name|short
name|ohst_gid
decl_stmt|;
name|u_short
name|ohst_rdev
decl_stmt|;
name|int
name|ohst_size
decl_stmt|;
name|int
name|ohst_atime
decl_stmt|;
name|int
name|ohst_mtime
decl_stmt|;
name|int
name|ohst_ctime
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * SYS V style setpgrp()  */
end_comment

begin_expr_stmt
name|ohpuxsetpgrp
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|uap
decl_stmt|,
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|->
name|p_pid
operator|!=
name|p
operator|->
name|p_pgid
condition|)
name|enterpgrp
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
name|p
operator|->
name|p_pgid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|ohpuxtime_args
block|{
name|long
modifier|*
name|tp
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|ohpuxtime
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ohpuxtime_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|tp
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|time
operator|.
name|tv_sec
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|time_t
operator|*
operator|)
name|retval
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|ohpuxstime_args
block|{
name|int
name|time
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|ohpuxstime
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ohpuxstime_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|uap
operator|->
name|time
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* WHAT DO WE DO ABOUT PENDING REAL-TIME TIMEOUTS??? */
name|boottime
operator|.
name|tv_sec
operator|+=
name|tv
operator|.
name|tv_sec
operator|-
name|time
operator|.
name|tv_sec
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|time
operator|=
name|tv
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|resettodr
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|ohpuxftime_args
block|{
name|struct
name|hpuxtimeb
modifier|*
name|tp
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|ohpuxftime
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ohpuxftime_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|hpuxtimeb
name|tb
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|tb
operator|.
name|time
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|tb
operator|.
name|millitm
operator|=
name|time
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tb
operator|.
name|timezone
operator|=
name|tz
operator|.
name|tz_minuteswest
expr_stmt|;
name|tb
operator|.
name|dstflag
operator|=
name|tz
operator|.
name|tz_dsttime
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tb
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
name|tb
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|ohpuxalarm_args
block|{
name|int
name|deltat
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|ohpuxalarm
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|ohpuxalarm_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|untimeout
argument_list|(
name|realitexpire
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
argument_list|)
expr_stmt|;
name|timerclear
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_interval
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|timerisset
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
argument_list|)
operator|&&
name|timercmp
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
argument_list|,
operator|&
name|time
argument_list|,
operator|>
argument_list|)
condition|)
operator|*
name|retval
operator|=
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|-
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|deltat
operator|==
literal|0
condition|)
block|{
name|timerclear
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
operator|=
name|time
expr_stmt|;
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|+=
name|uap
operator|->
name|deltat
expr_stmt|;
name|timeout
argument_list|(
name|realitexpire
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
name|hzto
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|ohpuxnice_args
block|{
name|int
name|niceness
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|ohpuxnice
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|ohpuxnice_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|donice
argument_list|(
name|p
argument_list|,
name|p
argument_list|,
operator|(
name|p
operator|->
name|p_nice
operator|-
name|NZERO
operator|)
operator|+
name|uap
operator|->
name|niceness
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|retval
operator|=
name|p
operator|->
name|p_nice
operator|-
name|NZERO
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|ohpuxtimes_args
block|{
name|struct
name|tms
modifier|*
name|tmsb
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|ohpuxtimes
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ohpuxtimes_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|timeval
name|ru
decl_stmt|,
name|rs
decl_stmt|;
name|struct
name|tms
name|atms
decl_stmt|;
name|int
name|error
decl_stmt|;
name|calcru
argument_list|(
name|p
argument_list|,
operator|&
name|ru
argument_list|,
operator|&
name|rs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|atms
operator|.
name|tms_utime
operator|=
name|hpuxscale
argument_list|(
operator|&
name|ru
argument_list|)
expr_stmt|;
name|atms
operator|.
name|tms_stime
operator|=
name|hpuxscale
argument_list|(
operator|&
name|rs
argument_list|)
expr_stmt|;
name|atms
operator|.
name|tms_cutime
operator|=
name|hpuxscale
argument_list|(
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_cru
operator|.
name|ru_utime
argument_list|)
expr_stmt|;
name|atms
operator|.
name|tms_cstime
operator|=
name|hpuxscale
argument_list|(
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_cru
operator|.
name|ru_stime
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|atms
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tmsb
argument_list|,
sizeof|sizeof
argument_list|(
name|atms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
operator|(
name|time_t
operator|*
operator|)
name|retval
operator|=
name|hpuxscale
argument_list|(
operator|&
name|time
argument_list|)
operator|-
name|hpuxscale
argument_list|(
operator|&
name|boottime
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Doesn't exactly do what the documentation says.  * What we really do is return 1/HPUX_HZ-th of a second since that  * is what HP-UX returns.  */
end_comment

begin_expr_stmt
name|hpuxscale
argument_list|(
name|tvp
argument_list|)
specifier|register
expr|struct
name|timeval
operator|*
name|tvp
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|tvp
operator|->
name|tv_sec
operator|*
name|HPUX_HZ
operator|+
name|tvp
operator|->
name|tv_usec
operator|*
name|HPUX_HZ
operator|/
literal|1000000
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Set IUPD and IACC times on file.  * Can't set ICHG.  */
end_comment

begin_struct
struct|struct
name|ohpuxutime_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|time_t
modifier|*
name|tptr
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|ohpuxutime
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ohpuxutime_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|time_t
name|tv
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|tptr
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
name|tv
index|[
literal|0
index|]
operator|=
name|tv
index|[
literal|1
index|]
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|vattr_null
argument_list|(
operator|&
name|vattr
argument_list|)
expr_stmt|;
name|vattr
operator|.
name|va_atime
operator|.
name|ts_sec
operator|=
name|tv
index|[
literal|0
index|]
expr_stmt|;
name|vattr
operator|.
name|va_atime
operator|.
name|ts_nsec
operator|=
literal|0
expr_stmt|;
name|vattr
operator|.
name|va_mtime
operator|.
name|ts_sec
operator|=
name|tv
index|[
literal|1
index|]
expr_stmt|;
name|vattr
operator|.
name|va_mtime
operator|.
name|ts_nsec
operator|=
literal|0
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|fname
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
name|error
operator|=
name|EROFS
expr_stmt|;
else|else
name|error
operator|=
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|nd
operator|.
name|ni_cnd
operator|.
name|cn_cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|ohpuxpause
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|uap
decl_stmt|,
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|tsleep
argument_list|(
name|kstack
argument_list|,
name|PPAUSE
operator||
name|PCATCH
argument_list|,
literal|"pause"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* always return EINTR rather than ERESTART... */
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * The old fstat system call.  */
end_comment

begin_struct
struct|struct
name|ohpuxfstat_args
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|ohpuxstat
modifier|*
name|sb
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|ohpuxfstat
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ohpuxfstat_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|fd
operator|)
operator|>=
name|fdp
operator|->
name|fd_nfiles
operator|||
operator|(
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|fd
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_VNODE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|ohpuxstat1
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
argument_list|,
name|uap
operator|->
name|sb
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Old stat system call.  This version follows links.  */
end_comment

begin_struct
struct|struct
name|ohpuxstat_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|ohpuxstat
modifier|*
name|sb
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|ohpuxstat
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|ohpuxstat_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|fname
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ohpuxstat1
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|sb
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_function
name|int
name|ohpuxstat1
parameter_list|(
name|vp
parameter_list|,
name|ub
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|ohpuxstat
modifier|*
name|ub
decl_stmt|;
block|{
name|struct
name|ohpuxstat
name|ds
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|curproc
operator|->
name|p_ucred
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Copy from inode table 	 */
name|ds
operator|.
name|ohst_dev
operator|=
name|vattr
operator|.
name|va_fsid
expr_stmt|;
name|ds
operator|.
name|ohst_ino
operator|=
operator|(
name|short
operator|)
name|vattr
operator|.
name|va_fileid
expr_stmt|;
name|ds
operator|.
name|ohst_mode
operator|=
operator|(
name|u_short
operator|)
name|vattr
operator|.
name|va_mode
expr_stmt|;
name|ds
operator|.
name|ohst_nlink
operator|=
name|vattr
operator|.
name|va_nlink
expr_stmt|;
name|ds
operator|.
name|ohst_uid
operator|=
operator|(
name|short
operator|)
name|vattr
operator|.
name|va_uid
expr_stmt|;
name|ds
operator|.
name|ohst_gid
operator|=
operator|(
name|short
operator|)
name|vattr
operator|.
name|va_gid
expr_stmt|;
name|ds
operator|.
name|ohst_rdev
operator|=
operator|(
name|u_short
operator|)
name|vattr
operator|.
name|va_rdev
expr_stmt|;
name|ds
operator|.
name|ohst_size
operator|=
operator|(
name|int
operator|)
name|vattr
operator|.
name|va_size
expr_stmt|;
name|ds
operator|.
name|ohst_atime
operator|=
operator|(
name|int
operator|)
name|vattr
operator|.
name|va_atime
operator|.
name|ts_sec
expr_stmt|;
name|ds
operator|.
name|ohst_mtime
operator|=
operator|(
name|int
operator|)
name|vattr
operator|.
name|va_mtime
operator|.
name|ts_sec
expr_stmt|;
name|ds
operator|.
name|ohst_ctime
operator|=
operator|(
name|int
operator|)
name|vattr
operator|.
name|va_ctime
operator|.
name|ts_sec
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ds
argument_list|,
operator|(
name|caddr_t
operator|)
name|ub
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

