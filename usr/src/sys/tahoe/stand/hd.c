begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Stand alone driver for the HDC controller  *  *	@(#)hd.c	7.3 (Berkeley) %G%  */
end_comment

begin_define
define|#
directive|define
name|KERNEL
end_define

begin_include
include|#
directive|include
file|"machine/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"inode.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tahoevba/dsk.h"
end_include

begin_include
include|#
directive|include
file|"tahoevba/dskio.h"
end_include

begin_include
include|#
directive|include
file|"tahoevba/hdc.h"
end_include

begin_include
include|#
directive|include
file|"saio.h"
end_include

begin_define
define|#
directive|define
name|NHD
value|4
end_define

begin_define
define|#
directive|define
name|NDRIVE
value|8
end_define

begin_comment
comment|/* drives per controller */
end_comment

begin_define
define|#
directive|define
name|HDSLAVE
parameter_list|(
name|x
parameter_list|)
value|((x) % NDRIVE)
end_define

begin_define
define|#
directive|define
name|HDCTLR
parameter_list|(
name|x
parameter_list|)
value|((x) / NDRIVE)
end_define

begin_define
define|#
directive|define
name|HDREG
parameter_list|(
name|x
parameter_list|)
value|(ctlr_addr->x)
end_define

begin_comment
comment|/* standalone io to an hdc register */
end_comment

begin_define
define|#
directive|define
name|HID_HDC
value|0x01
end_define

begin_comment
comment|/* hvme_id for HDC */
end_comment

begin_comment
comment|/*  * hdc controller table. It contains information about the hdc controller.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|ctlr
decl_stmt|;
comment|/* controller number (0-15)         */
name|hdc_regs_type
modifier|*
name|registers
decl_stmt|;
comment|/* base address of hdc io registers */
name|hdc_mid_type
name|mid
decl_stmt|;
comment|/* the module id is read to here    */
name|master_mcb_type
name|master_mcb
decl_stmt|;
comment|/* the master mcb for this hdc      */
name|mcb_type
name|mcb
decl_stmt|;
comment|/* an mcb for i/o to the controller */
block|}
name|hdctlr_type
typedef|;
end_typedef

begin_decl_stmt
name|hdctlr_type
name|hdc_ctlr
index|[
name|HDC_MAXCTLR
index|]
index|[
name|HDC_MAXBUS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * hdc unit table. It contains information about the hdc drive.  * Some information is obtained from the profile prom and geometry block.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|par_tab
name|partition
index|[
name|GB_MAXPART
index|]
decl_stmt|;
comment|/* partition definitions            */
name|int
name|ctlr
decl_stmt|;
comment|/* the controller number (0-15)     */
name|int
name|slave
decl_stmt|;
comment|/* the slave number (0-4)           */
name|int
name|unit
decl_stmt|;
comment|/* the unit number (0-31)           */
name|int
name|id
decl_stmt|;
comment|/* identifies the disk model        */
name|int
name|cylinders
decl_stmt|;
comment|/* number of logical cylinders      */
name|int
name|heads
decl_stmt|;
comment|/* number of logical heads          */
name|int
name|sectors
decl_stmt|;
comment|/* number of logical sectors/track  */
name|int
name|phys_cylinders
decl_stmt|;
comment|/* number of physical cylinders     */
name|int
name|phys_heads
decl_stmt|;
comment|/* number of physical heads         */
name|int
name|phys_sectors
decl_stmt|;
comment|/* number of physical sectors/track */
name|int
name|def_cyl
decl_stmt|;
comment|/* logical cylinder of drive def    */
name|int
name|def_cyl_count
decl_stmt|;
comment|/* number of logical def cylinders  */
name|int
name|diag_cyl
decl_stmt|;
comment|/* logical cylinder of diag area    */
name|int
name|diag_cyl_count
decl_stmt|;
comment|/* number of logical diag cylinders */
name|int
name|rpm
decl_stmt|;
comment|/* disk rpm                         */
name|int
name|bytes_per_sec
decl_stmt|;
comment|/* bytes/sector -vendorflaw conversn*/
name|int
name|format
decl_stmt|;
comment|/* format program is active         */
name|u_long
name|phio_data
index|[
name|HDC_PHIO_SIZE
index|]
decl_stmt|;
comment|/* data for physical io     */
block|}
name|hdunit_type
typedef|;
end_typedef

begin_decl_stmt
name|hdunit_type
name|hdc_unit
index|[
name|HDC_MAXDRIVE
index|]
index|[
name|HDC_MAXCTLR
index|]
index|[
name|HDC_MAXBUS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************* *  Procedure:	hdopen * *  Description:	The hdc open routine. Initializes the hdc and reads the *		hdc status and the geometry block. * *  Returns:	 0  open was successful *		-1  this is not an hdc controller **************************************************************************/
end_comment

begin_expr_stmt
name|hdopen
argument_list|(
name|io
argument_list|)
specifier|register
expr|struct
name|iob
operator|*
name|io
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* i/o block */
end_comment

begin_block
block|{
name|mcb_type
modifier|*
name|mcb
decl_stmt|;
comment|/* an mcb to send commands to hdc   */
name|hdunit_type
modifier|*
name|hu
decl_stmt|;
comment|/* disk unit information table      */
name|hdctlr_type
modifier|*
name|hc
decl_stmt|;
comment|/* hdc ctlr information table       */
name|hdc_mid_type
modifier|*
name|id
decl_stmt|;
comment|/* the hdc module id                */
name|geometry_sector
name|geometry
decl_stmt|;
comment|/* the geometry block sector        */
name|geometry_block
modifier|*
name|geo
decl_stmt|;
comment|/* the geometry block               */
name|drive_stat_type
name|status
decl_stmt|;
comment|/* the hdc status is read to here   */
name|long
name|ctlr
decl_stmt|;
comment|/* the controller number            */
name|long
name|junk
decl_stmt|;
comment|/* badaddr will write junk here     */
name|int
name|par
decl_stmt|;
comment|/* partition number                 */
name|int
name|drive
decl_stmt|;
comment|/* the drive number                 */
name|int
name|bus
decl_stmt|;
comment|/* the bus number                   */
name|int
name|i
decl_stmt|;
comment|/* temp                             */
name|hdc_regs_type
modifier|*
name|ctlr_addr
decl_stmt|;
comment|/* hdc i/o registers                */
name|par
operator|=
name|io
operator|->
name|i_boff
expr_stmt|;
comment|/* io->i_part;	*/
name|bus
operator|=
literal|0
expr_stmt|;
comment|/* io->i_bus;	*/
name|ctlr
operator|=
name|HDCTLR
argument_list|(
name|io
operator|->
name|i_unit
argument_list|)
expr_stmt|;
comment|/* io->i_ctlr;	*/
name|drive
operator|=
name|HDSLAVE
argument_list|(
name|io
operator|->
name|i_unit
argument_list|)
expr_stmt|;
comment|/* io->i_drive;	*/
name|hu
operator|=
operator|&
name|hdc_unit
index|[
name|drive
index|]
index|[
name|ctlr
index|]
index|[
name|bus
index|]
expr_stmt|;
name|hc
operator|=
operator|&
name|hdc_ctlr
index|[
name|ctlr
index|]
index|[
name|bus
index|]
expr_stmt|;
name|mcb
operator|=
operator|&
name|hc
operator|->
name|mcb
expr_stmt|;
comment|/* 	 * Validate the device specification 	 */
if|if
condition|(
name|ctlr
operator|>=
name|HDC_MAXCTLR
condition|)
block|{
name|printf
argument_list|(
literal|"invalid controller number\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|drive
operator|<
literal|0
operator|||
name|drive
operator|>
name|HDC_MAXDRIVE
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: bad drive number.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EUNIT
operator|)
return|;
block|}
if|if
condition|(
name|par
operator|<
literal|0
operator|||
name|par
operator|>
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: bad partition number.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EUNIT
operator|)
return|;
block|}
name|ctlr_addr
operator|=
operator|(
name|hdc_regs_type
operator|*
operator|)
operator|(
name|bus
operator|==
literal|0
condition|?
literal|0xC0000000
operator||
name|ctlr
operator|<<
literal|24
operator||
name|HDC_MID
operator|<<
literal|16
else|:
literal|0x80000000
operator||
name|ctlr
operator|<<
literal|24
operator||
name|HDC_MID
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* 	 * Init drive structure. 	 */
name|hu
operator|->
name|slave
operator|=
name|drive
expr_stmt|;
name|hc
operator|->
name|registers
operator|=
name|ctlr_addr
expr_stmt|;
comment|/* 	 * Insure that this is an hdc, then reset the hdc. 	 */
name|junk
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wbadaddr
argument_list|(
operator|&
name|ctlr_addr
operator|->
name|module_id_reg
argument_list|,
literal|4
argument_list|,
operator|&
name|junk
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"hd%d: %x: invalid csr\n"
argument_list|,
name|ctlr
argument_list|,
operator|(
name|u_int
operator|)
name|ctlr_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|HDREG
argument_list|(
name|soft_reset_reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
comment|/* 	 * Read in the hdc module id word.  The controller is bad if the 	 * hdc's writeable control store is not loaded or if the hdc failed 	 * the functional integrity test for any reason. 	 */
name|id
operator|=
operator|&
name|hc
operator|->
name|mid
expr_stmt|;
name|HDREG
argument_list|(
name|module_id_reg
argument_list|)
operator|=
operator|(
name|u_long
operator|)
name|id
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|PADC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|module_id
operator|!=
operator|(
name|u_char
operator|)
name|HDC_MID
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: Controller bad module id: id = %x\n"
argument_list|,
name|id
operator|->
name|module_id
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|id
operator|->
name|code_rev
operator|==
operator|(
name|u_char
operator|)
literal|0xFF
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: Controller micro-code is not loaded.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|id
operator|->
name|fit
operator|!=
operator|(
name|u_char
operator|)
literal|0xFF
condition|)
block|{
name|printf
argument_list|(
literal|"hdc:  Controller FIT test failed: error= %x\n"
argument_list|,
name|id
operator|->
name|fit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Read the drive status. Save important info. 	 */
name|mcb
operator|->
name|command
operator|=
name|HCMD_STATUS
expr_stmt|;
name|mcb
operator|->
name|drive
operator|=
name|drive
expr_stmt|;
name|mcb
operator|->
name|cyl
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|sector
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|lwc
operator|=
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|drive_stat_type
argument_list|)
operator|/
literal|4
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|ta
operator|=
operator|(
name|long
operator|)
operator|&
name|status
expr_stmt|;
if|if
condition|(
name|hdmcb
argument_list|(
name|mcb
argument_list|,
name|io
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|hu
operator|->
name|cylinders
operator|=
name|status
operator|.
name|max_cyl
operator|+
literal|1
expr_stmt|;
name|hu
operator|->
name|heads
operator|=
name|status
operator|.
name|max_head
operator|+
literal|1
expr_stmt|;
name|hu
operator|->
name|sectors
operator|=
name|status
operator|.
name|max_sector
operator|+
literal|1
expr_stmt|;
name|hu
operator|->
name|def_cyl
operator|=
name|status
operator|.
name|def_cyl
expr_stmt|;
name|hu
operator|->
name|def_cyl_count
operator|=
name|status
operator|.
name|def_cyl_count
expr_stmt|;
name|hu
operator|->
name|diag_cyl
operator|=
name|status
operator|.
name|diag_cyl
expr_stmt|;
name|hu
operator|->
name|diag_cyl_count
operator|=
name|status
operator|.
name|diag_cyl_count
expr_stmt|;
name|hu
operator|->
name|phys_cylinders
operator|=
name|status
operator|.
name|max_phys_cyl
operator|+
literal|1
expr_stmt|;
name|hu
operator|->
name|phys_heads
operator|=
name|status
operator|.
name|max_phys_head
operator|+
literal|1
expr_stmt|;
name|hu
operator|->
name|phys_sectors
operator|=
name|status
operator|.
name|max_phys_sector
operator|+
literal|1
expr_stmt|;
name|hu
operator|->
name|bytes_per_sec
operator|=
name|status
operator|.
name|bytes_per_sec
expr_stmt|;
name|hu
operator|->
name|id
operator|=
name|status
operator|.
name|id
expr_stmt|;
name|hu
operator|->
name|rpm
operator|=
name|status
operator|.
name|rpm
expr_stmt|;
name|hu
operator|->
name|partition
index|[
name|HDC_DEFPART
index|]
operator|.
name|start
operator|=
name|hu
operator|->
name|def_cyl
operator|*
name|hu
operator|->
name|sectors
operator|*
name|hu
operator|->
name|heads
operator|/
name|HDC_SPB
expr_stmt|;
name|hu
operator|->
name|partition
index|[
name|HDC_DEFPART
index|]
operator|.
name|length
operator|=
name|hu
operator|->
name|def_cyl_count
operator|*
name|hu
operator|->
name|sectors
operator|*
name|hu
operator|->
name|heads
operator|/
name|HDC_SPB
expr_stmt|;
name|io
operator|->
name|i_boff
operator|=
name|hu
operator|->
name|partition
index|[
name|HDC_DEFPART
index|]
operator|.
name|start
expr_stmt|;
comment|/* default */
comment|/* 	 * Report drive down if anything in the drive status is bad. 	 * If fault condition, reading geo will try to clear the fault. 	 */
if|if
condition|(
name|status
operator|.
name|drs
operator|&
name|DRS_FAULT
condition|)
name|printf
argument_list|(
literal|"hdc: clearing drive fault.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|.
name|drs
operator|&
name|DRS_ONLINE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: drive is not online.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Read the geometry block (at head=0 sector=0 of the drive 	 * definition cylinder), validate it (must have the correct 	 * version number, header, and checksum). 	 */
name|geo
operator|=
operator|&
name|geometry
operator|.
name|geometry_block
expr_stmt|;
name|mcb
operator|->
name|command
operator|=
name|HCMD_READ
expr_stmt|;
name|mcb
operator|->
name|drive
operator|=
name|drive
expr_stmt|;
name|mcb
operator|->
name|cyl
operator|=
name|status
operator|.
name|def_cyl
expr_stmt|;
name|mcb
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|sector
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|lwc
operator|=
sizeof|sizeof
argument_list|(
name|geometry_sector
argument_list|)
operator|/
literal|4
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|ta
operator|=
operator|(
name|long
operator|)
operator|&
name|geometry
expr_stmt|;
if|if
condition|(
name|hdmcb
argument_list|(
name|mcb
argument_list|,
name|io
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: could not read geometry block\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|io
operator|->
name|i_boff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|geo
operator|->
name|version
operator|>
literal|64000
operator|||
name|geo
operator|->
name|version
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: bad geometry block version#\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|geo
operator|->
name|id
index|[
literal|0
index|]
argument_list|,
name|GB_ID
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: bad geometry block header\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|GB_CHECKSUM
argument_list|(
name|geo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|geometry
operator|.
name|checksum
operator|!=
name|i
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: bad geometry block checksum\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Set the partition start/size info. 	 * Note: this info was already defaulted to be the disk 	 * definition partition. 	 */
if|if
condition|(
name|par
operator|!=
name|HDC_DEFPART
condition|)
if|if
condition|(
name|geo
operator|->
name|partition
index|[
name|par
index|]
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hdc:  null partition\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
else|else
block|{
name|hu
operator|->
name|partition
index|[
name|par
index|]
operator|.
name|start
operator|=
name|geo
operator|->
name|partition
index|[
name|par
index|]
operator|.
name|start
expr_stmt|;
name|hu
operator|->
name|partition
index|[
name|par
index|]
operator|.
name|length
operator|=
name|geo
operator|->
name|partition
index|[
name|par
index|]
operator|.
name|length
expr_stmt|;
name|io
operator|->
name|i_boff
operator|=
name|hu
operator|->
name|partition
index|[
name|par
index|]
operator|.
name|start
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/************************************************************************* *  Procedure:	hdstrategy * *  Description:	The hdc strategy routine. This routine does the disk *		reads/writes. If this is the format program, read/writes *		are forced to be within the disk definition partition. * *  Returns:	The number of bytes transfered. **************************************************************************/
end_comment

begin_expr_stmt
name|hdstrategy
argument_list|(
name|io
argument_list|,
name|cmd
argument_list|)
specifier|register
expr|struct
name|iob
operator|*
name|io
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* i/o block */
end_comment

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i/o operation to perform */
end_comment

begin_block
block|{
name|mcb_type
modifier|*
name|mcb
decl_stmt|;
comment|/* mcb to send to the hdc           */
name|hdunit_type
modifier|*
name|hu
decl_stmt|;
comment|/* disk unit information table      */
name|hdctlr_type
modifier|*
name|hc
decl_stmt|;
comment|/* hdc ctlr information table       */
name|long
name|err
decl_stmt|;
comment|/* error code                       */
name|long
name|sector
decl_stmt|;
comment|/* sector number for i/o            */
name|int
name|partstart
decl_stmt|;
comment|/* block number of partition start  */
name|int
name|partlen
decl_stmt|;
comment|/* number of blocks in partition    */
name|int
name|bytes
decl_stmt|;
comment|/* number of bytes to transfer      */
name|int
name|bus
decl_stmt|;
comment|/* bus number	                    */
name|int
name|ctlr
decl_stmt|;
comment|/* the controller number            */
name|int
name|drive
decl_stmt|;
comment|/* the drive number                 */
name|bus
operator|=
literal|0
expr_stmt|;
comment|/* io->i_bus;	*/
name|ctlr
operator|=
name|HDCTLR
argument_list|(
name|io
operator|->
name|i_unit
argument_list|)
expr_stmt|;
comment|/* io->i_ctlr;	*/
name|drive
operator|=
name|HDSLAVE
argument_list|(
name|io
operator|->
name|i_unit
argument_list|)
expr_stmt|;
comment|/* io->i_drive;	*/
name|hu
operator|=
operator|&
name|hdc_unit
index|[
name|drive
index|]
index|[
name|ctlr
index|]
index|[
name|bus
index|]
expr_stmt|;
name|hc
operator|=
operator|&
name|hdc_ctlr
index|[
name|ctlr
index|]
index|[
name|bus
index|]
expr_stmt|;
comment|/* 	 * Only the format program can access the disk definition tracks. 	 */
if|if
condition|(
name|io
operator|->
name|i_boff
operator|==
name|HDC_DEFPART
operator|&&
operator|!
name|hu
operator|->
name|format
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: partition 7 is protected\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Insure the transfer fits in the partition. 	 * Set and validate transfer size. 	 */
name|partstart
operator|=
name|hu
operator|->
name|partition
index|[
name|io
operator|->
name|i_boff
index|]
operator|.
name|start
expr_stmt|;
name|partlen
operator|=
name|hu
operator|->
name|partition
index|[
name|io
operator|->
name|i_boff
index|]
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|i_bn
operator|<
name|partstart
operator|||
name|io
operator|->
name|i_bn
operator|>=
name|partstart
operator|+
name|partlen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bytes
operator|=
name|MIN
argument_list|(
name|io
operator|->
name|i_cc
argument_list|,
name|DEV_BSIZE
operator|*
operator|(
name|partstart
operator|+
name|partlen
operator|-
name|io
operator|->
name|i_bn
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|i_cc
operator|&
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: i/o not a longword multiple\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Set up the mcb and send it to the hdc. 	 */
name|mcb
operator|=
operator|&
name|hc
operator|->
name|mcb
expr_stmt|;
name|sector
operator|=
name|io
operator|->
name|i_bn
operator|*
name|HDC_SPB
expr_stmt|;
name|mcb
operator|->
name|command
operator|=
operator|(
name|cmd
operator|==
name|READ
operator|)
condition|?
name|HCMD_READ
else|:
name|HCMD_WRITE
expr_stmt|;
name|mcb
operator|->
name|drive
operator|=
name|hu
operator|->
name|slave
expr_stmt|;
name|mcb
operator|->
name|cyl
operator|=
name|sector
operator|/
operator|(
name|hu
operator|->
name|sectors
operator|*
name|hu
operator|->
name|heads
operator|)
expr_stmt|;
name|mcb
operator|->
name|head
operator|=
operator|(
name|sector
operator|/
name|hu
operator|->
name|sectors
operator|)
operator|%
name|hu
operator|->
name|heads
expr_stmt|;
name|mcb
operator|->
name|sector
operator|=
name|sector
operator|%
name|hu
operator|->
name|sectors
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|ta
operator|=
operator|(
name|u_long
operator|)
name|io
operator|->
name|i_ma
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|lwc
operator|=
operator|(
name|bytes
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|err
operator|=
name|hdmcb
argument_list|(
name|mcb
argument_list|,
name|io
argument_list|)
expr_stmt|;
name|io
operator|->
name|i_error
operator|=
name|err
expr_stmt|;
return|return
operator|(
name|err
condition|?
literal|0
else|:
name|bytes
operator|)
return|;
block|}
end_block

begin_comment
comment|/************************************************************************* *  Procedure:	hdioctl * *  Description:	ioctl routine. * *  Returns:	0	no errors *		non-0	error **************************************************************************/
end_comment

begin_macro
name|hdioctl
argument_list|(
argument|io
argument_list|,
argument|command
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iob
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i/o block */
end_comment

begin_decl_stmt
name|int
name|command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The ioctl commmand */
end_comment

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data.  Format depends on ioctl */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|mcb_type
modifier|*
name|mcb
decl_stmt|;
name|hdunit_type
modifier|*
name|hu
decl_stmt|;
comment|/* disk unit information table	*/
name|hdctlr_type
modifier|*
name|hc
decl_stmt|;
comment|/* hdc ctlr information table	*/
name|int
name|bus
decl_stmt|;
comment|/* bus number			*/
name|int
name|ctlr
decl_stmt|;
comment|/* the controller number	*/
name|int
name|drive
decl_stmt|;
comment|/* the drive number		*/
name|bus
operator|=
literal|0
expr_stmt|;
comment|/* io->i_bus;	*/
name|ctlr
operator|=
name|HDCTLR
argument_list|(
name|io
operator|->
name|i_unit
argument_list|)
expr_stmt|;
comment|/* io->i_ctlr;	*/
name|drive
operator|=
name|HDSLAVE
argument_list|(
name|io
operator|->
name|i_unit
argument_list|)
expr_stmt|;
comment|/* io->i_drive;	*/
name|hu
operator|=
operator|&
name|hdc_unit
index|[
name|drive
index|]
index|[
name|ctlr
index|]
index|[
name|bus
index|]
expr_stmt|;
name|hc
operator|=
operator|&
name|hdc_ctlr
index|[
name|ctlr
index|]
index|[
name|bus
index|]
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|DSKIOCFORMAT
case|:
block|{
comment|/* 		 * Format a disk track. The received argument is a pointer 		 * to a "formatop" structure describing the track to format. 		 * 		 * Set up a buffer with each longword corresponding to a 		 * sector on the track; a 1 means no flaw, a 0 means a flaw. 		 * Send an mcb to the hdc to format the track. 		 */
specifier|register
name|struct
name|formatop
modifier|*
name|track
decl_stmt|;
if|if
condition|(
operator|!
name|hu
operator|->
name|format
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|track
operator|=
operator|(
expr|struct
name|formatop
operator|*
operator|)
name|arg
expr_stmt|;
name|mcb
operator|=
operator|&
name|hc
operator|->
name|mcb
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hu
operator|->
name|phys_sectors
condition|;
name|i
operator|++
control|)
name|hu
operator|->
name|phio_data
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|track
operator|->
name|flaw_count
condition|;
name|i
operator|++
control|)
name|hu
operator|->
name|phio_data
index|[
name|track
operator|->
name|flaw
index|[
name|i
index|]
index|]
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|command
operator|=
name|HCMD_FORMAT
expr_stmt|;
name|mcb
operator|->
name|drive
operator|=
name|hu
operator|->
name|slave
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|ta
operator|=
operator|(
name|u_long
operator|)
name|hu
operator|->
name|phio_data
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|lwc
operator|=
name|hu
operator|->
name|phys_sectors
expr_stmt|;
name|mcb
operator|->
name|cyl
operator|=
name|track
operator|->
name|cylinder
expr_stmt|;
name|mcb
operator|->
name|head
operator|=
name|track
operator|->
name|head
expr_stmt|;
name|mcb
operator|->
name|sector
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdmcb
argument_list|(
name|mcb
argument_list|,
name|io
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
block|}
case|case
name|DSKIOCCERTIFY
case|:
block|{
comment|/* 		 * Certify a disk track. The received argument is a pointer 		 * to a "formatop" structure describing the track to certify. 		 * 		 * Send an mcb to the hdc to certify the track. 		 * The controller returns data in which each longword 		 * corresponds to a sector on the track; a 1 means no flaw, 		 * a 0 means a flaw. 		 */
specifier|register
name|struct
name|formatop
modifier|*
name|track
decl_stmt|;
if|if
condition|(
operator|!
name|hu
operator|->
name|format
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|track
operator|=
operator|(
expr|struct
name|formatop
operator|*
operator|)
name|arg
expr_stmt|;
name|mcb
operator|=
operator|&
name|hc
operator|->
name|mcb
expr_stmt|;
name|mcb
operator|->
name|command
operator|=
name|HCMD_CERTIFY
expr_stmt|;
name|mcb
operator|->
name|drive
operator|=
name|hu
operator|->
name|slave
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|ta
operator|=
operator|(
name|u_long
operator|)
name|hu
operator|->
name|phio_data
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|lwc
operator|=
name|hu
operator|->
name|phys_sectors
expr_stmt|;
name|mcb
operator|->
name|cyl
operator|=
name|track
operator|->
name|cylinder
expr_stmt|;
name|mcb
operator|->
name|head
operator|=
name|track
operator|->
name|head
expr_stmt|;
name|mcb
operator|->
name|sector
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdmcb
argument_list|(
name|mcb
argument_list|,
name|io
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|track
operator|->
name|flaw_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hu
operator|->
name|phys_sectors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|track
operator|->
name|flaw_count
operator|>=
name|MAXVFLAW
condition|)
break|break;
if|if
condition|(
name|hu
operator|->
name|phio_data
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|track
operator|->
name|flaw
index|[
name|track
operator|->
name|flaw_count
index|]
operator|=
name|i
expr_stmt|;
name|track
operator|->
name|flaw_count
operator|++
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|DSKIOCVERIFY
case|:
block|{
comment|/* 		 * Verify a disk track. The received argument is a pointer 		 * to a "formatop" structure describing the track to verify. 		 */
specifier|register
name|struct
name|formatop
modifier|*
name|track
decl_stmt|;
if|if
condition|(
operator|!
name|hu
operator|->
name|format
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|track
operator|=
operator|(
expr|struct
name|formatop
operator|*
operator|)
name|arg
expr_stmt|;
name|mcb
operator|=
operator|&
name|hc
operator|->
name|mcb
expr_stmt|;
name|mcb
operator|->
name|command
operator|=
name|HCMD_VERIFY
expr_stmt|;
name|mcb
operator|->
name|drive
operator|=
name|hu
operator|->
name|slave
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|ta
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|lwc
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|cyl
operator|=
name|track
operator|->
name|cylinder
expr_stmt|;
name|mcb
operator|->
name|head
operator|=
name|track
operator|->
name|head
expr_stmt|;
name|mcb
operator|->
name|sector
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdmcb
argument_list|(
name|mcb
argument_list|,
name|io
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
block|}
case|case
name|DSKIOCFORMATCTL
case|:
block|{
comment|/* 		 * This ioctl provides special format control. 		 * Currently the valid arguments are: 		 * 		 * arg = 0	disable formatting; 		 * 		 * arg = 1	enable formatting (allow privileged access); 		 *		formatting must not already be enabled; 		 *		For formatting, change to use partition 7. 		 */
if|if
condition|(
name|arg
operator|<
literal|0
operator|||
name|arg
operator|>
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|arg
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|hu
operator|->
name|format
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If not already formatting.... */
name|hu
operator|->
name|format
operator|=
literal|1
expr_stmt|;
comment|/* io->i_part = HDC_DEFPART; */
name|io
operator|->
name|i_boff
operator|=
name|hu
operator|->
name|partition
index|[
name|HDC_DEFPART
index|]
operator|.
name|start
expr_stmt|;
block|}
else|else
name|hu
operator|->
name|format
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|DSKIOCSTATUS
case|:
block|{
comment|/* 		 * Return info about the disk. Caller's parameter is a 		 * pointer to a dsk_status structure. 		 */
specifier|register
name|dsk_status
modifier|*
name|status
decl_stmt|;
name|status
operator|=
operator|(
name|dsk_status
operator|*
operator|)
name|arg
expr_stmt|;
name|status
operator|->
name|id
operator|=
name|hu
operator|->
name|id
expr_stmt|;
name|status
operator|->
name|drive_status
operator|=
literal|0
expr_stmt|;
name|status
operator|->
name|rpm
operator|=
name|hu
operator|->
name|rpm
expr_stmt|;
name|status
operator|->
name|bytes_per_sec
operator|=
name|hu
operator|->
name|bytes_per_sec
expr_stmt|;
name|status
operator|->
name|cylinders
operator|=
name|hu
operator|->
name|cylinders
expr_stmt|;
name|status
operator|->
name|heads
operator|=
name|hu
operator|->
name|heads
expr_stmt|;
name|status
operator|->
name|sectors
operator|=
name|hu
operator|->
name|sectors
expr_stmt|;
name|status
operator|->
name|phys_cylinders
operator|=
name|hu
operator|->
name|phys_cylinders
expr_stmt|;
name|status
operator|->
name|phys_heads
operator|=
name|hu
operator|->
name|phys_heads
expr_stmt|;
name|status
operator|->
name|phys_sectors
operator|=
name|hu
operator|->
name|phys_sectors
expr_stmt|;
name|status
operator|->
name|diag_cyl
operator|=
name|hu
operator|->
name|diag_cyl
expr_stmt|;
name|status
operator|->
name|diag_cylinders
operator|=
name|hu
operator|->
name|diag_cyl_count
expr_stmt|;
name|status
operator|->
name|def_cyl
operator|=
name|hu
operator|->
name|def_cyl
expr_stmt|;
name|status
operator|->
name|def_cylinders
operator|=
name|hu
operator|->
name|def_cyl_count
expr_stmt|;
break|break;
block|}
case|case
name|DSKIOCVENDORFLAW
case|:
block|{
comment|/* 		 * Return vendor flaw info. 		 * 		 * Read in the vendor data (data for each track is at 		 * relative sector 0 of the track); then copy the 		 * vendor flaw data to the caller's buffer. 		 */
specifier|register
name|vflaw_type
modifier|*
name|vflaw
decl_stmt|;
specifier|register
name|struct
name|flaw
modifier|*
name|vendor
decl_stmt|;
if|if
condition|(
operator|!
name|hu
operator|->
name|format
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|vflaw
operator|=
operator|(
name|vflaw_type
operator|*
operator|)
name|arg
expr_stmt|;
name|mcb
operator|=
operator|&
name|hc
operator|->
name|mcb
expr_stmt|;
name|mcb
operator|->
name|command
operator|=
name|HCMD_VENDOR
expr_stmt|;
name|mcb
operator|->
name|drive
operator|=
name|hu
operator|->
name|slave
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|lwc
operator|=
name|HDC_VDATA_SIZE
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|ta
operator|=
operator|(
name|u_long
operator|)
name|hu
operator|->
name|phio_data
expr_stmt|;
name|mcb
operator|->
name|cyl
operator|=
name|vflaw
operator|->
name|cylinder
expr_stmt|;
name|mcb
operator|->
name|head
operator|=
name|vflaw
operator|->
name|head
expr_stmt|;
name|mcb
operator|->
name|sector
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdmcb
argument_list|(
name|mcb
argument_list|,
name|io
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|vendor
operator|=
operator|(
expr|struct
name|flaw
operator|*
operator|)
operator|&
name|hu
operator|->
name|phio_data
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXVFLAW
condition|;
name|i
operator|++
control|)
block|{
name|vflaw
operator|->
name|flaw
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|vendor
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
name|vflaw
operator|->
name|flaw
index|[
name|i
index|]
operator|.
name|length
operator|=
name|vendor
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/************************************************************************* *  Procedure:	hdmcb * *  Description:	Internal routine used to send mcb's to the hdc. * *  Returns:	0		normal *		non-zero	error occurred **************************************************************************/
end_comment

begin_expr_stmt
name|hdmcb
argument_list|(
name|mcb
argument_list|,
name|io
argument_list|)
specifier|register
name|mcb_type
operator|*
name|mcb
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* mcb to send to the hdc	*/
end_comment

begin_decl_stmt
specifier|register
name|struct
name|iob
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i/o block			*/
end_comment

begin_block
block|{
name|master_mcb_type
modifier|*
name|master_mcb
decl_stmt|;
comment|/* the hdc's master mcb		*/
name|hdctlr_type
modifier|*
name|hc
decl_stmt|;
comment|/* hdc ctlr information table	*/
name|hdc_regs_type
modifier|*
name|ctlr_addr
decl_stmt|;
comment|/* pointer to hdc i/o registers	*/
name|int
name|timeout
decl_stmt|;
comment|/* used to timeout the mcb	*/
name|int
name|bus
decl_stmt|;
comment|/* bus number			*/
name|int
name|ctlr
decl_stmt|;
comment|/* the controller number	*/
name|int
name|i
decl_stmt|,
name|end
decl_stmt|;
name|u_int
modifier|*
name|ptr
decl_stmt|;
name|bus
operator|=
literal|0
expr_stmt|;
comment|/* io->i_bus;	*/
name|ctlr
operator|=
name|HDCTLR
argument_list|(
name|io
operator|->
name|i_unit
argument_list|)
expr_stmt|;
comment|/* io->i_ctlr;	*/
name|hc
operator|=
operator|&
name|hdc_ctlr
index|[
name|ctlr
index|]
index|[
name|bus
index|]
expr_stmt|;
name|mcb
operator|->
name|interrupt
operator|=
name|FALSE
expr_stmt|;
name|mcb
operator|->
name|priority
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|forw_phaddr
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|context
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|reserved
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|reserved
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|master_mcb
operator|=
operator|&
name|hc
operator|->
name|master_mcb
expr_stmt|;
name|master_mcb
operator|->
name|forw_phaddr
operator|=
operator|(
name|long
operator|)
operator|&
name|mcb
operator|->
name|forw_phaddr
expr_stmt|;
name|master_mcb
operator|->
name|mcs
operator|=
literal|0
expr_stmt|;
name|master_mcb
operator|->
name|interrupt
operator|=
literal|0
expr_stmt|;
name|master_mcb
operator|->
name|reserve1
operator|=
literal|0
expr_stmt|;
name|master_mcb
operator|->
name|reserve2
operator|=
literal|0
expr_stmt|;
name|master_mcb
operator|->
name|context
operator|=
literal|0
expr_stmt|;
name|master_mcb
operator|->
name|mcl
operator|=
name|MCL_IMMEDIATE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDC_XSTAT_SIZE
condition|;
name|i
operator|++
control|)
name|master_mcb
operator|->
name|xstatus
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ctlr_addr
operator|=
name|hc
operator|->
name|registers
expr_stmt|;
name|HDREG
argument_list|(
name|master_mcb_reg
argument_list|)
operator|=
operator|(
name|u_long
operator|)
name|master_mcb
expr_stmt|;
name|timeout
operator|=
literal|15000
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|PADC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|master_mcb
operator|->
name|mcs
operator|&
name|MCS_DONE
operator|&&
operator|!
operator|(
name|master_mcb
operator|->
name|mcs
operator|&
name|MCS_FATALERROR
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|timeout
operator|--
expr_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
operator|&&
operator|!
operator|(
name|master_mcb
operator|->
name|mcs
operator|&
name|MCS_FATALERROR
operator|)
condition|)
continue|continue;
if|if
condition|(
name|master_mcb
operator|->
name|mcs
operator|&
name|MCS_FATALERROR
condition|)
name|printf
argument_list|(
literal|"hdc: controller fatal error\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"hdc: controller timed out\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mmcb: "
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|u_int
operator|*
operator|)
name|master_mcb
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
operator|+
name|HDC_XSTAT_SIZE
init|;
name|i
operator|>
literal|7
condition|;
name|i
operator|--
control|)
block|{
name|end
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mcb:  "
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|u_int
operator|*
operator|)
operator|&
name|mcb
operator|->
name|forw_phaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|6
init|;
name|i
operator|<
literal|72
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|printf
argument_list|(
literal|"  %x %x"
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|,
name|ptr
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ptr
index|[
name|i
index|]
operator|&
literal|0x80000000
operator|)
condition|)
break|break;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_block

end_unit

