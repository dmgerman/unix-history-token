begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)verify.c	1.5 (Berkeley/CCI) 6/7/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"vdfmt.h"
end_include

begin_define
define|#
directive|define
name|verbose
value|1
end_define

begin_comment
comment|/* ** */
end_comment

begin_macro
name|verify
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|boolean
name|read_bad_sector_map
parameter_list|()
function_decl|;
name|cur
operator|.
name|state
operator|=
name|vfy
expr_stmt|;
name|print
argument_list|(
literal|"Starting verification on "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"controller %d, drive %d, "
argument_list|,
name|cur
operator|.
name|controller
argument_list|,
name|cur
operator|.
name|drive
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"type %s.\n"
argument_list|,
name|lab
operator|->
name|d_typename
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_formatted
argument_list|()
operator|==
name|true
condition|)
block|{
if|if
condition|(
name|read_bad_sector_map
argument_list|()
operator|==
name|true
condition|)
block|{
if|if
condition|(
name|bad_map
operator|->
name|bs_id
operator|==
name|D_INFO
operator|->
name|id
condition|)
block|{
name|verify_users_data_area
argument_list|()
expr_stmt|;
name|writelabel
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|print
argument_list|(
literal|"I can't verify drives with old formats.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|print
argument_list|(
literal|"I can't verify unformatted drives.\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|load_verify_patterns
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|index
decl_stmt|;
specifier|register
name|struct
name|flawpat
modifier|*
name|fp
init|=
operator|(
expr|struct
name|flawpat
operator|*
operator|)
name|lab
operator|->
name|d_pat
decl_stmt|;
comment|/* Init bad block pattern array */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|MAXTRKSIZ
condition|;
name|index
operator|++
control|)
block|{
name|pattern_0
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|0
index|]
expr_stmt|;
name|pattern_1
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|1
index|]
expr_stmt|;
name|pattern_2
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|2
index|]
expr_stmt|;
name|pattern_3
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|3
index|]
expr_stmt|;
name|pattern_4
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|4
index|]
expr_stmt|;
name|pattern_5
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|5
index|]
expr_stmt|;
name|pattern_6
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|6
index|]
expr_stmt|;
name|pattern_7
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|7
index|]
expr_stmt|;
name|pattern_8
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|8
index|]
expr_stmt|;
name|pattern_9
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|9
index|]
expr_stmt|;
name|pattern_10
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|10
index|]
expr_stmt|;
name|pattern_12
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|12
index|]
expr_stmt|;
name|pattern_13
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|13
index|]
expr_stmt|;
name|pattern_14
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|14
index|]
expr_stmt|;
name|pattern_15
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|fp_pat
index|[
literal|15
index|]
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|verify_relocation_area
argument_list|()
end_macro

begin_block
block|{
name|cur
operator|.
name|substate
operator|=
name|sub_vfy
expr_stmt|;
name|verify_cylinders
argument_list|(
operator|(
name|int
operator|)
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMSYS
argument_list|,
name|NUMREL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|sync_bad_sector_map
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|verify_users_data_area
argument_list|()
end_macro

begin_block
block|{
name|int
name|pats
init|=
name|ops_to_do
index|[
name|cur
operator|.
name|controller
index|]
index|[
name|cur
operator|.
name|drive
index|]
operator|.
name|numpat
decl_stmt|;
name|cur
operator|.
name|substate
operator|=
name|sub_vfy
expr_stmt|;
name|verify_cylinders
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMSYS
argument_list|,
name|pats
argument_list|)
expr_stmt|;
name|sync_bad_sector_map
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_macro
name|verify_maintenence_area
argument_list|()
end_macro

begin_block
block|{
name|cur
operator|.
name|substate
operator|=
name|sub_vfy
expr_stmt|;
name|verify_cylinders
argument_list|(
name|lab
operator|->
name|d_ncylinders
operator|-
name|NUMSYS
operator|+
name|NUMREL
argument_list|,
name|NUMMNT
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|sync_bad_sector_map
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	verify_cylinders does full track certification for every track ** on the cylinder. */
end_comment

begin_macro
name|verify_cylinders
argument_list|(
argument|base_cyl
argument_list|,
argument|cyl_count
argument_list|,
argument|pats
argument_list|)
end_macro

begin_decl_stmt
name|int
name|base_cyl
decl_stmt|,
name|cyl_count
decl_stmt|,
name|pats
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dskadr
name|dskaddr
decl_stmt|;
if|if
condition|(
name|pats
operator|==
literal|0
condition|)
return|return;
comment|/* verify each track of each cylinder */
for|for
control|(
name|dskaddr
operator|.
name|cylinder
operator|=
name|base_cyl
init|;
name|dskaddr
operator|.
name|cylinder
operator|<
name|base_cyl
operator|+
name|cyl_count
condition|;
name|dskaddr
operator|.
name|cylinder
operator|++
control|)
for|for
control|(
name|dskaddr
operator|.
name|track
operator|=
literal|0
init|;
name|dskaddr
operator|.
name|track
operator|<
name|lab
operator|->
name|d_ntracks
condition|;
name|dskaddr
operator|.
name|track
operator|++
control|)
name|verify_track
argument_list|(
operator|&
name|dskaddr
argument_list|,
name|pats
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	verify_track verifies a single track.  If a full-track write fails, ** the sector is flagged; if a full-track read fails, then each sector ** is read individually to determine which sectors are really bad. ** If a sector is bad it is flagged as bad by flag_sector. */
end_comment

begin_macro
name|verify_track
argument_list|(
argument|dskaddr
argument_list|,
argument|pats
argument_list|,
argument|verbosity
argument_list|)
end_macro

begin_decl_stmt
name|dskadr
modifier|*
name|dskaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbosity
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|index
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|long
name|before
decl_stmt|;
specifier|register
name|long
modifier|*
name|after
decl_stmt|;
specifier|register
name|long
name|offset
init|=
name|lab
operator|->
name|d_secsize
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
decl_stmt|;
name|int
name|pattern_count
init|=
name|pats
decl_stmt|;
if|if
condition|(
name|pats
operator|==
literal|0
condition|)
return|return;
name|dskaddr
operator|->
name|sector
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
name|access_dsk
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pattern_address
index|[
literal|0
index|]
argument_list|,
name|dskaddr
argument_list|,
name|VDOP_WD
argument_list|,
name|lab
operator|->
name|d_nsectors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|pattern_count
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|data_ok
argument_list|()
condition|)
block|{
if|if
condition|(
name|dcb
operator|.
name|operrsta
operator|&
name|HEADER_ERROR
operator|&&
name|C_INFO
operator|->
name|type
operator|==
name|VDTYPE_SMDE
condition|)
block|{
name|flag_sector
argument_list|(
name|dskaddr
argument_list|,
name|dcb
operator|.
name|operrsta
argument_list|,
name|dcb
operator|.
name|err_code
argument_list|,
literal|"write"
argument_list|,
name|verbosity
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|indent
argument_list|()
expr_stmt|;
name|vd_error
argument_list|(
literal|"write track"
argument_list|)
expr_stmt|;
name|exdent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* 			 * we presume that write errors will be detected 			 * on read or data compare, 			 * don't bother with extra testing. 			 */
if|if
condition|(
name|dcb
operator|.
name|operrsta
operator|&
name|DATA_ERROR
condition|)
name|pattern_count
operator|=
literal|16
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Write track a sector at a time, 			 * so that a write aborted on one sector 			 * doesn't cause compare errors on all 			 * subsequent sectors on the track. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lab
operator|->
name|d_nsectors
condition|;
name|i
operator|++
control|)
block|{
name|dskaddr
operator|->
name|sector
operator|=
name|i
expr_stmt|;
name|access_dsk
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pattern_address
index|[
name|index
index|]
argument_list|,
name|dskaddr
argument_list|,
name|VDOP_WD
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|dskaddr
operator|->
name|sector
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
block|}
name|access_dsk
argument_list|(
operator|(
name|char
operator|*
operator|)
name|scratch
argument_list|,
name|dskaddr
argument_list|,
name|VDOP_RD
argument_list|,
name|lab
operator|->
name|d_nsectors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data_ok
argument_list|()
condition|)
block|{
if|if
condition|(
name|dcb
operator|.
name|operrsta
operator|&
name|HEADER_ERROR
condition|)
block|{
name|flag_sector
argument_list|(
name|dskaddr
argument_list|,
name|dcb
operator|.
name|operrsta
argument_list|,
name|dcb
operator|.
name|err_code
argument_list|,
literal|"read"
argument_list|,
name|verbosity
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lab
operator|->
name|d_nsectors
condition|;
name|i
operator|++
control|)
block|{
name|dskaddr
operator|->
name|sector
operator|=
name|i
expr_stmt|;
name|access_dsk
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|scratch
index|[
name|i
operator|*
name|offset
index|]
argument_list|,
name|dskaddr
argument_list|,
name|VDOP_RD
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data_ok
argument_list|()
condition|)
name|flag_sector
argument_list|(
name|dskaddr
argument_list|,
name|dcb
operator|.
name|operrsta
argument_list|,
name|dcb
operator|.
name|err_code
argument_list|,
literal|"read"
argument_list|,
name|verbosity
argument_list|)
expr_stmt|;
block|}
name|dskaddr
operator|->
name|sector
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|+
literal|1
operator|<
name|pattern_count
condition|)
name|access_dsk
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pattern_address
index|[
name|index
operator|+
literal|1
index|]
argument_list|,
name|dskaddr
argument_list|,
name|VDOP_WD
argument_list|,
name|lab
operator|->
name|d_nsectors
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
name|lab
operator|->
name|d_nsectors
operator|*
name|offset
expr_stmt|;
name|before
operator|=
operator|*
name|pattern_address
index|[
name|index
index|]
expr_stmt|;
name|after
operator|=
name|scratch
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
control|)
block|{
if|if
condition|(
name|before
operator|!=
operator|*
operator|(
name|after
operator|++
operator|)
condition|)
block|{
name|dskaddr
operator|->
name|sector
operator|=
call|(
name|char
call|)
argument_list|(
name|i
operator|/
name|offset
argument_list|)
expr_stmt|;
name|flag_sector
argument_list|(
name|dskaddr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"data compare"
argument_list|,
name|verbosity
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|dskaddr
operator|->
name|sector
operator|+
literal|1
operator|)
operator|*
name|offset
expr_stmt|;
name|after
operator|=
name|scratch
operator|+
name|i
expr_stmt|;
block|}
else|else
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|+
literal|1
operator|<
name|pattern_count
condition|)
block|{
name|poll
argument_list|(
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdtimeout
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" while writing track.\n"
argument_list|)
expr_stmt|;
name|_longjmp
argument_list|(
name|abort_environ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|kill_processes
operator|==
name|true
condition|)
block|{
name|sync_bad_sector_map
argument_list|()
expr_stmt|;
name|_longjmp
argument_list|(
name|quit_environ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check again in case of header error */
if|if
condition|(
name|kill_processes
operator|==
name|true
condition|)
block|{
name|sync_bad_sector_map
argument_list|()
expr_stmt|;
name|_longjmp
argument_list|(
name|quit_environ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|flag_sector
argument_list|(
argument|dskaddr
argument_list|,
argument|status
argument_list|,
argument|ecode
argument_list|,
argument|func
argument_list|,
argument|verbosity
argument_list|)
end_macro

begin_decl_stmt
name|dskadr
modifier|*
name|dskaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ecode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|func
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbosity
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fmt_err
name|error
decl_stmt|;
name|bs_entry
name|entry
decl_stmt|;
name|int
name|result
decl_stmt|;
name|error
operator|.
name|err_adr
operator|=
operator|*
name|dskaddr
expr_stmt|;
name|error
operator|.
name|err_stat
operator|=
name|status
expr_stmt|;
call|(
modifier|*
name|C_INFO
operator|->
name|code_pos
call|)
argument_list|(
operator|&
name|error
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
name|result
operator|=
name|add_flaw
argument_list|(
operator|&
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|!=
literal|0
operator|&&
name|result
operator|!=
literal|0
condition|)
block|{
name|indent
argument_list|()
expr_stmt|;
name|print
argument_list|(
literal|"%s error at sector %d (cyl %d trk %d sect %d)"
argument_list|,
name|func
argument_list|,
name|to_sector
argument_list|(
operator|*
name|dskaddr
argument_list|)
argument_list|,
name|dskaddr
operator|->
name|cylinder
argument_list|,
name|dskaddr
operator|->
name|track
argument_list|,
name|dskaddr
operator|->
name|sector
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|printf
argument_list|(
literal|",\n"
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|"  status=%b"
argument_list|,
name|status
argument_list|,
name|VDERRBITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|C_INFO
operator|->
name|type
operator|==
name|VDTYPE_SMDE
operator|&&
name|ecode
condition|)
name|printf
argument_list|(
literal|", ecode=0x%x"
argument_list|,
name|ecode
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
literal|1
case|:
name|print
argument_list|(
literal|"%s will be relocated.\n"
argument_list|,
operator|(
name|status
operator|&
name|HEADER_ERROR
operator|&&
name|C_INFO
operator|->
name|type
operator|==
name|VDTYPE_SMDE
operator|)
condition|?
literal|"Track"
else|:
literal|"Sector"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|print
argument_list|(
literal|"Sector cannot be relocated.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|exdent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

