begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	vd.c	1.6	86/01/20	*/
end_comment

begin_include
include|#
directive|include
file|"fsd.h"
end_include

begin_if
if|#
directive|if
name|NVD
operator|>
literal|0
end_if

begin_comment
comment|/*  * VDDC - Versabus SMD/ESMD driver.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VDDCPERF
end_ifdef

begin_define
define|#
directive|define
name|DOSCOPE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../tahoe/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"dk.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbavar.h"
end_include

begin_define
define|#
directive|define
name|VDGENDATA
end_define

begin_include
include|#
directive|include
file|"../tahoevba/vddcreg.h"
end_include

begin_undef
undef|#
directive|undef
name|VDGENDATA
end_undef

begin_include
include|#
directive|include
file|"../tahoevba/scope.h"
end_include

begin_define
define|#
directive|define
name|VDMAXIO
value|(MAXBPTE*NBPG)
end_define

begin_define
define|#
directive|define
name|DUMPSIZE
value|64
end_define

begin_comment
comment|/* controller limit */
end_comment

begin_define
define|#
directive|define
name|VDUNIT
parameter_list|(
name|x
parameter_list|)
value|(minor(x)>> 3)
end_define

begin_define
define|#
directive|define
name|FILSYS
parameter_list|(
name|x
parameter_list|)
value|(minor(x)& 0x07)
end_define

begin_define
define|#
directive|define
name|PHYS
parameter_list|(
name|x
parameter_list|)
value|(vtoph((struct proc *)0, (unsigned)(x)))
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|CTLR_ERROR
value|1
end_define

begin_define
define|#
directive|define
name|DRIVE_ERROR
value|2
end_define

begin_define
define|#
directive|define
name|HARD_DATA_ERROR
value|3
end_define

begin_define
define|#
directive|define
name|SOFT_DATA_ERROR
value|4
end_define

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_define
define|#
directive|define
name|b_daddr
value|b_error
end_define

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|vdminfo
index|[
name|NVD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vddinfo
index|[
name|NFSD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vdprobe
argument_list|()
decl_stmt|,
name|vdslave
argument_list|()
decl_stmt|,
name|vdattach
argument_list|()
decl_stmt|,
name|vddgo
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|vddriver
init|=
block|{
name|vdprobe
block|,
name|vdslave
block|,
name|vdattach
block|,
name|vddgo
block|,
name|vddcaddr
block|,
literal|"smd/fsd"
block|,
name|vddinfo
block|,
literal|"vd"
block|,
name|vdminfo
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Per-drive state.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|buf
name|raw_q_element
decl_stmt|;
name|short
name|sec_per_blk
decl_stmt|;
name|short
name|sec_per_cyl
decl_stmt|;
name|char
name|status
decl_stmt|;
name|struct
name|buf
name|xfer_queue
decl_stmt|;
name|int
name|drive_type
decl_stmt|;
name|fs_tab
name|info
decl_stmt|;
block|}
name|unit_tab
typedef|;
end_typedef

begin_comment
comment|/*  * Per-controller state.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
name|ctlr_type
decl_stmt|;
comment|/* controller type */
name|struct
name|pte
modifier|*
name|map
decl_stmt|;
comment|/* i/o page map */
name|caddr_t
name|utl
decl_stmt|;
comment|/* mapped i/o space */
name|u_int
name|cur_slave
range|:
literal|8
decl_stmt|;
comment|/* last active unit number */
name|u_int
name|int_expected
range|:
literal|1
decl_stmt|;
comment|/* expect an interupt */
name|u_int
name|ctlr_started
range|:
literal|1
decl_stmt|;
comment|/* start command was issued */
name|u_int
name|overlap_seeks
range|:
literal|1
decl_stmt|;
comment|/* should overlap seeks */
name|u_int
name|initdone
range|:
literal|1
decl_stmt|;
comment|/* controller initialization completed */
name|u_int
name|off_cylinder
range|:
literal|16
decl_stmt|;
comment|/* off cylinder bit map */
name|u_int
name|unit_type
index|[
literal|16
index|]
decl_stmt|;
comment|/* slave types */
name|u_int
name|cur_cyl
index|[
literal|16
index|]
decl_stmt|;
comment|/* cylinder last selected */
name|long
name|cur_trk
index|[
literal|16
index|]
decl_stmt|;
comment|/* track last selected */
name|fmt_mdcb
name|ctlr_mdcb
decl_stmt|;
comment|/* controller mdcb */
name|fmt_dcb
name|ctlr_dcb
decl_stmt|;
comment|/* r/w dcb */
name|fmt_dcb
name|seek_dcb
index|[
literal|4
index|]
decl_stmt|;
comment|/* dcbs for overlapped seeks */
comment|/* buffer for raw/swap i/o */
name|char
name|rawbuf
index|[
name|VDMAXIO
index|]
decl_stmt|;
block|}
name|ctlr_tab
typedef|;
end_typedef

begin_decl_stmt
name|ctlr_tab
name|vdctlr_info
index|[
name|NVD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unit_tab
name|vdunit_info
index|[
name|NFSD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * See if the controller is really there; if so, initialize it.  */
end_comment

begin_macro
name|vdprobe
argument_list|(
argument|reg
argument_list|,
argument|vm
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|br
operator|,
name|cvec
expr_stmt|;
comment|/* must be r12, r11 */
specifier|register
name|cdr
modifier|*
name|addr
init|=
operator|(
name|cdr
operator|*
operator|)
name|reg
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|reg
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ci
operator|=
operator|&
name|vdctlr_info
index|[
name|vm
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|addr
operator|->
name|cdr_reset
operator|=
literal|0xffffffff
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|cdr_reset
operator|!=
operator|(
name|unsigned
operator|)
literal|0xffffffff
condition|)
block|{
name|ci
operator|->
name|ctlr_type
operator|=
name|SMDCTLR
expr_stmt|;
name|ci
operator|->
name|overlap_seeks
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ci
operator|->
name|overlap_seeks
operator|=
literal|1
expr_stmt|;
name|ci
operator|->
name|ctlr_type
operator|=
name|SMD_ECTLR
expr_stmt|;
name|addr
operator|->
name|cdr_reserved
operator|=
literal|0x0
expr_stmt|;
name|DELAY
argument_list|(
literal|3000000
argument_list|)
expr_stmt|;
name|addr
operator|->
name|cdr_csr
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|mdcb_tcf
operator|=
name|AM_ENPDA
expr_stmt|;
name|addr
operator|->
name|dcb_tcf
operator|=
name|AM_ENPDA
expr_stmt|;
name|addr
operator|->
name|trail_tcf
operator|=
name|AM_ENPDA
expr_stmt|;
name|addr
operator|->
name|data_tcf
operator|=
name|AM_ENPDA
expr_stmt|;
name|addr
operator|->
name|cdr_ccf
operator|=
name|CCF_STS
operator||
name|XMD_32BIT
operator||
name|BSZ_16WRD
operator||
name|CCF_ENP
operator||
name|CCF_EPE
operator||
name|CCF_EDE
operator||
name|CCF_ECE
operator||
name|CCF_ERR
expr_stmt|;
block|}
comment|/* 	 * Allocate page tables. 	 */
name|vbmapalloc
argument_list|(
name|btoc
argument_list|(
name|VDMAXIO
argument_list|)
operator|+
literal|1
argument_list|,
operator|&
name|ci
operator|->
name|map
argument_list|,
operator|&
name|ci
operator|->
name|utl
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize all the drives to be of an unknown type. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
name|ci
operator|->
name|unit_type
index|[
name|i
index|]
operator|=
name|UNKNOWN
expr_stmt|;
name|br
operator|=
literal|0x17
operator|,
name|cvec
operator|=
literal|0xe0
operator|+
name|vm
operator|->
name|um_ctlr
expr_stmt|;
comment|/* XXX */
return|return
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * See if a drive is really there  * Try to reset/configure the drive, then test its status.  */
end_comment

begin_expr_stmt
name|vdslave
argument_list|(
name|vi
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|cdr
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|vdctlr_info
index|[
name|vi
operator|->
name|ui_ctlr
index|]
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|vdunit_info
index|[
name|vi
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|fmt_mdcb
modifier|*
name|mdcb
init|=
operator|&
name|ci
operator|->
name|ctlr_mdcb
decl_stmt|;
specifier|register
name|fmt_dcb
modifier|*
name|dcb
init|=
operator|&
name|ci
operator|->
name|ctlr_dcb
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|ci
operator|->
name|initdone
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: %s controller\n"
argument_list|,
name|vi
operator|->
name|ui_ctlr
argument_list|,
name|ci
operator|->
name|ctlr_type
operator|==
name|SMDCTLR
condition|?
literal|"smd"
else|:
literal|"xsmd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdnotrailer
argument_list|(
name|addr
argument_list|,
name|vi
operator|->
name|ui_ctlr
argument_list|,
name|vi
operator|->
name|ui_slave
argument_list|,
name|INIT
argument_list|,
literal|10
argument_list|)
operator|&
name|HRDERR
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: init error\n"
argument_list|,
name|vi
operator|->
name|ui_ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|vdnotrailer
argument_list|(
name|addr
argument_list|,
name|vi
operator|->
name|ui_ctlr
argument_list|,
name|vi
operator|->
name|ui_slave
argument_list|,
name|DIAG
argument_list|,
literal|10
argument_list|)
operator|&
name|HRDERR
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: diagnostic error\n"
argument_list|,
name|vi
operator|->
name|ui_ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ci
operator|->
name|initdone
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Seek on all drive types starting from the largest one. 	 * a successful seek to the last sector/cylinder/track verifies  	 * the drive type connected to this port.  	 */
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|nvddrv
condition|;
name|type
operator|++
control|)
block|{
comment|/* XXX */
if|if
condition|(
name|ci
operator|->
name|ctlr_type
operator|==
name|SMDCTLR
operator|&&
name|vdst
index|[
name|type
index|]
operator|.
name|nsec
operator|!=
literal|32
condition|)
continue|continue;
comment|/* XXX */
if|if
condition|(
operator|!
name|vdconfigure_drive
argument_list|(
name|addr
argument_list|,
name|vi
operator|->
name|ui_ctlr
argument_list|,
name|vi
operator|->
name|ui_slave
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dcb
operator|->
name|opcode
operator|=
operator|(
name|short
operator|)
name|RD
expr_stmt|;
name|dcb
operator|->
name|intflg
operator|=
name|NOINT
expr_stmt|;
name|dcb
operator|->
name|nxtdcb
operator|=
operator|(
name|fmt_dcb
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* end of chain */
name|dcb
operator|->
name|operrsta
operator|=
literal|0
expr_stmt|;
name|dcb
operator|->
name|devselect
operator|=
call|(
name|char
call|)
argument_list|(
name|vi
operator|->
name|ui_slave
argument_list|)
expr_stmt|;
name|dcb
operator|->
name|trailcnt
operator|=
call|(
name|char
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|trrw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|memadr
operator|=
operator|(
name|char
operator|*
operator|)
name|PHYS
argument_list|(
name|ci
operator|->
name|rawbuf
argument_list|)
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|wcount
operator|=
name|vdst
index|[
name|type
index|]
operator|.
name|secsize
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|cylinder
operator|=
name|vdst
index|[
name|type
index|]
operator|.
name|ncyl
operator|-
literal|2
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|track
operator|=
name|vdst
index|[
name|type
index|]
operator|.
name|ntrak
operator|-
literal|1
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|sector
operator|=
name|vdst
index|[
name|type
index|]
operator|.
name|nsec
operator|-
literal|1
expr_stmt|;
name|mdcb
operator|->
name|firstdcb
operator|=
operator|(
name|fmt_dcb
operator|*
operator|)
operator|(
name|PHYS
argument_list|(
name|dcb
argument_list|)
operator|)
expr_stmt|;
name|mdcb
operator|->
name|vddcstat
operator|=
literal|0
expr_stmt|;
name|VDDC_ATTENTION
argument_list|(
name|addr
argument_list|,
operator|(
name|fmt_mdcb
operator|*
operator|)
operator|(
name|PHYS
argument_list|(
name|mdcb
argument_list|)
operator|)
argument_list|,
name|ci
operator|->
name|ctlr_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdpoll
argument_list|(
name|ci
argument_list|,
name|addr
argument_list|,
literal|60
argument_list|)
condition|)
name|printf
argument_list|(
literal|" during probe\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dcb
operator|->
name|operrsta
operator|&
name|HRDERR
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|type
operator|>=
name|nvddrv
condition|)
block|{
comment|/* 		 * If reached here, a drive which is not defined in the  		 * 'vdst' tables is connected. Cannot set it's type. 		 */
name|printf
argument_list|(
literal|"vd%d: unknown drive type\n"
argument_list|,
name|vi
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ui
operator|->
name|drive_type
operator|=
name|type
expr_stmt|;
name|ui
operator|->
name|info
operator|=
name|vdst
index|[
name|type
index|]
expr_stmt|;
name|ui
operator|->
name|sec_per_blk
operator|=
name|DEV_BSIZE
operator|/
name|ui
operator|->
name|info
operator|.
name|secsize
expr_stmt|;
name|vi
operator|->
name|ui_type
operator|=
name|type
expr_stmt|;
name|vi
operator|->
name|ui_dk
operator|=
literal|1
expr_stmt|;
name|vddriver
operator|.
name|ud_dname
operator|=
name|ui
operator|->
name|info
operator|.
name|type_name
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|vdconfigure_drive
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|,
name|slave
argument_list|,
name|type
argument_list|,
name|pass
argument_list|)
specifier|register
name|cdr
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|type
decl_stmt|,
name|pass
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|vdctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
name|ci
operator|->
name|ctlr_dcb
operator|.
name|opcode
operator|=
name|RSTCFG
expr_stmt|;
comment|/* command */
name|ci
operator|->
name|ctlr_dcb
operator|.
name|intflg
operator|=
name|NOINT
expr_stmt|;
name|ci
operator|->
name|ctlr_dcb
operator|.
name|nxtdcb
operator|=
operator|(
name|fmt_dcb
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* end of chain */
name|ci
operator|->
name|ctlr_dcb
operator|.
name|operrsta
operator|=
literal|0
expr_stmt|;
name|ci
operator|->
name|ctlr_dcb
operator|.
name|devselect
operator|=
operator|(
name|char
operator|)
name|slave
expr_stmt|;
name|ci
operator|->
name|ctlr_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|ncyl
operator|=
name|vdst
index|[
name|type
index|]
operator|.
name|ncyl
expr_stmt|;
name|ci
operator|->
name|ctlr_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|nsurfaces
operator|=
name|vdst
index|[
name|type
index|]
operator|.
name|ntrak
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ctlr_type
operator|==
name|SMD_ECTLR
condition|)
block|{
name|ci
operator|->
name|ctlr_dcb
operator|.
name|trailcnt
operator|=
operator|(
name|char
operator|)
literal|4
expr_stmt|;
name|ci
operator|->
name|ctlr_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|nsectors
operator|=
name|vdst
index|[
name|type
index|]
operator|.
name|nsec
expr_stmt|;
name|ci
operator|->
name|ctlr_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|slip_sec
operator|=
name|vdst
index|[
name|type
index|]
operator|.
name|nslip
expr_stmt|;
block|}
else|else
name|ci
operator|->
name|ctlr_dcb
operator|.
name|trailcnt
operator|=
operator|(
name|char
operator|)
literal|2
expr_stmt|;
name|ci
operator|->
name|ctlr_mdcb
operator|.
name|firstdcb
operator|=
operator|(
name|fmt_dcb
operator|*
operator|)
operator|(
name|PHYS
argument_list|(
operator|&
name|ci
operator|->
name|ctlr_dcb
argument_list|)
operator|)
expr_stmt|;
name|ci
operator|->
name|ctlr_mdcb
operator|.
name|vddcstat
operator|=
literal|0
expr_stmt|;
name|VDDC_ATTENTION
argument_list|(
name|addr
argument_list|,
operator|(
name|fmt_mdcb
operator|*
operator|)
operator|(
name|PHYS
argument_list|(
operator|&
name|ci
operator|->
name|ctlr_mdcb
argument_list|)
operator|)
argument_list|,
name|ci
operator|->
name|ctlr_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdpoll
argument_list|(
name|ci
argument_list|,
name|addr
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" during config\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ci
operator|->
name|ctlr_dcb
operator|.
name|operrsta
operator|&
name|HRDERR
condition|)
block|{
if|if
condition|(
operator|(
name|ci
operator|->
name|ctlr_dcb
operator|.
name|operrsta
operator|&
operator|(
name|NOTCYLERR
operator||
name|DRVNRDY
operator|)
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"vd%d: drive %d: config error\n"
argument_list|,
name|ctlr
argument_list|,
name|slave
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|vdstart_drive
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|,
name|slave
argument_list|)
expr_stmt|;
return|return
operator|(
name|vdconfigure_drive
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|,
name|slave
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|pass
operator|==
literal|2
condition|)
return|return
operator|(
name|vdconfigure_drive
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|,
name|slave
argument_list|,
name|type
argument_list|,
literal|3
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|vdstart_drive
argument_list|(
argument|addr
argument_list|,
argument|ctlr
argument_list|,
argument|slave
argument_list|)
end_macro

begin_decl_stmt
name|cdr
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"vd%d: starting drive %d, wait..."
argument_list|,
name|ctlr
argument_list|,
name|slave
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdctlr_info
index|[
name|ctlr
index|]
operator|.
name|ctlr_started
condition|)
block|{
name|printf
argument_list|(
literal|"DELAY(5500000)..."
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5500000
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|vdctlr_info
index|[
name|ctlr
index|]
operator|.
name|ctlr_started
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|vdnotrailer
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|,
literal|0
argument_list|,
name|VDSTART
argument_list|,
operator|(
name|slave
operator|*
literal|6
operator|)
operator|+
literal|62
argument_list|)
operator|&
name|HRDERR
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"DELAY(%d)..."
argument_list|,
operator|(
name|slave
operator|*
literal|5500000
operator|)
operator|+
literal|62000000
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
operator|(
name|slave
operator|*
literal|5500000
operator|)
operator|+
literal|62000000
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|vdnotrailer
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|,
name|unit
argument_list|,
name|function
argument_list|,
name|time
argument_list|)
specifier|register
name|cdr
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ctlr
decl_stmt|,
name|unit
decl_stmt|,
name|function
decl_stmt|,
name|time
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|vdctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
name|fmt_mdcb
modifier|*
name|mdcb
init|=
operator|&
name|ci
operator|->
name|ctlr_mdcb
decl_stmt|;
name|fmt_dcb
modifier|*
name|dcb
init|=
operator|&
name|ci
operator|->
name|ctlr_dcb
decl_stmt|;
name|dcb
operator|->
name|opcode
operator|=
name|function
expr_stmt|;
comment|/* command */
name|dcb
operator|->
name|intflg
operator|=
name|NOINT
expr_stmt|;
name|dcb
operator|->
name|nxtdcb
operator|=
operator|(
name|fmt_dcb
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* end of chain */
name|dcb
operator|->
name|operrsta
operator|=
literal|0
expr_stmt|;
name|dcb
operator|->
name|devselect
operator|=
operator|(
name|char
operator|)
name|unit
expr_stmt|;
name|dcb
operator|->
name|trailcnt
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
name|mdcb
operator|->
name|firstdcb
operator|=
operator|(
name|fmt_dcb
operator|*
operator|)
operator|(
name|PHYS
argument_list|(
name|dcb
argument_list|)
operator|)
expr_stmt|;
name|mdcb
operator|->
name|vddcstat
operator|=
literal|0
expr_stmt|;
name|VDDC_ATTENTION
argument_list|(
name|addr
argument_list|,
operator|(
name|fmt_mdcb
operator|*
operator|)
operator|(
name|PHYS
argument_list|(
name|mdcb
argument_list|)
operator|)
argument_list|,
name|ci
operator|->
name|ctlr_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdpoll
argument_list|(
name|ci
argument_list|,
name|addr
argument_list|,
name|time
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" during init\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DCBCMP
operator||
name|ANYERR
operator||
name|HRDERR
operator||
name|OPABRT
operator|)
return|;
block|}
return|return
operator|(
name|dcb
operator|->
name|operrsta
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|vdattach
argument_list|(
name|vi
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|vdunit_info
index|[
name|vi
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|vdctlr_info
index|[
name|vi
operator|->
name|ui_ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|cq
init|=
operator|&
name|vi
operator|->
name|ui_mi
operator|->
name|um_tab
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|uq
init|=
name|cq
operator|->
name|b_forw
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|start_queue
init|=
name|uq
decl_stmt|;
specifier|register
name|fs_tab
modifier|*
name|fs
init|=
operator|&
name|ui
operator|->
name|info
decl_stmt|;
name|ui
operator|->
name|info
operator|=
name|vdst
index|[
name|vi
operator|->
name|ui_type
index|]
expr_stmt|;
name|ui
operator|->
name|sec_per_blk
operator|=
name|DEV_BSIZE
operator|/
name|ui
operator|->
name|info
operator|.
name|secsize
expr_stmt|;
name|ui
operator|->
name|sec_per_cyl
operator|=
name|ui
operator|->
name|info
operator|.
name|nsec
operator|*
name|ui
operator|->
name|info
operator|.
name|ntrak
expr_stmt|;
name|ui
operator|->
name|xfer_queue
operator|.
name|b_dev
operator|=
name|vi
operator|->
name|ui_slave
expr_stmt|;
name|ci
operator|->
name|unit_type
index|[
name|vi
operator|->
name|ui_slave
index|]
operator|=
name|vi
operator|->
name|ui_type
expr_stmt|;
comment|/* load unit into controller's active unit list */
if|if
condition|(
name|uq
operator|==
name|NULL
condition|)
block|{
name|cq
operator|->
name|b_forw
operator|=
operator|&
name|ui
operator|->
name|xfer_queue
expr_stmt|;
name|ui
operator|->
name|xfer_queue
operator|.
name|b_forw
operator|=
operator|&
name|ui
operator|->
name|xfer_queue
expr_stmt|;
name|ui
operator|->
name|xfer_queue
operator|.
name|b_back
operator|=
operator|&
name|ui
operator|->
name|xfer_queue
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|uq
operator|->
name|b_forw
operator|!=
name|start_queue
condition|)
name|uq
operator|=
name|uq
operator|->
name|b_forw
expr_stmt|;
name|ui
operator|->
name|xfer_queue
operator|.
name|b_forw
operator|=
name|start_queue
expr_stmt|;
name|ui
operator|->
name|xfer_queue
operator|.
name|b_back
operator|=
name|uq
expr_stmt|;
name|uq
operator|->
name|b_forw
operator|=
operator|&
name|ui
operator|->
name|xfer_queue
expr_stmt|;
name|start_queue
operator|->
name|b_back
operator|=
operator|&
name|ui
operator|->
name|xfer_queue
expr_stmt|;
block|}
comment|/* 	 * (60 / rpm) / (number of sectors per track * (bytes per sector / 2)) 	 */
name|dk_mspw
index|[
name|vi
operator|->
name|ui_unit
index|]
operator|=
literal|120.0
operator|/
operator|(
name|fs
operator|->
name|rpm
operator|*
name|fs
operator|->
name|nsec
operator|*
name|fs
operator|->
name|secsize
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|vddgo
argument_list|(
argument|um
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|um
decl_stmt|;
end_decl_stmt

begin_block
block|{  }
end_block

begin_expr_stmt
name|vdstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|VDUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
init|=
name|vddinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|par_tab
modifier|*
name|par
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
decl_stmt|;
specifier|register
name|fs_tab
modifier|*
name|fs
decl_stmt|;
specifier|register
name|int
name|blks
decl_stmt|,
name|bn
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
operator|||
name|vi
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|ui
operator|=
operator|&
name|vdunit_info
index|[
name|unit
index|]
expr_stmt|;
name|fs
operator|=
operator|&
name|ui
operator|->
name|info
expr_stmt|;
name|par
operator|=
operator|&
name|fs
operator|->
name|partition
index|[
name|FILSYS
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|blks
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|>>
name|DEV_BSHIFT
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|+
name|blks
operator|>=
name|par
operator|->
name|par_len
condition|)
block|{
name|blks
operator|=
name|par
operator|->
name|par_len
operator|-
name|bp
operator|->
name|b_blkno
expr_stmt|;
if|if
condition|(
name|blks
operator|<=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|bp
operator|->
name|b_bcount
operator|=
name|blks
operator|*
name|DEV_BSIZE
expr_stmt|;
block|}
name|bn
operator|=
name|bp
operator|->
name|b_blkno
operator|+
name|par
operator|->
name|par_start
expr_stmt|;
name|bn
operator|*=
name|ui
operator|->
name|sec_per_blk
expr_stmt|;
name|bp
operator|->
name|b_daddr
operator|=
operator|(
name|bn
operator|/
name|fs
operator|->
name|nsec
operator|)
operator|%
name|fs
operator|->
name|ntrak
expr_stmt|;
name|bp
operator|->
name|b_cylin
operator|=
name|bn
operator|/
name|ui
operator|->
name|sec_per_cyl
expr_stmt|;
name|vbasetup
argument_list|(
name|bp
argument_list|,
name|ui
operator|->
name|info
operator|.
name|secsize
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|xfer_queue
operator|.
name|av_forw
operator|==
name|NULL
condition|)
block|{
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|vdctlr_info
index|[
name|vi
operator|->
name|ui_ctlr
index|]
decl_stmt|;
name|int
name|slave
init|=
name|vi
operator|->
name|ui_slave
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_cylin
operator|!=
name|ci
operator|->
name|cur_cyl
index|[
name|slave
index|]
operator|||
name|bp
operator|->
name|b_daddr
operator|!=
name|ci
operator|->
name|cur_trk
index|[
name|slave
index|]
condition|)
name|ci
operator|->
name|off_cylinder
operator||=
literal|1
operator|<<
name|slave
expr_stmt|;
block|}
name|bp
operator|->
name|b_daddr
operator||=
operator|(
name|bn
operator|%
name|fs
operator|->
name|nsec
operator|)
operator|<<
literal|8
expr_stmt|;
name|disksort
argument_list|(
operator|&
name|ui
operator|->
name|xfer_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vddinfo
index|[
name|unit
index|]
operator|->
name|ui_mi
operator|->
name|um_tab
operator|.
name|b_active
operator|++
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vdstart
argument_list|(
name|vddinfo
index|[
name|unit
index|]
operator|->
name|ui_mi
argument_list|)
expr_stmt|;
block|}
else|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
operator|,
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start up a transfer on a drive.  */
end_comment

begin_expr_stmt
name|vdstart
argument_list|(
name|ci
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|ci
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|cq
init|=
operator|&
name|ci
operator|->
name|um_tab
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|uq
init|=
name|cq
operator|->
name|b_forw
decl_stmt|;
comment|/* search for next ready unit */
name|cq
operator|->
name|b_forw
operator|=
name|cq
operator|->
name|b_forw
operator|->
name|b_forw
expr_stmt|;
name|uq
operator|=
name|cq
operator|->
name|b_forw
expr_stmt|;
do|do
block|{
if|if
condition|(
name|uq
operator|->
name|av_forw
operator|!=
name|NULL
condition|)
block|{
name|cq
operator|->
name|b_forw
operator|=
name|uq
expr_stmt|;
name|vdexecute
argument_list|(
name|ci
argument_list|,
name|uq
argument_list|)
expr_stmt|;
return|return;
block|}
name|uq
operator|=
name|uq
operator|->
name|b_forw
expr_stmt|;
block|}
do|while
condition|(
name|uq
operator|!=
name|cq
operator|->
name|b_forw
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  * Initiate seeks for all drives off-cylinder.  */
end_comment

begin_expr_stmt
name|vdload_seeks
argument_list|(
name|ci
argument_list|,
name|uq
argument_list|)
specifier|register
name|ctlr_tab
operator|*
name|ci
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|uq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|,
name|slave
decl_stmt|,
name|nseeks
decl_stmt|;
specifier|register
name|fmt_dcb
modifier|*
name|dcb
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|start_queue
init|=
name|uq
decl_stmt|;
name|nseeks
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|bp
operator|=
name|uq
operator|->
name|av_forw
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|unit
operator|=
name|VDUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|slave
operator|=
name|vddinfo
index|[
name|unit
index|]
operator|->
name|ui_slave
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|off_cylinder
operator|&
operator|(
literal|1
operator|<<
name|slave
operator|)
condition|)
block|{
name|ci
operator|->
name|off_cylinder
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slave
operator|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|cur_cyl
index|[
name|slave
index|]
operator|!=
name|bp
operator|->
name|b_cylin
condition|)
block|{
name|ci
operator|->
name|cur_cyl
index|[
name|slave
index|]
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|dk_seek
index|[
name|unit
index|]
operator|++
expr_stmt|;
block|}
name|ci
operator|->
name|cur_trk
index|[
name|slave
index|]
operator|=
name|bp
operator|->
name|b_daddr
operator|&
literal|0xff
expr_stmt|;
name|dcb
operator|=
operator|&
name|ci
operator|->
name|seek_dcb
index|[
name|nseeks
operator|++
index|]
expr_stmt|;
name|dcb
operator|->
name|opcode
operator|=
name|SEEK
expr_stmt|;
name|dcb
operator|->
name|intflg
operator|=
name|NOINT
operator||
name|INT_PBA
expr_stmt|;
name|dcb
operator|->
name|operrsta
operator|=
literal|0
expr_stmt|;
name|dcb
operator|->
name|devselect
operator|=
operator|(
name|char
operator|)
name|slave
expr_stmt|;
name|dcb
operator|->
name|trailcnt
operator|=
operator|(
name|char
operator|)
literal|1
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|sktrail
operator|.
name|skaddr
operator|.
name|cylinder
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|sktrail
operator|.
name|skaddr
operator|.
name|track
operator|=
name|bp
operator|->
name|b_daddr
operator|&
literal|0xff
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|sktrail
operator|.
name|skaddr
operator|.
name|sector
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|uq
operator|=
name|uq
operator|->
name|b_forw
expr_stmt|;
block|}
do|while
condition|(
name|uq
operator|!=
name|start_queue
operator|&&
name|nseeks
operator|<
literal|4
condition|)
do|;
return|return
operator|(
name|nseeks
operator|)
return|;
block|}
end_block

begin_extern
extern|extern	vd_int_timeout(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * Execute the next command on the unit queue uq.  */
end_comment

begin_expr_stmt
name|vdexecute
argument_list|(
name|controller_info
argument_list|,
name|uq
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|controller_info
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|uq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|uq
operator|->
name|av_forw
decl_stmt|;
specifier|register
name|int
name|ctlr
init|=
name|controller_info
operator|->
name|um_ctlr
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|vdctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|VDUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|int
name|slave
init|=
name|vddinfo
index|[
name|unit
index|]
operator|->
name|ui_slave
decl_stmt|;
specifier|register
name|fmt_mdcb
modifier|*
name|mdcb
init|=
operator|&
name|ci
operator|->
name|ctlr_mdcb
decl_stmt|;
specifier|register
name|fmt_dcb
modifier|*
name|dcb
init|=
operator|&
name|ci
operator|->
name|ctlr_dcb
decl_stmt|;
comment|/* 	 * If there are overlapped seeks to perform, shuffle 	 * them to the front of the queue and get them started 	 * before any data transfers (to get some parallelism). 	 */
if|if
condition|(
operator|(
name|ci
operator|->
name|off_cylinder
operator|&
operator|~
operator|(
literal|1
operator|<<
name|slave
operator|)
operator|)
operator|&&
name|ci
operator|->
name|overlap_seeks
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|nseeks
decl_stmt|;
comment|/* setup seek requests in seek-q */
name|nseeks
operator|=
name|vdload_seeks
argument_list|(
name|ci
argument_list|,
name|uq
argument_list|)
expr_stmt|;
comment|/* place at the front of the master q */
name|mdcb
operator|->
name|firstdcb
operator|=
operator|(
name|fmt_dcb
operator|*
operator|)
name|PHYS
argument_list|(
operator|&
name|ci
operator|->
name|seek_dcb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* shuffle any remaining seeks up in the seek-q */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nseeks
condition|;
name|i
operator|++
control|)
name|ci
operator|->
name|seek_dcb
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|nxtdcb
operator|=
operator|(
name|fmt_dcb
operator|*
operator|)
name|PHYS
argument_list|(
operator|&
name|ci
operator|->
name|seek_dcb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ci
operator|->
name|seek_dcb
index|[
name|nseeks
operator|-
literal|1
index|]
operator|.
name|nxtdcb
operator|=
operator|(
name|fmt_dcb
operator|*
operator|)
name|PHYS
argument_list|(
name|dcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bp
operator|->
name|b_cylin
operator|!=
name|ci
operator|->
name|cur_cyl
index|[
name|slave
index|]
condition|)
block|{
name|ci
operator|->
name|cur_cyl
index|[
name|slave
index|]
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|dk_seek
index|[
name|unit
index|]
operator|++
expr_stmt|;
block|}
name|ci
operator|->
name|cur_trk
index|[
name|slave
index|]
operator|=
name|bp
operator|->
name|b_daddr
operator|&
literal|0xff
expr_stmt|;
name|ci
operator|->
name|off_cylinder
operator|=
literal|0
expr_stmt|;
name|mdcb
operator|->
name|firstdcb
operator|=
operator|(
name|fmt_dcb
operator|*
operator|)
operator|(
name|PHYS
argument_list|(
name|dcb
argument_list|)
operator|)
expr_stmt|;
block|}
name|dcb
operator|->
name|opcode
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|RD
else|:
name|WD
expr_stmt|;
name|dcb
operator|->
name|intflg
operator|=
name|INTDONE
expr_stmt|;
name|dcb
operator|->
name|nxtdcb
operator|=
operator|(
name|fmt_dcb
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* end of chain */
name|dcb
operator|->
name|operrsta
operator|=
literal|0
expr_stmt|;
name|dcb
operator|->
name|devselect
operator|=
operator|(
name|char
operator|)
name|slave
expr_stmt|;
name|dcb
operator|->
name|trailcnt
operator|=
call|(
name|char
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|trrw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|memadr
operator|=
operator|(
name|char
operator|*
operator|)
name|vbastart
argument_list|(
name|bp
argument_list|,
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ci
operator|->
name|map
argument_list|,
name|ci
operator|->
name|utl
argument_list|)
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|wcount
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
name|bp
operator|->
name|b_bcount
operator|+
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|cylinder
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|track
operator|=
name|bp
operator|->
name|b_daddr
operator|&
literal|0xff
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|sector
operator|=
name|bp
operator|->
name|b_daddr
operator|>>
literal|8
expr_stmt|;
name|mdcb
operator|->
name|vddcstat
operator|=
literal|0
expr_stmt|;
name|dk_wds
index|[
name|unit
index|]
operator|+=
name|bp
operator|->
name|b_bcount
operator|/
literal|32
expr_stmt|;
name|ci
operator|->
name|int_expected
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|vd_int_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ctlr
argument_list|,
literal|20
operator|*
literal|60
argument_list|)
expr_stmt|;
name|dk_busy
operator||=
literal|1
operator|<<
name|unit
expr_stmt|;
name|scope_out
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|VDDC_ATTENTION
argument_list|(
operator|(
name|cdr
operator|*
operator|)
operator|(
name|vdminfo
index|[
name|ctlr
index|]
operator|->
name|um_addr
operator|)
argument_list|,
operator|(
name|fmt_mdcb
operator|*
operator|)
operator|(
name|PHYS
argument_list|(
name|mdcb
argument_list|)
operator|)
argument_list|,
name|ci
operator|->
name|ctlr_type
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Watch for lost interrupts.  */
end_comment

begin_expr_stmt
name|vd_int_timeout
argument_list|(
name|ctlr
argument_list|)
specifier|register
name|int
name|ctlr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|vdctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|fmt_dcb
modifier|*
name|dcb
init|=
operator|&
name|ci
operator|->
name|ctlr_dcb
decl_stmt|;
name|uncache
argument_list|(
operator|&
name|dcb
operator|->
name|operrsta
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vd%d: lost interupt, status %x"
argument_list|,
name|ctlr
argument_list|,
name|dcb
operator|->
name|operrsta
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ctlr_type
operator|==
name|SMD_ECTLR
condition|)
block|{
name|uncache
argument_list|(
operator|&
name|dcb
operator|->
name|err_code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", error code %x"
argument_list|,
name|dcb
operator|->
name|err_code
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dcb
operator|->
name|operrsta
operator|&
name|DCBCMP
operator|)
operator|==
literal|0
condition|)
block|{
name|VDDC_ABORT
argument_list|(
operator|(
name|cdr
operator|*
operator|)
operator|(
name|vdminfo
index|[
name|ctlr
index|]
operator|->
name|um_addr
operator|)
argument_list|,
name|ci
operator|->
name|ctlr_type
argument_list|)
expr_stmt|;
name|dcb
operator|->
name|operrsta
operator||=
name|DCBUSC
operator||
name|DCBABT
operator||
name|ANYERR
operator||
name|HRDERR
operator||
name|CTLRERR
expr_stmt|;
block|}
name|vdintr
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Handle a disk interrupt.  */
end_comment

begin_expr_stmt
name|vdintr
argument_list|(
name|ctlr
argument_list|)
specifier|register
name|int
name|ctlr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ctlr_tab
modifier|*
name|ci
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|cq
decl_stmt|,
modifier|*
name|uq
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|slave
decl_stmt|,
name|unit
decl_stmt|;
specifier|register
name|fmt_mdcb
modifier|*
name|mdcb
decl_stmt|;
specifier|register
name|fmt_dcb
modifier|*
name|dcb
decl_stmt|;
name|int
name|code
decl_stmt|,
name|s
decl_stmt|;
name|untimeout
argument_list|(
name|vd_int_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ctlr
argument_list|)
expr_stmt|;
name|scope_out
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ci
operator|=
operator|&
name|vdctlr_info
index|[
name|ctlr
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ci
operator|->
name|int_expected
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: stray interrupt\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Take first request off controller's queue. 	 */
name|cq
operator|=
operator|&
name|vdminfo
index|[
name|ctlr
index|]
operator|->
name|um_tab
expr_stmt|;
name|uq
operator|=
name|cq
operator|->
name|b_forw
expr_stmt|;
name|bp
operator|=
name|uq
operator|->
name|av_forw
expr_stmt|;
name|unit
operator|=
name|VDUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|unit
operator|)
expr_stmt|;
name|dk_xfer
index|[
name|unit
index|]
operator|++
expr_stmt|;
name|ci
operator|->
name|int_expected
operator|=
literal|0
expr_stmt|;
comment|/* find associated control blocks */
name|mdcb
operator|=
operator|&
name|ci
operator|->
name|ctlr_mdcb
operator|,
name|uncache
argument_list|(
operator|&
name|mdcb
operator|->
name|intdcb
argument_list|)
expr_stmt|;
name|dcb
operator|=
operator|&
name|ci
operator|->
name|ctlr_dcb
operator|,
name|uncache
argument_list|(
operator|&
name|dcb
operator|->
name|operrsta
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ctlr_type
operator|==
name|SMD_ECTLR
condition|)
name|uncache
argument_list|(
operator|&
name|dcb
operator|->
name|err_code
argument_list|)
expr_stmt|;
name|slave
operator|=
name|uq
operator|->
name|b_dev
expr_stmt|;
switch|switch
condition|(
name|code
operator|=
name|vddecode_error
argument_list|(
name|dcb
argument_list|)
condition|)
block|{
case|case
name|CTLR_ERROR
case|:
case|case
name|DRIVE_ERROR
case|:
if|if
condition|(
name|cq
operator|->
name|b_errcnt
operator|>=
literal|2
condition|)
name|vdhard_error
argument_list|(
name|ci
argument_list|,
name|bp
argument_list|,
name|dcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CTLR_ERROR
condition|)
name|vdreset_ctlr
argument_list|(
operator|(
name|cdr
operator|*
operator|)
name|vdminfo
index|[
name|ctlr
index|]
operator|->
name|um_addr
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
else|else
name|reset_drive
argument_list|(
operator|(
name|cdr
operator|*
operator|)
name|vdminfo
index|[
name|ctlr
index|]
operator|->
name|um_addr
argument_list|,
name|ctlr
argument_list|,
name|slave
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cq
operator|->
name|b_errcnt
operator|++
operator|<
literal|2
condition|)
block|{
comment|/* retry error */
name|cq
operator|->
name|b_forw
operator|=
name|uq
operator|->
name|b_back
expr_stmt|;
name|vdstart
argument_list|(
name|vdminfo
index|[
name|ctlr
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
break|break;
case|case
name|HARD_DATA_ERROR
case|:
name|vdhard_error
argument_list|(
name|ci
argument_list|,
name|bp
argument_list|,
name|dcb
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SOFT_DATA_ERROR
case|:
name|vdsoft_error
argument_list|(
name|ci
argument_list|,
name|bp
argument_list|,
name|dcb
argument_list|)
expr_stmt|;
comment|/* fall thru... */
default|default:
comment|/* operation completed */
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|vbadone
argument_list|(
name|bp
argument_list|,
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ci
operator|->
name|map
argument_list|,
name|ci
operator|->
name|utl
argument_list|)
expr_stmt|;
comment|/* 	 * Take next request on this unit q, or, if none, 	 * the next request on the next active unit q. 	 */
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
name|uq
operator|->
name|av_forw
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
if|if
condition|(
name|uq
operator|->
name|av_back
operator|!=
name|bp
condition|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|next
decl_stmt|;
name|unit
operator|=
name|VDUNIT
argument_list|(
name|uq
operator|->
name|av_forw
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|slave
operator|=
name|vddinfo
index|[
name|unit
index|]
operator|->
name|ui_slave
expr_stmt|;
name|next
operator|=
name|uq
operator|->
name|av_forw
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|b_cylin
operator|!=
name|ci
operator|->
name|cur_cyl
index|[
name|slave
index|]
operator|||
operator|(
name|next
operator|->
name|b_daddr
operator|&
literal|0xff
operator|)
operator|!=
name|ci
operator|->
name|cur_trk
index|[
name|slave
index|]
condition|)
name|ci
operator|->
name|off_cylinder
operator||=
literal|1
operator|<<
name|slave
expr_stmt|;
block|}
else|else
name|uq
operator|->
name|av_back
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* reset controller state */
name|cq
operator|->
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|cq
operator|->
name|b_active
operator|--
expr_stmt|;
name|scope_out
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|vdstart
argument_list|(
name|vdminfo
index|[
name|ctlr
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Convert controller status to internal operation/error code.  */
end_comment

begin_expr_stmt
name|vddecode_error
argument_list|(
name|dcb
argument_list|)
specifier|register
name|fmt_dcb
operator|*
name|dcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|dcb
operator|->
name|operrsta
operator|&
name|HRDERR
condition|)
block|{
if|if
condition|(
name|dcb
operator|->
name|operrsta
operator|&
operator|(
name|HCRCERR
operator||
name|HCMPERR
operator||
name|UCDATERR
operator||
name|WPTERR
operator||
name|DSEEKERR
operator||
name|NOTCYLERR
operator||
name|DRVNRDY
operator||
name|INVDADR
operator|)
condition|)
return|return
operator|(
name|DRIVE_ERROR
operator|)
return|;
if|if
condition|(
name|dcb
operator|->
name|operrsta
operator|&
operator|(
name|CTLRERR
operator||
name|OPABRT
operator||
name|INVCMD
operator||
name|DNEMEM
operator|)
condition|)
return|return
operator|(
name|CTLR_ERROR
operator|)
return|;
return|return
operator|(
name|HARD_DATA_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|dcb
operator|->
name|operrsta
operator|&
name|SFTERR
condition|)
return|return
operator|(
name|SOFT_DATA_ERROR
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Report a hard error.  */
end_comment

begin_macro
name|vdhard_error
argument_list|(
argument|ci
argument_list|,
argument|bp
argument_list|,
argument|dcb
argument_list|)
end_macro

begin_decl_stmt
name|ctlr_tab
modifier|*
name|ci
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|fmt_dcb
modifier|*
name|dcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|vdunit_info
index|[
name|VDUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
decl_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|harderr
argument_list|(
name|bp
argument_list|,
name|ui
operator|->
name|info
operator|.
name|type_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"status %x"
argument_list|,
name|dcb
operator|->
name|operrsta
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ctlr_type
operator|==
name|SMD_ECTLR
condition|)
name|printf
argument_list|(
literal|" ecode %x"
argument_list|,
name|dcb
operator|->
name|err_code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Report a soft error.  */
end_comment

begin_macro
name|vdsoft_error
argument_list|(
argument|ci
argument_list|,
argument|bp
argument_list|,
argument|dcb
argument_list|)
end_macro

begin_decl_stmt
name|ctlr_tab
modifier|*
name|ci
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|fmt_dcb
modifier|*
name|dcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|vdunit_info
index|[
name|VDUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"%s%d%c: soft error sn%d status %x"
argument_list|,
name|ui
operator|->
name|info
operator|.
name|type_name
argument_list|,
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|>>
literal|3
argument_list|,
literal|'a'
operator|+
operator|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
literal|07
operator|)
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|dcb
operator|->
name|operrsta
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ctlr_type
operator|==
name|SMD_ECTLR
condition|)
name|printf
argument_list|(
literal|" ecode %x"
argument_list|,
name|dcb
operator|->
name|err_code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|vdopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unit
operator|=
name|VDUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
init|=
name|vddinfo
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|vi
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_type
operator|>=
name|nvddrv
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|vdunit_info
index|[
name|unit
index|]
operator|.
name|info
operator|.
name|partition
index|[
name|FILSYS
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|par_len
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|vdread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|VDUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|vdunit_info
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NFSD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|physio
argument_list|(
name|vdstrategy
argument_list|,
operator|&
name|ui
operator|->
name|raw_q_element
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|vdwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|VDUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|vdunit_info
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NFSD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|physio
argument_list|(
name|vdstrategy
argument_list|,
operator|&
name|ui
operator|->
name|raw_q_element
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Crash dump.  */
end_comment

begin_macro
name|vddump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|VDUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|vdunit_info
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|fs_tab
modifier|*
name|fs
init|=
operator|&
name|ui
operator|->
name|info
decl_stmt|;
specifier|register
name|int
name|ctlr
init|=
name|vddinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vba_vdctlr_info
init|=
name|vdminfo
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|int
name|filsys
init|=
name|FILSYS
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|cdr
modifier|*
name|addr
init|=
operator|(
name|cdr
operator|*
operator|)
operator|(
name|vba_vdctlr_info
operator|->
name|um_addr
operator|)
decl_stmt|;
specifier|register
name|int
name|cur_blk
decl_stmt|,
name|blkcount
decl_stmt|,
name|blocks
decl_stmt|;
name|caddr_t
name|memaddr
decl_stmt|;
name|vdreset_ctlr
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
name|blkcount
operator|=
name|maxfree
operator|-
literal|2
expr_stmt|;
comment|/* In 1k byte pages */
if|if
condition|(
name|dumplo
operator|+
name|blkcount
operator|>
name|fs
operator|->
name|partition
index|[
name|filsys
index|]
operator|.
name|par_len
condition|)
block|{
name|blkcount
operator|=
name|fs
operator|->
name|partition
index|[
name|filsys
index|]
operator|.
name|par_len
operator|-
name|dumplo
expr_stmt|;
name|printf
argument_list|(
literal|"vd%d: Dump truncated to %dMB\n"
argument_list|,
name|unit
argument_list|,
name|blkcount
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
name|cur_blk
operator|=
name|fs
operator|->
name|partition
index|[
name|filsys
index|]
operator|.
name|par_start
operator|+
name|dumplo
expr_stmt|;
name|memaddr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|blkcount
operator|>
literal|0
condition|)
block|{
name|blocks
operator|=
name|MIN
argument_list|(
name|blkcount
argument_list|,
name|DUMPSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdwrite_block
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|,
name|unit
argument_list|,
name|memaddr
argument_list|,
name|cur_blk
argument_list|,
name|blocks
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|blkcount
operator|-=
name|blocks
expr_stmt|;
name|memaddr
operator|+=
name|blocks
operator|*
name|NBPG
expr_stmt|;
name|cur_blk
operator|+=
name|blocks
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Write a block to disk during a crash dump.  */
end_comment

begin_expr_stmt
name|vdwrite_block
argument_list|(
name|caddr
argument_list|,
name|ctlr
argument_list|,
name|unit
argument_list|,
name|addr
argument_list|,
name|block
argument_list|,
name|blocks
argument_list|)
specifier|register
name|cdr
operator|*
name|caddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|ctlr
decl_stmt|,
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|block
decl_stmt|,
name|blocks
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|vdctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|fmt_mdcb
modifier|*
name|mdcb
init|=
operator|&
name|ci
operator|->
name|ctlr_mdcb
decl_stmt|;
specifier|register
name|fmt_dcb
modifier|*
name|dcb
init|=
operator|&
name|ci
operator|->
name|ctlr_dcb
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|vdunit_info
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|fs_tab
modifier|*
name|fs
init|=
operator|&
name|ui
operator|->
name|info
decl_stmt|;
name|block
operator|*=
operator|(
name|int
operator|)
name|ui
operator|->
name|sec_per_blk
expr_stmt|;
name|blocks
operator|*=
operator|(
name|int
operator|)
name|ui
operator|->
name|sec_per_blk
expr_stmt|;
name|mdcb
operator|->
name|firstdcb
operator|=
operator|(
name|fmt_dcb
operator|*
operator|)
operator|(
name|PHYS
argument_list|(
name|dcb
argument_list|)
operator|)
expr_stmt|;
name|dcb
operator|->
name|intflg
operator|=
name|NOINT
expr_stmt|;
name|dcb
operator|->
name|opcode
operator|=
name|WD
expr_stmt|;
name|dcb
operator|->
name|operrsta
operator|=
literal|0
expr_stmt|;
name|dcb
operator|->
name|devselect
operator|=
call|(
name|char
call|)
argument_list|(
name|vddinfo
index|[
name|unit
index|]
argument_list|)
operator|->
name|ui_slave
expr_stmt|;
name|dcb
operator|->
name|trailcnt
operator|=
call|(
name|char
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|trrw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|memadr
operator|=
name|addr
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|wcount
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
name|blocks
operator|*
name|fs
operator|->
name|secsize
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|cylinder
operator|=
call|(
name|short
call|)
argument_list|(
name|block
operator|/
name|ui
operator|->
name|sec_per_cyl
argument_list|)
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|track
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|block
operator|/
name|fs
operator|->
name|nsec
operator|)
operator|%
name|fs
operator|->
name|ntrak
argument_list|)
expr_stmt|;
name|dcb
operator|->
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|sector
operator|=
call|(
name|char
call|)
argument_list|(
name|block
operator|%
name|fs
operator|->
name|nsec
argument_list|)
expr_stmt|;
name|VDDC_ATTENTION
argument_list|(
name|caddr
argument_list|,
operator|(
name|fmt_mdcb
operator|*
operator|)
operator|(
name|PHYS
argument_list|(
name|mdcb
argument_list|)
operator|)
argument_list|,
name|ci
operator|->
name|ctlr_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdpoll
argument_list|(
name|ci
argument_list|,
name|caddr
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" during dump\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|dcb
operator|->
name|operrsta
operator|&
name|HRDERR
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: hard error, status %x\n"
argument_list|,
name|unit
argument_list|,
name|dcb
operator|->
name|operrsta
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|vdsize
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|vba_device
modifier|*
name|vi
init|=
name|vddinfo
index|[
name|VDUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|vi
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_type
operator|>=
name|nvddrv
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|vdunit_info
index|[
name|VDUNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|info
operator|.
name|partition
index|[
name|FILSYS
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|par_len
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Perform a controller reset.  */
end_comment

begin_expr_stmt
name|vdreset_ctlr
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|)
specifier|register
name|cdr
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|cq
init|=
operator|&
name|vdminfo
index|[
name|ctlr
index|]
operator|->
name|um_tab
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|uq
init|=
name|cq
operator|->
name|b_forw
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|vdctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
name|VDDC_RESET
argument_list|(
name|addr
argument_list|,
name|ci
operator|->
name|ctlr_type
argument_list|)
expr_stmt|;
name|ci
operator|->
name|ctlr_started
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ctlr_type
operator|==
name|SMD_ECTLR
condition|)
block|{
name|addr
operator|->
name|cdr_csr
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|mdcb_tcf
operator|=
name|AM_ENPDA
expr_stmt|;
name|addr
operator|->
name|dcb_tcf
operator|=
name|AM_ENPDA
expr_stmt|;
name|addr
operator|->
name|trail_tcf
operator|=
name|AM_ENPDA
expr_stmt|;
name|addr
operator|->
name|data_tcf
operator|=
name|AM_ENPDA
expr_stmt|;
name|addr
operator|->
name|cdr_ccf
operator|=
name|CCF_STS
operator||
name|XMD_32BIT
operator||
name|BSZ_16WRD
operator||
name|CCF_ENP
operator||
name|CCF_EPE
operator||
name|CCF_EDE
operator||
name|CCF_ECE
operator||
name|CCF_ERR
expr_stmt|;
block|}
if|if
condition|(
name|vdnotrailer
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|,
literal|0
argument_list|,
name|INIT
argument_list|,
literal|10
argument_list|)
operator|&
name|HRDERR
condition|)
block|{
name|printf
argument_list|(
literal|"failed to init\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|vdnotrailer
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|,
literal|0
argument_list|,
name|DIAG
argument_list|,
literal|10
argument_list|)
operator|&
name|HRDERR
condition|)
block|{
name|printf
argument_list|(
literal|"diagnostic error\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  reset all units attached to controller */
name|uq
operator|=
name|cq
operator|->
name|b_forw
expr_stmt|;
do|do
block|{
name|reset_drive
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|,
name|uq
operator|->
name|b_dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uq
operator|=
name|uq
operator|->
name|b_forw
expr_stmt|;
block|}
do|while
condition|(
name|uq
operator|!=
name|cq
operator|->
name|b_forw
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Perform a reset on a drive.  */
end_comment

begin_expr_stmt
name|reset_drive
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|,
name|slave
argument_list|,
name|start
argument_list|)
specifier|register
name|cdr
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|start
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|type
init|=
name|vdctlr_info
index|[
name|ctlr
index|]
operator|.
name|unit_type
index|[
name|slave
index|]
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|UNKNOWN
condition|)
return|return;
if|if
condition|(
operator|!
name|vdconfigure_drive
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|,
name|slave
argument_list|,
name|type
argument_list|,
name|start
argument_list|)
condition|)
name|printf
argument_list|(
literal|"vd%d: drive %d: couldn't reset\n"
argument_list|,
name|ctlr
argument_list|,
name|slave
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Poll controller until operation completes  * or timeout expires.  */
end_comment

begin_expr_stmt
name|vdpoll
argument_list|(
name|ci
argument_list|,
name|addr
argument_list|,
name|t
argument_list|)
specifier|register
name|ctlr_tab
operator|*
name|ci
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|cdr
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|fmt_dcb
modifier|*
name|dcb
init|=
operator|&
name|ci
operator|->
name|ctlr_dcb
decl_stmt|;
name|t
operator|*=
literal|1000
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|dcb
operator|->
name|operrsta
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dcb
operator|->
name|operrsta
operator|&
operator|(
name|DCBCMP
operator||
name|DCBABT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|dcb
operator|->
name|operrsta
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|t
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: controller timeout"
argument_list|,
name|ci
operator|-
name|vdctlr_info
argument_list|)
expr_stmt|;
name|VDDC_ABORT
argument_list|(
name|addr
argument_list|,
name|ci
operator|->
name|ctlr_type
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30000
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|dcb
operator|->
name|operrsta
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ci
operator|->
name|ctlr_type
operator|==
name|SMD_ECTLR
condition|)
block|{
name|uncache
argument_list|(
operator|&
name|addr
operator|->
name|cdr_csr
argument_list|)
expr_stmt|;
while|while
condition|(
name|addr
operator|->
name|cdr_csr
operator|&
name|CS_GO
condition|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|addr
operator|->
name|cdr_csr
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|dcb
operator|->
name|operrsta
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * Dump the mdcb and DCB for diagnostic purposes.  */
end_comment

begin_expr_stmt
name|vdprintdcb
argument_list|(
name|lp
argument_list|)
specifier|register
name|long
operator|*
name|lp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|dcb
decl_stmt|,
name|tc
decl_stmt|;
for|for
control|(
name|dcb
operator|=
literal|0
init|;
name|lp
condition|;
name|lp
operator|=
operator|(
name|long
operator|*
operator|)
operator|(
operator|*
name|lp
operator|)
operator|,
name|dcb
operator|++
control|)
block|{
name|lp
operator|=
operator|(
name|long
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|lp
operator||
literal|0xc0000000
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nDump of dcb%d@%x:"
argument_list|,
name|dcb
argument_list|,
name|lp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tc
operator|=
name|lp
index|[
literal|3
index|]
operator|&
literal|0xff
init|;
name|i
operator|<
name|tc
operator|+
literal|7
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %lx"
argument_list|,
name|lp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1750000
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

