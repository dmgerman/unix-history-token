begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Computer Consoles Inc.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)vd.c	7.11 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"dk.h"
end_include

begin_if
if|#
directive|if
name|NVD
operator|>
literal|0
end_if

begin_comment
comment|/*  * Versabus VDDC/SMDE driver.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"dkstat.h"
end_include

begin_include
include|#
directive|include
file|"disklabel.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/pte.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vdreg.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_42
end_ifndef

begin_define
define|#
directive|define
name|COMPAT_42
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|B_FORMAT
value|B_XXX
end_define

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|vdunit
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>> 3)
end_define

begin_define
define|#
directive|define
name|vdpart
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x07)
end_define

begin_define
define|#
directive|define
name|vdminor
parameter_list|(
name|unit
parameter_list|,
name|part
parameter_list|)
value|(((unit)<< 3) | (part))
end_define

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|vdminfo
index|[
name|NVD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vddinfo
index|[
name|NDK
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vdprobe
argument_list|()
decl_stmt|,
name|vdslave
argument_list|()
decl_stmt|,
name|vdattach
argument_list|()
decl_stmt|,
name|vddgo
argument_list|()
decl_stmt|,
name|vdstrategy
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|vdstd
index|[]
init|=
block|{
literal|0xffff2000
block|,
literal|0xffff2100
block|,
literal|0xffff2200
block|,
literal|0xffff2300
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|vddriver
init|=
block|{
name|vdprobe
block|,
name|vdslave
block|,
name|vdattach
block|,
name|vddgo
block|,
name|vdstd
block|,
literal|"dk"
block|,
name|vddinfo
block|,
literal|"vd"
block|,
name|vdminfo
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Per-controller state.  */
end_comment

begin_struct
struct|struct
name|vdsoftc
block|{
name|u_short
name|vd_flags
decl_stmt|;
define|#
directive|define
name|VD_PRINT
value|0x1
comment|/* controller info printed */
define|#
directive|define
name|VD_STARTED
value|0x2
comment|/* start command issued */
define|#
directive|define
name|VD_DOSEEKS
value|0x4
comment|/* should overlap seeks */
define|#
directive|define
name|VD_SCATGATH
value|0x8
comment|/* can do scatter-gather commands (correctly) */
define|#
directive|define
name|VD_LOCKED
value|0x10
comment|/* locked for direct controller access */
define|#
directive|define
name|VD_WAIT
value|0x20
comment|/* someone needs direct controller access */
name|u_short
name|vd_type
decl_stmt|;
comment|/* controller type */
name|u_short
name|vd_wticks
decl_stmt|;
comment|/* timeout */
name|u_short
name|vd_secsize
decl_stmt|;
comment|/* sector size for controller */
name|struct
name|mdcb
name|vd_mdcb
decl_stmt|;
comment|/* master command block */
name|u_long
name|vd_mdcbphys
decl_stmt|;
comment|/* physical address of vd_mdcb */
name|struct
name|dcb
name|vd_dcb
decl_stmt|;
comment|/* i/o command block */
name|u_long
name|vd_dcbphys
decl_stmt|;
comment|/* physical address of vd_dcb */
name|struct
name|vb_buf
name|vd_rbuf
decl_stmt|;
comment|/* vba resources */
block|}
name|vdsoftc
index|[
name|NVD
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|VDMAXTIME
value|20
end_define

begin_comment
comment|/* max time for operation, sec. */
end_comment

begin_comment
comment|/*  * Per-drive state.  */
end_comment

begin_struct
struct|struct
name|dksoftc
block|{
name|int
name|dk_state
decl_stmt|;
comment|/* open fsm */
ifndef|#
directive|ifndef
name|SECSIZE
name|u_short
name|dk_bshift
decl_stmt|;
comment|/* shift for * (DEV_BSIZE / sectorsize) XXX */
endif|#
directive|endif
endif|SECSIZE
name|int
name|dk_wlabel
decl_stmt|;
comment|/* label sector is currently writable */
name|u_long
name|dk_copenpart
decl_stmt|;
comment|/* character units open on this drive */
name|u_long
name|dk_bopenpart
decl_stmt|;
comment|/* block units open on this drive */
name|u_long
name|dk_openpart
decl_stmt|;
comment|/* all units open on this drive */
name|u_int
name|dk_curcyl
decl_stmt|;
comment|/* last selected cylinder */
name|struct
name|skdcb
name|dk_dcb
decl_stmt|;
comment|/* seek command block */
name|u_long
name|dk_dcbphys
decl_stmt|;
comment|/* physical address of dk_dcb */
name|int
name|df_reg
index|[
literal|3
index|]
decl_stmt|;
comment|/* for formatting, in-out parameters */
block|}
name|dksoftc
index|[
name|NDK
index|]
struct|;
end_struct

begin_comment
comment|/*  * Drive states.  Used during steps of open/initialization.  * States< OPEN (> 0) are transient, during an open operation.  * OPENRAW is used for unlabeled disks, to allow format operations.  */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|0
end_define

begin_comment
comment|/* disk is closed */
end_comment

begin_define
define|#
directive|define
name|WANTOPEN
value|1
end_define

begin_comment
comment|/* open requested, not started */
end_comment

begin_define
define|#
directive|define
name|WANTOPENRAW
value|2
end_define

begin_comment
comment|/* open requested, no label */
end_comment

begin_define
define|#
directive|define
name|RDLABEL
value|3
end_define

begin_comment
comment|/* reading pack label */
end_comment

begin_define
define|#
directive|define
name|OPEN
value|4
end_define

begin_comment
comment|/* intialized and ready */
end_comment

begin_define
define|#
directive|define
name|OPENRAW
value|5
end_define

begin_comment
comment|/* open, no label */
end_comment

begin_decl_stmt
name|struct
name|buf
name|dkutab
index|[
name|NDK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i/o queue headers */
end_comment

begin_decl_stmt
name|struct
name|disklabel
name|dklabel
index|[
name|NDK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pack labels */
end_comment

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_define
define|#
directive|define
name|b_track
value|b_error
end_define

begin_comment
comment|/* used for seek commands */
end_comment

begin_define
define|#
directive|define
name|b_seekf
value|b_forw
end_define

begin_comment
comment|/* second queue on um_tab */
end_comment

begin_define
define|#
directive|define
name|b_seekl
value|b_back
end_define

begin_comment
comment|/* second queue on um_tab */
end_comment

begin_decl_stmt
name|int
name|vdwstart
decl_stmt|,
name|vdwatch
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * See if the controller is really there; if so, initialize it.  */
end_comment

begin_macro
name|vdprobe
argument_list|(
argument|reg
argument_list|,
argument|vm
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|br
operator|,
name|cvec
expr_stmt|;
comment|/* must be r12, r11 */
specifier|register
name|struct
name|vddevice
modifier|*
name|vdaddr
init|=
operator|(
expr|struct
name|vddevice
operator|*
operator|)
name|reg
decl_stmt|;
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|vdintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|reg
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vd
operator|=
operator|&
name|vdsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|vdaddr
operator|->
name|vdreset
operator|=
literal|0xffffffff
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdaddr
operator|->
name|vdreset
operator|!=
operator|(
name|unsigned
operator|)
literal|0xffffffff
condition|)
block|{
name|vd
operator|->
name|vd_type
operator|=
name|VDTYPE_VDDC
expr_stmt|;
name|vd
operator|->
name|vd_flags
operator|&=
operator|~
name|VD_DOSEEKS
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vd
operator|->
name|vd_type
operator|=
name|VDTYPE_SMDE
expr_stmt|;
name|vd
operator|->
name|vd_flags
operator||=
name|VD_DOSEEKS
expr_stmt|;
name|vdaddr
operator|->
name|vdrstclr
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|3000000
argument_list|)
expr_stmt|;
block|}
name|vd
operator|->
name|vd_mdcbphys
operator|=
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
operator|&
name|vd
operator|->
name|vd_mdcb
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcbphys
operator|=
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
operator|&
name|vd
operator|->
name|vd_dcb
argument_list|)
expr_stmt|;
name|vm
operator|->
name|um_addr
operator|=
name|reg
expr_stmt|;
comment|/* XXX */
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
if|if
condition|(
name|vdinit_ctlr
argument_list|(
name|vm
argument_list|,
name|vd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
comment|/* 		 * Attempt PROBE to get all drive status; 		 * we take advantage of this in vdreset_drive 		 * to try to avoid guessing games. 		 */
operator|(
name|void
operator|)
name|vdcmd
argument_list|(
name|vm
argument_list|,
name|VDOP_PROBE
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Check for scatter-gather by checking firmware date 		 * with IDENT command.  The date is printed when 		 * vdslave is first called, thus this must be 		 * the last controller operation in vdprobe. 		 */
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|idtrail
operator|.
name|date
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vdcmd
argument_list|(
name|vm
argument_list|,
name|VDOP_IDENT
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|uncache
argument_list|(
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|idtrail
operator|.
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|idtrail
operator|.
name|date
operator|!=
literal|0
condition|)
name|vd
operator|->
name|vd_flags
operator||=
name|VD_SCATGATH
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate page tables and i/o buffer. 	 */
if|if
condition|(
name|vbainit
argument_list|(
operator|&
name|vd
operator|->
name|vd_rbuf
argument_list|,
name|MAXPHYS
argument_list|,
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_VDDC
condition|?
name|VB_24BIT
else|:
name|VB_32BIT
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: vbainit failed\n"
argument_list|,
name|vm
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|br
operator|=
literal|0x17
operator|,
name|cvec
operator|=
literal|0xe0
operator|+
name|vm
operator|->
name|um_ctlr
expr_stmt|;
comment|/* XXX */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|vddevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * See if a drive is really there.  *  * Can't read pack label here as various data structures  * aren't setup for doing a read in a straightforward  * manner.  Instead just probe for the drive and leave  * the pack label stuff to the attach routine.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
name|vdslave
argument_list|(
name|vi
argument_list|,
name|vdaddr
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|vddevice
modifier|*
name|vdaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|dklabel
index|[
name|vi
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
init|=
operator|&
name|dksoftc
index|[
name|vi
operator|->
name|ui_unit
index|]
decl_stmt|;
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|vi
operator|->
name|ui_ctlr
index|]
decl_stmt|;
name|int
name|bcd
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|vd
operator|->
name|vd_flags
operator|&
name|VD_PRINT
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: %s controller"
argument_list|,
name|vi
operator|->
name|ui_ctlr
argument_list|,
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_VDDC
condition|?
literal|"VDDC"
else|:
literal|"SMDE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_flags
operator|&
name|VD_SCATGATH
condition|)
block|{
name|char
name|rev
index|[
literal|5
index|]
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|idtrail
operator|.
name|rev
argument_list|,
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|idtrail
operator|.
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" firmware rev %s (%d-%d-%d)"
argument_list|,
name|rev
argument_list|,
name|bcd
argument_list|(
operator|(
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|idtrail
operator|.
name|date
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
name|bcd
argument_list|(
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|idtrail
operator|.
name|date
operator|&
literal|0xff
argument_list|)
argument_list|,
name|bcd
argument_list|(
operator|(
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|idtrail
operator|.
name|date
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_flags
operator||=
name|VD_PRINT
expr_stmt|;
block|}
comment|/* 	 * Initialize label enough to do a reset on 	 * the drive.  The remainder of the default 	 * label values will be filled in in vdinit 	 * at attach time. 	 */
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
condition|)
name|lp
operator|->
name|d_secsize
operator|=
name|VD_MAXSECSIZE
expr_stmt|;
else|else
name|lp
operator|->
name|d_secsize
operator|=
name|VDDC_SECSIZE
expr_stmt|;
name|lp
operator|->
name|d_nsectors
operator|=
literal|66
expr_stmt|;
comment|/* only used on smd-e */
name|lp
operator|->
name|d_ntracks
operator|=
literal|23
expr_stmt|;
name|lp
operator|->
name|d_ncylinders
operator|=
literal|850
expr_stmt|;
name|lp
operator|->
name|d_secpercyl
operator|=
literal|66
operator|*
literal|23
expr_stmt|;
name|lp
operator|->
name|d_rpm
operator|=
literal|3600
expr_stmt|;
name|lp
operator|->
name|d_npartitions
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
name|LABELSECTOR
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Initialize invariant portion of 	 * dcb used for overlapped seeks. 	 */
name|dk
operator|->
name|dk_dcb
operator|.
name|opcode
operator|=
name|VDOP_SEEK
expr_stmt|;
name|dk
operator|->
name|dk_dcb
operator|.
name|intflg
operator|=
name|DCBINT_NONE
operator||
name|DCBINT_PBA
expr_stmt|;
name|dk
operator|->
name|dk_dcb
operator|.
name|devselect
operator|=
name|vi
operator|->
name|ui_slave
expr_stmt|;
name|dk
operator|->
name|dk_dcb
operator|.
name|trailcnt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|trseek
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|dk
operator|->
name|dk_dcb
operator|.
name|trail
operator|.
name|sktrail
operator|.
name|skaddr
operator|.
name|sector
operator|=
literal|0
expr_stmt|;
name|dk
operator|->
name|dk_dcbphys
operator|=
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
operator|&
name|dk
operator|->
name|dk_dcb
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SECSIZE
name|vd_setsecsize
argument_list|(
name|dk
argument_list|,
name|lp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|vdreset_drive
argument_list|(
name|vi
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|bcd
parameter_list|(
name|n
parameter_list|)
specifier|register
name|u_int
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|bin
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|mul
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|bin
operator|+=
operator|(
name|n
operator|&
literal|0xf
operator|)
operator|*
name|mul
expr_stmt|;
name|n
operator|>>=
literal|4
expr_stmt|;
name|mul
operator|*=
literal|10
expr_stmt|;
block|}
return|return
operator|(
name|bin
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|vdattach
argument_list|(
name|vi
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|vi
operator|->
name|ui_unit
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|dklabel
index|[
name|unit
index|]
decl_stmt|;
comment|/* 	 * Try to initialize device and read pack label. 	 */
if|if
condition|(
name|vdinit
argument_list|(
name|vdminor
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|": unknown drive type"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dksoftc
index|[
name|unit
index|]
operator|.
name|dk_state
operator|==
name|OPEN
condition|)
name|printf
argument_list|(
literal|": %s<secsize %d, ntrak %d, ncyl %d, nsec %d>"
argument_list|,
name|lp
operator|->
name|d_typename
argument_list|,
name|lp
operator|->
name|d_secsize
argument_list|,
name|lp
operator|->
name|d_ntracks
argument_list|,
name|lp
operator|->
name|d_ncylinders
argument_list|,
name|lp
operator|->
name|d_nsectors
argument_list|)
expr_stmt|;
comment|/* 	 * (60 / rpm) / (sectors per track * (bytes per sector / 2)) 	 */
if|if
condition|(
name|vi
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
name|dk_wpms
index|[
name|vi
operator|->
name|ui_dk
index|]
operator|=
operator|(
name|lp
operator|->
name|d_rpm
operator|*
name|lp
operator|->
name|d_nsectors
operator|*
name|lp
operator|->
name|d_secsize
operator|)
operator|/
literal|120
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|addswap
argument_list|(
name|makedev
argument_list|(
name|VDMAJOR
argument_list|,
name|vdminor
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|vdopen
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|,
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|,
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unit
operator|=
name|vdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|register
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|part
init|=
name|vdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|mask
init|=
literal|1
operator|<<
name|part
decl_stmt|;
name|daddr_t
name|start
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NDK
operator|||
operator|(
name|vi
operator|=
name|vddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|lp
operator|=
operator|&
name|dklabel
index|[
name|unit
index|]
expr_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
while|while
condition|(
name|dk
operator|->
name|dk_state
operator|!=
name|OPEN
operator|&&
name|dk
operator|->
name|dk_state
operator|!=
name|OPENRAW
operator|&&
name|dk
operator|->
name|dk_state
operator|!=
name|CLOSED
condition|)
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dk
argument_list|,
operator|(
name|PZERO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
name|devopn
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|dk
operator|->
name|dk_state
operator|!=
name|OPEN
operator|&&
name|dk
operator|->
name|dk_state
operator|!=
name|OPENRAW
condition|)
if|if
condition|(
name|error
operator|=
name|vdinit
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|vdwstart
operator|==
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|vdwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|vdwstart
operator|++
expr_stmt|;
block|}
comment|/* 	 * Warn if a partion is opened 	 * that overlaps another partition which is open 	 * unless one is the "raw" partition (whole disk). 	 */
define|#
directive|define
name|RAWPART
value|8
comment|/* 'x' partition */
comment|/* XXX */
if|if
condition|(
operator|(
name|dk
operator|->
name|dk_openpart
operator|&
name|mask
operator|)
operator|==
literal|0
operator|&&
name|part
operator|!=
name|RAWPART
condition|)
block|{
name|pp
operator|=
operator|&
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
expr_stmt|;
name|start
operator|=
name|pp
operator|->
name|p_offset
expr_stmt|;
name|end
operator|=
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|lp
operator|->
name|d_partitions
init|;
name|pp
operator|<
operator|&
name|lp
operator|->
name|d_partitions
index|[
name|lp
operator|->
name|d_npartitions
index|]
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
operator|<=
name|start
operator|||
name|pp
operator|->
name|p_offset
operator|>=
name|end
condition|)
continue|continue;
if|if
condition|(
name|pp
operator|-
name|lp
operator|->
name|d_partitions
operator|==
name|RAWPART
condition|)
continue|continue;
if|if
condition|(
name|dk
operator|->
name|dk_openpart
operator|&
operator|(
literal|1
operator|<<
operator|(
name|pp
operator|-
name|lp
operator|->
name|d_partitions
operator|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dk%d%c: overlaps open partition (%c)\n"
argument_list|,
name|unit
argument_list|,
name|part
operator|+
literal|'a'
argument_list|,
name|pp
operator|-
name|lp
operator|->
name|d_partitions
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|part
operator|>=
name|lp
operator|->
name|d_npartitions
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dk
operator|->
name|dk_openpart
operator||=
name|mask
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|dk
operator|->
name|dk_copenpart
operator||=
name|mask
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|dk
operator|->
name|dk_bopenpart
operator||=
name|mask
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|vdclose
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|,
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|,
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|vdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
init|=
operator|&
name|dksoftc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|part
init|=
name|vdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|mask
init|=
literal|1
operator|<<
name|part
decl_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|dk
operator|->
name|dk_copenpart
operator|&=
operator|~
name|mask
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|dk
operator|->
name|dk_bopenpart
operator|&=
operator|~
name|mask
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|dk
operator|->
name|dk_copenpart
operator||
name|dk
operator|->
name|dk_bopenpart
operator|)
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
name|dk
operator|->
name|dk_openpart
operator|&=
operator|~
name|mask
expr_stmt|;
comment|/* 	 * Should wait for i/o to complete on this partition 	 * even if others are open, but wait for work on blkflush(). 	 */
if|if
condition|(
name|dk
operator|->
name|dk_openpart
operator|==
literal|0
condition|)
block|{
name|int
name|s
init|=
name|spl7
argument_list|()
decl_stmt|;
while|while
condition|(
name|dkutab
index|[
name|unit
index|]
operator|.
name|b_actf
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dk
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dk
operator|->
name|dk_state
operator|=
name|CLOSED
expr_stmt|;
name|dk
operator|->
name|dk_wlabel
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|vdinit
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|int
name|unit
init|=
name|vdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|readdisklabel
argument_list|()
decl_stmt|;
specifier|extern
name|int
name|cold
decl_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|O_NDELAY
condition|)
block|{
name|dk
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dk
operator|->
name|dk_state
operator|=
name|RDLABEL
expr_stmt|;
name|lp
operator|=
operator|&
name|dklabel
index|[
name|unit
index|]
expr_stmt|;
name|vi
operator|=
name|vddinfo
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|msg
operator|=
name|readdisklabel
argument_list|(
name|dev
argument_list|,
name|vdstrategy
argument_list|,
name|lp
argument_list|)
condition|)
block|{
if|if
condition|(
name|cold
condition|)
block|{
name|printf
argument_list|(
literal|": %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|dk
operator|->
name|dk_state
operator|=
name|CLOSED
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"dk%d: %s\n"
argument_list|,
name|unit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|dk
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COMPAT_42
name|vdlock
argument_list|(
name|vi
operator|->
name|ui_ctlr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdmaptype
argument_list|(
name|vi
argument_list|,
name|lp
argument_list|)
condition|)
name|dk
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
name|vdunlock
argument_list|(
name|vi
operator|->
name|ui_ctlr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * Now that we have the label, configure 		 * the correct drive parameters. 		 */
name|vdlock
argument_list|(
name|vi
operator|->
name|ui_ctlr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdreset_drive
argument_list|(
name|vi
argument_list|)
condition|)
name|dk
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
else|else
block|{
name|dk
operator|->
name|dk_state
operator|=
name|CLOSED
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
name|vdunlock
argument_list|(
name|vi
operator|->
name|ui_ctlr
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SECSIZE
name|vd_setsecsize
argument_list|(
name|dk
argument_list|,
name|lp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|SECSIZE
end_ifndef

begin_expr_stmt
name|vd_setsecsize
argument_list|(
name|dk
argument_list|,
name|lp
argument_list|)
specifier|register
expr|struct
name|dksoftc
operator|*
name|dk
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|mul
decl_stmt|;
comment|/* 	 * Calculate scaling shift for mapping 	 * DEV_BSIZE blocks to drive sectors. 	 */
name|mul
operator|=
name|DEV_BSIZE
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|dk
operator|->
name|dk_bshift
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|mul
operator|>>=
literal|1
operator|)
operator|>
literal|0
condition|)
name|dk
operator|->
name|dk_bshift
operator|++
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|SECSIZE
end_endif

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|vddgo
argument_list|(
argument|vm
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vm
decl_stmt|;
end_decl_stmt

begin_block
block|{  }
end_block

begin_expr_stmt
name|vdstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|daddr_t
name|sn
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|daddr_t
name|sz
decl_stmt|,
name|maxsz
decl_stmt|;
name|int
name|part
decl_stmt|,
name|s
decl_stmt|;
name|unit
operator|=
name|vdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NDK
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|vi
operator|=
name|vddinfo
index|[
name|unit
index|]
expr_stmt|;
name|lp
operator|=
operator|&
name|dklabel
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|vi
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|dk
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
block|{
if|if
condition|(
name|dk
operator|->
name|dk_state
operator|==
name|CLOSED
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
goto|goto
name|q
goto|;
block|}
if|if
condition|(
name|dk
operator|->
name|dk_state
operator|!=
name|OPEN
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|part
operator|=
name|vdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dk
operator|->
name|dk_openpart
operator|&
operator|(
literal|1
operator|<<
name|part
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sz
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
name|lp
operator|->
name|d_secsize
operator|-
literal|1
operator|)
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|maxsz
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
expr_stmt|;
ifndef|#
directive|ifndef
name|SECSIZE
name|sn
operator|=
name|bp
operator|->
name|b_blkno
operator|<<
name|dk
operator|->
name|dk_bshift
expr_stmt|;
else|#
directive|else
else|SECSIZE
name|sn
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
endif|#
directive|endif
endif|SECSIZE
if|if
condition|(
name|sn
operator|+
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
operator|<=
name|LABELSECTOR
operator|&&
if|#
directive|if
name|LABELSECTOR
operator|!=
literal|0
name|sn
operator|+
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
operator|+
name|sz
operator|>
name|LABELSECTOR
operator|&&
endif|#
directive|endif
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|&&
name|dk
operator|->
name|dk_wlabel
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|sn
operator|<
literal|0
operator|||
name|sn
operator|+
name|sz
operator|>
name|maxsz
condition|)
block|{
if|if
condition|(
name|sn
operator|==
name|maxsz
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sz
operator|=
name|maxsz
operator|-
name|sn
expr_stmt|;
if|if
condition|(
name|sz
operator|<=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bp
operator|->
name|b_bcount
operator|=
name|sz
operator|*
name|lp
operator|->
name|d_secsize
expr_stmt|;
block|}
name|bp
operator|->
name|b_cylin
operator|=
operator|(
name|sn
operator|+
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
operator|)
operator|/
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
ifdef|#
directive|ifdef
name|SECSIZE
if|if
condition|(
name|bp
operator|->
name|b_blksize
operator|!=
name|lp
operator|->
name|d_secsize
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_PGIN
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"vdstrat blksize"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SECSIZE
name|q
label|:
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
name|dp
operator|=
operator|&
name|dkutab
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
operator|->
name|b_active
condition|)
block|{
operator|(
name|void
operator|)
name|vdustart
argument_list|(
name|vi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vi
operator|->
name|ui_mi
operator|->
name|um_tab
operator|.
name|b_active
condition|)
name|vdstart
argument_list|(
name|vi
operator|->
name|ui_mi
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_expr_stmt
name|vdustart
argument_list|(
name|vi
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|vi
operator|->
name|ui_unit
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|dp
operator|=
operator|&
name|dkutab
index|[
name|unit
index|]
expr_stmt|;
comment|/* 	 * If queue empty, nothing to do. 	 */
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * If drive is off-cylinder and controller supports seeks, 	 * place drive on seek queue for controller. 	 * Otherwise, place on transfer queue. 	 */
name|vd
operator|=
operator|&
name|vdsoftc
index|[
name|vi
operator|->
name|ui_ctlr
index|]
expr_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
name|vm
operator|=
name|vi
operator|->
name|ui_mi
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_cylin
operator|!=
name|dk
operator|->
name|dk_curcyl
operator|&&
name|vd
operator|->
name|vd_flags
operator|&
name|VD_DOSEEKS
condition|)
block|{
name|lp
operator|=
operator|&
name|dklabel
index|[
name|unit
index|]
expr_stmt|;
name|bp
operator|->
name|b_track
operator|=
operator|(
name|bp
operator|->
name|b_blkno
operator|%
name|lp
operator|->
name|d_secpercyl
operator|)
operator|/
name|lp
operator|->
name|d_nsectors
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_seekf
operator|==
name|NULL
condition|)
name|vm
operator|->
name|um_tab
operator|.
name|b_seekf
operator|=
name|dp
expr_stmt|;
else|else
name|vm
operator|->
name|um_tab
operator|.
name|b_seekl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|vm
operator|->
name|um_tab
operator|.
name|b_seekl
operator|=
name|dp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|vm
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|vm
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
block|}
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
name|dp
operator|->
name|b_active
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start next transfer on a controller.  * There are two queues of drives, the first on-cylinder  * and the second off-cylinder from their next transfers.  * Perform the first transfer for the first drive on the on-cylinder  * queue, if any, otherwise the first transfer for the first drive  * on the second queue.  Initiate seeks on remaining drives on the  * off-cylinder queue, then move them all to the on-cylinder queue.  */
end_comment

begin_expr_stmt
name|vdstart
argument_list|(
name|vm
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|vm
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|dcb
modifier|*
modifier|*
name|dcbp
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|int
name|sn
decl_stmt|,
name|tn
decl_stmt|;
name|loop
label|:
comment|/* 	 * Pull a request off the controller queue. 	 */
if|if
condition|(
operator|(
name|dp
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|dp
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_seekf
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|==
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
condition|)
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
else|else
name|vm
operator|->
name|um_tab
operator|.
name|b_seekf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* 	 * Mark controller busy, and determine 	 * destination of this request. 	 */
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|++
expr_stmt|;
name|vi
operator|=
name|vddinfo
index|[
name|vdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|SECSIZE
name|sn
operator|=
name|bp
operator|->
name|b_blkno
operator|<<
name|dk
operator|->
name|dk_bshift
expr_stmt|;
else|#
directive|else
else|SECSIZE
name|sn
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
endif|#
directive|endif
endif|SECSIZE
name|lp
operator|=
operator|&
name|dklabel
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
name|sn
operator|%=
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
name|tn
operator|=
name|sn
operator|/
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|sn
operator|%=
name|lp
operator|->
name|d_nsectors
expr_stmt|;
comment|/* 	 * Construct dcb for read/write command. 	 */
name|vd
operator|=
operator|&
name|vdsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|intflg
operator|=
name|DCBINT_DONE
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|devselect
operator|=
name|dk
operator|->
name|dk_dcb
operator|.
name|devselect
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|nxtdcb
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* end of chain */
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|cylinder
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|track
operator|=
name|tn
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|sector
operator|=
name|sn
expr_stmt|;
name|dk
operator|->
name|dk_curcyl
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|bp
operator|->
name|b_track
operator|=
literal|0
expr_stmt|;
comment|/* init overloaded field */
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|trrw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FORMAT
condition|)
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|=
name|dk
operator|->
name|dk_op
expr_stmt|;
elseif|else
if|if
condition|(
name|vd
operator|->
name|vd_flags
operator|&
name|VD_SCATGATH
operator|&&
operator|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|VDOP_RAS
else|:
name|VDOP_GAW
expr_stmt|;
else|else
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|VDOP_RD
else|:
name|VDOP_WD
expr_stmt|;
switch|switch
condition|(
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
condition|)
block|{
case|case
name|VDOP_FSECT
case|:
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|trfmt
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|fmtrail
operator|.
name|nsectors
operator|=
name|bp
operator|->
name|b_bcount
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|fmtrail
operator|.
name|hdr
operator|=
operator|*
operator|(
name|dskadr
operator|*
operator|)
operator|&
name|dk
operator|->
name|dk_althdr
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|cylinder
operator||=
name|dk
operator|->
name|dk_fmtflags
expr_stmt|;
goto|goto
name|setupaddr
goto|;
case|case
name|VDOP_RDRAW
case|:
case|case
name|VDOP_RD
case|:
case|case
name|VDOP_RHDE
case|:
case|case
name|VDOP_WD
case|:
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|wcount
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|setupaddr
label|:
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|memadr
operator|=
name|vbasetup
argument_list|(
name|bp
argument_list|,
operator|&
name|vd
operator|->
name|vd_rbuf
argument_list|,
operator|(
name|int
operator|)
name|lp
operator|->
name|d_secsize
argument_list|)
expr_stmt|;
break|break;
case|case
name|VDOP_RAS
case|:
case|case
name|VDOP_GAW
case|:
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|+=
name|vd_sgsetup
argument_list|(
name|bp
argument_list|,
operator|&
name|vd
operator|->
name|vd_rbuf
argument_list|,
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|sgtrail
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vi
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
block|{
name|dk_busy
operator||=
literal|1
operator|<<
name|vi
operator|->
name|ui_dk
expr_stmt|;
name|dk_xfer
index|[
name|vi
operator|->
name|ui_dk
index|]
operator|++
expr_stmt|;
name|dk_wds
index|[
name|vi
operator|->
name|ui_dk
index|]
operator|+=
name|bp
operator|->
name|b_bcount
operator|>>
literal|6
expr_stmt|;
block|}
comment|/* 	 * Look for any seeks to be performed on other drives on this 	 * controller.  If overlapped seeks exist, insert seek commands 	 * on the controller's command queue before the transfer. 	 */
name|dcbp
operator|=
operator|&
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_head
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|vm
operator|->
name|um_tab
operator|.
name|b_seekf
condition|)
name|dp
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
else|else
name|dp
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_seekf
expr_stmt|;
for|for
control|(
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|b_forw
control|)
block|{
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|vi
operator|=
name|vddinfo
index|[
name|vdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
name|dk
operator|->
name|dk_curcyl
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
name|dk_seek
index|[
name|vi
operator|->
name|ui_dk
index|]
operator|++
expr_stmt|;
name|dk
operator|->
name|dk_dcb
operator|.
name|operrsta
operator|=
literal|0
expr_stmt|;
name|dk
operator|->
name|dk_dcb
operator|.
name|trail
operator|.
name|sktrail
operator|.
name|skaddr
operator|.
name|cylinder
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
name|dk
operator|->
name|dk_dcb
operator|.
name|trail
operator|.
name|sktrail
operator|.
name|skaddr
operator|.
name|track
operator|=
name|bp
operator|->
name|b_track
expr_stmt|;
operator|*
name|dcbp
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
name|dk
operator|->
name|dk_dcbphys
expr_stmt|;
name|dcbp
operator|=
operator|&
name|dk
operator|->
name|dk_dcb
operator|.
name|nxtdcb
expr_stmt|;
block|}
operator|*
name|dcbp
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
name|vd
operator|->
name|vd_dcbphys
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
condition|)
name|vm
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_seekf
expr_stmt|;
else|else
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_seekf
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_seekf
condition|)
name|vm
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_seekl
expr_stmt|;
name|vm
operator|->
name|um_tab
operator|.
name|b_seekf
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initiate operation. 	 */
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_status
operator|=
literal|0
expr_stmt|;
name|VDGO
argument_list|(
name|vm
operator|->
name|um_addr
argument_list|,
name|vd
operator|->
name|vd_mdcbphys
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Wait for controller to finish current operation  * so that direct controller accesses can be done.  */
end_comment

begin_macro
name|vdlock
argument_list|(
argument|ctlr
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
init|=
name|vdminfo
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|ctlr
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
while|while
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|||
name|vd
operator|->
name|vd_flags
operator|&
name|VD_LOCKED
condition|)
block|{
name|vd
operator|->
name|vd_flags
operator||=
name|VD_WAIT
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vd
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|vd
operator|->
name|vd_flags
operator||=
name|VD_LOCKED
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Continue normal operations after pausing for   * munging the controller directly.  */
end_comment

begin_macro
name|vdunlock
argument_list|(
argument|ctlr
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
init|=
name|vdminfo
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|ctlr
index|]
decl_stmt|;
name|vd
operator|->
name|vd_flags
operator|&=
operator|~
name|VD_LOCKED
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_flags
operator|&
name|VD_WAIT
condition|)
block|{
name|vd
operator|->
name|vd_flags
operator|&=
operator|~
name|VD_WAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|vd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|||
name|vm
operator|->
name|um_tab
operator|.
name|b_seekf
condition|)
name|vdstart
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|DONTCARE
value|(DCBS_DSE|DCBS_DSL|DCBS_TOP|DCBS_TOM|DCBS_FAIL|DCBS_DONE)
end_define

begin_comment
comment|/*  * Handle a disk interrupt.  */
end_comment

begin_expr_stmt
name|vdintr
argument_list|(
name|ctlr
argument_list|)
specifier|register
name|ctlr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
init|=
name|vdminfo
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|status
expr_stmt|;
name|int
name|timedout
decl_stmt|;
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
if|if
condition|(
operator|!
name|vm
operator|->
name|um_tab
operator|.
name|b_active
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: stray interrupt\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get device and block structures, and a pointer 	 * to the vba_device for the drive. 	 */
name|dp
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|vi
operator|=
name|vddinfo
index|[
name|vdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|vi
operator|->
name|ui_dk
operator|)
expr_stmt|;
name|timedout
operator|=
operator|(
name|vd
operator|->
name|vd_wticks
operator|>=
name|VDMAXTIME
operator|)
expr_stmt|;
comment|/* 	 * Check for and process errors on 	 * either the drive or the controller. 	 */
name|uncache
argument_list|(
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
argument_list|)
expr_stmt|;
name|status
operator|=
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FORMAT
condition|)
block|{
name|dk
operator|->
name|dk_operrsta
operator|=
name|status
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|err_code
argument_list|)
expr_stmt|;
comment|/* ecodecnt gets err_code + err_wcnt from the same longword */
name|dk
operator|->
name|dk_ecodecnt
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|err_code
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|err_trk
argument_list|)
expr_stmt|;
comment|/* erraddr gets error trk/sec/cyl from the same longword */
name|dk
operator|->
name|dk_erraddr
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|err_trk
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|VDERR_HARD
operator|||
name|timedout
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
condition|)
name|uncache
argument_list|(
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|err_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|DCBS_WPT
condition|)
block|{
comment|/* 			 * Give up on write locked devices immediately. 			 */
name|printf
argument_list|(
literal|"dk%d: write locked\n"
argument_list|,
name|vi
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|VDERR_RETRY
operator|||
name|timedout
condition|)
block|{
if|if
condition|(
name|status
operator|&
name|VDERR_CTLR
operator|||
name|timedout
condition|)
block|{
name|vdharderr
argument_list|(
name|timedout
condition|?
literal|"controller timeout"
else|:
literal|"controller err"
argument_list|,
name|vd
argument_list|,
name|bp
argument_list|,
operator|&
name|vd
operator|->
name|vd_dcb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"; resetting controller..."
argument_list|)
expr_stmt|;
name|vdreset_ctlr
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|VDERR_DRIVE
condition|)
block|{
name|vdharderr
argument_list|(
literal|"drive err"
argument_list|,
name|vd
argument_list|,
name|bp
argument_list|,
operator|&
name|vd
operator|->
name|vd_dcb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"; resetting drive..."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdreset_drive
argument_list|(
name|vi
argument_list|)
condition|)
name|dk
operator|->
name|dk_state
operator|=
name|CLOSED
expr_stmt|;
block|}
else|else
name|vdharderr
argument_list|(
literal|"data err"
argument_list|,
name|vd
argument_list|,
name|bp
argument_list|,
operator|&
name|vd
operator|->
name|vd_dcb
argument_list|)
expr_stmt|;
comment|/* 			 * Retry transfer once, unless reset failed. 			 */
if|if
condition|(
operator|!
name|vi
operator|->
name|ui_alive
operator|||
name|dp
operator|->
name|b_errcnt
operator|++
operator|>=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
goto|goto
name|hard
goto|;
block|}
name|printf
argument_list|(
literal|" retrying\n"
argument_list|)
expr_stmt|;
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
comment|/* force retry */
block|}
else|else
block|{
name|vdharderr
argument_list|(
literal|"hard error"
argument_list|,
name|vd
argument_list|,
name|bp
argument_list|,
operator|&
name|vd
operator|->
name|vd_dcb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|hard
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|DCBS_SOFT
condition|)
name|vdsofterr
argument_list|(
name|bp
argument_list|,
operator|&
name|vd
operator|->
name|vd_dcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_wticks
operator|>
literal|3
condition|)
block|{
name|vd
operator|->
name|vd_dcb
operator|.
name|err_code
operator|=
name|vd
operator|->
name|vd_wticks
expr_stmt|;
name|vdharderr
argument_list|(
literal|"slow transfer (ecode is sec.)"
argument_list|,
name|vd
argument_list|,
name|bp
argument_list|,
operator|&
name|vd
operator|->
name|vd_dcb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|vd
operator|->
name|vd_wticks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_active
condition|)
block|{
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|vbadone
argument_list|(
name|bp
argument_list|,
operator|&
name|vd
operator|->
name|vd_rbuf
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * If this unit has more work to do, 		 * then start it up right away. 		 */
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
name|vdustart
argument_list|(
name|vi
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dk
operator|->
name|dk_openpart
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dk
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there are devices ready to 	 * transfer, start the controller. 	 */
if|if
condition|(
name|vd
operator|->
name|vd_flags
operator|&
name|VD_WAIT
condition|)
block|{
name|vd
operator|->
name|vd_flags
operator|&=
operator|~
name|VD_WAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|vd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|||
name|vm
operator|->
name|um_tab
operator|.
name|b_seekf
condition|)
name|vdstart
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vdharderr
argument_list|(
argument|what
argument_list|,
argument|vd
argument_list|,
argument|bp
argument_list|,
argument|dcb
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|what
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|dcb
modifier|*
name|dcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|vdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|,
name|status
init|=
name|dcb
operator|->
name|operrsta
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|dklabel
index|[
name|unit
index|]
decl_stmt|;
name|int
name|blkdone
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_wticks
operator|<
name|VDMAXTIME
condition|)
name|status
operator|&=
operator|~
name|DONTCARE
expr_stmt|;
name|blkdone
operator|=
operator|(
operator|(
operator|(
operator|(
name|dcb
operator|->
name|err_cyl
operator|&
literal|0xfff
operator|)
operator|*
name|lp
operator|->
name|d_ntracks
operator|+
name|dcb
operator|->
name|err_trk
operator|)
operator|*
name|lp
operator|->
name|d_nsectors
operator|+
name|dcb
operator|->
name|err_sec
operator|-
name|lp
operator|->
name|d_partitions
index|[
name|vdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|p_offset
operator|)
operator|>>
name|dksoftc
index|[
name|unit
index|]
operator|.
name|dk_bshift
operator|)
operator|-
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|diskerr
argument_list|(
name|bp
argument_list|,
literal|"dk"
argument_list|,
name|what
argument_list|,
name|LOG_PRINTF
argument_list|,
name|blkdone
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", status %b"
argument_list|,
name|status
argument_list|,
name|VDERRBITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
condition|)
name|printf
argument_list|(
literal|" ecode %x"
argument_list|,
name|dcb
operator|->
name|err_code
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|vdsofterr
argument_list|(
name|bp
argument_list|,
name|dcb
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|dcb
modifier|*
name|dcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|vdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|dklabel
index|[
name|unit
index|]
decl_stmt|;
name|int
name|status
init|=
name|dcb
operator|->
name|operrsta
decl_stmt|;
name|int
name|blkdone
decl_stmt|;
name|blkdone
operator|=
operator|(
operator|(
operator|(
operator|(
name|dcb
operator|->
name|err_cyl
operator|&
literal|0xfff
operator|)
operator|*
name|lp
operator|->
name|d_ntracks
operator|+
name|dcb
operator|->
name|err_trk
operator|)
operator|*
name|lp
operator|->
name|d_nsectors
operator|+
name|dcb
operator|->
name|err_sec
operator|-
name|lp
operator|->
name|d_partitions
index|[
name|vdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|p_offset
operator|)
operator|>>
name|dksoftc
index|[
name|unit
index|]
operator|.
name|dk_bshift
operator|)
operator|-
name|bp
operator|->
name|b_blkno
expr_stmt|;
if|if
condition|(
name|status
operator|!=
operator|(
name|DCBS_CCD
operator||
name|DCBS_SOFT
operator||
name|DCBS_ERR
operator||
name|DCBS_DONE
operator|)
condition|)
block|{
name|diskerr
argument_list|(
name|bp
argument_list|,
literal|"dk"
argument_list|,
literal|"soft error"
argument_list|,
name|LOG_WARNING
argument_list|,
name|blkdone
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|addlog
argument_list|(
literal|", status %b ecode %x\n"
argument_list|,
name|status
argument_list|,
name|VDERRBITS
argument_list|,
name|dcb
operator|->
name|err_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|diskerr
argument_list|(
name|bp
argument_list|,
literal|"dk"
argument_list|,
literal|"soft ecc"
argument_list|,
name|LOG_WARNING
argument_list|,
name|blkdone
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|addlog
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|vdioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|vdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|dklabel
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
init|=
operator|&
name|dksoftc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|vdformat
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
operator|=
operator|*
name|lp
expr_stmt|;
break|break;
case|case
name|DIOCGPART
case|:
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|disklab
operator|=
name|lp
expr_stmt|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|part
operator|=
operator|&
name|lp
operator|->
name|d_partitions
index|[
name|vdpart
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|DIOCSDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|error
operator|=
name|setdisklabel
argument_list|(
name|lp
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
argument_list|,
operator|(
name|dk
operator|->
name|dk_state
operator|==
name|OPENRAW
operator|)
condition|?
literal|0
else|:
name|dk
operator|->
name|dk_openpart
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|dk
operator|->
name|dk_state
operator|==
name|OPENRAW
operator|&&
name|vdreset_drive
argument_list|(
name|vddinfo
index|[
name|unit
index|]
argument_list|)
condition|)
name|dk
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
break|break;
case|case
name|DIOCWLABEL
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|dk
operator|->
name|dk_wlabel
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|DIOCWDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|setdisklabel
argument_list|(
name|lp
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
argument_list|,
operator|(
name|dk
operator|->
name|dk_state
operator|==
name|OPENRAW
operator|)
condition|?
literal|0
else|:
name|dk
operator|->
name|dk_openpart
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|wlab
decl_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|dk
operator|->
name|dk_state
operator|==
name|OPENRAW
operator|&&
name|vdreset_drive
argument_list|(
name|vddinfo
index|[
name|unit
index|]
argument_list|)
condition|)
name|dk
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
comment|/* simulate opening partition 0 so write succeeds */
name|dk
operator|->
name|dk_openpart
operator||=
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
comment|/* XXX */
name|wlab
operator|=
name|dk
operator|->
name|dk_wlabel
expr_stmt|;
name|dk
operator|->
name|dk_wlabel
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|writedisklabel
argument_list|(
name|dev
argument_list|,
name|vdstrategy
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|dk
operator|->
name|dk_openpart
operator|=
name|dk
operator|->
name|dk_copenpart
operator||
name|dk
operator|->
name|dk_bopenpart
expr_stmt|;
name|dk
operator|->
name|dk_wlabel
operator|=
name|wlab
expr_stmt|;
block|}
break|break;
case|case
name|DIOCWFORMAT
case|:
block|{
specifier|register
name|struct
name|format_op
modifier|*
name|fop
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|fop
operator|=
operator|(
expr|struct
name|format_op
operator|*
operator|)
name|data
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|fop
operator|->
name|df_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|fop
operator|->
name|df_startblk
operator|*
name|lp
operator|->
name|d_secsize
expr_stmt|;
comment|/* This assumes one active format operation per disk... */
name|dk
operator|->
name|dk_op
operator|=
name|fop
operator|->
name|dk_op
expr_stmt|;
name|dk
operator|->
name|dk_althdr
operator|=
name|fop
operator|->
name|dk_althdr
expr_stmt|;
name|dk
operator|->
name|dk_fmtflags
operator|=
name|fop
operator|->
name|dk_fmtflags
expr_stmt|;
comment|/* 		 * Don't return errors, as the format op won't get copied 		 * out if we return nonzero.  Callers must check the returned 		 * registers and count. 		 */
name|error
operator|=
name|physio
argument_list|(
name|vdformat
argument_list|,
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EIO
condition|)
name|error
operator|=
literal|0
expr_stmt|;
name|fop
operator|->
name|df_count
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
comment|/* This assumes one active format operation per disk... */
name|fop
operator|->
name|dk_operrsta
operator|=
name|dk
operator|->
name|dk_operrsta
expr_stmt|;
name|fop
operator|->
name|dk_ecodecnt
operator|=
name|dk
operator|->
name|dk_ecodecnt
expr_stmt|;
name|fop
operator|->
name|dk_erraddr
operator|=
name|dk
operator|->
name|dk_erraddr
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|vdformat
argument_list|(
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_FORMAT
expr_stmt|;
name|vdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Watch for lost interrupts.  */
end_comment

begin_macro
name|vdwatch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|timeout
argument_list|(
name|vdwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
for|for
control|(
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|NVD
condition|;
name|ctlr
operator|++
control|)
block|{
name|vm
operator|=
name|vdminfo
index|[
name|ctlr
index|]
expr_stmt|;
if|if
condition|(
name|vm
operator|==
literal|0
operator|||
name|vm
operator|->
name|um_alive
operator|==
literal|0
condition|)
continue|continue;
name|vd
operator|=
operator|&
name|vdsoftc
index|[
name|ctlr
index|]
expr_stmt|;
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|&&
name|vd
operator|->
name|vd_wticks
operator|++
operator|>=
name|VDMAXTIME
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: lost interrupt\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|maybe
name|VDABORT
argument_list|(
operator|(
expr|struct
name|vddevice
operator|*
operator|)
name|vm
operator|->
name|um_addr
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vdintr
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|DBSIZE
value|64
end_define

begin_comment
comment|/* controller limit with 1K sectors */
end_comment

begin_comment
comment|/*  * Crash dump.  */
end_comment

begin_macro
name|vddump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
name|int
name|part
decl_stmt|,
name|unit
decl_stmt|,
name|num
decl_stmt|;
name|u_long
name|start
decl_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|unit
operator|=
name|vdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>
name|NDK
operator|||
operator|(
name|vi
operator|=
name|vddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|dk
operator|->
name|dk_state
operator|!=
name|OPEN
operator|&&
name|dk
operator|->
name|dk_state
operator|!=
name|OPENRAW
operator|&&
name|vdinit
argument_list|(
name|vdminor
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|lp
operator|=
operator|&
name|dklabel
index|[
name|unit
index|]
expr_stmt|;
name|part
operator|=
name|vdpart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|>=
name|lp
operator|->
name|d_npartitions
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|vm
operator|=
name|vi
operator|->
name|ui_mi
expr_stmt|;
name|vdreset_ctlr
argument_list|(
name|vm
argument_list|)
expr_stmt|;
if|if
condition|(
name|dumplo
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Maxfree is in pages, dumplo is in DEV_BSIZE units. 	 */
name|num
operator|=
name|maxfree
operator|*
operator|(
name|NBPG
operator|/
name|lp
operator|->
name|d_secsize
operator|)
expr_stmt|;
name|dumplo
operator|*=
name|DEV_BSIZE
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
if|if
condition|(
name|dumplo
operator|+
name|num
operator|>=
name|lp
operator|->
name|d_partitions
index|[
name|vdpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
condition|)
name|num
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|vdpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
operator|-
name|dumplo
expr_stmt|;
name|vd
operator|=
operator|&
name|vdsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|intflg
operator|=
name|DCBINT_NONE
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|=
name|VDOP_WD
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|devselect
operator|=
name|dk
operator|->
name|dk_dcb
operator|.
name|devselect
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|trrw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|int
name|nsec
decl_stmt|,
name|cn
decl_stmt|,
name|sn
decl_stmt|,
name|tn
decl_stmt|;
name|nsec
operator|=
name|MIN
argument_list|(
name|num
argument_list|,
name|DBSIZE
argument_list|)
expr_stmt|;
name|sn
operator|=
name|dumplo
operator|+
name|start
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|cn
operator|=
operator|(
name|sn
operator|+
name|lp
operator|->
name|d_partitions
index|[
name|vdpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_offset
operator|)
operator|/
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
name|sn
operator|%=
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
name|tn
operator|=
name|sn
operator|/
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|sn
operator|%=
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_head
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
name|vd
operator|->
name|vd_dcbphys
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|memadr
operator|=
name|start
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|wcount
operator|=
operator|(
name|nsec
operator|*
name|lp
operator|->
name|d_secsize
operator|)
operator|>>
literal|1
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|cylinder
operator|=
name|cn
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|track
operator|=
name|tn
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|sector
operator|=
name|sn
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|=
literal|0
expr_stmt|;
name|VDGO
argument_list|(
name|vm
operator|->
name|um_addr
argument_list|,
name|vd
operator|->
name|vd_mdcbphys
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdpoll
argument_list|(
name|vm
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" during dump\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|&
name|VDERR_HARD
condition|)
block|{
name|printf
argument_list|(
literal|"dk%d: hard error, status=%b\n"
argument_list|,
name|unit
argument_list|,
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
argument_list|,
name|VDERRBITS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|start
operator|+=
name|nsec
operator|*
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|num
operator|-=
name|nsec
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|vdsize
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|vdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NDK
operator|||
operator|(
name|vi
operator|=
name|vddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
operator|||
operator|(
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
operator|)
operator|->
name|dk_state
operator|!=
name|OPEN
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|lp
operator|=
operator|&
name|dklabel
index|[
name|unit
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SECSIZE
return|return
operator|(
operator|(
name|int
operator|)
name|lp
operator|->
name|d_partitions
index|[
name|vdpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
operator|)
return|;
else|#
directive|else
else|SECSIZE
return|return
operator|(
operator|(
name|int
operator|)
name|lp
operator|->
name|d_partitions
index|[
name|vdpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
operator|>>
name|dk
operator|->
name|dk_bshift
operator|)
return|;
endif|#
directive|endif
endif|SECSIZE
block|}
end_block

begin_comment
comment|/*  * Initialize controller.  */
end_comment

begin_macro
name|vdinit_ctlr
argument_list|(
argument|vm
argument_list|,
argument|vd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vddevice
modifier|*
name|vdaddr
init|=
operator|(
expr|struct
name|vddevice
operator|*
operator|)
name|vm
operator|->
name|um_addr
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
condition|)
block|{
name|vdaddr
operator|->
name|vdcsr
operator|=
literal|0
expr_stmt|;
name|vdaddr
operator|->
name|vdtcf_mdcb
operator|=
name|AM_ENPDA
expr_stmt|;
name|vdaddr
operator|->
name|vdtcf_dcb
operator|=
name|AM_ENPDA
expr_stmt|;
name|vdaddr
operator|->
name|vdtcf_trail
operator|=
name|AM_ENPDA
expr_stmt|;
name|vdaddr
operator|->
name|vdtcf_data
operator|=
name|AM_ENPDA
expr_stmt|;
name|vdaddr
operator|->
name|vdccf
operator|=
name|CCF_SEN
operator||
name|CCF_DIU
operator||
name|CCF_STS
operator||
name|CCF_RFE
operator||
name|XMD_32BIT
operator||
name|BSZ_16WRD
operator||
name|CCF_ENP
operator||
name|CCF_EPE
operator||
name|CCF_EDE
operator||
name|CCF_ECE
operator||
name|CCF_ERR
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vdcmd
argument_list|(
name|vm
argument_list|,
name|VDOP_INIT
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|vdcmd
argument_list|(
name|vm
argument_list|,
name|VDOP_DIAG
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: %s cmd failed\n"
argument_list|,
name|vm
operator|->
name|um_ctlr
argument_list|,
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|==
name|VDOP_INIT
condition|?
literal|"init"
else|:
literal|"diag"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|vd
operator|->
name|vd_secsize
operator|=
name|vdaddr
operator|->
name|vdsecsize
operator|<<
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Perform a controller reset.  */
end_comment

begin_expr_stmt
name|vdreset_ctlr
argument_list|(
name|vm
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|vm
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vddevice
modifier|*
name|vdaddr
init|=
operator|(
expr|struct
name|vddevice
operator|*
operator|)
name|vm
operator|->
name|um_addr
decl_stmt|;
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|VDRESET
argument_list|(
name|vdaddr
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdinit_ctlr
argument_list|(
name|vm
argument_list|,
name|vd
argument_list|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NDK
condition|;
name|unit
operator|++
control|)
if|if
condition|(
operator|(
name|vi
operator|=
name|vddinfo
index|[
name|unit
index|]
operator|)
operator|->
name|ui_mi
operator|==
name|vm
operator|&&
name|vi
operator|->
name|ui_alive
condition|)
operator|(
name|void
operator|)
name|vdreset_drive
argument_list|(
name|vi
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|vdreset_drive
argument_list|(
name|vi
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|dklabel
index|[
name|vi
operator|->
name|ui_unit
index|]
decl_stmt|;
name|struct
name|vba_ctlr
modifier|*
name|vm
init|=
name|vdminfo
index|[
name|vi
operator|->
name|ui_ctlr
index|]
decl_stmt|;
name|struct
name|vddevice
modifier|*
name|vdaddr
init|=
operator|(
expr|struct
name|vddevice
operator|*
operator|)
name|vm
operator|->
name|um_addr
decl_stmt|;
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|vi
operator|->
name|ui_ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
init|=
operator|&
name|dksoftc
index|[
name|vi
operator|->
name|ui_unit
index|]
decl_stmt|;
name|int
name|config_status
decl_stmt|,
name|config_ecode
decl_stmt|,
name|saw_drive
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * check for ESDI distribution panel already configured, 	 * e.g. on boot drive, or if PROBE on controller actually 	 * worked.  Status will be zero if drive hasn't 	 * been probed yet. 	 */
if|#
directive|if
name|STA_ESDI
operator|!=
literal|0
if|if
condition|(
operator|(
name|vdaddr
operator|->
name|vdstatus
index|[
name|vi
operator|->
name|ui_slave
index|]
operator|&
name|STA_TYPE
operator|)
operator|==
name|STA_ESDI
condition|)
name|lp
operator|->
name|d_devflags
operator||=
name|VD_ESDI
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|top
label|:
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|=
name|VDOP_CONFIG
expr_stmt|;
comment|/* command */
name|vd
operator|->
name|vd_dcb
operator|.
name|intflg
operator|=
name|DCBINT_NONE
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|nxtdcb
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* end of chain */
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|devselect
operator|=
name|vi
operator|->
name|ui_slave
operator||
name|lp
operator|->
name|d_devflags
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|ncyl
operator|=
name|lp
operator|->
name|d_ncylinders
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|nsurfaces
operator|=
name|lp
operator|->
name|d_ntracks
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
condition|)
block|{
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|treset
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|nsectors
operator|=
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|slip_sec
operator|=
name|lp
operator|->
name|d_sparespertrack
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rstrail
operator|.
name|recovery
operator|=
operator|(
name|lp
operator|->
name|d_flags
operator|&
name|D_REMOVABLE
operator|)
condition|?
name|VDRF_NORMAL
else|:
operator|(
name|VDRF_NORMAL
operator|&
operator|~
operator|(
name|VDRF_OSP
operator||
name|VDRF_OSM
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|=
literal|2
expr_stmt|;
comment|/* XXX */
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_head
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
name|vd
operator|->
name|vd_dcbphys
expr_stmt|;
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_status
operator|=
literal|0
expr_stmt|;
name|VDGO
argument_list|(
name|vdaddr
argument_list|,
name|vd
operator|->
name|vd_mdcbphys
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdpoll
argument_list|(
name|vm
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" during config\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|config_status
operator|=
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
expr_stmt|;
name|config_ecode
operator|=
operator|(
name|u_char
operator|)
name|vd
operator|->
name|vd_dcb
operator|.
name|err_code
expr_stmt|;
if|if
condition|(
name|config_status
operator|&
name|VDERR_HARD
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
condition|)
block|{
comment|/* 			 * If drive status was updated successfully, 			 * STA_US (unit selected) should be set 			 * if the drive is attached and powered up. 			 * (But only if we've guessed right on SMD 			 * vs. ESDI; if that flag is wrong, we won't 			 * see the drive.)  If we don't see STA_US 			 * with either SMD or ESDI set for the unit, 			 * we assume that the drive doesn't exist, 			 * and don't wait for it to spin up. 			 */
operator|(
name|void
operator|)
name|vdcmd
argument_list|(
name|vm
argument_list|,
name|VDOP_STATUS
argument_list|,
literal|5
argument_list|,
name|vi
operator|->
name|ui_slave
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|vdaddr
operator|->
name|vdstatus
index|[
name|vi
operator|->
name|ui_slave
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdaddr
operator|->
name|vdstatus
index|[
name|vi
operator|->
name|ui_slave
index|]
operator|&
name|STA_US
condition|)
name|saw_drive
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lp
operator|->
name|d_devflags
operator|==
literal|0
condition|)
block|{
name|lp
operator|->
name|d_devflags
operator|=
name|VD_ESDI
expr_stmt|;
goto|goto
name|top
goto|;
block|}
block|}
else|else
name|saw_drive
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|config_status
operator|&
operator|(
name|DCBS_OCYL
operator||
name|DCBS_NRDY
operator|)
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"dk%d: config error %b ecode %x\n"
argument_list|,
name|vi
operator|->
name|ui_unit
argument_list|,
name|config_status
argument_list|,
name|VDERRBITS
argument_list|,
name|config_ecode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|vd
operator|->
name|vd_flags
operator|&
name|VD_STARTED
operator|)
operator|==
literal|0
operator|&&
name|saw_drive
condition|)
block|{
name|int
name|started
decl_stmt|;
name|printf
argument_list|(
literal|" starting drives, wait ... "
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_flags
operator||=
name|VD_STARTED
expr_stmt|;
name|started
operator|=
operator|(
name|vdcmd
argument_list|(
name|vm
argument_list|,
name|VDOP_START
argument_list|,
literal|10
argument_list|)
operator|==
literal|1
operator|)
expr_stmt|;
name|DELAY
argument_list|(
literal|62000000
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
name|lp
operator|->
name|d_devflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|started
condition|)
goto|goto
name|top
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dk
operator|->
name|dk_dcb
operator|.
name|devselect
operator||=
name|lp
operator|->
name|d_devflags
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Perform a command w/o trailer.  */
end_comment

begin_expr_stmt
name|vdcmd
argument_list|(
name|vm
argument_list|,
name|cmd
argument_list|,
name|t
argument_list|,
name|slave
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|vm
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
decl_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|=
name|cmd
expr_stmt|;
comment|/* command */
name|vd
operator|->
name|vd_dcb
operator|.
name|intflg
operator|=
name|DCBINT_NONE
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|nxtdcb
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* end of chain */
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|devselect
operator|=
name|slave
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_head
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
name|vd
operator|->
name|vd_dcbphys
expr_stmt|;
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_status
operator|=
literal|0
expr_stmt|;
name|VDGO
argument_list|(
name|vm
operator|->
name|um_addr
argument_list|,
name|vd
operator|->
name|vd_mdcbphys
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdpoll
argument_list|(
name|vm
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" during init\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|&
name|VDERR_HARD
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Poll controller until operation  * completes or timeout expires.  */
end_comment

begin_expr_stmt
name|vdpoll
argument_list|(
name|vm
argument_list|,
name|t
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|vm
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
init|=
operator|&
name|vdsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|vddevice
modifier|*
name|vdaddr
init|=
operator|(
expr|struct
name|vddevice
operator|*
operator|)
name|vm
operator|->
name|um_addr
decl_stmt|;
name|t
operator|*=
literal|1000
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|uncache
argument_list|(
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|&
operator|(
name|DCBS_DONE
operator||
name|DCBS_ABORT
operator|)
condition|)
break|break;
if|if
condition|(
operator|--
name|t
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vd%d: controller timeout"
argument_list|,
name|vm
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
name|VDABORT
argument_list|(
name|vdaddr
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_SMDE
condition|)
block|{
do|do
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|vdaddr
operator|->
name|vdcsr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|vdaddr
operator|->
name|vdcsr
operator|&
name|CS_GO
condition|)
do|;
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|err_code
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_42
end_ifdef

begin_struct
struct|struct
name|vdst
block|{
name|int
name|nsec
decl_stmt|;
comment|/* sectors/track */
name|int
name|ntrack
decl_stmt|;
comment|/* tracks/cylinder */
name|int
name|ncyl
decl_stmt|;
comment|/* cylinders */
name|int
name|secsize
decl_stmt|;
comment|/* sector size */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* type name */
struct|struct
block|{
name|int
name|off
decl_stmt|;
comment|/* partition offset in sectors */
name|int
name|size
decl_stmt|;
comment|/* partition size in sectors */
block|}
name|parts
index|[
literal|8
index|]
struct|;
block|}
name|vdst
index|[]
init|=
block|{
block|{
literal|66
block|,
literal|23
block|,
literal|850
block|,
literal|512
block|,
literal|"NEC 800"
block|,
block|{
literal|0
block|,
literal|1290300
block|}
block|,
comment|/* a cyl   0 - 849 */
block|}
block|,
block|{
literal|64
block|,
literal|20
block|,
literal|842
block|,
literal|512
block|,
literal|"2361a"
block|,
block|{
literal|0
block|,
literal|61440
block|}
block|,
comment|/* a cyl   0 - 47 */
block|{
literal|61440
block|,
literal|67840
block|}
block|,
comment|/* b cyl  48 - 100 */
block|{
literal|129280
block|,
literal|942080
block|}
block|,
comment|/* c cyl 101 - 836 */
block|{
literal|0
block|,
literal|1071360
block|}
block|,
comment|/* d cyl   0 - 836 */
block|{
literal|449280
block|,
literal|311040
block|}
block|,
comment|/* e cyl 351 - 593 */
block|{
literal|760320
block|,
literal|311040
block|}
block|,
comment|/* f cyl 594 - 836 */
block|{
literal|449280
block|,
literal|622080
block|}
block|,
comment|/* g cyl 351 - 836 */
block|{
literal|129280
block|,
literal|320000
block|}
comment|/* h cyl 101 - 350 */
block|}
block|,
block|{
literal|48
block|,
literal|24
block|,
literal|711
block|,
literal|512
block|,
literal|"xsd"
block|,
block|{
literal|0
block|,
literal|61056
block|}
block|,
comment|/* a cyl   0 - 52 */
block|{
literal|61056
block|,
literal|61056
block|}
block|,
comment|/* b cyl  53 - 105 */
block|{
literal|122112
block|,
literal|691200
block|}
block|,
comment|/* c cyl 106 - 705 */
block|{
literal|237312
block|,
literal|576000
block|}
block|,
comment|/* d cyl 206 - 705 */
block|{
literal|352512
block|,
literal|460800
block|}
block|,
comment|/* e cyl 306 - 705 */
block|{
literal|467712
block|,
literal|345600
block|}
block|,
comment|/* f cyl 406 - 705 */
block|{
literal|582912
block|,
literal|230400
block|}
block|,
comment|/* g cyl 506 - 705 */
block|{
literal|698112
block|,
literal|115200
block|}
comment|/* h cyl 606 - 705 */
block|}
block|,
block|{
literal|44
block|,
literal|20
block|,
literal|842
block|,
literal|512
block|,
literal|"eagle"
block|,
block|{
literal|0
block|,
literal|52800
block|}
block|,
comment|/* egl0a cyl   0 - 59 */
block|{
literal|52800
block|,
literal|66000
block|}
block|,
comment|/* egl0b cyl  60 - 134 */
block|{
literal|118800
block|,
literal|617760
block|}
block|,
comment|/* egl0c cyl 135 - 836 */
block|{
literal|736560
block|,
literal|4400
block|}
block|,
comment|/* egl0d cyl 837 - 841 */
block|{
literal|0
block|,
literal|736560
block|}
block|,
comment|/* egl0e cyl   0 - 836 */
block|{
literal|0
block|,
literal|740960
block|}
block|,
comment|/* egl0f cyl   0 - 841 */
block|{
literal|118800
block|,
literal|310640
block|}
block|,
comment|/* egl0g cyl 135 - 487 */
block|{
literal|429440
block|,
literal|307120
block|}
comment|/* egl0h cyl 488 - 836 */
block|}
block|,
block|{
literal|64
block|,
literal|10
block|,
literal|823
block|,
literal|512
block|,
literal|"fuj"
block|,
block|{
literal|0
block|,
literal|38400
block|}
block|,
comment|/* fuj0a cyl   0 - 59 */
block|{
literal|38400
block|,
literal|48000
block|}
block|,
comment|/* fuj0b cyl  60 - 134 */
block|{
literal|86400
block|,
literal|437120
block|}
block|,
comment|/* fuj0c cyl 135 - 817 */
block|{
literal|159360
block|,
literal|364160
block|}
block|,
comment|/* fuj0d cyl 249 - 817 */
block|{
literal|232320
block|,
literal|291200
block|}
block|,
comment|/* fuj0e cyl 363 - 817 */
block|{
literal|305280
block|,
literal|218240
block|}
block|,
comment|/* fuj0f cyl 477 - 817 */
block|{
literal|378240
block|,
literal|145280
block|}
block|,
comment|/* fuj0g cyl 591 - 817 */
block|{
literal|451200
block|,
literal|72320
block|}
comment|/* fug0h cyl 705 - 817 */
block|}
block|,
block|{
literal|32
block|,
literal|24
block|,
literal|711
block|,
literal|512
block|,
literal|"xfd"
block|,
block|{
literal|0
block|,
literal|40704
block|}
block|,
comment|/* a cyl   0 - 52 */
block|{
literal|40704
block|,
literal|40704
block|}
block|,
comment|/* b cyl  53 - 105 */
block|{
literal|81408
block|,
literal|460800
block|}
block|,
comment|/* c cyl 106 - 705 */
block|{
literal|0
block|,
literal|81408
block|}
block|,
comment|/* d cyl 709 - 710 (a& b) */
block|{
literal|0
block|,
literal|542208
block|}
block|,
comment|/* e cyl   0 - 705 */
block|{
literal|40704
block|,
literal|501504
block|}
block|,
comment|/* f cyl  53 - 705 (b& c) */
block|{
literal|81408
block|,
literal|230400
block|}
block|,
comment|/* g cyl 106 - 405 (1/2 of c) */
block|{
literal|311808
block|,
literal|230400
block|}
comment|/* h cyl 406 - 705 (1/2 of c) */
block|}
block|,
block|{
literal|32
block|,
literal|19
block|,
literal|823
block|,
literal|512
block|,
literal|"smd"
block|,
block|{
literal|0
block|,
literal|40128
block|}
block|,
comment|/* a cyl   0-65 */
block|{
literal|40128
block|,
literal|27360
block|}
block|,
comment|/* b cyl  66-110 */
block|{
literal|67488
block|,
literal|429856
block|}
block|,
comment|/* c cyl 111-817 */
block|{
literal|139232
block|,
literal|358112
block|}
block|,
comment|/* d cyl 229 - 817 */
block|{
literal|210976
block|,
literal|286368
block|}
block|,
comment|/* e cyl 347 - 817 */
block|{
literal|282720
block|,
literal|214624
block|}
block|,
comment|/* f cyl 465 - 817 */
block|{
literal|354464
block|,
literal|142880
block|}
block|,
comment|/* g cyl 583 - 817 */
block|{
literal|426208
block|,
literal|71136
block|}
comment|/* h cyl 701 - 817 */
block|}
block|,
block|{
literal|18
block|,
literal|15
block|,
literal|1224
block|,
literal|1024
block|,
literal|"mxd"
block|,
block|{
literal|0
block|,
literal|21600
block|}
block|,
comment|/* a cyl   0-79 */
block|{
literal|21600
block|,
literal|22410
block|}
block|,
comment|/* b cyl  80-162 */
block|{
literal|44010
block|,
literal|285120
block|}
block|,
comment|/* c cyl 163-1217 */
ifdef|#
directive|ifdef
name|notyet
block|{
name|x
block|,
literal|237600
block|}
block|,
comment|/* d cyl y - 1217 */
block|{
name|x
block|,
literal|190080
block|}
block|,
comment|/* e cyl y - 1217 */
block|{
name|x
block|,
literal|142560
block|}
block|,
comment|/* f cyl y - 1217 */
block|{
name|x
block|,
literal|95040
block|}
block|,
comment|/* g cyl y - 1217 */
block|{
name|x
block|,
literal|47520
block|}
comment|/* h cyl 701 - 817 */
endif|#
directive|endif
block|}
block|,
block|{
literal|32
block|,
literal|10
block|,
literal|823
block|,
literal|512
block|,
literal|"fsd"
block|,
block|{
literal|0
block|,
literal|19200
block|}
block|,
comment|/* a cyl   0 -  59 */
block|{
literal|19200
block|,
literal|24000
block|}
block|,
comment|/* b cyl  60 - 134 */
block|{
literal|43200
block|,
literal|218560
block|}
block|,
comment|/* c cyl 135 - 817 */
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NVDST
value|(sizeof (vdst) / sizeof (vdst[0]))
end_define

begin_comment
comment|/*  * Construct a label for an unlabeled pack.  We  * deduce the drive type by reading from the last  * track on successively smaller drives until we  * don't get an error.  */
end_comment

begin_expr_stmt
name|vdmaptype
argument_list|(
name|vi
argument_list|,
name|lp
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vdsoftc
modifier|*
name|vd
decl_stmt|;
specifier|register
name|struct
name|vdst
modifier|*
name|p
decl_stmt|;
name|struct
name|vba_ctlr
modifier|*
name|vm
init|=
name|vi
operator|->
name|ui_mi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vd
operator|=
operator|&
name|vdsoftc
index|[
name|vi
operator|->
name|ui_ctlr
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|vdst
init|;
name|p
operator|<
operator|&
name|vdst
index|[
name|NVDST
index|]
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|vd
operator|->
name|vd_type
operator|==
name|VDTYPE_VDDC
operator|&&
name|p
operator|->
name|nsec
operator|!=
literal|32
condition|)
continue|continue;
name|lp
operator|->
name|d_nsectors
operator|=
name|p
operator|->
name|nsec
expr_stmt|;
name|lp
operator|->
name|d_ntracks
operator|=
name|p
operator|->
name|ntrack
expr_stmt|;
name|lp
operator|->
name|d_ncylinders
operator|=
name|p
operator|->
name|ncyl
expr_stmt|;
name|lp
operator|->
name|d_secsize
operator|=
name|p
operator|->
name|secsize
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdreset_drive
argument_list|(
name|vi
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|opcode
operator|=
name|VDOP_RD
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|intflg
operator|=
name|DCBINT_NONE
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|nxtdcb
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* end of chain */
name|vd
operator|->
name|vd_dcb
operator|.
name|devselect
operator|=
name|dksoftc
index|[
name|vi
operator|->
name|ui_unit
index|]
operator|.
name|dk_dcb
operator|.
name|devselect
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trailcnt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|trrw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|memadr
operator|=
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|vd
operator|->
name|vd_rbuf
operator|.
name|vb_rawbuf
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|wcount
operator|=
name|lp
operator|->
name|d_secsize
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|cylinder
operator|=
name|p
operator|->
name|ncyl
operator|-
literal|2
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|track
operator|=
name|p
operator|->
name|ntrack
operator|-
literal|1
expr_stmt|;
name|vd
operator|->
name|vd_dcb
operator|.
name|trail
operator|.
name|rwtrail
operator|.
name|disk
operator|.
name|sector
operator|=
name|p
operator|->
name|nsec
operator|-
literal|1
expr_stmt|;
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_head
operator|=
operator|(
expr|struct
name|dcb
operator|*
operator|)
name|vd
operator|->
name|vd_dcbphys
expr_stmt|;
name|vd
operator|->
name|vd_mdcb
operator|.
name|mdcb_status
operator|=
literal|0
expr_stmt|;
name|VDGO
argument_list|(
name|vm
operator|->
name|um_addr
argument_list|,
name|vd
operator|->
name|vd_mdcbphys
argument_list|,
name|vd
operator|->
name|vd_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdpoll
argument_list|(
name|vm
argument_list|,
literal|60
argument_list|)
condition|)
name|printf
argument_list|(
literal|" during probe\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|->
name|vd_dcb
operator|.
name|operrsta
operator|&
name|VDERR_HARD
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|p
operator|>=
operator|&
name|vdst
index|[
name|NVDST
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|lp
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_offset
operator|=
name|p
operator|->
name|parts
index|[
name|i
index|]
operator|.
name|off
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_size
operator|=
name|p
operator|->
name|parts
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
block|}
name|lp
operator|->
name|d_npartitions
operator|=
literal|8
expr_stmt|;
name|lp
operator|->
name|d_secpercyl
operator|=
name|lp
operator|->
name|d_nsectors
operator|*
name|lp
operator|->
name|d_ntracks
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|lp
operator|->
name|d_typename
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|COMPAT_42
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

