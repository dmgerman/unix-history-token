begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that this notice is preserved and that due credit is given  * to the University of California at Berkeley. The name of the University  * may not be used to endorse or promote products derived from this  * software without specific prior written permission. This software  * is provided ``as is'' without express or implied warranty.  *  *	@(#)mp.c	1.6 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"mp.h"
end_include

begin_if
if|#
directive|if
name|NMP
operator|>
literal|0
end_if

begin_comment
comment|/*  * Multi Protocol Communications Controller (MPCC).  * Asynchronous Terminal Protocol Support.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"clist.h"
end_include

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../machine/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/mpreg.h"
end_include

begin_define
define|#
directive|define
name|MPCHUNK
value|16
end_define

begin_define
define|#
directive|define
name|MPPORT
parameter_list|(
name|n
parameter_list|)
value|((n)& 0xf)
end_define

begin_define
define|#
directive|define
name|MPUNIT
parameter_list|(
name|n
parameter_list|)
value|((n)>> 4)
end_define

begin_comment
comment|/*  * Driver information for auto-configuration stuff.  */
end_comment

begin_decl_stmt
name|int
name|mpprobe
argument_list|()
decl_stmt|,
name|mpattach
argument_list|()
decl_stmt|,
name|mpintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|mpinfo
index|[
name|NMP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|mpstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|mpdriver
init|=
block|{
name|mpprobe
block|,
literal|0
block|,
name|mpattach
block|,
literal|0
block|,
name|mpstd
block|,
literal|"mp"
block|,
name|mpinfo
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|mpstart
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|mpevent
modifier|*
name|mpparam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|mpevent
modifier|*
name|mp_getevent
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * The following structure is needed to deal with mpcc's convoluted  * method for locating it's mblok structures (hold your stomach).  * When an mpcc is reset at boot time it searches host memory  * looking for a string that says ``ThIs Is MpCc''.  The mpcc  * then reads the structure to locate the pointer to it's mblok  * structure (you can wretch now).  */
end_comment

begin_struct
struct|struct
name|mpbogus
block|{
name|char
name|s
index|[
literal|12
index|]
decl_stmt|;
comment|/* `ThIs Is MpCc'' */
name|u_char
name|status
decl_stmt|;
name|u_char
name|unused
decl_stmt|;
name|u_short
name|magic
decl_stmt|;
name|struct
name|mblok
modifier|*
name|mb
decl_stmt|;
name|struct
name|mblok
modifier|*
name|mbloks
index|[
name|NMP
index|]
decl_stmt|;
comment|/* can support at most 16 mpcc's */
block|}
name|mpbogus
init|=
block|{
literal|'T'
block|,
literal|'h'
block|,
literal|'I'
block|,
literal|'s'
block|,
literal|' '
block|,
literal|'I'
block|,
literal|'s'
block|,
literal|' '
block|,
literal|'M'
block|,
literal|'p'
block|,
literal|'C'
block|,
literal|'c'
block|}
struct|;
end_struct

begin_comment
comment|/*  * Software state per unit.  */
end_comment

begin_struct
struct|struct
name|mpsoftc
block|{
name|u_int
name|ms_ivec
decl_stmt|;
comment|/* interrupt vector */
name|u_int
name|ms_softCAR
decl_stmt|;
comment|/* software carrier for async */
name|struct
name|mblok
modifier|*
name|ms_mb
decl_stmt|;
comment|/* mpcc status area */
name|struct
name|vb_buf
name|ms_buf
decl_stmt|;
comment|/* vba resources for ms_mb */
name|struct
name|hxmtl
name|ms_hxl
index|[
name|MPMAXPORT
index|]
decl_stmt|;
comment|/* host transmit list */
name|struct
name|asyncparam
name|ms_async
index|[
name|MPMAXPORT
index|]
index|[
name|MPINSET
index|]
decl_stmt|;
comment|/* async structs */
name|char
name|ms_cbuf
index|[
name|MPMAXPORT
index|]
index|[
name|MPOUTSET
index|]
index|[
name|CBSIZE
index|]
decl_stmt|;
comment|/* input character buffers */
block|}
name|mp_softc
index|[
name|NMP
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|tty
name|mp_tty
index|[
name|NMP
operator|*
name|MPCHUNK
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|int
name|nmp
init|=
name|NMP
operator|*
name|MPCHUNK
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|ttrstrt
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|mpprobe
argument_list|(
argument|reg
argument_list|,
argument|vi
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
specifier|register
name|struct
name|mpsoftc
modifier|*
name|ms
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|mpintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mpdlintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|badaddr
argument_list|(
name|reg
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ms
operator|=
operator|&
name|mp_softc
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
comment|/* 	 * Allocate page tables and mblok 	 * structure (mblok in non-cached memory). 	 */
if|if
condition|(
name|vbainit
argument_list|(
operator|&
name|ms
operator|->
name|ms_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mblok
argument_list|)
argument_list|,
name|VB_32BIT
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"mp%d: vbainit failed\n"
argument_list|,
name|vi
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ms
operator|->
name|ms_mb
operator|=
operator|(
expr|struct
name|mblok
operator|*
operator|)
name|ms
operator|->
name|ms_buf
operator|.
name|vb_rawbuf
expr_stmt|;
name|ms
operator|->
name|ms_ivec
operator|=
name|MPINTRBASE
operator|+
literal|2
operator|*
name|vi
operator|->
name|ui_unit
expr_stmt|;
comment|/* XXX */
name|br
operator|=
literal|0x14
operator|,
name|cvec
operator|=
name|ms
operator|->
name|ms_ivec
expr_stmt|;
comment|/* XXX */
return|return
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|reg
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|mpattach
argument_list|(
name|vi
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|mpsoftc
modifier|*
name|ms
init|=
operator|&
name|mp_softc
index|[
name|vi
operator|->
name|ui_unit
index|]
decl_stmt|;
name|ms
operator|->
name|ms_softCAR
operator|=
name|vi
operator|->
name|ui_flags
expr_stmt|;
comment|/* 	 * Setup pointer to mblok, initialize bogus 	 * status block used by mpcc to locate the pointer 	 * and then poke the mpcc to get it to search host 	 * memory to find mblok pointer. 	 */
name|mpbogus
operator|.
name|mbloks
index|[
name|vi
operator|->
name|ui_unit
index|]
operator|=
operator|(
expr|struct
name|mblok
operator|*
operator|)
name|ms
operator|->
name|ms_buf
operator|.
name|vb_physbuf
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|vi
operator|->
name|ui_addr
operator|=
literal|0x100
expr_stmt|;
comment|/* magic */
block|}
end_block

begin_comment
comment|/*  * Open an mpcc port.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|mpopen
argument_list|(
argument|dev
argument_list|,
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|mpsoftc
modifier|*
name|ms
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|,
name|port
decl_stmt|,
name|unit
decl_stmt|,
name|mpu
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|struct
name|mpport
modifier|*
name|mp
decl_stmt|;
name|struct
name|mpevent
modifier|*
name|ev
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mpu
operator|=
name|MPUNIT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpu
operator|>=
name|NMP
operator|||
operator|(
name|vi
operator|=
name|mpinfo
index|[
name|mpu
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|=
operator|&
name|mp_tty
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|u
operator|.
name|u_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|ms
operator|=
operator|&
name|mp_softc
index|[
name|mpu
index|]
expr_stmt|;
name|port
operator|=
name|MPPORT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ms
operator|->
name|ms_mb
operator|->
name|mb_proto
index|[
name|port
index|]
operator|!=
name|MPPROTO_ASYNC
operator|||
name|ms
operator|->
name|ms_mb
operator|->
name|mb_status
operator|!=
name|MP_OPOPEN
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mp
operator|=
operator|&
name|ms
operator|->
name|ms_mb
operator|->
name|mb_port
index|[
name|port
index|]
expr_stmt|;
comment|/* host mpcc struct */
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
while|while
condition|(
name|mp
operator|->
name|mp_flags
operator|&
name|MP_PROGRESS
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_canq
argument_list|,
name|TTIPRI
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_WOPEN
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_canq
argument_list|,
name|TTIPRI
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
name|ms
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|mpstart
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_ispeed
operator|=
name|B9600
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|B9600
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|ODDP
operator||
name|EVENP
operator||
name|ECHO
expr_stmt|;
block|}
comment|/* 	 * Initialize port state: init MPCC interface 	 * structures for port and setup modem control. 	 */
name|mp
operator|->
name|mp_proto
operator|=
name|MPPROTO_ASYNC
expr_stmt|;
comment|/* XXX */
name|error
operator|=
name|mpportinit
argument_list|(
name|ms
argument_list|,
name|mp
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|ev
operator|=
name|mpparam
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|mpcmd
argument_list|(
name|ev
argument_list|,
name|EVCMD_OPEN
argument_list|,
literal|0
argument_list|,
name|ms
operator|->
name|ms_mb
argument_list|,
name|port
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
argument_list|)
expr_stmt|;
name|error
operator|=
name|mpmodem
argument_list|(
name|unit
argument_list|,
name|MMOD_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
while|while
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
name|done
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* wakeup anyone waiting for open to complete */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_canq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|bad
label|:
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_WOPEN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_block

begin_comment
comment|/*  * Close an mpcc port.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|mpclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|mpport
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|mpevent
modifier|*
name|ev
decl_stmt|;
name|int
name|s
decl_stmt|,
name|port
decl_stmt|,
name|unit
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|mblok
modifier|*
name|mb
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|mp_tty
index|[
name|unit
index|]
expr_stmt|;
name|port
operator|=
name|MPPORT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|mb
operator|=
name|mp_softc
index|[
name|MPUNIT
argument_list|(
name|unit
argument_list|)
index|]
operator|.
name|ms_mb
expr_stmt|;
name|mp
operator|=
operator|&
name|mb
operator|->
name|mb_port
index|[
name|port
index|]
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mp_flags
operator|&
name|MP_PROGRESS
condition|)
block|{
comment|/* close in progress */
if|if
condition|(
name|mp
operator|->
name|mp_flags
operator|&
name|MP_REMBSY
condition|)
block|{
name|mp
operator|->
name|mp_flags
operator|&=
operator|~
name|MP_REMBSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|mp
operator|->
name|mp_flags
operator|&
name|MP_PROGRESS
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_canq
argument_list|,
name|TTIPRI
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mp_flags
operator||=
name|MP_PROGRESS
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_HUPCLS
operator|||
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|error
operator|=
name|mpmodem
argument_list|(
name|unit
argument_list|,
name|MMOD_OFF
argument_list|)
condition|)
block|{
name|mp
operator|->
name|mp_flags
operator|&=
operator|~
name|MP_PROGRESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
while|while
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
comment|/* ??? */
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_state
argument_list|,
name|TTOPRI
argument_list|)
expr_stmt|;
comment|/* ??? */
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ev
operator|=
name|mp_getevent
argument_list|(
name|mp
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mpcmd
argument_list|(
name|ev
argument_list|,
name|EVCMD_CLOSE
argument_list|,
literal|0
argument_list|,
name|mb
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|mp
operator|->
name|mp_flags
operator|&
name|MP_REMBSY
condition|)
name|mpclean
argument_list|(
name|mb
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Read from an mpcc port.  */
end_comment

begin_macro
name|mpread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|mp_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Write to an mpcc port.  */
end_comment

begin_macro
name|mpwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|mp_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Ioctl for a mpcc port  */
end_comment

begin_macro
name|mpioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|mpsoftc
modifier|*
name|ms
decl_stmt|;
specifier|register
name|struct
name|mpevent
modifier|*
name|ev
decl_stmt|;
specifier|register
name|struct
name|mpport
modifier|*
name|mp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|port
decl_stmt|,
name|error
decl_stmt|,
name|unit
decl_stmt|;
name|struct
name|mblok
modifier|*
name|mb
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|mp_tty
index|[
name|unit
index|]
expr_stmt|;
name|ms
operator|=
operator|&
name|mp_softc
index|[
name|MPUNIT
argument_list|(
name|unit
argument_list|)
index|]
expr_stmt|;
name|mb
operator|=
name|ms
operator|->
name|ms_mb
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|TIOCSETP
operator|||
name|cmd
operator|==
name|TIOCSETN
operator|||
name|cmd
operator|==
name|TIOCLBIS
operator|||
name|cmd
operator|==
name|TIOCLBIC
operator|||
name|cmd
operator|==
name|TIOCLSET
condition|)
block|{
name|ev
operator|=
name|mpparam
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
literal|0
condition|)
name|error
operator|=
name|ENOBUFS
expr_stmt|;
else|else
name|mpcmd
argument_list|(
name|ev
argument_list|,
name|EVCMD_IOCTL
argument_list|,
name|A_CHGALL
argument_list|,
name|mb
argument_list|,
name|MPPORT
argument_list|(
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
comment|/* send break */
case|case
name|TIOCCBRK
case|:
comment|/* clear break */
name|port
operator|=
name|MPPORT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|mp
operator|=
operator|&
name|mb
operator|->
name|mb_port
index|[
name|port
index|]
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|ev
operator|=
name|mp_getevent
argument_list|(
name|mp
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
condition|)
name|mpcmd
argument_list|(
name|ev
argument_list|,
name|EVCMD_IOCTL
argument_list|,
operator|(
name|cmd
operator|==
name|TIOCSBRK
condition|?
name|A_BRKON
else|:
name|A_BRKOFF
operator|)
argument_list|,
name|mb
argument_list|,
name|port
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ENOBUFS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCSDTR
case|:
comment|/* set dtr control line */
break|break;
case|case
name|TIOCCDTR
case|:
comment|/* clear dtr control line */
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|mpevent
modifier|*
name|mpparam
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|mpevent
modifier|*
name|ev
decl_stmt|;
specifier|register
name|struct
name|mpport
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|mblok
modifier|*
name|mb
decl_stmt|;
name|struct
name|mpsoftc
modifier|*
name|ms
decl_stmt|;
specifier|register
name|struct
name|asyncparam
modifier|*
name|asp
decl_stmt|;
name|int
name|port
decl_stmt|;
name|ms
operator|=
operator|&
name|mp_softc
index|[
name|MPUNIT
argument_list|(
name|unit
argument_list|)
index|]
expr_stmt|;
name|mb
operator|=
name|ms
operator|->
name|ms_mb
expr_stmt|;
name|port
operator|=
name|MPPORT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|mp
operator|=
operator|&
name|mb
operator|->
name|mb_port
index|[
name|port
index|]
expr_stmt|;
name|ev
operator|=
name|mp_getevent
argument_list|(
name|mp
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|ev
operator|==
literal|0
condition|)
return|return
operator|(
name|ev
operator|)
return|;
name|tp
operator|=
operator|&
name|mp_tty
index|[
name|unit
index|]
expr_stmt|;
comment|/* YUCK */
name|asp
operator|=
operator|&
name|ms
operator|->
name|ms_async
index|[
name|port
index|]
index|[
name|mp
operator|->
name|mp_on
condition|?
name|mp
operator|->
name|mp_on
operator|-
literal|1
else|:
name|MPINSET
operator|-
literal|1
index|]
expr_stmt|;
name|asp
operator|->
name|ap_xon
operator|=
name|tp
operator|->
name|t_startc
expr_stmt|;
name|asp
operator|->
name|ap_xoff
operator|=
name|tp
operator|->
name|t_stopc
expr_stmt|;
name|asp
operator|->
name|ap_xena
operator|=
operator|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|RAW
operator|)
condition|?
name|MPA_DIS
else|:
name|MPA_ENA
operator|)
expr_stmt|;
name|asp
operator|->
name|ap_xany
operator|=
operator|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|DECCTQ
operator|)
condition|?
name|MPA_DIS
else|:
name|MPA_ENA
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notnow
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator||
name|PASS8
operator|)
condition|)
block|{
endif|#
directive|endif
name|asp
operator|->
name|ap_data
operator|=
name|MPCHAR_8
expr_stmt|;
name|asp
operator|->
name|ap_parity
operator|=
name|MPPAR_NONE
expr_stmt|;
ifdef|#
directive|ifdef
name|notnow
block|}
else|else
block|{
name|asp
operator|->
name|ap_data
operator|=
name|MPCHAR_7
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
name|ODDP
condition|)
name|asp
operator|->
name|ap_parity
operator|=
name|MPPAR_ODD
expr_stmt|;
else|else
name|asp
operator|->
name|ap_parity
operator|=
name|MPPAR_EVEN
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tp
operator|->
name|t_ospeed
operator|==
name|B110
condition|)
name|asp
operator|->
name|ap_stop
operator|=
name|MPSTOP_2
expr_stmt|;
else|else
name|asp
operator|->
name|ap_stop
operator|=
name|MPSTOP_1
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ospeed
operator|==
name|EXTA
operator|||
name|tp
operator|->
name|t_ospeed
operator|==
name|EXTB
condition|)
name|asp
operator|->
name|ap_baud
operator|=
name|M19200
expr_stmt|;
else|else
name|asp
operator|->
name|ap_baud
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
name|asp
operator|->
name|ap_loop
operator|=
name|MPA_DIS
expr_stmt|;
comment|/* disable loopback */
name|asp
operator|->
name|ap_rtimer
operator|=
name|A_RCVTIM
expr_stmt|;
comment|/* default receive timer */
if|if
condition|(
name|ms
operator|->
name|ms_softCAR
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
condition|)
name|setm
argument_list|(
operator|&
name|asp
operator|->
name|ap_modem
argument_list|,
name|A_DTR
argument_list|,
name|ASSERT
argument_list|)
expr_stmt|;
else|else
name|setm
argument_list|(
operator|&
name|asp
operator|->
name|ap_modem
argument_list|,
name|A_DTR
argument_list|,
name|AUTO
argument_list|)
expr_stmt|;
name|seti
argument_list|(
operator|&
name|asp
operator|->
name|ap_intena
argument_list|,
name|A_DCD
argument_list|)
expr_stmt|;
return|return
operator|(
name|ev
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|mpstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|mpevent
modifier|*
name|ev
decl_stmt|;
specifier|register
name|struct
name|mpport
modifier|*
name|mp
decl_stmt|;
name|struct
name|mblok
modifier|*
name|mb
decl_stmt|;
name|struct
name|mpsoftc
modifier|*
name|ms
decl_stmt|;
name|int
name|port
decl_stmt|,
name|unit
decl_stmt|,
name|xcnt
decl_stmt|,
name|n
decl_stmt|,
name|s
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|hxmtl
modifier|*
name|hxp
decl_stmt|;
name|struct
name|clist
name|outq
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|ms
operator|=
operator|&
name|mp_softc
index|[
name|MPUNIT
argument_list|(
name|unit
argument_list|)
index|]
expr_stmt|;
name|mb
operator|=
name|ms
operator|->
name|ms_mb
expr_stmt|;
name|port
operator|=
name|MPPORT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|mp
operator|=
operator|&
name|mb
operator|->
name|mb_port
index|[
name|port
index|]
expr_stmt|;
name|hxp
operator|=
operator|&
name|ms
operator|->
name|ms_hxl
index|[
name|port
index|]
expr_stmt|;
name|xcnt
operator|=
literal|0
expr_stmt|;
name|outq
operator|=
name|tp
operator|->
name|t_outq
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPXMIT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
break|break;
if|if
condition|(
name|outq
operator|.
name|c_cc
operator|<=
name|TTLOWAT
argument_list|(
name|tp
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_wsel
condition|)
block|{
name|selwakeup
argument_list|(
name|tp
operator|->
name|t_wsel
argument_list|,
name|tp
operator|->
name|t_state
operator|&
name|TS_WCOLL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_wsel
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_WCOLL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * If we're not currently busy outputting, 		 * and there is data to be output, set up 		 * port transmit structure to send to mpcc. 		 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator|)
condition|)
name|n
operator|=
name|ndqb
argument_list|(
operator|&
name|outq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|n
operator|=
name|ndqb
argument_list|(
operator|&
name|outq
argument_list|,
literal|0200
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|n
operator|=
name|getc
argument_list|(
operator|&
name|outq
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ttrstrt
argument_list|,
operator|(
name|caddr_t
operator|)
name|tp
argument_list|,
operator|(
name|n
operator|&
literal|0177
operator|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_TIMEOUT
expr_stmt|;
break|break;
block|}
block|}
name|hxp
operator|->
name|dblock
index|[
name|i
index|]
operator|=
operator|(
name|caddr_t
operator|)
name|kvtophys
argument_list|(
name|outq
operator|.
name|c_cf
argument_list|)
expr_stmt|;
name|hxp
operator|->
name|size
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
name|xcnt
operator|++
expr_stmt|;
comment|/* count of xmts to send */
name|ndadvance
argument_list|(
operator|&
name|outq
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If data to send, poke mpcc. 	 */
if|if
condition|(
name|xcnt
condition|)
block|{
name|ev
operator|=
name|mp_getevent
argument_list|(
name|mp
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_BUSY
operator||
name|TS_TIMEOUT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|ev
operator|->
name|ev_count
operator|=
name|xcnt
expr_stmt|;
name|mpcmd
argument_list|(
name|ev
argument_list|,
name|EVCMD_WRITE
argument_list|,
literal|0
argument_list|,
name|mb
argument_list|,
name|MPPORT
argument_list|(
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Advance cc bytes from q  but don't free memory.  */
end_comment

begin_expr_stmt
name|ndadvance
argument_list|(
name|q
argument_list|,
name|cc
argument_list|)
specifier|register
expr|struct
name|clist
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|cc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|cblock
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|rem
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|c_cc
operator|<=
literal|0
condition|)
goto|goto
name|out
goto|;
while|while
condition|(
name|cc
operator|>
literal|0
operator|&&
name|q
operator|->
name|c_cc
condition|)
block|{
name|bp
operator|=
operator|(
expr|struct
name|cblock
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|q
operator|->
name|c_cf
operator|&
operator|~
name|CROUND
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|bp
operator|==
operator|(
operator|(
operator|(
name|int
operator|)
name|q
operator|->
name|c_cl
operator|-
literal|1
operator|)
operator|&
operator|~
name|CROUND
operator|)
condition|)
block|{
name|end
operator|=
name|q
operator|->
name|c_cl
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|bp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cblock
argument_list|)
operator|)
expr_stmt|;
block|}
name|rem
operator|=
name|end
operator|-
name|q
operator|->
name|c_cf
expr_stmt|;
if|if
condition|(
name|cc
operator|>=
name|rem
condition|)
block|{
name|cc
operator|-=
name|rem
expr_stmt|;
name|q
operator|->
name|c_cc
operator|-=
name|rem
expr_stmt|;
name|q
operator|->
name|c_cf
operator|=
name|bp
operator|->
name|c_next
operator|->
name|c_info
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|c_cc
operator|-=
name|cc
expr_stmt|;
name|q
operator|->
name|c_cf
operator|+=
name|cc
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|q
operator|->
name|c_cc
operator|<=
literal|0
condition|)
block|{
name|q
operator|->
name|c_cf
operator|=
name|q
operator|->
name|c_cl
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|c_cc
operator|=
literal|0
expr_stmt|;
block|}
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Stop output on a line, e.g. for ^S/^Q or output flush.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
name|mpstop
argument_list|(
name|tp
argument_list|,
name|rw
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|rw
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
comment|/* XXX: DISABLE TRANSMITTER */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialize an async port's MPCC state.  */
end_comment

begin_expr_stmt
name|mpportinit
argument_list|(
name|ms
argument_list|,
name|mp
argument_list|,
name|port
argument_list|)
specifier|register
expr|struct
name|mpsoftc
operator|*
name|ms
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mpport
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mpevent
modifier|*
name|ev
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|caddr_t
name|ptr
decl_stmt|;
name|mp
operator|->
name|mp_on
operator|=
name|mp
operator|->
name|mp_off
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mp_nextrcv
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mp_flags
operator|=
literal|0
expr_stmt|;
name|ev
operator|=
operator|&
name|mp
operator|->
name|mp_recvq
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ev
operator|<
operator|&
name|mp
operator|->
name|mp_recvq
index|[
name|MPINSET
index|]
condition|;
name|ev
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|ev
operator|->
name|ev_status
operator|=
name|EVSTATUS_FREE
expr_stmt|;
name|ev
operator|->
name|ev_cmd
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_opts
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_error
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_count
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_un
operator|.
name|hxl
operator|=
operator|(
expr|struct
name|hxmtl
operator|*
operator|)
name|kvtophys
argument_list|(
operator|&
name|ms
operator|->
name|ms_hxl
index|[
name|port
index|]
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_params
operator|=
operator|(
name|caddr_t
operator|)
name|kvtophys
argument_list|(
operator|&
name|ms
operator|->
name|ms_async
index|[
name|port
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ev
operator|=
operator|&
name|mp
operator|->
name|mp_sendq
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ev
operator|<
operator|&
name|mp
operator|->
name|mp_sendq
index|[
name|MPOUTSET
index|]
condition|;
name|ev
operator|++
operator|,
name|i
operator|++
control|)
block|{
comment|/* init so that L2 can't send any events */
comment|/* to host until open has completed      */
name|ev
operator|->
name|ev_status
operator|=
name|EVSTATUS_FREE
expr_stmt|;
name|ev
operator|->
name|ev_cmd
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_error
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_count
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ms
operator|->
name|ms_cbuf
index|[
name|port
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|ev
operator|->
name|ev_un
operator|.
name|rcvblk
operator|=
operator|(
name|u_char
operator|*
operator|)
name|kvtophys
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_params
operator|=
operator|(
name|caddr_t
operator|)
name|kvtophys
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Send an event to an mpcc.  */
end_comment

begin_expr_stmt
name|mpcmd
argument_list|(
name|ev
argument_list|,
name|cmd
argument_list|,
name|flags
argument_list|,
name|mb
argument_list|,
name|port
argument_list|)
specifier|register
expr|struct
name|mpevent
operator|*
name|ev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mblok
modifier|*
name|mb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
comment|/* move host values to inbound entry */
name|ev
operator|->
name|ev_cmd
operator|=
name|cmd
expr_stmt|;
name|ev
operator|->
name|ev_opts
operator|=
name|flags
expr_stmt|;
comment|/* show event ready for mpcc */
name|ev
operator|->
name|ev_status
operator|=
name|EVSTATUS_GO
expr_stmt|;
name|mpintmpcc
argument_list|(
name|mb
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return the next available event entry for the indicated port.  */
end_comment

begin_function
name|struct
name|mpevent
modifier|*
name|mp_getevent
parameter_list|(
name|mp
parameter_list|,
name|unit
parameter_list|)
specifier|register
name|struct
name|mpport
modifier|*
name|mp
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|mpevent
modifier|*
name|ev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|ev
operator|=
operator|&
name|mp
operator|->
name|mp_recvq
index|[
name|mp
operator|->
name|mp_on
index|]
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_status
operator|!=
name|EVSTATUS_FREE
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * If not a close request, verify one extra 	 * event is available for closing the port. 	 */
if|if
condition|(
operator|(
name|mp
operator|->
name|mp_flags
operator|&
name|MP_PROGRESS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|mp
operator|->
name|mp_on
operator|+
literal|1
operator|)
operator|>=
name|MPINSET
condition|)
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mp_recvq
index|[
name|i
index|]
operator|.
name|ev_status
operator|!=
name|EVSTATUS_FREE
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* init inbound fields marking this entry as busy */
name|ev
operator|->
name|ev_error
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_count
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_status
operator|=
name|EVSTATUS_BUSY
expr_stmt|;
comment|/* adjust pointer to next available inbound entry */
name|adjptr
argument_list|(
name|mp
operator|->
name|mp_on
argument_list|,
name|MPINSET
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ev
operator|)
return|;
name|bad
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mp%d: port%d, out of events"
argument_list|,
name|MPUNIT
argument_list|(
name|unit
argument_list|)
argument_list|,
name|MPPORT
argument_list|(
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|mpevent
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|mpmodem
argument_list|(
argument|unit
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|mpsoftc
modifier|*
name|ms
init|=
operator|&
name|mp_softc
index|[
name|MPUNIT
argument_list|(
name|unit
argument_list|)
index|]
decl_stmt|;
name|int
name|port
init|=
name|MPPORT
argument_list|(
name|unit
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|mpport
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|mpevent
modifier|*
name|ev
decl_stmt|;
specifier|register
name|struct
name|asyncparam
modifier|*
name|asp
decl_stmt|;
name|mp
operator|=
operator|&
name|ms
operator|->
name|ms_mb
operator|->
name|mb_port
index|[
name|port
index|]
expr_stmt|;
name|ev
operator|=
name|mp_getevent
argument_list|(
name|mp
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* YUCK */
name|asp
operator|=
operator|&
name|ms
operator|->
name|ms_async
index|[
name|port
index|]
index|[
name|mp
operator|->
name|mp_on
condition|?
name|mp
operator|->
name|mp_on
operator|-
literal|1
else|:
name|MPINSET
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|MMOD_ON
condition|)
block|{
if|if
condition|(
name|ms
operator|->
name|ms_softCAR
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
condition|)
name|setm
argument_list|(
operator|&
name|asp
operator|->
name|ap_modem
argument_list|,
name|A_DTR
argument_list|,
name|ASSERT
argument_list|)
expr_stmt|;
else|else
name|setm
argument_list|(
operator|&
name|asp
operator|->
name|ap_modem
argument_list|,
name|A_DTR
argument_list|,
name|AUTO
argument_list|)
expr_stmt|;
name|seti
argument_list|(
operator|&
name|asp
operator|->
name|ap_intena
argument_list|,
name|A_DCD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setm
argument_list|(
operator|&
name|asp
operator|->
name|ap_modem
argument_list|,
literal|0
argument_list|,
name|DROP
argument_list|)
expr_stmt|;
name|seti
argument_list|(
operator|&
name|asp
operator|->
name|ap_intena
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mpcmd
argument_list|(
name|ev
argument_list|,
name|EVCMD_IOCTL
argument_list|,
name|A_MDMCHG
argument_list|,
name|ms
operator|->
name|ms_mb
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Set up the modem control structure according to mask.  * Each set bit in the mask means assert the corresponding  * modem control line, otherwise, it will be dropped.    * RTS is special since it can either be asserted, dropped  * or put in auto mode for auto modem control.  */
end_comment

begin_expr_stmt
specifier|static
name|setm
argument_list|(
name|mc
argument_list|,
name|mask
argument_list|,
name|rts
argument_list|)
specifier|register
expr|struct
name|mdmctl
operator|*
name|mc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mc
operator|->
name|mc_rngdsr
operator|=
operator|(
name|mask
operator|&
name|A_RNGDSR
operator|)
condition|?
name|ASSERT
else|:
name|DROP
expr_stmt|;
name|mc
operator|->
name|mc_rate
operator|=
operator|(
name|mask
operator|&
name|A_RATE
operator|)
condition|?
name|ASSERT
else|:
name|DROP
expr_stmt|;
name|mc
operator|->
name|mc_dcd
operator|=
operator|(
name|mask
operator|&
name|A_DCD
operator|)
condition|?
name|ASSERT
else|:
name|DROP
expr_stmt|;
name|mc
operator|->
name|mc_sectx
operator|=
operator|(
name|mask
operator|&
name|A_SECTX
operator|)
condition|?
name|ASSERT
else|:
name|DROP
expr_stmt|;
name|mc
operator|->
name|mc_cts
operator|=
operator|(
name|mask
operator|&
name|A_CTS
operator|)
condition|?
name|ASSERT
else|:
name|DROP
expr_stmt|;
name|mc
operator|->
name|mc_secrx
operator|=
operator|(
name|mask
operator|&
name|A_SECRX
operator|)
condition|?
name|ASSERT
else|:
name|DROP
expr_stmt|;
name|mc
operator|->
name|mc_dtr
operator|=
operator|(
name|mask
operator|&
name|A_DTR
operator|)
condition|?
name|ASSERT
else|:
name|DROP
expr_stmt|;
name|mc
operator|->
name|mc_rts
operator|=
name|rts
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set up the status change enable field from mask.  * When a signal is enabled in this structure and  * and a change in state on a corresponding modem  * control line occurs, a status change event will  * be delivered to the host.  */
end_comment

begin_expr_stmt
specifier|static
name|seti
argument_list|(
name|mc
argument_list|,
name|mask
argument_list|)
specifier|register
expr|struct
name|mdmctl
operator|*
name|mc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mc
operator|->
name|mc_rngdsr
operator|=
operator|(
name|mask
operator|&
name|A_RNGDSR
operator|)
condition|?
name|MDM_ON
else|:
name|MDM_OFF
expr_stmt|;
name|mc
operator|->
name|mc_rate
operator|=
operator|(
name|mask
operator|&
name|A_RATE
operator|)
condition|?
name|MDM_ON
else|:
name|MDM_OFF
expr_stmt|;
name|mc
operator|->
name|mc_dcd
operator|=
operator|(
name|mask
operator|&
name|A_DCD
operator|)
condition|?
name|MDM_ON
else|:
name|MDM_OFF
expr_stmt|;
name|mc
operator|->
name|mc_sectx
operator|=
operator|(
name|mask
operator|&
name|A_SECTX
operator|)
condition|?
name|MDM_ON
else|:
name|MDM_OFF
expr_stmt|;
name|mc
operator|->
name|mc_cts
operator|=
operator|(
name|mask
operator|&
name|A_CTS
operator|)
condition|?
name|MDM_ON
else|:
name|MDM_OFF
expr_stmt|;
name|mc
operator|->
name|mc_secrx
operator|=
operator|(
name|mask
operator|&
name|A_SECRX
operator|)
condition|?
name|MDM_ON
else|:
name|MDM_OFF
expr_stmt|;
name|mc
operator|->
name|mc_dtr
operator|=
operator|(
name|mask
operator|&
name|A_DTR
operator|)
condition|?
name|MDM_ON
else|:
name|MDM_OFF
expr_stmt|;
name|mc
operator|->
name|mc_rts
operator|=
operator|(
name|mask
operator|&
name|A_RTS
operator|)
condition|?
name|MDM_ON
else|:
name|MDM_OFF
expr_stmt|;
block|}
end_block

begin_macro
name|mpcleanport
argument_list|(
argument|mb
argument_list|,
argument|port
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mblok
modifier|*
name|mb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mpport
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|mp
operator|=
operator|&
name|mb
operator|->
name|mb_port
index|[
name|port
index|]
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mp_proto
operator|==
name|MPPROTO_ASYNC
condition|)
block|{
name|mp
operator|->
name|mp_flags
operator|=
name|MP_REMBSY
expr_stmt|;
comment|/* signal loss of carrier and close */
name|tp
operator|=
operator|&
name|mp_tty
index|[
name|mb
operator|->
name|mb_unit
operator|*
name|MPCHUNK
operator|+
name|port
index|]
expr_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mpclose
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|mpclean
argument_list|(
name|mb
argument_list|,
name|port
argument_list|)
specifier|register
expr|struct
name|mblok
operator|*
name|mb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|port
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mpport
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|mpevent
modifier|*
name|ev
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|u_char
name|list
index|[
literal|2
index|]
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|mp
operator|=
operator|&
name|mb
operator|->
name|mb_port
index|[
name|port
index|]
expr_stmt|;
name|unit
operator|=
name|mb
operator|->
name|mb_unit
expr_stmt|;
for|for
control|(
name|i
operator|=
name|mp
operator|->
name|mp_off
init|;
name|i
operator|!=
name|mp
operator|->
name|mp_on
condition|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|%
name|MPINSET
operator|)
control|)
block|{
name|ev
operator|=
operator|&
name|mp
operator|->
name|mp_recvq
index|[
name|i
index|]
expr_stmt|;
name|ev
operator|->
name|ev_error
operator|=
name|ENXIO
expr_stmt|;
name|ev
operator|->
name|ev_status
operator|=
name|EVSTATUS_DONE
expr_stmt|;
block|}
name|list
index|[
literal|0
index|]
operator|=
name|port
operator|,
name|list
index|[
literal|1
index|]
operator|=
name|MPPORT_EOL
expr_stmt|;
name|mpxintr
argument_list|(
name|unit
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|mprintr
argument_list|(
name|unit
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* Clear async for port */
name|mp
operator|->
name|mp_proto
operator|=
name|MPPROTO_UNUSED
expr_stmt|;
name|mp
operator|->
name|mp_flags
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mp_on
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mp_off
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mp_nextrcv
operator|=
literal|0
expr_stmt|;
name|mp_tty
index|[
name|unit
operator|*
name|MPCHUNK
operator|+
name|port
index|]
operator|.
name|t_state
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ev
operator|=
operator|&
name|mp
operator|->
name|mp_sendq
index|[
literal|0
index|]
init|;
name|ev
operator|<
operator|&
name|mp
operator|->
name|mp_sendq
index|[
name|MPOUTSET
index|]
condition|;
name|ev
operator|++
control|)
block|{
name|ev
operator|->
name|ev_status
operator|=
name|EVSTATUS_FREE
expr_stmt|;
name|ev
operator|->
name|ev_cmd
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_error
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_un
operator|.
name|rcvblk
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_params
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|ev
operator|=
operator|&
name|mp
operator|->
name|mp_recvq
index|[
literal|0
index|]
init|;
name|ev
operator|<
operator|&
name|mp
operator|->
name|mp_recvq
index|[
name|MPINSET
index|]
condition|;
name|ev
operator|++
control|)
block|{
name|ev
operator|->
name|ev_status
operator|=
name|EVSTATUS_FREE
expr_stmt|;
name|ev
operator|->
name|ev_cmd
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_error
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_params
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * MPCC interrupt handler.  */
end_comment

begin_macro
name|mpintr
argument_list|(
argument|mpcc
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mpcc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mblok
modifier|*
name|mb
decl_stmt|;
specifier|register
name|struct
name|his
modifier|*
name|his
decl_stmt|;
name|mb
operator|=
name|mp_softc
index|[
name|mpcc
index|]
operator|.
name|ms_mb
expr_stmt|;
if|if
condition|(
name|mb
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"mp%d: stray interrupt\n"
argument_list|,
name|mpcc
argument_list|)
expr_stmt|;
return|return;
block|}
name|his
operator|=
operator|&
name|mb
operator|->
name|mb_hostint
expr_stmt|;
name|his
operator|->
name|semaphore
operator|&=
operator|~
name|MPSEMA_AVAILABLE
expr_stmt|;
comment|/* 	 * Check for events to be processed. 	 */
if|if
condition|(
name|his
operator|->
name|proto
index|[
name|MPPROTO_ASYNC
index|]
operator|.
name|outbdone
index|[
literal|0
index|]
operator|!=
name|MPPORT_EOL
condition|)
name|mprintr
argument_list|(
name|mpcc
argument_list|,
name|his
operator|->
name|proto
index|[
name|MPPROTO_ASYNC
index|]
operator|.
name|outbdone
argument_list|)
expr_stmt|;
if|if
condition|(
name|his
operator|->
name|proto
index|[
name|MPPROTO_ASYNC
index|]
operator|.
name|inbdone
index|[
literal|0
index|]
operator|!=
name|MPPORT_EOL
condition|)
name|mpxintr
argument_list|(
name|mpcc
argument_list|,
name|his
operator|->
name|proto
index|[
name|MPPROTO_ASYNC
index|]
operator|.
name|inbdone
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|mb_harderr
operator|||
name|mb
operator|->
name|mb_softerr
condition|)
name|mperror
argument_list|(
name|mb
argument_list|,
name|mpcc
argument_list|)
expr_stmt|;
name|his
operator|->
name|semaphore
operator||=
name|MPSEMA_AVAILABLE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Handler for processing completion of transmitted events.  */
end_comment

begin_expr_stmt
name|mpxintr
argument_list|(
name|unit
argument_list|,
name|list
argument_list|)
specifier|register
name|u_char
operator|*
name|list
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|mpport
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|mpevent
modifier|*
name|ev
decl_stmt|;
specifier|register
name|struct
name|mblok
modifier|*
name|mb
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|asyncparam
modifier|*
name|ap
decl_stmt|;
name|struct
name|mpsoftc
modifier|*
name|ms
decl_stmt|;
name|int
name|port
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ms
operator|=
operator|&
name|mp_softc
index|[
name|unit
index|]
expr_stmt|;
name|mb
operator|=
name|mp_softc
index|[
name|unit
index|]
operator|.
name|ms_mb
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MPMAXPORT
operator|&&
operator|(
operator|(
name|port
operator|=
operator|*
name|list
operator|++
operator|)
operator|!=
name|MPPORT_EOL
operator|)
condition|;
name|j
operator|++
control|)
block|{
comment|/* 		 * Process each completed entry in the inbound queue. 		 */
name|mp
operator|=
operator|&
name|mb
operator|->
name|mb_port
index|[
name|port
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|mp_tty
index|[
name|unit
operator|*
name|MPCHUNK
operator|+
name|port
index|]
expr_stmt|;
define|#
directive|define
name|nextevent
parameter_list|(
name|mp
parameter_list|)
value|&mp->mp_recvq[mp->mp_off]
name|ev
operator|=
name|nextevent
argument_list|(
name|mp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ev
operator|->
name|ev_status
operator|&
name|EVSTATUS_DONE
condition|;
name|ev
operator|=
name|nextevent
argument_list|(
name|mp
argument_list|)
control|)
block|{
comment|/* YUCK */
name|ap
operator|=
operator|&
name|ms
operator|->
name|ms_async
index|[
name|port
index|]
index|[
name|mp
operator|->
name|mp_off
index|]
expr_stmt|;
name|mppurge
argument_list|(
operator|(
name|caddr_t
operator|)
name|ap
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ev
operator|->
name|ev_cmd
condition|)
block|{
case|case
name|EVCMD_OPEN
case|:
comment|/* 				 * Open completion, start all reads and 				 * assert modem status information. 				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPOUTSET
condition|;
name|i
operator|++
control|)
name|mp
operator|->
name|mp_sendq
index|[
name|i
index|]
operator|.
name|ev_status
operator|=
name|EVSTATUS_GO
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
name|ap
operator|->
name|ap_modem
operator|.
name|mc_dcd
operator|==
name|ASSERT
operator|)
expr_stmt|;
break|break;
case|case
name|EVCMD_CLOSE
case|:
comment|/* 				 * Close completion, flush all pending 				 * transmissions, free resources, and 				 * cleanup mpcc port state. 				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPOUTSET
condition|;
name|i
operator|++
control|)
block|{
name|mp
operator|->
name|mp_sendq
index|[
name|i
index|]
operator|.
name|ev_status
operator|=
name|EVSTATUS_FREE
expr_stmt|;
name|mp
operator|->
name|mp_sendq
index|[
name|i
index|]
operator|.
name|ev_un
operator|.
name|rcvblk
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mp_sendq
index|[
name|i
index|]
operator|.
name|ev_params
operator|=
literal|0
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CARR_ON
expr_stmt|;
name|mp
operator|->
name|mp_on
operator|=
name|mp
operator|->
name|mp_off
operator|=
name|mp
operator|->
name|mp_nextrcv
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mp_flags
operator|&=
operator|~
name|MP_PROGRESS
expr_stmt|;
name|mp
operator|->
name|mp_proto
operator|=
name|MPPROTO_UNUSED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_canq
argument_list|)
expr_stmt|;
comment|/* ??? */
goto|goto
name|done
goto|;
case|case
name|EVCMD_IOCTL
case|:
comment|/* 				 * Nothing to do, just pitch. 				 */
break|break;
case|case
name|EVCMD_WRITE
case|:
comment|/* 				 * Transmission completed, update tty 				 * state and restart output. 				 */
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_FLUSH
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|cc
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|hxmtl
modifier|*
name|hxp
decl_stmt|;
name|hxp
operator|=
operator|&
name|ms
operator|->
name|ms_hxl
index|[
name|port
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ev
operator|->
name|ev_count
condition|;
name|n
operator|++
control|)
name|cc
operator|+=
name|hxp
operator|->
name|size
index|[
name|n
index|]
expr_stmt|;
name|ndflush
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ev
operator|->
name|ev_error
condition|)
block|{
case|case
name|A_SIZERR
case|:
comment|/*# error in xmt data size */
name|mplog
argument_list|(
name|unit
argument_list|,
name|port
argument_list|,
name|A_XSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_NXBERR
case|:
comment|/*# no more xmt evt buffers */
name|mplog
argument_list|(
name|unit
argument_list|,
name|port
argument_list|,
name|A_NOXBUF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|mpstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mplog
argument_list|(
name|unit
argument_list|,
name|port
argument_list|,
name|A_INVCMD
argument_list|,
operator|(
name|int
operator|)
name|ev
operator|->
name|ev_cmd
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* re-init all values in this entry */
name|ev
operator|->
name|ev_cmd
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_opts
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_error
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_count
operator|=
literal|0
expr_stmt|;
comment|/* show this entry is available for use */
name|ev
operator|->
name|ev_status
operator|=
name|EVSTATUS_FREE
expr_stmt|;
name|adjptr
argument_list|(
name|mp
operator|->
name|mp_off
argument_list|,
name|MPINSET
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|nextevent
block|}
name|done
label|:
empty_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Handler for processing received events.  */
end_comment

begin_macro
name|mprintr
argument_list|(
argument|unit
argument_list|,
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|mpport
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|mpevent
modifier|*
name|ev
decl_stmt|;
name|struct
name|mblok
modifier|*
name|mb
decl_stmt|;
specifier|register
name|int
name|cc
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|mpsoftc
modifier|*
name|ms
decl_stmt|;
name|caddr_t
name|ptr
decl_stmt|;
name|char
modifier|*
name|rcverr
decl_stmt|;
name|int
name|port
decl_stmt|,
name|i
decl_stmt|;
name|ms
operator|=
operator|&
name|mp_softc
index|[
name|unit
index|]
expr_stmt|;
name|mb
operator|=
name|mp_softc
index|[
name|unit
index|]
operator|.
name|ms_mb
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPMAXPORT
operator|&&
operator|(
name|port
operator|=
operator|*
name|list
operator|++
operator|)
operator|!=
name|MPPORT_EOL
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
operator|&
name|mp_tty
index|[
name|unit
operator|*
name|MPCHUNK
operator|+
name|port
index|]
expr_stmt|;
name|mp
operator|=
operator|&
name|mb
operator|->
name|mb_port
index|[
name|port
index|]
expr_stmt|;
name|ev
operator|=
operator|&
name|mp
operator|->
name|mp_sendq
index|[
name|mp
operator|->
name|mp_nextrcv
index|]
expr_stmt|;
while|while
condition|(
name|ev
operator|->
name|ev_status
operator|&
name|EVSTATUS_DONE
condition|)
block|{
if|if
condition|(
name|ev
operator|->
name|ev_cmd
operator|!=
name|EVCMD_READ
operator|&&
name|ev
operator|->
name|ev_cmd
operator|!=
name|EVCMD_STATUS
condition|)
block|{
name|mplog
argument_list|(
name|unit
argument_list|,
name|port
argument_list|,
literal|"unexpected command"
argument_list|,
operator|(
name|int
operator|)
name|ev
operator|->
name|ev_cmd
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|ev
operator|->
name|ev_cmd
operator|==
name|EVCMD_STATUS
condition|)
block|{
comment|/* 				 * Status change, look for carrier changes. 				 */
if|if
condition|(
name|ev
operator|->
name|ev_opts
operator|==
name|DCDASRT
operator|||
name|ev
operator|->
name|ev_opts
operator|==
name|DCDDROP
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
name|ev
operator|->
name|ev_opts
operator|==
name|DCDASRT
operator|)
expr_stmt|;
else|else
name|mplog
argument_list|(
name|unit
argument_list|,
name|port
argument_list|,
literal|"unexpect status command"
argument_list|,
operator|(
name|int
operator|)
name|ev
operator|->
name|ev_opts
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 			 * Process received data. 			 */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_ISOPEN
operator||
name|TS_WOPEN
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|next
goto|;
name|cc
operator|=
name|ev
operator|->
name|ev_count
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
goto|goto
name|next
goto|;
comment|/* YUCK */
name|cp
operator|=
name|ms
operator|->
name|ms_cbuf
index|[
name|port
index|]
index|[
name|mp
operator|->
name|mp_nextrcv
index|]
expr_stmt|;
name|mppurge
argument_list|(
name|cp
argument_list|,
name|CBSIZE
argument_list|)
expr_stmt|;
while|while
condition|(
name|cc
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* 				 * A null character is inserted, potentially 				 * when a break or framing error occurs.  If 				 * we're not in raw mode, substitute the 				 * interrupt character. 				 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
operator|&&
operator|(
name|ev
operator|->
name|ev_error
operator|==
name|BRKASRT
operator|||
name|ev
operator|->
name|ev_error
operator|==
name|FRAMERR
operator|)
condition|)
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|RAW
operator|)
operator|==
literal|0
condition|)
operator|*
name|cp
operator|=
name|tp
operator|->
name|t_intrc
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|*
name|cp
operator|++
operator|,
name|tp
operator|)
expr_stmt|;
block|}
comment|/* setup for next read */
name|ptr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|mp_softc
index|[
name|unit
index|]
operator|.
name|ms_cbuf
index|[
name|port
index|]
index|[
name|mp
operator|->
name|mp_nextrcv
index|]
index|[
literal|0
index|]
expr_stmt|;
name|ev
operator|->
name|ev_un
operator|.
name|rcvblk
operator|=
operator|(
name|u_char
operator|*
operator|)
name|kvtophys
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_params
operator|=
operator|(
name|caddr_t
operator|)
name|kvtophys
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ev
operator|->
name|ev_error
condition|)
block|{
case|case
name|RCVDTA
case|:
comment|/* Normal (good) rcv data */
comment|/* do not report the following */
comment|/* they are "normal" errors */
case|case
name|FRAMERR
case|:
comment|/* frame error */
case|case
name|BRKASRT
case|:
comment|/* Break condition */
case|case
name|PARERR
case|:
comment|/* parity error */
name|rcverr
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
break|break;
case|case
name|OVRNERR
case|:
comment|/* Overrun error */
name|rcverr
operator|=
literal|"overrun error"
expr_stmt|;
break|break;
case|case
name|OVFERR
case|:
comment|/* Overflow error */
name|rcverr
operator|=
literal|"overflow error"
expr_stmt|;
break|break;
default|default:
name|rcverr
operator|=
literal|"undefined rcv error"
expr_stmt|;
block|}
if|if
condition|(
name|rcverr
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|mplog
argument_list|(
name|unit
argument_list|,
name|port
argument_list|,
name|rcverr
argument_list|,
operator|(
name|int
operator|)
name|ev
operator|->
name|ev_error
argument_list|)
expr_stmt|;
name|next
label|:
name|ev
operator|->
name|ev_cmd
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_opts
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_error
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_status
operator|=
name|EVSTATUS_GO
expr_stmt|;
comment|/* start next read */
name|adjptr
argument_list|(
name|mp
operator|->
name|mp_nextrcv
argument_list|,
name|MPOUTSET
argument_list|)
expr_stmt|;
name|ev
operator|=
operator|&
name|mp
operator|->
name|mp_sendq
index|[
name|mp
operator|->
name|mp_nextrcv
index|]
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Log an mpcc diagnostic.  */
end_comment

begin_macro
name|mplog
argument_list|(
argument|unit
argument_list|,
argument|port
argument_list|,
argument|cp
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|flags
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mp%d: port%d, %s (%d)\n"
argument_list|,
name|unit
argument_list|,
name|port
argument_list|,
name|cp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mp%d: port%d, %s\n"
argument_list|,
name|unit
argument_list|,
name|port
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|MPHOSTINT
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|mptimeint
argument_list|(
name|mb
argument_list|)
specifier|register
expr|struct
name|mblok
operator|*
name|mb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|mb
operator|->
name|mb_mpintcnt
operator|=
literal|0
expr_stmt|;
name|mb
operator|->
name|mb_mpintclk
operator|=
operator|(
name|caddr_t
operator|)
literal|0
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|mpinfo
index|[
name|mb
operator|->
name|mb_unit
index|]
operator|->
name|ui_addr
operator|=
literal|2
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Interupt mpcc  */
end_comment

begin_expr_stmt
name|mpintmpcc
argument_list|(
name|mb
argument_list|,
name|port
argument_list|)
specifier|register
expr|struct
name|mblok
operator|*
name|mb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|mb
operator|->
name|mb_intr
index|[
name|port
index|]
operator||=
name|MPSEMA_WORK
expr_stmt|;
if|if
condition|(
operator|++
name|mb
operator|->
name|mb_mpintcnt
operator|==
name|MPHOSTINT
condition|)
block|{
name|mb
operator|->
name|mb_mpintcnt
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|mpinfo
index|[
name|mb
operator|->
name|mb_unit
index|]
operator|->
name|ui_addr
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|mb_mpintclk
condition|)
block|{
name|untimeout
argument_list|(
name|mptimeint
argument_list|,
operator|(
name|caddr_t
operator|)
name|mb
argument_list|)
expr_stmt|;
name|mb
operator|->
name|mb_mpintclk
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mb
operator|->
name|mb_mpintclk
operator|==
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|mptimeint
argument_list|,
operator|(
name|caddr_t
operator|)
name|mb
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|mb
operator|->
name|mb_mpintclk
operator|=
operator|(
name|caddr_t
operator|)
literal|1
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mpherrmsg
index|[]
init|=
block|{
literal|""
block|,
literal|"Bus error"
block|,
comment|/* MPBUSERR */
literal|"Address error"
block|,
comment|/* ADDRERR */
literal|"Undefined ecc interrupt"
block|,
comment|/* UNDECC */
literal|"Undefined interrupt"
block|,
comment|/* UNDINT */
literal|"Power failure occurred"
block|,
comment|/* PWRFL */
literal|"Stray transmit done interrupt"
block|,
comment|/* NOXENTRY */
literal|"Two fast timers on one port"
block|,
comment|/* TWOFTMRS */
literal|"Interrupt queue full"
block|,
comment|/* INTQFULL */
literal|"Interrupt queue ack error"
block|,
comment|/* INTQERR */
literal|"Uncorrectable dma parity error"
block|,
comment|/* CBPERR */
literal|"32 port ACAP failed power up"
block|,
comment|/* ACPDEAD */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NHERRS
value|(sizeof (mpherrmsg) / sizeof (mpherrmsg[0]))
end_define

begin_expr_stmt
name|mperror
argument_list|(
name|mb
argument_list|,
name|unit
argument_list|)
specifier|register
expr|struct
name|mblok
operator|*
name|mb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mb
operator|->
name|mb_softerr
condition|)
block|{
switch|switch
condition|(
name|mb
operator|->
name|mb_softerr
condition|)
block|{
case|case
name|DMAPERR
case|:
comment|/* dma parity error */
name|cp
operator|=
literal|"dma parity error"
expr_stmt|;
break|break;
case|case
name|ECCERR
case|:
name|cp
operator|=
literal|"local memory ecc error"
expr_stmt|;
break|break;
default|default:
name|cp
operator|=
literal|"unknown error"
expr_stmt|;
break|break;
block|}
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mp%d: soft error, %s"
argument_list|,
name|unit
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|mb
operator|->
name|mb_softerr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mb
operator|->
name|mb_harderr
condition|)
block|{
if|if
condition|(
name|mb
operator|->
name|mb_harderr
operator|<
name|NHERRS
condition|)
name|cp
operator|=
name|mpherrmsg
index|[
name|mb
operator|->
name|mb_harderr
index|]
expr_stmt|;
else|else
name|cp
operator|=
literal|"unknown error"
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mp%d: hard error, %s"
argument_list|,
name|unit
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|mb_status
operator|==
name|MP_OPOPEN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPMAXPORT
condition|;
name|i
operator|++
control|)
block|{
name|mpcleanport
argument_list|(
name|mb
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mb
operator|->
name|mb_proto
index|[
name|i
index|]
operator|=
name|MPPROTO_UNUSED
expr_stmt|;
block|}
block|}
name|mb
operator|->
name|mb_harderr
operator|=
literal|0
expr_stmt|;
name|mb
operator|->
name|mb_status
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|mppurge
argument_list|(
name|addr
argument_list|,
name|cc
argument_list|)
specifier|register
name|caddr_t
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|cc
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
name|cc
operator|>=
literal|0
condition|;
name|addr
operator|+=
name|NBPG
operator|,
name|cc
operator|-=
name|NBPG
control|)
name|mtpr
argument_list|(
name|P1DC
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * MPCC Download Pseudo-device.  */
end_comment

begin_decl_stmt
name|char
name|mpdlbuf
index|[
name|MPDLBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mpdlbusy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interlock on download buffer */
end_comment

begin_decl_stmt
name|int
name|mpdlerr
decl_stmt|;
end_decl_stmt

begin_macro
name|mpdlopen
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
decl_stmt|,
name|mpu
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mpu
operator|=
name|MPUNIT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpu
operator|>=
name|NMP
operator|||
operator|(
name|vi
operator|=
name|mpinfo
index|[
name|mpu
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|mpdlwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mpsoftc
modifier|*
name|ms
init|=
operator|&
name|mp_softc
index|[
name|MPUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|mpdl
modifier|*
name|dl
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ms
operator|->
name|ms_mb
operator|==
literal|0
operator|||
name|ms
operator|->
name|ms_mb
operator|->
name|mb_status
operator|!=
name|MP_DLOPEN
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|dl
operator|=
operator|&
name|ms
operator|->
name|ms_mb
operator|->
name|mb_dl
expr_stmt|;
name|dl
operator|->
name|mpdl_count
operator|=
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
expr_stmt|;
name|dl
operator|->
name|mpdl_data
operator|=
operator|(
name|caddr_t
operator|)
name|kvtophys
argument_list|(
name|mpdlbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|uiomove
argument_list|(
name|mpdlbuf
argument_list|,
operator|(
name|int
operator|)
name|dl
operator|->
name|mpdl_count
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|uio
operator|->
name|uio_resid
operator|-=
name|dl
operator|->
name|mpdl_count
expr_stmt|;
comment|/* set up return from write */
name|dl
operator|->
name|mpdl_cmd
operator|=
name|MPDLCMD_NORMAL
expr_stmt|;
name|error
operator|=
name|mpdlwait
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|mpdlclose
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mblok
modifier|*
name|mb
init|=
name|mp_softc
index|[
name|MPUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
index|]
operator|.
name|ms_mb
decl_stmt|;
if|if
condition|(
name|mb
operator|==
literal|0
operator|||
name|mb
operator|->
name|mb_status
operator|!=
name|MP_DLDONE
condition|)
block|{
name|mpbogus
operator|.
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mpbogus
operator|.
name|mb
operator|==
name|mpbogus
operator|.
name|mbloks
index|[
name|MPUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
index|]
condition|)
name|mpdlbusy
operator|--
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|mb
operator|->
name|mb_status
operator|=
name|MP_OPOPEN
expr_stmt|;
name|mpbogus
operator|.
name|status
operator|=
literal|0
expr_stmt|;
comment|/* set to dead, for board handshake */
name|mb
operator|->
name|mb_hostint
operator|.
name|imok
operator|=
name|MPIMOK_DEAD
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function_decl
name|int
name|mpdltimeout
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|mpdlioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mblok
modifier|*
name|mb
decl_stmt|;
specifier|register
name|struct
name|mpdl
modifier|*
name|dl
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|error
decl_stmt|,
name|s
decl_stmt|,
name|i
decl_stmt|;
name|mb
operator|=
name|mp_softc
index|[
name|unit
operator|=
name|MPUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
index|]
operator|.
name|ms_mb
expr_stmt|;
if|if
condition|(
name|mb
operator|==
literal|0
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
name|dl
operator|=
operator|&
name|mb
operator|->
name|mb_dl
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MPIOPORTMAP
case|:
name|bcopy
argument_list|(
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
name|mb
operator|->
name|mb_proto
argument_list|,
sizeof|sizeof
argument_list|(
name|mb
operator|->
name|mb_proto
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPIOHILO
case|:
name|bcopy
argument_list|(
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|mb
operator|->
name|mb_hiport
argument_list|,
literal|2
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|mb
operator|->
name|mb_hiport
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPIOENDDL
case|:
name|dl
operator|->
name|mpdl_count
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|mpdl_data
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|mpdl_cmd
operator|=
name|MPIOENDDL
operator|&
name|IOCPARM_MASK
expr_stmt|;
name|error
operator|=
name|mpdlwait
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|mpccinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|mb
operator|->
name|mb_status
operator|=
name|MP_DLDONE
expr_stmt|;
name|mpdlbusy
operator|--
expr_stmt|;
break|break;
case|case
name|MPIOENDCODE
case|:
name|dl
operator|->
name|mpdl_count
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|mpdl_data
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|mpdl_cmd
operator|=
name|MPIOENDCODE
operator|&
name|IOCPARM_MASK
expr_stmt|;
name|error
operator|=
name|mpdlwait
argument_list|(
name|dl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPIOASYNCNF
case|:
name|bcopy
argument_list|(
name|data
argument_list|,
name|mpdlbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|abdcf
argument_list|)
argument_list|)
expr_stmt|;
name|dl
operator|->
name|mpdl_data
operator|=
operator|(
name|caddr_t
operator|)
name|kvtophys
argument_list|(
name|mpdlbuf
argument_list|)
expr_stmt|;
name|dl
operator|->
name|mpdl_count
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|abdcf
argument_list|)
expr_stmt|;
name|dl
operator|->
name|mpdl_cmd
operator|=
name|MPIOASYNCNF
operator|&
name|IOCPARM_MASK
expr_stmt|;
name|error
operator|=
name|mpdlwait
argument_list|(
name|dl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPIOSTARTDL
case|:
while|while
condition|(
name|mpdlbusy
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|mpdlbusy
argument_list|,
name|PZERO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mpdlbusy
operator|++
expr_stmt|;
comment|/* initialize the downloading interface */
name|mpbogus
operator|.
name|magic
operator|=
name|MPMAGIC
expr_stmt|;
name|mpbogus
operator|.
name|mb
operator|=
name|mpbogus
operator|.
name|mbloks
index|[
name|unit
index|]
expr_stmt|;
name|mpbogus
operator|.
name|status
operator|=
literal|1
expr_stmt|;
name|dl
operator|->
name|mpdl_status
operator|=
name|EVSTATUS_FREE
expr_stmt|;
name|dl
operator|->
name|mpdl_count
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|mpdl_cmd
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|mpdl_data
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|mpdlerr
operator|=
literal|0
expr_stmt|;
name|mb
operator|->
name|mb_magic
operator|=
name|MPMAGIC
expr_stmt|;
name|mb
operator|->
name|mb_ivec
operator|=
name|mp_softc
index|[
name|unit
index|]
operator|.
name|ms_ivec
operator|+
literal|1
expr_stmt|;
comment|/* download vector */
name|mb
operator|->
name|mb_status
operator|=
name|MP_DLPEND
expr_stmt|;
name|mb
operator|->
name|mb_diagswitch
index|[
literal|0
index|]
operator|=
literal|'A'
expr_stmt|;
name|mb
operator|->
name|mb_diagswitch
index|[
literal|1
index|]
operator|=
literal|'P'
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|mpinfo
index|[
name|unit
index|]
operator|->
name|ui_addr
operator|=
literal|2
expr_stmt|;
name|timeout
argument_list|(
name|mpdltimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|mb
argument_list|,
literal|30
operator|*
name|hz
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|mb
operator|->
name|mb_status
argument_list|,
name|PZERO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|mb_status
operator|==
name|MP_DLOPEN
condition|)
block|{
name|untimeout
argument_list|(
name|mpdltimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|mb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mb
operator|->
name|mb_status
operator|==
name|MP_DLTIME
condition|)
block|{
name|mpbogus
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
else|else
block|{
name|mpbogus
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mp%d: start download: unknown status %x"
argument_list|,
name|unit
argument_list|,
name|mb
operator|->
name|mb_status
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mb
operator|->
name|mb_port
argument_list|,
sizeof|sizeof
argument_list|(
name|mb
operator|->
name|mb_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPIORESETBOARD
case|:
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|mb_imokclk
condition|)
name|mb
operator|->
name|mb_imokclk
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
name|mpinfo
index|[
name|unit
index|]
operator|->
name|ui_addr
operator|=
literal|0x100
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|mb_status
operator|==
name|MP_DLOPEN
operator|||
name|mb
operator|->
name|mb_status
operator|==
name|MP_DLDONE
condition|)
block|{
name|mpdlerr
operator|=
name|MP_DLERROR
expr_stmt|;
name|dl
operator|->
name|mpdl_status
operator|=
name|EVSTATUS_FREE
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dl
operator|->
name|mpdl_status
argument_list|)
expr_stmt|;
name|mpbogus
operator|.
name|status
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPMAXPORT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mb
operator|->
name|mb_harderr
operator|||
name|mb
operator|->
name|mb_softerr
condition|)
name|mperror
argument_list|(
name|mb
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mpcleanport
argument_list|(
name|mb
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mb
operator|->
name|mb_proto
index|[
name|i
index|]
operator|=
name|MPPROTO_UNUSED
expr_stmt|;
block|}
name|mb
operator|->
name|mb_status
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|mpccinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mblok
modifier|*
name|mb
init|=
name|mp_softc
index|[
name|unit
index|]
operator|.
name|ms_mb
decl_stmt|;
specifier|register
name|struct
name|his
modifier|*
name|his
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|mb
operator|->
name|mb_status
operator|=
name|MP_DLDONE
expr_stmt|;
name|mb
operator|->
name|mb_ivec
operator|=
name|mp_softc
index|[
name|unit
index|]
operator|.
name|ms_ivec
expr_stmt|;
name|mb
operator|->
name|mb_magic
operator|=
name|MPMAGIC
expr_stmt|;
comment|/* Init host interface structure */
name|his
operator|=
operator|&
name|mb
operator|->
name|mb_hostint
expr_stmt|;
name|his
operator|->
name|semaphore
operator|=
name|MPSEMA_AVAILABLE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMPPROTO
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MPMAXPORT
condition|;
name|j
operator|++
control|)
block|{
name|his
operator|->
name|proto
index|[
name|i
index|]
operator|.
name|inbdone
index|[
name|j
index|]
operator|=
name|MPPORT_EOL
expr_stmt|;
name|his
operator|->
name|proto
index|[
name|i
index|]
operator|.
name|outbdone
index|[
name|j
index|]
operator|=
name|MPPORT_EOL
expr_stmt|;
block|}
name|mb
operator|->
name|mb_unit
operator|=
name|unit
expr_stmt|;
block|}
end_block

begin_macro
name|mpdlintr
argument_list|(
argument|mpcc
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mpcc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mblok
modifier|*
name|mb
decl_stmt|;
specifier|register
name|struct
name|mpdl
modifier|*
name|dl
decl_stmt|;
name|mb
operator|=
name|mp_softc
index|[
name|mpcc
index|]
operator|.
name|ms_mb
expr_stmt|;
if|if
condition|(
name|mb
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"mp%d: stray download interrupt\n"
argument_list|,
name|mpcc
argument_list|)
expr_stmt|;
return|return;
block|}
name|dl
operator|=
operator|&
name|mb
operator|->
name|mb_dl
expr_stmt|;
switch|switch
condition|(
name|mb
operator|->
name|mb_status
condition|)
block|{
case|case
name|MP_DLOPEN
case|:
if|if
condition|(
name|dl
operator|->
name|mpdl_status
operator|!=
name|EVSTATUS_DONE
condition|)
name|mpdlerr
operator|=
name|MP_DLERROR
expr_stmt|;
name|dl
operator|->
name|mpdl_status
operator|=
name|EVSTATUS_FREE
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dl
operator|->
name|mpdl_status
argument_list|)
expr_stmt|;
return|return;
case|case
name|MP_DLPEND
case|:
name|mb
operator|->
name|mb_status
operator|=
name|MP_DLOPEN
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|mb
operator|->
name|mb_status
argument_list|)
expr_stmt|;
comment|/* fall thru... */
case|case
name|MP_DLTIME
case|:
return|return;
case|case
name|MP_OPOPEN
case|:
if|if
condition|(
name|mb
operator|->
name|mb_imokclk
condition|)
name|mb
operator|->
name|mb_imokclk
operator|=
literal|0
expr_stmt|;
name|mb
operator|->
name|mb_nointcnt
operator|=
literal|0
expr_stmt|;
comment|/* reset no interrupt count */
name|mb
operator|->
name|mb_hostint
operator|.
name|imok
operator|=
name|MPIMOK_DEAD
expr_stmt|;
name|mb
operator|->
name|mb_imokclk
operator|=
operator|(
name|caddr_t
operator|)
literal|1
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mp%d: mpdlintr, status %x\n"
argument_list|,
name|mpcc
argument_list|,
name|mb
operator|->
name|mb_status
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|mpdltimeout
argument_list|(
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mblok
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mp
operator|->
name|mb_status
operator|=
name|MP_DLTIME
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|mp
operator|->
name|mb_status
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * Wait for a transfer to complete or a timeout to occur.  */
end_comment

begin_expr_stmt
name|mpdlwait
argument_list|(
name|dl
argument_list|)
specifier|register
expr|struct
name|mpdl
operator|*
name|dl
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|dl
operator|->
name|mpdl_status
operator|=
name|EVSTATUS_GO
expr_stmt|;
while|while
condition|(
name|dl
operator|->
name|mpdl_status
operator|!=
name|EVSTATUS_FREE
condition|)
block|{
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dl
operator|->
name|mpdl_status
argument_list|,
name|PZERO
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpdlerr
operator|==
name|MP_DLERROR
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

