begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Harris Corp.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)hd.c	7.8 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"hd.h"
end_include

begin_if
if|#
directive|if
name|NHD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"dkstat.h"
end_include

begin_include
include|#
directive|include
file|"disklabel.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/hdreg.h"
end_include

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_define
define|#
directive|define
name|hdunit
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>>3)
end_define

begin_define
define|#
directive|define
name|hdpart
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)&0x07)
end_define

begin_define
define|#
directive|define
name|hdminor
parameter_list|(
name|unit
parameter_list|,
name|part
parameter_list|)
value|(((unit)<<3)|(part))
end_define

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|hdcminfo
index|[
name|NHDC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|hddinfo
index|[
name|NHD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hdcprobe
argument_list|()
decl_stmt|,
name|hdslave
argument_list|()
decl_stmt|,
name|hdattach
argument_list|()
decl_stmt|,
name|hddgo
argument_list|()
decl_stmt|,
name|hdstrategy
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|hdstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|hdcdriver
init|=
block|{
name|hdcprobe
block|,
name|hdslave
block|,
name|hdattach
block|,
name|hddgo
block|,
name|hdstd
block|,
literal|"hd"
block|,
name|hddinfo
block|,
literal|"hdc"
block|,
name|hdcminfo
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Per-controller state.  */
end_comment

begin_struct
struct|struct
name|hdcsoftc
block|{
name|u_short
name|hdc_flags
decl_stmt|;
define|#
directive|define
name|HDC_INIT
value|0x01
comment|/* controller initialized */
define|#
directive|define
name|HDC_STARTED
value|0x02
comment|/* start command issued */
define|#
directive|define
name|HDC_LOCKED
value|0x04
comment|/* locked for direct controller access */
define|#
directive|define
name|HDC_WAIT
value|0x08
comment|/* someone needs direct controller access */
name|u_short
name|hdc_wticks
decl_stmt|;
comment|/* timeout */
name|struct
name|master_mcb
modifier|*
name|hdc_mcbp
decl_stmt|;
comment|/* address of controller mcb */
name|struct
name|registers
modifier|*
name|hdc_reg
decl_stmt|;
comment|/* base address of i/o regs */
name|struct
name|vb_buf
name|hdc_rbuf
decl_stmt|;
comment|/* vba resources */
name|struct
name|master_mcb
name|hdc_mcb
decl_stmt|;
comment|/* controller mcb */
block|}
name|hdcsoftc
index|[
name|NHDC
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|HDCMAXTIME
value|20
end_define

begin_comment
comment|/* max time for operation, sec. */
end_comment

begin_define
define|#
directive|define
name|HDCINTERRUPT
value|0xf0
end_define

begin_comment
comment|/* interrupt vector */
end_comment

begin_comment
comment|/*  * Per-drive state; probably everything should be "hd_", not "dk_",  * but it's not worth it, and dk is a better mnemonic for disk anyway.  */
end_comment

begin_struct
struct|struct
name|dksoftc
block|{
ifdef|#
directive|ifdef
name|COMPAT_42
name|u_short
name|dk_def_cyl
decl_stmt|;
comment|/* definition track cylinder address */
endif|#
directive|endif
name|int
name|dk_state
decl_stmt|;
comment|/* open fsm */
name|u_short
name|dk_bshift
decl_stmt|;
comment|/* shift for * (DEV_BSIZE / sectorsize) XXX */
name|int
name|dk_wlabel
decl_stmt|;
comment|/* if label sector is writeable */
name|u_long
name|dk_copenpart
decl_stmt|;
comment|/* character units open on this drive */
name|u_long
name|dk_bopenpart
decl_stmt|;
comment|/* block units open on this drive */
name|u_long
name|dk_openpart
decl_stmt|;
comment|/* all units open on this drive */
name|int
name|dk_unit
decl_stmt|;
comment|/* unit# */
name|int
name|dk_ctlr
decl_stmt|;
comment|/* controller# */
name|int
name|dk_format
decl_stmt|;
comment|/* if format program is using disk */
name|struct
name|buf
name|dk_utab
decl_stmt|;
comment|/* i/o queue header */
name|struct
name|disklabel
name|dk_label
decl_stmt|;
comment|/* disklabel for this disk */
name|struct
name|mcb
name|dk_mcb
decl_stmt|;
comment|/* disk mcb */
block|}
name|dksoftc
index|[
name|NHD
index|]
struct|;
end_struct

begin_comment
comment|/*  * Drive states.  Used during steps of open/initialization.  * States< OPEN (> 0) are transient, during an open operation.  * OPENRAW is used for unlabeled disks, to allow format operations.  */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|0
end_define

begin_comment
comment|/* disk is closed */
end_comment

begin_define
define|#
directive|define
name|WANTOPEN
value|1
end_define

begin_comment
comment|/* open requested, not started */
end_comment

begin_define
define|#
directive|define
name|WANTOPENRAW
value|2
end_define

begin_comment
comment|/* open requested, no label */
end_comment

begin_define
define|#
directive|define
name|RDLABEL
value|3
end_define

begin_comment
comment|/* reading pack label */
end_comment

begin_define
define|#
directive|define
name|OPEN
value|4
end_define

begin_comment
comment|/* intialized and ready */
end_comment

begin_define
define|#
directive|define
name|OPENRAW
value|5
end_define

begin_comment
comment|/* open, no label */
end_comment

begin_decl_stmt
name|int
name|hdcwstart
decl_stmt|,
name|hdcwatch
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* see if the controller is really there, if so, init it. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|hdcprobe
argument_list|(
argument|reg
argument_list|,
argument|vm
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* register */
end_comment

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* must be r12, r11 */
specifier|register
name|struct
name|hdcsoftc
modifier|*
name|hdc
decl_stmt|;
specifier|static
name|struct
name|module_id
name|id
decl_stmt|;
name|struct
name|pte
modifier|*
name|dummypte
decl_stmt|;
name|caddr_t
name|putl
decl_stmt|;
comment|/* initialize the hdc controller structure. */
name|hdc
operator|=
operator|&
name|hdcsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|vbmemalloc
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|,
operator|&
name|dummypte
argument_list|,
operator|&
name|putl
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"hdc%d: vbmemalloc failed.\n"
argument_list|,
name|vm
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hdc
operator|->
name|hdc_reg
operator|=
operator|(
expr|struct
name|registers
operator|*
operator|)
name|putl
expr_stmt|;
comment|/* 	 * try and ping the MID register; side effect of wbadaddr is to read 	 * the module id; the controller is bad if it's not an hdc, the hdc's 	 * writeable control store is not loaded, or the hdc failed the 	 * functional integrity test; 	 */
if|if
condition|(
name|wbadaddr
argument_list|(
operator|&
name|hdc
operator|->
name|hdc_reg
operator|->
name|module_id
argument_list|,
literal|4
argument_list|,
name|vtoph
argument_list|(
operator|(
expr|struct
name|process
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|id
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|PADC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|.
name|module_id
operator|!=
operator|(
name|u_char
operator|)
name|HDC_MID
condition|)
block|{
name|printf
argument_list|(
literal|"hdc%d: bad module id; id = %x.\n"
argument_list|,
name|vm
operator|->
name|um_ctlr
argument_list|,
name|id
operator|.
name|module_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|id
operator|.
name|code_rev
operator|==
operator|(
name|u_char
operator|)
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"hdc%d: micro-code not loaded.\n"
argument_list|,
name|vm
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|id
operator|.
name|fit
operator|!=
operator|(
name|u_char
operator|)
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"hdc%d: FIT test failed.\n"
argument_list|,
name|vm
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* reset that pup; flag as inited */
name|hdc
operator|->
name|hdc_reg
operator|->
name|soft_reset
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|hdc
operator|->
name|hdc_flags
operator||=
name|HDC_INIT
expr_stmt|;
comment|/* allocate page tables and i/o buffer. */
if|if
condition|(
operator|!
name|vbainit
argument_list|(
operator|&
name|hdc
operator|->
name|hdc_rbuf
argument_list|,
name|MAXPHYS
argument_list|,
name|VB_32BIT
operator||
name|VB_SCATTER
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"hdc%d: vbainit failed\n"
argument_list|,
name|vm
operator|->
name|um_ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* set pointer to master control block */
name|hdc
operator|->
name|hdc_mcbp
operator|=
operator|(
expr|struct
name|master_mcb
operator|*
operator|)
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|hdc
operator|->
name|hdc_mcb
argument_list|)
expr_stmt|;
name|br
operator|=
literal|0x17
operator|,
name|cvec
operator|=
name|HDCINTERRUPT
operator|+
name|vm
operator|->
name|um_ctlr
expr_stmt|;
comment|/* XXX */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|registers
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|hdslave
argument_list|(
argument|vi
argument_list|,
argument|vdaddr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vddevice
modifier|*
name|vdaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mcb
modifier|*
name|mcb
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|static
name|struct
name|status
name|status
decl_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
name|dk
operator|->
name|dk_unit
operator|=
name|vi
operator|->
name|ui_unit
expr_stmt|;
name|dk
operator|->
name|dk_ctlr
operator|=
name|vi
operator|->
name|ui_ctlr
expr_stmt|;
name|mcb
operator|=
operator|&
name|dk
operator|->
name|dk_mcb
expr_stmt|;
name|mcb
operator|->
name|command
operator|=
name|HCMD_STATUS
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|wcount
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|status
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|memadr
operator|=
operator|(
name|u_long
operator|)
name|vtoph
argument_list|(
operator|(
expr|struct
name|process
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdimcb
argument_list|(
name|dk
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" (no status)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Report the drive down if anything in the drive status looks bad. 	 * If the drive is offline and it is not on cylinder, then the drive 	 * is not there.  If there is a fault condition, the hdc will try to 	 * clear it when we read the disklabel information. 	 */
if|if
condition|(
operator|!
operator|(
name|status
operator|.
name|drs
operator|&
name|DRS_ONLINE
operator|)
condition|)
block|{
if|if
condition|(
name|status
operator|.
name|drs
operator|&
name|DRS_ON_CYLINDER
condition|)
name|printf
argument_list|(
literal|" (not online)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|status
operator|.
name|drs
operator|&
name|DRS_FAULT
condition|)
name|printf
argument_list|(
literal|" (clearing fault)"
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|&
name|dk
operator|->
name|dk_label
expr_stmt|;
ifdef|#
directive|ifdef
name|RAW_SIZE
name|lp
operator|->
name|d_secsize
operator|=
name|status
operator|.
name|bytes_per_sec
expr_stmt|;
else|#
directive|else
name|lp
operator|->
name|d_secsize
operator|=
literal|512
expr_stmt|;
endif|#
directive|endif
name|lp
operator|->
name|d_nsectors
operator|=
name|status
operator|.
name|max_sector
operator|+
literal|1
expr_stmt|;
name|lp
operator|->
name|d_ntracks
operator|=
name|status
operator|.
name|max_head
operator|+
literal|1
expr_stmt|;
name|lp
operator|->
name|d_ncylinders
operator|=
name|status
operator|.
name|max_cyl
operator|+
literal|1
expr_stmt|;
name|lp
operator|->
name|d_secpercyl
operator|=
name|lp
operator|->
name|d_ntracks
operator|*
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|lp
operator|->
name|d_npartitions
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
name|LABELSECTOR
operator|+
literal|1
expr_stmt|;
name|lp
operator|->
name|d_rpm
operator|=
name|status
operator|.
name|rpm
expr_stmt|;
name|lp
operator|->
name|d_typename
index|[
literal|0
index|]
operator|=
literal|'h'
expr_stmt|;
name|lp
operator|->
name|d_typename
index|[
literal|1
index|]
operator|=
literal|'d'
expr_stmt|;
name|lp
operator|->
name|d_typename
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_42
name|dk
operator|->
name|dk_def_cyl
operator|=
name|status
operator|.
name|def_cyl
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|hdattach
argument_list|(
name|vi
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|vi
operator|->
name|ui_unit
expr_stmt|;
if|if
condition|(
name|hdinit
argument_list|(
name|hdminor
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": unknown drive type"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
name|lp
operator|=
operator|&
name|dk
operator|->
name|dk_label
expr_stmt|;
name|hd_setsecsize
argument_list|(
name|dk
argument_list|,
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dk
operator|->
name|dk_state
operator|==
name|OPEN
condition|)
name|printf
argument_list|(
literal|": %s<secsize %d, ntrak %d, ncyl %d, nsec %d>"
argument_list|,
name|lp
operator|->
name|d_typename
argument_list|,
name|lp
operator|->
name|d_secsize
argument_list|,
name|lp
operator|->
name|d_ntracks
argument_list|,
name|lp
operator|->
name|d_ncylinders
argument_list|,
name|lp
operator|->
name|d_nsectors
argument_list|)
expr_stmt|;
comment|/* 	 * (60 / rpm) / (sectors per track * (bytes per sector / 2)) 	 */
if|if
condition|(
name|vi
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
name|dk_wpms
index|[
name|vi
operator|->
name|ui_dk
index|]
operator|=
operator|(
name|lp
operator|->
name|d_rpm
operator|*
name|lp
operator|->
name|d_nsectors
operator|*
name|lp
operator|->
name|d_secsize
operator|)
operator|/
literal|120
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|addswap
argument_list|(
name|makedev
argument_list|(
name|HDMAJOR
argument_list|,
name|hdminor
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|lp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|hdopen
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|,
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|,
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|register
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|part
init|=
name|hdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|mask
init|=
literal|1
operator|<<
name|part
decl_stmt|;
name|daddr_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|unit
operator|=
name|hdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NHD
operator|||
operator|(
name|vi
operator|=
name|hddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
name|lp
operator|=
operator|&
name|dk
operator|->
name|dk_label
expr_stmt|;
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
while|while
condition|(
name|dk
operator|->
name|dk_state
operator|!=
name|OPEN
operator|&&
name|dk
operator|->
name|dk_state
operator|!=
name|OPENRAW
operator|&&
name|dk
operator|->
name|dk_state
operator|!=
name|CLOSED
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dk
argument_list|,
name|PZERO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dk
operator|->
name|dk_state
operator|!=
name|OPEN
operator|&&
name|dk
operator|->
name|dk_state
operator|!=
name|OPENRAW
condition|)
if|if
condition|(
name|error
operator|=
name|hdinit
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|hdcwstart
operator|==
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|hdcwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|hdcwstart
operator|++
expr_stmt|;
block|}
comment|/* 	 * Warn if a partion is opened that overlaps another partition 	 * which is open unless one is the "raw" partition (whole disk). 	 */
define|#
directive|define
name|RAWPART
value|8
comment|/* 'x' partition */
comment|/* XXX */
if|if
condition|(
operator|(
name|dk
operator|->
name|dk_openpart
operator|&
name|mask
operator|)
operator|==
literal|0
operator|&&
name|part
operator|!=
name|RAWPART
condition|)
block|{
name|pp
operator|=
operator|&
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
expr_stmt|;
name|start
operator|=
name|pp
operator|->
name|p_offset
expr_stmt|;
name|end
operator|=
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|lp
operator|->
name|d_partitions
init|;
name|pp
operator|<
operator|&
name|lp
operator|->
name|d_partitions
index|[
name|lp
operator|->
name|d_npartitions
index|]
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
operator|<=
name|start
operator|||
name|pp
operator|->
name|p_offset
operator|>=
name|end
condition|)
continue|continue;
if|if
condition|(
name|pp
operator|-
name|lp
operator|->
name|d_partitions
operator|==
name|RAWPART
condition|)
continue|continue;
if|if
condition|(
name|dk
operator|->
name|dk_openpart
operator|&
operator|(
literal|1
operator|<<
operator|(
name|pp
operator|-
name|lp
operator|->
name|d_partitions
operator|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"hd%d%c: overlaps open partition (%c)\n"
argument_list|,
name|unit
argument_list|,
name|part
operator|+
literal|'a'
argument_list|,
name|pp
operator|-
name|lp
operator|->
name|d_partitions
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|part
operator|>=
name|lp
operator|->
name|d_npartitions
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dk
operator|->
name|dk_openpart
operator||=
name|mask
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|dk
operator|->
name|dk_copenpart
operator||=
name|mask
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|dk
operator|->
name|dk_bopenpart
operator||=
name|mask
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|hdclose
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|,
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|,
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|hdunit
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
name|hdpart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|dk
operator|->
name|dk_copenpart
operator|&=
operator|~
name|mask
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|dk
operator|->
name|dk_bopenpart
operator|&=
operator|~
name|mask
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|dk
operator|->
name|dk_copenpart
operator||
name|dk
operator|->
name|dk_bopenpart
operator|)
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
name|dk
operator|->
name|dk_openpart
operator|&=
operator|~
name|mask
expr_stmt|;
comment|/* 	 * Should wait for i/o to complete on this partition 	 * even if others are open, but wait for work on blkflush(). 	 */
if|if
condition|(
name|dk
operator|->
name|dk_openpart
operator|==
literal|0
condition|)
block|{
name|int
name|s
init|=
name|spl7
argument_list|()
decl_stmt|;
while|while
condition|(
name|dk
operator|->
name|dk_utab
operator|.
name|b_actf
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dk
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dk
operator|->
name|dk_state
operator|=
name|CLOSED
expr_stmt|;
name|dk
operator|->
name|dk_wlabel
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|hdinit
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|int
name|error
decl_stmt|,
name|unit
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|readdisklabel
argument_list|()
decl_stmt|;
specifier|extern
name|int
name|cold
decl_stmt|;
name|vi
operator|=
name|hddinfo
index|[
name|unit
operator|=
name|hdunit
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
name|dk
operator|->
name|dk_unit
operator|=
name|vi
operator|->
name|ui_slave
expr_stmt|;
name|dk
operator|->
name|dk_ctlr
operator|=
name|vi
operator|->
name|ui_ctlr
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|O_NDELAY
condition|)
block|{
name|dk
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
operator|&
name|dk
operator|->
name|dk_label
expr_stmt|;
name|dk
operator|->
name|dk_state
operator|=
name|RDLABEL
expr_stmt|;
if|if
condition|(
name|msg
operator|=
name|readdisklabel
argument_list|(
name|dev
argument_list|,
name|hdstrategy
argument_list|,
name|lp
argument_list|)
condition|)
block|{
if|if
condition|(
name|cold
condition|)
block|{
name|printf
argument_list|(
literal|": %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|dk
operator|->
name|dk_state
operator|=
name|CLOSED
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"hd%d: %s\n"
argument_list|,
name|unit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|dk
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COMPAT_42
name|hdclock
argument_list|(
name|vi
operator|->
name|ui_ctlr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|error
operator|=
name|hdreadgeometry
argument_list|(
name|dk
argument_list|)
operator|)
condition|)
name|dk
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
name|hdcunlock
argument_list|(
name|vi
operator|->
name|ui_ctlr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|dk
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|hd_setsecsize
argument_list|(
name|dk
argument_list|,
name|lp
argument_list|)
specifier|register
expr|struct
name|dksoftc
operator|*
name|dk
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|mul
decl_stmt|;
comment|/* 	 * Calculate scaling shift for mapping 	 * DEV_BSIZE blocks to drive sectors. 	 */
name|mul
operator|=
name|DEV_BSIZE
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|dk
operator|->
name|dk_bshift
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|mul
operator|>>=
literal|1
operator|)
operator|>
literal|0
condition|)
name|dk
operator|->
name|dk_bshift
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|hddgo
argument_list|(
argument|vm
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vm
decl_stmt|;
end_decl_stmt

begin_block
block|{}
end_block

begin_decl_stmt
specifier|extern
name|int
name|name_ext
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|hdstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|daddr_t
name|sn
decl_stmt|,
name|sz
decl_stmt|,
name|maxsz
decl_stmt|;
name|int
name|part
decl_stmt|,
name|s
decl_stmt|;
name|vi
operator|=
name|hddinfo
index|[
name|unit
operator|=
name|hdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NHD
operator|||
name|vi
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|dk
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
goto|goto
name|q
goto|;
if|if
condition|(
name|dk
operator|->
name|dk_state
operator|!=
name|OPEN
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|part
operator|=
name|hdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dk
operator|->
name|dk_openpart
operator|&
operator|(
literal|1
operator|<<
name|part
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|lp
operator|=
operator|&
name|dk
operator|->
name|dk_label
expr_stmt|;
name|sz
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
name|lp
operator|->
name|d_secsize
operator|-
literal|1
operator|)
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|maxsz
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
expr_stmt|;
name|sn
operator|=
name|bp
operator|->
name|b_blkno
operator|<<
name|dk
operator|->
name|dk_bshift
expr_stmt|;
if|if
condition|(
name|sn
operator|+
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
operator|<=
name|LABELSECTOR
operator|&&
if|#
directive|if
name|LABELSECTOR
operator|!=
literal|0
name|sn
operator|+
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
operator|+
name|sz
operator|>
name|LABELSECTOR
operator|&&
endif|#
directive|endif
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|&&
name|dk
operator|->
name|dk_wlabel
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|sn
operator|<
literal|0
operator|||
name|sn
operator|+
name|sz
operator|>
name|maxsz
condition|)
block|{
if|if
condition|(
name|sn
operator|==
name|maxsz
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sz
operator|=
name|maxsz
operator|-
name|sn
expr_stmt|;
if|if
condition|(
name|sz
operator|<=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bp
operator|->
name|b_bcount
operator|=
name|sz
operator|*
name|lp
operator|->
name|d_secsize
expr_stmt|;
block|}
name|bp
operator|->
name|b_cylin
operator|=
operator|(
name|sn
operator|+
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
operator|)
operator|/
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
name|q
label|:
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
name|dp
operator|=
operator|&
name|dk
operator|->
name|dk_utab
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
operator|->
name|b_active
condition|)
block|{
operator|(
name|void
operator|)
name|hdustart
argument_list|(
name|vi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vi
operator|->
name|ui_mi
operator|->
name|um_tab
operator|.
name|b_active
condition|)
name|hdcstart
argument_list|(
name|vi
operator|->
name|ui_mi
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hdustart
argument_list|(
name|vi
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
name|dp
operator|=
operator|&
name|dk
operator|->
name|dk_utab
expr_stmt|;
comment|/* if queue empty, nothing to do.  impossible? */
if|if
condition|(
name|dp
operator|->
name|b_actf
operator|==
name|NULL
condition|)
return|return;
comment|/* place on controller transfer queue */
name|vm
operator|=
name|vi
operator|->
name|ui_mi
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|vm
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|vm
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
name|dp
operator|->
name|b_active
operator|++
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hdcstart
argument_list|(
name|vm
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|vm
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|master_mcb
modifier|*
name|master
decl_stmt|;
specifier|register
name|struct
name|mcb
modifier|*
name|mcb
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|struct
name|hdcsoftc
modifier|*
name|hdc
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|int
name|sn
decl_stmt|;
comment|/* pull a request off the controller queue */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|dp
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
condition|)
break|break;
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
block|}
comment|/* mark controller active */
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|++
expr_stmt|;
name|vi
operator|=
name|hddinfo
index|[
name|hdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
name|lp
operator|=
operator|&
name|dk
operator|->
name|dk_label
expr_stmt|;
name|sn
operator|=
name|bp
operator|->
name|b_blkno
operator|<<
name|dk
operator|->
name|dk_bshift
expr_stmt|;
comment|/* fill in mcb */
name|mcb
operator|=
operator|&
name|dk
operator|->
name|dk_mcb
expr_stmt|;
name|mcb
operator|->
name|forw_phaddr
operator|=
literal|0
expr_stmt|;
comment|/* mcb->priority = 0; */
name|mcb
operator|->
name|interrupt
operator|=
literal|1
expr_stmt|;
name|mcb
operator|->
name|command
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|HCMD_READ
else|:
name|HCMD_WRITE
expr_stmt|;
name|mcb
operator|->
name|cyl
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
comment|/* assumes partition starts on cylinder boundary */
name|mcb
operator|->
name|head
operator|=
operator|(
name|sn
operator|/
name|lp
operator|->
name|d_nsectors
operator|)
operator|%
name|lp
operator|->
name|d_ntracks
expr_stmt|;
name|mcb
operator|->
name|sector
operator|=
name|sn
operator|%
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|mcb
operator|->
name|drive
operator|=
name|vi
operator|->
name|ui_slave
expr_stmt|;
comment|/* mcb->context = 0;		/* what do we want on interrupt? */
name|hdc
operator|=
operator|&
name|hdcsoftc
index|[
name|vm
operator|->
name|um_ctlr
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|hd_sgsetup
argument_list|(
name|bp
argument_list|,
operator|&
name|hdc
operator|->
name|hdc_rbuf
argument_list|,
name|mcb
operator|->
name|chain
argument_list|)
condition|)
block|{
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|wcount
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|memadr
operator|=
name|vbasetup
argument_list|(
name|bp
argument_list|,
operator|&
name|hdc
operator|->
name|hdc_rbuf
argument_list|,
operator|(
name|int
operator|)
name|lp
operator|->
name|d_secsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vi
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
block|{
name|dk_busy
operator||=
literal|1
operator|<<
name|vi
operator|->
name|ui_dk
expr_stmt|;
name|dk_xfer
index|[
name|vi
operator|->
name|ui_dk
index|]
operator|++
expr_stmt|;
name|dk_wds
index|[
name|vi
operator|->
name|ui_dk
index|]
operator|+=
name|bp
operator|->
name|b_bcount
operator|>>
literal|6
expr_stmt|;
block|}
name|master
operator|=
operator|&
name|hdc
operator|->
name|hdc_mcb
expr_stmt|;
name|master
operator|->
name|mcw
operator|=
name|MCL_QUEUED
expr_stmt|;
name|master
operator|->
name|interrupt
operator|=
name|HDCINTERRUPT
operator|+
name|vm
operator|->
name|um_ctlr
expr_stmt|;
name|master
operator|->
name|forw_phaddr
operator|=
operator|(
name|u_long
operator|)
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
name|NULL
argument_list|,
name|mcb
argument_list|)
expr_stmt|;
name|hdc
operator|->
name|hdc_reg
operator|->
name|master_mcb
operator|=
operator|(
name|u_long
operator|)
name|hdc
operator|->
name|hdc_mcbp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Wait for controller to finish current operation  * so that direct controller accesses can be done.  */
end_comment

begin_macro
name|hdclock
argument_list|(
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
init|=
name|hdcminfo
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|hdcsoftc
modifier|*
name|hdc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|hdc
operator|=
operator|&
name|hdcsoftc
index|[
name|ctlr
index|]
expr_stmt|;
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
while|while
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|||
name|hdc
operator|->
name|hdc_flags
operator|&
name|HDC_LOCKED
condition|)
block|{
name|hdc
operator|->
name|hdc_flags
operator||=
name|HDC_WAIT
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|hdc
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|hdc
operator|->
name|hdc_flags
operator||=
name|HDC_LOCKED
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Continue normal operations after pausing for   * munging the controller directly.  */
end_comment

begin_macro
name|hdcunlock
argument_list|(
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
specifier|register
name|struct
name|hdcsoftc
modifier|*
name|hdc
init|=
operator|&
name|hdcsoftc
index|[
name|ctlr
index|]
decl_stmt|;
name|hdc
operator|->
name|hdc_flags
operator|&=
operator|~
name|HDC_LOCKED
expr_stmt|;
if|if
condition|(
name|hdc
operator|->
name|hdc_flags
operator|&
name|HDC_WAIT
condition|)
block|{
name|hdc
operator|->
name|hdc_flags
operator|&=
operator|~
name|HDC_WAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|hdc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm
operator|=
name|hdcminfo
index|[
name|ctlr
index|]
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
condition|)
name|hdcstart
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|hdintr
argument_list|(
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
specifier|register
name|struct
name|hdcsoftc
modifier|*
name|hdc
decl_stmt|;
specifier|register
name|struct
name|mcb
modifier|*
name|mcb
decl_stmt|;
name|struct
name|master_mcb
modifier|*
name|master
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
name|int
name|timedout
decl_stmt|;
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
name|hdc
operator|=
operator|&
name|hdcsoftc
index|[
name|ctlr
index|]
expr_stmt|;
name|master
operator|=
operator|&
name|hdc
operator|->
name|hdc_mcb
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|master
operator|->
name|mcs
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|master
operator|->
name|context
argument_list|)
expr_stmt|;
name|vm
operator|=
name|hdcminfo
index|[
name|ctlr
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|||
operator|!
operator|(
name|master
operator|->
name|mcs
operator|&
name|MCS_DONE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"hd%d: stray interrupt\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
name|dp
operator|=
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|vi
operator|=
name|hddinfo
index|[
name|hdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
if|if
condition|(
name|vi
operator|->
name|ui_dk
operator|>=
literal|0
condition|)
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|vi
operator|->
name|ui_dk
operator|)
expr_stmt|;
name|timedout
operator|=
operator|(
name|hdc
operator|->
name|hdc_wticks
operator|>=
name|HDCMAXTIME
operator|)
expr_stmt|;
name|mcb
operator|=
operator|&
name|dk
operator|->
name|dk_mcb
expr_stmt|;
if|if
condition|(
name|master
operator|->
name|mcs
operator|&
operator|(
name|MCS_SOFTERROR
operator||
name|MCS_FATALERROR
operator|)
operator|||
name|timedout
condition|)
name|hdcerror
argument_list|(
name|ctlr
argument_list|,
operator|*
operator|(
name|u_long
operator|*
operator|)
name|master
operator|->
name|xstatus
argument_list|)
expr_stmt|;
else|else
name|hdc
operator|->
name|hdc_wticks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_active
condition|)
block|{
name|vm
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|vbadone
argument_list|(
name|bp
argument_list|,
operator|&
name|hdc
operator|->
name|hdc_rbuf
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* start up now, if more work to do */
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
name|hdustart
argument_list|(
name|vi
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dk
operator|->
name|dk_openpart
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dk
argument_list|)
expr_stmt|;
block|}
comment|/* if there are devices ready to transfer, start the controller. */
if|if
condition|(
name|hdc
operator|->
name|hdc_flags
operator|&
name|HDC_WAIT
condition|)
block|{
name|hdc
operator|->
name|hdc_flags
operator|&=
operator|~
name|HDC_WAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|hdc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vm
operator|->
name|um_tab
operator|.
name|b_actf
condition|)
name|hdcstart
argument_list|(
name|vm
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hdioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|,
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unit
operator|=
name|hdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
expr_stmt|;
name|lp
operator|=
operator|&
name|dk
operator|->
name|dk_label
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
operator|=
operator|*
name|lp
expr_stmt|;
break|break;
case|case
name|DIOCGPART
case|:
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|disklab
operator|=
name|lp
expr_stmt|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|part
operator|=
operator|&
name|lp
operator|->
name|d_partitions
index|[
name|hdpart
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|DIOCSDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|error
operator|=
name|setdisklabel
argument_list|(
name|lp
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
argument_list|,
operator|(
name|dk
operator|->
name|dk_state
operator|==
name|OPENRAW
operator|)
condition|?
literal|0
else|:
name|dk
operator|->
name|dk_openpart
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|dk
operator|->
name|dk_state
operator|==
name|OPENRAW
condition|)
name|dk
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
break|break;
case|case
name|DIOCWLABEL
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|dk
operator|->
name|dk_wlabel
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|DIOCWDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|setdisklabel
argument_list|(
name|lp
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
argument_list|,
operator|(
name|dk
operator|->
name|dk_state
operator|==
name|OPENRAW
operator|)
condition|?
literal|0
else|:
name|dk
operator|->
name|dk_openpart
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|wlab
decl_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|dk
operator|->
name|dk_state
operator|==
name|OPENRAW
condition|)
name|dk
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
comment|/* simulate opening partition 0 so write succeeds */
name|dk
operator|->
name|dk_openpart
operator||=
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
comment|/* XXX */
name|wlab
operator|=
name|dk
operator|->
name|dk_wlabel
expr_stmt|;
name|dk
operator|->
name|dk_wlabel
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|writedisklabel
argument_list|(
name|dev
argument_list|,
name|hdstrategy
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|dk
operator|->
name|dk_openpart
operator|=
name|dk
operator|->
name|dk_copenpart
operator||
name|dk
operator|->
name|dk_bopenpart
expr_stmt|;
name|dk
operator|->
name|dk_wlabel
operator|=
name|wlab
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Watch for lost interrupts.  */
end_comment

begin_macro
name|hdcwatch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|hdcsoftc
modifier|*
name|hdc
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
modifier|*
name|vmp
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|timeout
argument_list|(
name|hdcwatch
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
for|for
control|(
name|vmp
operator|=
name|hdcminfo
operator|,
name|hdc
operator|=
name|hdcsoftc
operator|,
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|NHDC
condition|;
operator|++
name|ctlr
operator|,
operator|++
name|vmp
operator|,
operator|++
name|hdc
control|)
block|{
if|if
condition|(
operator|*
name|vmp
operator|==
literal|0
operator|||
operator|(
operator|*
name|vmp
operator|)
operator|->
name|um_alive
operator|==
literal|0
condition|)
continue|continue;
name|s
operator|=
name|spl7
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|vmp
operator|)
operator|->
name|um_tab
operator|.
name|b_active
operator|&&
name|hdc
operator|->
name|hdc_wticks
operator|++
operator|>=
name|HDCMAXTIME
condition|)
block|{
name|printf
argument_list|(
literal|"hd%d: lost interrupt\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
name|hdintr
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|hddump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_block

begin_macro
name|hdsize
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|hdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NHD
operator|||
operator|(
name|vi
operator|=
name|hddinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
operator|||
operator|(
name|dk
operator|=
operator|&
name|dksoftc
index|[
name|unit
index|]
operator|)
operator|->
name|dk_state
operator|!=
name|OPEN
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|lp
operator|=
operator|&
name|dk
operator|->
name|dk_label
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|lp
operator|->
name|d_partitions
index|[
name|hdpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
operator|>>
name|dk
operator|->
name|dk_bshift
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|hdimcb
argument_list|(
name|dk
argument_list|)
specifier|register
expr|struct
name|dksoftc
operator|*
name|dk
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|master_mcb
modifier|*
name|master
decl_stmt|;
specifier|register
name|struct
name|mcb
modifier|*
name|mcb
decl_stmt|;
specifier|register
name|struct
name|hdcsoftc
modifier|*
name|hdc
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* fill in mcb */
name|mcb
operator|=
operator|&
name|dk
operator|->
name|dk_mcb
expr_stmt|;
name|mcb
operator|->
name|interrupt
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|forw_phaddr
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|drive
operator|=
name|dk
operator|->
name|dk_unit
expr_stmt|;
name|hdc
operator|=
operator|&
name|hdcsoftc
index|[
name|dk
operator|->
name|dk_ctlr
index|]
expr_stmt|;
name|master
operator|=
operator|&
name|hdc
operator|->
name|hdc_mcb
expr_stmt|;
comment|/* fill in master mcb */
name|master
operator|->
name|mcw
operator|=
name|MCL_IMMEDIATE
expr_stmt|;
name|master
operator|->
name|forw_phaddr
operator|=
operator|(
name|u_long
operator|)
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
name|NULL
argument_list|,
name|mcb
argument_list|)
expr_stmt|;
name|master
operator|->
name|mcs
operator|=
literal|0
expr_stmt|;
comment|/* kick controller and wait */
name|hdc
operator|->
name|hdc_reg
operator|->
name|master_mcb
operator|=
operator|(
name|u_long
operator|)
name|hdc
operator|->
name|hdc_mcbp
expr_stmt|;
for|for
control|(
name|timeout
operator|=
literal|15000
init|;
name|timeout
condition|;
operator|--
name|timeout
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|PADC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|master
operator|->
name|mcs
operator|&
name|MCS_FATALERROR
condition|)
block|{
name|printf
argument_list|(
literal|"hdc%d: fatal error\n"
argument_list|,
name|dk
operator|->
name|dk_ctlr
argument_list|)
expr_stmt|;
name|hdcerror
argument_list|(
name|dk
operator|->
name|dk_ctlr
argument_list|,
operator|*
operator|(
name|u_long
operator|*
operator|)
name|master
operator|->
name|xstatus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|master
operator|->
name|mcs
operator|&
name|MCS_DONE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"hdc%d: timed out\n"
argument_list|,
name|dk
operator|->
name|dk_ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|hdcerror
argument_list|(
argument|ctlr
argument_list|,
argument|code
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"hd%d: error %lx\n"
argument_list|,
name|ctlr
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_42
end_ifdef

begin_macro
name|hdreadgeometry
argument_list|(
argument|dk
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|dksoftc
modifier|*
name|dk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|geometry_sector
name|geometry
decl_stmt|;
specifier|register
name|struct
name|mcb
modifier|*
name|mcb
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|geometry_block
modifier|*
name|geo
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* 	 * Read the geometry block (at head = 0 sector = 0 of the drive 	 * definition cylinder), validate it (must have the correct version 	 * number, header, and checksum). 	 */
name|mcb
operator|=
operator|&
name|dk
operator|->
name|dk_mcb
expr_stmt|;
name|mcb
operator|->
name|command
operator|=
name|HCMD_READ
expr_stmt|;
name|mcb
operator|->
name|cyl
operator|=
name|dk
operator|->
name|dk_def_cyl
expr_stmt|;
name|mcb
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|sector
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|wcount
operator|=
sizeof|sizeof
argument_list|(
name|geometry_sector
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|memadr
operator|=
operator|(
name|u_long
operator|)
name|vtoph
argument_list|(
operator|(
expr|struct
name|process
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|geometry
argument_list|)
expr_stmt|;
comment|/* mcb->chain[0].memadr = (long)&geometry; */
if|if
condition|(
name|hdimcb
argument_list|(
name|dk
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"hd%d: can't read default geometry.\n"
argument_list|,
name|dk
operator|->
name|dk_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|geo
operator|=
operator|&
name|geometry
operator|.
name|geometry_block
expr_stmt|;
if|if
condition|(
name|geo
operator|->
name|version
operator|>
literal|64000
operator|||
name|geo
operator|->
name|version
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hd%d: bad default geometry version#.\n"
argument_list|,
name|dk
operator|->
name|dk_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|geo
operator|->
name|id
index|[
literal|0
index|]
argument_list|,
name|GB_ID
argument_list|,
name|GB_ID_LEN
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"hd%d: bad default geometry header.\n"
argument_list|,
name|dk
operator|->
name|dk_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|GB_CHECKSUM
argument_list|(
name|geo
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|geometry
operator|.
name|checksum
operator|!=
name|cnt
condition|)
block|{
name|printf
argument_list|(
literal|"hd%d: bad default geometry checksum.\n"
argument_list|,
name|dk
operator|->
name|dk_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lp
operator|=
operator|&
name|dk
operator|->
name|dk_label
expr_stmt|;
comment|/* 1K block in Harris geometry; convert to sectors for disklabels */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|GB_MAXPART
condition|;
name|cnt
operator|++
control|)
block|{
name|lp
operator|->
name|d_partitions
index|[
name|cnt
index|]
operator|.
name|p_offset
operator|=
name|geo
operator|->
name|partition
index|[
name|cnt
index|]
operator|.
name|start
operator|*
operator|(
literal|1024
operator|/
name|lp
operator|->
name|d_secsize
operator|)
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
name|cnt
index|]
operator|.
name|p_size
operator|=
name|geo
operator|->
name|partition
index|[
name|cnt
index|]
operator|.
name|length
operator|*
operator|(
literal|1024
operator|/
name|lp
operator|->
name|d_secsize
operator|)
expr_stmt|;
block|}
name|lp
operator|->
name|d_npartitions
operator|=
name|GB_MAXPART
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_42 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NHD */
end_comment

end_unit

