begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Driver for HCX Disk Controller (HDC)  *  *	@(#)hd.c	7.2 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"../sys/param.h"
end_include

begin_include
include|#
directive|include
file|"../sys/buf.h"
end_include

begin_include
include|#
directive|include
file|"../sys/conf.h"
end_include

begin_include
include|#
directive|include
file|"../sys/dir.h"
end_include

begin_include
include|#
directive|include
file|"../sys/dk.h"
end_include

begin_include
include|#
directive|include
file|"../ml/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../sys/systm.h"
end_include

begin_include
include|#
directive|include
file|"../sys/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"../sys/user.h"
end_include

begin_include
include|#
directive|include
file|"../sys/vmmac.h"
end_include

begin_include
include|#
directive|include
file|"../sys/uio.h"
end_include

begin_include
include|#
directive|include
file|"../sys/elog.h"
end_include

begin_include
include|#
directive|include
file|"../sys/iobuf.h"
end_include

begin_include
include|#
directive|include
file|"../sys/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../sys/reboot.h"
end_include

begin_include
include|#
directive|include
file|"../sys/ioctl.h"
end_include

begin_define
define|#
directive|define
name|DSKGENDATA
end_define

begin_include
include|#
directive|include
file|"../sys/dsk.h"
end_include

begin_undef
undef|#
directive|undef
name|DSKGENDATA
end_undef

begin_include
include|#
directive|include
file|"../sys/dskio.h"
end_include

begin_include
include|#
directive|include
file|"../sys/hdc.h"
end_include

begin_include
include|#
directive|include
file|"../sys/proc.h"
end_include

begin_comment
comment|/*  * External data.  */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|blkacty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for error logging      */
end_comment

begin_decl_stmt
specifier|extern
name|hdc_ctlr_type
name|hdc_ctlrs
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hdc controller info    */
end_comment

begin_decl_stmt
specifier|extern
name|hdc_unit_type
name|hdc_units
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hdc unit info          */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|vba_ctlr
modifier|*
name|hdminfo
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* vba controller info    */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|vba_device
modifier|*
name|vddinfo
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* vba device info        */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|iotime
name|vdstat
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for disk activity info */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|iobuf
name|vdtab
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for disk activity info */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|maxfree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no. of blocks for dump */
end_comment

begin_comment
comment|/*  * Procedure forward references.  */
end_comment

begin_function_decl
name|int
name|hdprobe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|hdslave
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|hdstrategy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|hdattach
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Driver structure.  */
end_comment

begin_decl_stmt
name|struct
name|vba_driver
name|hddriver
init|=
block|{
name|hdprobe
block|,
comment|/* handler probe routine        */
name|hdslave
block|,
comment|/* handler slave routine        */
name|hdattach
block|,
comment|/* handler attach routine       */
literal|0
block|,
comment|/* handler go routine           */
literal|0
block|,
comment|/*                              */
literal|"dsk"
block|,
comment|/* name of the device           */
name|vddinfo
block|,
comment|/* table of unit info           */
literal|"HDC Controller #"
block|,
comment|/* name of the controller       */
name|hdminfo
block|,
comment|/* table of ctlr info           */
name|HDC_MID
block|,
comment|/* controller's module id       */
literal|0
comment|/* no exclusive use of bdp's    */
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HDCLOG
end_ifdef

begin_comment
comment|/************************************************************************* *  Procedure:	hdlog * *  Description: logs mcb's, master mcb's, etc. * *  Returns: **************************************************************************/
end_comment

begin_define
define|#
directive|define
name|ENT_SIZE
value|16
end_define

begin_define
define|#
directive|define
name|ENT_COUNT
value|256
end_define

begin_decl_stmt
specifier|static
name|int
name|hdclog_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hdclog
index|[
name|ENT_SIZE
operator|*
name|ENT_COUNT
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|hdlog
argument_list|(
name|ptr
argument_list|,
name|id
argument_list|)
specifier|register
name|unsigned
name|int
operator|*
name|ptr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|int
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|hdclog
index|[
name|hdclog_index
operator|++
index|]
operator|=
name|id
expr_stmt|;
name|hdclog
index|[
name|hdclog_index
operator|++
index|]
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|hdclog
index|[
name|hdclog_index
operator|++
index|]
operator|=
name|time
operator|.
name|tv_usec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|ENT_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|hdclog
index|[
name|hdclog_index
operator|++
index|]
operator|=
operator|*
name|ptr
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hdclog_index
operator|>=
name|ENT_SIZE
operator|*
name|ENT_COUNT
condition|)
name|hdclog_index
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/************************************************************************* *  Procedure:	hdattach * *  Description: "hdattach" does device-dependent initialization of * 		hdc drives. It is called during the configuration phase *               of a reboot for each disk device on an hdc controller. *               Note that most things get initialized in "hdslave", *               because "slave" initializes what it needs to determine *               whether the drive is ready (which turns out to be a lot). * *  Returns: **************************************************************************/
end_comment

begin_expr_stmt
name|hdattach
argument_list|(
name|vba_unit
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vba_unit
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Pointer to vba drive info 					 */
end_comment

begin_block
block|{
specifier|register
name|hdc_unit_type
modifier|*
name|hu
decl_stmt|;
comment|/* hdc unit info 					 */
specifier|register
name|int
name|unit
decl_stmt|;
comment|/* drive's unit# (0-31) 					 */
name|unit
operator|=
name|vba_unit
operator|->
name|ui_unit
expr_stmt|;
name|hu
operator|=
operator|&
name|hdc_units
index|[
name|unit
index|]
expr_stmt|;
comment|/* 	 * Initialize the hdc unit information structure. 	 * A lot of this is done in "hdslave". 	 */
name|hu
operator|->
name|spc
operator|=
name|hu
operator|->
name|heads
operator|*
name|hu
operator|->
name|sectors
expr_stmt|;
comment|/* 	 * bytes per second: 	 *      (number of sectors per track) * (bytes per sector) * rpm / 60  	 */
name|dk_bps
index|[
name|unit
index|]
operator|=
name|hu
operator|->
name|sectors
operator|*
name|BPS
operator|*
name|hu
operator|->
name|rpm
operator|/
literal|60
expr_stmt|;
block|}
end_block

begin_comment
comment|/************************************************************************* *  Procedure:	hddump * *  Description: Dump system memory to disk. The hdc controller is reset. *               After this call, queued operations on this hdc are no *               longer possible until the next reboot. * *  Returns:     ENXIO    the dump was truncated for some reason. *               EIO      there were controller problems *               0        normal **************************************************************************/
end_comment

begin_function
name|int
name|hddump
parameter_list|(
name|dev
parameter_list|)
name|int
name|dev
decl_stmt|;
comment|/* the major/minor device number. 			 */
block|{
specifier|register
name|hdc_unit_type
modifier|*
name|hu
decl_stmt|;
comment|/* hdc unit info            */
specifier|register
name|hdc_ctlr_type
modifier|*
name|hc
decl_stmt|;
comment|/* hdc controller info      */
specifier|register
name|mcb_type
modifier|*
name|mcb
decl_stmt|;
comment|/* hdc controller info      */
specifier|register
name|int
name|current_block
decl_stmt|;
comment|/* next disk block to write */
specifier|register
name|int
name|block_count
decl_stmt|;
comment|/* #blocks to dump total    */
specifier|register
name|int
name|blocks
decl_stmt|;
comment|/* #blocks to dump at a time*/
specifier|register
name|int
name|mem_addr
decl_stmt|;
comment|/* memory address to dump   */
name|int
name|sector
decl_stmt|;
comment|/* sector to write to       */
name|int
name|par
decl_stmt|;
comment|/* disk partition number    */
name|int
name|parlen
decl_stmt|;
comment|/* disk partition # blocks  */
name|int
name|dump_short
decl_stmt|;
comment|/* TRUE= dump was truncated */
name|int
name|chn
decl_stmt|;
comment|/* temporary data chain no. */
name|int
name|bc
decl_stmt|;
comment|/* temporary byte count     */
name|mem_addr
operator|=
literal|0
expr_stmt|;
name|dump_short
operator|=
name|FALSE
expr_stmt|;
name|par
operator|=
name|HDC_PARTITION
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hu
operator|=
operator|&
name|hdc_units
index|[
name|HDC_UNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|hc
operator|=
operator|&
name|hdc_ctlrs
index|[
name|hu
operator|->
name|ctlr
index|]
expr_stmt|;
name|mcb
operator|=
operator|&
name|hu
operator|->
name|phio_mcb
expr_stmt|;
name|parlen
operator|=
name|hu
operator|->
name|partition
index|[
name|par
index|]
operator|.
name|length
expr_stmt|;
name|printf
argument_list|(
literal|"\nhdc: resetting controller #%d.\n"
argument_list|,
name|hc
operator|->
name|ctlr
argument_list|)
expr_stmt|;
name|HDC_REGISTER
argument_list|(
name|soft_reset_reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|PADC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If the drive has not been initialized yet, abort the dump. 	 * Set dump limits. The dump must fit in the partition. 	 */
if|if
condition|(
name|hu
operator|->
name|sectors
operator|<=
literal|0
operator|||
name|hu
operator|->
name|heads
operator|<=
literal|0
operator|||
name|hu
operator|->
name|cylinders
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nhdc: dump device is not initialized - no dump!\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|block_count
operator|=
name|dumpsize
expr_stmt|;
if|if
condition|(
operator|(
name|dumplo
operator|+
name|block_count
operator|)
operator|>
name|parlen
condition|)
block|{
name|block_count
operator|=
name|parlen
operator|-
name|dumplo
expr_stmt|;
name|dumpsize
operator|=
name|block_count
expr_stmt|;
comment|/* let savecore know */
name|printf
argument_list|(
literal|"\nhdc: only dumping first %dmb of memory!\n"
argument_list|,
name|block_count
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|dump_short
operator|=
name|TRUE
expr_stmt|;
block|}
name|current_block
operator|=
name|hu
operator|->
name|partition
index|[
name|par
index|]
operator|.
name|start
operator|+
name|dumplo
expr_stmt|;
comment|/* 	 * Dump memory to disk. For each disk transfer, fill in the 	 * mcb with information describing the transfer, then send 	 * the mcb to the hdc controller. 	 */
while|while
condition|(
name|block_count
operator|>
literal|0
condition|)
block|{
name|blocks
operator|=
name|MIN
argument_list|(
name|block_count
argument_list|,
name|HDC_DUMPSIZE
argument_list|)
expr_stmt|;
name|sector
operator|=
name|HDC_SPB
operator|*
name|current_block
expr_stmt|;
name|mcb
operator|->
name|command
operator|=
name|HCMD_WRITE
expr_stmt|;
name|mcb
operator|->
name|cyl
operator|=
name|sector
operator|/
name|hu
operator|->
name|spc
expr_stmt|;
name|mcb
operator|->
name|head
operator|=
operator|(
name|sector
operator|/
name|hu
operator|->
name|sectors
operator|)
operator|%
name|hu
operator|->
name|heads
expr_stmt|;
name|mcb
operator|->
name|sector
operator|=
name|sector
operator|%
name|hu
operator|->
name|sectors
expr_stmt|;
name|chn
operator|=
literal|0
expr_stmt|;
name|bc
operator|=
name|blocks
operator|*
name|DEV_BSIZE
expr_stmt|;
while|while
condition|(
name|bc
operator|>
literal|0
condition|)
block|{
name|mcb
operator|->
name|chain
index|[
name|chn
index|]
operator|.
name|ta
operator|=
name|mem_addr
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
name|chn
index|]
operator|.
name|lwc
operator|=
operator|(
name|bc
operator|>
name|HDC_MAXBC
operator|)
condition|?
operator|(
name|LWC_DATA_CHAIN
operator||
operator|(
name|HDC_MAXBC
operator|/
literal|4
operator|)
operator|)
else|:
name|bc
operator|/
literal|4
expr_stmt|;
name|mem_addr
operator|+=
operator|(
operator|(
name|bc
operator|>
name|HDC_MAXBC
operator|)
condition|?
name|HDC_MAXBC
else|:
name|bc
operator|)
expr_stmt|;
name|chn
operator|++
expr_stmt|;
name|bc
operator|-=
name|HDC_MAXBC
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hdimcb
argument_list|(
name|hu
argument_list|,
name|mcb
argument_list|)
condition|)
return|return
name|EIO
return|;
name|block_count
operator|-=
name|blocks
expr_stmt|;
name|current_block
operator|+=
name|blocks
expr_stmt|;
block|}
return|return
operator|(
name|dump_short
condition|?
name|ENXIO
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************* *  Procedure:	hddumpmcb * *  Description: Dumps a single mcb to the console - up to the last *               active data chain lword. * *  Returns: **************************************************************************/
end_comment

begin_expr_stmt
name|hddumpmcb
argument_list|(
name|mcb
argument_list|)
specifier|register
name|mcb_type
operator|*
name|mcb
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* the mcb pointer 			 */
end_comment

begin_block
block|{
name|unsigned
name|int
modifier|*
name|ptr
decl_stmt|,
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"mcb: "
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|mcb
operator|->
name|forw_phaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|6
init|;
name|i
operator|<
literal|72
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|printf
argument_list|(
literal|"  %x %x"
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|,
name|ptr
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ptr
index|[
name|i
index|]
operator|&
literal|0x80000000
operator|)
condition|)
break|break;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/************************************************************************* *  Procedure:	hddumpmmcb * *  Description: dumps the master mcb on the console up to the *               last non-zero byte of the extended status. * *  Returns: **************************************************************************/
end_comment

begin_expr_stmt
name|hddumpmmcb
argument_list|(
name|master
argument_list|)
specifier|register
name|master_mcb_type
operator|*
name|master
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* the master mcb pointer 				   */
end_comment

begin_block
block|{
name|unsigned
name|int
modifier|*
name|ptr
decl_stmt|,
name|i
decl_stmt|,
name|end
decl_stmt|;
name|printf
argument_list|(
literal|"mmcb:  "
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|master
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
operator|+
name|HDC_XSTAT_SIZE
init|;
name|i
operator|>
literal|7
condition|;
name|i
operator|--
control|)
block|{
name|end
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/************************************************************************* *  Procedure:	hdimcb * *  Description: "hdc immediate mcb" sends an mcb to the hdc and returns *               when the hdc has completed the operation (polled io). *               "hdimcb" is called during system configuration or *               when the system is being dumped after a fatal error. * *  Entry:       o  There is no active process. * *               o  "hdimcb" cannot be called from interrupt level. * *               o  There can be no queued operations pending; i.e. *                  this routine assumes exclusive use of the hdc. *                  Note: a soft reset will terminate queued operations. * *  Returns:     Returns FALSE if a controller error occurred. **************************************************************************/
end_comment

begin_function
name|int
name|hdimcb
parameter_list|(
name|hu
parameter_list|,
name|mcb
parameter_list|)
specifier|register
name|hdc_unit_type
modifier|*
name|hu
decl_stmt|;
comment|/* unit information 					 */
specifier|register
name|mcb_type
modifier|*
name|mcb
decl_stmt|;
comment|/* mcb to send to the hdc 					 */
block|{
specifier|register
name|hdc_ctlr_type
modifier|*
name|hc
decl_stmt|;
comment|/* controller information   */
specifier|register
name|master_mcb_type
modifier|*
name|master
decl_stmt|;
comment|/* the hdc's master mcb     */
specifier|register
name|int
name|timeout
decl_stmt|;
comment|/* used to timeout the mcb  */
specifier|register
name|int
name|ctlr
decl_stmt|;
comment|/* controller number        */
name|int
name|i
decl_stmt|,
name|ok
decl_stmt|;
name|unsigned
name|int
modifier|*
name|ptr
decl_stmt|;
name|ok
operator|=
name|TRUE
expr_stmt|;
name|ctlr
operator|=
name|hu
operator|->
name|ctlr
expr_stmt|;
name|hc
operator|=
operator|&
name|hdc_ctlrs
index|[
name|ctlr
index|]
expr_stmt|;
name|master
operator|=
operator|&
name|hc
operator|->
name|master_mcb
expr_stmt|;
comment|/* 	 * Complete the setup of the mcb and master mcb. 	 */
name|mcb
operator|->
name|priority
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|interrupt
operator|=
name|FALSE
expr_stmt|;
name|mcb
operator|->
name|drive
operator|=
name|hu
operator|->
name|slave
expr_stmt|;
name|mcb
operator|->
name|forw_phaddr
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|context
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|reserved
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|reserved
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|master
operator|->
name|forw_phaddr
operator|=
operator|(
name|long
operator|)
name|vtoph
argument_list|(
literal|0
argument_list|,
operator|&
name|mcb
operator|->
name|forw_phaddr
argument_list|)
expr_stmt|;
name|master
operator|->
name|mcs
operator|=
literal|0
expr_stmt|;
name|master
operator|->
name|reserve1
operator|=
literal|0
expr_stmt|;
name|master
operator|->
name|reserve2
operator|=
literal|0
expr_stmt|;
name|master
operator|->
name|context
operator|=
literal|0
expr_stmt|;
name|master
operator|->
name|cmcb_phaddr
operator|=
literal|0
expr_stmt|;
name|master
operator|->
name|mcl
operator|=
name|MCL_IMMEDIATE
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|master
operator|->
name|xstatus
index|[
literal|0
index|]
argument_list|,
name|HDC_XSTAT_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Tell hdc to xqt the mcb; wait for completion. 	 * If a controller error or timeout occurs, print 	 * out the mcb and master mcb on the console. 	 */
name|HDC_REGISTER
argument_list|(
name|master_mcb_reg
argument_list|)
operator|=
name|hc
operator|->
name|master_phaddr
expr_stmt|;
name|timeout
operator|=
literal|15000
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|PADC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|master
operator|->
name|mcs
operator|&
name|MCS_DONE
operator|)
operator|&&
operator|!
operator|(
name|master
operator|->
name|mcs
operator|&
name|MCS_FATALERROR
operator|)
condition|)
break|break;
name|timeout
operator|--
expr_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
operator|&&
operator|!
operator|(
name|master
operator|->
name|mcs
operator|&
name|MCS_FATALERROR
operator|)
condition|)
continue|continue;
if|if
condition|(
name|master
operator|->
name|mcs
operator|&
name|MCS_FATALERROR
condition|)
name|printf
argument_list|(
literal|"hdc: controller %d fatal error\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"hdc: controller %d timed out\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
name|hddumpmcb
argument_list|(
name|mcb
argument_list|)
expr_stmt|;
name|hddumpmmcb
argument_list|(
name|master
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|master
operator|->
name|mcl
operator|=
name|MCL_QUEUED
expr_stmt|;
return|return
operator|(
name|ok
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************* *  Procedure:	hdintr * *  Description: The hdc interrupt routine. * *  Returns: **************************************************************************/
end_comment

begin_macro
name|hdintr
argument_list|(
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the hdc controller number. 			 */
end_comment

begin_block
block|{
specifier|register
name|master_mcb_type
modifier|*
name|master
decl_stmt|;
comment|/* master mcb for this hdc  */
specifier|register
name|mcb_type
modifier|*
name|mcb
decl_stmt|;
comment|/* the mcb just completed   */
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buf for the completed mcb*/
specifier|register
name|hdc_ctlr_type
modifier|*
name|hc
decl_stmt|;
comment|/* info for this controller */
specifier|register
name|struct
name|iobuf
modifier|*
name|iobp
decl_stmt|;
comment|/* iobuf for this unit      */
specifier|register
name|int
name|unit
decl_stmt|;
comment|/* unit# of the hdc drive   */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* temporary                */
name|hc
operator|=
operator|&
name|hdc_ctlrs
index|[
name|ctlr
index|]
expr_stmt|;
name|master
operator|=
operator|&
name|hc
operator|->
name|master_mcb
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|master
operator|->
name|mcs
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|master
operator|->
name|context
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HDCLOG
name|hdlog
argument_list|(
name|master
argument_list|,
literal|1
operator|+
literal|16
operator|*
name|hc
operator|->
name|ctlr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|master
operator|->
name|mcs
operator|&
name|MCS_DONE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nhdc: spurious interrupt from controller #%d\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
name|mcb
operator|=
operator|(
name|mcb_type
operator|*
operator|)
name|master
operator|->
name|context
expr_stmt|;
name|bp
operator|=
name|mcb
operator|->
name|buf_ptr
expr_stmt|;
name|unit
operator|=
name|HDC_UNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|iobp
operator|=
operator|&
name|vdtab
index|[
name|unit
index|]
expr_stmt|;
comment|/* 	 * Error log and system activity. 	 * 	 * Turn off the activity bit for this device. 	 * Record the time required to process the buf. 	 * If there is no more activity on this unit, record the 	 * amount of time that the unit was active. 	 * Update dkprf and lastcyl for "sadp". 	 */
name|blkacty
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|major
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|iobp
operator|->
name|b_active
condition|)
block|{
name|vdstat
index|[
name|unit
index|]
operator|.
name|io_resp
operator|+=
operator|(
name|time
operator|.
name|tv_sec
operator|-
name|bp
operator|->
name|b_start
operator|)
expr_stmt|;
if|if
condition|(
operator|--
name|iobp
operator|->
name|b_active
operator|==
literal|0
condition|)
name|vdstat
index|[
name|unit
index|]
operator|.
name|io_act
operator|+=
operator|(
name|time
operator|.
name|tv_sec
operator|-
name|iobp
operator|->
name|io_start
operator|)
expr_stmt|;
block|}
name|i
operator|=
name|mcb
operator|->
name|cyl
expr_stmt|;
name|dkprf
index|[
name|unit
index|]
index|[
name|i
operator|>>
literal|3
index|]
operator|++
expr_stmt|;
name|i
operator|-=
name|lastcyl
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
operator|-
name|i
expr_stmt|;
name|skprf
index|[
name|unit
index|]
index|[
name|i
operator|>>
literal|3
index|]
operator|++
expr_stmt|;
name|lastcyl
index|[
name|unit
index|]
operator|=
name|mcb
operator|->
name|cyl
expr_stmt|;
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|unit
operator|)
expr_stmt|;
name|dk_seek
index|[
name|unit
index|]
operator|++
expr_stmt|;
name|dk_xfer
index|[
name|unit
index|]
operator|++
expr_stmt|;
comment|/* 	 * If there are no free mcb's, wake up anyone that might 	 * be waiting for one.  Remove the completed mcb from the 	 * queue of active mcb's and add it to the free-mcb queue. 	 */
if|if
condition|(
name|hc
operator|->
name|forw_free
operator|==
operator|(
name|mcb_type
operator|*
operator|)
operator|&
name|hc
operator|->
name|forw_free
condition|)
name|wakeup
argument_list|(
name|hc
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|mcb
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|mcb
argument_list|,
operator|&
name|hc
operator|->
name|forw_free
argument_list|)
expr_stmt|;
comment|/* 	 * If there was a fatal error, dump the mcb and master mcb on the 	 * console, then halt if the system was booted with the debug option. 	 * 	 * Record fatal and soft errors in the error log. 	 */
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|master
operator|->
name|mcs
operator|&
operator|(
name|MCS_SOFTERROR
operator||
name|MCS_FATALERROR
operator|)
condition|)
block|{
name|mtpr
argument_list|(
name|P1DC
argument_list|,
operator|(
name|caddr_t
operator|)
name|master
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|P1DC
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|master
operator|->
name|xstatus
index|[
name|HDC_XSTAT_SIZE
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|master
operator|->
name|mcs
operator|&
name|MCS_FATALERROR
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|harderr
argument_list|(
name|bp
argument_list|,
literal|"hdc"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nhdc:  fatal error on controller #%d\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
name|hddumpmmcb
argument_list|(
name|master
argument_list|)
expr_stmt|;
name|hddumpmcb
argument_list|(
name|mcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|boothowto
operator|&
name|RB_DEBUG
condition|)
asm|asm("halt");
block|}
empty_stmt|;
name|vdstat
index|[
name|unit
index|]
operator|.
name|ios
operator|.
name|io_misc
operator|++
expr_stmt|;
name|iobp
operator|->
name|io_erec
operator|=
literal|0
expr_stmt|;
name|iobp
operator|->
name|io_addr
operator|=
operator|(
name|caddr_t
operator|)
name|hc
operator|->
name|registers
expr_stmt|;
name|iobp
operator|->
name|io_stp
operator|=
operator|&
name|vdstat
index|[
name|unit
index|]
operator|.
name|ios
expr_stmt|;
name|iobp
operator|->
name|io_nreg
operator|=
name|HDC_XSTAT_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|HDC_XSTAT_SIZE
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|master
operator|->
name|xstatus
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
name|iobp
operator|->
name|io_nreg
operator|--
expr_stmt|;
block|}
name|iobp
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
name|iobp
operator|->
name|b_dev
operator|=
name|bp
operator|->
name|b_dev
expr_stmt|;
name|fmtberr
argument_list|(
name|iobp
argument_list|,
name|mcb
operator|->
name|cyl
argument_list|,
operator|&
name|master
operator|->
name|xstatus
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|logberr
argument_list|(
name|iobp
argument_list|,
name|master
operator|->
name|mcs
operator|&
name|MCS_FATALERROR
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|master
operator|->
name|xstatus
index|[
literal|0
index|]
argument_list|,
name|HDC_XSTAT_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there are any waiting mcb's, move them to the active queue. 	 * Physically link the new mcb's from the master mcb. 	 */
name|master
operator|->
name|forw_phaddr
operator|=
literal|0
expr_stmt|;
name|next
label|:
name|mcb
operator|=
name|hc
operator|->
name|forw_wait
expr_stmt|;
name|remque
argument_list|(
name|mcb
argument_list|)
expr_stmt|;
asm|asm(" bvs done");
name|insque
argument_list|(
name|mcb
argument_list|,
operator|&
name|hc
operator|->
name|forw_active
argument_list|)
expr_stmt|;
name|mcb
operator|->
name|forw_phaddr
operator|=
name|master
operator|->
name|forw_phaddr
expr_stmt|;
ifdef|#
directive|ifdef
name|HDCLOG
name|hdlog
argument_list|(
name|mcb
argument_list|,
literal|2
operator|+
literal|16
operator|*
name|hc
operator|->
name|ctlr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|master
operator|->
name|forw_phaddr
operator|=
name|mcb
operator|->
name|mcb_phaddr
expr_stmt|;
goto|goto
name|next
goto|;
name|done
label|:
asm|asm("done:");
comment|/* 	 * If there are any mcb's active, initialize the master mcb 	 * and tell the hdc to continue queued operation. 	 * New mcb's (if any) are linked off of "forw_phaddr". 	 */
if|if
condition|(
name|hc
operator|->
name|forw_active
operator|!=
operator|(
name|mcb_type
operator|*
operator|)
operator|&
name|hc
operator|->
name|forw_active
condition|)
block|{
name|master
operator|->
name|mcs
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HDCLOG
name|hdlog
argument_list|(
name|master
argument_list|,
literal|3
operator|+
literal|16
operator|*
name|hc
operator|->
name|ctlr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|HDC_REGISTER
argument_list|(
name|master_mcb_reg
argument_list|)
operator|=
name|hc
operator|->
name|master_phaddr
expr_stmt|;
block|}
comment|/* 	 * Return the buf for the completed operation. 	 */
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/************************************************************************* *  Procedure:	hdioctl * *  Description: Character device ioctl routine. * *  Returns:     EACCES    formatting is active on the drive *                         (or) function is valid only for the format program *                         (or) formatting ioctl's must be done on partition 7 *               EIO       controller error occurred *               ENXIO     invalid parameter value *               0         normal **************************************************************************/
end_comment

begin_function
name|int
name|hdioctl
parameter_list|(
name|dev
parameter_list|,
name|command
parameter_list|,
name|arg
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
comment|/* Device type. Major/minor dev#. 				 */
name|int
name|command
decl_stmt|;
comment|/* The ioctl commmand. 				 */
name|int
modifier|*
name|arg
decl_stmt|;
comment|/* Data. Format depends on ioctl. 				 */
name|int
name|flag
decl_stmt|;
comment|/* Not used. 				 */
block|{
specifier|register
name|hdc_unit_type
modifier|*
name|hu
decl_stmt|;
comment|/* unit information        */
name|int
name|formatok
decl_stmt|;
comment|/* TRUE= it's ok to format */
specifier|register
name|int
name|i
decl_stmt|;
name|hu
operator|=
operator|&
name|hdc_units
index|[
name|HDC_UNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|formatok
operator|=
operator|(
name|HDC_PARTITION
argument_list|(
name|dev
argument_list|)
operator|==
literal|7
operator|&&
name|hu
operator|->
name|format
operator|)
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|DSKIOCFORMAT
case|:
block|{
comment|/* 		 * Format a disk track. The received argument is a pointer 		 * to a "formatop" structure describing the track to format. 		 * 		 * Set up a buffer with each longword corresponding to a 		 * sector on the track; a 1 means no flaw, a 0 means a flaw. 		 * Call hdphysio to send the data from the phio_data buffer 		 * to the hdc to format the track. 		 */
specifier|register
name|struct
name|formatop
modifier|*
name|track
decl_stmt|;
if|if
condition|(
operator|!
name|formatok
condition|)
return|return
name|EACCES
return|;
name|track
operator|=
operator|(
expr|struct
name|formatop
operator|*
operator|)
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hu
operator|->
name|phys_sectors
condition|;
name|i
operator|++
control|)
name|hu
operator|->
name|phio_data
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|track
operator|->
name|flaw_count
condition|;
name|i
operator|++
control|)
name|hu
operator|->
name|phio_data
index|[
name|track
operator|->
name|flaw
index|[
name|i
index|]
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hdphysio
argument_list|(
name|dev
argument_list|,
name|HCMD_FORMAT
argument_list|,
name|track
operator|->
name|cylinder
argument_list|,
name|track
operator|->
name|head
argument_list|,
literal|0
argument_list|,
name|hu
operator|->
name|phio_data
argument_list|,
name|hu
operator|->
name|phys_sectors
operator|*
literal|4
argument_list|)
condition|)
return|return
name|EIO
return|;
break|break;
block|}
case|case
name|DSKIOCCERTIFY
case|:
block|{
comment|/* 		 * Certify a disk track. The received argument is a pointer 		 * to a "formatop" structure describing the track to certify. 		 * 		 * Call hdphysio to read data into the phio_data buffer. 		 * The controller returns data in which each longword 		 * corresponds to a sector on the track; a 1 means no flaw, 		 * a 0 means a flaw. 		 */
specifier|register
name|struct
name|formatop
modifier|*
name|track
decl_stmt|;
if|if
condition|(
operator|!
name|formatok
condition|)
return|return
name|EACCES
return|;
name|track
operator|=
operator|(
expr|struct
name|formatop
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|hdphysio
argument_list|(
name|dev
argument_list|,
name|HCMD_CERTIFY
argument_list|,
name|track
operator|->
name|cylinder
argument_list|,
name|track
operator|->
name|head
argument_list|,
literal|0
argument_list|,
name|hu
operator|->
name|phio_data
argument_list|,
name|hu
operator|->
name|phys_sectors
operator|*
literal|4
argument_list|)
condition|)
return|return
name|EIO
return|;
name|track
operator|->
name|flaw_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hu
operator|->
name|phys_sectors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|track
operator|->
name|flaw_count
operator|>=
name|MAXVFLAW
condition|)
break|break;
if|if
condition|(
name|hu
operator|->
name|phio_data
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|track
operator|->
name|flaw
index|[
name|track
operator|->
name|flaw_count
index|]
operator|=
name|i
expr_stmt|;
name|track
operator|->
name|flaw_count
operator|++
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|DSKIOCVERIFY
case|:
block|{
comment|/* 		 * Verify a disk track. The received argument is a pointer 		 * to a "formatop" structure describing the track to verify. 		 */
specifier|register
name|struct
name|formatop
modifier|*
name|track
decl_stmt|;
if|if
condition|(
operator|!
name|formatok
condition|)
return|return
name|EACCES
return|;
name|track
operator|=
operator|(
expr|struct
name|formatop
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|hdphysio
argument_list|(
name|dev
argument_list|,
name|HCMD_VERIFY
argument_list|,
name|track
operator|->
name|cylinder
argument_list|,
name|track
operator|->
name|head
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|EIO
return|;
break|break;
block|}
case|case
name|DSKIOCFORMATCTL
case|:
block|{
comment|/* 		 * This ioctl provides special format control. 		 * 		 * Currently the valid arguments are: 		 * arg= 0  disable formatting; 		 * arg= 1  enable formatting (allow privileged access); 		 * 		 * Partition must be the disk definition tracks of 		 * the raw device. 		 */
if|if
condition|(
name|HDC_PARTITION
argument_list|(
name|dev
argument_list|)
operator|!=
name|HDC_DEFPART
condition|)
return|return
name|EACCES
return|;
switch|switch
condition|(
operator|*
name|arg
condition|)
block|{
case|case
literal|0
case|:
name|hu
operator|->
name|format
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|hu
operator|->
name|format
condition|)
return|return
name|EACCES
return|;
name|hu
operator|->
name|format
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
return|return
name|ENXIO
return|;
block|}
break|break;
block|}
case|case
name|DSKIOCGEOMETRY
case|:
block|{
comment|/* 		 * Return info about disk geometry (partitions). 		 * Caller's parameter is a pointer to a geometry 		 * status structure. 		 */
specifier|register
name|geometry_status
modifier|*
name|geo_status
decl_stmt|;
name|geo_status
operator|=
operator|(
name|geometry_status
operator|*
operator|)
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GB_MAXPART
condition|;
name|i
operator|++
control|)
block|{
name|geo_status
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|start
operator|=
name|hu
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|start
expr_stmt|;
name|geo_status
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|length
operator|=
name|hu
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DSKIOCSETGEOMETRY
case|:
block|{
comment|/* 		 * Set new geometry - new partition sizes. 		 * Caller must have formatting privilege. 		 * Caller's parameter is a pointer to a geometry 		 * status structure containing the new geometries. 		 * The disk definition partition cannot be changed. 		 */
specifier|register
name|geometry_status
modifier|*
name|geo_status
decl_stmt|;
if|if
condition|(
operator|!
name|formatok
condition|)
return|return
name|EACCES
return|;
name|geo_status
operator|=
operator|(
name|geometry_status
operator|*
operator|)
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GB_MAXPART
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|HDC_DEFPART
condition|)
continue|continue;
name|hu
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|start
operator|=
name|geo_status
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|start
expr_stmt|;
name|hu
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|length
operator|=
name|geo_status
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DSKIOCSTATUS
case|:
block|{
comment|/* 		 * Return info about the disk. Caller's parameter is a 		 * pointer to a dsk_status structure. 		 */
specifier|register
name|dsk_status
modifier|*
name|status
decl_stmt|;
name|status
operator|=
operator|(
name|dsk_status
operator|*
operator|)
name|arg
expr_stmt|;
name|status
operator|->
name|id
operator|=
name|hu
operator|->
name|id
expr_stmt|;
name|status
operator|->
name|rpm
operator|=
name|hu
operator|->
name|rpm
expr_stmt|;
name|status
operator|->
name|bytes_per_sec
operator|=
name|hu
operator|->
name|bytes_per_sec
expr_stmt|;
name|status
operator|->
name|cylinders
operator|=
name|hu
operator|->
name|cylinders
expr_stmt|;
name|status
operator|->
name|heads
operator|=
name|hu
operator|->
name|heads
expr_stmt|;
name|status
operator|->
name|sectors
operator|=
name|hu
operator|->
name|sectors
expr_stmt|;
name|status
operator|->
name|phys_cylinders
operator|=
name|hu
operator|->
name|phys_cylinders
expr_stmt|;
name|status
operator|->
name|phys_heads
operator|=
name|hu
operator|->
name|phys_heads
expr_stmt|;
name|status
operator|->
name|phys_sectors
operator|=
name|hu
operator|->
name|phys_sectors
expr_stmt|;
name|status
operator|->
name|diag_cyl
operator|=
name|hu
operator|->
name|diag_cyl
expr_stmt|;
name|status
operator|->
name|diag_cylinders
operator|=
name|hu
operator|->
name|diag_cyl_count
expr_stmt|;
name|status
operator|->
name|def_cyl
operator|=
name|hu
operator|->
name|def_cyl
expr_stmt|;
name|status
operator|->
name|def_cylinders
operator|=
name|hu
operator|->
name|def_cyl_count
expr_stmt|;
break|break;
block|}
case|case
name|DSKIOCVENDORFLAW
case|:
block|{
comment|/* 		 * Return vendor flaw info. 		 * 		 * Read in the vendor data from relative sector 0 of 		 * the track to the phio_data buffer; then copy the 		 * vendor flaw data to the caller's buffer. 		 */
specifier|register
name|vflaw_type
modifier|*
name|vflaw
decl_stmt|;
specifier|register
name|struct
name|flaw
modifier|*
name|vendor
decl_stmt|;
if|if
condition|(
operator|!
name|formatok
condition|)
return|return
name|EACCES
return|;
name|vflaw
operator|=
operator|(
name|vflaw_type
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|hdphysio
argument_list|(
name|dev
argument_list|,
name|HCMD_VENDOR
argument_list|,
name|vflaw
operator|->
name|cylinder
argument_list|,
name|vflaw
operator|->
name|head
argument_list|,
literal|0
argument_list|,
name|hu
operator|->
name|phio_buf
argument_list|,
name|HDC_VDATA_SIZE
operator|<<
literal|2
argument_list|)
condition|)
return|return
name|EIO
return|;
name|vendor
operator|=
operator|(
expr|struct
name|flaw
operator|*
operator|)
operator|&
name|hu
operator|->
name|phio_data
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXVFLAW
condition|;
name|i
operator|++
control|)
block|{
name|vflaw
operator|->
name|flaw
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|vendor
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
name|vflaw
operator|->
name|flaw
index|[
name|i
index|]
operator|.
name|length
operator|=
name|vendor
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
break|break;
block|}
default|default:
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/************************************************************************* *  Procedure:	hdopen * *  Description: The character device and block device open routine. * *  Returns:     ENXIO     the partition or device isn't defined *               EACCES    Formatting is active on this drive *               0         normal **************************************************************************/
end_comment

begin_function
name|int
name|hdopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
comment|/* Device type. Major/minor dev#. 				 */
name|int
name|flag
decl_stmt|;
comment|/* Not used. 				 */
block|{
specifier|register
name|int
name|unit
decl_stmt|;
comment|/* hdc unit#  (0-31)*/
specifier|register
name|int
name|par
decl_stmt|;
comment|/* partition# (0-7) */
specifier|register
name|struct
name|vba_device
modifier|*
name|vba_unit
decl_stmt|;
comment|/* vba unit info    */
specifier|register
name|hdc_unit_type
modifier|*
name|hu
decl_stmt|;
comment|/* hdc unit info    */
name|unit
operator|=
name|HDC_UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|par
operator|=
name|HDC_PARTITION
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vba_unit
operator|=
name|vddinfo
index|[
name|unit
index|]
expr_stmt|;
name|hu
operator|=
operator|&
name|hdc_units
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|vba_unit
operator|->
name|ui_alive
operator|||
name|hu
operator|->
name|partition
index|[
name|par
index|]
operator|.
name|length
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|hu
operator|->
name|format
condition|)
return|return
name|EACCES
return|;
name|vdtab
index|[
name|unit
index|]
operator|.
name|io_stp
operator|=
operator|&
name|vdstat
index|[
name|unit
index|]
operator|.
name|ios
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/************************************************************************* *  Procedure:	hdphysio * *  Description: "hdphysio" does the physical i/o initiated by this *               handler. It does the things which "physio" does for *               raw read/writes; i.e. it provides an interface to the *               hdstrategy routine. * *               hdphysio assumes that it has exclusive access to the *               drive; it uses the drive's phio buf. * *  Returns:     FALSE     an i/o error occurred. *               0         normal; data is in phio_data if read was done **************************************************************************/
end_comment

begin_function
name|int
name|hdphysio
parameter_list|(
name|dev
parameter_list|,
name|command
parameter_list|,
name|cylinder
parameter_list|,
name|head
parameter_list|,
name|sector
parameter_list|,
name|ta
parameter_list|,
name|bc
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
comment|/*  major/minor device number 				 */
name|int
name|command
decl_stmt|;
comment|/*  the hdc command to execute 				 */
name|int
name|cylinder
decl_stmt|;
comment|/*  disk cylinder address 				 */
name|int
name|head
decl_stmt|;
comment|/*  disk head address 				 */
name|int
name|sector
decl_stmt|;
comment|/*  disk sector address 				 */
name|int
name|ta
decl_stmt|;
comment|/*  memory transfer address 				 */
name|int
name|bc
decl_stmt|;
comment|/*  byte count 				 */
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* buf structure built here */
name|hdc_unit_type
modifier|*
name|hu
decl_stmt|;
comment|/* hdc device unit info     */
name|int
name|s
decl_stmt|;
comment|/* processor level save     */
name|hu
operator|=
operator|&
name|hdc_units
index|[
name|HDC_UNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
operator|&
name|hu
operator|->
name|phio_buf
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_proc
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
operator|(
name|caddr_t
operator|)
name|ta
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_PHYS
operator||
name|B_READ
operator||
name|B_LOCALIO
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_hdccommand
operator|=
name|command
expr_stmt|;
name|bp
operator|->
name|b_cyl
operator|=
name|cylinder
expr_stmt|;
name|bp
operator|->
name|b_head
operator|=
name|head
expr_stmt|;
name|bp
operator|->
name|b_sector
operator|=
name|sector
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|bc
expr_stmt|;
name|hdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
name|slumber
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
literal|0
argument_list|,
name|iocomboost
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_BUSY
operator||
name|B_PHYS
operator||
name|B_WANTED
operator||
name|B_LOCALIO
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_error
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/************************************************************************* *  Procedure:	hdprobe * *  Description: "hdprobe" verifies that an hdc controller is really *               there and then initializes the controller. It is called *		during the configuration phase of a reboot for each *		hdc controller in the configuration. * *  Returns:	TRUE means the controller is ready. **************************************************************************/
end_comment

begin_function
name|int
name|hdprobe
parameter_list|(
name|vba_ctlr
parameter_list|)
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|vba_ctlr
decl_stmt|;
comment|/* vba controller information 						 */
block|{
specifier|register
name|hdc_ctlr_type
modifier|*
name|hc
decl_stmt|;
comment|/* hdc controller info      */
specifier|register
name|hdc_mid_type
modifier|*
name|id
decl_stmt|;
comment|/* returned module id word  */
specifier|register
name|int
name|ctlr
decl_stmt|;
comment|/* the controller number    */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* temporary                */
name|mcb_type
modifier|*
name|mcb
decl_stmt|;
comment|/* temporary mcb pointer    */
specifier|extern
name|int
name|Xhdintr0
decl_stmt|,
name|Xhdintr1
decl_stmt|,
name|Xhdintr2
decl_stmt|,
name|Xhdintr3
decl_stmt|,
name|Xhdintr4
decl_stmt|,
name|Xhdintr5
decl_stmt|,
name|Xhdintr6
decl_stmt|,
name|Xhdintr7
decl_stmt|;
specifier|static
name|int
name|hd_proc
index|[]
init|=
block|{
operator|(
name|int
operator|)
operator|&
name|Xhdintr0
block|,
operator|(
name|int
operator|)
operator|&
name|Xhdintr1
block|,
operator|(
name|int
operator|)
operator|&
name|Xhdintr2
block|,
operator|(
name|int
operator|)
operator|&
name|Xhdintr3
block|,
operator|(
name|int
operator|)
operator|&
name|Xhdintr4
block|,
operator|(
name|int
operator|)
operator|&
name|Xhdintr5
block|,
operator|(
name|int
operator|)
operator|&
name|Xhdintr6
block|,
operator|(
name|int
operator|)
operator|&
name|Xhdintr7
block|}
decl_stmt|;
name|ctlr
operator|=
name|vba_ctlr
operator|->
name|um_ctlr
expr_stmt|;
name|hc
operator|=
operator|&
name|hdc_ctlrs
index|[
name|ctlr
index|]
expr_stmt|;
comment|/* 	 * Initialize the hdc controller structure. 	 * Initially all mcb's are in the free-mcb list. 	 * The interrupt acknowledge word is the vector offset 	 * for this controller's interrupts. 	 */
name|hc
operator|->
name|ctlr
operator|=
name|ctlr
expr_stmt|;
name|hc
operator|->
name|registers
operator|=
operator|(
name|hdc_regs_type
operator|*
operator|)
name|vba_ctlr
operator|->
name|um_addr
expr_stmt|;
name|id
operator|=
operator|&
name|hc
operator|->
name|mid
expr_stmt|;
if|if
condition|(
name|badaddr
argument_list|(
operator|&
name|hc
operator|->
name|registers
operator|->
name|module_id_reg
argument_list|,
literal|4
argument_list|,
name|vtoph
argument_list|(
literal|0
argument_list|,
name|id
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|hc
operator|->
name|forw_active
operator|=
operator|(
name|mcb_type
operator|*
operator|)
operator|&
name|hc
operator|->
name|forw_active
expr_stmt|;
name|hc
operator|->
name|back_active
operator|=
operator|(
name|mcb_type
operator|*
operator|)
operator|&
name|hc
operator|->
name|forw_active
expr_stmt|;
name|hc
operator|->
name|forw_wait
operator|=
operator|(
name|mcb_type
operator|*
operator|)
operator|&
name|hc
operator|->
name|forw_wait
expr_stmt|;
name|hc
operator|->
name|back_wait
operator|=
operator|(
name|mcb_type
operator|*
operator|)
operator|&
name|hc
operator|->
name|forw_wait
expr_stmt|;
name|hc
operator|->
name|forw_free
operator|=
operator|(
name|mcb_type
operator|*
operator|)
operator|&
name|hc
operator|->
name|forw_free
expr_stmt|;
name|hc
operator|->
name|back_free
operator|=
operator|(
name|mcb_type
operator|*
operator|)
operator|&
name|hc
operator|->
name|forw_free
expr_stmt|;
for|for
control|(
name|i
operator|=
name|HDC_MAXMCBS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mcb
operator|=
operator|&
name|hc
operator|->
name|mcbs
index|[
name|i
index|]
expr_stmt|;
name|mcb
operator|->
name|mcb_phaddr
operator|=
name|vtoph
argument_list|(
literal|0
argument_list|,
operator|&
name|mcb
operator|->
name|forw_phaddr
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|mcb
argument_list|,
operator|&
name|hc
operator|->
name|forw_free
argument_list|)
expr_stmt|;
block|}
name|vba_ctlr
operator|->
name|um_ivct
operator|=
name|get_ivct
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vba_ctlr
operator|->
name|um_ivct
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
return|return
name|FALSE
return|;
name|init_ivct
argument_list|(
name|vba_ctlr
operator|->
name|um_ivct
argument_list|,
name|hd_proc
index|[
name|vba_ctlr
operator|->
name|um_ctlr
index|]
argument_list|)
expr_stmt|;
name|hc
operator|->
name|master_mcb
operator|.
name|interrupt
operator|=
name|vba_ctlr
operator|->
name|um_ivct
expr_stmt|;
name|hc
operator|->
name|master_phaddr
operator|=
operator|(
name|u_long
operator|)
name|vtoph
argument_list|(
literal|0
argument_list|,
operator|&
name|hc
operator|->
name|master_mcb
argument_list|)
expr_stmt|;
comment|/* 	 * Read in the hdc module id word. 	 */
name|HDC_REGISTER
argument_list|(
name|module_id_reg
argument_list|)
operator|=
operator|(
name|unsigned
name|long
operator|)
name|vtoph
argument_list|(
literal|0
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|PADC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * hdc's are reset and downloaded by the console processor. 	 * Check the module id; the controller is bad if: 	 * 1) it is not an hdc; 	 * 2) the hdc's writeable control store is not loaded; 	 * 3) the hdc failed the functional integrity test; 	 */
name|printf
argument_list|(
literal|"hdc controller %d module id is %x\n"
argument_list|,
name|ctlr
argument_list|,
operator|*
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|module_id
operator|!=
operator|(
name|unsigned
name|char
operator|)
name|HDC_MID
condition|)
block|{
name|printf
argument_list|(
literal|"hdc:  controller #%d bad module id.\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|id
operator|->
name|code_rev
operator|==
operator|(
name|unsigned
name|char
operator|)
literal|0xFF
condition|)
block|{
name|printf
argument_list|(
literal|"hdc:  controller #%d micro-code not loaded.\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|id
operator|->
name|fit
operator|!=
operator|(
name|unsigned
name|char
operator|)
literal|0xFF
condition|)
block|{
name|printf
argument_list|(
literal|"hdc:  controller #%d FIT test failed.\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 	 * Reset the hdc in case it still has queued mcb's. 	 */
name|HDC_REGISTER
argument_list|(
name|soft_reset_reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/************************************************************************* *  Procedure:	hdsize * *  Description: Return the partition size for a specified partition. * *  Returns:     Partition size in blocks. *               -1 means the device isn't there **************************************************************************/
end_comment

begin_function
name|int
name|hdsize
parameter_list|(
name|dev
parameter_list|)
specifier|register
name|dev_t
name|dev
decl_stmt|;
comment|/* Major/minor dev#. 				 */
block|{
name|int
name|unit
decl_stmt|;
comment|/* hdc unit#  (0-31)  */
name|int
name|par
decl_stmt|;
comment|/* partition# (0-7)   */
name|struct
name|vba_device
modifier|*
name|vba_unit
decl_stmt|;
comment|/* vba unit info      */
name|hdc_unit_type
modifier|*
name|hu
decl_stmt|;
comment|/* hdc unit info      */
name|unit
operator|=
name|HDC_UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|par
operator|=
name|HDC_PARTITION
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vba_unit
operator|=
name|vddinfo
index|[
name|unit
index|]
expr_stmt|;
name|hu
operator|=
operator|&
name|hdc_units
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|vba_unit
operator|==
literal|0
operator|||
operator|!
name|vba_unit
operator|->
name|ui_alive
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|hu
operator|->
name|partition
index|[
name|par
index|]
operator|.
name|length
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************* *  Procedure:	hdslave * *  Description: "hdslave" verifies that an hdc drive is really there. *               It is called during the configuration phase of a reboot *               for each drive on an hdc. * *               Note: a lot of device initialization is done here, which *               should normally be done in hdattach; however, it is *               done here since it is info needed to determine whether *               the drive is really there and is functional. * *  Returns:	TRUE means the drive is there. **************************************************************************/
end_comment

begin_function
name|int
name|hdslave
parameter_list|(
name|vba_unit
parameter_list|,
name|regs
parameter_list|)
name|struct
name|vba_device
modifier|*
name|vba_unit
decl_stmt|;
comment|/* vba drive info 						 */
name|hdc_regs_type
modifier|*
name|regs
decl_stmt|;
comment|/* hdc io address (not used) 						 */
block|{
specifier|register
name|hdc_ctlr_type
modifier|*
name|hc
decl_stmt|;
comment|/* hdc ctlr info            */
specifier|register
name|hdc_unit_type
modifier|*
name|hu
decl_stmt|;
comment|/* hdc unit info            */
specifier|register
name|mcb_type
modifier|*
name|mcb
decl_stmt|;
comment|/* mcb to send to the hdc   */
specifier|register
name|int
name|unit
decl_stmt|;
comment|/* hdc unit# (0-31)         */
specifier|register
name|int
name|ctlr
decl_stmt|;
comment|/* hdc ctlr# (0-15)         */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* temp                     */
name|geometry_block
modifier|*
name|geo
decl_stmt|;
comment|/* ptr to the geometry block*/
name|drive_stat_type
modifier|*
name|drive_status
decl_stmt|;
comment|/* status returned by hdc   */
name|ctlr
operator|=
name|vba_unit
operator|->
name|ui_ctlr
expr_stmt|;
name|hc
operator|=
operator|&
name|hdc_ctlrs
index|[
name|ctlr
index|]
expr_stmt|;
name|unit
operator|=
name|vba_unit
operator|->
name|ui_unit
expr_stmt|;
name|hu
operator|=
operator|&
name|hdc_units
index|[
name|unit
index|]
expr_stmt|;
name|mcb
operator|=
operator|(
name|mcb_type
operator|*
operator|)
operator|&
name|hu
operator|->
name|phio_mcb
expr_stmt|;
comment|/* 	 * Initialize things in the hdc unit structure which are used 	 * by this routine. The rest is initialized by hdattach. 	 */
name|hu
operator|->
name|ctlr
operator|=
name|ctlr
expr_stmt|;
name|hu
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|hu
operator|->
name|slave
operator|=
name|vba_unit
operator|->
name|ui_slave
expr_stmt|;
comment|/* 	 * Read the drive status and keep a permanent copy of the 	 * info in the hdc unit structure. 	 */
name|drive_status
operator|=
operator|(
name|drive_stat_type
operator|*
operator|)
name|hu
operator|->
name|phio_data
expr_stmt|;
name|mcb
operator|->
name|command
operator|=
name|HCMD_STATUS
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|lwc
operator|=
sizeof|sizeof
argument_list|(
name|drive_stat_type
argument_list|)
operator|/
literal|4
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|ta
operator|=
operator|(
name|u_long
operator|)
name|vtoph
argument_list|(
literal|0
argument_list|,
name|drive_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hdimcb
argument_list|(
name|hu
argument_list|,
name|mcb
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|hu
operator|->
name|id
operator|=
name|drive_status
operator|->
name|id
expr_stmt|;
name|hu
operator|->
name|cylinders
operator|=
name|drive_status
operator|->
name|max_cyl
operator|+
literal|1
expr_stmt|;
name|hu
operator|->
name|heads
operator|=
name|drive_status
operator|->
name|max_head
operator|+
literal|1
expr_stmt|;
name|hu
operator|->
name|sectors
operator|=
name|drive_status
operator|->
name|max_sector
operator|+
literal|1
expr_stmt|;
name|hu
operator|->
name|phys_cylinders
operator|=
name|drive_status
operator|->
name|max_phys_cyl
operator|+
literal|1
expr_stmt|;
name|hu
operator|->
name|phys_heads
operator|=
name|drive_status
operator|->
name|max_phys_head
operator|+
literal|1
expr_stmt|;
name|hu
operator|->
name|phys_sectors
operator|=
name|drive_status
operator|->
name|max_phys_sector
operator|+
literal|1
expr_stmt|;
name|hu
operator|->
name|def_cyl
operator|=
name|drive_status
operator|->
name|def_cyl
expr_stmt|;
name|hu
operator|->
name|def_cyl_count
operator|=
name|drive_status
operator|->
name|def_cyl_count
expr_stmt|;
name|hu
operator|->
name|diag_cyl
operator|=
name|drive_status
operator|->
name|diag_cyl
expr_stmt|;
name|hu
operator|->
name|diag_cyl_count
operator|=
name|drive_status
operator|->
name|diag_cyl_count
expr_stmt|;
name|hu
operator|->
name|bytes_per_sec
operator|=
name|drive_status
operator|->
name|bytes_per_sec
expr_stmt|;
name|hu
operator|->
name|rpm
operator|=
name|drive_status
operator|->
name|rpm
expr_stmt|;
name|hu
operator|->
name|partition
index|[
name|HDC_DEFPART
index|]
operator|.
name|start
operator|=
name|hu
operator|->
name|def_cyl
operator|*
name|hu
operator|->
name|sectors
operator|*
name|hu
operator|->
name|heads
operator|/
name|HDC_SPB
expr_stmt|;
name|hu
operator|->
name|partition
index|[
name|HDC_DEFPART
index|]
operator|.
name|length
operator|=
name|hu
operator|->
name|def_cyl_count
operator|*
name|hu
operator|->
name|sectors
operator|*
name|hu
operator|->
name|heads
operator|/
name|HDC_SPB
expr_stmt|;
comment|/* 	 * Report the drive down if anything in the drive status 	 * looks bad.  If the drive is offline and it is not on 	 * cylinder, then the drive is not there. 	 * If there is a fault condition, the hdc will try to clear 	 * it when we read the geometry block. 	 */
if|if
condition|(
name|drive_status
operator|->
name|drs
operator|&
name|DRS_FAULT
condition|)
name|printf
argument_list|(
literal|"hdc: clearing fault on unit #%d.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|drive_status
operator|->
name|drs
operator|&
name|DRS_ONLINE
operator|)
condition|)
block|{
if|if
condition|(
name|drive_status
operator|->
name|drs
operator|&
name|DRS_ON_CYLINDER
condition|)
name|printf
argument_list|(
literal|"hdc: unit #%d is not online.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 	 * Read the geometry block from the start of the drive 	 * definition cylinder, validate it (must have the correct 	 * header and checksum), and set partition starts and sizes 	 * (definition partition has already been set above). 	 */
name|geo
operator|=
operator|(
name|geometry_block
operator|*
operator|)
name|hu
operator|->
name|phio_data
expr_stmt|;
name|mcb
operator|->
name|command
operator|=
name|HCMD_READ
expr_stmt|;
name|mcb
operator|->
name|cyl
operator|=
name|hu
operator|->
name|def_cyl
expr_stmt|;
name|mcb
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|sector
operator|=
literal|0
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|lwc
operator|=
sizeof|sizeof
argument_list|(
name|geometry_sector
argument_list|)
operator|/
literal|4
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|ta
operator|=
operator|(
name|unsigned
name|long
operator|)
name|vtoph
argument_list|(
literal|0
argument_list|,
name|geo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hdimcb
argument_list|(
name|hu
argument_list|,
name|mcb
argument_list|)
condition|)
goto|goto
name|badgeo
goto|;
if|if
condition|(
name|geo
operator|->
name|version
operator|>
literal|64000
operator|||
name|geo
operator|->
name|version
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: bad geometry block version# on unit #%d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|badgeo
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|geo
operator|->
name|id
index|[
literal|0
index|]
argument_list|,
name|GB_ID
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: bad geometry block header on unit #%d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|badgeo
goto|;
block|}
name|GB_CHECKSUM
argument_list|(
name|geo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|geometry_sector
operator|*
operator|)
name|geo
operator|)
operator|->
name|checksum
operator|!=
name|i
condition|)
block|{
name|printf
argument_list|(
literal|"hdc: bad geometry block checksum on unit #%d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|badgeo
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GB_MAXPART
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|HDC_DEFPART
condition|)
continue|continue;
name|hu
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|start
operator|=
name|geo
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|start
expr_stmt|;
name|hu
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|length
operator|=
name|geo
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
return|return
name|TRUE
return|;
comment|/* 	 * If the geometry block is bad, return ok status so that 	 * the disk can be formatted etc, but zero the partitions 	 * so that no one except "format" can read/write the disk. 	 */
name|badgeo
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GB_MAXPART
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|HDC_DEFPART
condition|)
continue|continue;
name|hu
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|hu
operator|->
name|partition
index|[
name|i
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/************************************************************************* *  Procedure:	hdstrategy * *  Description: The hdc strategy routine. It is called by the kernel *               to do a disk operation  ('physio' if raw i/o, the block *               i/o routines if block i/o); i.e. this is the point where *               raw i/o and block i/o merge. This routine is also called *               internally by this handler to do misc disk operations. * *  Returns: **************************************************************************/
end_comment

begin_expr_stmt
name|hdstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This buf structure contains info        				 * describing the requested disk xfer. 				 */
end_comment

begin_block
block|{
specifier|register
name|hdc_unit_type
modifier|*
name|hu
decl_stmt|;
comment|/* hdc device unit info     */
specifier|register
name|mcb_type
modifier|*
name|mcb
decl_stmt|;
comment|/* the mcb built here       */
specifier|register
name|int
name|vaddr
decl_stmt|;
comment|/* virtual address of data  */
name|hdc_ctlr_type
modifier|*
name|hc
decl_stmt|;
comment|/* hdc controller info      */
name|int
name|sector
decl_stmt|;
comment|/* absolute sector number   */
name|int
name|unit
decl_stmt|;
comment|/* minor device unit#       */
name|int
name|par
decl_stmt|;
comment|/* disk partition number    */
name|int
name|blocks
decl_stmt|;
comment|/* number of blocks to xfer */
name|int
name|priority
decl_stmt|;
comment|/* processor level save     */
name|int
name|bytes
decl_stmt|;
comment|/* bytecount requested      */
name|int
name|i
decl_stmt|;
comment|/* temporary                */
comment|/* 	 * Initialize pointers and data. 	 */
name|unit
operator|=
name|HDC_UNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|par
operator|=
name|HDC_PARTITION
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|hu
operator|=
operator|&
name|hdc_units
index|[
name|unit
index|]
expr_stmt|;
name|hc
operator|=
operator|&
name|hdc_ctlrs
index|[
name|hu
operator|->
name|ctlr
index|]
expr_stmt|;
name|bytes
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|vaddr
operator|=
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
comment|/* 	 * Make some preliminary checks of the i/o request. 	 * Terminate the i/o immediately if: the request is for zero 	 * bytes or more than 32k bytes; the xfer does not start or 	 * end on a longword boundary. 	 * "format" sometimes requires bytes=0; e.g. for verify and 	 * format ioctls. 	 */
if|if
condition|(
name|bytes
operator|==
literal|0
operator|||
name|bytes
operator|>
literal|32
operator|*
literal|1024
condition|)
if|if
condition|(
operator|!
name|hu
operator|->
name|format
condition|)
goto|goto
name|enxio
goto|;
if|if
condition|(
operator|(
name|bytes
operator|&
literal|3
operator|)
operator|||
operator|(
name|vaddr
operator|&
literal|3
operator|)
condition|)
goto|goto
name|efault
goto|;
comment|/* 	 * Round up requested byte count to a multiple of the block size. 	 * If the transfer would exceed the end of the partition, 	 * truncate the byte count at the partition boundary (except that 	 * the format program is allowed to access the entire disk). 	 * Determine absolute sector number of the start of the transfer 	 * (requested start plus the start of the partition). 	 */
block|{
specifier|register
name|int
name|par_start
decl_stmt|;
comment|/* partition start blk */
specifier|register
name|int
name|par_length
decl_stmt|;
comment|/* partition blk count */
name|par_start
operator|=
name|hu
operator|->
name|partition
index|[
name|par
index|]
operator|.
name|start
expr_stmt|;
name|par_length
operator|=
name|hu
operator|->
name|partition
index|[
name|par
index|]
operator|.
name|length
expr_stmt|;
name|blocks
operator|=
operator|(
name|bytes
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|>>
name|DEV_BSHIFT
expr_stmt|;
if|if
condition|(
name|par_length
operator|<
operator|(
name|bp
operator|->
name|b_blkno
operator|+
name|blocks
operator|)
condition|)
if|if
condition|(
operator|!
name|hu
operator|->
name|format
condition|)
block|{
name|blocks
operator|=
name|par_length
operator|-
name|bp
operator|->
name|b_blkno
expr_stmt|;
if|if
condition|(
name|blocks
operator|<=
literal|0
condition|)
goto|goto
name|enxio
goto|;
name|bytes
operator|=
name|blocks
operator|*
name|DEV_BSIZE
expr_stmt|;
block|}
name|sector
operator|=
name|HDC_SPB
operator|*
operator|(
name|bp
operator|->
name|b_blkno
operator|+
name|par_start
operator|)
expr_stmt|;
block|}
comment|/* 	 * Insure that nobody except the format program writes to 	 * the drive definition tracks in partition 7. 	 * Note: they may access other tracks in partition 7 	 * (i.e. diagnostic tracks). 	 */
if|if
condition|(
name|par
operator|==
name|HDC_DEFPART
condition|)
if|if
condition|(
operator|!
name|hu
operator|->
name|format
operator|&&
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|)
block|{
specifier|register
name|int
name|defs
decl_stmt|;
comment|/* definition cyl start */
specifier|register
name|int
name|defe
decl_stmt|;
comment|/* (def cylinder end)+1 */
name|defs
operator|=
name|hu
operator|->
name|def_cyl
operator|*
name|hu
operator|->
name|spc
expr_stmt|;
name|defe
operator|=
name|defs
operator|+
name|hu
operator|->
name|def_cyl_count
operator|*
name|hu
operator|->
name|spc
expr_stmt|;
if|if
condition|(
name|sector
operator|<
name|defe
operator|&&
operator|(
name|sector
operator|+
name|blocks
operator|*
name|HDC_SPB
operator|)
operator|>
name|defs
condition|)
goto|goto
name|eacces
goto|;
block|}
comment|/* 	 * Get a free mcb. Wait if no mcb's are available 	 */
name|priority
operator|=
name|spl7
argument_list|()
expr_stmt|;
name|get
label|:
name|mcb
operator|=
name|hc
operator|->
name|forw_free
expr_stmt|;
name|remque
argument_list|(
name|mcb
argument_list|)
expr_stmt|;
asm|asm(" bvc got");
name|slumber
argument_list|(
name|hc
argument_list|,
literal|0
argument_list|,
name|iocomboost
argument_list|)
expr_stmt|;
goto|goto
name|get
goto|;
name|got
label|:
asm|asm("got:");
name|splx
argument_list|(
name|priority
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the mcb with information about the xfer. 	 * 	 * Currently everything is given equal priority. 	 * Keep a pointer to the buf associated with the mcb. 	 * Add virtual address of this mcb to the software context 	 * word of the mcb; the hdc firmware copies this word to 	 * the master mcb when the mcb is complete. 	 * 	 * If the buf was sent locally by this handler (via 'hdphysio') 	 * then there may be commands other than just read or write. 	 * 'hdphysio' also provides a cylinder/head/sector address. 	 */
block|{
comment|/* 		 * The following priority calculation is based on the 		 * real time functional specification. 		 */
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|u
operator|.
name|u_procp
decl_stmt|;
name|mcb
operator|->
name|priority
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_ppid
operator|)
operator|&&
comment|/* not a system process */
operator|(
operator|(
name|p
operator|->
name|p_nice
operator|<
name|MIN_NON_RT_NICE_VAL
operator|)
operator|||
operator|(
name|rt_disk_scheduling
operator|)
operator|)
condition|)
block|{
name|mcb
operator|->
name|priority
operator|=
literal|32
operator|-
name|p
operator|->
name|p_basepri
expr_stmt|;
block|}
block|}
name|mcb
operator|->
name|interrupt
operator|=
name|TRUE
expr_stmt|;
name|mcb
operator|->
name|drive
operator|=
name|hu
operator|->
name|slave
expr_stmt|;
name|mcb
operator|->
name|buf_ptr
operator|=
name|bp
expr_stmt|;
name|mcb
operator|->
name|context
operator|=
operator|(
name|unsigned
name|long
operator|)
name|mcb
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_LOCALIO
condition|)
block|{
name|mcb
operator|->
name|command
operator|=
name|bp
operator|->
name|b_hdccommand
expr_stmt|;
name|mcb
operator|->
name|cyl
operator|=
name|bp
operator|->
name|b_cyl
expr_stmt|;
name|mcb
operator|->
name|head
operator|=
name|bp
operator|->
name|b_head
expr_stmt|;
name|mcb
operator|->
name|sector
operator|=
name|bp
operator|->
name|b_sector
expr_stmt|;
block|}
else|else
block|{
name|mcb
operator|->
name|command
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|HCMD_READ
else|:
name|HCMD_WRITE
expr_stmt|;
name|mcb
operator|->
name|cyl
operator|=
name|sector
operator|/
name|hu
operator|->
name|spc
expr_stmt|;
name|mcb
operator|->
name|head
operator|=
operator|(
name|sector
operator|/
name|hu
operator|->
name|sectors
operator|)
operator|%
name|hu
operator|->
name|heads
expr_stmt|;
name|mcb
operator|->
name|sector
operator|=
name|sector
operator|%
name|hu
operator|->
name|sectors
expr_stmt|;
block|}
comment|/* 	 * Build the data chain - address/count pairs for each page. 	 * The first transfer might not start on a page boundary. 	 * Purge the data cache for pages to be dma'd into. 	 * 	 * There is no attempt to combine physically contiguous 	 * pages into the same data chain, since it is faster 	 * to just dma the extra data chain into the controller 	 * than it is to combine the pages; 	 */
block|{
specifier|register
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
comment|/* process structure   */
specifier|register
name|int
name|bc
decl_stmt|;
comment|/* bytecount this page */
specifier|register
name|int
name|bcremain
init|=
name|bytes
decl_stmt|;
comment|/* bytecount remaining */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DIRTY
condition|)
name|procp
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
operator|&
name|proc
index|[
literal|2
index|]
expr_stmt|;
else|else
name|procp
operator|=
name|bp
operator|->
name|b_proc
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|mtpr
argument_list|(
name|P1DC
argument_list|,
name|vaddr
argument_list|)
expr_stmt|;
name|bc
operator|=
name|min
argument_list|(
name|bcremain
argument_list|,
operator|(
name|NBPG
operator|-
operator|(
name|vaddr
operator|&
operator|(
name|NBPG
operator|-
literal|1
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|ta
operator|=
name|vtoph
argument_list|(
name|procp
argument_list|,
name|vaddr
argument_list|)
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
literal|0
index|]
operator|.
name|lwc
operator|=
name|bc
operator|/
literal|4
expr_stmt|;
for|for
control|(
name|bcremain
operator|-=
name|bc
operator|,
name|i
operator|=
literal|0
init|;
name|bcremain
operator|>
literal|0
condition|;
control|)
block|{
name|vaddr
operator|+=
name|bc
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|mtpr
argument_list|(
name|P1DC
argument_list|,
name|vaddr
argument_list|)
expr_stmt|;
name|bc
operator|=
name|min
argument_list|(
name|bcremain
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
name|i
index|]
operator|.
name|lwc
operator||=
name|LWC_DATA_CHAIN
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
name|i
index|]
operator|.
name|ta
operator|=
name|vtoph
argument_list|(
name|procp
argument_list|,
name|vaddr
argument_list|)
expr_stmt|;
name|mcb
operator|->
name|chain
index|[
name|i
index|]
operator|.
name|lwc
operator|=
name|bc
operator|/
literal|4
expr_stmt|;
name|bcremain
operator|-=
name|bc
expr_stmt|;
block|}
block|}
comment|/* 	 * Set up information for error logging and system activity 	 * for programs such as iostat, sadp, sadc, sar, sag. 	 * Time-stamp the buf (and the unit if it is just becoming busy). 	 * Record the total number of transfer operations and the total 	 * no. of 512-byte blocks xferred. 	 * Turn on the activity bit for this device - for error logging. 	 */
name|bp
operator|->
name|b_start
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|vdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|++
operator|==
literal|1
condition|)
name|vdtab
index|[
name|unit
index|]
operator|.
name|io_start
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|vdstat
index|[
name|unit
index|]
operator|.
name|io_cnt
operator|++
expr_stmt|;
name|vdstat
index|[
name|unit
index|]
operator|.
name|io_bcnt
operator|+=
name|blocks
operator|*
name|HDC_SPB
expr_stmt|;
name|blkacty
operator||=
operator|(
literal|1
operator|<<
name|major
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|)
expr_stmt|;
name|dk_wds
index|[
name|unit
index|]
operator|+=
name|bytes
operator|/
literal|32
expr_stmt|;
name|dk_busy
operator||=
literal|1
operator|<<
name|unit
expr_stmt|;
comment|/* 	 * If the controller has active mcb's: 	 *    don't send this mcb until the next interrupt occurs. 	 * 	 * Otherwise: 	 *    1) add the mcb to the active queue; 	 *    2) physically link the mcb from the master mcb; 	 *    3) fill in the master mcb; 	 *    4) tell the hdc to scan the new mcb. 	 */
block|{
specifier|register
name|master_mcb_type
modifier|*
name|master
decl_stmt|;
comment|/* hdc's master mcb */
name|master
operator|=
operator|&
name|hc
operator|->
name|master_mcb
expr_stmt|;
name|priority
operator|=
name|spl7
argument_list|()
expr_stmt|;
if|if
condition|(
name|hc
operator|->
name|forw_active
operator|!=
operator|(
name|mcb_type
operator|*
operator|)
operator|&
name|hc
operator|->
name|forw_active
condition|)
block|{
name|insque
argument_list|(
name|mcb
argument_list|,
operator|&
name|hc
operator|->
name|forw_wait
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HDCLOG
name|hdlog
argument_list|(
name|mcb
argument_list|,
literal|4
operator|+
literal|16
operator|*
name|hc
operator|->
name|ctlr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|insque
argument_list|(
name|mcb
argument_list|,
operator|&
name|hc
operator|->
name|forw_active
argument_list|)
expr_stmt|;
name|master
operator|->
name|forw_phaddr
operator|=
name|mcb
operator|->
name|mcb_phaddr
expr_stmt|;
name|mcb
operator|->
name|forw_phaddr
operator|=
literal|0
expr_stmt|;
name|master
operator|->
name|mcs
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HDCLOG
name|hdlog
argument_list|(
name|mcb
argument_list|,
literal|5
operator|+
literal|16
operator|*
name|hc
operator|->
name|ctlr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|HDC_REGISTER
argument_list|(
name|master_mcb_reg
argument_list|)
operator|=
name|hc
operator|->
name|master_phaddr
expr_stmt|;
block|}
name|splx
argument_list|(
name|priority
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Returns. 	 */
return|return;
name|eacces
label|:
name|bp
operator|->
name|b_error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|errcom
goto|;
name|efault
label|:
name|bp
operator|->
name|b_error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|errcom
goto|;
name|enxio
label|:
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
name|errcom
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bytes
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hdread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|hdc_unit_type
modifier|*
name|hu
decl_stmt|;
name|hu
operator|=
operator|&
name|hdc_units
index|[
name|HDC_UNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|hdstrategy
argument_list|,
operator|&
name|hu
operator|->
name|raw_buf
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|hdwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|hdc_unit_type
modifier|*
name|hu
decl_stmt|;
name|hu
operator|=
operator|&
name|hdc_units
index|[
name|HDC_UNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|hdstrategy
argument_list|,
operator|&
name|hu
operator|->
name|raw_buf
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

end_unit

