begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	vx.c	1.3	86/01/12	*/
end_comment

begin_include
include|#
directive|include
file|"vx.h"
end_include

begin_if
if|#
directive|if
name|NVX
operator|>
literal|0
end_if

begin_comment
comment|/*  * VIOC-X driver  */
end_comment

begin_include
include|#
directive|include
file|"../tahoe/pte.h"
end_include

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/ioctl.h"
end_include

begin_include
include|#
directive|include
file|"../h/tty.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/map.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_include
include|#
directive|include
file|"../h/conf.h"
end_include

begin_include
include|#
directive|include
file|"../h/file.h"
end_include

begin_include
include|#
directive|include
file|"../h/uio.h"
end_include

begin_include
include|#
directive|include
file|"../h/proc.h"
end_include

begin_include
include|#
directive|include
file|"../h/vm.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vioc.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VXPERF
end_ifdef

begin_include
include|#
directive|include
file|"../tahoevba/scope.h"
end_include

begin_endif
endif|#
directive|endif
endif|VXPERF
end_endif

begin_include
include|#
directive|include
file|"vbsc.h"
end_include

begin_if
if|#
directive|if
name|NVBSC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"../bsc/bscio.h"
end_include

begin_include
include|#
directive|include
file|"../bsc/bsc.h"
end_include

begin_decl_stmt
name|char
name|bscport
index|[
name|NVXPORTS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSC_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"../bsc/bscdebug.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VX_DEBUG
end_ifdef

begin_decl_stmt
name|long
name|vxintr4
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|vxdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"../vba/vxdebug.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RSPquals
value|1
end_define

begin_decl_stmt
name|struct
name|vcx
name|vcx
index|[
name|NVIOCX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tty
name|vx_tty
index|[
name|NVXPORTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|vcmds
name|v_cmds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|reinit
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|vxstart
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ttrstrt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|vxcmd
modifier|*
name|vobtain
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|vxcmd
modifier|*
name|nextcmd
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Driver information for auto-configuration stuff.  * (not tested and probably should be changed)  */
end_comment

begin_decl_stmt
name|int
name|vxprobe
argument_list|()
decl_stmt|,
name|vxattach
argument_list|()
decl_stmt|,
name|vxrint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vxinfo
index|[
name|NVIOCX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|vxstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|vxdriver
init|=
block|{
name|vxprobe
block|,
literal|0
block|,
name|vxattach
block|,
literal|0
block|,
name|vxstd
block|,
literal|"vx"
block|,
name|vxinfo
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|vxtype
index|[
name|NVIOCX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0: viox-x/vioc-b; 1: vioc-bop */
end_comment

begin_decl_stmt
name|char
name|vxbbno
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|vxbopno
index|[
name|NVIOCX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BOP board no. if indicated by vxtype[] */
end_comment

begin_decl_stmt
name|int
name|vxivec
index|[
name|NVIOCX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interrupt vector base */
end_comment

begin_extern
extern|extern	vbrall(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_macro
name|vxprobe
argument_list|(
argument|reg
argument_list|,
argument|vi
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* must be r12, r11 */
specifier|register
name|struct
name|vblok
modifier|*
name|vp
init|=
operator|(
expr|struct
name|vblok
operator|*
operator|)
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|vackint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vunsol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vcmdrsp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vxfreset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vp
operator|->
name|v_fault
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|v_vioc
operator|=
name|V_BSY
expr_stmt|;
name|vp
operator|->
name|v_hdwre
operator|=
name|V_RESET
expr_stmt|;
comment|/* reset interrupt */
name|DELAY
argument_list|(
literal|4000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_fault
operator|!=
name|VREADY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * Align vioc interrupt vector base to 4 vector 	 * boundary and fitting in 8 bits (is this necessary, 	 * wish we had documentation). 	 */
if|if
condition|(
operator|(
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
operator|-=
literal|3
operator|)
operator|>
literal|0xff
condition|)
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
operator|=
literal|0xff
expr_stmt|;
name|vxivec
index|[
name|vi
operator|->
name|ui_unit
index|]
operator|=
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
operator|=
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
operator|&
operator|~
literal|0x3
expr_stmt|;
else|#
directive|else
name|vxivec
index|[
name|vi
operator|->
name|ui_unit
index|]
operator|=
literal|0x40
operator|+
name|vi
operator|->
name|ui_unit
operator|*
literal|4
expr_stmt|;
endif|#
directive|endif
name|br
operator|=
literal|0x18
operator|,
name|cvec
operator|=
name|vxivec
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
comment|/* XXX */
return|return
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|vp
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|vxattach
argument_list|(
name|vi
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|VIOCBAS
index|[
name|vi
operator|->
name|ui_unit
index|]
operator|=
name|vi
operator|->
name|ui_addr
expr_stmt|;
name|vxinit
argument_list|(
name|vi
operator|->
name|ui_unit
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Open a VX line.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|vxopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
comment|/* pointer to tty struct for port */
specifier|register
name|struct
name|vcx
modifier|*
name|xp
decl_stmt|;
comment|/* pointer to VIOC-X info/cmd buffer */
specifier|register
name|d
expr_stmt|;
comment|/* minor device number */
specifier|register
name|long
name|jj
decl_stmt|;
name|d
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* get minor device number */
if|if
condition|(
name|d
operator|>=
name|NVXPORTS
condition|)
comment|/* validate minor device number */
return|return
name|ENXIO
return|;
comment|/* set errno to indicate bad port # */
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|d
index|]
expr_stmt|;
comment|/* index the tty structure for port */
name|xp
operator|=
operator|&
name|vcx
index|[
name|d
operator|>>
literal|4
index|]
expr_stmt|;
comment|/* index VIOC-X info/cmd area */
name|d
operator|&=
literal|017
expr_stmt|;
comment|/* If we did not find a board with the correct port number on 	   it, or the entry for the VIOC-X had no ports on it, inform the 	   caller that the port does not exist. */
if|if
condition|(
operator|!
operator|(
name|xp
operator|->
name|v_loport
operator|<=
name|d
operator|&&
name|d
operator|<=
name|xp
operator|->
name|v_hiport
operator|)
comment|/* home? */
operator|||
operator|(
name|xp
operator|->
name|v_hiport
operator|-
name|xp
operator|->
name|v_loport
operator|)
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
comment|/* bad minor device number */
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
name|xp
expr_stmt|;
comment|/* store address of VIOC-X info */
name|tp
operator|->
name|t_oproc
operator|=
name|vxstart
expr_stmt|;
comment|/* store address of startup routine */
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
comment|/* store major/minor device numbers */
name|d
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
comment|/* mark device as waiting for open */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
comment|/* is device already open? */
block|{
comment|/*  no, open it */
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* set default control chars */
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
comment|/* if no default speeds set them */
block|{
name|tp
operator|->
name|t_ispeed
operator|=
name|SSPEED
expr_stmt|;
comment|/* default input baud */
name|tp
operator|->
name|t_ospeed
operator|=
name|SSPEED
expr_stmt|;
comment|/* default output baud */
name|tp
operator|->
name|t_flags
operator||=
operator|(
name|ODDP
operator||
name|EVENP
operator||
name|ECHO
operator|)
expr_stmt|;
comment|/* default modes */
block|}
name|vxparam
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* set parameters for this port */
block|}
name|splx
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* ? if already open for exclusive use open fails unless caller is  	     root. */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|u
operator|.
name|u_uid
operator|!=
literal|0
condition|)
return|return
name|EBUSY
return|;
comment|/* device is busy, sorry */
comment|/* wait for data carrier detect to go high */
name|d
operator|=
name|spl8
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|vcmodem
argument_list|(
name|dev
argument_list|,
name|VMOD_ON
argument_list|)
condition|)
while|while
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_canq
argument_list|,
name|TTIPRI
argument_list|)
expr_stmt|;
name|jj
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
comment|/*let tty.c finish the open */
name|splx
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* 1/2/85 : assures open complete */
return|return
operator|(
name|jj
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Close a VX line.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|vxclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|d
expr_stmt|;
name|d
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0377
expr_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|d
index|]
expr_stmt|;
name|d
operator|=
name|spl8
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_HUPCLS
operator|)
condition|)
if|if
condition|(
operator|!
name|vcmodem
argument_list|(
name|dev
argument_list|,
name|VMOD_OFF
argument_list|)
condition|)
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CARR_ON
expr_stmt|;
comment|/* wait for the last response */
while|while
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_state
argument_list|,
name|TTOPRI
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* let tty.c finish the close */
name|splx
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read from a VX line.  */
end_comment

begin_macro
name|vxread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|vx_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0377
index|]
decl_stmt|;
return|return
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * write on a VX line  */
end_comment

begin_macro
name|vxwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|vx_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0377
index|]
decl_stmt|;
return|return
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * VIOCX unsolicited interrupt.  */
end_comment

begin_expr_stmt
name|vxrint
argument_list|(
name|n
argument_list|)
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* mux number */
end_comment

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|vcx
modifier|*
name|xp
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|vblok
modifier|*
name|kp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|short
modifier|*
name|savsilo
decl_stmt|;
struct|struct
name|silo
block|{
name|char
name|data
decl_stmt|;
name|char
name|port
decl_stmt|;
block|}
struct|;
name|kp
operator|=
name|VBAS
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|xp
operator|=
operator|&
name|vcx
index|[
name|n
index|]
expr_stmt|;
switch|switch
condition|(
name|kp
operator|->
name|v_uqual
operator|&
literal|037
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|" ERR NBR %x\n"
argument_list|,
name|kp
operator|->
name|v_ustat
argument_list|)
expr_stmt|;
name|vpanic
argument_list|(
literal|"vc: VC PROC ERR"
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|3
case|:
name|vcmintr
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
literal|1
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|" ERR NBR %x\n"
argument_list|,
name|kp
operator|->
name|v_uqual
argument_list|)
expr_stmt|;
name|vpanic
argument_list|(
literal|"vc: VC UQUAL ERR"
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|xp
operator|->
name|v_vers
operator|==
name|V_NEW
condition|)
block|{
specifier|register
name|short
modifier|*
name|aa
decl_stmt|;
name|aa
operator|=
operator|(
name|short
operator|*
operator|)
name|kp
operator|->
name|v_usdata
expr_stmt|;
name|sp
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
operator|*
name|aa
operator|+
operator|(
name|char
operator|*
operator|)
name|kp
operator|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|kp
operator|->
name|v_usdata
index|[
literal|0
index|]
operator|<<
literal|6
expr_stmt|;
name|sp
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|kp
operator|+
name|SILOBAS
operator|+
name|c
operator|)
expr_stmt|;
block|}
name|i
operator|=
operator|*
operator|(
name|savsilo
operator|=
name|sp
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|xp
operator|->
name|v_vers
operator|==
name|V_NEW
condition|)
if|if
condition|(
name|i
operator|>
name|xp
operator|->
name|v_silosiz
condition|)
block|{
name|printf
argument_list|(
literal|"vx: %d exceeds silo size\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|xp
operator|->
name|v_silosiz
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|++
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|sp
operator|++
control|)
block|{
name|c
operator|=
operator|(
operator|(
expr|struct
name|silo
operator|*
operator|)
name|sp
operator|)
operator|->
name|port
operator|&
literal|017
expr_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|c
operator|+
name|n
operator|*
literal|16
index|]
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|v_loport
operator|>
name|c
operator|||
name|c
operator|>
name|xp
operator|->
name|v_hiport
condition|)
continue|continue;
comment|/* port out of bounds */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
operator|(
operator|(
expr|struct
name|silo
operator|*
operator|)
name|sp
operator|)
operator|->
name|data
expr_stmt|;
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|silo
operator|*
operator|)
name|sp
operator|)
operator|->
name|port
operator|&
operator|(
name|PERROR
operator||
name|FERROR
operator|)
condition|)
block|{
case|case
name|PERROR
case|:
case|case
name|PERROR
operator||
name|FERROR
case|:
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
name|EVENP
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
name|ODDP
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
expr|struct
name|silo
operator|*
operator|)
name|sp
operator|)
operator|->
name|port
operator|&
name|FERROR
operator|)
condition|)
break|break;
case|case
name|FERROR
case|:
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|RAW
condition|)
name|c
operator|=
literal|0
expr_stmt|;
else|else
name|c
operator|=
name|tp
operator|->
name|t_intrc
expr_stmt|;
block|}
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|,
name|tp
operator|)
expr_stmt|;
block|}
operator|*
name|savsilo
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * stty/gtty for VX  */
end_comment

begin_macro
name|vxioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* major, minor device numbers */
end_comment

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command */
end_comment

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|error
expr_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0377
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|TIOCSETP
operator|||
name|cmd
operator|==
name|TIOCSETN
condition|)
name|vxparam
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
else|else
return|return
name|ENOTTY
return|;
block|}
end_block

begin_macro
name|vxparam
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|vxcparam
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set parameters from open or stty into the VX hardware  * registers.  */
end_comment

begin_macro
name|vxcparam
argument_list|(
argument|dev
argument_list|,
argument|wait
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* major, minor device numbers */
end_comment

begin_decl_stmt
name|int
name|wait
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero if we should wait for finish */
end_comment

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|vcx
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|s
expr_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
comment|/* pointer to tty structure for port */
name|xp
operator|=
operator|(
expr|struct
name|vcx
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
comment|/* pointer to VIOCX info/cmd buffer */
name|cp
operator|=
name|vobtain
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|cp
operator|->
name|cmd
operator|=
name|LPARAX
expr_stmt|;
comment|/* set command to "load parameters" */
name|cp
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|017
expr_stmt|;
comment|/* port number */
name|cp
operator|->
name|par
index|[
literal|2
index|]
operator|=
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|RAW
operator|)
condition|?
literal|0
else|:
name|tp
operator|->
name|t_startc
expr_stmt|;
comment|/* XON char */
name|cp
operator|->
name|par
index|[
literal|3
index|]
operator|=
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|RAW
operator|)
condition|?
literal|0
else|:
name|tp
operator|->
name|t_stopc
expr_stmt|;
comment|/* XOFF char */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator|)
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
operator|(
name|EVENP
operator||
name|ODDP
operator|)
condition|)
block|{
name|cp
operator|->
name|par
index|[
literal|4
index|]
operator|=
literal|0xc0
expr_stmt|;
comment|/* 8 bits of data */
name|cp
operator|->
name|par
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no parity */
block|}
else|else
block|{
name|cp
operator|->
name|par
index|[
literal|4
index|]
operator|=
literal|0x40
expr_stmt|;
comment|/* 7 bits of data */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
name|ODDP
condition|)
name|cp
operator|->
name|par
index|[
literal|7
index|]
operator|=
literal|1
expr_stmt|;
comment|/* odd parity */
elseif|else
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
name|EVENP
condition|)
name|cp
operator|->
name|par
index|[
literal|7
index|]
operator|=
literal|3
expr_stmt|;
comment|/* even parity */
else|else
name|cp
operator|->
name|par
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no parity */
block|}
name|cp
operator|->
name|par
index|[
literal|5
index|]
operator|=
literal|0x4
expr_stmt|;
comment|/* 1 stop bit */
name|cp
operator|->
name|par
index|[
literal|6
index|]
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
if|if
condition|(
name|vcmd
argument_list|(
name|xp
operator|->
name|v_nbr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
operator|&&
name|wait
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|,
name|TTIPRI
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * VIOCX command response interrupt.  * For transmission, restart output to any active port.  * For all other commands, just clean up.  */
end_comment

begin_expr_stmt
name|vxxint
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* VIOC number */
end_comment

begin_decl_stmt
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command structure */
end_comment

begin_block
block|{
specifier|register
name|struct
name|vxmit
modifier|*
name|vp
decl_stmt|,
modifier|*
name|pvp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|vcx
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|hp
decl_stmt|;
name|xp
operator|=
operator|&
name|vcx
index|[
name|n
index|]
expr_stmt|;
name|cp
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
operator|(
operator|(
name|long
operator|*
operator|)
name|cp
operator|-
literal|1
operator|)
expr_stmt|;
if|#
directive|if
name|NVBSC
operator|>
literal|0
switch|switch
condition|(
name|cp
operator|->
name|cmd
condition|)
block|{
case|case
name|MDMCTL1
case|:
case|case
name|HUNTMD1
case|:
case|case
name|LPARAX1
case|:
name|vrelease
argument_list|(
name|xp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|cp
operator|->
name|cmd
operator|&
literal|0xff00
condition|)
block|{
case|case
name|LIDENT
case|:
comment|/* initialization complete */
if|if
condition|(
name|xp
operator|->
name|v_state
operator|&
name|V_RESETTING
condition|)
block|{
name|vxfnreset
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|vinthandl
argument_list|(
name|n
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|RSPquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|cmd
operator|++
expr_stmt|;
return|return;
case|case
name|XMITDTA
case|:
case|case
name|XMITIMM
case|:
break|break;
case|case
name|LPARAX
case|:
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|)
expr_stmt|;
default|default:
comment|/* MDMCTL or FDTATOX */
name|vrelease
argument_list|(
name|xp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|v_state
operator|&
name|V_RESETTING
condition|)
block|{
name|vinthandl
argument_list|(
name|n
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|RSPquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
for|for
control|(
name|vp
operator|=
operator|(
expr|struct
name|vxmit
operator|*
operator|)
operator|(
name|cp
operator|->
name|par
operator|+
operator|(
name|cp
operator|->
name|cmd
operator|&
literal|07
operator|)
operator|*
name|sizvxmit
operator|)
init|;
name|vp
operator|>=
operator|(
expr|struct
name|vxmit
operator|*
operator|)
name|cp
operator|->
name|par
condition|;
name|vp
operator|=
operator|(
expr|struct
name|vxmit
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|vp
operator|-
name|sizvxmit
operator|)
control|)
block|{
name|tp
operator|=
operator|&
name|vx_tty
index|[
operator|(
name|vp
operator|->
name|line
operator|&
literal|017
operator|)
operator|+
name|n
operator|*
literal|16
index|]
expr_stmt|;
comment|/* cjk buffer bug */
if|#
directive|if
name|NVBSC
operator|>
literal|0
comment|/* bsc change */
if|if
condition|(
name|tp
operator|->
name|t_line
operator|==
name|LDISP
condition|)
block|{
name|vrelease
argument_list|(
name|xp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|bsctxd
argument_list|(
operator|(
name|vp
operator|->
name|line
operator|&
literal|017
operator|)
argument_list|)
expr_stmt|;
return|return ;
block|}
comment|/* End of bsc change */
endif|#
directive|endif
comment|/* cjk */
name|pvp
operator|=
name|vp
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_FLUSH
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
block|}
else|else
name|ndflush
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|vp
operator|->
name|bcount
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|xp
operator|->
name|v_xmtcnt
operator|--
expr_stmt|;
name|vrelease
argument_list|(
name|xp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|v_vers
operator|==
name|V_NEW
condition|)
block|{
name|vp
operator|=
name|pvp
expr_stmt|;
name|xp
operator|->
name|v_actport
index|[
operator|(
name|vp
operator|->
name|line
operator|&
literal|017
operator|)
operator|-
name|xp
operator|->
name|v_loport
index|]
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|vxstart
argument_list|(
name|tp
argument_list|)
operator|&&
operator|(
name|cp
operator|=
name|nextcmd
argument_list|(
name|xp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|xp
operator|->
name|v_xmtcnt
operator|++
expr_stmt|;
name|vcmd
argument_list|(
name|n
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return ;
block|}
name|xp
operator|->
name|v_actport
index|[
operator|(
name|vp
operator|->
name|line
operator|&
literal|017
operator|)
operator|-
name|xp
operator|->
name|v_loport
index|]
operator|=
literal|0
expr_stmt|;
return|return ;
block|}
name|xp
operator|->
name|v_actflg
operator|=
literal|1
expr_stmt|;
name|hp
operator|=
operator|&
name|vx_tty
index|[
name|xp
operator|->
name|v_hiport
operator|+
name|n
operator|*
literal|16
index|]
expr_stmt|;
for|for
control|(
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|xp
operator|->
name|v_loport
operator|+
name|n
operator|*
literal|16
index|]
init|;
name|tp
operator|<=
name|hp
condition|;
name|tp
operator|++
control|)
if|if
condition|(
name|vxstart
argument_list|(
name|tp
argument_list|)
operator|&&
operator|(
name|cp
operator|=
name|nextcmd
argument_list|(
name|xp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|xp
operator|->
name|v_xmtcnt
operator|++
expr_stmt|;
name|vcmd
argument_list|(
name|n
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|nextcmd
argument_list|(
name|xp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
comment|/* command to send ? */
block|{
name|xp
operator|->
name|v_xmtcnt
operator|++
expr_stmt|;
name|vcmd
argument_list|(
name|n
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
name|xp
operator|->
name|v_actflg
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Force out partial XMIT command after timeout  */
end_comment

begin_expr_stmt
name|vxforce
argument_list|(
name|xp
argument_list|)
specifier|register
expr|struct
name|vcx
operator|*
name|xp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|nextcmd
argument_list|(
name|xp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|xp
operator|->
name|v_xmtcnt
operator|++
expr_stmt|;
name|vcmd
argument_list|(
name|xp
operator|->
name|v_nbr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start (restart) transmission on the given VX line.  */
end_comment

begin_expr_stmt
name|vxstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|short
name|n
decl_stmt|;
specifier|register
name|struct
name|vcx
modifier|*
name|xp
decl_stmt|;
specifier|register
name|char
modifier|*
name|outb
decl_stmt|;
specifier|register
name|full
operator|=
literal|0
expr_stmt|;
name|int
name|k
decl_stmt|,
name|s
decl_stmt|,
name|port
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|port
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&
literal|017
expr_stmt|;
name|xp
operator|=
operator|(
expr|struct
name|vcx
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|TTLOWAT
argument_list|(
name|tp
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_wsel
condition|)
block|{
name|selwakeup
argument_list|(
name|tp
operator|->
name|t_wsel
argument_list|,
name|tp
operator|->
name|t_state
operator|&
name|TS_WCOLL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_wsel
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_WCOLL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|VXPERF
name|scope_out
argument_list|(
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|VXPERF
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator|)
operator|)
condition|)
name|full
operator|=
literal|0200
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|full
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|full
condition|)
block|{
name|n
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ttrstrt
argument_list|,
operator|(
name|caddr_t
operator|)
name|tp
argument_list|,
operator|(
name|n
operator|&
literal|0177
operator|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_TIMEOUT
expr_stmt|;
name|full
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|outb
operator|=
operator|(
name|char
operator|*
operator|)
name|tp
operator|->
name|t_outq
operator|.
name|c_cf
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|v_vers
operator|==
name|V_NEW
condition|)
name|k
operator|=
name|xp
operator|->
name|v_actport
index|[
name|port
operator|-
name|xp
operator|->
name|v_loport
index|]
expr_stmt|;
else|else
name|k
operator|=
name|xp
operator|->
name|v_actflg
expr_stmt|;
name|full
operator|=
name|vsetq
argument_list|(
name|xp
argument_list|,
name|port
argument_list|,
name|outb
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* not called from vxxint */
if|if
condition|(
name|full
operator|||
name|xp
operator|->
name|v_xmtcnt
operator|==
literal|0
condition|)
block|{
name|outb
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|nextcmd
argument_list|(
name|xp
argument_list|)
operator|->
name|cmd
operator|)
expr_stmt|;
name|xp
operator|->
name|v_xmtcnt
operator|++
expr_stmt|;
name|vcmd
argument_list|(
name|xp
operator|->
name|v_nbr
argument_list|,
name|outb
argument_list|)
expr_stmt|;
block|}
else|else
name|timeout
argument_list|(
name|vxforce
argument_list|,
operator|(
name|caddr_t
operator|)
name|xp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|full
operator|)
return|;
comment|/* indicate if max commands or not */
block|}
end_block

begin_comment
comment|/*  * Stop output on a line.  */
end_comment

begin_expr_stmt
name|vxstop
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|s
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * VIOCX Initialization.  Makes free lists of command buffers.  * Resets all viocx's.  Issues a LIDENT command to each  * viocx which establishes interrupt vectors and logical  * port numbers  */
end_comment

begin_expr_stmt
name|vxinit
argument_list|(
name|i
argument_list|,
name|wait
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|long
name|wait
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vcx
modifier|*
name|xp
decl_stmt|;
comment|/* ptr to VIOC-X info/cmd buffer */
specifier|register
name|struct
name|vblok
modifier|*
name|kp
decl_stmt|;
comment|/* pointer to VIOC-X control block */
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
comment|/* pointer to a command buffer */
specifier|register
name|char
modifier|*
name|resp
decl_stmt|;
comment|/* pointer to response buffer */
specifier|register
name|int
name|j
decl_stmt|;
name|char
name|type
decl_stmt|;
if|#
directive|if
name|NVBSC
operator|>
literal|0
specifier|register
name|struct
name|bsc
modifier|*
name|bp
decl_stmt|;
comment|/* bsc change */
specifier|extern
name|struct
name|bsc
name|bsc
index|[]
decl_stmt|;
endif|#
directive|endif
name|kp
operator|=
name|VBAS
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* get base adr of cntl blok for VIOC */
name|xp
operator|=
operator|&
name|vcx
index|[
name|i
index|]
expr_stmt|;
comment|/* index info/command buffers */
name|type
operator|=
name|kp
operator|->
name|v_ident
expr_stmt|;
name|vxtype
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Type is Viox-x */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|VIOCX
case|:
block|{
name|xp
operator|->
name|v_vers
operator|=
name|V_OLD
expr_stmt|;
comment|/* set DCD for printer ports */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|kp
operator|->
name|v_portyp
index|[
name|j
index|]
operator|==
literal|4
condition|)
name|kp
operator|->
name|v_dcd
operator||=
literal|1
operator|<<
name|j
expr_stmt|;
block|}
break|break ;
case|case
name|NWVIOCX
case|:
block|{
name|xp
operator|->
name|v_vers
operator|=
name|V_NEW
expr_stmt|;
name|xp
operator|->
name|v_silosiz
operator|=
name|kp
operator|->
name|v_maxsilo
expr_stmt|;
comment|/* set DCD for printer ports */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|kp
operator|->
name|v_portyp
index|[
name|j
index|]
operator|==
literal|4
condition|)
name|kp
operator|->
name|v_dcd
operator||=
literal|1
operator|<<
name|j
expr_stmt|;
block|}
break|break ;
case|case
name|PVIOCX
case|:
name|xp
operator|->
name|v_vers
operator|=
name|V_OLD
expr_stmt|;
break|break ;
case|case
name|NPVIOCX
case|:
name|xp
operator|->
name|v_vers
operator|=
name|V_NEW
expr_stmt|;
name|xp
operator|->
name|v_silosiz
operator|=
name|kp
operator|->
name|v_maxsilo
expr_stmt|;
break|break ;
if|#
directive|if
name|NVBSC
operator|>
literal|0
case|case
name|VIOCB
case|:
comment|/* old f/w, Bisync board */
name|printf
argument_list|(
literal|"%X: %x%x OLD VIOC-B, "
argument_list|,
operator|(
name|long
operator|)
name|kp
argument_list|,
operator|(
name|int
operator|)
name|kp
operator|->
name|v_ident
argument_list|,
operator|(
name|int
operator|)
name|kp
operator|->
name|v_fault
argument_list|)
expr_stmt|;
name|xp
operator|->
name|v_vers
operator|=
name|V_OLD
expr_stmt|;
comment|/* save device specific info */
for|for
control|(
name|bp
operator|=
operator|&
name|bsc
index|[
literal|0
index|]
init|;
name|bp
operator|<=
operator|&
name|bsc
index|[
name|NBSC
index|]
condition|;
name|bp
operator|++
control|)
name|bp
operator|->
name|b_devregs
operator|=
operator|(
name|caddr_t
operator|)
name|xp
expr_stmt|;
name|printf
argument_list|(
literal|"%d BSC Ports initialized.\n"
argument_list|,
name|NBSC
argument_list|)
expr_stmt|;
break|break ;
case|case
name|NWVIOCB
case|:
comment|/* new f/w, Bisync board */
name|printf
argument_list|(
literal|"%X: %x%x 16K VIOC-B, "
argument_list|,
operator|(
name|long
operator|)
name|kp
argument_list|,
operator|(
name|int
operator|)
name|kp
operator|->
name|v_ident
argument_list|,
operator|(
name|int
operator|)
name|kp
operator|->
name|v_fault
argument_list|)
expr_stmt|;
name|xp
operator|->
name|v_vers
operator|=
name|V_NEW
expr_stmt|;
name|xp
operator|->
name|v_silosiz
operator|=
name|kp
operator|->
name|v_maxsilo
expr_stmt|;
comment|/* save device specific info */
for|for
control|(
name|bp
operator|=
operator|&
name|bsc
index|[
literal|0
index|]
init|;
name|bp
operator|<=
operator|&
name|bsc
index|[
name|NBSC
index|]
condition|;
name|bp
operator|++
control|)
name|bp
operator|->
name|b_devregs
operator|=
operator|(
name|caddr_t
operator|)
name|xp
expr_stmt|;
name|printf
argument_list|(
literal|"%d BSC Ports initialized.\n"
argument_list|,
name|NBSC
argument_list|)
expr_stmt|;
if|if
condition|(
name|CBSIZE
operator|>
name|kp
operator|->
name|v_maxxmt
condition|)
name|printf
argument_list|(
literal|"vxinit: Warning CBSIZE> maxxmt\n"
argument_list|)
expr_stmt|;
break|break ;
endif|#
directive|endif
case|case
name|VBOPID
case|:
comment|/* VIOC-BOP */
name|vxbbno
operator|++
expr_stmt|;
name|vxtype
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|vxbopno
index|[
name|i
index|]
operator|=
name|vxbbno
expr_stmt|;
name|printf
argument_list|(
literal|"VIOC-BOP no. %d at %lx\n"
argument_list|,
name|vxbopno
index|[
name|i
index|]
argument_list|,
name|VIOCBAS
index|[
name|i
index|]
argument_list|)
expr_stmt|;
default|default:
return|return ;
comment|/* Not a viocx type */
block|}
name|xp
operator|->
name|v_nbr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no number for it yet */
name|xp
operator|->
name|v_maxcmd
operator|=
name|xp
operator|->
name|v_vers
operator|==
name|V_NEW
condition|?
literal|24
else|:
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVCXBUFS
condition|;
name|j
operator|++
control|)
comment|/* init all cmd buffers */
block|{
name|cp
operator|=
operator|&
name|xp
operator|->
name|vx_lst
index|[
name|j
index|]
expr_stmt|;
comment|/* index a buffer */
name|cp
operator|->
name|c_fwd
operator|=
operator|&
name|xp
operator|->
name|vx_lst
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
comment|/* point to next buf */
block|}
name|xp
operator|->
name|vx_avail
operator|=
operator|&
name|xp
operator|->
name|vx_lst
index|[
literal|0
index|]
expr_stmt|;
comment|/* set idx to 1st free buf */
name|cp
operator|->
name|c_fwd
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* mark last buf in free list */
name|cp
operator|=
name|vobtain
argument_list|(
name|xp
argument_list|)
expr_stmt|;
comment|/* grap the control block */
name|cp
operator|->
name|cmd
operator|=
name|LIDENT
expr_stmt|;
comment|/* set command type */
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|=
name|vxivec
index|[
name|i
index|]
expr_stmt|;
comment|/* ack vector */
name|cp
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
comment|/* cmd resp vector */
name|cp
operator|->
name|par
index|[
literal|3
index|]
operator|=
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
comment|/* unsol intr vector */
name|cp
operator|->
name|par
index|[
literal|4
index|]
operator|=
literal|15
expr_stmt|;
comment|/* max ports, no longer used */
name|cp
operator|->
name|par
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* set 1st port number */
name|vcmd
argument_list|(
name|i
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
comment|/* initialize the VIOC-X */
if|if
condition|(
operator|!
name|wait
condition|)
return|return;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|cp
operator|->
name|cmd
operator|==
name|LIDENT
operator|&&
name|j
operator|<
literal|4000000
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|>=
literal|4000000
condition|)
name|printf
argument_list|(
literal|"vx%d: didn't respond to LIDENT\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* calculate address of response buffer */
name|resp
operator|=
operator|(
name|char
operator|*
operator|)
name|kp
expr_stmt|;
name|resp
operator|+=
name|kp
operator|->
name|v_rspoff
operator|&
literal|0x3FFF
expr_stmt|;
if|if
condition|(
name|resp
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
operator|(
name|resp
index|[
literal|0
index|]
operator|&
literal|0177
operator|)
operator|!=
literal|3
condition|)
comment|/* did init work? */
block|{
name|vrelease
argument_list|(
name|xp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* init failed */
return|return;
comment|/* try next VIOC-X */
block|}
name|xp
operator|->
name|v_loport
operator|=
name|cp
operator|->
name|par
index|[
literal|5
index|]
expr_stmt|;
comment|/* save low port number */
name|xp
operator|->
name|v_hiport
operator|=
name|cp
operator|->
name|par
index|[
literal|7
index|]
expr_stmt|;
comment|/* VIOC knows high port numbr */
name|vrelease
argument_list|(
name|xp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* done with this control block */
name|xp
operator|->
name|v_nbr
operator|=
name|i
expr_stmt|;
comment|/* assign VIOC-X board number */
block|}
end_block

begin_comment
comment|/*  * Obtain a command buffer  */
end_comment

begin_function
name|struct
name|vxcmd
modifier|*
name|vobtain
parameter_list|(
name|xp
parameter_list|)
specifier|register
name|struct
name|vcx
modifier|*
name|xp
decl_stmt|;
block|{
specifier|register
name|struct
name|vxcmd
modifier|*
name|p
decl_stmt|;
specifier|register
name|s
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|p
operator|=
name|xp
operator|->
name|vx_avail
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|VX_DEBUG
if|if
condition|(
name|vxintr4
operator|&
name|VXNOBUF
condition|)
name|vxintr4
operator|&=
operator|~
name|VXNOBUF
expr_stmt|;
endif|#
directive|endif
name|vpanic
argument_list|(
literal|"vx: no buffs"
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|xp
operator|-
name|vcx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|vobtain
argument_list|(
name|xp
argument_list|)
operator|)
return|;
block|}
name|xp
operator|->
name|vx_avail
operator|=
operator|(
name|xp
operator|->
name|vx_avail
operator|)
operator|->
name|c_fwd
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a command buffer  */
end_comment

begin_expr_stmt
name|vrelease
argument_list|(
name|xp
argument_list|,
name|cp
argument_list|)
specifier|register
expr|struct
name|vcx
operator|*
name|xp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|s
expr_stmt|;
ifdef|#
directive|ifdef
name|VX_DEBUG
if|if
condition|(
name|vxintr4
operator|&
name|VXNOBUF
condition|)
return|return;
endif|#
directive|endif
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|cp
operator|->
name|c_fwd
operator|=
name|xp
operator|->
name|vx_avail
expr_stmt|;
name|xp
operator|->
name|vx_avail
operator|=
name|cp
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * vxcmd -   *  */
end_comment

begin_function
name|struct
name|vxcmd
modifier|*
name|nextcmd
parameter_list|(
name|xp
parameter_list|)
specifier|register
name|struct
name|vcx
modifier|*
name|xp
decl_stmt|;
block|{
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|cp
operator|=
name|xp
operator|->
name|vx_build
expr_stmt|;
name|xp
operator|->
name|vx_build
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * assemble transmits into a multiple command.  * up to 8 transmits to 8 lines can be assembled together  */
end_comment

begin_expr_stmt
name|vsetq
argument_list|(
name|xp
argument_list|,
name|d
argument_list|,
name|addr
argument_list|,
name|n
argument_list|)
specifier|register
expr|struct
name|vcx
operator|*
name|xp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|vxmit
modifier|*
name|mp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|cp
operator|=
name|xp
operator|->
name|vx_build
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
condition|)
block|{
name|cp
operator|=
name|vobtain
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|xp
operator|->
name|vx_build
operator|=
name|cp
expr_stmt|;
name|cp
operator|->
name|cmd
operator|=
name|XMITDTA
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cp
operator|->
name|cmd
operator|&
literal|07
operator|)
operator|==
literal|07
condition|)
block|{
name|vpanic
argument_list|(
literal|"vx: vsetq overflow"
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|xp
operator|->
name|v_nbr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cp
operator|->
name|cmd
operator|++
expr_stmt|;
block|}
name|mp
operator|=
operator|(
expr|struct
name|vxmit
operator|*
operator|)
operator|(
name|cp
operator|->
name|par
operator|+
operator|(
name|cp
operator|->
name|cmd
operator|&
literal|07
operator|)
operator|*
name|sizvxmit
operator|)
expr_stmt|;
name|mp
operator|->
name|bcount
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|mp
operator|->
name|line
operator|=
name|d
expr_stmt|;
if|if
condition|(
operator|(
name|xp
operator|->
name|v_vers
operator|==
name|V_NEW
operator|)
operator|&&
operator|(
name|n
operator|<=
literal|6
operator|)
condition|)
block|{
name|cp
operator|->
name|cmd
operator|=
name|XMITIMM
expr_stmt|;
name|p
operator|=
name|addr
expr_stmt|;
comment|/* bcopy(addr,&(char *)mp->ostream, n) ; */
block|}
else|else
block|{
name|addr
operator|=
operator|(
name|caddr_t
operator|)
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|addr
argument_list|)
expr_stmt|;
comment|/* should be a sys address */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
expr_stmt|;
name|n
operator|=
sizeof|sizeof
name|addr
expr_stmt|;
comment|/* mp->ostream = addr ; */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|mp
operator|->
name|ostream
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|v_vers
operator|==
name|V_NEW
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|cp
operator|->
name|cmd
operator|&
literal|07
operator|)
operator|==
literal|7
operator|)
return|;
comment|/* Indicate if full */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

