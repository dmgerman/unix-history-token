begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Computer Consoles Inc.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)vx.c	7.8 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"vx.h"
end_include

begin_if
if|#
directive|if
name|NVX
operator|>
literal|0
end_if

begin_comment
comment|/*  * VIOC-X driver  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VXPERF
end_ifdef

begin_define
define|#
directive|define
name|DOSCOPE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/pte.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbaparam.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vxreg.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/scope.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VX_DEBUG
end_ifdef

begin_decl_stmt
name|long
name|vxintr4
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VXERR4
value|1
end_define

begin_define
define|#
directive|define
name|VXNOBUF
value|2
end_define

begin_decl_stmt
name|long
name|vxdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VXVCM
value|1
end_define

begin_define
define|#
directive|define
name|VXVCC
value|2
end_define

begin_define
define|#
directive|define
name|VXVCX
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Interrupt type bits passed to vinthandl().  */
end_comment

begin_define
define|#
directive|define
name|CMDquals
value|0
end_define

begin_comment
comment|/* command completed interrupt */
end_comment

begin_define
define|#
directive|define
name|RSPquals
value|1
end_define

begin_comment
comment|/* command response interrupt */
end_comment

begin_define
define|#
directive|define
name|UNSquals
value|2
end_define

begin_comment
comment|/* unsolicited interrupt */
end_comment

begin_define
define|#
directive|define
name|VXUNIT
parameter_list|(
name|n
parameter_list|)
value|((n)>> 4)
end_define

begin_define
define|#
directive|define
name|VXPORT
parameter_list|(
name|n
parameter_list|)
value|((n)& 0xf)
end_define

begin_decl_stmt
name|struct
name|tty
name|vx_tty
index|[
name|NVX
operator|*
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|int
name|nvx
init|=
name|NVX
operator|*
literal|16
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|vxstart
argument_list|()
decl_stmt|,
name|ttrstrt
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vxcmd
modifier|*
name|vobtain
argument_list|()
decl_stmt|,
modifier|*
name|nextcmd
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Driver information for auto-configuration stuff.  */
end_comment

begin_decl_stmt
name|int
name|vxprobe
argument_list|()
decl_stmt|,
name|vxattach
argument_list|()
decl_stmt|,
name|vxrint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vxinfo
index|[
name|NVX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|vxstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|vxdriver
init|=
block|{
name|vxprobe
block|,
literal|0
block|,
name|vxattach
block|,
literal|0
block|,
name|vxstd
block|,
literal|"vx"
block|,
name|vxinfo
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|vx_softc
block|{
name|struct
name|vxdevice
modifier|*
name|vs_addr
decl_stmt|;
comment|/* H/W address */
name|u_char
name|vs_type
decl_stmt|;
comment|/* 0: viox-x/vioc-b, 1: vioc-bop */
name|u_char
name|vs_bop
decl_stmt|;
comment|/* bop board # for vioc-bop's */
name|u_char
name|vs_loport
decl_stmt|;
comment|/* low port nbr */
name|u_char
name|vs_hiport
decl_stmt|;
comment|/* high port nbr */
name|u_short
name|vs_nbr
decl_stmt|;
comment|/* viocx number */
name|u_short
name|vs_maxcmd
decl_stmt|;
comment|/* max number of concurrent cmds */
name|u_short
name|vs_silosiz
decl_stmt|;
comment|/* silo size */
name|short
name|vs_vers
decl_stmt|;
comment|/* vioc/pvioc version */
define|#
directive|define
name|VXV_OLD
value|0
comment|/* PVIOCX | VIOCX */
define|#
directive|define
name|VXV_NEW
value|1
comment|/* NPVIOCX | NVIOCX */
name|short
name|vs_state
decl_stmt|;
comment|/* controller state */
define|#
directive|define
name|VXS_READY
value|0
comment|/* ready for commands */
define|#
directive|define
name|VXS_RESET
value|1
comment|/* in process of reseting */
name|u_short
name|vs_softCAR
decl_stmt|;
comment|/* soft carrier */
name|u_int
name|vs_ivec
decl_stmt|;
comment|/* interrupt vector base */
name|caddr_t
name|vs_mricmd
decl_stmt|;
comment|/* most recent issued cmd */
comment|/* The remaining fields are zeroed on reset... */
define|#
directive|define
name|vs_zero
value|vs_xmtcnt
name|int
name|vs_xmtcnt
decl_stmt|;
comment|/* xmit commands pending */
name|struct
name|vxcmd
modifier|*
name|vs_avail
decl_stmt|;
comment|/* next available command buffer */
name|struct
name|vxcmd
modifier|*
name|vs_build
decl_stmt|;
name|struct
name|vxcmd
name|vs_lst
index|[
name|NVCXBUFS
index|]
decl_stmt|;
name|struct
name|vcmds
name|vs_cmds
decl_stmt|;
block|}
name|vx_softc
index|[
name|NVX
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|speedtab
name|vxspeedtab
index|[]
init|=
block|{
name|EXTA
block|,
name|V19200
block|,
name|EXTB
block|,
name|V19200
block|,
literal|19200
block|,
name|V19200
block|,
literal|9600
block|,
literal|13
block|,
literal|4800
block|,
literal|12
block|,
literal|2400
block|,
literal|11
block|,
literal|1800
block|,
literal|10
block|,
literal|1200
block|,
literal|9
block|,
literal|600
block|,
literal|8
block|,
literal|300
block|,
literal|7
block|,
literal|200
block|,
literal|6
block|,
literal|150
block|,
literal|5
block|,
literal|134
block|,
literal|4
block|,
literal|110
block|,
literal|3
block|,
literal|75
block|,
literal|2
block|,
literal|50
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_macro
name|vxprobe
argument_list|(
argument|reg
argument_list|,
argument|vi
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* must be r12, r11 */
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|struct
name|pte
modifier|*
name|dummypte
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|vackint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vunsol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vcmdrsp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VX_DEBUG
name|vxfreset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* lint */
comment|/* 	 * If on an HCX-9, the device has a 32-bit address, 	 * and we receive that address so we can set up a map. 	 * On VERSAbus devices, the address is 24-bit, and is 	 * already mapped (into vmem[]) by autoconf. 	 */
if|if
condition|(
operator|!
operator|(
name|reg
operator|>=
name|vmem
operator|&&
name|reg
operator|<
operator|&
name|vmem
index|[
name|ctob
argument_list|(
name|VBIOSIZE
argument_list|)
index|]
operator|)
operator|&&
comment|/* XXX */
operator|!
name|vbmemalloc
argument_list|(
literal|16
argument_list|,
name|reg
argument_list|,
operator|&
name|dummypte
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: vbmemalloc failed.\n"
argument_list|,
name|vi
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|vp
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
name|reg
expr_stmt|;
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vp
operator|->
name|v_fault
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|v_vioc
operator|=
name|V_BSY
expr_stmt|;
name|vp
operator|->
name|v_hdwre
operator|=
name|V_RESET
expr_stmt|;
comment|/* reset interrupt */
name|DELAY
argument_list|(
literal|4000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_fault
operator|!=
name|VXF_READY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vi
operator|->
name|ui_unit
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * Align vioc interrupt vector base to 4 vector 	 * boundary and fitting in 8 bits (is this necessary, 	 * wish we had documentation). 	 */
if|if
condition|(
operator|(
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
operator|-=
literal|3
operator|)
operator|>
literal|0xff
condition|)
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
operator|=
literal|0xff
expr_stmt|;
name|vs
operator|->
name|vs_ivec
operator|=
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
operator|=
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
operator|&
operator|~
literal|0x3
expr_stmt|;
else|#
directive|else
name|vs
operator|->
name|vs_ivec
operator|=
literal|0x40
operator|+
name|vi
operator|->
name|ui_unit
operator|*
literal|4
expr_stmt|;
endif|#
directive|endif
name|br
operator|=
literal|0x18
operator|,
name|cvec
operator|=
name|vs
operator|->
name|vs_ivec
expr_stmt|;
comment|/* XXX */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|vxdevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|vxattach
argument_list|(
name|vi
argument_list|)
specifier|register
expr|struct
name|vba_device
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
init|=
operator|&
name|vx_softc
index|[
name|vi
operator|->
name|ui_unit
index|]
decl_stmt|;
name|vs
operator|->
name|vs_softCAR
operator|=
name|vi
operator|->
name|ui_flags
expr_stmt|;
name|vs
operator|->
name|vs_addr
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
name|vi
operator|->
name|ui_addr
expr_stmt|;
name|vxinit
argument_list|(
name|vi
operator|->
name|ui_unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Open a VX line.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|vxopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
comment|/* pointer to tty struct for port */
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|vx
decl_stmt|,
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|vxparam
parameter_list|()
function_decl|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vx
operator|=
name|VXUNIT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|vx
operator|>=
name|NVX
operator|||
operator|(
name|vi
operator|=
name|vxinfo
index|[
name|vx
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|unit
index|]
expr_stmt|;
name|unit
operator|=
name|VXPORT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|u
operator|.
name|u_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|unit
operator|<
name|vs
operator|->
name|vs_loport
operator|||
name|unit
operator|>
name|vs
operator|->
name|vs_hiport
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
name|vs
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|vxstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|vxparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
block|}
name|vxparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|vcmodem
argument_list|(
name|dev
argument_list|,
name|VMOD_ON
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
name|ttopen
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|error
operator|=
name|ttclosed
argument_list|(
name|tp
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Close a VX line.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|vxclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|unit
index|]
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|||
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
name|vcmodem
argument_list|(
name|dev
argument_list|,
name|VMOD_OFF
argument_list|)
expr_stmt|;
comment|/* wait for the last response */
while|while
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_state
argument_list|,
name|TTOPRI
operator||
name|PCATCH
argument_list|,
name|ttclos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|ttyclose
argument_list|(
name|tp
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Read from a VX line.  */
end_comment

begin_macro
name|vxread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|vx_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * write on a VX line  */
end_comment

begin_macro
name|vxwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|vx_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * VIOCX unsolicited interrupt.  */
end_comment

begin_expr_stmt
name|vxrint
argument_list|(
name|vx
argument_list|)
specifier|register
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tp0
decl_stmt|;
specifier|register
name|struct
name|vxdevice
modifier|*
name|addr
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
specifier|register
name|int
name|nc
decl_stmt|,
name|c
decl_stmt|;
specifier|register
struct|struct
name|silo
block|{
name|u_char
name|data
decl_stmt|,
name|port
decl_stmt|;
block|}
modifier|*
name|sp
struct|;
name|short
modifier|*
name|osp
decl_stmt|;
name|int
name|overrun
init|=
literal|0
decl_stmt|;
name|vi
operator|=
name|vxinfo
index|[
name|vx
index|]
expr_stmt|;
if|if
condition|(
name|vi
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return;
name|addr
operator|=
operator|(
expr|struct
name|vxdevice
operator|*
operator|)
name|vi
operator|->
name|ui_addr
expr_stmt|;
switch|switch
condition|(
name|addr
operator|->
name|v_uqual
operator|&
literal|037
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|addr
operator|->
name|v_ustat
operator|==
name|VP_SILO_OFLOW
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vx%d: input silo overflow\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"vx%d: vc proc err, ustat %x\n"
argument_list|,
name|vx
argument_list|,
name|addr
operator|->
name|v_ustat
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|3
case|:
name|vcmintr
argument_list|(
name|vx
argument_list|)
expr_stmt|;
return|return;
case|case
literal|4
case|:
return|return;
default|default:
name|printf
argument_list|(
literal|"vx%d: vc uqual err, uqual %x\n"
argument_list|,
name|vx
argument_list|,
name|addr
operator|->
name|v_uqual
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
return|return;
block|}
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
condition|)
name|sp
operator|=
operator|(
expr|struct
name|silo
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|addr
operator|+
operator|*
operator|(
name|short
operator|*
operator|)
name|addr
operator|->
name|v_usdata
operator|)
expr_stmt|;
else|else
name|sp
operator|=
operator|(
expr|struct
name|silo
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|addr
operator|+
name|VX_SILO
operator|+
operator|(
name|addr
operator|->
name|v_usdata
index|[
literal|0
index|]
operator|<<
literal|6
operator|)
operator|)
expr_stmt|;
name|nc
operator|=
operator|*
operator|(
name|osp
operator|=
operator|(
name|short
operator|*
operator|)
name|sp
operator|)
expr_stmt|;
if|if
condition|(
name|nc
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
operator|&&
name|nc
operator|>
name|vs
operator|->
name|vs_silosiz
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: %d exceeds silo size\n"
argument_list|,
name|nc
argument_list|)
expr_stmt|;
name|nc
operator|=
name|vs
operator|->
name|vs_silosiz
expr_stmt|;
block|}
name|tp0
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
index|]
expr_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|silo
operator|*
operator|)
operator|(
operator|(
operator|(
name|short
operator|*
operator|)
name|sp
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
init|;
name|nc
operator|>
literal|0
condition|;
name|nc
operator|--
operator|,
name|sp
operator|=
operator|(
expr|struct
name|silo
operator|*
operator|)
operator|(
operator|(
operator|(
name|short
operator|*
operator|)
name|sp
operator|)
operator|+
literal|1
operator|)
control|)
block|{
name|c
operator|=
name|sp
operator|->
name|port
operator|&
literal|017
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_loport
operator|>
name|c
operator|||
name|c
operator|>
name|vs
operator|->
name|vs_hiport
condition|)
continue|continue;
name|tp
operator|=
name|tp0
operator|+
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|sp
operator|->
name|data
operator|&
operator|(
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CSIZE
operator|)
operator|==
name|CS8
condition|?
literal|0xff
else|:
literal|0x7f
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|port
operator|&
name|VX_RO
operator|)
operator|==
name|VX_RO
operator|&&
operator|!
name|overrun
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vx%d: receiver overrun\n"
argument_list|,
name|vi
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
name|overrun
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|port
operator|&
name|VX_PE
condition|)
name|c
operator||=
name|TTY_PE
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|port
operator|&
name|VX_FE
condition|)
name|c
operator||=
name|TTY_FE
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|,
name|tp
operator|)
expr_stmt|;
block|}
operator|*
name|osp
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Ioctl for VX.  */
end_comment

begin_macro
name|vxioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_block

begin_macro
name|vxparam
argument_list|(
argument|tp
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|vxcparam
argument_list|(
name|tp
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Set parameters from open or stty into the VX hardware  * registers.  */
end_comment

begin_macro
name|vxcparam
argument_list|(
argument|tp
argument_list|,
argument|t
argument_list|,
argument|wait
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wait
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|speedcode
init|=
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
name|vxspeedtab
argument_list|)
decl_stmt|;
if|if
condition|(
name|speedcode
operator|<
literal|0
operator|||
operator|(
name|t
operator|->
name|c_ispeed
operator|!=
name|t
operator|->
name|c_ospeed
operator|&&
name|t
operator|->
name|c_ispeed
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vs
operator|=
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
name|cp
operator|=
name|vobtain
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
comment|/* 	 * Construct ``load parameters'' command block 	 * to setup baud rates, xon-xoff chars, parity, 	 * and stop bits for the specified port. 	 */
name|cp
operator|->
name|cmd
operator|=
name|VXC_LPARAX
expr_stmt|;
name|cp
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|VXPORT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * note: if the hardware does flow control, ^V doesn't work 	 * to escape ^S 	 */
if|if
condition|(
name|t
operator|->
name|c_iflag
operator|&
name|IXON
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
operator|==
name|_POSIX_VDISABLE
condition|)
name|cp
operator|->
name|par
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|cp
operator|->
name|par
index|[
literal|2
index|]
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
operator|==
name|_POSIX_VDISABLE
condition|)
name|cp
operator|->
name|par
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|cp
operator|->
name|par
index|[
literal|3
index|]
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
expr_stmt|;
block|}
else|else
name|cp
operator|->
name|par
index|[
literal|2
index|]
operator|=
name|cp
operator|->
name|par
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notnow
switch|switch
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|CSIZE
condition|)
block|{
comment|/* XXX */
case|case
name|CS8
case|:
endif|#
directive|endif
name|cp
operator|->
name|par
index|[
literal|4
index|]
operator|=
name|BITS8
expr_stmt|;
comment|/* 8 bits of data */
ifdef|#
directive|ifdef
name|notnow
break|break;
case|case
name|CS7
case|:
name|cp
operator|->
name|par
index|[
literal|4
index|]
operator|=
name|BITS7
expr_stmt|;
comment|/* 7 bits of data */
break|break;
case|case
name|CS6
case|:
name|cp
operator|->
name|par
index|[
literal|4
index|]
operator|=
name|BITS6
expr_stmt|;
comment|/* 6 bits of data */
break|break;
case|case
name|CS5
case|:
name|cp
operator|->
name|par
index|[
literal|4
index|]
operator|=
name|BITS5
expr_stmt|;
comment|/* 5 bits of data */
break|break;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|c_cflag
operator|&
name|PARENB
operator|)
operator|==
literal|0
condition|)
comment|/* XXX */
endif|#
directive|endif
name|cp
operator|->
name|par
index|[
literal|7
index|]
operator|=
name|VNOPARITY
expr_stmt|;
comment|/* no parity */
ifdef|#
directive|ifdef
name|notnow
elseif|else
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|PARODD
condition|)
name|cp
operator|->
name|par
index|[
literal|7
index|]
operator|=
name|VODDP
expr_stmt|;
comment|/* odd parity */
else|else
name|cp
operator|->
name|par
index|[
literal|7
index|]
operator|=
name|VEVENP
expr_stmt|;
comment|/* even parity */
endif|#
directive|endif
name|cp
operator|->
name|par
index|[
literal|5
index|]
operator|=
operator|(
name|t
operator|->
name|c_cflag
operator|&
name|CSTOPB
operator|)
condition|?
name|VSTOP2
else|:
name|VSTOP1
expr_stmt|;
name|cp
operator|->
name|par
index|[
literal|6
index|]
operator|=
name|speedcode
expr_stmt|;
if|if
condition|(
name|vcmd
argument_list|(
operator|(
name|int
operator|)
name|vs
operator|->
name|vs_nbr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
operator|&&
name|wait
condition|)
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
name|ttyout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|c_ospeed
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_cflag
operator||=
name|HUPCL
expr_stmt|;
name|vcmodem
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|,
name|VMOD_OFF
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * VIOCX command response interrupt.  * For transmission, restart output to any active port.  * For all other commands, just clean up.  */
end_comment

begin_expr_stmt
name|vxxint
argument_list|(
name|vx
argument_list|,
name|cp
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vxmit
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tp0
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
name|cp
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
operator|(
operator|(
name|long
operator|*
operator|)
name|cp
operator|-
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|cmd
operator|&
literal|0xff00
condition|)
block|{
case|case
name|VXC_LIDENT
case|:
comment|/* initialization complete */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VXS_RESET
condition|)
block|{
name|vxfnreset
argument_list|(
name|vx
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|vinthandl
argument_list|(
name|vx
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|RSPquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|cmd
operator|++
expr_stmt|;
return|return;
case|case
name|VXC_XMITDTA
case|:
case|case
name|VXC_XMITIMM
case|:
break|break;
case|case
name|VXC_LPARAX
case|:
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|)
expr_stmt|;
comment|/* fall thru... */
default|default:
comment|/* VXC_MDMCTL or VXC_FDTATOX */
name|vrelease
argument_list|(
name|vs
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VXS_RESET
condition|)
name|vinthandl
argument_list|(
name|vx
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|RSPquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
return|return;
block|}
name|tp0
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
index|]
expr_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vxmit
operator|*
operator|)
operator|(
name|cp
operator|->
name|par
operator|+
operator|(
name|cp
operator|->
name|cmd
operator|&
literal|07
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vxmit
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|vp
operator|>=
operator|(
expr|struct
name|vxmit
operator|*
operator|)
name|cp
operator|->
name|par
condition|;
name|vp
operator|--
control|)
block|{
name|tp
operator|=
name|tp0
operator|+
operator|(
name|vp
operator|->
name|line
operator|&
literal|017
operator|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_FLUSH
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
block|}
else|else
name|ndflush
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|vp
operator|->
name|bcount
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|vrelease
argument_list|(
name|vs
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
else|else
block|{
name|tp0
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
operator|+
name|vs
operator|->
name|vs_hiport
index|]
expr_stmt|;
for|for
control|(
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
operator|+
name|vs
operator|->
name|vs_loport
index|]
init|;
name|tp
operator|<=
name|tp0
condition|;
name|tp
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|nextcmd
argument_list|(
name|vs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* command to send? */
name|vs
operator|->
name|vs_xmtcnt
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
name|vx
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
name|vs
operator|->
name|vs_xmtcnt
operator|--
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Force out partial XMIT command after timeout  */
end_comment

begin_expr_stmt
name|vxforce
argument_list|(
name|vs
argument_list|)
specifier|register
expr|struct
name|vx_softc
operator|*
name|vs
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|nextcmd
argument_list|(
name|vs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|vs
operator|->
name|vs_xmtcnt
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
operator|(
name|int
operator|)
name|vs
operator|->
name|vs_nbr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start (restart) transmission on the given VX line.  */
end_comment

begin_expr_stmt
name|vxstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|short
name|n
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|int
name|s
decl_stmt|,
name|port
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|port
operator|=
name|VXPORT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|vs
operator|=
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_wsel
condition|)
block|{
name|selwakeup
argument_list|(
name|tp
operator|->
name|t_wsel
argument_list|,
name|tp
operator|->
name|t_state
operator|&
name|TS_WCOLL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_wsel
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_WCOLL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|scope_out
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_oflag
operator|&
name|OPOST
operator|)
condition|)
comment|/* XXX */
name|n
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|n
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0200
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|n
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ttrstrt
argument_list|,
operator|(
name|caddr_t
operator|)
name|tp
argument_list|,
operator|(
name|n
operator|&
literal|0177
operator|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_TIMEOUT
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|vsetq
argument_list|(
name|vs
argument_list|,
name|port
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tp
operator|->
name|t_outq
operator|.
name|c_cf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Stop output on a line.  */
end_comment

begin_expr_stmt
name|vxstop
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|vxbbno
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * VIOCX Initialization.  Makes free lists of command buffers.  * Resets all viocx's.  Issues a LIDENT command to each  * viocx to establish interrupt vectors and logical port numbers.  */
end_comment

begin_expr_stmt
name|vxinit
argument_list|(
name|vx
argument_list|,
name|wait
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|wait
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vxdevice
modifier|*
name|addr
decl_stmt|;
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|resp
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|char
name|type
decl_stmt|,
modifier|*
name|typestring
decl_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
name|addr
operator|=
name|vs
operator|->
name|vs_addr
expr_stmt|;
name|type
operator|=
name|addr
operator|->
name|v_ident
expr_stmt|;
name|vs
operator|->
name|vs_vers
operator|=
operator|(
name|type
operator|&
name|VXT_NEW
operator|)
condition|?
name|VXV_NEW
else|:
name|VXV_OLD
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
condition|)
name|vs
operator|->
name|vs_silosiz
operator|=
name|addr
operator|->
name|v_maxsilo
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|VXT_VIOCX
case|:
case|case
name|VXT_VIOCX
operator||
name|VXT_NEW
case|:
name|typestring
operator|=
literal|"VIOC-X"
expr_stmt|;
comment|/* set soft carrier for printer ports */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|vs
operator|->
name|vs_softCAR
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|||
name|addr
operator|->
name|v_portyp
index|[
name|j
index|]
operator|==
name|VXT_PARALLEL
condition|)
block|{
name|vs
operator|->
name|vs_softCAR
operator||=
literal|1
operator|<<
name|j
expr_stmt|;
name|addr
operator|->
name|v_dcd
operator||=
literal|1
operator|<<
name|j
expr_stmt|;
block|}
break|break;
case|case
name|VXT_PVIOCX
case|:
case|case
name|VXT_PVIOCX
operator||
name|VXT_NEW
case|:
name|typestring
operator|=
literal|"VIOC-X (old connector panel)"
expr_stmt|;
break|break;
case|case
name|VXT_VIOCBOP
case|:
comment|/* VIOC-BOP */
name|vs
operator|->
name|vs_type
operator|=
literal|1
expr_stmt|;
name|vs
operator|->
name|vs_bop
operator|=
operator|++
name|vxbbno
expr_stmt|;
name|printf
argument_list|(
literal|"VIOC-BOP no. %d at %x\n"
argument_list|,
name|vs
operator|->
name|vs_bop
argument_list|,
name|addr
argument_list|)
expr_stmt|;
goto|goto
name|unsup
goto|;
default|default:
name|printf
argument_list|(
literal|"vx%d: unknown type %x\n"
argument_list|,
name|vx
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|unsup
label|:
name|vxinfo
index|[
name|vx
index|]
operator|->
name|ui_alive
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|vs
operator|->
name|vs_nbr
operator|=
name|vx
expr_stmt|;
comment|/* assign board number */
name|vs
operator|->
name|vs_maxcmd
operator|=
operator|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
operator|)
condition|?
literal|24
else|:
literal|4
expr_stmt|;
comment|/* 	 * Initialize all cmd buffers by linking them 	 * into a free list. 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVCXBUFS
condition|;
name|j
operator|++
control|)
block|{
name|cp
operator|=
operator|&
name|vs
operator|->
name|vs_lst
index|[
name|j
index|]
expr_stmt|;
name|cp
operator|->
name|c_fwd
operator|=
operator|&
name|vs
operator|->
name|vs_lst
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|vs
operator|->
name|vs_avail
operator|=
operator|&
name|vs
operator|->
name|vs_lst
index|[
literal|0
index|]
expr_stmt|;
comment|/* set idx to 1st free buf */
name|cp
operator|->
name|c_fwd
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* mark last buf in free list */
comment|/* 	 * Establish the interrupt vectors and define the port numbers. 	 */
name|cp
operator|=
name|vobtain
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cmd
operator|=
name|VXC_LIDENT
expr_stmt|;
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|=
name|vs
operator|->
name|vs_ivec
expr_stmt|;
comment|/* ack vector */
name|cp
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
comment|/* cmd resp vector */
name|cp
operator|->
name|par
index|[
literal|3
index|]
operator|=
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
comment|/* unsol intr vector */
name|cp
operator|->
name|par
index|[
literal|4
index|]
operator|=
literal|15
expr_stmt|;
comment|/* max ports, no longer used */
name|cp
operator|->
name|par
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* set 1st port number */
operator|(
name|void
operator|)
name|vcmd
argument_list|(
name|vx
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wait
condition|)
return|return;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|cp
operator|->
name|cmd
operator|==
name|VXC_LIDENT
operator|&&
name|j
operator|<
literal|4000000
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|>=
literal|4000000
condition|)
name|printf
argument_list|(
literal|"vx%d: didn't respond to LIDENT\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
comment|/* calculate address of response buffer */
name|resp
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
operator|(
name|addr
operator|->
name|v_rspoff
operator|&
literal|0x3fff
operator|)
expr_stmt|;
if|if
condition|(
name|resp
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
operator|(
name|resp
index|[
literal|0
index|]
operator|&
literal|0177
operator|)
operator|!=
literal|3
condition|)
block|{
name|vrelease
argument_list|(
name|vs
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* init failed */
return|return;
block|}
name|vs
operator|->
name|vs_loport
operator|=
name|cp
operator|->
name|par
index|[
literal|5
index|]
expr_stmt|;
name|vs
operator|->
name|vs_hiport
operator|=
name|cp
operator|->
name|par
index|[
literal|7
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"vx%d: %s%s, ports %d-%d\n"
argument_list|,
name|vx
argument_list|,
operator|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
operator|)
condition|?
literal|""
else|:
literal|"old "
argument_list|,
name|typestring
argument_list|,
name|vs
operator|->
name|vs_loport
argument_list|,
name|vs
operator|->
name|vs_hiport
argument_list|)
expr_stmt|;
name|vrelease
argument_list|(
name|vs
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Obtain a command buffer  */
end_comment

begin_function
name|struct
name|vxcmd
modifier|*
name|vobtain
parameter_list|(
name|vs
parameter_list|)
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
block|{
specifier|register
name|struct
name|vxcmd
modifier|*
name|p
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|p
operator|=
name|vs
operator|->
name|vs_avail
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|VX_DEBUG
if|if
condition|(
name|vxintr4
operator|&
name|VXNOBUF
condition|)
name|vxintr4
operator|&=
operator|~
name|VXNOBUF
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"vx%d: no buffers\n"
argument_list|,
name|vs
operator|->
name|vs_nbr
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vs
operator|->
name|vs_nbr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|vobtain
argument_list|(
name|vs
argument_list|)
operator|)
return|;
block|}
name|vs
operator|->
name|vs_avail
operator|=
name|p
operator|->
name|c_fwd
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a command buffer  */
end_comment

begin_expr_stmt
name|vrelease
argument_list|(
name|vs
argument_list|,
name|cp
argument_list|)
specifier|register
expr|struct
name|vx_softc
operator|*
name|vs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|VX_DEBUG
if|if
condition|(
name|vxintr4
operator|&
name|VXNOBUF
condition|)
return|return;
endif|#
directive|endif
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|cp
operator|->
name|c_fwd
operator|=
name|vs
operator|->
name|vs_avail
expr_stmt|;
name|vs
operator|->
name|vs_avail
operator|=
name|cp
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|vxcmd
modifier|*
name|nextcmd
parameter_list|(
name|vs
parameter_list|)
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
block|{
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|cp
operator|=
name|vs
operator|->
name|vs_build
expr_stmt|;
name|vs
operator|->
name|vs_build
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Assemble transmits into a multiple command;  * up to 8 transmits to 8 lines can be assembled together  * (on PVIOCX only).  */
end_comment

begin_expr_stmt
name|vsetq
argument_list|(
name|vs
argument_list|,
name|line
argument_list|,
name|addr
argument_list|,
name|n
argument_list|)
specifier|register
expr|struct
name|vx_softc
operator|*
name|vs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|vxmit
modifier|*
name|mp
decl_stmt|;
comment|/* 	 * Grab a new command buffer or append 	 * to the current one being built. 	 */
name|cp
operator|=
name|vs
operator|->
name|vs_build
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
condition|)
block|{
name|cp
operator|=
name|vobtain
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_build
operator|=
name|cp
expr_stmt|;
name|cp
operator|->
name|cmd
operator|=
name|VXC_XMITDTA
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cp
operator|->
name|cmd
operator|&
literal|07
operator|)
operator|==
literal|07
operator|||
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: setq overflow\n"
argument_list|,
name|vs
operator|-
name|vx_softc
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
operator|(
name|int
operator|)
name|vs
operator|->
name|vs_nbr
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|->
name|cmd
operator|++
expr_stmt|;
block|}
comment|/* 	 * Select the next vxmit buffer and copy the 	 * characters into the buffer (if there's room 	 * and the device supports ``immediate mode'', 	 * or store an indirect pointer to the data. 	 */
name|mp
operator|=
operator|(
expr|struct
name|vxmit
operator|*
operator|)
operator|(
name|cp
operator|->
name|par
operator|+
operator|(
name|cp
operator|->
name|cmd
operator|&
literal|07
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vxmit
argument_list|)
operator|)
expr_stmt|;
name|mp
operator|->
name|bcount
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|mp
operator|->
name|line
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
operator|&&
name|n
operator|<=
sizeof|sizeof
argument_list|(
name|mp
operator|->
name|ostream
argument_list|)
condition|)
block|{
name|cp
operator|->
name|cmd
operator|=
name|VXC_XMITIMM
expr_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|mp
operator|->
name|ostream
argument_list|,
operator|(
name|unsigned
operator|)
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* get system address of clist block */
name|addr
operator|=
operator|(
name|caddr_t
operator|)
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|addr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|addr
argument_list|,
name|mp
operator|->
name|ostream
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We send the data immediately if a VIOCX, 	 * the command buffer is full, or if we've nothing 	 * currently outstanding.  If we don't send it, 	 * set a timeout to force the data to be sent soon. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
operator|||
operator|(
name|cp
operator|->
name|cmd
operator|&
literal|07
operator|)
operator|==
literal|7
operator|||
name|vs
operator|->
name|vs_xmtcnt
operator|==
literal|0
condition|)
block|{
name|vs
operator|->
name|vs_xmtcnt
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
operator|(
name|int
operator|)
name|vs
operator|->
name|vs_nbr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_build
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|timeout
argument_list|(
name|vxforce
argument_list|,
operator|(
name|caddr_t
operator|)
name|vs
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Write a command out to the VIOC  */
end_comment

begin_expr_stmt
name|vcmd
argument_list|(
name|vx
argument_list|,
name|cmdad
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|caddr_t
name|cmdad
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
init|=
operator|&
name|vx_softc
index|[
name|vx
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
comment|/* 	 * When the vioc is resetting, don't process 	 * anything other than VXC_LIDENT commands. 	 */
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VXS_RESET
operator|&&
name|cmdad
operator|!=
name|NULL
condition|)
block|{
name|struct
name|vxcmd
modifier|*
name|vcp
init|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
operator|(
name|cmdad
operator|-
sizeof|sizeof
argument_list|(
name|vcp
operator|->
name|c_fwd
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|vcp
operator|->
name|cmd
operator|!=
name|VXC_LIDENT
condition|)
block|{
name|vrelease
argument_list|(
name|vs
argument_list|,
name|vcp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|cp
operator|=
operator|&
name|vs
operator|->
name|vs_cmds
expr_stmt|;
if|if
condition|(
name|cmdad
operator|!=
operator|(
name|caddr_t
operator|)
literal|0
condition|)
block|{
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_fill
index|]
operator|=
name|cmdad
expr_stmt|;
if|if
condition|(
operator|++
name|cp
operator|->
name|v_fill
operator|>=
name|VC_CMDBUFL
condition|)
name|cp
operator|->
name|v_fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|v_fill
operator|==
name|cp
operator|->
name|v_empty
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: cmd q overflow\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cp
operator|->
name|v_cmdsem
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|v_cmdsem
operator|&&
name|cp
operator|->
name|v_curcnt
operator|<
name|vs
operator|->
name|vs_maxcmd
condition|)
block|{
name|cp
operator|->
name|v_cmdsem
operator|--
expr_stmt|;
name|cp
operator|->
name|v_curcnt
operator|++
expr_stmt|;
name|vinthandl
argument_list|(
name|vx
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|CMDquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * VIOC acknowledge interrupt.  The VIOC has received the new  * command.  If no errors, the new command becomes one of 16 (max)  * current commands being executed.  */
end_comment

begin_expr_stmt
name|vackint
argument_list|(
name|vx
argument_list|)
specifier|register
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|int
name|s
decl_stmt|;
name|scope_out
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_type
condition|)
comment|/* Its a BOP */
return|return;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|vp
operator|=
name|vs
operator|->
name|vs_addr
expr_stmt|;
name|cp
operator|=
operator|&
name|vs
operator|->
name|vs_cmds
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_vcid
operator|&
name|V_ERR
condition|)
block|{
specifier|register
name|char
modifier|*
name|resp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"vx%d: ackint error type %x v_dcd %x\n"
argument_list|,
name|vx
argument_list|,
name|vp
operator|->
name|v_vcid
operator|&
literal|07
argument_list|,
name|vp
operator|->
name|v_dcd
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|resp
operator|=
operator|(
name|char
operator|*
operator|)
name|vs
operator|->
name|vs_mricmd
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|resp
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|vp
operator|->
name|v_hdwre
operator|&
literal|017
operator|)
operator|==
name|CMDquals
condition|)
block|{
ifdef|#
directive|ifdef
name|VX_DEBUG
if|if
condition|(
name|vxintr4
operator|&
name|VXERR4
condition|)
block|{
comment|/* causes VIOC INTR ERR 4 */
name|struct
name|vxcmd
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp0
decl_stmt|;
name|cp0
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_empty
index|]
operator|-
sizeof|sizeof
argument_list|(
name|cp0
operator|->
name|c_fwd
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cp0
operator|->
name|cmd
operator|==
name|VXC_XMITDTA
operator|||
name|cp0
operator|->
name|cmd
operator|==
name|VXC_XMITIMM
condition|)
block|{
name|cp1
operator|=
name|vobtain
argument_list|(
name|vs
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|=
operator|*
name|cp0
expr_stmt|;
name|vxintr4
operator|&=
operator|~
name|VXERR4
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
name|vx
argument_list|,
operator|&
name|cp1
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|cp
operator|->
name|v_curcmd
index|[
name|vp
operator|->
name|v_vcid
operator|&
name|VCMDLEN
operator|-
literal|1
index|]
operator|=
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_empty
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|cp
operator|->
name|v_empty
operator|>=
name|VC_CMDBUFL
condition|)
name|cp
operator|->
name|v_empty
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|cp
operator|->
name|v_itrempt
operator|>=
name|VC_IQLEN
condition|)
name|cp
operator|->
name|v_itrempt
operator|=
literal|0
expr_stmt|;
name|vintempt
argument_list|(
name|vx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
name|vx
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* queue next cmd, if any */
block|}
end_block

begin_comment
comment|/*  * Command Response interrupt.  The Vioc has completed  * a command.  The command may now be returned to  * the appropriate device driver.  */
end_comment

begin_expr_stmt
name|vcmdrsp
argument_list|(
name|vx
argument_list|)
specifier|register
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
specifier|register
name|caddr_t
name|cmd
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|char
modifier|*
name|resp
decl_stmt|;
specifier|register
name|k
expr_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|scope_out
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_type
condition|)
block|{
comment|/* Its a BOP */
name|printf
argument_list|(
literal|"vx%d: vcmdrsp interrupt\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|vp
operator|=
name|vs
operator|->
name|vs_addr
expr_stmt|;
name|cp
operator|=
operator|&
name|vs
operator|->
name|vs_cmds
expr_stmt|;
name|resp
operator|=
operator|(
name|char
operator|*
operator|)
name|vp
operator|+
operator|(
name|vp
operator|->
name|v_rspoff
operator|&
literal|0x7fff
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|k
operator|=
name|resp
index|[
literal|1
index|]
operator|)
operator|&
name|V_UNBSY
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: cmdresp debug\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
return|return;
block|}
name|k
operator|&=
name|VCMDLEN
operator|-
literal|1
expr_stmt|;
name|cmd
operator|=
name|cp
operator|->
name|v_curcmd
index|[
name|k
index|]
expr_stmt|;
name|cp
operator|->
name|v_curcmd
index|[
name|k
index|]
operator|=
operator|(
name|caddr_t
operator|)
literal|0
expr_stmt|;
name|cp
operator|->
name|v_curcnt
operator|--
expr_stmt|;
name|k
operator|=
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|&
name|resp
index|[
literal|4
index|]
operator|)
expr_stmt|;
comment|/* cmd operation code */
if|if
condition|(
operator|(
name|k
operator|&
literal|0xff00
operator|)
operator|==
name|VXC_LIDENT
condition|)
comment|/* want hiport number */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|VRESPLEN
condition|;
name|k
operator|++
control|)
name|cmd
index|[
name|k
index|]
operator|=
name|resp
index|[
name|k
operator|+
literal|4
index|]
expr_stmt|;
name|resp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|vxxint
argument_list|(
name|vx
argument_list|,
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VXS_READY
condition|)
name|vinthandl
argument_list|(
name|vx
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|RSPquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Unsolicited interrupt.  */
end_comment

begin_expr_stmt
name|vunsol
argument_list|(
name|vx
argument_list|)
specifier|register
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|int
name|s
decl_stmt|;
name|scope_out
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_type
condition|)
block|{
comment|/* Its a BOP */
name|printf
argument_list|(
literal|"vx%d: vunsol from BOP\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|vp
operator|=
name|vs
operator|->
name|vs_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_uqual
operator|&
name|V_UNBSY
condition|)
block|{
name|vxrint
argument_list|(
name|vx
argument_list|)
expr_stmt|;
name|vinthandl
argument_list|(
name|vx
argument_list|,
operator|(
operator|(
name|V_BSY
operator||
name|UNSquals
operator|)
operator|<<
literal|8
operator|)
operator||
name|V_INTR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
block|}
else|else
block|{
name|printf
argument_list|(
literal|"vx%d: unsolicited interrupt error\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Enqueue an interrupt.  */
end_comment

begin_expr_stmt
name|vinthandl
argument_list|(
name|vx
argument_list|,
name|item
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|item
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|cp
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
operator|.
name|vs_cmds
expr_stmt|;
name|empty
operator|=
operator|(
name|cp
operator|->
name|v_itrfill
operator|==
name|cp
operator|->
name|v_itrempt
operator|)
expr_stmt|;
name|cp
operator|->
name|v_itrqueu
index|[
name|cp
operator|->
name|v_itrfill
index|]
operator|=
name|item
expr_stmt|;
if|if
condition|(
operator|++
name|cp
operator|->
name|v_itrfill
operator|>=
name|VC_IQLEN
condition|)
name|cp
operator|->
name|v_itrfill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|v_itrfill
operator|==
name|cp
operator|->
name|v_itrempt
condition|)
block|{
name|printf
argument_list|(
literal|"vx%d: interrupt q overflow\n"
argument_list|,
name|vx
argument_list|)
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|empty
condition|)
name|vintempt
argument_list|(
name|vx
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vintempt
argument_list|(
argument|vx
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vx
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|short
name|item
decl_stmt|;
specifier|register
name|short
modifier|*
name|intr
decl_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
name|vp
operator|=
name|vs
operator|->
name|vs_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_vioc
operator|&
name|V_BSY
condition|)
return|return;
name|cp
operator|=
operator|&
name|vs
operator|->
name|vs_cmds
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|v_itrempt
operator|==
name|cp
operator|->
name|v_itrfill
condition|)
return|return;
name|item
operator|=
name|cp
operator|->
name|v_itrqueu
index|[
name|cp
operator|->
name|v_itrempt
index|]
expr_stmt|;
name|intr
operator|=
operator|(
name|short
operator|*
operator|)
operator|&
name|vp
operator|->
name|v_vioc
expr_stmt|;
switch|switch
condition|(
operator|(
name|item
operator|>>
literal|8
operator|)
operator|&
literal|03
condition|)
block|{
case|case
name|CMDquals
case|:
block|{
comment|/* command */
name|int
name|phys
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|v_empty
operator|==
name|cp
operator|->
name|v_fill
operator|||
name|vp
operator|->
name|v_vcbsy
operator|&
name|V_BSY
condition|)
break|break;
name|vs
operator|->
name|vs_mricmd
operator|=
operator|(
name|caddr_t
operator|)
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_empty
index|]
expr_stmt|;
name|phys
operator|=
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|cp
operator|->
name|cmdbuf
index|[
name|cp
operator|->
name|v_empty
index|]
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vcp
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|short
operator|*
operator|)
operator|&
name|phys
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|vp
operator|->
name|v_vcp
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|short
operator|*
operator|)
operator|&
name|phys
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|vp
operator|->
name|v_vcbsy
operator|=
name|V_BSY
expr_stmt|;
operator|*
name|intr
operator|=
name|item
expr_stmt|;
name|scope_out
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RSPquals
case|:
comment|/* command response */
operator|*
name|intr
operator|=
name|item
expr_stmt|;
name|scope_out
argument_list|(
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSquals
case|:
comment|/* unsolicited interrupt */
name|vp
operator|->
name|v_uqual
operator|=
literal|0
expr_stmt|;
operator|*
name|intr
operator|=
name|item
expr_stmt|;
name|scope_out
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * Start a reset on a vioc after error (hopefully)  */
end_comment

begin_expr_stmt
name|vxstreset
argument_list|(
name|vx
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|extern
name|int
name|vxinreset
parameter_list|()
function_decl|;
name|int
name|s
decl_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|==
name|VXS_RESET
condition|)
block|{
comment|/* avoid recursion */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|vp
operator|=
name|vs
operator|->
name|vs_addr
expr_stmt|;
comment|/* 	 * Zero out the vioc structures, mark the vioc as being 	 * reset, reinitialize the free command list, reset the vioc 	 * and start a timer to check on the progress of the reset. 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vs
operator|->
name|vs_zero
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|vs
operator|+
literal|1
argument_list|)
operator|-
operator|(
name|caddr_t
operator|)
operator|&
name|vs
operator|->
name|vs_zero
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Setting VXS_RESET prevents others from issuing 	 * commands while allowing currently queued commands to 	 * be passed to the VIOC. 	 */
name|vs
operator|->
name|vs_state
operator|=
name|VXS_RESET
expr_stmt|;
comment|/* init all cmd buffers */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NVCXBUFS
condition|;
name|j
operator|++
control|)
block|{
name|cp
operator|=
operator|&
name|vs
operator|->
name|vs_lst
index|[
name|j
index|]
expr_stmt|;
name|cp
operator|->
name|c_fwd
operator|=
operator|&
name|vs
operator|->
name|vs_lst
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|vs
operator|->
name|vs_avail
operator|=
operator|&
name|vs
operator|->
name|vs_lst
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|->
name|c_fwd
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"vx%d: reset..."
argument_list|,
name|vx
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_fault
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|v_vioc
operator|=
name|V_BSY
expr_stmt|;
name|vp
operator|->
name|v_hdwre
operator|=
name|V_RESET
expr_stmt|;
comment|/* generate reset interrupt */
name|timeout
argument_list|(
name|vxinreset
argument_list|,
operator|(
name|caddr_t
operator|)
name|vx
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* continue processing a reset on a vioc after an error (hopefully) */
end_comment

begin_macro
name|vxinreset
argument_list|(
argument|vx
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vx
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
name|int
name|s
init|=
name|spl8
argument_list|()
decl_stmt|;
name|vp
operator|=
name|vx_softc
index|[
name|vx
index|]
operator|.
name|vs_addr
expr_stmt|;
comment|/* 	 * See if the vioc has reset. 	 */
if|if
condition|(
name|vp
operator|->
name|v_fault
operator|!=
name|VXF_READY
condition|)
block|{
name|printf
argument_list|(
literal|" vxreset failed\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Send a LIDENT to the vioc and mess with carrier flags 	 * on parallel printer ports. 	 */
name|vxinit
argument_list|(
name|vx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Finish the reset on the vioc after an error (hopefully).  *  * Restore modem control, parameters and restart output.  * Since the vioc can handle no more then 24 commands at a time  * and we could generate as many as 48 commands, we must do this in  * phases, issuing no more then 16 commands at a time.  */
end_comment

begin_expr_stmt
name|vxfnreset
argument_list|(
name|vx
argument_list|,
name|cp
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vxdevice
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tp0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
specifier|register
name|int
name|on
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|int
name|vxrestart
parameter_list|()
function_decl|;
name|int
name|s
init|=
name|spl8
argument_list|()
decl_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
name|vrelease
argument_list|(
name|vs
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_state
operator|=
name|VXS_READY
expr_stmt|;
name|vp
operator|=
name|vs
operator|->
name|vs_addr
expr_stmt|;
name|vp
operator|->
name|v_vcid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Restore modem information and control. 	 */
name|tp0
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|vs
operator|->
name|vs_loport
init|;
name|i
operator|<=
name|vs
operator|->
name|vs_hiport
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|tp0
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_ISOPEN
operator||
name|TS_WOPEN
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CARR_ON
expr_stmt|;
name|vcmodem
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|,
name|VMOD_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* 		 * If carrier has changed while we were resetting, 		 * take appropriate action. 		 */
name|on
operator|=
name|vp
operator|->
name|v_dcd
operator|&
literal|1
operator|<<
name|i
expr_stmt|;
if|if
condition|(
name|on
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|on
operator|&&
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|vs
operator|->
name|vs_state
operator|=
name|VXS_RESET
expr_stmt|;
name|timeout
argument_list|(
name|vxrestart
argument_list|,
operator|(
name|caddr_t
operator|)
name|vx
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Restore a particular aspect of the VIOC.  */
end_comment

begin_macro
name|vxrestart
argument_list|(
argument|vx
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vx
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tp0
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|int
name|s
init|=
name|spl8
argument_list|()
decl_stmt|;
name|count
operator|=
name|vx
operator|>>
literal|8
expr_stmt|;
name|vx
operator|&=
literal|0xff
expr_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
name|vs
operator|->
name|vs_state
operator|=
name|VXS_READY
expr_stmt|;
name|tp0
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|vs
operator|->
name|vs_loport
init|;
name|i
operator|<=
name|vs
operator|->
name|vs_hiport
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|tp0
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_BUSY
operator||
name|TS_TIMEOUT
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_ISOPEN
operator||
name|TS_WOPEN
operator|)
condition|)
name|vxstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* restart pending output */
block|}
else|else
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_WOPEN
operator||
name|TS_ISOPEN
operator|)
condition|)
name|vxcparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|vs
operator|->
name|vs_state
operator|=
name|VXS_RESET
expr_stmt|;
name|timeout
argument_list|(
name|vxrestart
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|vx
operator|+
literal|1
operator|*
literal|256
argument_list|)
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|" vx reset done\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vxreset
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|vxstreset
argument_list|(
operator|(
name|int
operator|)
name|VXUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* completes asynchronously */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|VX_DEBUG
end_ifdef

begin_expr_stmt
name|vxfreset
argument_list|(
name|vx
argument_list|)
specifier|register
name|int
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|vx
operator|>
name|NVX
operator|||
operator|(
name|vi
operator|=
name|vxinfo
index|[
name|vx
index|]
operator|)
operator|==
literal|0
operator|||
name|vi
operator|->
name|ui_addr
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|vx_softc
index|[
name|vx
index|]
operator|.
name|vs_state
operator|=
name|VXS_READY
expr_stmt|;
name|vxstreset
argument_list|(
name|vx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* completes asynchronously */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|vcmodem
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|vxcmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
specifier|register
name|struct
name|vxdevice
modifier|*
name|kp
decl_stmt|;
specifier|register
name|port
expr_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|unit
index|]
expr_stmt|;
name|vs
operator|=
operator|(
expr|struct
name|vx_softc
operator|*
operator|)
name|tp
operator|->
name|t_addr
expr_stmt|;
if|if
condition|(
name|vs
operator|->
name|vs_state
operator|!=
name|VXS_READY
condition|)
return|return;
name|cp
operator|=
name|vobtain
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|kp
operator|=
name|vs
operator|->
name|vs_addr
expr_stmt|;
name|port
operator|=
name|VXPORT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* 	 * Issue MODEM command 	 */
name|cp
operator|->
name|cmd
operator|=
name|VXC_MDMCTL
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|VMOD_ON
condition|)
block|{
if|if
condition|(
name|vs
operator|->
name|vs_softCAR
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
condition|)
block|{
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|=
name|V_MANUAL
operator||
name|V_DTR_ON
operator||
name|V_RTS
expr_stmt|;
name|kp
operator|->
name|v_dcd
operator||=
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
block|}
else|else
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|=
name|V_AUTO
operator||
name|V_DTR_ON
expr_stmt|;
block|}
else|else
name|cp
operator|->
name|par
index|[
literal|0
index|]
operator|=
name|V_DTR_OFF
expr_stmt|;
name|cp
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|port
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
operator|(
name|int
operator|)
name|vs
operator|->
name|vs_nbr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cp
operator|->
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kp
operator|->
name|v_dcd
operator||
name|vs
operator|->
name|vs_softCAR
operator|)
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
operator|&&
name|flag
operator|==
name|VMOD_ON
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * VCMINTR called when an unsolicited interrupt occurs signaling  * some change of modem control state.  */
end_comment

begin_expr_stmt
name|vcmintr
argument_list|(
name|vx
argument_list|)
specifier|register
name|vx
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|vxdevice
modifier|*
name|kp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|port
expr_stmt|;
specifier|register
name|struct
name|vx_softc
modifier|*
name|vs
decl_stmt|;
name|vs
operator|=
operator|&
name|vx_softc
index|[
name|vx
index|]
expr_stmt|;
name|kp
operator|=
name|vs
operator|->
name|vs_addr
expr_stmt|;
name|port
operator|=
name|kp
operator|->
name|v_usdata
index|[
literal|0
index|]
operator|&
literal|017
expr_stmt|;
name|tp
operator|=
operator|&
name|vx_tty
index|[
name|vx
operator|*
literal|16
operator|+
name|port
index|]
expr_stmt|;
if|if
condition|(
name|kp
operator|->
name|v_ustat
operator|&
name|DCD_ON
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|kp
operator|->
name|v_ustat
operator|&
name|DCD_OFF
operator|)
operator|&&
operator|(
operator|(
name|vs
operator|->
name|vs_softCAR
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|vcmds
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|vxcmd
modifier|*
name|cmdp
decl_stmt|;
comment|/* clear all pending transmits */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_BUSY
operator||
name|TS_FLUSH
operator|)
operator|&&
name|vs
operator|->
name|vs_vers
operator|==
name|VXV_NEW
condition|)
block|{
name|int
name|i
decl_stmt|,
name|cmdfound
init|=
literal|0
decl_stmt|;
name|cp
operator|=
operator|&
name|vs
operator|->
name|vs_cmds
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cp
operator|->
name|v_empty
init|;
name|i
operator|!=
name|cp
operator|->
name|v_fill
condition|;
control|)
block|{
name|cmdp
operator|=
operator|(
expr|struct
name|vxcmd
operator|*
operator|)
operator|(
operator|(
name|long
operator|*
operator|)
name|cp
operator|->
name|cmdbuf
index|[
name|i
index|]
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmdp
operator|->
name|cmd
operator|==
name|VXC_XMITDTA
operator|||
name|cmdp
operator|->
name|cmd
operator|==
name|VXC_XMITIMM
operator|)
operator|&&
operator|(
operator|(
expr|struct
name|vxmit
operator|*
operator|)
name|cmdp
operator|->
name|par
operator|)
operator|->
name|line
operator|==
name|port
condition|)
block|{
name|cmdfound
operator|++
expr_stmt|;
name|cmdp
operator|->
name|cmd
operator|=
name|VXC_FDTATOX
expr_stmt|;
name|cmdp
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|port
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|>=
name|VC_CMDBUFL
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cmdfound
condition|)
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_BUSY
operator||
name|TS_FLUSH
operator|)
expr_stmt|;
comment|/* cmd is already in vioc, have to flush it */
else|else
block|{
name|cmdp
operator|=
name|vobtain
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|cmdp
operator|->
name|cmd
operator|=
name|VXC_FDTATOX
expr_stmt|;
name|cmdp
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|port
expr_stmt|;
operator|(
name|void
operator|)
name|vcmd
argument_list|(
name|vx
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cmdp
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|kp
operator|->
name|v_ustat
operator|&
name|BRK_CHR
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|TTY_FE
operator|,
name|tp
operator|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

