begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	dr.c	1.1	86/07/20	*/
end_comment

begin_include
include|#
directive|include
file|"dr.h"
end_include

begin_if
if|#
directive|if
name|NDR
operator|>
literal|0
end_if

begin_comment
comment|/*      DRV11-W DMA interface driver.  */
end_comment

begin_include
include|#
directive|include
file|"../machine/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/drreg.h"
end_include

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|drinfo
index|[
name|NDR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dr_aux
name|dr_aux
index|[
name|NDR
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|caddr_t
name|vtoph
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|drminphys
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|drprobe
argument_list|()
decl_stmt|,
name|drintr
argument_list|()
decl_stmt|,
name|drattach
argument_list|()
decl_stmt|,
name|drtime
argument_list|()
decl_stmt|,
name|drrwtimo
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|drstrategy
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|vba_device
modifier|*
name|drinfo
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|drstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|drdriver
init|=
block|{
name|drprobe
block|,
literal|0
block|,
name|drattach
block|,
literal|0
block|,
name|drstd
block|,
literal|"rs"
block|,
name|drinfo
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|hz
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RSUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 7)
end_define

begin_define
define|#
directive|define
name|SPL_UP
value|spl5
end_define

begin_comment
comment|/* -------- Per-unit data -------- */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|dr_aux
name|dr_aux
index|[]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|rs_data
block|{
name|struct
name|buf
name|rs_buf
decl_stmt|;
name|int
name|rs_ubainfo
decl_stmt|;
name|short
name|rs_debug
decl_stmt|;
name|short
name|rs_busy
decl_stmt|;
name|short
name|rs_tout
decl_stmt|;
name|short
name|rs_uid
decl_stmt|;
name|short
name|rs_isopen
decl_stmt|;
name|short
name|rs_func
decl_stmt|;
block|}
name|rs_data
index|[
name|NDR
index|]
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|DR_DEBUG
end_ifdef

begin_decl_stmt
name|long
name|DR11
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|drprobe
argument_list|(
argument|reg
argument_list|,
argument|vi
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* must be r12, r11 */
specifier|register
name|struct
name|rsdevice
modifier|*
name|dr
decl_stmt|;
specifier|register
name|ushort
name|status
decl_stmt|;
name|dr
operator|=
operator|(
expr|struct
name|rsdevice
operator|*
operator|)
name|reg
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|dr
operator|->
name|dr_intvec
operator|=
operator|--
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
expr_stmt|;
else|#
directive|else
name|dr
operator|->
name|dr_intvec
operator|=
name|DRINTV
operator|+
name|vi
operator|->
name|ui_unit
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DR_DEBUG
name|printf
argument_list|(
literal|"dprobe: Set interrupt vector %lx and init\n"
argument_list|,
name|dr
operator|->
name|dr_intvec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* generate interrupt here for autoconfig */
name|dr
operator|->
name|dr_cstat
operator|=
name|MCLR
expr_stmt|;
comment|/* init board and device */
name|status
operator|=
name|dr
operator|->
name|dr_cstat
expr_stmt|;
comment|/* read initial status */
ifdef|#
directive|ifdef
name|DR_DEBUG
name|printf
argument_list|(
literal|"drprobe: Initial status %lx\n"
argument_list|,
name|status
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|br
operator|=
literal|0x18
operator|,
name|cvec
operator|=
name|dr
operator|->
name|dr_intvec
expr_stmt|;
comment|/* XXX */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|rsdevice
argument_list|)
operator|)
return|;
comment|/* DR11 exist */
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|drattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dr_aux
modifier|*
name|rsd
decl_stmt|;
name|rsd
operator|=
operator|&
name|dr_aux
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
name|rsd
operator|->
name|dr_flags
operator|=
name|DR_PRES
expr_stmt|;
comment|/* This dr11 is present */
name|rsd
operator|->
name|dr_addr
operator|=
operator|(
expr|struct
name|rsdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
comment|/* Save addr of this dr11 */
name|rsd
operator|->
name|dr_istat
operator|=
literal|0
expr_stmt|;
name|rsd
operator|->
name|dr_bycnt
operator|=
literal|0
expr_stmt|;
name|rsd
operator|->
name|dr_cmd
operator|=
literal|0
expr_stmt|;
name|rsd
operator|->
name|currenttimo
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|dropen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rsdevice
modifier|*
name|dr
decl_stmt|;
specifier|register
name|struct
name|dr_aux
modifier|*
name|rsd
decl_stmt|;
if|if
condition|(
operator|(
name|drinfo
index|[
name|unit
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
operator|!
name|drinfo
index|[
name|unit
index|]
operator|->
name|ui_alive
operator|)
condition|)
return|return
name|ENXIO
return|;
name|dr
operator|=
name|RSADDR
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|rsd
operator|=
operator|&
name|dr_aux
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|rsd
operator|->
name|dr_flags
operator|&
name|DR_OPEN
condition|)
block|{
ifdef|#
directive|ifdef
name|DR_DEBUG
name|printf
argument_list|(
literal|"\ndropen: dr11 unit %ld already open"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ENXIO
return|;
comment|/* DR11 already open */
block|}
name|rsd
operator|->
name|dr_flags
operator||=
name|DR_OPEN
expr_stmt|;
comment|/* Mark it OPEN */
name|rsd
operator|->
name|dr_istat
operator|=
literal|0
expr_stmt|;
comment|/* Clear status of previous interrupt */
name|rsd
operator|->
name|rtimoticks
operator|=
name|hz
expr_stmt|;
comment|/* Set read no stall timout to 1 sec */
name|rsd
operator|->
name|wtimoticks
operator|=
name|hz
operator|*
literal|60
expr_stmt|;
comment|/* Set write no stall timout to 1 min */
name|dr
operator|->
name|dr_cstat
operator|=
name|DR_ZERO
expr_stmt|;
comment|/* Clear function& latches */
name|dr
operator|->
name|dr_pulse
operator|=
operator|(
name|RDMA
operator||
name|RATN
operator|)
expr_stmt|;
comment|/* clear leftover attn& e-o-r flags */
name|drtimo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* start the self kicker */
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|drclose
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
specifier|register
name|struct
name|rsdevice
modifier|*
name|rs
decl_stmt|;
specifier|register
name|short
name|s
decl_stmt|;
name|dra
operator|=
operator|&
name|dr_aux
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_OPEN
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DR_DEBUG
name|printf
argument_list|(
literal|"\ndrclose: DR11 device %ld not open"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
operator|(
name|DR_OPEN
operator||
name|DR_ACTV
operator|)
expr_stmt|;
name|rs
operator|=
name|dra
operator|->
name|dr_addr
expr_stmt|;
name|s
operator|=
name|SPL_UP
argument_list|()
expr_stmt|;
name|rs
operator|->
name|dr_cstat
operator|=
name|DR_ZERO
expr_stmt|;
if|if
condition|(
name|dra
operator|->
name|dr_buf
operator|.
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
name|dra
operator|->
name|dr_buf
operator|.
name|b_flags
operator|&=
operator|~
name|B_BUSY
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|dra
operator|->
name|dr_buf
operator|.
name|b_flags
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*	drread() works exactly like drwrite() except that the 	B_READ flag is used when physio() is called */
end_comment

begin_macro
name|drread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|long
name|spl
decl_stmt|,
name|err
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<=
literal|0
comment|/* Negative count */
operator|||
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|&
literal|1
comment|/* odd count */
operator|||
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|&
literal|1
comment|/* odd destination address */
condition|)
return|return
name|EINVAL
return|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"\ndrread: (len:%ld)(base:%lx)"
argument_list|,
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
argument_list|,
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dra
operator|=
operator|&
name|dr_aux
index|[
name|RSUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|dra
operator|->
name|dr_op
operator|=
name|DR_READ
expr_stmt|;
name|bp
operator|=
operator|&
name|dra
operator|->
name|dr_buf
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_NORSTALL
condition|)
block|{
comment|/* We are in no stall mode, start the timer, raise IPL so nothing 	   can stop us once the timer's running */
name|spl
operator|=
name|SPL_UP
argument_list|()
expr_stmt|;
name|timeout
argument_list|(
name|drrwtimo
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|dra
operator|->
name|currenttimo
operator|<<
literal|8
operator|)
operator||
name|unit
argument_list|)
argument_list|,
name|dra
operator|->
name|rtimoticks
argument_list|)
expr_stmt|;
name|err
operator|=
name|physio
argument_list|(
name|drstrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|drminphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dra
operator|->
name|currenttimo
operator|++
expr_stmt|;
comment|/* Update current timeout number */
comment|/* Did we timeout */
if|if
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_TMDM
condition|)
block|{
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_TMDM
expr_stmt|;
comment|/* Clear timeout flag */
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
comment|/* Made the error ourself, ignore it */
block|}
block|}
else|else
block|{
return|return
name|physio
argument_list|(
name|drstrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|drminphys
argument_list|,
name|uio
argument_list|)
return|;
block|}
block|}
end_block

begin_macro
name|drwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|long
name|spl
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<=
literal|0
operator|||
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|&
literal|1
operator|||
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|&
literal|1
condition|)
return|return
name|EINVAL
return|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"\ndrwrite: (len:%ld)(base:%lx)"
argument_list|,
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
argument_list|,
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dra
operator|=
operator|&
name|dr_aux
index|[
name|RSUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|dra
operator|->
name|dr_op
operator|=
name|DR_WRITE
expr_stmt|;
name|bp
operator|=
operator|&
name|dra
operator|->
name|dr_buf
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_NOWSTALL
condition|)
block|{
comment|/* We are in no stall mode, start the timer, raise IPL so nothing 	   can stop us once the timer's running */
name|spl
operator|=
name|SPL_UP
argument_list|()
expr_stmt|;
name|timeout
argument_list|(
name|drrwtimo
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|dra
operator|->
name|currenttimo
operator|<<
literal|8
operator|)
operator||
name|unit
argument_list|)
argument_list|,
name|dra
operator|->
name|wtimoticks
argument_list|)
expr_stmt|;
name|err
operator|=
name|physio
argument_list|(
name|drstrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|drminphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dra
operator|->
name|currenttimo
operator|++
expr_stmt|;
comment|/* Update current timeout number */
comment|/* Did we timeout */
if|if
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_TMDM
condition|)
block|{
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_TMDM
expr_stmt|;
comment|/* Clear timeout flag */
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
comment|/* Made the error ourself, ignore it */
block|}
block|}
else|else
block|{
return|return
name|physio
argument_list|(
name|drstrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|drminphys
argument_list|,
name|uio
argument_list|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  Routine used by calling program to issue commands to dr11 driver and      through it to the device.     It is also used to read status from the device and driver and to wait      for attention interrupts.     Status is returned in an 8 elements unsigned short integer array, the      first two elements of the array are also used to pass arguments to      drioctl() if required.     The function bits to be written to the dr11 are included in the cmd     argument. Even if they are not being written to the dr11 in a particular     drioctl() call, they will update the copy of cmd that is stored in the     driver. When drstrategy() is called, this updated copy is used if a      deferred function bit write has been specified. The "side effect" of     calls to the drioctl() requires that the last call prior to a read or     write has an appropriate copy of the function bits in cmd if they are     to be used in drstrategy().     When used as command value, the contents of data[0] is the command     parameter. */
end_comment

begin_macro
name|drioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
specifier|register
name|struct
name|rsdevice
modifier|*
name|rsaddr
init|=
name|RSADDR
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|struct
name|dr11io
name|dio
decl_stmt|;
name|ushort
name|s
decl_stmt|,
name|errcode
decl_stmt|,
name|status
decl_stmt|;
name|long
name|temp
decl_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|0x10
condition|)
name|printf
argument_list|(
literal|"\ndrioctl: (dev:%lx)(cmd:%lx)(data:%lx)(data[0]:%lx)"
argument_list|,
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dra
operator|=
operator|&
name|dr_aux
index|[
name|unit
index|]
expr_stmt|;
name|dra
operator|->
name|dr_cmd
operator|=
literal|0
expr_stmt|;
comment|/* Fresh copy; clear all previous flags */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DRWAIT
case|:
comment|/* Wait for attention interrupt */
ifdef|#
directive|ifdef
name|DR_DEBUG
name|printf
argument_list|(
literal|"\ndrioctl: wait for attention interrupt"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|SPL_UP
argument_list|()
expr_stmt|;
comment|/* If the attention flag in dr_flags is set, it probably means that 	   an attention has arrived by the time a previous DMA end-of-range 	   interrupt was serviced. If ATRX is set, we will return with out 	   sleeping, since we have received an attention since the last call 	   to wait on attention. 	   This may not be appropriate for some applications. 	*/
if|if
condition|(
operator|!
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_ATRX
operator|)
condition|)
block|{
name|dra
operator|->
name|dr_flags
operator||=
name|DR_ATWT
expr_stmt|;
comment|/* Set waiting flag */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|IENB
expr_stmt|;
comment|/* Enable interrupt; use pulse 						   reg. so function bits are 						   not changed */
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dra
operator|->
name|dr_cmd
argument_list|,
name|DRPRI
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRPIOW
case|:
comment|/* Write to p-i/o register */
name|rsaddr
operator|->
name|dr_data
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|DRPACL
case|:
comment|/* Send pulse to device */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|FCN2
expr_stmt|;
break|break;
case|case
name|DRDACL
case|:
comment|/* Defer alco pulse until go */
name|dra
operator|->
name|dr_cmd
operator||=
name|DR_DACL
expr_stmt|;
break|break;
case|case
name|DRPCYL
case|:
comment|/* Set cycle with next go */
name|dra
operator|->
name|dr_cmd
operator||=
name|DR_PCYL
expr_stmt|;
break|break;
case|case
name|DRDFCN
case|:
comment|/* Do not update function bits until next go issued */
name|dra
operator|->
name|dr_cmd
operator||=
name|DR_DFCN
expr_stmt|;
break|break;
case|case
name|DRRATN
case|:
comment|/* Reset attention flag -- use with extreme caution */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|RATN
expr_stmt|;
break|break;
case|case
name|DRRDMA
case|:
comment|/* Reset DMA e-o-r flag -- should never used */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|RDMA
expr_stmt|;
break|break;
case|case
name|DRSFCN
case|:
comment|/* Set function bits */
name|temp
operator|=
name|data
index|[
literal|0
index|]
operator|&
name|DR_FMSK
expr_stmt|;
name|rsaddr
operator|->
name|dr_cstat
operator|=
name|temp
expr_stmt|;
comment|/* Write to control register */
comment|/* This has a very important side effect -- It clears the interrupt 	   enable flag. That is fine for this driver, but if it is desired 	   to leave interrupt enable at all times, it will be necessary to 	   to read the status register first to get IENB, or carry a software 	   flag that indicates whether interrupts are set, and or this into  	   the controll register value being written. 	*/
break|break;
case|case
name|DRRPER
case|:
comment|/* Clear parity flag */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|RPER
expr_stmt|;
break|break;
case|case
name|DRSETRSTALL
case|:
comment|/* Set read stall mode. */
name|dra
operator|->
name|dr_flags
operator|&=
operator|(
operator|~
name|DR_NORSTALL
operator|)
expr_stmt|;
break|break;
case|case
name|DRSETNORSTALL
case|:
comment|/* Set no stall read  mode. */
name|dra
operator|->
name|dr_flags
operator||=
name|DR_NORSTALL
expr_stmt|;
break|break;
case|case
name|DRGETRSTALL
case|:
comment|/* Returns true if in read stall mode. */
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_NORSTALL
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
case|case
name|DRSETRTIMEOUT
case|:
comment|/* Set the number of ticks before a no stall read times out. 	   The argument is given in tenths of a second. */
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|<
literal|1
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
name|temp
operator|=
literal|1
expr_stmt|;
block|}
name|dra
operator|->
name|rtimoticks
operator|=
operator|(
name|data
index|[
literal|0
index|]
operator|*
name|hz
operator|)
operator|/
literal|10
expr_stmt|;
break|break;
case|case
name|DRGETRTIMEOUT
case|:
comment|/* Returns the number of tenths of seconds before 	   a no stall read times out. */
comment|/* The argument is given in tenths of a second. */
name|data
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|dra
operator|->
name|rtimoticks
operator|)
operator|*
literal|10
operator|)
operator|/
name|hz
expr_stmt|;
break|break;
case|case
name|DRSETWSTALL
case|:
comment|/* Set write stall mode. */
name|dra
operator|->
name|dr_flags
operator|&=
operator|(
operator|~
name|DR_NOWSTALL
operator|)
expr_stmt|;
break|break;
case|case
name|DRSETNOWSTALL
case|:
comment|/* Set write stall mode. */
name|dra
operator|->
name|dr_flags
operator||=
name|DR_NOWSTALL
expr_stmt|;
break|break;
case|case
name|DRGETWSTALL
case|:
comment|/* Returns true if in write stall mode. */
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_NOWSTALL
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
case|case
name|DRSETWTIMEOUT
case|:
comment|/* Set the number of ticks before a no stall write times out. 	   The argument is given in tenths of a second. */
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|<
literal|1
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
name|temp
operator|=
literal|1
expr_stmt|;
block|}
name|dra
operator|->
name|wtimoticks
operator|=
operator|(
name|data
index|[
literal|0
index|]
operator|*
name|hz
operator|)
operator|/
literal|10
expr_stmt|;
break|break;
case|case
name|DRGETWTIMEOUT
case|:
comment|/* Returns the number of tenths of seconds before 	   a no stall write times out. */
comment|/* The argument is given in tenths of a second. */
name|data
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|dra
operator|->
name|wtimoticks
operator|)
operator|*
literal|10
operator|)
operator|/
name|hz
expr_stmt|;
break|break;
case|case
name|DRWRITEREADY
case|:
comment|/* Returns a value of 1 if the device can accept 	   data, 0 otherwise. Internally this is the 	   DR11-W STAT A bit. */
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|rsaddr
operator|->
name|dr_cstat
operator|&
name|STTA
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|DRREADREADY
case|:
comment|/* Returns a value of 1 if the device has data 	   for host to be read, 0 otherwise. Internally 	   this is the DR11-W STAT B bit. */
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|rsaddr
operator|->
name|dr_cstat
operator|&
name|STTB
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|DRBUSY
case|:
comment|/* Returns a value of 1 if the device is busy, 	   0 otherwise. Internally this is the DR11-W 	   STAT C bit, but there is a bug in the Omega 500/FIFO interface 	   board that it cannot drive this signal low for certain DR11-W 	   ctlr such as the Ikon. We use the REDY signal of the CSR on 	   the Ikon DR11-W instead.   	data[0] = (rsaddr->dr_cstat& STTC)? 1 : 0; 	*/
name|data
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|rsaddr
operator|->
name|dr_cstat
operator|&
name|REDY
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|DRRESET
case|:
name|rsaddr
operator|->
name|dr_pulse
operator|=
operator|(
name|MCLR
operator||
name|RDMA
operator||
name|RATN
operator||
name|RPER
operator|)
expr_stmt|;
comment|/* Reset DMA ATN RPER flag */
name|DELAY
argument_list|(
literal|0x1f000
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|rsaddr
operator|->
name|dr_cstat
operator|&
name|REDY
operator|)
condition|)
block|{
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dra
argument_list|,
name|DRPRI
argument_list|)
expr_stmt|;
comment|/* Wakeup by drtimo() */
block|}
name|dra
operator|->
name|dr_istat
operator|=
literal|0
expr_stmt|;
name|dra
operator|->
name|dr_cmd
operator|=
literal|0
expr_stmt|;
name|dra
operator|->
name|currenttimo
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\ndrioctl: Invalid ioctl cmd : %lx"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|0x10
condition|)
name|printf
argument_list|(
literal|"**** (data[0]:%lx)"
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Reset state on Unibus reset */
end_comment

begin_macro
name|drreset
argument_list|(
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDR
condition|;
name|i
operator|++
operator|,
name|dra
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ui
operator|=
name|drinfo
index|[
name|i
index|]
operator|)
operator|==
literal|0
operator|||
operator|!
name|ui
operator|->
name|ui_alive
operator|||
name|ui
operator|->
name|ui_vbanum
operator|!=
name|uban
condition|)
continue|continue;
name|printf
argument_list|(
literal|"\ndrreset: %ld"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Do something; reset board */
block|}
return|return;
block|}
end_block

begin_comment
comment|/*  * An interrupt is caused either by an error,  * base address overflow, or transfer complete  */
end_comment

begin_expr_stmt
name|drintr
argument_list|(
name|unit
argument_list|)
specifier|register
name|long
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
init|=
operator|&
name|dr_aux
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|rsdevice
modifier|*
name|rsaddr
init|=
name|RSADDR
argument_list|(
name|unit
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|short
name|status
decl_stmt|,
name|csrtmp
decl_stmt|;
name|status
operator|=
name|rsaddr
operator|->
name|dr_cstat
operator|&
literal|0xffff
expr_stmt|;
comment|/* get board status register */
name|dra
operator|->
name|dr_istat
operator|=
name|status
expr_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|2
condition|)
name|printf
argument_list|(
literal|"\ndrintr: dr11 status : %lx"
argument_list|,
name|status
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_LOOPTST
condition|)
block|{
comment|/* Controller is doing loopback test */
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_LOOPTST
expr_stmt|;
return|return;
block|}
comment|/* Make sure this is not a stray interrupt; at least one of dmaf or attf        must be set. Note that if the dr11 interrupt enable latch is reset         during a hardware interrupt ack sequence, and by the we get to this         point in the interrupt code it will be 0. This is done to give the        programmer some control over how the two more-or-less independent        interrupt sources on the board are handled.        If the attention flag is set when drstrategy() is called to start a        dma read or write an interrupt will be generated as soon as the        strategy routine enables interrupts for dma end-of-range. This will        cause execution of the interrupt routine (not necessarily bad) and        will cause the interrupt enable mask to be reset (very bad since the        dma end-of-range condition will not be able to generate an interrupt        when it occurs) causing the dma operation to time-out (even though        the dma transfer will be done successfully) or hang the process if a        software time-out capability is not implemented. One way to avoid         this situation is to check for a pending attention interrupt (attf        set) by calling drioctl() before doing a read or a write. For the        time being this driver will solve the problem by clearing the attf        flag in the status register before enabling interrupts in drstrategy().         **** The IKON 10084 for which this driver is written will set both        attf and dmaf if dma is terminated by an attention pulse. This will        cause a wakeup(&dr_aux), which will be ignored since it is not being         waited on, and an iodone(bp) which is the desired action. Some other        dr11 emulators, in particular the IKON 10077 for the Multibus, donot        dmaf in this case. This may require some addtional code in the inter-        rupt routine to ensure that en iodone(bp) is issued when dma is term-        inated by attention.     */
name|bp
operator|=
name|dra
operator|->
name|dr_actf
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
operator|(
name|ATTF
operator||
name|DMAF
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\ndrintr: Stray interrupt, dr11 status : %lx"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|status
operator|&
name|DMAF
condition|)
block|{
comment|/* End-of-range interrupt */
name|dra
operator|->
name|dr_flags
operator||=
name|DR_DMAX
expr_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|2
condition|)
name|printf
argument_list|(
literal|"\ndrintr: e-o-r interrupt,cstat:%lx,dr_flags:%lx"
argument_list|,
name|status
operator|&
literal|0xffff
argument_list|,
name|dra
operator|->
name|dr_flags
operator|&
name|DR_ACTV
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_ACTV
operator|)
condition|)
block|{
comment|/* We are not doing DMA !! */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dra
operator|->
name|dr_op
operator|==
name|DR_READ
condition|)
name|mtpr
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|P1DC
argument_list|)
expr_stmt|;
name|dra
operator|->
name|dr_bycnt
operator|-=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|dra
operator|->
name|dr_bycnt
operator|>
literal|0
condition|)
block|{
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
operator|(
name|dra
operator|->
name|dr_bycnt
operator|>
name|NBPG
operator|)
condition|?
name|NBPG
else|:
name|dra
operator|->
name|dr_bycnt
expr_stmt|;
name|drstart
argument_list|(
name|rsaddr
argument_list|,
name|dra
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_ACTV
expr_stmt|;
name|wakeup
argument_list|(
name|dra
argument_list|)
expr_stmt|;
comment|/* Wakeup proc waiting in drwait() */
name|rsaddr
operator|->
name|dr_pulse
operator|=
operator|(
name|RPER
operator||
name|RDMA
operator||
name|RATN
operator|)
expr_stmt|;
comment|/* reset dma e-o-r flag */
block|}
comment|/* Now test for attention interrupt -- It may be set in addition to         the dma e-o-r interrupt. If we get one we will issue a wakeup to        the drioctl() routine which is presumable waiting for one.        The program may have to monitor the attention interrupt received        flag in addition to doing waits for the interrupt. Futhermore,         interrupts are not enabled unless dma is in progress or drioctl()        has been called to wait for attention -- this may produce some        strange results if attf is set on the dr11 when a read or a write        is initiated, since that will enables interrupts.        **** The appropriate code for this interrupt routine will probably        be rather application dependent.     */
if|if
condition|(
name|status
operator|&
name|ATTF
condition|)
block|{
name|dra
operator|->
name|dr_flags
operator||=
name|DR_ATRX
expr_stmt|;
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_ATWT
expr_stmt|;
name|rsaddr
operator|->
name|dr_cstat
operator|=
name|RATN
expr_stmt|;
comment|/* reset attention flag */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dra
operator|->
name|dr_cmd
argument_list|)
expr_stmt|;
comment|/* Some applications which use attention to terminate dma may also 	   want to issue an iodone() here to wakeup physio().  	*/
block|}
return|return;
block|}
end_block

begin_function
name|unsigned
name|drminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
literal|65536
condition|)
name|bp
operator|->
name|b_bcount
operator|=
literal|65536
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  This routine performs the device unique operations on the DR11W  *  it is passed as an argument to and invoked by physio  */
end_comment

begin_expr_stmt
name|drstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rsdevice
modifier|*
name|rsaddr
init|=
name|RSADDR
argument_list|(
name|unit
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
init|=
operator|&
name|dr_aux
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|short
name|go
init|=
literal|0
decl_stmt|;
specifier|register
name|long
name|baddr
decl_stmt|,
name|ok
decl_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
specifier|register
name|char
modifier|*
name|caddr
decl_stmt|;
name|long
name|drva
parameter_list|()
function_decl|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_OPEN
operator|)
condition|)
block|{
comment|/* Device not open */
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_ACTV
condition|)
block|{
comment|/* Device is active; should never be in here... */
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dra
operator|->
name|dr_flags
argument_list|,
name|DRPRI
argument_list|)
expr_stmt|;
block|}
name|dra
operator|->
name|dr_actf
operator|=
name|bp
expr_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
name|drva
argument_list|(
name|dra
argument_list|,
name|bp
operator|->
name|b_proc
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dra
operator|->
name|dr_oba
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
comment|/* Save original addr, count */
name|dra
operator|->
name|dr_obc
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|dra
operator|->
name|dr_bycnt
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
comment|/* Save xfer count used by drintr() */
if|if
condition|(
operator|(
operator|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|&
literal|0x3fffffff
operator|)
operator|>>
name|PGSHIFT
operator|)
operator|!=
operator|(
operator|(
operator|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|&
literal|0x3fffffff
operator|)
operator|+
name|bp
operator|->
name|b_bcount
operator|)
operator|>>
name|PGSHIFT
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
name|NBPG
operator|-
operator|(
operator|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|)
operator|&
name|PGOFSET
operator|)
expr_stmt|;
block|}
name|dra
operator|->
name|dr_flags
operator||=
name|DR_ACTV
expr_stmt|;
comment|/* Mark it active (use in intr handler) */
name|s
operator|=
name|SPL_UP
argument_list|()
expr_stmt|;
name|drstart
argument_list|(
name|rsaddr
argument_list|,
name|dra
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ok
operator|=
name|drwait
argument_list|(
name|rsaddr
argument_list|,
name|dra
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|0x40
condition|)
block|{
name|caddr
operator|=
operator|(
name|char
operator|*
operator|)
name|dra
operator|->
name|dr_oba
expr_stmt|;
if|if
condition|(
name|dra
operator|->
name|dr_op
operator|==
name|DR_READ
condition|)
name|printf
argument_list|(
literal|"\nAfter read: (%lx)(%lx)"
argument_list|,
name|caddr
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|,
name|caddr
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_ACTV
expr_stmt|;
comment|/* Clear active flag */
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
name|dra
operator|->
name|dr_oba
expr_stmt|;
comment|/* Restore original addr, count */
name|bp
operator|->
name|b_bcount
operator|=
name|dra
operator|->
name|dr_obc
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Mark buffer B_DONE,so physstrat() 					   in ml/machdep.c won't sleep */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dra
operator|->
name|dr_flags
argument_list|)
expr_stmt|;
comment|/* Return to the calling program (physio()). Physio() will sleep        until awaken by a call to iodone() in the interupt handler --        which will be called by the dispatcher when it receives dma        end-of-range interrupt.     */
return|return;
block|}
end_block

begin_expr_stmt
name|drwait
argument_list|(
name|rs
argument_list|,
name|dr
argument_list|)
specifier|register
expr|struct
name|rsdevice
operator|*
name|rs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|dr_aux
modifier|*
name|dr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|status
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|SPL_UP
argument_list|()
expr_stmt|;
while|while
condition|(
name|dr
operator|->
name|dr_flags
operator|&
name|DR_ACTV
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dr
argument_list|,
name|DRPRI
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_flags
operator|&
name|DR_TMDM
condition|)
block|{
comment|/* DMA timed out */
name|dr
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_TMDM
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|rs
operator|->
name|dr_cstat
operator|&
operator|(
name|PERR
operator||
name|BERR
operator||
name|TERR
operator|)
condition|)
block|{
operator|(
name|dr
operator|->
name|dr_actf
operator|)
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|dr
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_DMAX
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|drrwtimo
argument_list|(
name|tinfo
argument_list|)
specifier|register
name|unsigned
name|long
name|tinfo
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * 	The lower 8-bit of tinfo is the minor device number, the  *	remaining higher 8-bit is the current timout number */
end_comment

begin_block
block|{
specifier|register
name|long
name|unit
init|=
name|tinfo
operator|&
literal|0xff
decl_stmt|;
specifier|register
name|struct
name|dr_aux
modifier|*
name|dr
init|=
operator|&
name|dr_aux
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|rsdevice
modifier|*
name|rs
init|=
name|dr
operator|->
name|dr_addr
decl_stmt|;
comment|/* If this is not the timeout that drwrite/drread is waiting 	   for then we should just go away */
if|if
condition|(
operator|(
name|tinfo
operator|&
operator|(
operator|~
literal|0xff
operator|)
operator|)
operator|!=
operator|(
name|dr
operator|->
name|currenttimo
operator|<<
literal|8
operator|)
condition|)
return|return;
comment|/* Mark the device timed out */
name|dr
operator|->
name|dr_flags
operator||=
name|DR_TMDM
expr_stmt|;
name|dr
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_ACTV
expr_stmt|;
name|rs
operator|->
name|dr_pulse
operator|=
name|RMSK
expr_stmt|;
comment|/* Inihibit interrupt */
name|rs
operator|->
name|dr_pulse
operator|=
operator|(
name|RPER
operator||
name|RDMA
operator||
name|RATN
operator||
name|IENB
operator|)
expr_stmt|;
comment|/* Clear DMA logic */
comment|/* Some applications will not issue a master after dma timeout, 	   since doing so sends an INIT H pulse to the external device, 	   which may produce undesirable side-effects.  */
comment|/* Wake up process waiting in drwait() and flag the error */
operator|(
name|dr
operator|->
name|dr_actf
operator|)
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dr
operator|->
name|dr_cmd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Kick the driver every second */
end_comment

begin_macro
name|drtimo
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|dr_aux
modifier|*
name|dr
decl_stmt|;
name|dr
operator|=
operator|&
name|dr_aux
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_flags
operator|&
name|DR_OPEN
condition|)
name|timeout
argument_list|(
name|drtimo
argument_list|,
operator|(
name|caddr_t
operator|)
name|dev
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dr
argument_list|)
expr_stmt|;
comment|/* Wakeup any process waiting for interrupt */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DR_DEBUG
end_ifdef

begin_macro
name|drva
argument_list|(
argument|dra
argument_list|,
argument|p
argument_list|,
argument|va
argument_list|,
argument|bcnt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|va
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|bcnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|first
decl_stmt|,
name|last
decl_stmt|,
name|np
decl_stmt|;
if|if
condition|(
name|DR11
operator|&
literal|0x20
condition|)
block|{
name|first
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
name|vtoph
argument_list|(
name|p
argument_list|,
name|va
argument_list|)
argument_list|)
operator|)
operator|>>
literal|10
expr_stmt|;
name|last
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
name|vtoph
argument_list|(
name|p
argument_list|,
name|va
operator|+
name|bcnt
argument_list|)
argument_list|)
operator|)
operator|>>
literal|10
expr_stmt|;
name|np
operator|=
name|bcnt
operator|/
literal|0x3ff
expr_stmt|;
name|printf
argument_list|(
literal|"\ndrva: (op:%ld)(first:%ld)(last:%ld)(np:%ld)(cnt:%ld)"
argument_list|,
name|dra
operator|->
name|dr_op
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|np
argument_list|,
name|bcnt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|drstart
argument_list|(
name|rsaddr
argument_list|,
name|dra
argument_list|,
name|bp
argument_list|)
specifier|register
expr|struct
name|rsdevice
operator|*
name|rsaddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|baddr
decl_stmt|;
name|ushort
name|go
decl_stmt|;
specifier|register
name|char
modifier|*
name|caddr
decl_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
operator|(
name|dra
operator|->
name|dr_op
operator|==
name|DR_READ
operator|)
operator|&&
operator|(
name|DR11
operator|&
literal|8
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\ndrstart: READ, bcnt:%ld"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|caddr
operator|=
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|printf
argument_list|(
literal|",(%lx)(%lx)"
argument_list|,
name|caddr
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|,
name|caddr
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* we are doing raw IO, bp->b_un.b_addr is user's address */
name|baddr
operator|=
operator|(
name|long
operator|)
name|vtoph
argument_list|(
name|bp
operator|->
name|b_proc
argument_list|,
operator|(
name|caddr_t
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
expr_stmt|;
comment|/* Set DMA address into DR11 interace registers: DR11 requires that        the address be right shifted 1 bit position before it is written        to the board (The board will left shift it one bit position before        it places the address on the bus     */
name|rsaddr
operator|->
name|dr_walo
operator|=
call|(
name|ushort
call|)
argument_list|(
operator|(
name|baddr
operator|>>
literal|1
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|rsaddr
operator|->
name|dr_wahi
operator|=
call|(
name|ushort
call|)
argument_list|(
operator|(
name|baddr
operator|>>
literal|17
operator|)
operator|&
literal|0x7fff
argument_list|)
expr_stmt|;
comment|/* Set DMA range count: (number of words - 1) */
name|rsaddr
operator|->
name|dr_range
operator|=
call|(
name|ushort
call|)
argument_list|(
operator|(
name|bp
operator|->
name|b_bcount
operator|>>
literal|1
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Set address modifier code to be used for DMA access to memory */
name|rsaddr
operator|->
name|dr_addmod
operator|=
operator|(
name|char
operator|)
name|DRADDMOD
expr_stmt|;
comment|/* Now determine whether this is a read or a write. ***** This is        probably only usefull for link mode operation, since dr11 doesnot        controll the direction of data transfer. The C1 control input         controls whether the hardware is doing a read or a write. In link        mode this is controlled by function 1 latch (looped back by the        cable) and could be set the program. In the general case, the dr11        doesnot know in advance what the direction of transfer is - although        the program and protocol logic probably is     */
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|1
condition|)
name|printf
argument_list|(
literal|"\ndrstrat: about to GO..,dr_cmd:%lx,drstat:%lx,drcnt:%ld,cdata:%lx,OP:%ld"
argument_list|,
name|dra
operator|->
name|dr_cmd
argument_list|,
name|rsaddr
operator|->
name|dr_cstat
argument_list|,
name|rsaddr
operator|->
name|dr_range
argument_list|,
name|rsaddr
operator|->
name|dr_data
argument_list|,
name|dra
operator|->
name|dr_op
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Update function latches may have been done already by drioctl() if        request from drioctl()     */
if|if
condition|(
name|dra
operator|->
name|dr_cmd
operator|&
name|DR_DFCN
condition|)
block|{
comment|/* deferred function write */
name|dra
operator|->
name|dr_cmd
operator|&=
operator|~
name|DR_DFCN
expr_stmt|;
comment|/* Clear request */
name|go
operator|=
name|dra
operator|->
name|dr_cmd
operator|&
name|DR_FMSK
expr_stmt|;
comment|/* mask out fcn bits */
name|rsaddr
operator|->
name|dr_cstat
operator|=
name|go
expr_stmt|;
comment|/* Write it to the board */
block|}
comment|/* Clear dmaf and attf to assure a clean dma start */
name|rsaddr
operator|->
name|dr_pulse
operator|=
call|(
name|ushort
call|)
argument_list|(
name|RATN
operator||
name|RDMA
operator||
name|RPER
argument_list|)
expr_stmt|;
name|rsaddr
operator|->
name|dr_cstat
operator|=
call|(
name|ushort
call|)
argument_list|(
name|IENB
operator||
name|GO
operator||
name|CYCL
operator||
name|dra
operator|->
name|dr_op
argument_list|)
expr_stmt|;
comment|/* GO...... */
comment|/* Now check for software cycle request -- usually by transmitter in        link mode.     */
if|if
condition|(
name|dra
operator|->
name|dr_cmd
operator|&
name|DR_PCYL
condition|)
block|{
name|dra
operator|->
name|dr_cmd
operator|&=
operator|~
name|DR_PCYL
expr_stmt|;
comment|/* Clear request */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|CYCL
expr_stmt|;
comment|/* Use pulse register again */
block|}
comment|/* Now check for deferred ACLO FCNT2 pulse request -- usually to tell        the transmitter (via its attention) that we have enabled dma.     */
if|if
condition|(
name|dra
operator|->
name|dr_cmd
operator|&
name|DR_DACL
condition|)
block|{
name|dra
operator|->
name|dr_cmd
operator|&=
operator|~
name|DR_DACL
expr_stmt|;
comment|/* Clear request */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|FCN2
expr_stmt|;
comment|/* Use pulse register again */
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|NDR
end_endif

end_unit

