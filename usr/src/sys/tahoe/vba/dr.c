begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Computer Consoles Inc.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  *	@(#)dr.c	7.6 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"dr.h"
end_include

begin_if
if|#
directive|if
name|NDR
operator|>
literal|0
end_if

begin_comment
comment|/*  * DRV11-W DMA interface driver.  *  * UNTESTED WITH 4.3  */
end_comment

begin_include
include|#
directive|include
file|"machine/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/drreg.h"
end_include

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|drinfo
index|[
name|NDR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dr_aux
name|dr_aux
index|[
name|NDR
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|unsigned
name|drminphys
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|drprobe
argument_list|()
decl_stmt|,
name|drintr
argument_list|()
decl_stmt|,
name|drattach
argument_list|()
decl_stmt|,
name|drtimo
argument_list|()
decl_stmt|,
name|drrwtimo
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|drstrategy
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|vba_device
modifier|*
name|drinfo
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|drstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|drdriver
init|=
block|{
name|drprobe
block|,
literal|0
block|,
name|drattach
block|,
literal|0
block|,
name|drstd
block|,
literal|"rs"
block|,
name|drinfo
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RSUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 7)
end_define

begin_define
define|#
directive|define
name|SPL_UP
value|spl5
end_define

begin_comment
comment|/* -------- Per-unit data -------- */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|dr_aux
name|dr_aux
index|[]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DR_DEBUG
end_ifdef

begin_decl_stmt
name|long
name|DR11
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|drprobe
argument_list|(
argument|reg
argument_list|,
argument|vi
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* must be r12, r11 */
name|struct
name|rsdevice
modifier|*
name|dr
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|drintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|badaddr
argument_list|(
name|reg
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dr
operator|=
operator|(
expr|struct
name|rsdevice
operator|*
operator|)
name|reg
expr_stmt|;
name|dr
operator|->
name|dr_intvect
operator|=
operator|--
name|vi
operator|->
name|ui_hd
operator|->
name|vh_lastiv
expr_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
name|printf
argument_list|(
literal|"dprobe: Set interrupt vector %lx and init\n"
argument_list|,
name|dr
operator|->
name|dr_intvec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* generate interrupt here for autoconfig */
name|dr
operator|->
name|dr_cstat
operator|=
name|MCLR
expr_stmt|;
comment|/* init board and device */
ifdef|#
directive|ifdef
name|DR_DEBUG
name|printf
argument_list|(
literal|"drprobe: Initial status %lx\n"
argument_list|,
name|dr
operator|->
name|dr_cstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|br
operator|=
literal|0x18
operator|,
name|cvec
operator|=
name|dr
operator|->
name|dr_intvect
expr_stmt|;
comment|/* XXX */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|rsdevice
argument_list|)
operator|)
return|;
comment|/* DR11 exist */
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|drattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dr_aux
modifier|*
name|rsd
decl_stmt|;
name|rsd
operator|=
operator|&
name|dr_aux
index|[
name|ui
operator|->
name|ui_unit
index|]
expr_stmt|;
name|rsd
operator|->
name|dr_flags
operator|=
name|DR_PRES
expr_stmt|;
comment|/* This dr11 is present */
name|rsd
operator|->
name|dr_addr
operator|=
operator|(
expr|struct
name|rsdevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
comment|/* Save addr of this dr11 */
name|rsd
operator|->
name|dr_istat
operator|=
literal|0
expr_stmt|;
name|rsd
operator|->
name|dr_bycnt
operator|=
literal|0
expr_stmt|;
name|rsd
operator|->
name|dr_cmd
operator|=
literal|0
expr_stmt|;
name|rsd
operator|->
name|currenttimo
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|dropen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rsdevice
modifier|*
name|dr
decl_stmt|;
specifier|register
name|struct
name|dr_aux
modifier|*
name|rsd
decl_stmt|;
if|if
condition|(
name|drinfo
index|[
name|unit
index|]
operator|==
literal|0
operator|||
operator|!
name|drinfo
index|[
name|unit
index|]
operator|->
name|ui_alive
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dr
operator|=
name|RSADDR
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|rsd
operator|=
operator|&
name|dr_aux
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|rsd
operator|->
name|dr_flags
operator|&
name|DR_OPEN
condition|)
block|{
ifdef|#
directive|ifdef
name|DR_DEBUG
name|printf
argument_list|(
literal|"\ndropen: dr11 unit %ld already open"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* DR11 already open */
block|}
name|rsd
operator|->
name|dr_flags
operator||=
name|DR_OPEN
expr_stmt|;
comment|/* Mark it OPEN */
name|rsd
operator|->
name|dr_istat
operator|=
literal|0
expr_stmt|;
comment|/* Clear status of previous interrupt */
name|rsd
operator|->
name|rtimoticks
operator|=
name|hz
expr_stmt|;
comment|/* Set read no stall timout to 1 sec */
name|rsd
operator|->
name|wtimoticks
operator|=
name|hz
operator|*
literal|60
expr_stmt|;
comment|/* Set write no stall timout to 1 min */
name|dr
operator|->
name|dr_cstat
operator|=
name|DR_ZERO
expr_stmt|;
comment|/* Clear function& latches */
name|dr
operator|->
name|dr_pulse
operator|=
operator|(
name|RDMA
operator||
name|RATN
operator|)
expr_stmt|;
comment|/* clear leftover attn& e-o-r flags */
name|drtimo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* start the self kicker */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|drclose
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
specifier|register
name|struct
name|rsdevice
modifier|*
name|rs
decl_stmt|;
specifier|register
name|short
name|s
decl_stmt|;
name|dra
operator|=
operator|&
name|dr_aux
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DR_DEBUG
name|printf
argument_list|(
literal|"\ndrclose: DR11 device %ld not open"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
operator|(
name|DR_OPEN
operator||
name|DR_ACTV
operator|)
expr_stmt|;
name|rs
operator|=
name|dra
operator|->
name|dr_addr
expr_stmt|;
name|s
operator|=
name|SPL_UP
argument_list|()
expr_stmt|;
name|rs
operator|->
name|dr_cstat
operator|=
name|DR_ZERO
expr_stmt|;
if|if
condition|(
name|dra
operator|->
name|dr_buf
operator|.
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
name|dra
operator|->
name|dr_buf
operator|.
name|b_flags
operator|&=
operator|~
name|B_BUSY
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dra
operator|->
name|dr_buf
operator|.
name|b_flags
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*	drread() works exactly like drwrite() except that the 	B_READ flag is used when physio() is called */
end_comment

begin_macro
name|drread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|spl
decl_stmt|,
name|err
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<=
literal|0
operator|||
comment|/* Negative count */
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|&
literal|1
operator|||
comment|/* odd count */
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|&
literal|1
condition|)
comment|/* odd destination address */
return|return
operator|(
name|EINVAL
operator|)
return|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|8
condition|)
name|printf
argument_list|(
literal|"\ndrread: (len:%ld)(base:%lx)"
argument_list|,
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
argument_list|,
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dra
operator|=
operator|&
name|dr_aux
index|[
name|RSUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|dra
operator|->
name|dr_op
operator|=
name|DR_READ
expr_stmt|;
name|bp
operator|=
operator|&
name|dra
operator|->
name|dr_buf
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_NORSTALL
condition|)
block|{
comment|/* 		 * We are in no stall mode, start the timer, 		 * raise IPL so nothing can stop us once the 		 * timer's running 		 */
name|spl
operator|=
name|SPL_UP
argument_list|()
expr_stmt|;
name|timeout
argument_list|(
name|drrwtimo
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|dra
operator|->
name|currenttimo
operator|<<
literal|8
operator|)
operator||
name|unit
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|dra
operator|->
name|rtimoticks
argument_list|)
expr_stmt|;
name|err
operator|=
name|physio
argument_list|(
name|drstrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|drminphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dra
operator|->
name|currenttimo
operator|++
expr_stmt|;
comment|/* Update current timeout number */
comment|/* Did we timeout */
if|if
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_TMDM
condition|)
block|{
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_TMDM
expr_stmt|;
comment|/* Clear timeout flag */
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
comment|/* Made the error ourself, ignore it */
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
name|physio
argument_list|(
name|drstrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|drminphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|drwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|spl
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<=
literal|0
operator|||
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|&
literal|1
operator|||
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|&
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|4
condition|)
name|printf
argument_list|(
literal|"\ndrwrite: (len:%ld)(base:%lx)"
argument_list|,
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
argument_list|,
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dra
operator|=
operator|&
name|dr_aux
index|[
name|RSUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|dra
operator|->
name|dr_op
operator|=
name|DR_WRITE
expr_stmt|;
name|bp
operator|=
operator|&
name|dra
operator|->
name|dr_buf
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_NOWSTALL
condition|)
block|{
comment|/* 		 * We are in no stall mode, start the timer, 		 * raise IPL so nothing can stop us once the 		 * timer's running 		 */
name|spl
operator|=
name|SPL_UP
argument_list|()
expr_stmt|;
name|timeout
argument_list|(
name|drrwtimo
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|dra
operator|->
name|currenttimo
operator|<<
literal|8
operator|)
operator||
name|unit
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|dra
operator|->
name|wtimoticks
argument_list|)
expr_stmt|;
name|err
operator|=
name|physio
argument_list|(
name|drstrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|drminphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dra
operator|->
name|currenttimo
operator|++
expr_stmt|;
comment|/* Update current timeout number */
comment|/* Did we timeout */
if|if
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_TMDM
condition|)
block|{
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_TMDM
expr_stmt|;
comment|/* Clear timeout flag */
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
comment|/* Made the error ourself, ignore it */
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
name|physio
argument_list|(
name|drstrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|drminphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Routine used by calling program to issue commands to dr11 driver and   * through it to the device.  * It is also used to read status from the device and driver and to wait   * for attention interrupts.  * Status is returned in an 8 elements unsigned short integer array, the   * first two elements of the array are also used to pass arguments to   * drioctl() if required.  * The function bits to be written to the dr11 are included in the cmd  * argument. Even if they are not being written to the dr11 in a particular  * drioctl() call, they will update the copy of cmd that is stored in the  * driver. When drstrategy() is called, this updated copy is used if a   * deferred function bit write has been specified. The "side effect" of  * calls to the drioctl() requires that the last call prior to a read or  * write has an appropriate copy of the function bits in cmd if they are  * to be used in drstrategy().  * When used as command value, the contents of data[0] is the command  * parameter.  */
end_comment

begin_macro
name|drioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
specifier|register
name|struct
name|rsdevice
modifier|*
name|rsaddr
init|=
name|RSADDR
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|u_short
name|status
decl_stmt|;
name|long
name|temp
decl_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|0x10
condition|)
name|printf
argument_list|(
literal|"\ndrioctl: (dev:%lx)(cmd:%lx)(data:%lx)(data[0]:%lx)"
argument_list|,
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dra
operator|=
operator|&
name|dr_aux
index|[
name|unit
index|]
expr_stmt|;
name|dra
operator|->
name|dr_cmd
operator|=
literal|0
expr_stmt|;
comment|/* Fresh copy; clear all previous flags */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DRWAIT
case|:
comment|/* Wait for attention interrupt */
ifdef|#
directive|ifdef
name|DR_DEBUG
name|printf
argument_list|(
literal|"\ndrioctl: wait for attention interrupt"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|SPL_UP
argument_list|()
expr_stmt|;
comment|/*  		 * If the attention flag in dr_flags is set, it probably 		 * means that an attention has arrived by the time a 		 * previous DMA end-of-range interrupt was serviced. If 		 * ATRX is set, we will return with out sleeping, since 		 * we have received an attention since the last call to 		 * wait on attention.  This may not be appropriate for 		 * some applications. 		 */
if|if
condition|(
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_ATRX
operator|)
operator|==
literal|0
condition|)
block|{
name|dra
operator|->
name|dr_flags
operator||=
name|DR_ATWT
expr_stmt|;
comment|/* Set waiting flag */
comment|/* 			 * Enable interrupt; use pulse reg. 			 * so function bits are not changed 			 */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|IENB
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dra
operator|->
name|dr_cmd
argument_list|,
name|DRPRI
operator||
name|PCATCH
argument_list|,
name|devio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRPIOW
case|:
comment|/* Write to p-i/o register */
name|rsaddr
operator|->
name|dr_data
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|DRPACL
case|:
comment|/* Send pulse to device */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|FCN2
expr_stmt|;
break|break;
case|case
name|DRDACL
case|:
comment|/* Defer alco pulse until go */
name|dra
operator|->
name|dr_cmd
operator||=
name|DR_DACL
expr_stmt|;
break|break;
case|case
name|DRPCYL
case|:
comment|/* Set cycle with next go */
name|dra
operator|->
name|dr_cmd
operator||=
name|DR_PCYL
expr_stmt|;
break|break;
case|case
name|DRDFCN
case|:
comment|/* Update function with next go */
name|dra
operator|->
name|dr_cmd
operator||=
name|DR_DFCN
expr_stmt|;
break|break;
case|case
name|DRRATN
case|:
comment|/* Reset attention flag */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|RATN
expr_stmt|;
break|break;
case|case
name|DRRDMA
case|:
comment|/* Reset DMA e-o-r flag */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|RDMA
expr_stmt|;
break|break;
case|case
name|DRSFCN
case|:
comment|/* Set function bits */
name|temp
operator|=
name|data
index|[
literal|0
index|]
operator|&
name|DR_FMSK
expr_stmt|;
comment|/* 		 * This has a very important side effect -- It clears 		 * the interrupt enable flag. That is fine for this driver, 		 * but if it is desired to leave interrupt enable at all 		 * times, it will be necessary to read the status register 		 * first to get IENB, or carry a software flag that indicates 		 * whether interrupts are set, and or this into the control 		 * register value being written. 		 */
name|rsaddr
operator|->
name|dr_cstat
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|DRRPER
case|:
comment|/* Clear parity flag */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|RPER
expr_stmt|;
break|break;
case|case
name|DRSETRSTALL
case|:
comment|/* Set read stall mode. */
name|dra
operator|->
name|dr_flags
operator|&=
operator|(
operator|~
name|DR_NORSTALL
operator|)
expr_stmt|;
break|break;
case|case
name|DRSETNORSTALL
case|:
comment|/* Set no stall read  mode. */
name|dra
operator|->
name|dr_flags
operator||=
name|DR_NORSTALL
expr_stmt|;
break|break;
case|case
name|DRGETRSTALL
case|:
comment|/* Returns true if in read stall mode */
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_NORSTALL
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
case|case
name|DRSETRTIMEOUT
case|:
comment|/* Set read stall timeout (1/10 secs) */
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|<
literal|1
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
name|temp
operator|=
literal|1
expr_stmt|;
block|}
name|dra
operator|->
name|rtimoticks
operator|=
operator|(
name|data
index|[
literal|0
index|]
operator|*
name|hz
operator|)
operator|/
literal|10
expr_stmt|;
break|break;
case|case
name|DRGETRTIMEOUT
case|:
comment|/* Return read stall timeout */
name|data
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|dra
operator|->
name|rtimoticks
operator|)
operator|*
literal|10
operator|)
operator|/
name|hz
expr_stmt|;
break|break;
case|case
name|DRSETWSTALL
case|:
comment|/* Set write stall mode. */
name|dra
operator|->
name|dr_flags
operator|&=
operator|(
operator|~
name|DR_NOWSTALL
operator|)
expr_stmt|;
break|break;
case|case
name|DRSETNOWSTALL
case|:
comment|/* Set write stall mode. */
name|dra
operator|->
name|dr_flags
operator||=
name|DR_NOWSTALL
expr_stmt|;
break|break;
case|case
name|DRGETWSTALL
case|:
comment|/* Return true if in write stall mode */
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_NOWSTALL
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
case|case
name|DRSETWTIMEOUT
case|:
comment|/* Set write stall timeout (1/10's) */
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|<
literal|1
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
name|temp
operator|=
literal|1
expr_stmt|;
block|}
name|dra
operator|->
name|wtimoticks
operator|=
operator|(
name|data
index|[
literal|0
index|]
operator|*
name|hz
operator|)
operator|/
literal|10
expr_stmt|;
break|break;
case|case
name|DRGETWTIMEOUT
case|:
comment|/* Return write stall timeout */
name|data
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|dra
operator|->
name|wtimoticks
operator|)
operator|*
literal|10
operator|)
operator|/
name|hz
expr_stmt|;
break|break;
case|case
name|DRWRITEREADY
case|:
comment|/* Return true if can write data */
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|rsaddr
operator|->
name|dr_cstat
operator|&
name|STTA
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|DRREADREADY
case|:
comment|/* Return true if data to be read */
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|rsaddr
operator|->
name|dr_cstat
operator|&
name|STTB
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|DRBUSY
case|:
comment|/* Return true if device busy */
comment|/* 		 * Internally this is the DR11-W 		 * STAT C bit, but there is a bug in the Omega 500/FIFO 		 * interface board that it cannot drive this signal low 		 * for certain DR11-W ctlr such as the Ikon. We use the 		 * REDY signal of the CSR on the Ikon DR11-W instead.  		 */
ifdef|#
directive|ifdef
name|notdef
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|rsaddr
operator|->
name|dr_cstat
operator|&
name|STTC
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
else|#
directive|else
name|data
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|rsaddr
operator|->
name|dr_cstat
operator|&
name|REDY
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DRRESET
case|:
comment|/* Reset device */
comment|/* Reset DMA ATN RPER flag */
name|rsaddr
operator|->
name|dr_pulse
operator|=
operator|(
name|MCLR
operator||
name|RDMA
operator||
name|RATN
operator||
name|RPER
operator|)
expr_stmt|;
name|DELAY
argument_list|(
literal|0x1f000
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rsaddr
operator|->
name|dr_cstat
operator|&
name|REDY
operator|)
operator|==
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
comment|/* Wakeup by drtimo() */
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dra
argument_list|,
name|DRPRI
operator||
name|PCATCH
argument_list|,
name|devio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dra
operator|->
name|dr_istat
operator|=
literal|0
expr_stmt|;
name|dra
operator|->
name|dr_cmd
operator|=
literal|0
expr_stmt|;
name|dra
operator|->
name|currenttimo
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DR11STAT
case|:
block|{
comment|/* Copy back dr11 status to user */
specifier|register
name|struct
name|dr11io
modifier|*
name|dr
init|=
operator|(
expr|struct
name|dr11io
operator|*
operator|)
name|data
decl_stmt|;
name|dr
operator|->
name|arg
index|[
literal|0
index|]
operator|=
name|dra
operator|->
name|dr_flags
expr_stmt|;
name|dr
operator|->
name|arg
index|[
literal|1
index|]
operator|=
name|rsaddr
operator|->
name|dr_cstat
expr_stmt|;
name|dr
operator|->
name|arg
index|[
literal|2
index|]
operator|=
name|dra
operator|->
name|dr_istat
expr_stmt|;
comment|/* Status at last interrupt */
name|dr
operator|->
name|arg
index|[
literal|3
index|]
operator|=
name|rsaddr
operator|->
name|dr_data
expr_stmt|;
comment|/* P-i/o input data */
name|status
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|rsaddr
operator|->
name|dr_addmod
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
argument_list|)
expr_stmt|;
name|dr
operator|->
name|arg
index|[
literal|4
index|]
operator|=
name|status
operator||
call|(
name|u_short
call|)
argument_list|(
name|rsaddr
operator|->
name|dr_intvect
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|dr
operator|->
name|arg
index|[
literal|5
index|]
operator|=
name|rsaddr
operator|->
name|dr_range
expr_stmt|;
name|dr
operator|->
name|arg
index|[
literal|6
index|]
operator|=
name|rsaddr
operator|->
name|dr_rahi
expr_stmt|;
name|dr
operator|->
name|arg
index|[
literal|7
index|]
operator|=
name|rsaddr
operator|->
name|dr_ralo
expr_stmt|;
break|break;
block|}
case|case
name|DR11LOOP
case|:
comment|/* Perform loopback test */
comment|/* 		 * NB: MUST HAVE LOOPBACK CABLE ATTACHED -- 		 * Test results are printed on system console 		 */
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|u
operator|.
name|u_cred
argument_list|,
operator|&
name|u
operator|.
name|u_acflag
argument_list|)
condition|)
break|break;
name|dr11loop
argument_list|(
name|rsaddr
argument_list|,
name|dra
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|0x10
condition|)
name|printf
argument_list|(
literal|"**** (data[0]:%lx)"
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|NPAT
value|2
end_define

begin_define
define|#
directive|define
name|DMATBL
value|20
end_define

begin_decl_stmt
name|u_short
name|tstpat
index|[
name|DMATBL
index|]
init|=
block|{
literal|0xAAAA
block|,
literal|0x5555
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|DMAin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Perform loopback test -- MUST HAVE LOOPBACK CABLE ATTACHED  * Test results are printed on system console  */
end_comment

begin_macro
name|dr11loop
argument_list|(
argument|dr
argument_list|,
argument|dra
argument_list|,
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|rsdevice
modifier|*
name|dr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|result
decl_stmt|,
name|ix
decl_stmt|;
name|long
name|addr
decl_stmt|,
name|wait
decl_stmt|;
name|dr
operator|->
name|dr_cstat
operator|=
name|MCLR
expr_stmt|;
comment|/* Clear board& device, disable intr */
name|printf
argument_list|(
literal|"\n\t ----- DR11 unit %ld loopback test -----"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t Program I/O ..."
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|NPAT
condition|;
name|ix
operator|++
control|)
block|{
name|dr
operator|->
name|dr_data
operator|=
name|tstpat
index|[
name|ix
index|]
expr_stmt|;
comment|/* Write to Data out register */
name|result
operator|=
name|dr
operator|->
name|dr_data
operator|&
literal|0xFFFF
expr_stmt|;
comment|/* Read it back */
if|if
condition|(
name|result
operator|!=
name|tstpat
index|[
name|ix
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"Failed, expected : %lx --- actual : %lx"
argument_list|,
name|tstpat
index|[
name|ix
index|]
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"OK\n\t Functions& Status Bits ..."
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_cstat
operator|=
operator|(
name|FCN1
operator||
name|FCN3
operator|)
expr_stmt|;
name|result
operator|=
name|dr
operator|->
name|dr_cstat
operator|&
literal|0xffff
expr_stmt|;
comment|/* Read them back */
if|if
condition|(
operator|(
name|result
operator|&
operator|(
name|STTC
operator||
name|STTA
operator|)
operator|)
operator|!=
operator|(
name|STTC
operator||
name|STTA
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Failed, expected : %lx --- actual : %lx, ISR:%lx"
argument_list|,
operator|(
name|STTA
operator||
name|STTC
operator|)
argument_list|,
operator|(
name|result
operator|&
operator|(
name|STTA
operator||
name|STTC
operator|)
operator|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|dr
operator|->
name|dr_cstat
operator|=
name|FCN2
expr_stmt|;
name|result
operator|=
name|dr
operator|->
name|dr_cstat
operator|&
literal|0xffff
expr_stmt|;
comment|/* Read them back */
if|if
condition|(
operator|(
name|result
operator|&
name|STTB
operator|)
operator|!=
name|STTB
condition|)
block|{
name|printf
argument_list|(
literal|"Failed, expected : %lx --- actual : %lx, ISR:%lx"
argument_list|,
name|STTB
argument_list|,
operator|(
name|result
operator|&
name|STTB
operator|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"OK\n\t DMA output ..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|DMAin
condition|)
goto|goto
name|dmain
goto|;
comment|/* Initialize DMA data buffer */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|DMATBL
condition|;
name|ix
operator|++
control|)
name|tstpat
index|[
name|ix
index|]
operator|=
literal|0xCCCC
operator|+
name|ix
expr_stmt|;
name|tstpat
index|[
name|DMATBL
operator|-
literal|1
index|]
operator|=
literal|0xCCCC
expr_stmt|;
comment|/* Last word output */
comment|/* Setup normal DMA */
name|addr
operator|=
operator|(
name|long
operator|)
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|tstpat
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_walo
operator|=
operator|(
name|addr
operator|>>
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|dr
operator|->
name|dr_wahi
operator|=
operator|(
name|addr
operator|>>
literal|17
operator|)
operator|&
literal|0x7fff
expr_stmt|;
comment|/* Set DMA range count: (number of words - 1) */
name|dr
operator|->
name|dr_range
operator|=
name|DMATBL
operator|-
literal|1
expr_stmt|;
comment|/* Set address modifier code to be used for DMA access to memory */
name|dr
operator|->
name|dr_addmod
operator|=
name|DRADDMOD
expr_stmt|;
comment|/* 	 * Clear dmaf and attf to assure a clean dma start, also disable 	 * attention interrupt 	 */
name|dr
operator|->
name|dr_pulse
operator|=
name|RDMA
operator||
name|RATN
operator||
name|RMSK
expr_stmt|;
comment|/* Use pulse register */
name|dr
operator|->
name|dr_cstat
operator|=
name|GO
operator||
name|CYCL
expr_stmt|;
comment|/* GO...... */
comment|/* Wait for DMA complete; REDY and DMAF are true in ISR */
name|wait
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|result
operator|=
operator|(
name|dr
operator|->
name|dr_cstat
operator|&
operator|(
name|REDY
operator||
name|DMAF
operator|)
operator|)
operator|)
operator|!=
operator|(
name|REDY
operator||
name|DMAF
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n\tWait for DMA complete...ISR : %lx"
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|wait
operator|>
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t DMA output fails...timeout!!, ISR:%lx"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|result
operator|=
name|dr
operator|->
name|dr_data
operator|&
literal|0xffff
expr_stmt|;
comment|/* Read last word output */
if|if
condition|(
name|result
operator|!=
literal|0xCCCC
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t Fails, expected : %lx --- actual : %lx"
argument_list|,
literal|0xCCCC
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"OK\n\t DMA input ..."
argument_list|)
expr_stmt|;
name|dmain
label|:
name|dr
operator|->
name|dr_data
operator|=
literal|0x1111
expr_stmt|;
comment|/* DMA input data */
comment|/* Setup normal DMA */
name|addr
operator|=
operator|(
name|long
operator|)
name|vtoph
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|tstpat
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_walo
operator|=
operator|(
name|addr
operator|>>
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|dr
operator|->
name|dr_wahi
operator|=
operator|(
name|addr
operator|>>
literal|17
operator|)
operator|&
literal|0x7fff
expr_stmt|;
name|dr
operator|->
name|dr_range
operator|=
name|DMATBL
operator|-
literal|1
expr_stmt|;
name|dr
operator|->
name|dr_addmod
operator|=
operator|(
name|char
operator|)
name|DRADDMOD
expr_stmt|;
name|dr
operator|->
name|dr_cstat
operator|=
name|FCN1
expr_stmt|;
comment|/* Set FCN1 in ICR to DMA in*/
if|if
condition|(
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_LOOPTST
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Use pulse reg */
name|dr
operator|->
name|dr_pulse
operator|=
name|RDMA
operator||
name|RATN
operator||
name|RMSK
operator||
name|CYCL
operator||
name|GO
expr_stmt|;
comment|/* Wait for DMA complete; REDY and DMAF are true in ISR */
name|wait
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|result
operator|=
operator|(
name|dr
operator|->
name|dr_cstat
operator|&
operator|(
name|REDY
operator||
name|DMAF
operator|)
operator|)
operator|)
operator|!=
operator|(
name|REDY
operator||
name|DMAF
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n\tWait for DMA to complete...ISR:%lx"
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|wait
operator|>
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t DMA input timeout!!, ISR:%lx"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
comment|/* Enable DMA e-o-r interrupt */
name|dr
operator|->
name|dr_pulse
operator|=
name|IENB
operator||
name|RDMA
operator||
name|RATN
operator||
name|CYCL
operator||
name|GO
expr_stmt|;
comment|/* Wait for DMA complete; DR_LOOPTST is false in dra->dr_flags*/
name|wait
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_LOOPTST
condition|)
block|{
name|result
operator|=
name|dr
operator|->
name|dr_cstat
operator|&
literal|0xffff
expr_stmt|;
name|printf
argument_list|(
literal|"\n\tWait for DMA e-o-r intr...ISR:%lx"
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|wait
operator|>
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t DMA e-o-r timeout!!, ISR:%lx"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_LOOPTST
expr_stmt|;
return|return;
block|}
block|}
name|dra
operator|->
name|dr_flags
operator||=
name|DR_LOOPTST
expr_stmt|;
block|}
name|mtpr
argument_list|(
name|P1DC
argument_list|,
name|tstpat
argument_list|)
expr_stmt|;
comment|/* Purge cache */
name|mtpr
argument_list|(
name|P1DC
argument_list|,
literal|0x3ff
operator|+
name|tstpat
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|DMATBL
condition|;
name|ix
operator|++
control|)
block|{
if|if
condition|(
name|tstpat
index|[
name|ix
index|]
operator|!=
literal|0x1111
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t Fails, ix:%d, expected:%x --- actual:%x"
argument_list|,
name|ix
argument_list|,
literal|0x1111
argument_list|,
name|tstpat
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_LOOPTST
operator|)
operator|==
literal|0
condition|)
block|{
name|dra
operator|->
name|dr_flags
operator||=
name|DR_LOOPTST
expr_stmt|;
name|printf
argument_list|(
literal|" OK..\n\tDMA end of range interrupt..."
argument_list|)
expr_stmt|;
goto|goto
name|dmain
goto|;
block|}
name|printf
argument_list|(
literal|" OK..\n\tAttention interrupt...."
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_pulse
operator|=
name|IENB
operator||
name|RDMA
expr_stmt|;
name|dr
operator|->
name|dr_pulse
operator|=
name|FCN2
expr_stmt|;
comment|/* Wait for ATTN interrupt; DR_LOOPTST is false in dra->dr_flags*/
name|wait
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_LOOPTST
condition|)
block|{
name|result
operator|=
name|dr
operator|->
name|dr_cstat
operator|&
literal|0xffff
expr_stmt|;
name|printf
argument_list|(
literal|"\n\tWait for Attention intr...ISR:%lx"
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|wait
operator|>
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t Attention interrupt timeout!!, ISR:%lx"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_LOOPTST
expr_stmt|;
return|return;
block|}
block|}
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_LOOPTST
expr_stmt|;
name|printf
argument_list|(
literal|" OK..\n\tDone..."
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Reset state on Unibus reset */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|drreset
argument_list|(
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{  }
end_block

begin_comment
comment|/*  * An interrupt is caused either by an error,  * base address overflow, or transfer complete  */
end_comment

begin_macro
name|drintr
argument_list|(
argument|dr11
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dr11
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
init|=
operator|&
name|dr_aux
index|[
name|dr11
index|]
decl_stmt|;
specifier|register
name|struct
name|rsdevice
modifier|*
name|rsaddr
init|=
name|RSADDR
argument_list|(
name|dr11
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|short
name|status
decl_stmt|;
name|status
operator|=
name|rsaddr
operator|->
name|dr_cstat
operator|&
literal|0xffff
expr_stmt|;
comment|/* get board status register */
name|dra
operator|->
name|dr_istat
operator|=
name|status
expr_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|2
condition|)
name|printf
argument_list|(
literal|"\ndrintr: dr11 status : %lx"
argument_list|,
name|status
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_LOOPTST
condition|)
block|{
comment|/* doing loopback test */
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_LOOPTST
expr_stmt|;
return|return;
block|}
comment|/* 	 * Make sure this is not a stray interrupt; at least one of dmaf or attf 	 * must be set. Note that if the dr11 interrupt enable latch is reset  	 * during a hardware interrupt ack sequence, and by the we get to this  	 * point in the interrupt code it will be 0. This is done to give the 	 * programmer some control over how the two more-or-less independent 	 * interrupt sources on the board are handled. 	 * If the attention flag is set when drstrategy() is called to start a 	 * dma read or write an interrupt will be generated as soon as the 	 * strategy routine enables interrupts for dma end-of-range. This will 	 * cause execution of the interrupt routine (not necessarily bad) and 	 * will cause the interrupt enable mask to be reset (very bad since the 	 * dma end-of-range condition will not be able to generate an interrupt 	 * when it occurs) causing the dma operation to time-out (even though 	 * the dma transfer will be done successfully) or hang the process if a 	 * software time-out capability is not implemented. One way to avoid  	 * this situation is to check for a pending attention interrupt (attf 	 * set) by calling drioctl() before doing a read or a write. For the 	 * time being this driver will solve the problem by clearing the attf 	 * flag in the status register before enabling interrupts in 	 * drstrategy(). 	 * 	 * **** The IKON 10084 for which this driver is written will set both 	 * attf and dmaf if dma is terminated by an attention pulse. This will 	 * cause a wakeup(&dr_aux), which will be ignored since it is not being  	 * waited on, and an iodone(bp) which is the desired action. Some other 	 * dr11 emulators, in particular the IKON 10077 for the Multibus, donot 	 * dmaf in this case. This may require some addtional code in the inter- 	 * rupt routine to ensure that en iodone(bp) is issued when dma is term- 	 * inated by attention. 	 */
name|bp
operator|=
name|dra
operator|->
name|dr_actf
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|ATTF
operator||
name|DMAF
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dr%d: stray interrupt, status=%x"
argument_list|,
name|dr11
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|status
operator|&
name|DMAF
condition|)
block|{
comment|/* End-of-range interrupt */
name|dra
operator|->
name|dr_flags
operator||=
name|DR_DMAX
expr_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|2
condition|)
name|printf
argument_list|(
literal|"\ndrintr: e-o-r interrupt,cstat:%lx,dr_flags:%lx"
argument_list|,
name|status
operator|&
literal|0xffff
argument_list|,
name|dra
operator|->
name|dr_flags
operator|&
name|DR_ACTV
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_ACTV
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We are not doing DMA !! */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dra
operator|->
name|dr_op
operator|==
name|DR_READ
condition|)
name|mtpr
argument_list|(
name|P1DC
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
expr_stmt|;
name|dra
operator|->
name|dr_bycnt
operator|-=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|dra
operator|->
name|dr_bycnt
operator|>
literal|0
condition|)
block|{
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
operator|(
name|dra
operator|->
name|dr_bycnt
operator|>
name|NBPG
operator|)
condition|?
name|NBPG
else|:
name|dra
operator|->
name|dr_bycnt
expr_stmt|;
name|drstart
argument_list|(
name|rsaddr
argument_list|,
name|dra
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_ACTV
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dra
argument_list|)
expr_stmt|;
comment|/* Wakeup waiting in drwait() */
name|rsaddr
operator|->
name|dr_pulse
operator|=
operator|(
name|RPER
operator||
name|RDMA
operator||
name|RATN
operator|)
expr_stmt|;
comment|/* reset dma e-o-r flag */
block|}
comment|/* 	 * Now test for attention interrupt -- It may be set in addition to  	 * the dma e-o-r interrupt. If we get one we will issue a wakeup to 	 * the drioctl() routine which is presumable waiting for one. 	 * The program may have to monitor the attention interrupt received 	 * flag in addition to doing waits for the interrupt. Futhermore,  	 * interrupts are not enabled unless dma is in progress or drioctl() 	 * has been called to wait for attention -- this may produce some 	 * strange results if attf is set on the dr11 when a read or a write 	 * is initiated, since that will enables interrupts. 	 * **** The appropriate code for this interrupt routine will probably 	 * be rather application dependent. 	 */
if|if
condition|(
name|status
operator|&
name|ATTF
condition|)
block|{
name|dra
operator|->
name|dr_flags
operator||=
name|DR_ATRX
expr_stmt|;
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_ATWT
expr_stmt|;
name|rsaddr
operator|->
name|dr_cstat
operator|=
name|RATN
expr_stmt|;
comment|/* reset attention flag */
comment|/* 		 * Some applications which use attention to terminate 		 * dma may also want to issue an iodone() here to 		 * wakeup physio(). 		 */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dra
operator|->
name|dr_cmd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|unsigned
name|drminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
literal|65536
condition|)
name|bp
operator|->
name|b_bcount
operator|=
literal|65536
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine performs the device unique operations on the DR11W  * it is passed as an argument to and invoked by physio  */
end_comment

begin_expr_stmt
name|drstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rsdevice
modifier|*
name|rsaddr
init|=
name|RSADDR
argument_list|(
name|unit
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
init|=
operator|&
name|dr_aux
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|ok
decl_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
specifier|register
name|char
modifier|*
name|caddr
decl_stmt|;
name|long
name|drva
parameter_list|()
function_decl|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Device not open */
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|dra
operator|->
name|dr_flags
operator|&
name|DR_ACTV
condition|)
comment|/* Device is active; should never be in here... */
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dra
operator|->
name|dr_flags
argument_list|,
name|DRPRI
argument_list|,
name|devio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dra
operator|->
name|dr_actf
operator|=
name|bp
expr_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
name|drva
argument_list|(
name|dra
argument_list|,
name|bp
operator|->
name|b_proc
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dra
operator|->
name|dr_oba
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
comment|/* Save original addr, count */
name|dra
operator|->
name|dr_obc
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|dra
operator|->
name|dr_bycnt
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
comment|/* Save xfer count used by drintr() */
if|if
condition|(
operator|(
operator|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|&
literal|0x3fffffff
operator|)
operator|>>
name|PGSHIFT
operator|)
operator|!=
operator|(
operator|(
operator|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|&
literal|0x3fffffff
operator|)
operator|+
name|bp
operator|->
name|b_bcount
operator|)
operator|>>
name|PGSHIFT
operator|)
condition|)
name|bp
operator|->
name|b_bcount
operator|=
name|NBPG
operator|-
operator|(
operator|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|)
operator|&
name|PGOFSET
operator|)
expr_stmt|;
name|dra
operator|->
name|dr_flags
operator||=
name|DR_ACTV
expr_stmt|;
comment|/* Mark active (use in intr handler) */
name|s
operator|=
name|SPL_UP
argument_list|()
expr_stmt|;
name|drstart
argument_list|(
name|rsaddr
argument_list|,
name|dra
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ok
operator|=
name|drwait
argument_list|(
name|rsaddr
argument_list|,
name|dra
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|0x40
condition|)
block|{
name|caddr
operator|=
operator|(
name|char
operator|*
operator|)
name|dra
operator|->
name|dr_oba
expr_stmt|;
if|if
condition|(
name|dra
operator|->
name|dr_op
operator|==
name|DR_READ
condition|)
name|printf
argument_list|(
literal|"\nAfter read: (%lx)(%lx)"
argument_list|,
name|caddr
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|,
name|caddr
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dra
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_ACTV
expr_stmt|;
comment|/* Clear active flag */
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
name|dra
operator|->
name|dr_oba
expr_stmt|;
comment|/* Restore original addr, count */
name|bp
operator|->
name|b_bcount
operator|=
name|dra
operator|->
name|dr_obc
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* Mark buffer B_DONE,so physstrat() in ml/machdep.c won't sleep */
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dra
operator|->
name|dr_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Return to the calling program (physio()). Physio() will sleep 	 * until awaken by a call to iodone() in the interupt handler -- 	 * which will be called by the dispatcher when it receives dma 	 * end-of-range interrupt. 	 */
block|}
end_block

begin_expr_stmt
name|drwait
argument_list|(
name|rs
argument_list|,
name|dr
argument_list|)
specifier|register
expr|struct
name|rsdevice
operator|*
name|rs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|dr_aux
modifier|*
name|dr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|SPL_UP
argument_list|()
expr_stmt|;
while|while
condition|(
name|dr
operator|->
name|dr_flags
operator|&
name|DR_ACTV
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dr
argument_list|,
name|DRPRI
argument_list|,
name|devio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_flags
operator|&
name|DR_TMDM
condition|)
block|{
comment|/* DMA timed out */
name|dr
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_TMDM
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|rs
operator|->
name|dr_cstat
operator|&
operator|(
name|PERR
operator||
name|BERR
operator||
name|TERR
operator|)
condition|)
block|{
name|dr
operator|->
name|dr_actf
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dr
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_DMAX
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  * The lower 8-bit of tinfo is the minor device number, the  * remaining higher 8-bit is the current timout number  */
end_comment

begin_expr_stmt
name|drrwtimo
argument_list|(
name|tinfo
argument_list|)
specifier|register
name|u_long
name|tinfo
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|long
name|unit
init|=
name|tinfo
operator|&
literal|0xff
decl_stmt|;
specifier|register
name|struct
name|dr_aux
modifier|*
name|dr
init|=
operator|&
name|dr_aux
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|rsdevice
modifier|*
name|rs
init|=
name|dr
operator|->
name|dr_addr
decl_stmt|;
comment|/* 	 * If this is not the timeout that drwrite/drread is waiting 	 * for then we should just go away 	 */
if|if
condition|(
operator|(
name|tinfo
operator|&
operator|~
literal|0xff
operator|)
operator|!=
operator|(
name|dr
operator|->
name|currenttimo
operator|<<
literal|8
operator|)
condition|)
return|return;
comment|/* Mark the device timed out */
name|dr
operator|->
name|dr_flags
operator||=
name|DR_TMDM
expr_stmt|;
name|dr
operator|->
name|dr_flags
operator|&=
operator|~
name|DR_ACTV
expr_stmt|;
name|rs
operator|->
name|dr_pulse
operator|=
name|RMSK
expr_stmt|;
comment|/* Inihibit interrupt */
name|rs
operator|->
name|dr_pulse
operator|=
operator|(
name|RPER
operator||
name|RDMA
operator||
name|RATN
operator||
name|IENB
operator|)
expr_stmt|;
comment|/* Clear DMA logic */
comment|/* 	 * Some applications will not issue a master after dma timeout, 	 * since doing so sends an INIT H pulse to the external device, 	 * which may produce undesirable side-effects. 	 */
comment|/* Wake up process waiting in drwait() and flag the error */
name|dr
operator|->
name|dr_actf
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dr
operator|->
name|dr_cmd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Kick the driver every second  */
end_comment

begin_macro
name|drtimo
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|RSUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|dr_aux
modifier|*
name|dr
decl_stmt|;
name|dr
operator|=
operator|&
name|dr_aux
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_flags
operator|&
name|DR_OPEN
condition|)
name|timeout
argument_list|(
name|drtimo
argument_list|,
operator|(
name|caddr_t
operator|)
name|dev
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dr
argument_list|)
expr_stmt|;
comment|/* Wakeup any process waiting for interrupt */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DR_DEBUG
end_ifdef

begin_macro
name|drva
argument_list|(
argument|dra
argument_list|,
argument|p
argument_list|,
argument|va
argument_list|,
argument|bcnt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|va
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|bcnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|first
decl_stmt|,
name|last
decl_stmt|,
name|np
decl_stmt|;
if|if
condition|(
name|DR11
operator|&
literal|0x20
condition|)
block|{
name|first
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
name|vtoph
argument_list|(
name|p
argument_list|,
operator|(
name|unsigned
operator|)
name|va
argument_list|)
argument_list|)
operator|)
operator|>>
literal|10
expr_stmt|;
name|last
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
name|vtoph
argument_list|(
name|p
argument_list|,
operator|(
name|unsigned
operator|)
name|va
operator|+
name|bcnt
argument_list|)
argument_list|)
operator|)
operator|>>
literal|10
expr_stmt|;
name|np
operator|=
name|bcnt
operator|/
literal|0x3ff
expr_stmt|;
name|printf
argument_list|(
literal|"\ndrva: (op:%ld)(first:%ld)(last:%ld)(np:%ld)(cnt:%ld)"
argument_list|,
name|dra
operator|->
name|dr_op
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|np
argument_list|,
name|bcnt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|drstart
argument_list|(
name|rsaddr
argument_list|,
name|dra
argument_list|,
name|bp
argument_list|)
specifier|register
expr|struct
name|rsdevice
operator|*
name|rsaddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|dr_aux
modifier|*
name|dra
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|addr
decl_stmt|;
name|u_short
name|go
decl_stmt|;
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|dra
operator|->
name|dr_op
operator|==
name|DR_READ
operator|&&
operator|(
name|DR11
operator|&
literal|8
operator|)
condition|)
block|{
name|char
modifier|*
name|caddr
init|=
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
decl_stmt|;
name|printf
argument_list|(
literal|"\ndrstart: READ, bcnt:%ld"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|",(%lx)(%lx)"
argument_list|,
name|caddr
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|,
name|caddr
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* we are doing raw IO, bp->b_un.b_addr is user's address */
name|addr
operator|=
operator|(
name|long
operator|)
name|vtoph
argument_list|(
name|bp
operator|->
name|b_proc
argument_list|,
operator|(
name|unsigned
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Set DMA address into DR11 interace registers: DR11 requires that 	 * the address be right shifted 1 bit position before it is written 	 * to the board (The board will left shift it one bit position before 	 * it places the address on the bus 	 */
name|rsaddr
operator|->
name|dr_walo
operator|=
operator|(
name|addr
operator|>>
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|rsaddr
operator|->
name|dr_wahi
operator|=
operator|(
name|addr
operator|>>
literal|17
operator|)
operator|&
literal|0x7fff
expr_stmt|;
comment|/* Set DMA range count: (number of words - 1) */
name|rsaddr
operator|->
name|dr_range
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|>>
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Set address modifier code to be used for DMA access to memory */
name|rsaddr
operator|->
name|dr_addmod
operator|=
name|DRADDMOD
expr_stmt|;
comment|/* 	 * Now determine whether this is a read or a write. ***** This is 	 * probably only usefull for link mode operation, since dr11 doesnot 	 * controll the direction of data transfer. The C1 control input  	 * controls whether the hardware is doing a read or a write. In link 	 * mode this is controlled by function 1 latch (looped back by the 	 * cable) and could be set the program. In the general case, the dr11 	 * doesnot know in advance what the direction of transfer is - although 	 * the program and protocol logic probably is 	 */
ifdef|#
directive|ifdef
name|DR_DEBUG
if|if
condition|(
name|DR11
operator|&
literal|1
condition|)
name|printf
argument_list|(
literal|"\ndrstrat: about to GO..,dr_cmd:%lx,drstat:%lx,drcnt:%ld,cdata:%lx,OP:%ld"
argument_list|,
name|dra
operator|->
name|dr_cmd
argument_list|,
name|rsaddr
operator|->
name|dr_cstat
argument_list|,
name|rsaddr
operator|->
name|dr_range
argument_list|,
name|rsaddr
operator|->
name|dr_data
argument_list|,
name|dra
operator|->
name|dr_op
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Update function latches may have been done already by drioctl() if 	 * request from drioctl() 	 */
if|if
condition|(
name|dra
operator|->
name|dr_cmd
operator|&
name|DR_DFCN
condition|)
block|{
comment|/* deferred function write */
name|dra
operator|->
name|dr_cmd
operator|&=
operator|~
name|DR_DFCN
expr_stmt|;
comment|/* Clear request */
name|go
operator|=
name|dra
operator|->
name|dr_cmd
operator|&
name|DR_FMSK
expr_stmt|;
comment|/* mask out fcn bits */
name|rsaddr
operator|->
name|dr_cstat
operator|=
name|go
expr_stmt|;
comment|/* Write it to the board */
block|}
comment|/* Clear dmaf and attf to assure a clean dma start */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|RATN
operator||
name|RDMA
operator||
name|RPER
expr_stmt|;
name|rsaddr
operator|->
name|dr_cstat
operator|=
name|IENB
operator||
name|GO
operator||
name|CYCL
operator||
name|dra
operator|->
name|dr_op
expr_stmt|;
comment|/* GO...... */
comment|/* 	 * Now check for software cycle request -- usually 	 * by transmitter in link mode. 	 */
if|if
condition|(
name|dra
operator|->
name|dr_cmd
operator|&
name|DR_PCYL
condition|)
block|{
name|dra
operator|->
name|dr_cmd
operator|&=
operator|~
name|DR_PCYL
expr_stmt|;
comment|/* Clear request */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|CYCL
expr_stmt|;
comment|/* Use pulse register again */
block|}
comment|/* 	 * Now check for deferred ACLO FCNT2 pulse request -- usually to tell 	 * the transmitter (via its attention) that we have enabled dma. 	 */
if|if
condition|(
name|dra
operator|->
name|dr_cmd
operator|&
name|DR_DACL
condition|)
block|{
name|dra
operator|->
name|dr_cmd
operator|&=
operator|~
name|DR_DACL
expr_stmt|;
comment|/* Clear request */
name|rsaddr
operator|->
name|dr_pulse
operator|=
name|FCN2
expr_stmt|;
comment|/* Use pulse register again */
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|NDR
end_endif

end_unit

