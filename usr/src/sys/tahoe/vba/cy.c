begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	cy.c	1.3	86/01/12	*/
end_comment

begin_include
include|#
directive|include
file|"cy.h"
end_include

begin_if
if|#
directive|if
name|NCY
operator|>
literal|0
end_if

begin_comment
comment|/*  * Cipher Tapemaster driver.  */
end_comment

begin_decl_stmt
name|int
name|cydebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"../tahoe/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"signal.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"mtio.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"../tahoevba/cyreg.h"
end_include

begin_define
define|#
directive|define
name|MAXCONTROLLERS
value|4
end_define

begin_define
define|#
directive|define
name|MAX_BLOCKSIZE
value|(TBUFSIZ*NBPG)
end_define

begin_define
define|#
directive|define
name|NUM_UNIT
value|(NCY * 4)
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|RETRY
value|1
end_define

begin_define
define|#
directive|define
name|EXTEND
value|2
end_define

begin_define
define|#
directive|define
name|FATAL
value|3
end_define

begin_define
define|#
directive|define
name|MAINTAIN_POSITION
value|0
end_define

begin_define
define|#
directive|define
name|DONT_MAINTAIN_POSITION
value|1
end_define

begin_define
define|#
directive|define
name|PROCESSED
value|0x80000000
end_define

begin_define
define|#
directive|define
name|SLEEPING
value|0x80000000
end_define

begin_define
define|#
directive|define
name|b_cmd
value|av_back
end_define

begin_comment
comment|/* only unused word in request */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|cywrite_filemark
argument_list|()
decl_stmt|,
name|cysearch_fm_forw
argument_list|()
decl_stmt|,
name|cysearch_fm_back
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cy_space_forw
argument_list|()
decl_stmt|,
name|cy_space_back
argument_list|()
decl_stmt|,
name|cyrewind_tape_ta
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cyrewind_tape_unl
argument_list|()
decl_stmt|,
name|cydrive_status
argument_list|()
decl_stmt|,
name|cyrewind_tape_ov
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cyraw_read
argument_list|()
decl_stmt|,
name|cyraw_write
argument_list|()
decl_stmt|,
name|cybuf_read
argument_list|()
decl_stmt|,
name|cybuf_write
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cywait_until_ready
argument_list|()
decl_stmt|,
name|cywrite_0_fm
argument_list|()
decl_stmt|,
name|cywrite_1_fm
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cywrite_2_fm
argument_list|()
decl_stmt|,
name|cyno_op
argument_list|()
decl_stmt|,
name|cywrite_eov
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|cmd_tbl
index|[
literal|15
index|]
function_decl|)
parameter_list|()
init|=
block|{
name|cywrite_filemark
operator|,
define|#
directive|define
name|DO_W_FM
value|0
function_decl|cysearch_fm_forw
operator|,
define|#
directive|define
name|DO_SFMF
value|1
function_decl|cysearch_fm_back
operator|,
define|#
directive|define
name|DO_SFMB
value|2
function_decl|cy_space_forw
operator|,
define|#
directive|define
name|DO_SPF
value|3
function_decl|cy_space_back
operator|,
define|#
directive|define
name|DO_SPB
value|4
function_decl|cyrewind_tape_ta
operator|,
define|#
directive|define
name|DO_RWTA
value|5
function_decl|cyrewind_tape_unl
operator|,
define|#
directive|define
name|DO_RWUN
value|6
function_decl|cydrive_status
operator|,
define|#
directive|define
name|DO_STAT
value|7
function_decl|cyrewind_tape_ov
operator|,
define|#
directive|define
name|DO_RWOV
value|8
function_decl|cywait_until_ready
operator|,
define|#
directive|define
name|DO_WAIT
value|9
function_decl|cywrite_eov
operator|,
define|#
directive|define
name|DO_WEOV
value|10
function_decl|cyraw_read
operator|,
define|#
directive|define
name|DO_RRD
value|11
function_decl|cyraw_write
operator|,
define|#
directive|define
name|DO_RWT
value|12
function_decl|cybuf_read
operator|,
define|#
directive|define
name|DO_BRD
value|13
function_decl|cybuf_write
end_function_decl

begin_define
define|#
directive|define
name|DO_BWT
value|14
end_define

begin_if
unit|};
if|#
directive|if
name|NCY
operator|>
literal|0
end_if

begin_decl_stmt
specifier|extern
name|char
name|cy0utl
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NCY
operator|>
literal|1
end_if

begin_decl_stmt
specifier|extern
name|char
name|cy1utl
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|cyminfo
index|[
name|NCY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|cydinfo
index|[
name|NUM_UNIT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cystd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cyprobe
argument_list|()
decl_stmt|,
name|cyslave
argument_list|()
decl_stmt|,
name|cyattach
argument_list|()
decl_stmt|,
name|cydgo
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|cydriver
init|=
block|{
name|cyprobe
block|,
name|cyslave
block|,
name|cyattach
block|,
name|cydgo
block|,
name|cystd
block|,
literal|"yc"
block|,
name|cydinfo
block|,
literal|"cy"
block|,
name|cyminfo
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|fmt_scp
modifier|*
name|cyscp
index|[]
init|=
block|{
operator|(
name|fmt_scp
operator|*
operator|)
literal|0xc0000c06
block|,
operator|(
name|fmt_scp
operator|*
operator|)
literal|0xc0000c16
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|unsigned
name|cyminsize
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Per-controller data structure.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|pte
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|utl
decl_stmt|;
name|int
function_decl|(
modifier|*
name|interupt_path
function_decl|)
parameter_list|()
function_decl|;
name|label_t
name|environ
decl_stmt|;
comment|/* Environment variable for longjmps */
name|struct
name|buf
modifier|*
name|my_request
decl_stmt|;
name|struct
name|buf
modifier|*
name|wakeup_request
decl_stmt|;
name|short
name|bs
decl_stmt|;
comment|/* buffer size */
name|fmt_ccb
name|ccb
decl_stmt|;
comment|/* Channel control blocks */
name|fmt_scb
name|scb
decl_stmt|;
comment|/* System configuration blocks */
name|fmt_tpb
name|tpb
decl_stmt|;
comment|/* Tape parameter blocks */
name|fmt_tpb
name|last
decl_stmt|;
comment|/* Tape parameter blocks */
name|fmt_tpb
name|noop
decl_stmt|;
comment|/* Tape parameter blocks */
name|long
name|rawbuf
index|[
name|MAX_BLOCKSIZE
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|ctlr_tab
typedef|;
end_typedef

begin_function_decl
specifier|extern
name|int
name|cy_normal_path
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|ctlr_tab
name|ctlr_info
index|[
name|NCY
index|]
init|=
block|{
if|#
directive|if
name|NCY
operator|>
literal|0
block|{
name|CY0map
block|,
name|cy0utl
block|,
name|cy_normal_path
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|NCY
operator|>
literal|1
block|{
name|CY1map
block|,
name|cy1utl
block|,
name|cy_normal_path
block|}
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Per-drive information.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
function_decl|(
modifier|*
name|cleanup
function_decl|)
parameter_list|()
function_decl|;
name|struct
name|buf
name|u_queue
decl_stmt|;
name|struct
name|buf
name|rawbp
decl_stmt|;
name|long
name|blkno
decl_stmt|;
name|long
name|file_number
decl_stmt|;
name|short
name|last_control
decl_stmt|;
name|short
name|last_status
decl_stmt|;
name|short
name|last_resid
decl_stmt|;
name|unsigned
name|long
name|bad_count
decl_stmt|;
name|unsigned
name|control_proto
range|:
literal|16
decl_stmt|;
name|unsigned
name|error_count
range|:
literal|8
decl_stmt|;
name|unsigned
name|open
range|:
literal|1
decl_stmt|;
name|unsigned
name|eof
range|:
literal|1
decl_stmt|;
name|unsigned
name|bot
range|:
literal|1
decl_stmt|;
name|unsigned
name|eot
range|:
literal|1
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
block|}
name|unit_tab
typedef|;
end_typedef

begin_decl_stmt
name|unit_tab
name|unit_info
index|[
name|NUM_UNIT
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|cyprobe
argument_list|(
argument|reg
argument_list|,
argument|vm
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|vm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|br
operator|,
name|cvec
expr_stmt|;
comment|/* must be r12, r11 */
if|if
condition|(
name|badcyaddr
argument_list|(
name|reg
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|br
operator|=
literal|0x13
operator|,
name|cvec
operator|=
literal|0x80
expr_stmt|;
comment|/* XXX */
return|return
operator|(
sizeof|sizeof
argument_list|(
name|caddr_t
argument_list|)
operator|)
return|;
comment|/* XXX */
block|}
end_block

begin_comment
comment|/*  * Check to see if a drive is attached to a controller.  * Since we can only tell that a drive is there if a tape is loaded and  * the drive is placed online, we always indicate the slave is present.  */
end_comment

begin_macro
name|cyslave
argument_list|(
argument|vi
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|lint
name|vi
operator|=
name|vi
expr_stmt|;
name|addr
operator|=
name|addr
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* THIS NEEDS TO BE REWRITTEN TO MOVE STUFF TO CYPROBE */
end_comment

begin_macro
name|cyattach
argument_list|(
argument|vi
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|vi
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|vi
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|cq
init|=
operator|&
name|vi
operator|->
name|ui_mi
operator|->
name|um_tab
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|uq
init|=
name|cq
operator|->
name|b_forw
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|start_queue
init|=
name|uq
decl_stmt|;
operator|(
name|void
operator|)
name|cy_init_controller
argument_list|(
name|vi
operator|->
name|ui_addr
argument_list|,
name|vi
operator|->
name|ui_ctlr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Add unit to controllers queue */
if|if
condition|(
name|cq
operator|->
name|b_forw
operator|==
name|NULL
condition|)
block|{
name|cq
operator|->
name|b_forw
operator|=
operator|&
name|ui
operator|->
name|u_queue
expr_stmt|;
name|ui
operator|->
name|u_queue
operator|.
name|b_forw
operator|=
operator|&
name|ui
operator|->
name|u_queue
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|uq
operator|->
name|b_forw
operator|!=
name|start_queue
condition|)
name|uq
operator|=
name|uq
operator|->
name|b_forw
expr_stmt|;
name|ui
operator|->
name|u_queue
operator|.
name|b_forw
operator|=
name|start_queue
expr_stmt|;
name|uq
operator|->
name|b_forw
operator|=
operator|&
name|ui
operator|->
name|u_queue
expr_stmt|;
block|}
name|ui
operator|->
name|cleanup
operator|=
name|cyno_op
expr_stmt|;
name|ui
operator|->
name|last_status
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|last_control
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|file_number
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|bad_count
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|open
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|bot
operator|=
literal|1
expr_stmt|;
name|ui
operator|->
name|eot
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|eof
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|message
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialize the controller after a controller reset or  * during autoconfigure.  All of the system control blocks  * are initialized and the controller is asked to configure  * itself for later use.  */
end_comment

begin_macro
name|cy_init_controller
argument_list|(
argument|addr
argument_list|,
argument|ctlr
argument_list|,
argument|print
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ctlr
decl_stmt|,
name|print
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|pte
decl_stmt|;
specifier|register
name|fmt_scp
modifier|*
name|SCP
decl_stmt|;
specifier|register
name|fmt_scb
modifier|*
name|SCB
decl_stmt|;
specifier|register
name|fmt_ccb
modifier|*
name|CCB
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
decl_stmt|;
comment|/* 	 * Initialize the system configuration pointer. 	 */
name|SCP
operator|=
name|cyscp
index|[
name|ctlr
index|]
expr_stmt|;
comment|/* make kernel writable */
name|pte
operator|=
operator|(
name|int
operator|*
operator|)
name|vtopte
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|,
name|btop
argument_list|(
name|SCP
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|&=
operator|~
name|PG_PROT
expr_stmt|;
operator|*
name|pte
operator||=
name|PG_KW
expr_stmt|;
name|mtpr
argument_list|(
name|TBIS
argument_list|,
name|SCP
argument_list|)
expr_stmt|;
comment|/* load the correct values in the scp */
name|SCP
operator|->
name|bus_size
operator|=
name|_16_BITS
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
operator|.
name|scb
argument_list|,
name|SCP
operator|->
name|scb_ptr
argument_list|)
expr_stmt|;
comment|/* put it back to read-only */
operator|*
name|pte
operator|&=
operator|~
name|PG_PROT
expr_stmt|;
operator|*
name|pte
operator||=
name|PG_KR
expr_stmt|;
name|mtpr
argument_list|(
name|TBIS
argument_list|,
name|SCP
argument_list|)
expr_stmt|;
comment|/* 	 * Init system configuration block. 	 */
name|SCB
operator|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
operator|.
name|scb
expr_stmt|;
name|SCB
operator|->
name|fixed_value
operator|=
literal|0x3
expr_stmt|;
comment|/* set pointer to the channel control block */
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
operator|.
name|ccb
argument_list|,
name|SCB
operator|->
name|ccb_ptr
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the chanel control block. 	 */
name|CCB
operator|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
operator|.
name|ccb
expr_stmt|;
name|CCB
operator|->
name|ccw
operator|=
name|CLEAR_INTERUPT
expr_stmt|;
name|CCB
operator|->
name|gate
operator|=
name|GATE_OPEN
expr_stmt|;
comment|/* set pointer to the tape parameter block */
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
operator|.
name|tpb
argument_list|,
name|CCB
operator|->
name|tpb_ptr
argument_list|)
expr_stmt|;
comment|/* 	 * Issue a noop cmd and get the internal buffer size for buffered i/o. 	 */
name|ci
operator|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
expr_stmt|;
comment|/* set command to be CONFIGURE */
name|ci
operator|->
name|tpb
operator|.
name|cmd
operator|=
name|NO_OP
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|control
operator|=
name|CW_16bits
expr_stmt|;
name|ci
operator|->
name|ccb
operator|.
name|gate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|CY_ATTENTION
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* execute! */
if|if
condition|(
name|cywait
argument_list|(
operator|&
name|ci
operator|->
name|ccb
argument_list|)
operator|||
operator|(
name|ci
operator|->
name|tpb
operator|.
name|status
operator|&
name|CS_ERm
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"cy%d: time-out during init\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ci
operator|->
name|tpb
operator|.
name|cmd
operator|=
name|CONFIG
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|control
operator|=
name|CW_16bits
expr_stmt|;
name|ci
operator|->
name|ccb
operator|.
name|gate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|CY_ATTENTION
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* execute! */
if|if
condition|(
name|cywait
argument_list|(
operator|&
name|ci
operator|->
name|ccb
argument_list|)
operator|||
operator|(
name|ci
operator|->
name|tpb
operator|.
name|status
operator|&
name|CS_ERm
operator|)
condition|)
block|{
name|cyprint_err
argument_list|(
literal|"Tapemaster configuration failure"
argument_list|,
literal|0
argument_list|,
name|ci
operator|->
name|tpb
operator|.
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|uncache
argument_list|(
operator|&
name|ci
operator|->
name|tpb
operator|.
name|count
argument_list|)
expr_stmt|;
name|ci
operator|->
name|bs
operator|=
name|MULTIBUS_SHORT
argument_list|(
name|ci
operator|->
name|tpb
operator|.
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|print
condition|)
name|printf
argument_list|(
literal|"cy%d: %dKb buffer\n"
argument_list|,
name|ctlr
argument_list|,
name|ci
operator|->
name|bs
operator|/
literal|1024
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|cydgo
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_comment
comment|/* macro to pack the unit number into Tapemaster format */
end_comment

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|unit
parameter_list|)
define|\
value|(((cydinfo[unit]->ui_slave& 1)<< 11) | \      ((cydinfo[unit]->ui_slave& 2)<< 9) | \      ((cydinfo[unit]->ui_slave& 4)>> 2))
end_define

begin_expr_stmt
name|cyopen
argument_list|(
name|dev
argument_list|,
name|flag
argument_list|)
specifier|register
name|int
name|flag
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NUM_UNIT
operator|||
name|cydinfo
index|[
name|unit
index|]
operator|==
literal|0
operator|||
operator|(
name|ui
operator|=
operator|&
name|unit_info
index|[
name|unit
index|]
operator|)
operator|->
name|open
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ui
operator|->
name|control_proto
operator|=
name|UNIT
argument_list|(
name|unit
argument_list|)
operator||
name|CW_INTR
operator||
name|CW_16bits
expr_stmt|;
name|ui
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|bad_count
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|eof
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|open
operator|=
literal|1
expr_stmt|;
name|cycmd
argument_list|(
name|dev
argument_list|,
name|DO_WAIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* wait for tape to rewind */
if|if
condition|(
operator|(
name|ui
operator|->
name|last_status
operator|&
name|CS_OL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* not on-line */
name|ui
operator|->
name|open
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|ui
operator|->
name|last_status
operator|&
name|CS_P
operator|)
condition|)
block|{
name|uprintf
argument_list|(
literal|"cy%d: write protected\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ui
operator|->
name|open
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|ui
operator|->
name|last_status
operator|&
name|CS_LP
condition|)
block|{
name|ui
operator|->
name|file_number
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|bot
operator|=
literal|1
expr_stmt|;
name|ui
operator|->
name|eof
operator|=
name|ui
operator|->
name|eot
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|cyclose
argument_list|(
name|dev
argument_list|,
name|flag
argument_list|)
specifier|register
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|flag
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|ui
operator|->
name|last_status
operator|&
name|CS_OL
condition|)
block|{
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_NOREWIND
operator|)
condition|)
name|cycmd
argument_list|(
name|dev
argument_list|,
name|DO_WEOV
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_NOREWIND
operator|)
operator|==
literal|0
condition|)
name|cycmd
argument_list|(
name|dev
argument_list|,
name|DO_RWOV
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ui
operator|->
name|bad_count
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
name|ui
operator|->
name|bad_count
operator|*=
literal|889
expr_stmt|;
name|uprintf
argument_list|(
literal|"cy%d: Warning - %d.%dcm of tape were used for recovering bad spots.\n"
argument_list|,
name|unit
argument_list|,
name|ui
operator|->
name|bad_count
operator|/
literal|100
argument_list|,
name|ui
operator|->
name|bad_count
operator|%
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ui
operator|->
name|bad_count
operator|=
literal|0
expr_stmt|;
block|}
name|ui
operator|->
name|open
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Cycmd is used internally to implement all the ioctl functions.  * We duplicate the code in physio  * that is used for syncronizing the processes (sleep / wakeup) so  * that we can treat our internal command requests exactly like  * regular reads and writes.  They get put on the controller queue,  * start processes them and iodone is called to wake us up on completion.  *  * We don't call physio directly because it expects data to be moved  * and has a lot more overhead than we really need.  */
end_comment

begin_expr_stmt
name|cycmd
argument_list|(
name|dev
argument_list|,
name|command
argument_list|,
name|count
argument_list|)
specifier|register
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|command
decl_stmt|,
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|uq
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl3
argument_list|()
expr_stmt|;
while|while
condition|(
name|ui
operator|->
name|rawbp
operator|.
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
name|ui
operator|->
name|rawbp
operator|.
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ui
operator|->
name|rawbp
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* load the request queue element */
name|ui
operator|->
name|rawbp
operator|.
name|b_error
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|rawbp
operator|.
name|b_dev
operator|=
name|dev
expr_stmt|;
name|ui
operator|->
name|rawbp
operator|.
name|b_cmd
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|command
expr_stmt|;
name|ui
operator|->
name|rawbp
operator|.
name|b_bcount
operator|=
name|count
expr_stmt|;
name|ui
operator|->
name|rawbp
operator|.
name|b_flags
operator|=
name|B_PHYS
operator||
name|B_BUSY
expr_stmt|;
name|s
operator|=
name|spl3
argument_list|()
expr_stmt|;
name|uq
operator|=
operator|&
name|ui
operator|->
name|u_queue
expr_stmt|;
name|ui
operator|->
name|rawbp
operator|.
name|av_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|uq
operator|->
name|av_forw
operator|==
name|NULL
condition|)
name|uq
operator|->
name|av_forw
operator|=
operator|&
name|ui
operator|->
name|rawbp
expr_stmt|;
else|else
name|uq
operator|->
name|av_back
operator|->
name|av_forw
operator|=
operator|&
name|ui
operator|->
name|rawbp
expr_stmt|;
name|uq
operator|->
name|av_back
operator|=
operator|&
name|ui
operator|->
name|rawbp
expr_stmt|;
name|cystart
argument_list|(
name|cydinfo
index|[
name|unit
index|]
operator|->
name|ui_mi
argument_list|,
operator|&
name|ui
operator|->
name|rawbp
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* wait for operation to complete */
while|while
condition|(
operator|(
name|ui
operator|->
name|rawbp
operator|.
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ui
operator|->
name|rawbp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|ui
operator|->
name|rawbp
operator|.
name|b_flags
operator|&=
operator|~
operator|(
name|B_PHYS
operator||
name|B_BUSY
operator|)
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|rawbp
operator|.
name|b_flags
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ui
operator|->
name|rawbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|geterror
argument_list|(
operator|&
name|ui
operator|->
name|rawbp
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|cystrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|uq
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* check the validity of the request */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|MAX_BLOCKSIZE
condition|)
block|{
name|uprintf
argument_list|(
literal|"cy%d: Maximum block size is %dk!\n"
argument_list|,
name|unit
argument_list|,
name|MAX_BLOCKSIZE
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|vbasetup
argument_list|(
name|bp
argument_list|,
name|MAX_BLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_PHYS
condition|)
name|bp
operator|->
name|b_cmd
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
name|DO_RRD
else|:
name|DO_RWT
operator|)
expr_stmt|;
else|else
name|bp
operator|->
name|b_cmd
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
name|DO_BRD
else|:
name|DO_BWT
operator|)
expr_stmt|;
comment|/* place request on queue and start it */
name|s
operator|=
name|spl3
argument_list|()
expr_stmt|;
name|uq
operator|=
operator|&
name|ui
operator|->
name|u_queue
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|uq
operator|->
name|av_forw
operator|==
name|NULL
condition|)
name|uq
operator|->
name|av_forw
operator|=
name|bp
expr_stmt|;
else|else
name|uq
operator|->
name|av_back
operator|->
name|av_forw
operator|=
name|bp
expr_stmt|;
name|uq
operator|->
name|av_back
operator|=
name|bp
expr_stmt|;
name|cystart
argument_list|(
name|cydinfo
index|[
name|unit
index|]
operator|->
name|ui_mi
argument_list|,
name|bp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_function_decl
name|struct
name|buf
modifier|*
name|cyget_next
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cystart_timeout
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Cystart is called once for every request that is placed on a  * controller's queue.  Start is responsible for fetching requests for  * a controller queue, starting the operation, and waiting for completion,  * and releasing the buf structure back to UNIX or cycmd, before fetching  * the next request.  *  * The controller's queue looks like this:  *  *                      +---------------------------------------+  *                      |                                       |   *      +-----------+   |   +-----------+        +-----------+  |  *      |  b_forw   |---+-->|  b_forw   |--~ ~-->|  b_forw   |--+  *      +-----------+       +-----------+        +-----------+  *      |  b_back   |       | ......... |        | ......... |  *      +-----------+       +-----------+        +-----------+  *      | ......... |      First unit queue     Last unit queue  *      +-----------+          element              element  * head of controller queue  *  (cyminfo[ctlr].um_tab)  */
end_comment

begin_expr_stmt
name|cystart
argument_list|(
name|vi
argument_list|,
name|bp
argument_list|,
name|s
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|vi
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|,
name|ctlr
init|=
name|vi
operator|->
name|um_ctlr
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|next
decl_stmt|,
modifier|*
name|cq
init|=
operator|&
name|vi
operator|->
name|um_tab
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
if|if
condition|(
name|cq
operator|->
name|b_active
operator|&
name|SLEEPING
condition|)
block|{
name|untimeout
argument_list|(
name|cystart_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|cq
argument_list|)
expr_stmt|;
name|cystart_timeout
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cq
operator|->
name|b_active
condition|)
block|{
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PRIBIO
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|PROCESSED
condition|)
block|{
if|if
condition|(
name|ui
operator|->
name|message
condition|)
block|{
name|uprintf
argument_list|(
literal|"cy%d: %s\n"
argument_list|,
name|unit
argument_list|,
name|ui
operator|->
name|message
argument_list|)
expr_stmt|;
name|ui
operator|->
name|message
operator|=
literal|0
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|PROCESSED
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|cq
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ci
operator|->
name|my_request
operator|=
name|bp
expr_stmt|;
name|cydo_my_command
argument_list|(
name|ctlr
argument_list|,
name|cq
argument_list|,
name|ci
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|message
condition|)
block|{
name|uprintf
argument_list|(
literal|"cy%d: %s\n"
argument_list|,
name|unit
argument_list|,
name|ui
operator|->
name|message
argument_list|)
expr_stmt|;
name|ui
operator|->
name|message
operator|=
literal|0
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|PROCESSED
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|next
operator|=
name|cyget_next
argument_list|(
name|cq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|next
argument_list|)
expr_stmt|;
else|else
name|cq
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Cystart_timeout wakes up the start routine after it's 3  * second wait time is up or when a new command enters the queue.  * The timer is used to give up the processor while all drives  * on the queue are rewinding and we need to wait for them to be dome.  */
end_comment

begin_expr_stmt
name|cystart_timeout
argument_list|(
name|cq
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|cq
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|cq
operator|->
name|b_active
operator|&=
operator|~
name|SLEEPING
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|cq
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Cydo_my command scans the request queues once for a  * particular controller and calls the appropriate processing routine  * each time we find a request that can be started.  */
end_comment

begin_expr_stmt
name|cydo_my_command
argument_list|(
name|ctlr
argument_list|,
name|cq
argument_list|,
name|ci
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|cq
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|ctlr_tab
modifier|*
name|ci
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|next
decl_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|cyget_next
argument_list|(
name|cq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cq
operator|->
name|b_forw
operator|->
name|b_active
operator|&
name|SLEEPING
condition|)
block|{
name|cq
operator|->
name|b_active
operator||=
name|SLEEPING
expr_stmt|;
name|timeout
argument_list|(
name|cystart_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|cq
argument_list|,
literal|1
operator|*
literal|60
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|cq
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|setjmp
argument_list|(
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
operator|.
name|environ
argument_list|)
condition|)
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|cmd
init|=
operator|(
name|int
operator|)
name|next
operator|->
name|b_cmd
decl_stmt|;
call|(
modifier|*
name|cmd_tbl
index|[
name|cmd
index|]
call|)
argument_list|(
name|next
argument_list|,
name|cq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|->
name|b_flags
operator|&
name|PROCESSED
condition|)
block|{
if|if
condition|(
name|ci
operator|->
name|my_request
operator|==
name|next
condition|)
break|break;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|struct
name|buf
modifier|*
name|cyget_next
parameter_list|(
name|cq
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|uq
decl_stmt|,
modifier|*
name|next
init|=
name|NULL
decl_stmt|;
name|cq
operator|->
name|b_forw
operator|=
name|cq
operator|->
name|b_forw
operator|->
name|b_forw
expr_stmt|;
name|uq
operator|=
name|cq
operator|->
name|b_forw
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|bp
operator|=
name|uq
operator|->
name|av_forw
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|uq
operator|->
name|b_active
operator|&
name|SLEEPING
operator|)
operator|==
literal|0
condition|)
block|{
name|cq
operator|->
name|b_forw
operator|=
name|uq
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
name|next
operator|=
name|uq
expr_stmt|;
block|}
name|uq
operator|=
name|uq
operator|->
name|b_forw
expr_stmt|;
block|}
do|while
condition|(
name|uq
operator|!=
name|cq
operator|->
name|b_forw
condition|)
do|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
name|cq
operator|->
name|b_forw
operator|=
name|next
expr_stmt|;
return|return
operator|(
name|next
operator|->
name|av_forw
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark the current command on the controller's q completed and remove it.  */
end_comment

begin_macro
name|cydone
argument_list|(
argument|cq
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|uq
init|=
name|cq
operator|->
name|b_forw
decl_stmt|;
name|int
name|s
decl_stmt|;
name|uq
operator|->
name|av_forw
operator|->
name|b_flags
operator||=
name|PROCESSED
expr_stmt|;
name|s
operator|=
name|spl3
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|uq
operator|->
name|av_forw
operator|=
name|uq
operator|->
name|av_forw
operator|->
name|av_forw
operator|)
operator|==
name|NULL
condition|)
name|uq
operator|->
name|av_back
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The following routines implement the individual commands.  *  * Each command is responsible for a few things. 1) Each has to keep  * track of special cases that are related to the individual command and  * the previous commands sequence, 2) each is required to call iodone when  * command is actually finished, 3) it must use cyexecute to actually  * start the controller, and 4) they are required to keep the tape in  * a consistant state so that other commands will not be messed up.  */
end_comment

begin_comment
comment|/*  * Read requests from the raw device.  * The special cases are:  *  1) we can not read after a write.  (writting defines end of file)  *  2) reading past end of file returns 0 bytes;  */
end_comment

begin_expr_stmt
name|cyraw_read
argument_list|(
name|bp
argument_list|,
name|cq
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|cydinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
index|]
decl_stmt|;
name|int
name|addr
decl_stmt|,
name|lock_flag
decl_stmt|,
name|command
decl_stmt|;
if|if
condition|(
name|ui
operator|->
name|cleanup
operator|!=
name|cyno_op
operator|||
name|ui
operator|->
name|eof
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
operator|,
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|ci
operator|->
name|bs
condition|)
name|command
operator|=
name|READ_TA
operator|,
name|lock_flag
operator|=
name|CW_LOCK
expr_stmt|;
else|else
name|command
operator|=
name|READ_BU
operator|,
name|lock_flag
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|blkno
operator|++
expr_stmt|;
name|addr
operator|=
name|vbastart
argument_list|(
name|bp
argument_list|,
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ci
operator|->
name|map
argument_list|,
name|ci
operator|->
name|utl
argument_list|)
expr_stmt|;
name|cyexecute
argument_list|(
name|command
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|addr
argument_list|,
name|lock_flag
argument_list|,
name|unit
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|vbadone
argument_list|(
name|bp
argument_list|,
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ci
operator|->
name|map
argument_list|,
name|ci
operator|->
name|utl
argument_list|)
expr_stmt|;
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Write requests from the raw device.  * The special cases are:  *  1) we don't allow writes after end of tape is reached.  */
end_comment

begin_expr_stmt
name|cyraw_write
argument_list|(
name|bp
argument_list|,
name|cq
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|CYUNIT
argument_list|(
name|unit
argument_list|)
index|]
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|cydinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
index|]
decl_stmt|;
name|int
name|addr
decl_stmt|,
name|lock_flag
decl_stmt|,
name|command
decl_stmt|;
if|if
condition|(
name|ui
operator|->
name|eot
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
operator|,
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|longjmp
argument_list|(
operator|&
name|ci
operator|->
name|environ
argument_list|)
expr_stmt|;
block|}
name|ui
operator|->
name|cleanup
operator|=
name|cywrite_2_fm
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|ci
operator|->
name|bs
condition|)
name|command
operator|=
name|WRIT_TA
operator|,
name|lock_flag
operator|=
name|CW_LOCK
expr_stmt|;
else|else
name|command
operator|=
name|WRIT_BU
operator|,
name|lock_flag
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|blkno
operator|++
expr_stmt|;
name|addr
operator|=
name|vbastart
argument_list|(
name|bp
argument_list|,
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ci
operator|->
name|map
argument_list|,
name|ci
operator|->
name|utl
argument_list|)
expr_stmt|;
name|cyexecute
argument_list|(
name|command
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|addr
argument_list|,
name|lock_flag
argument_list|,
name|unit
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|vbadone
argument_list|(
name|bp
argument_list|,
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ci
operator|->
name|map
argument_list|,
name|ci
operator|->
name|utl
argument_list|)
expr_stmt|;
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Write a filemark on a tape.  */
end_comment

begin_expr_stmt
name|cywrite_filemark
argument_list|(
name|bp
argument_list|,
name|cq
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|CYUNIT
argument_list|(
name|unit
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
condition|)
block|{
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|b_bcount
operator|--
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|cleanup
operator|==
name|cywrite_1_fm
condition|)
name|ui
operator|->
name|cleanup
operator|=
name|cywrite_0_fm
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|cleanup
operator|==
name|cywrite_2_fm
operator|||
name|ui
operator|->
name|cleanup
operator|==
name|cyno_op
condition|)
name|ui
operator|->
name|cleanup
operator|=
name|cywrite_1_fm
expr_stmt|;
name|ui
operator|->
name|file_number
operator|++
expr_stmt|;
name|ui
operator|->
name|eof
operator|=
literal|1
expr_stmt|;
name|ui
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|cyexecute
argument_list|(
name|WRIT_FM
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	cysearch_fm_forw is the ioctl to search for a filemark in the **  forward direction on tape. ** **	Since only one device can be active on a given controller at any **  given instant in time, we try to be nice and let onther devices  on **  this controller be scheduled after we space over each record.  This will **  at least give the apperance of overlapped operations on the controller. ** **  The special cases are: **  1) if the last command was a write the we can't search. */
end_comment

begin_expr_stmt
name|cysearch_fm_forw
argument_list|(
name|request
argument_list|,
name|cq
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|request
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|request
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|CYUNIT
argument_list|(
name|unit
argument_list|)
index|]
decl_stmt|;
specifier|register
name|int
name|ctlr
init|=
name|cydinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ui
operator|->
name|cleanup
operator|!=
name|cyno_op
operator|)
operator|||
name|ui
operator|->
name|eot
condition|)
block|{
name|request
operator|->
name|b_resid
operator|=
name|request
operator|->
name|b_bcount
expr_stmt|;
name|request
operator|->
name|b_error
operator|=
name|ENXIO
operator|,
name|request
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|longjmp
argument_list|(
operator|&
name|ci
operator|->
name|environ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|->
name|b_bcount
operator|&&
operator|!
name|ui
operator|->
name|eot
condition|)
block|{
if|if
condition|(
operator|!
name|ui
operator|->
name|eot
condition|)
block|{
name|ui
operator|->
name|blkno
operator|++
expr_stmt|;
name|cyexecute
argument_list|(
name|SPAC_FM
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|5
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ui
operator|->
name|eof
operator|||
name|ui
operator|->
name|eot
operator|)
condition|)
return|return;
block|}
name|request
operator|->
name|b_bcount
operator|--
expr_stmt|;
name|ui
operator|->
name|eof
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|ui
operator|->
name|eot
condition|)
block|{
name|ui
operator|->
name|file_number
operator|++
expr_stmt|;
name|ui
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|ui
operator|->
name|eot
condition|)
block|{
name|request
operator|->
name|b_resid
operator|=
name|request
operator|->
name|b_bcount
expr_stmt|;
name|request
operator|->
name|b_flags
operator||=
name|B_ERROR
operator|,
name|request
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
block|}
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	cysearch_fm_back is the ioctl to search for a filemark in the **  reverse direction on tape. ** **	Since only one device can be active on a given controller at any **  given instant in time, we try to be nice and let onther devices  on **  this controller be scheduled after we space over each record.  This will **  at least give the apperance of overlapped operations on the controller. ** **  The special cases are: **  1) can't search past begining of tape. **  2) if the lasr operation was a write data then we need to add **     an end of volume record before we start searching. */
end_comment

begin_expr_stmt
name|cysearch_fm_back
argument_list|(
name|request
argument_list|,
name|cq
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|request
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|request
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|CYUNIT
argument_list|(
name|unit
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ui
operator|->
name|bot
condition|)
block|{
call|(
modifier|*
name|ui
operator|->
name|cleanup
call|)
argument_list|(
name|unit
argument_list|,
name|MAINTAIN_POSITION
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|blkno
operator|==
literal|0
condition|)
name|request
operator|->
name|b_bcount
operator|++
expr_stmt|;
name|ui
operator|->
name|blkno
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|b_bcount
operator|&&
operator|!
name|ui
operator|->
name|bot
condition|)
block|{
name|cyexecute
argument_list|(
name|SPAC_FM
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
name|CW_REV
argument_list|,
name|unit
argument_list|,
literal|6
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui
operator|->
name|eof
condition|)
block|{
name|ui
operator|->
name|eof
operator|=
name|FALSE
expr_stmt|;
name|ui
operator|->
name|file_number
operator|--
expr_stmt|;
name|request
operator|->
name|b_bcount
operator|--
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|ui
operator|->
name|bot
condition|)
block|{
name|ui
operator|->
name|file_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|b_bcount
condition|)
block|{
name|request
operator|->
name|b_resid
operator|=
name|request
operator|->
name|b_bcount
expr_stmt|;
name|request
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
name|request
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
block|}
else|else
block|{
name|request
operator|->
name|b_cmd
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|DO_SFMF
expr_stmt|;
name|request
operator|->
name|b_bcount
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|ui
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|eof
operator|=
name|FALSE
expr_stmt|;
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	cy_space_forw is used to search forward a given number of records on **  tape. ** **	Since only one device can be active on a given controller at any **  given instant in time, we try to be nice and let onther devices  on **  this controller be scheduled after we space over each record.  This will **  at least give the apperance of overlapped operations on the controller. ** **  The special cases are: **  1) we can't space over a filemark. **  2) if the last command was a write data or filemark we can't space forward. */
end_comment

begin_expr_stmt
name|cy_space_forw
argument_list|(
name|request
argument_list|,
name|cq
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|request
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|request
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|CYUNIT
argument_list|(
name|unit
argument_list|)
index|]
decl_stmt|;
specifier|register
name|int
name|ctlr
init|=
name|cydinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ui
operator|->
name|cleanup
operator|!=
name|cyno_op
operator|)
operator|||
name|ui
operator|->
name|eof
condition|)
block|{
name|request
operator|->
name|b_resid
operator|=
name|request
operator|->
name|b_bcount
expr_stmt|;
name|request
operator|->
name|b_error
operator|=
name|ENXIO
operator|,
name|request
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|longjmp
argument_list|(
operator|&
name|ci
operator|->
name|environ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|->
name|b_bcount
condition|)
block|{
name|ui
operator|->
name|blkno
operator|++
expr_stmt|;
name|cyexecute
argument_list|(
name|SPAC_FM
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ui
operator|->
name|eof
operator|&&
name|request
operator|->
name|b_bcount
condition|)
block|{
name|request
operator|->
name|b_bcount
operator|--
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|ui
operator|->
name|eof
condition|)
block|{
name|request
operator|->
name|b_resid
operator|=
name|request
operator|->
name|b_bcount
expr_stmt|;
name|request
operator|->
name|b_error
operator|=
name|ENXIO
operator|,
name|request
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	Cy_space_back spaces backward a given number of records. ** **	Since only one device can be active on a given controller at any **  given instant in time, we try to be nice and let onther devices  on **  this controller be scheduled after we space over each record.  This will **  at least give the apperance of overlapped operations on the controller. ** **  The special cases are: **  1) we can't space over a filemark. **  2) we can't space past the beginning of tape. **  3) if the last operation was a write data then we need to add **     an end of volume record before we start searching. */
end_comment

begin_expr_stmt
name|cy_space_back
argument_list|(
name|request
argument_list|,
name|cq
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|request
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|request
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|CYUNIT
argument_list|(
name|unit
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ui
operator|->
name|bot
condition|)
block|{
call|(
modifier|*
name|ui
operator|->
name|cleanup
call|)
argument_list|(
name|unit
argument_list|,
name|MAINTAIN_POSITION
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|b_bcount
operator|+
literal|1
operator|&&
operator|!
name|ui
operator|->
name|bot
operator|&&
operator|!
name|ui
operator|->
name|eof
condition|)
block|{
name|request
operator|->
name|b_bcount
operator|--
expr_stmt|;
name|ui
operator|->
name|blkno
operator|--
expr_stmt|;
name|cyexecute
argument_list|(
name|SPACE
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
name|CW_REV
argument_list|,
name|unit
argument_list|,
literal|15
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ui
operator|->
name|bot
condition|)
block|{
name|request
operator|->
name|b_bcount
operator|=
literal|1
expr_stmt|;
name|cy_space_forw
argument_list|(
name|request
argument_list|,
name|cq
argument_list|)
expr_stmt|;
block|}
name|ui
operator|->
name|eof
operator|=
name|FALSE
expr_stmt|;
block|}
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Rewind tape and wait for completion.  * An overlapped rewind is issued and then we change the command type to  * a wait for ready ioctl.  Wait for ready contains the logic to poll  * without blocking anything in the system, until the drive becomes ready or  * drops off line whichever comes first.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|cyrewind_tape_ta
argument_list|(
argument|bp
argument_list|,
argument|cq
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cyrewind_tape
argument_list|(
name|bp
argument_list|,
name|REWD_OV
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_cmd
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|DO_WAIT
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do an overlapped rewind and then unload the tape.  * This feature is handled by the individual tape drive and  * in some cases can not be performed.  */
end_comment

begin_macro
name|cyrewind_tape_unl
argument_list|(
argument|bp
argument_list|,
argument|cq
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cyrewind_tape
argument_list|(
name|bp
argument_list|,
name|OFF_UNL
argument_list|)
expr_stmt|;
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do an overlapped rewind.  */
end_comment

begin_macro
name|cyrewind_tape_ov
argument_list|(
argument|bp
argument_list|,
argument|cq
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cyrewind_tape
argument_list|(
name|bp
argument_list|,
name|REWD_OV
argument_list|)
expr_stmt|;
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Common code for all rewind commands.  * The special cases are:  *  3) if the last operation was a write data then we need to add  *     an end of volume record before we start searching.  */
end_comment

begin_expr_stmt
name|cyrewind_tape
argument_list|(
name|bp
argument_list|,
name|cmd
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|unit
index|]
decl_stmt|;
call|(
modifier|*
name|ui
operator|->
name|cleanup
call|)
argument_list|(
name|unit
argument_list|,
name|DONT_MAINTAIN_POSITION
argument_list|)
expr_stmt|;
name|ui
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|eof
operator|=
name|FALSE
expr_stmt|;
name|ui
operator|->
name|bot
operator|=
name|TRUE
expr_stmt|;
name|ui
operator|->
name|eot
operator|=
name|FALSE
expr_stmt|;
name|ui
operator|->
name|file_number
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|cleanup
operator|=
name|cyno_op
expr_stmt|;
name|cyexecute
argument_list|(
name|cmd
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
name|cmd
operator|==
name|REWD_OV
condition|?
literal|10
else|:
literal|10
operator|*
literal|60
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	Cywait_until_ready is used to wait for rewinds to complete. **  We check the status and if the tape is still rewinding we re-enter ourself **  on the activity queue to give other requests a chance to execute before we **  check the status again.  One other thing is that we only want to  check **  the status every five seconds.  so we set a timer for five seconds and **  check the time left every time we enter this routine.  If there is still **  time left then we simply reinsert ourself on the queue again and wait **  until next time .. */
end_comment

begin_expr_stmt
name|cywait_until_ready
argument_list|(
name|request
argument_list|,
name|cq
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|request
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|cywait_timeout
parameter_list|()
function_decl|;
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|request
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|unit
index|]
decl_stmt|;
name|cyexecute
argument_list|(
name|DRIVE_S
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|ui
operator|->
name|last_status
operator|&
name|CS_OL
operator|)
operator|)
operator|||
operator|(
name|ui
operator|->
name|last_status
operator|&
name|CS_RDY
operator|)
condition|)
block|{
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
return|return;
block|}
name|cq
operator|->
name|b_forw
operator|->
name|b_active
operator||=
name|SLEEPING
expr_stmt|;
name|timeout
argument_list|(
name|cywait_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|cq
operator|->
name|b_forw
argument_list|,
literal|2
operator|*
literal|60
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reset the timing flag for nice_wait after 3 seconds.  * This makes this drive eligible for scheduling again.  */
end_comment

begin_macro
name|cywait_timeout
argument_list|(
argument|uq
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|uq
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|uq
operator|->
name|b_active
operator|&=
operator|~
name|SLEEPING
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Process a status ioctl request.  * It depends entirly on the interupt routines to load the last_XXX  * registers in unit_info[].  */
end_comment

begin_macro
name|cydrive_status
argument_list|(
argument|bp
argument_list|,
argument|cq
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cyexecute
argument_list|(
name|DRIVE_S
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	cybuf_read handles the read requests from the block device. ** **  The special cases are: **  1)	we can not read after a write.  (writting defines end of file) **  2)  reading past end of file returns 0 bytes; **  3)  if we are mispositioned we have to seek to the correct block. **  4)  we can hit end of tape while seeking. **  5)  we want to be nice to other processes while seeking so we **  	break the request up into smaller requests. **  6)  returns error if the block was larger than requested.  */
end_comment

begin_expr_stmt
name|cybuf_read
argument_list|(
name|request
argument_list|,
name|cq
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|request
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|request
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|CYUNIT
argument_list|(
name|unit
argument_list|)
index|]
decl_stmt|;
specifier|register
name|int
name|ctlr
init|=
name|cydinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|int
name|addr
decl_stmt|,
name|command
decl_stmt|,
name|bus_lock
decl_stmt|;
name|cydebug
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cyseek
argument_list|(
name|request
argument_list|,
name|cq
argument_list|)
condition|)
block|{
if|if
condition|(
name|ui
operator|->
name|cleanup
operator|!=
name|cyno_op
condition|)
block|{
name|clrbuf
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
operator|&
name|ci
operator|->
name|environ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|->
name|b_bcount
operator|>
name|ci
operator|->
name|bs
condition|)
name|command
operator|=
name|READ_TA
operator|,
name|bus_lock
operator|=
name|CW_LOCK
expr_stmt|;
else|else
name|command
operator|=
name|READ_BU
operator|,
name|bus_lock
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|blkno
operator|++
expr_stmt|;
name|addr
operator|=
name|vbastart
argument_list|(
name|request
argument_list|,
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ci
operator|->
name|map
argument_list|,
name|ci
operator|->
name|utl
argument_list|)
expr_stmt|;
name|cyexecute
argument_list|(
name|command
argument_list|,
name|request
operator|->
name|b_bcount
argument_list|,
name|addr
argument_list|,
name|bus_lock
argument_list|,
name|unit
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|vbadone
argument_list|(
name|request
argument_list|,
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ci
operator|->
name|map
argument_list|,
name|ci
operator|->
name|utl
argument_list|)
expr_stmt|;
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* **	cybuf_write handles the write requests from the block device. ** **  The special cases are: **  1)  if we are mispositioned we have to seek to the correct block. **  2)  we can hit end of tape while seeking. **  3)  we want to be nice to other processes while seeking so we **  	break the request up into smaller requests. **  4) we don't allow writes after end of tape is reached. */
end_comment

begin_expr_stmt
name|cybuf_write
argument_list|(
name|request
argument_list|,
name|cq
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|request
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|request
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|CYUNIT
argument_list|(
name|unit
argument_list|)
index|]
decl_stmt|;
specifier|register
name|int
name|ctlr
init|=
name|cydinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|int
name|addr
decl_stmt|,
name|command
decl_stmt|,
name|bus_lock
decl_stmt|;
if|if
condition|(
name|ui
operator|->
name|eot
operator|&&
operator|(
name|request
operator|->
name|b_blkno
operator|>=
name|ui
operator|->
name|blkno
operator|)
condition|)
block|{
name|request
operator|->
name|b_error
operator|=
name|ENXIO
operator|,
name|request
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|request
operator|->
name|b_resid
operator|=
name|request
operator|->
name|b_bcount
expr_stmt|;
name|longjmp
argument_list|(
operator|&
name|ci
operator|->
name|environ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cyseek
argument_list|(
name|request
argument_list|,
name|cq
argument_list|)
condition|)
block|{
name|ui
operator|->
name|cleanup
operator|=
name|cywrite_2_fm
expr_stmt|;
name|ui
operator|->
name|blkno
operator|++
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|b_bcount
operator|>
name|ci
operator|->
name|bs
condition|)
name|command
operator|=
name|WRIT_TA
operator|,
name|bus_lock
operator|=
name|CW_LOCK
expr_stmt|;
else|else
name|command
operator|=
name|WRIT_BU
operator|,
name|bus_lock
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|vbastart
argument_list|(
name|request
argument_list|,
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ci
operator|->
name|map
argument_list|,
name|ci
operator|->
name|utl
argument_list|)
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
name|addr
argument_list|,
operator|(
name|short
operator|*
operator|)
operator|&
name|ci
operator|->
name|tpb
operator|.
name|data_ptr
argument_list|)
expr_stmt|;
name|cyexecute
argument_list|(
name|command
argument_list|,
name|request
operator|->
name|b_bcount
argument_list|,
name|addr
argument_list|,
name|bus_lock
argument_list|,
name|unit
argument_list|,
literal|5
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|vbadone
argument_list|(
name|request
argument_list|,
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ci
operator|->
name|map
argument_list|,
name|ci
operator|->
name|utl
argument_list|)
expr_stmt|;
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* **	cyseek is used by the block device to position the tape correctly **  before each read or write request. ** **  The special cases are: **  1)  we can hit end of tape while seeking. **  2)  we want to be nice to other processes while seeking so we **  	break the request up into smaller requests. */
end_comment

begin_expr_stmt
name|cyseek
argument_list|(
name|request
argument_list|,
name|cq
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|request
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|request
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|CYUNIT
argument_list|(
name|unit
argument_list|)
index|]
decl_stmt|;
specifier|register
name|int
name|ctlr
init|=
name|cydinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|cq
operator|=
name|cq
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|request
operator|->
name|b_blkno
operator|<
name|ui
operator|->
name|blkno
condition|)
block|{
specifier|register
name|int
name|count
decl_stmt|;
call|(
modifier|*
name|ui
operator|->
name|cleanup
call|)
argument_list|(
name|unit
argument_list|,
name|MAINTAIN_POSITION
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
name|request
operator|->
name|b_blkno
operator|+
literal|1
operator|)
operator|==
name|ui
operator|->
name|blkno
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|ui
operator|->
name|blkno
operator|-=
name|count
expr_stmt|;
name|cyexecute
argument_list|(
name|SPAC_FM
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
name|CW_REV
argument_list|,
name|unit
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ui
operator|->
name|eof
condition|)
return|return
name|FALSE
return|;
name|ui
operator|->
name|eof
operator|=
name|FALSE
expr_stmt|;
name|request
operator|->
name|b_blkno
operator|=
name|ui
operator|->
name|blkno
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|->
name|b_blkno
operator|>
name|ui
operator|->
name|blkno
condition|)
block|{
if|if
condition|(
operator|(
name|ui
operator|->
name|cleanup
operator|!=
name|cyno_op
operator|)
operator|||
name|ui
operator|->
name|eof
operator|||
name|ui
operator|->
name|eot
condition|)
block|{
name|request
operator|->
name|b_resid
operator|=
name|request
operator|->
name|b_bcount
expr_stmt|;
name|request
operator|->
name|b_error
operator|=
name|ENXIO
operator|,
name|request
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|longjmp
argument_list|(
operator|&
name|ci
operator|->
name|environ
argument_list|)
expr_stmt|;
block|}
name|ui
operator|->
name|blkno
operator|++
expr_stmt|;
name|cyexecute
argument_list|(
name|SPAC_FM
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/* */
end_comment

begin_expr_stmt
name|cywrite_eov
argument_list|(
name|request
argument_list|,
name|cq
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|request
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|buf
modifier|*
name|cq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|cyno_op
parameter_list|()
function_decl|;
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|request
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|CYUNIT
argument_list|(
name|unit
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|ui
operator|->
name|cleanup
operator|!=
name|cyno_op
condition|)
block|{
call|(
modifier|*
name|ui
operator|->
name|cleanup
call|)
argument_list|(
name|unit
argument_list|,
name|DONT_MAINTAIN_POSITION
argument_list|)
expr_stmt|;
name|cyexecute
argument_list|(
name|SPACE
argument_list|,
operator|(
name|long
operator|)
literal|2
argument_list|,
literal|0
argument_list|,
name|CW_REV
argument_list|,
name|unit
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cyexecute
argument_list|(
name|SPACE
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|unit_info
index|[
name|unit
index|]
operator|.
name|cleanup
operator|=
name|cyno_op
expr_stmt|;
name|ui
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
block|}
name|cydone
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	Do nothing */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|cyno_op
argument_list|(
argument|unit
argument_list|,
argument|action
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|action
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/* **	Write 0 file marks to tape */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|cywrite_0_fm
argument_list|(
argument|unit
argument_list|,
argument|action
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|action
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unit_info
index|[
name|unit
index|]
operator|.
name|cleanup
operator|=
name|cyno_op
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	Write 1 file mark to tape */
end_comment

begin_macro
name|cywrite_1_fm
argument_list|(
argument|unit
argument_list|,
argument|action
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|action
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cyexecute
argument_list|(
name|WRIT_FM
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|5
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|MAINTAIN_POSITION
condition|)
block|{
name|cyexecute
argument_list|(
name|SPACE
argument_list|,
operator|(
name|long
operator|)
literal|2
argument_list|,
literal|0
argument_list|,
name|CW_REV
argument_list|,
name|unit
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cyexecute
argument_list|(
name|SPACE
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|unit_info
index|[
name|unit
index|]
operator|.
name|cleanup
operator|=
name|cyno_op
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	Write 2 file marks to tape */
end_comment

begin_macro
name|cywrite_2_fm
argument_list|(
argument|unit
argument_list|,
argument|action
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|action
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cyexecute
argument_list|(
name|WRIT_FM
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|5
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cyexecute
argument_list|(
name|WRIT_FM
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|5
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|MAINTAIN_POSITION
condition|)
block|{
name|cyexecute
argument_list|(
name|SPACE
argument_list|,
operator|(
name|long
operator|)
literal|3
argument_list|,
literal|0
argument_list|,
name|CW_REV
argument_list|,
name|unit
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cyexecute
argument_list|(
name|SPACE
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|unit_info
index|[
name|unit
index|]
operator|.
name|cleanup
operator|=
name|cyno_op
expr_stmt|;
block|}
end_block

begin_function_decl
specifier|extern
name|int
name|cytimeout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cy_normal_path
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* **	Cyexecute is used to start all commands to the controller.  We **  do all common code here before starting. */
end_comment

begin_expr_stmt
name|cyexecute
argument_list|(
name|command
argument_list|,
name|count
argument_list|,
name|addr
argument_list|,
name|control_flags
argument_list|,
name|unit
argument_list|,
name|time
argument_list|,
name|interupt_routine
argument_list|)
specifier|register
name|int
name|command
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|long
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|addr
decl_stmt|,
name|control_flags
decl_stmt|,
name|unit
decl_stmt|,
name|time
decl_stmt|,
name|interupt_routine
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|priority
decl_stmt|;
specifier|register
name|int
name|ctlr
init|=
name|cydinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|request
init|=
name|ui
operator|->
name|u_queue
operator|.
name|av_forw
decl_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|cmd
operator|=
name|command
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|control
operator|=
name|ui
operator|->
name|control_proto
operator||
name|control_flags
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|status
operator|=
name|ci
operator|->
name|tpb
operator|.
name|count
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
name|addr
argument_list|,
operator|(
name|short
operator|*
operator|)
operator|&
name|ci
operator|->
name|tpb
operator|.
name|data_ptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|READ_BU
case|:
case|case
name|READ_TA
case|:
case|case
name|WRIT_BU
case|:
case|case
name|WRIT_TA
case|:
name|ci
operator|->
name|tpb
operator|.
name|size
operator|=
name|MULTIBUS_SHORT
argument_list|(
operator|(
name|short
operator|)
name|count
argument_list|)
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|rec_over
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
break|break;
default|default:
name|ci
operator|->
name|tpb
operator|.
name|size
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|rec_over
operator|=
name|MULTIBUS_SHORT
argument_list|(
operator|(
name|short
operator|)
name|count
argument_list|)
expr_stmt|;
break|break;
block|}
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ci
operator|->
name|tpb
operator|.
name|link_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|interupt_routine
condition|)
name|ci
operator|->
name|last
operator|=
name|ci
operator|->
name|tpb
expr_stmt|;
comment|/* 	gag! but it the last possible moment to wait  	for this controller to get out of it's own way..... 	*/
name|uncache
argument_list|(
operator|&
name|ci
operator|->
name|ccb
operator|.
name|gate
argument_list|)
expr_stmt|;
while|while
condition|(
name|ci
operator|->
name|ccb
operator|.
name|gate
operator|==
name|GATE_CLOSED
condition|)
name|uncache
argument_list|(
operator|&
name|ci
operator|->
name|ccb
operator|.
name|gate
argument_list|)
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ci
operator|->
name|tpb
argument_list|,
name|ci
operator|->
name|ccb
operator|.
name|tpb_ptr
argument_list|)
expr_stmt|;
name|ci
operator|->
name|ccb
operator|.
name|ccw
operator|=
name|NORMAL_INTERUPT
expr_stmt|;
name|ci
operator|->
name|ccb
operator|.
name|gate
operator|=
name|GATE_CLOSED
expr_stmt|;
if|if
condition|(
operator|!
name|interupt_routine
condition|)
name|ci
operator|->
name|interupt_path
operator|=
name|cy_normal_path
expr_stmt|;
name|timeout
argument_list|(
name|cytimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ctlr
argument_list|,
name|time
operator|*
literal|60
argument_list|)
expr_stmt|;
name|priority
operator|=
name|spl3
argument_list|()
expr_stmt|;
name|CY_ATTENTION
argument_list|(
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|interupt_routine
condition|)
block|{
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|ci
argument_list|,
name|PRIBIO
operator|+
literal|3
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|priority
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
if|if
condition|(
operator|(
name|command
operator|==
name|READ_BU
operator|)
operator|||
operator|(
name|command
operator|==
name|READ_TA
operator|)
operator|||
operator|(
name|command
operator|==
name|WRIT_BU
operator|)
operator|||
operator|(
name|command
operator|==
name|WRIT_TA
operator|)
condition|)
name|vbadone
argument_list|(
name|request
argument_list|,
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|long
operator|*
operator|)
name|ci
operator|->
name|map
argument_list|,
name|ci
operator|->
name|utl
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
operator|&
name|ci
operator|->
name|environ
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|splx
argument_list|(
name|priority
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	cytimeout is the interupt timeout routine.  We assume that a **  particular command has gone astray, so we completely reset the controller, **  and call the interupt routine to help us clean up.  Before the interupt **  routine is called we jam a controller timeout value in the status register **  to fake out the calling routines. */
end_comment

begin_expr_stmt
name|cytimeout
argument_list|(
name|ctlr
argument_list|)
specifier|register
name|int
name|ctlr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|priority
init|=
name|spl3
argument_list|()
decl_stmt|;
specifier|register
name|char
modifier|*
name|ctlr_vaddr
init|=
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_addr
decl_stmt|;
specifier|register
name|int
name|tmp_stat
decl_stmt|;
name|uncache
argument_list|(
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
operator|.
name|tpb
operator|.
name|status
argument_list|)
expr_stmt|;
name|tmp_stat
operator|=
name|ctlr_info
index|[
name|ctlr
index|]
operator|.
name|tpb
operator|.
name|status
expr_stmt|;
name|CY_RESET
argument_list|(
name|ctlr_vaddr
argument_list|)
expr_stmt|;
name|cy_init_controller
argument_list|(
name|ctlr_vaddr
argument_list|,
name|ctlr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|priority
argument_list|)
expr_stmt|;
name|ctlr_info
index|[
name|ctlr
index|]
operator|.
name|tpb
operator|=
name|ctlr_info
index|[
name|ctlr
index|]
operator|.
name|last
expr_stmt|;
name|ctlr_info
index|[
name|ctlr
index|]
operator|.
name|tpb
operator|.
name|status
operator|=
operator|(
name|tmp_stat
operator|&
operator|~
name|CS_ERm
operator|)
operator||
name|CS_OL
operator||
name|ER_TIMOUT
expr_stmt|;
name|cyintr
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	Cyintr is the interupt routine for the Tapemaster controller. ** **	Due to controller problems, the first thing we have to do is turn **  off the Tapemaster interupting mechanism.  If we don't we will be flooded **  with bogus interupts and the system will spend all it's time processing **  them.  To Turn the interupts off we issue a NOOP command with the 'turn **  off interupts' code in the ccb. ** **	  take note that since this command TURNS OFF the interupts it **	  itself CANNOT interupt...  This means that polling must be done **	  at sometime to make sure that tis command is completed.  The polling **	  is done before the next command is issued to reduce polling (halting **	  UNIX) time. ** **	After we turn off interupts we uncache all the values in the tpb **  and call the correct processing routine.  This routine can be for normal **  interupts or for interupts generated during a retry operation. */
end_comment

begin_expr_stmt
name|cyintr
argument_list|(
name|ctlr
argument_list|)
specifier|register
name|int
name|ctlr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|int
name|cytimeout
parameter_list|()
function_decl|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
name|untimeout
argument_list|(
name|cytimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ctlr
argument_list|)
expr_stmt|;
comment|/* turn off interupts for the stupid controller */
name|ci
operator|->
name|ccb
operator|.
name|ccw
operator|=
name|CLEAR_INTERUPT
expr_stmt|;
name|ci
operator|->
name|noop
operator|.
name|cmd
operator|=
name|NO_OP
expr_stmt|;
name|ci
operator|->
name|noop
operator|.
name|control
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ci
operator|->
name|noop
argument_list|,
name|ci
operator|->
name|ccb
operator|.
name|tpb_ptr
argument_list|)
expr_stmt|;
name|ci
operator|->
name|ccb
operator|.
name|gate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|CY_ATTENTION
argument_list|(
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_addr
argument_list|)
expr_stmt|;
name|uncache_tpb
argument_list|(
name|ci
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ci
operator|->
name|interupt_path
call|)
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	This is the portion of the interupt routine that processes all **  normal cases i.e. non retry cases.   We check the operations status **  if it is retryable we set the interupt path to the retry routines and **  start the backward spaceing.  when the spacing is done the retry logic **  will be called and this routine will be skipped entirely. ** **	If the command is ok or not retryable we set the status accordingly **  and wakeup cyexecute to continue processing. */
end_comment

begin_expr_stmt
name|cy_normal_path
argument_list|(
name|ctlr
argument_list|)
specifier|register
name|int
name|ctlr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|int
name|cy_retry_path
parameter_list|()
function_decl|;
specifier|extern
name|int
name|cy_extended_gap_path
parameter_list|()
function_decl|;
specifier|register
name|int
name|error
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|cq
init|=
operator|&
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_tab
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|uq
init|=
name|cq
operator|->
name|b_forw
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|request
init|=
name|uq
operator|->
name|av_forw
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|request
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|cydecode_error
argument_list|(
name|unit
argument_list|,
name|ci
operator|->
name|tpb
operator|.
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|FATAL
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|RETRY
condition|)
name|ci
operator|->
name|interupt_path
operator|=
name|cy_retry_path
expr_stmt|;
else|else
name|ci
operator|->
name|interupt_path
operator|=
name|cy_extended_gap_path
expr_stmt|;
name|cyexecute
argument_list|(
name|SPACE
argument_list|,
operator|(
name|long
operator|)
literal|2
argument_list|,
literal|0
argument_list|,
name|CW_REV
argument_list|,
name|unit
argument_list|,
literal|5
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|request
operator|->
name|b_resid
operator|=
name|request
operator|->
name|b_bcount
operator|-
name|MULTIBUS_SHORT
argument_list|(
name|ci
operator|->
name|tpb
operator|.
name|count
argument_list|)
expr_stmt|;
name|ui
operator|->
name|error_count
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|last_resid
operator|=
name|request
operator|->
name|b_resid
expr_stmt|;
name|ui
operator|->
name|last_status
operator|=
name|ci
operator|->
name|tpb
operator|.
name|status
expr_stmt|;
name|ui
operator|->
name|last_control
operator|=
name|ci
operator|->
name|tpb
operator|.
name|control
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|FATAL
condition|)
name|request
operator|->
name|b_flags
operator||=
name|B_ERROR
operator|,
name|request
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|ci
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	Cy_retry_path finishes up the retry sequence for the tape. ** If we were going in the reverse direction it means that we have to ** space forward to correctly position ourselfs in back of the tape gap ** instead of in front of it.  If we were going forward it means that ** we are positioned correctly and we can actually restart the instruction ** that failed before. */
end_comment

begin_expr_stmt
name|cy_retry_path
argument_list|(
name|ctlr
argument_list|)
specifier|register
name|int
name|ctlr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|int
name|cy_do_again_path
parameter_list|()
function_decl|;
specifier|register
name|struct
name|buf
modifier|*
name|cq
init|=
operator|&
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_tab
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|uq
init|=
name|cq
operator|->
name|b_forw
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|request
init|=
name|uq
operator|->
name|av_forw
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|request
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ci
operator|->
name|tpb
operator|.
name|status
operator|&
name|CS_OL
operator|)
condition|)
block|{
name|ci
operator|->
name|interupt_path
operator|=
name|cy_normal_path
expr_stmt|;
name|cy_normal_path
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ci
operator|->
name|tpb
operator|.
name|control
operator|&
name|CW_REV
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ci
operator|->
name|tpb
operator|.
name|status
operator|&
name|CS_LP
operator|)
condition|)
block|{
name|ci
operator|->
name|interupt_path
operator|=
name|cy_do_again_path
expr_stmt|;
name|cyexecute
argument_list|(
name|SPACE
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|5
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|cy_do_again_path
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_expr_stmt
name|cy_extended_gap_path
argument_list|(
name|ctlr
argument_list|)
specifier|register
name|int
name|ctlr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|int
name|cy_do_again_path
parameter_list|()
function_decl|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|cq
init|=
operator|&
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_tab
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|uq
init|=
name|cq
operator|->
name|b_forw
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|request
init|=
name|uq
operator|->
name|av_forw
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|request
operator|->
name|b_dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ci
operator|->
name|tpb
operator|.
name|status
operator|&
name|CS_OL
operator|)
condition|)
block|{
name|ci
operator|->
name|interupt_path
operator|=
name|cy_normal_path
expr_stmt|;
name|cy_normal_path
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ci
operator|->
name|tpb
operator|.
name|control
operator|&
name|CW_REV
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ci
operator|->
name|tpb
operator|.
name|status
operator|&
name|CS_LP
operator|)
condition|)
block|{
name|cyexecute
argument_list|(
name|SPACE
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|5
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ci
operator|->
name|interupt_path
operator|=
name|cy_do_again_path
expr_stmt|;
name|cyexecute
argument_list|(
name|ERASE_F
argument_list|,
operator|(
name|long
operator|)
name|unit_info
index|[
name|unit
index|]
operator|.
name|error_count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
literal|5
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** */
end_comment

begin_expr_stmt
name|cy_do_again_path
argument_list|(
name|ctlr
argument_list|)
specifier|register
name|int
name|ctlr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|int
name|cy_normal_path
parameter_list|()
function_decl|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ci
operator|->
name|tpb
operator|.
name|status
operator|&
name|CS_OL
operator|)
condition|)
block|{
name|ci
operator|->
name|interupt_path
operator|=
name|cy_normal_path
expr_stmt|;
name|cy_normal_path
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
name|ci
operator|->
name|tpb
operator|=
name|ci
operator|->
name|last
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|ci
operator|->
name|ccb
operator|.
name|gate
argument_list|)
expr_stmt|;
while|while
condition|(
name|ci
operator|->
name|ccb
operator|.
name|gate
operator|==
name|GATE_CLOSED
condition|)
name|uncache
argument_list|(
operator|&
name|ci
operator|->
name|ccb
operator|.
name|gate
argument_list|)
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ci
operator|->
name|tpb
argument_list|,
name|ci
operator|->
name|ccb
operator|.
name|tpb_ptr
argument_list|)
expr_stmt|;
name|ci
operator|->
name|ccb
operator|.
name|ccw
operator|=
name|NORMAL_INTERUPT
expr_stmt|;
name|ci
operator|->
name|ccb
operator|.
name|gate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|ci
operator|->
name|interupt_path
operator|=
name|cy_normal_path
expr_stmt|;
name|CY_ATTENTION
argument_list|(
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_addr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	for each longword in the tpb we call uncache to  purge it from **  the cache.  This is done so that we can correctly access tpb data **  that was placed there by the controller. */
end_comment

begin_macro
name|uncache_tpb
argument_list|(
argument|ci
argument_list|)
end_macro

begin_decl_stmt
name|ctlr_tab
modifier|*
name|ci
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
modifier|*
name|ptr
init|=
operator|(
name|long
operator|*
operator|)
operator|&
name|ci
operator|->
name|tpb
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|fmt_tpb
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
name|uncache
argument_list|(
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	Cyprint_error is the common printing routine for all messages **  that need to print the tape status along with it.  This is so we **  we can save space, have consistant messages, and we can send the messages **  to the correct places. */
end_comment

begin_expr_stmt
name|cyprint_err
argument_list|(
name|message
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
specifier|register
name|char
operator|*
name|message
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|unit
decl_stmt|,
name|status
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|status
operator|&=
literal|0xffff
expr_stmt|;
name|printf
argument_list|(
literal|"cy%d: %s!   Status = %x\n"
argument_list|,
name|unit
argument_list|,
name|message
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	Decode the error to determine whether the previous command was **  ok, retryable, or fatal and return the value.  If it was a hardware **  problem we print the message to the console, otherwise we print it **  to the user's terminal later when execute returns. */
end_comment

begin_expr_stmt
name|cydecode_error
argument_list|(
name|unit
argument_list|,
name|status
argument_list|)
specifier|register
name|int
name|unit
operator|,
name|status
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|cydinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|CS_OL
operator|)
operator|&&
operator|(
name|ci
operator|->
name|tpb
operator|.
name|cmd
operator|!=
name|OFF_UNL
operator|)
condition|)
block|{
name|ui
operator|->
name|message
operator|=
literal|"Drive is not on-line"
expr_stmt|;
name|cyprint_err
argument_list|(
name|ui
operator|->
name|message
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|FATAL
return|;
block|}
name|ui
operator|->
name|bot
operator|=
operator|(
operator|(
name|status
operator|&
name|CS_LP
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|ui
operator|->
name|eof
operator|=
operator|(
operator|(
name|status
operator|&
name|CS_FM
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
switch|switch
condition|(
name|status
operator|&
name|CS_ERm
condition|)
block|{
case|case
name|ER_EOT
case|:
if|if
condition|(
name|ci
operator|->
name|tpb
operator|.
name|control
operator|&
name|CW_REV
condition|)
block|{
name|ui
operator|->
name|bot
operator|=
name|TRUE
expr_stmt|;
name|ui
operator|->
name|eot
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ui
operator|->
name|eot
condition|)
block|{
name|ui
operator|->
name|message
operator|=
literal|"End of tape"
expr_stmt|;
name|ui
operator|->
name|bot
operator|=
name|FALSE
expr_stmt|;
name|ui
operator|->
name|eot
operator|=
name|TRUE
expr_stmt|;
block|}
case|case
literal|0
case|:
case|case
name|ER_FM
case|:
case|case
name|ER_NOSTRM
case|:
return|return
literal|0
return|;
case|case
name|ER_TIMOUT
case|:
case|case
name|ER_TIMOUT1
case|:
case|case
name|ER_TIMOUT2
case|:
case|case
name|ER_TIMOUT3
case|:
case|case
name|ER_TIMOUT4
case|:
name|ui
operator|->
name|message
operator|=
literal|"Drive timed out during transfer"
expr_stmt|;
name|cyprint_err
argument_list|(
name|ui
operator|->
name|message
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|FATAL
return|;
case|case
name|ER_NEX
case|:
name|ui
operator|->
name|message
operator|=
literal|"Controller referenced non-existant system memory"
expr_stmt|;
name|cyprint_err
argument_list|(
name|ui
operator|->
name|message
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|FATAL
return|;
case|case
name|ER_DIAG
case|:
case|case
name|ER_JUMPER
case|:
name|ui
operator|->
name|message
operator|=
literal|"Controller diagnostics failed"
expr_stmt|;
name|cyprint_err
argument_list|(
name|ui
operator|->
name|message
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|FATAL
return|;
case|case
name|ER_STROBE
case|:
if|if
condition|(
name|ci
operator|->
name|tpb
operator|.
name|cmd
operator|==
name|READ_BU
condition|)
block|{
name|ci
operator|->
name|last
operator|.
name|cmd
operator|=
name|READ_TA
expr_stmt|;
return|return
name|RETRY
return|;
block|}
if|if
condition|(
name|ci
operator|->
name|tpb
operator|.
name|cmd
operator|==
name|READ_TA
condition|)
return|return
literal|0
return|;
name|ui
operator|->
name|message
operator|=
literal|"Unsatisfactory media found"
expr_stmt|;
return|return
name|FATAL
return|;
case|case
name|ER_FIFO
case|:
case|case
name|ER_NOTRDY
case|:
name|ui
operator|->
name|error_count
operator|=
literal|1
expr_stmt|;
return|return
name|RETRY
return|;
case|case
name|ER_PROT
case|:
name|ui
operator|->
name|message
operator|=
literal|"Tape is write protected"
expr_stmt|;
return|return
name|FATAL
return|;
case|case
name|ER_CHKSUM
case|:
name|ui
operator|->
name|message
operator|=
literal|"Checksum error in controller proms"
expr_stmt|;
name|cyprint_err
argument_list|(
name|ui
operator|->
name|message
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|FATAL
return|;
case|case
name|ER_HARD
case|:
name|ui
operator|->
name|error_count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ci
operator|->
name|tpb
operator|.
name|cmd
operator|==
name|WRIT_TA
operator|)
operator|||
operator|(
name|ci
operator|->
name|tpb
operator|.
name|cmd
operator|==
name|WRIT_BU
operator|)
operator|||
operator|(
name|ci
operator|->
name|tpb
operator|.
name|cmd
operator|==
name|WRIT_FM
operator|)
condition|)
block|{
name|ui
operator|->
name|bad_count
operator|++
expr_stmt|;
return|return
name|EXTEND
return|;
block|}
name|ui
operator|->
name|message
operator|=
literal|"Unrecoverable media error during read"
expr_stmt|;
return|return
name|FATAL
return|;
case|case
name|ER_PARITY
case|:
if|if
condition|(
operator|++
name|ui
operator|->
name|error_count
operator|<
literal|8
condition|)
return|return
name|RETRY
return|;
name|ui
operator|->
name|message
operator|=
literal|"Unrecoverable tape parity error"
expr_stmt|;
return|return
name|FATAL
return|;
case|case
name|ER_BLANK
case|:
name|ui
operator|->
name|message
operator|=
literal|"Blank tape found (data expected)"
expr_stmt|;
return|return
name|FATAL
return|;
case|case
name|ER_HDWERR
case|:
default|default:
name|ui
operator|->
name|message
operator|=
literal|"Unrecoverble hardware error"
expr_stmt|;
name|cyprint_err
argument_list|(
name|ui
operator|->
name|message
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|FATAL
return|;
block|}
block|}
end_block

begin_macro
name|cyread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|CYUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|cystrategy
argument_list|,
operator|&
name|ui
operator|->
name|rawbp
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|cyminsize
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|cywrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|CYUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|cystrategy
argument_list|,
operator|&
name|ui
operator|->
name|rawbp
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|cyminsize
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|cyioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCTOP
case|:
block|{
name|struct
name|mtop
modifier|*
name|mp
init|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|mt_op
operator|<=
name|DO_WAIT
condition|)
return|return
operator|(
name|cycmd
argument_list|(
name|dev
argument_list|,
operator|(
name|int
operator|)
name|mp
operator|->
name|mt_op
argument_list|,
operator|(
name|int
operator|)
name|mp
operator|->
name|mt_count
argument_list|)
operator|)
return|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
case|case
name|MTIOCGET
case|:
block|{
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|CYUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|mtget
modifier|*
name|mp
init|=
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|data
decl_stmt|;
name|mp
operator|->
name|mt_type
operator|=
name|MT_ISCY
expr_stmt|;
name|mp
operator|->
name|mt_dsreg
operator|=
name|ui
operator|->
name|last_control
expr_stmt|;
name|mp
operator|->
name|mt_erreg
operator|=
name|ui
operator|->
name|last_status
expr_stmt|;
name|mp
operator|->
name|mt_resid
operator|=
name|ui
operator|->
name|last_resid
expr_stmt|;
name|mp
operator|->
name|mt_fileno
operator|=
name|ui
operator|->
name|file_number
expr_stmt|;
name|mp
operator|->
name|mt_blkno
operator|=
name|ui
operator|->
name|blkno
expr_stmt|;
name|cycmd
argument_list|(
name|dev
argument_list|,
name|DO_STAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Dump routine.  */
end_comment

begin_macro
name|cydump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|CYUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|int
name|ctlr
init|=
name|cydinfo
index|[
name|unit
index|]
operator|->
name|ui_ctlr
decl_stmt|;
specifier|register
name|unit_tab
modifier|*
name|ui
init|=
operator|&
name|unit_info
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|ctlr_tab
modifier|*
name|ci
init|=
operator|&
name|ctlr_info
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|int
name|blk_siz
decl_stmt|;
specifier|register
name|int
name|num
init|=
name|maxfree
decl_stmt|;
specifier|register
name|int
name|start
init|=
literal|0x800
decl_stmt|;
if|if
condition|(
operator|(
name|unit
operator|>=
name|NCY
operator|)
operator|||
name|cydinfo
index|[
name|unit
index|]
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ui
operator|->
name|control_proto
operator|=
name|CW_LOCK
operator||
name|CW_25ips
operator||
name|CW_16bits
expr_stmt|;
if|if
condition|(
name|cywait
argument_list|(
operator|&
name|ci
operator|->
name|ccb
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|blk_siz
operator|=
name|num
operator|>
name|TBUFSIZ
condition|?
name|TBUFSIZ
else|:
name|num
expr_stmt|;
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|start
operator|*
name|NBPG
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|rawbuf
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|blk_siz
operator|*
name|NBPG
argument_list|)
argument_list|)
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|cmd
operator|=
name|WRIT_TA
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|control
operator|=
name|ui
operator|->
name|control_proto
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|size
operator|=
name|MULTIBUS_SHORT
argument_list|(
name|blk_siz
operator|*
name|NBPG
argument_list|)
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ci
operator|->
name|tpb
operator|.
name|link_ptr
argument_list|)
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|short
operator|*
operator|)
operator|&
name|ci
operator|->
name|tpb
operator|.
name|data_ptr
argument_list|)
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ci
operator|->
name|tpb
argument_list|,
name|ci
operator|->
name|ccb
operator|.
name|tpb_ptr
argument_list|)
expr_stmt|;
name|ci
operator|->
name|ccb
operator|.
name|gate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|CY_ATTENTION
argument_list|(
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_addr
argument_list|)
expr_stmt|;
name|start
operator|+=
name|blk_siz
expr_stmt|;
name|num
operator|-=
name|blk_siz
expr_stmt|;
if|if
condition|(
name|cywait
argument_list|(
operator|&
name|ci
operator|->
name|ccb
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|uncache
argument_list|(
operator|&
name|ci
operator|->
name|tpb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|tpb
operator|.
name|status
operator|&
name|CS_ERm
condition|)
comment|/* error */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
for|for
control|(
name|num
operator|=
literal|0
init|;
name|num
operator|<
literal|2
condition|;
name|num
operator|++
control|)
block|{
name|ci
operator|->
name|tpb
operator|.
name|cmd
operator|=
name|WRIT_FM
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|control
operator|=
name|ui
operator|->
name|control_proto
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|status
operator|=
name|ci
operator|->
name|tpb
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|count
operator|=
name|MULTIBUS_SHORT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ci
operator|->
name|tpb
operator|.
name|link_ptr
argument_list|)
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|short
operator|*
operator|)
operator|&
name|ci
operator|->
name|tpb
operator|.
name|data_ptr
argument_list|)
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ci
operator|->
name|tpb
argument_list|,
name|ci
operator|->
name|ccb
operator|.
name|tpb_ptr
argument_list|)
expr_stmt|;
name|ci
operator|->
name|ccb
operator|.
name|gate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|CY_ATTENTION
argument_list|(
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cywait
argument_list|(
operator|&
name|ci
operator|->
name|ccb
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|uncache
argument_list|(
operator|&
name|ci
operator|->
name|tpb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|tpb
operator|.
name|status
operator|&
name|CS_ERm
condition|)
comment|/* error */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ci
operator|->
name|tpb
operator|.
name|cmd
operator|=
name|REWD_OV
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|control
operator|=
name|ui
operator|->
name|control_proto
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|status
operator|=
name|ci
operator|->
name|tpb
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|ci
operator|->
name|tpb
operator|.
name|count
operator|=
name|MULTIBUS_SHORT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ci
operator|->
name|tpb
operator|.
name|link_ptr
argument_list|)
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
name|ci
operator|->
name|rawbuf
argument_list|,
operator|(
name|short
operator|*
operator|)
operator|&
name|ci
operator|->
name|tpb
operator|.
name|data_ptr
argument_list|)
expr_stmt|;
name|load_mbus_addr
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ci
operator|->
name|tpb
argument_list|,
name|ci
operator|->
name|ccb
operator|.
name|tpb_ptr
argument_list|)
expr_stmt|;
name|ci
operator|->
name|ccb
operator|.
name|gate
operator|=
name|GATE_CLOSED
expr_stmt|;
name|CY_ATTENTION
argument_list|(
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cywait
argument_list|(
operator|&
name|ci
operator|->
name|ccb
argument_list|)
condition|)
return|return
name|EFAULT
return|;
name|uncache
argument_list|(
operator|&
name|ci
operator|->
name|tpb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Poll until the controller is ready.  */
end_comment

begin_expr_stmt
name|cywait
argument_list|(
name|cp
argument_list|)
specifier|register
name|fmt_ccb
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|5000
decl_stmt|;
name|uncache
argument_list|(
operator|&
name|cp
operator|->
name|gate
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
operator|&&
name|cp
operator|->
name|gate
operator|==
name|GATE_CLOSED
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|cp
operator|->
name|gate
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|<=
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Load a 20 bit pointer into the i/o registers.  */
end_comment

begin_macro
name|load_mbus_addr
argument_list|(
argument|in
argument_list|,
argument|out
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|tmp_in
init|=
operator|(
name|int
operator|)
name|in
decl_stmt|;
specifier|register
name|char
modifier|*
name|out_ptr
init|=
operator|(
name|char
operator|*
operator|)
name|out
decl_stmt|;
operator|*
name|out_ptr
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|tmp_in
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|out_ptr
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|tmp_in
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|out_ptr
operator|++
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
operator|*
name|out_ptr
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|tmp_in
operator|&
literal|0xf0000
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **	CYMINSIZE s supposed to adjust the buffer size for any raw i/o. **  since tapes can not read  the tail end of partial blocks we ignore **  this request and strategy will return an appropriate error message later. ** **	If this is not done UNIX will lose data that is on the tape. */
end_comment

begin_function
name|unsigned
name|cyminsize
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|MAX_BLOCKSIZE
condition|)
name|bp
operator|->
name|b_bcount
operator|=
name|MAX_BLOCKSIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unconditionally reset all controllers to their initial state.  */
end_comment

begin_macro
name|cyreset
argument_list|(
argument|vba
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vba
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|caddr_t
name|addr
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|;
for|for
control|(
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|NCY
condition|;
name|ctlr
operator|++
control|)
if|if
condition|(
name|cyminfo
index|[
name|ctlr
index|]
operator|&&
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_vbanum
operator|==
name|vba
condition|)
block|{
name|addr
operator|=
name|cyminfo
index|[
name|ctlr
index|]
operator|->
name|um_addr
expr_stmt|;
name|CY_RESET
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cy_init_controller
argument_list|(
name|addr
argument_list|,
name|ctlr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cy%d: reset failed\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
name|cyminfo
index|[
name|ctlr
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

