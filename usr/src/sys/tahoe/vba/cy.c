begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	cy.c	1.1	85/07/21	*/
end_comment

begin_comment
comment|/*	cy.c	Tahoe version 	Mar 1983.	*/
end_comment

begin_include
include|#
directive|include
file|"cy.h"
end_include

begin_if
if|#
directive|if
name|NCY
operator|>
literal|0
end_if

begin_comment
comment|/* number of CYPHER tapes in system */
end_comment

begin_comment
comment|/*  * Cypher tape driver  *  */
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/vm.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/conf.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/file.h"
end_include

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../vba/vbavar.h"
end_include

begin_include
include|#
directive|include
file|"../h/mtio.h"
end_include

begin_include
include|#
directive|include
file|"../machine/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../h/ioctl.h"
end_include

begin_include
include|#
directive|include
file|"../h/cmap.h"
end_include

begin_include
include|#
directive|include
file|"../h/uio.h"
end_include

begin_include
include|#
directive|include
file|"../vba/cyvar.h"
end_include

begin_define
define|#
directive|define
name|NTM
value|1
end_define

begin_comment
comment|/* number of TAPEMASTER controllers */
end_comment

begin_comment
comment|/*  * There is a ccybuf per tape controller.  * It is used as the token to pass to the control routines  * and also acts as a lock on the slaves on the  * controller, since there is only one per controller.  * In particular, when the tape is rewinding on close we release  * the user process but any further attempts to use the tape drive  * before the rewind completes will hang waiting for ccybuf.  */
end_comment

begin_decl_stmt
name|struct
name|buf
name|ccybuf
index|[
name|NTM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Raw tape operations use rcybuf.  The driver  * notices when rcybuf is being used and allows the user  * program to continue after errors and read records  * not of the standard length (BSIZE).  */
end_comment

begin_decl_stmt
name|struct
name|buf
name|rcybuf
index|[
name|NTM
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cybufused
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Driver interface routines and variables.  */
end_comment

begin_decl_stmt
name|int
name|cyprobe
argument_list|()
decl_stmt|,
name|cyslave
argument_list|()
decl_stmt|,
name|cyattach
argument_list|()
decl_stmt|,
name|cydgo
argument_list|()
decl_stmt|,
name|cyintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cywait
argument_list|()
decl_stmt|,
name|cyrewind
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|unsigned
name|tminphys
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|cyminfo
index|[
name|NTM
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|cydinfo
index|[
name|NCY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|cyutab
index|[
name|NCY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|cytotm
index|[
name|NCY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|cyutl
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cystd
index|[]
init|=
block|{
literal|0x400000
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vba_driver
name|cydriver
init|=
block|{
name|cyprobe
block|,
name|cyslave
block|,
name|cyattach
block|,
name|cydgo
block|,
name|cystd
block|,
literal|"yc"
block|,
name|cydinfo
block|,
literal|"cy"
block|,
name|cyminfo
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bits in minor device */
end_comment

begin_define
define|#
directive|define
name|CYUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)&07)
end_define

begin_comment
comment|/* tape unit number */
end_comment

begin_define
define|#
directive|define
name|TMUNIT
parameter_list|(
name|dev
parameter_list|)
value|(cytotm[CYUNIT(dev)])
end_define

begin_comment
comment|/* tape controller number */
end_comment

begin_define
define|#
directive|define
name|T_NOREWIND
value|0x08
end_define

begin_comment
comment|/* no rewind bit */
end_comment

begin_define
define|#
directive|define
name|T_100IPS
value|0x10
end_define

begin_comment
comment|/* high speed flag */
end_comment

begin_decl_stmt
name|int
name|pflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* probe flag, set every interrupt by cyintr */
end_comment

begin_define
define|#
directive|define
name|INF
value|(daddr_t)1000000L
end_define

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|scp
comment|/* SYSTEM CONFIGUREATION POINTER */
block|{
name|char
name|sysbus
decl_stmt|;
comment|/* width of system buss 0=8;1=16 */
name|char
name|nu1
decl_stmt|;
name|char
name|pt_scb
index|[
literal|4
index|]
decl_stmt|;
comment|/* pointer to ->SYSTEM CONFIGUREATION BLOCK */
block|}
struct|;
end_struct

begin_comment
comment|/* absolute address - jumpered on the controller */
end_comment

begin_define
define|#
directive|define
name|SCP
value|((struct scp *)0xc0000c06)
end_define

begin_struct
struct|struct
name|Scb
comment|/* SYSTEM CONFIGUREATION BLOCK */
block|{
name|char
name|sysblk
index|[
literal|1
index|]
decl_stmt|;
comment|/* 0x03 fixed value code */
name|char
name|nu2
index|[
literal|1
index|]
decl_stmt|;
name|char
name|pt_ccb
index|[
literal|4
index|]
decl_stmt|;
comment|/* pointer to ->CHANNEL CONTROL BLOCK */
block|}
name|Scb
struct|;
end_struct

begin_struct
struct|struct
name|ccb
comment|/* CHANNEL CONTROL BLOCK */
block|{
name|char
name|ccw
index|[
literal|1
index|]
decl_stmt|;
comment|/* 0x11 normal; 0x09 clear non_vect interrupt */
name|char
name|gate
index|[
literal|1
index|]
decl_stmt|;
comment|/* This is "the" GATE */
name|char
name|pt_tpb
index|[
literal|4
index|]
decl_stmt|;
comment|/* pointer to ->TAPE OPERATION BLOCK or MOVE BLOCK */
block|}
name|ccb
struct|;
end_struct

begin_struct
struct|struct
name|tpb
comment|/* TAPE OPERATIONS PARAMETER BLOCK */
block|{
name|long
name|cmd
decl_stmt|;
comment|/* COMMAND (input) */
name|char
name|control
index|[
literal|2
index|]
decl_stmt|;
comment|/* CONTROL (input) */
name|short
name|count
decl_stmt|;
comment|/* RETURN COUNT (output) */
name|short
name|size
decl_stmt|;
comment|/* BUFFER SIZE (input/output) */
name|short
name|rec_over
decl_stmt|;
comment|/* RECORDS/OVERRUN (input/output) */
name|char
name|pt_data
index|[
literal|4
index|]
decl_stmt|;
comment|/* pointer to ->SOURCE/DEST (input) */
name|char
name|status
index|[
literal|2
index|]
decl_stmt|;
comment|/* STATUS (output) */
name|char
name|pt_link
index|[
literal|4
index|]
decl_stmt|;
comment|/* pointer to ->INTERRUPT/PARAMETER BLOCK (input) */
block|}
name|tpb
index|[
name|NTM
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|tpb
name|cycool
comment|/* tape parameter block to clear interrupts */
init|=
block|{
literal|0L
block|,
comment|/* command */
literal|0
block|,
literal|0
block|,
comment|/* control */
literal|0
block|,
comment|/* count */
literal|0
block|,
comment|/* size */
literal|0
block|,
comment|/* rec_over */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* pt_data */
literal|0
block|,
literal|0
block|,
comment|/* status */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* pt_link */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Software state per tape transport.  *  * 1. A tape drive is a unique-open device; we refuse opens when it is already.  * 2. We keep track of the current position on a block tape and seek  *    before operations by forward/back spacing if necessary.  * 3. We remember if the last operation was a write on a tape, so if a tape  *    is open read write and the last thing done is a write we can  *    write a standard end of tape mark (two eofs).  */
end_comment

begin_struct
struct|struct
name|cy_softc
block|{
name|char
name|cy_openf
decl_stmt|;
comment|/* lock against multiple opens */
name|char
name|cy_lastiow
decl_stmt|;
comment|/* last op was a write */
name|daddr_t
name|cy_blkno
decl_stmt|;
comment|/* block number, for block device tape */
name|daddr_t
name|cy_nxrec
decl_stmt|;
comment|/* position of end of tape, if known */
name|daddr_t
name|cy_timo
decl_stmt|;
comment|/* time until timeout expires */
name|short
name|cy_tact
decl_stmt|;
comment|/* timeout is active */
name|short
name|cy_count
decl_stmt|;
comment|/* return count of last operation */
name|char
name|cy_status
index|[
literal|2
index|]
decl_stmt|;
comment|/* return status of last operation */
block|}
name|cy_softc
index|[
name|NTM
index|]
struct|;
end_struct

begin_comment
comment|/*   * I/O buffer for raw devices.  */
end_comment

begin_decl_stmt
name|char
name|cybuf
index|[
name|TBUFSIZ
operator|*
name|NBPG
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 10k buffer */
end_comment

begin_comment
comment|/*  * States for um->um_tab.b_active, the per controller state flag.  * This is used to sequence control in the driver.  */
end_comment

begin_define
define|#
directive|define
name|SSEEK
value|1
end_define

begin_comment
comment|/* seeking */
end_comment

begin_define
define|#
directive|define
name|SIO
value|2
end_define

begin_comment
comment|/* doing seq i/o */
end_comment

begin_define
define|#
directive|define
name|SCOM
value|3
end_define

begin_comment
comment|/* sending control command */
end_comment

begin_define
define|#
directive|define
name|SREW
value|4
end_define

begin_comment
comment|/* sending a drive rewind */
end_comment

begin_comment
comment|/*  * Determine if there is a controller for  * a cypher at address ctlr_vaddr.    * Reset the controller.  * Our goal is to make the device interrupt.  */
end_comment

begin_macro
name|cyprobe
argument_list|(
argument|ctlr_vaddr
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|ctlr_vaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
modifier|*
name|ip
decl_stmt|;
name|pflag
operator|=
literal|0
expr_stmt|;
comment|/* clear interrupt flag */
if|if
condition|(
name|badcyaddr
argument_list|(
name|ctlr_vaddr
operator|+
literal|1
argument_list|)
condition|)
comment|/* check for versabuss timeout  */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Initialize the system configuration pointer 	 */
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
name|vtopte
argument_list|(
literal|0
argument_list|,
name|btop
argument_list|(
name|SCP
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ip
operator|&=
operator|~
name|PG_PROT
expr_stmt|;
operator|*
name|ip
operator||=
name|PG_KW
expr_stmt|;
name|mtpr
argument_list|(
name|SCP
argument_list|,
name|TBIS
argument_list|)
expr_stmt|;
name|SCP
operator|->
name|sysbus
operator|=
literal|1
expr_stmt|;
comment|/* system width = 16 bits. */
comment|/* initialize the pointer to the system configuration block */
name|set_pointer
argument_list|(
operator|(
name|int
operator|)
operator|&
name|Scb
operator|.
name|sysblk
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|SCP
operator|->
name|pt_scb
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the system configuration block. 	 */
name|Scb
operator|.
name|sysblk
index|[
literal|0
index|]
operator|=
literal|0x3
expr_stmt|;
comment|/* fixed value */
comment|/* initialize the pointer to the channel control block */
name|set_pointer
argument_list|(
operator|(
name|int
operator|)
operator|&
name|ccb
operator|.
name|ccw
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Scb
operator|.
name|pt_ccb
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the channel control block. 	 */
name|ccb
operator|.
name|ccw
index|[
literal|0
index|]
operator|=
literal|0x11
expr_stmt|;
comment|/* normal interrupts */
comment|/* initialize the pointer to the tape parameter block */
name|set_pointer
argument_list|(
operator|(
name|int
operator|)
operator|&
name|tpb
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ccb
operator|.
name|pt_tpb
argument_list|)
expr_stmt|;
comment|/* 	 * set the command to be CONFIGURE. 	 */
name|tpb
index|[
literal|0
index|]
operator|.
name|cmd
operator|=
name|CONFIG
expr_stmt|;
name|tpb
index|[
literal|0
index|]
operator|.
name|control
index|[
literal|0
index|]
operator|=
name|CW_I
expr_stmt|;
comment|/* interrupt on completion */
name|tpb
index|[
literal|0
index|]
operator|.
name|control
index|[
literal|1
index|]
operator|=
name|CW_16bits
expr_stmt|;
name|ccb
operator|.
name|gate
index|[
literal|0
index|]
operator|=
name|GATE_CLOSED
expr_stmt|;
operator|*
name|ip
operator|&=
operator|~
name|PG_PROT
expr_stmt|;
operator|*
name|ip
operator||=
name|PG_KR
expr_stmt|;
name|mtpr
argument_list|(
name|SCP
argument_list|,
name|TBIS
argument_list|)
expr_stmt|;
name|TM_ATTENTION
argument_list|(
name|ctlr_vaddr
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* execute! */
if|if
condition|(
name|cywait
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Due to a design flaw, we cannot ascertain if the tape  * exists or not unless it is on line - ie: unless a tape is  * mounted. This is too severe a restriction to bear,  * so all units are assumed to exist.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|cyslave
argument_list|(
argument|ui
argument_list|,
argument|ctlr_vaddr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|ctlr_vaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Record attachment of the unit to the controller.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|cyattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * Cytotm is used in TMUNIT to index the ccybuf and rcybuf 	 * arrays given a cy unit number. 	 */
name|cytotm
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|=
name|ui
operator|->
name|ui_mi
operator|->
name|um_ctlr
expr_stmt|;
block|}
end_block

begin_function_decl
name|int
name|cytimer
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Open the device.  Tapes are unique open  * devices, so we refuse if it is already open.  * We also check that a tape is available, and  * don't block waiting here; if you want to wait  * for a tape you should timeout in user code.  */
end_comment

begin_macro
name|cyopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cyunit
decl_stmt|,
name|s
decl_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
decl_stmt|;
name|cyunit
operator|=
name|CYUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cyunit
operator|>=
name|NCY
operator|||
operator|(
name|cy
operator|=
operator|&
name|cy_softc
index|[
name|cyunit
index|]
operator|)
operator|->
name|cy_openf
operator|||
operator|(
name|ui
operator|=
name|cydinfo
index|[
name|cyunit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
name|cycommand
argument_list|(
name|dev
argument_list|,
operator|(
name|int
operator|)
name|DRIVE_S
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* drive status */
name|uncache
argument_list|(
operator|&
name|tpb
index|[
name|cyunit
index|]
operator|.
name|status
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tpb
index|[
name|cyunit
index|]
operator|.
name|status
index|[
literal|0
index|]
operator|&
operator|(
name|CS_DR
operator||
name|CS_OL
operator|)
operator|)
operator|!=
operator|(
name|CS_DR
operator||
name|CS_OL
operator|)
condition|)
block|{
name|uprintf
argument_list|(
literal|"cy%d: not online\n"
argument_list|,
name|cyunit
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|tpb
index|[
name|cyunit
index|]
operator|.
name|status
index|[
literal|0
index|]
operator|&
name|CS_P
operator|)
condition|)
block|{
name|uprintf
argument_list|(
literal|"cy%d: no write ring\n"
argument_list|,
name|cyunit
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|cy
operator|->
name|cy_openf
operator|=
literal|1
expr_stmt|;
name|cy
operator|->
name|cy_blkno
operator|=
operator|(
name|daddr_t
operator|)
literal|0
expr_stmt|;
name|cy
operator|->
name|cy_nxrec
operator|=
name|INF
expr_stmt|;
name|cy
operator|->
name|cy_lastiow
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
if|if
condition|(
name|cy
operator|->
name|cy_tact
operator|==
literal|0
condition|)
block|{
name|cy
operator|->
name|cy_timo
operator|=
name|INF
expr_stmt|;
name|cy
operator|->
name|cy_tact
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|cytimer
argument_list|,
operator|(
name|caddr_t
operator|)
name|dev
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Close tape device.  *  * If tape was open for writing or last operation was  * a write, then write two EOF's and backspace over the last one.  * Unless this is a non-rewinding special file, rewind the tape.  * Make the tape available to others.  */
end_comment

begin_expr_stmt
name|cyclose
argument_list|(
name|dev
argument_list|,
name|flag
argument_list|)
specifier|register
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|flag
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
init|=
operator|&
name|cy_softc
index|[
name|CYUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|FWRITE
operator|||
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
name|cy
operator|->
name|cy_lastiow
condition|)
block|{
name|cycommand
argument_list|(
name|dev
argument_list|,
operator|(
name|int
operator|)
name|WRIT_FM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write file mark */
name|cycommand
argument_list|(
name|dev
argument_list|,
operator|(
name|int
operator|)
name|WRIT_FM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cycommand
argument_list|(
name|dev
argument_list|,
operator|(
name|int
operator|)
name|SP_BACK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* space back */
block|}
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_NOREWIND
operator|)
operator|==
literal|0
condition|)
comment|/* 		 * 0 count means don't hang waiting for rewind complete 		 * rather ccybuf stays busy until the operation completes 		 * preventing further opens from completing by 		 * preventing a SENSE operation from completing. 		 */
name|cycommand
argument_list|(
name|dev
argument_list|,
operator|(
name|int
operator|)
name|REWD_TA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_openf
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|commflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* signal cystrategy that it is called from cycommand */
end_comment

begin_comment
comment|/*  * Execute a command on the tape drive  * a specified number of times.  */
end_comment

begin_macro
name|cycommand
argument_list|(
argument|dev
argument_list|,
argument|com
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|com
decl_stmt|,
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|bp
operator|=
operator|&
name|ccybuf
index|[
name|TMUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
while|while
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
comment|/* 		 * This special check is because B_BUSY never 		 * gets cleared in the non-waiting rewind case. 		 */
if|if
condition|(
name|bp
operator|->
name|b_repcnt
operator|==
literal|0
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
condition|)
break|break;
name|bp
operator|->
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_repcnt
operator|=
name|count
expr_stmt|;
name|bp
operator|->
name|b_command
operator|=
name|com
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
literal|0
expr_stmt|;
name|commflag
operator|=
literal|1
expr_stmt|;
name|cystrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|commflag
operator|=
literal|0
expr_stmt|;
comment|/* 	 * In case of rewind from close, don't wait. 	 * This is the only case where count can be 0. 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
name|iowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
name|B_ERROR
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Queue a tape operation.  */
end_comment

begin_expr_stmt
name|cystrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|cyunit
init|=
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
comment|/* 	 * Put transfer at end of unit queue 	 */
name|dp
operator|=
operator|&
name|cyutab
index|[
name|cyunit
index|]
expr_stmt|;
name|bp
operator|->
name|av_forw
operator|=
name|NULL
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
comment|/*  * Next piece of logic takes care of unusual cases when more than  * a full block is required.   * The driver reads the tape to a temporary buffer and  * then moves the amount needed back to the process.  * In this case, the flag NOT1K is set.  */
if|if
condition|(
name|commflag
operator|==
literal|0
condition|)
name|buf_setup
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|um
operator|=
name|cydinfo
index|[
name|cyunit
index|]
operator|->
name|ui_mi
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
operator|==
name|NULL
condition|)
block|{
name|dp
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
comment|/* 		 * Transport not already active... 		 * put at end of controller queue. 		 */
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
block|}
else|else
name|dp
operator|->
name|b_actl
operator|->
name|av_forw
operator|=
name|bp
expr_stmt|;
name|dp
operator|->
name|b_actl
operator|=
name|bp
expr_stmt|;
comment|/* 	 * If the controller is not busy, get 	 * it going. 	 */
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|==
literal|0
condition|)
name|cystart
argument_list|(
name|um
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start activity on a cypher controller.  */
end_comment

begin_expr_stmt
name|cystart
argument_list|(
name|um
argument_list|)
specifier|register
expr|struct
name|vba_ctlr
operator|*
name|um
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|tpb
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
decl_stmt|;
specifier|register
name|int
name|phadr
decl_stmt|;
name|int
name|cyunit
decl_stmt|,
name|timer
decl_stmt|;
name|daddr_t
name|blkno
decl_stmt|;
name|caddr_t
name|ctlr_vaddr
decl_stmt|;
name|ctlr_vaddr
operator|=
name|um
operator|->
name|um_addr
expr_stmt|;
comment|/* 	 * Look for an idle transport on the controller. 	 */
name|loop
label|:
if|if
condition|(
operator|(
name|dp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|cyunit
operator|=
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|cy
operator|=
operator|&
name|cy_softc
index|[
name|cyunit
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|tpb
index|[
name|cyunit
index|]
expr_stmt|;
comment|/* 	 * Default is that last command was NOT a write command; 	 * if we do a write command we will notice this in cyintr(). 	 */
name|cy
operator|->
name|cy_lastiow
operator|=
literal|0
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|tp
operator|->
name|status
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|tp
operator|->
name|count
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_count
operator|=
name|TM_SHORT
argument_list|(
name|tp
operator|->
name|count
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_status
index|[
literal|0
index|]
operator|=
name|tp
operator|->
name|status
index|[
literal|0
index|]
expr_stmt|;
name|cy
operator|->
name|cy_status
index|[
literal|1
index|]
operator|=
name|tp
operator|->
name|status
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cy
operator|->
name|cy_openf
operator|<
literal|0
operator|||
operator|(
name|bp
operator|->
name|b_command
operator|!=
name|DRIVE_S
operator|)
operator|&&
operator|(
operator|(
name|tp
operator|->
name|status
index|[
literal|0
index|]
operator|&
name|CS_OL
operator|)
operator|!=
name|CS_OL
operator|)
condition|)
block|{
comment|/* 		 * Have had a hard error on a non-raw tape 		 * or the tape unit is now unavailable 		 * (e.g. taken off line). 		 */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|bp
operator|==
operator|&
name|ccybuf
index|[
name|TMUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
condition|)
block|{
comment|/* 		 * Execute control operation with the specified count. 		 * Set next state; give 5 minutes to complete 		 * rewind, or 10 seconds per iteration (minimum 60 		 * seconds and max 5 minutes) to complete other ops. 		 */
if|if
condition|(
name|bp
operator|->
name|b_command
operator|==
name|REWD_TA
condition|)
block|{
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
name|SREW
expr_stmt|;
name|cy
operator|->
name|cy_timo
operator|=
literal|5
operator|*
literal|60
expr_stmt|;
block|}
else|else
block|{
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
name|SCOM
expr_stmt|;
name|cy
operator|->
name|cy_timo
operator|=
name|imin
argument_list|(
name|imax
argument_list|(
literal|10
operator|*
operator|(
name|int
operator|)
name|bp
operator|->
name|b_repcnt
argument_list|,
literal|60
argument_list|)
argument_list|,
literal|5
operator|*
literal|60
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Prepare parameter block for controller 		 */
name|tp
operator|->
name|cmd
operator|=
name|bp
operator|->
name|b_command
expr_stmt|;
name|tp
operator|->
name|control
index|[
literal|0
index|]
operator|=
operator|(
name|CW_I
operator||
operator|(
name|cyunit
operator|<<
name|CW_TSs
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
name|T_100IPS
condition|)
name|tp
operator|->
name|control
index|[
literal|1
index|]
operator|=
operator|(
name|CW_100ips
operator||
name|CW_16bits
operator|)
expr_stmt|;
else|else
name|tp
operator|->
name|control
index|[
literal|1
index|]
operator|=
operator|(
name|CW_25ips
operator||
name|CW_16bits
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_command
operator|==
name|SP_BACK
condition|)
block|{
name|tp
operator|->
name|control
index|[
literal|1
index|]
operator||=
name|CW_R
expr_stmt|;
name|tp
operator|->
name|cmd
operator|=
name|SPACE
expr_stmt|;
name|tp
operator|->
name|rec_over
operator|=
name|TM_SHORT
argument_list|(
operator|(
name|short
operator|)
name|bp
operator|->
name|b_repcnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_command
operator|==
name|SP_FORW
condition|)
name|tp
operator|->
name|rec_over
operator|=
name|TM_SHORT
argument_list|(
operator|(
name|short
operator|)
name|bp
operator|->
name|b_repcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_command
operator|==
name|SRFM_BK
condition|)
block|{
name|tp
operator|->
name|control
index|[
literal|1
index|]
operator||=
name|CW_R
expr_stmt|;
name|tp
operator|->
name|cmd
operator|=
name|SERH_FM
expr_stmt|;
name|tp
operator|->
name|rec_over
operator|=
name|TM_SHORT
argument_list|(
operator|(
name|short
operator|)
name|bp
operator|->
name|b_repcnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_command
operator|==
name|SRFM_FD
condition|)
name|tp
operator|->
name|rec_over
operator|=
name|TM_SHORT
argument_list|(
operator|(
name|short
operator|)
name|bp
operator|->
name|b_repcnt
argument_list|)
expr_stmt|;
name|tp
operator|->
name|status
index|[
literal|0
index|]
operator|=
name|tp
operator|->
name|status
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|set_pointer
argument_list|(
operator|(
name|int
operator|)
operator|&
name|tpb
index|[
name|cyunit
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ccb
operator|.
name|pt_tpb
argument_list|)
expr_stmt|;
goto|goto
name|dobpcmd
goto|;
block|}
comment|/* 	 * The following checks handle boundary cases for operation 	 * on non-raw tapes.  On raw tapes the initialization of 	 * cy->cy_nxrec by cyphys causes them to be skipped normally 	 */
if|if
condition|(
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|>
name|cy
operator|->
name|cy_nxrec
condition|)
block|{
comment|/* 		 * Can't read past known end-of-file. 		 */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|==
name|cy
operator|->
name|cy_nxrec
operator|&&
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
comment|/* 		 * Reading at end of file returns 0 bytes. 		 */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
comment|/* 		 * Writing sets EOF 		 */
name|cy
operator|->
name|cy_nxrec
operator|=
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 	 * If the data transfer command is in the correct place, 	 * set up the tape parameter block, and start the i/o. 	 */
if|if
condition|(
operator|(
name|blkno
operator|=
name|cy
operator|->
name|cy_blkno
operator|)
operator|==
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
condition|)
block|{
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
name|SIO
expr_stmt|;
name|cy
operator|->
name|cy_timo
operator|=
literal|60
expr_stmt|;
comment|/* premature, but should serve */
name|phadr
operator|=
name|get_ioadr
argument_list|(
name|bp
argument_list|,
name|cybuf
argument_list|,
name|CYmap
argument_list|,
name|cyutl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|cmd
operator|=
name|WRIT_BU
expr_stmt|;
else|else
name|tp
operator|->
name|cmd
operator|=
name|READ_BU
expr_stmt|;
name|tp
operator|->
name|control
index|[
literal|0
index|]
operator|=
operator|(
name|CW_I
operator||
operator|(
name|cyunit
operator|<<
name|CW_TSs
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
name|T_100IPS
condition|)
name|tp
operator|->
name|control
index|[
literal|1
index|]
operator|=
operator|(
name|CW_100ips
operator||
name|CW_16bits
operator|)
expr_stmt|;
else|else
name|tp
operator|->
name|control
index|[
literal|1
index|]
operator|=
operator|(
name|CW_25ips
operator||
name|CW_16bits
operator|)
expr_stmt|;
name|tp
operator|->
name|status
index|[
literal|0
index|]
operator|=
name|tp
operator|->
name|status
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|size
operator|=
name|TM_SHORT
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|set_pointer
argument_list|(
name|phadr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tp
operator|->
name|pt_data
argument_list|)
expr_stmt|;
name|set_pointer
argument_list|(
operator|(
name|int
operator|)
operator|&
name|tpb
index|[
name|cyunit
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ccb
operator|.
name|pt_tpb
argument_list|)
expr_stmt|;
goto|goto
name|dobpcmd
goto|;
block|}
comment|/* 	 * Tape positioned incorrectly; 	 * set to seek forwards or backwards to the correct spot. 	 */
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
name|SSEEK
expr_stmt|;
name|tp
operator|->
name|cmd
operator|=
name|SPACE
expr_stmt|;
name|tp
operator|->
name|control
index|[
literal|0
index|]
operator|=
operator|(
name|CW_I
operator||
operator|(
name|cyunit
operator|<<
name|CW_TSs
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
name|T_100IPS
condition|)
name|tp
operator|->
name|control
index|[
literal|1
index|]
operator|=
operator|(
name|CW_100ips
operator||
name|CW_16bits
operator|)
expr_stmt|;
else|else
name|tp
operator|->
name|control
index|[
literal|1
index|]
operator|=
operator|(
name|CW_25ips
operator||
name|CW_16bits
operator|)
expr_stmt|;
name|tp
operator|->
name|status
index|[
literal|0
index|]
operator|=
name|tp
operator|->
name|status
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|set_pointer
argument_list|(
operator|(
name|int
operator|)
operator|&
name|tpb
index|[
name|cyunit
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ccb
operator|.
name|pt_tpb
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
operator|<
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
condition|)
name|tp
operator|->
name|rec_over
operator|=
name|TM_SHORT
argument_list|(
call|(
name|short
call|)
argument_list|(
name|blkno
operator|-
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tp
operator|->
name|rec_over
operator|=
name|TM_SHORT
argument_list|(
call|(
name|short
call|)
argument_list|(
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|-
name|blkno
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|control
index|[
literal|1
index|]
operator||=
name|CW_R
expr_stmt|;
block|}
name|cy
operator|->
name|cy_timo
operator|=
name|imin
argument_list|(
name|imax
argument_list|(
literal|10
operator|*
operator|(
name|int
operator|)
name|TM_SHORT
argument_list|(
name|tp
operator|->
name|rec_over
argument_list|)
argument_list|,
literal|60
argument_list|)
argument_list|,
literal|5
operator|*
literal|60
argument_list|)
expr_stmt|;
name|dobpcmd
label|:
comment|/* 	 * Do the command in bp. 	 */
name|timer
operator|=
literal|8000
expr_stmt|;
comment|/* software tolerance for gate open */
name|uncache
argument_list|(
operator|&
name|ccb
operator|.
name|gate
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccb
operator|.
name|gate
index|[
literal|0
index|]
operator|!=
name|GATE_OPEN
condition|)
block|{
if|if
condition|(
operator|--
name|timer
operator|==
literal|0
condition|)
block|{
name|ccb
operator|.
name|ccw
index|[
literal|0
index|]
operator|=
literal|0x9
expr_stmt|;
comment|/* forget it...... */
name|TM_RESET
argument_list|(
name|ctlr_vaddr
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|uncache
argument_list|(
operator|&
name|ccb
operator|.
name|gate
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|.
name|ccw
index|[
literal|0
index|]
operator|=
literal|0x11
expr_stmt|;
comment|/* normal mode */
name|ccb
operator|.
name|gate
index|[
literal|0
index|]
operator|=
name|GATE_CLOSED
expr_stmt|;
name|TM_ATTENTION
argument_list|(
name|ctlr_vaddr
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* execute! */
return|return;
name|next
label|:
comment|/* 	 * Done with this operation due to error or 	 * the fact that it doesn't do anything. 	 * dequeue the transfer and continue processing this slave. 	 */
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_block

begin_comment
comment|/*  * Kept for historical reasons. Probably not neccessary.   */
end_comment

begin_macro
name|cydgo
argument_list|(
argument|um
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vba_ctlr
modifier|*
name|um
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/*  * Cy interrupt routine.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|cyintr
argument_list|(
argument|ctlr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ctlr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|tpb
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|um
init|=
name|cyminfo
index|[
name|ctlr
index|]
decl_stmt|;
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
decl_stmt|;
name|caddr_t
name|ctlr_vaddr
decl_stmt|;
name|int
name|cyunit
decl_stmt|;
specifier|register
name|state
expr_stmt|;
comment|/* 	 * First we clear the interrupt and close the gate. 	 */
name|ctlr_vaddr
operator|=
name|um
operator|->
name|um_addr
expr_stmt|;
name|ccb
operator|.
name|ccw
index|[
literal|0
index|]
operator|=
literal|0x9
expr_stmt|;
comment|/* clear the interrupt */
name|ccb
operator|.
name|gate
index|[
literal|0
index|]
operator|=
name|GATE_CLOSED
expr_stmt|;
name|set_pointer
argument_list|(
operator|(
name|int
operator|)
operator|&
name|cycool
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ccb
operator|.
name|pt_tpb
argument_list|)
expr_stmt|;
name|cycool
operator|.
name|cmd
operator|=
name|NO_OP
expr_stmt|;
comment|/* no operation */
name|cycool
operator|.
name|control
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* No INTERRUPTS */
name|cycool
operator|.
name|control
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|TM_ATTENTION
argument_list|(
name|ctlr_vaddr
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* cool it ! */
name|cywait
argument_list|()
expr_stmt|;
comment|/* 	 * Now we can start handling the interrupt. 	 */
name|pflag
operator|=
literal|1
expr_stmt|;
comment|/* set for the probe routine */
if|if
condition|(
name|intenable
operator|==
literal|0
condition|)
return|return;
comment|/* ignore all interrupts */
if|if
condition|(
operator|(
name|dp
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|)
operator|==
name|NULL
condition|)
return|return;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|cyunit
operator|=
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|tpb
index|[
name|cyunit
index|]
expr_stmt|;
name|cy
operator|=
operator|&
name|cy_softc
index|[
name|cyunit
index|]
expr_stmt|;
comment|/* 	 * If last command was a rewind, and tape is still 	 * rewinding, wait for the rewind complete interrupt. 	 */
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|==
name|SREW
condition|)
block|{
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
name|SCOM
expr_stmt|;
comment|/* uncache(&tp->status[1]); */
comment|/* if (tp->status[1]&CS_CC != CS_CC) { */
comment|/* not completed */
comment|/* cy->cy_timo = 5*60; */
comment|/* 5 minutes */
comment|/* return; */
comment|/* } */
block|}
comment|/* 	 * An operation completed... update status 	 */
name|cy
operator|->
name|cy_timo
operator|=
name|INF
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|tp
operator|->
name|count
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|tp
operator|->
name|status
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_count
operator|=
name|TM_SHORT
argument_list|(
name|tp
operator|->
name|count
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_status
index|[
literal|0
index|]
operator|=
name|tp
operator|->
name|status
index|[
literal|0
index|]
expr_stmt|;
name|cy
operator|->
name|cy_status
index|[
literal|1
index|]
operator|=
name|tp
operator|->
name|status
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
name|cy
operator|->
name|cy_lastiow
operator|=
literal|1
expr_stmt|;
name|state
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_active
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check for errors. 	 */
if|if
condition|(
name|tp
operator|->
name|status
index|[
literal|1
index|]
operator|&
name|CS_ERm
condition|)
block|{
comment|/* 		 * If we hit the end of the tape file, update our position. 		 */
if|if
condition|(
name|tp
operator|->
name|status
index|[
literal|0
index|]
operator|&
name|CS_FM
condition|)
block|{
name|cyseteof
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* set blkno and nxrec */
name|state
operator|=
name|SCOM
expr_stmt|;
goto|goto
name|opdone
goto|;
block|}
comment|/* If reading raw device and block was too short ignore the 		 * error and let the user program decide what to do. 		 */
if|if
condition|(
operator|(
name|tp
operator|->
name|status
index|[
literal|0
index|]
operator|&
name|ER_TOF
operator|)
operator|&&
comment|/* (bp->b_flags& B_PHYS)&& */
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|)
goto|goto
name|cont
goto|;
name|cy
operator|->
name|cy_openf
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* cause to close */
name|printf
argument_list|(
literal|"cy%d: hard error bn %d er=%x\n"
argument_list|,
name|cyunit
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|tp
operator|->
name|status
index|[
literal|1
index|]
operator|&
name|CS_ERm
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|opdone
goto|;
block|}
comment|/* 	 * If we were reading block tape and the record 	 * was too long, we consider this an error. 	 */
name|cont
label|:
name|uncache
argument_list|(
operator|&
name|tp
operator|->
name|count
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|tp
operator|->
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
operator|&
name|rcybuf
index|[
name|TMUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|&&
operator|(
name|tp
operator|->
name|cmd
operator|==
name|READ_BU
operator|)
operator|&&
name|bp
operator|->
name|b_bcount
operator|<
name|TM_SHORT
argument_list|(
name|tp
operator|->
name|count
argument_list|)
condition|)
block|{
name|cy
operator|->
name|cy_openf
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* cause to close */
name|printf
argument_list|(
literal|"cy%d: error - tape block too long \n"
argument_list|,
name|cyunit
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|opdone
goto|;
block|}
comment|/* 	 * No errors. 	 * Advance tape control FSM. 	 */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SIO
case|:
comment|/* 		 * Read/write increments tape block number 		 */
name|cy
operator|->
name|cy_blkno
operator|++
expr_stmt|;
name|end_transfer
argument_list|(
name|bp
argument_list|,
name|cybuf
argument_list|,
name|CYmap
argument_list|,
name|cyutl
argument_list|)
expr_stmt|;
goto|goto
name|opdone
goto|;
case|case
name|SCOM
case|:
comment|/* 		 * For forward/backward space record update current position. 		 */
if|if
condition|(
name|bp
operator|==
operator|&
name|ccybuf
index|[
name|TMUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
condition|)
switch|switch
condition|(
name|bp
operator|->
name|b_command
condition|)
block|{
case|case
name|SP_FORW
case|:
name|cy
operator|->
name|cy_blkno
operator|+=
name|bp
operator|->
name|b_repcnt
expr_stmt|;
break|break;
case|case
name|SP_BACK
case|:
name|cy
operator|->
name|cy_blkno
operator|-=
name|bp
operator|->
name|b_repcnt
expr_stmt|;
break|break;
block|}
goto|goto
name|opdone
goto|;
case|case
name|SSEEK
case|:
name|cy
operator|->
name|cy_blkno
operator|=
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
goto|goto
name|opcont
goto|;
default|default:
name|panic
argument_list|(
literal|"cyintr"
argument_list|)
expr_stmt|;
block|}
name|opdone
label|:
comment|/* 	 * Reset error count and remove 	 * from device queue. 	 */
name|um
operator|->
name|um_tab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|tp
operator|->
name|count
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|TM_SHORT
argument_list|(
name|tp
operator|->
name|count
argument_list|)
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Circulate slave to end of controller 	 * queue to give other slaves a chance. 	 */
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
block|{
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
block|}
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
literal|0
condition|)
return|return;
name|opcont
label|:
name|cystart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cytimer
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
init|=
operator|&
name|cy_softc
index|[
name|CYUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|cy
operator|->
name|cy_timo
operator|!=
name|INF
operator|&&
operator|(
name|cy
operator|->
name|cy_timo
operator|-=
literal|5
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cy%d: lost interrupt\n"
argument_list|,
name|CYUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_timo
operator|=
name|INF
expr_stmt|;
name|s
operator|=
name|spl8
argument_list|()
expr_stmt|;
name|cyintr
argument_list|(
name|TMUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cy
operator|->
name|cy_timo
operator|!=
name|INF
condition|)
name|timeout
argument_list|(
name|cytimer
argument_list|,
operator|(
name|caddr_t
operator|)
name|dev
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|cyseteof
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|cyunit
init|=
name|CYUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
init|=
operator|&
name|cy_softc
index|[
name|cyunit
index|]
decl_stmt|;
specifier|register
name|struct
name|tpb
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|tpb
index|[
name|cyunit
index|]
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|tp
operator|->
name|rec_over
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
operator|&
name|ccybuf
index|[
name|TMUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
condition|)
block|{
if|if
condition|(
name|cy
operator|->
name|cy_blkno
operator|>
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
condition|)
block|{
comment|/* reversing */
name|cy
operator|->
name|cy_nxrec
operator|=
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|-
operator|(
name|int
operator|)
name|TM_SHORT
argument_list|(
name|tp
operator|->
name|rec_over
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_blkno
operator|=
name|cy
operator|->
name|cy_nxrec
expr_stmt|;
block|}
else|else
block|{
comment|/* spacing forward */
name|cy
operator|->
name|cy_blkno
operator|=
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|+
operator|(
name|int
operator|)
name|TM_SHORT
argument_list|(
name|tp
operator|->
name|rec_over
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_nxrec
operator|=
name|cy
operator|->
name|cy_blkno
operator|-
literal|1
expr_stmt|;
block|}
return|return;
block|}
comment|/* eof on read */
name|cy
operator|->
name|cy_nxrec
operator|=
name|bdbtofsb
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cyread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|error
expr_stmt|;
name|error
operator|=
name|cyphys
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
while|while
condition|(
name|cybufused
condition|)
name|sleep
argument_list|(
operator|&
name|cybufused
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cybufused
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|physio
argument_list|(
name|cystrategy
argument_list|,
operator|&
name|rcybuf
index|[
name|TMUNIT
argument_list|(
name|dev
argument_list|)
index|]
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|tminphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|cybufused
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|cybufused
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_macro
name|cywrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|error
expr_stmt|;
name|error
operator|=
name|cyphys
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
while|while
condition|(
name|cybufused
condition|)
name|sleep
argument_list|(
operator|&
name|cybufused
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cybufused
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|physio
argument_list|(
name|cystrategy
argument_list|,
operator|&
name|rcybuf
index|[
name|TMUNIT
argument_list|(
name|dev
argument_list|)
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|tminphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|cybufused
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|cybufused
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_macro
name|cyreset
argument_list|(
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vba_ctlr
modifier|*
name|um
decl_stmt|;
specifier|register
name|cy0f
operator|,
name|cyunit
expr_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|cy0f
operator|=
literal|0
init|;
name|cy0f
operator|<
name|NTM
condition|;
name|cy0f
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|um
operator|=
name|cyminfo
index|[
name|cy0f
index|]
operator|)
operator|==
literal|0
operator|||
name|um
operator|->
name|um_alive
operator|==
literal|0
operator|||
name|um
operator|->
name|um_vbanum
operator|!=
name|uban
condition|)
continue|continue;
name|printf
argument_list|(
literal|" cy%d"
argument_list|,
name|cy0f
argument_list|)
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cyunit
operator|=
literal|0
init|;
name|cyunit
operator|<
name|NCY
condition|;
name|cyunit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ui
operator|=
name|cydinfo
index|[
name|cyunit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_mi
operator|!=
name|um
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
continue|continue;
name|dp
operator|=
operator|&
name|cyutab
index|[
name|cyunit
index|]
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_forw
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_command
operator|=
name|DRIVE_R
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|um
operator|->
name|um_tab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|um
operator|->
name|um_tab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
if|if
condition|(
name|cy_softc
index|[
name|cyunit
index|]
operator|.
name|cy_openf
operator|>
literal|0
condition|)
name|cy_softc
index|[
name|cyunit
index|]
operator|.
name|cy_openf
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|cystart
argument_list|(
name|um
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|cyioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cyunit
init|=
name|CYUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
init|=
operator|&
name|cy_softc
index|[
name|cyunit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
operator|&
name|ccybuf
index|[
name|TMUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|callcount
expr_stmt|;
name|int
name|fcount
decl_stmt|;
name|struct
name|mtop
modifier|*
name|mtop
decl_stmt|;
name|struct
name|mtget
modifier|*
name|mtget
decl_stmt|;
comment|/* we depend of the values and order of the MT codes here */
specifier|static
name|cyops
index|[]
operator|=
block|{
name|WRIT_FM
block|,
name|SRFM_FD
block|,
name|SRFM_BK
block|,
name|SP_FORW
block|,
name|SP_BACK
block|,
name|REWD_TA
block|,
name|OFF_UNL
block|,
name|NO_OP
block|}
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCTOP
case|:
comment|/* tape operation */
name|mtop
operator|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|mtop
operator|->
name|mt_op
condition|)
block|{
case|case
name|MTWEOF
case|:
name|callcount
operator|=
name|mtop
operator|->
name|mt_count
expr_stmt|;
name|fcount
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MTFSF
case|:
case|case
name|MTBSF
case|:
name|callcount
operator|=
name|mtop
operator|->
name|mt_count
expr_stmt|;
name|fcount
operator|=
name|INF
expr_stmt|;
break|break;
case|case
name|MTFSR
case|:
case|case
name|MTBSR
case|:
name|callcount
operator|=
literal|1
expr_stmt|;
name|fcount
operator|=
name|mtop
operator|->
name|mt_count
expr_stmt|;
break|break;
case|case
name|MTREW
case|:
case|case
name|MTOFFL
case|:
case|case
name|MTNOP
case|:
name|callcount
operator|=
literal|1
expr_stmt|;
name|fcount
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|callcount
operator|<=
literal|0
operator|||
name|fcount
operator|<=
literal|0
condition|)
return|return
name|EINVAL
return|;
while|while
condition|(
operator|--
name|callcount
operator|>=
literal|0
condition|)
block|{
name|cycommand
argument_list|(
name|dev
argument_list|,
name|cyops
index|[
name|mtop
operator|->
name|mt_op
index|]
argument_list|,
name|fcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|||
name|cy
operator|->
name|cy_status
index|[
literal|1
index|]
operator|&
name|CS_ERm
condition|)
break|break;
block|}
return|return
name|geterror
argument_list|(
name|bp
argument_list|)
return|;
case|case
name|MTIOCGET
case|:
name|mtget
operator|=
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|data
expr_stmt|;
name|mtget
operator|->
name|mt_dsreg
operator|=
name|cy
operator|->
name|cy_status
index|[
literal|0
index|]
expr_stmt|;
name|mtget
operator|->
name|mt_erreg
operator|=
name|cy
operator|->
name|cy_status
index|[
literal|1
index|]
expr_stmt|;
name|mtget
operator|->
name|mt_resid
operator|=
name|cy
operator|->
name|cy_count
expr_stmt|;
name|mtget
operator|->
name|mt_type
operator|=
name|MT_ISCY
expr_stmt|;
break|break;
default|default:
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Check that a raw device exists.  * If it does, set up cy_blkno and cy_nxrec  * so that the tape will appear positioned correctly.  */
end_comment

begin_macro
name|cyphys
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cyunit
init|=
name|CYUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|daddr_t
name|a
decl_stmt|;
specifier|register
name|struct
name|cy_softc
modifier|*
name|cy
decl_stmt|;
specifier|register
name|struct
name|vba_device
modifier|*
name|ui
decl_stmt|;
if|if
condition|(
name|cyunit
operator|>=
name|NCY
operator|||
operator|(
name|ui
operator|=
name|cydinfo
index|[
name|cyunit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
name|cy
operator|=
operator|&
name|cy_softc
index|[
name|cyunit
index|]
expr_stmt|;
name|a
operator|=
name|bdbtofsb
argument_list|(
name|uio
operator|->
name|uio_offset
operator|>>
name|PGSHIFT
argument_list|)
expr_stmt|;
name|cy
operator|->
name|cy_blkno
operator|=
name|a
expr_stmt|;
name|cy
operator|->
name|cy_nxrec
operator|=
name|a
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  *  Set a TAPEMASTER pointer (first parameter), into the  *  4 bytes array pointed by the second parameter.  */
end_comment

begin_macro
name|set_pointer
argument_list|(
argument|pointer
argument_list|,
argument|dest
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dest
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|dest
operator|++
operator|=
name|pointer
operator|&
literal|0xff
expr_stmt|;
comment|/* low byte - offset */
operator|*
name|dest
operator|++
operator|=
operator|(
name|pointer
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* high byte - offset */
operator|*
name|dest
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|dest
operator|=
operator|(
name|pointer
operator|&
literal|0xf0000
operator|)
operator|>>
literal|12
expr_stmt|;
comment|/* base */
block|}
end_block

begin_macro
name|cydump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|tpb
modifier|*
name|tp
decl_stmt|;
name|int
name|cyunit
init|=
name|CYUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|blk
decl_stmt|,
name|num
decl_stmt|;
name|int
name|start
decl_stmt|;
name|start
operator|=
literal|0x800
expr_stmt|;
name|num
operator|=
name|maxfree
expr_stmt|;
name|tp
operator|=
operator|&
name|tpb
index|[
name|cyunit
index|]
expr_stmt|;
if|if
condition|(
name|cyunit
operator|>=
name|NCY
operator|||
operator|(
name|ui
operator|=
name|cydinfo
index|[
name|cyunit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|cywait
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|blk
operator|=
name|num
operator|>
name|TBUFSIZ
condition|?
name|TBUFSIZ
else|:
name|num
expr_stmt|;
name|bcopy
argument_list|(
name|start
operator|*
name|NBPG
argument_list|,
name|cybuf
argument_list|,
name|blk
operator|*
name|NBPG
argument_list|)
expr_stmt|;
name|tp
operator|->
name|cmd
operator|=
name|WRIT_BU
expr_stmt|;
name|tp
operator|->
name|control
index|[
literal|0
index|]
operator|=
name|cyunit
operator|<<
name|CW_TSs
expr_stmt|;
name|tp
operator|->
name|control
index|[
literal|1
index|]
operator|=
operator|(
name|CW_100ips
operator||
name|CW_16bits
operator|)
expr_stmt|;
name|tp
operator|->
name|status
index|[
literal|0
index|]
operator|=
name|tp
operator|->
name|status
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|size
operator|=
name|TM_SHORT
argument_list|(
name|blk
operator|*
name|NBPG
argument_list|)
expr_stmt|;
name|set_pointer
argument_list|(
operator|(
name|int
operator|)
name|cybuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tp
operator|->
name|pt_data
argument_list|)
expr_stmt|;
name|set_pointer
argument_list|(
operator|(
name|int
operator|)
operator|&
name|tpb
index|[
name|cyunit
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ccb
operator|.
name|pt_tpb
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|gate
index|[
literal|0
index|]
operator|=
name|GATE_CLOSED
expr_stmt|;
name|TM_ATTENTION
argument_list|(
name|cyaddr
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* execute! */
name|start
operator|+=
name|blk
expr_stmt|;
name|num
operator|-=
name|blk
expr_stmt|;
if|if
condition|(
name|cywait
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|uncache
argument_list|(
operator|&
name|tp
operator|->
name|status
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|status
index|[
literal|1
index|]
operator|&
name|CS_ERm
condition|)
comment|/* error */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|cyeof
argument_list|(
name|tp
argument_list|,
name|cyunit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cywait
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|cyeof
argument_list|(
name|tp
argument_list|,
name|cyunit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cywait
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|uncache
argument_list|(
operator|&
name|tp
operator|->
name|status
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|status
index|[
literal|1
index|]
operator|&
name|CS_ERm
condition|)
comment|/* error */
return|return
operator|(
name|EIO
operator|)
return|;
name|cyrewind
argument_list|(
name|tp
argument_list|,
name|cyunit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|cywait
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|cnt
expr_stmt|;
name|cnt
operator|=
literal|5000
expr_stmt|;
comment|/* 5 seconds timeout */
do|do
block|{
operator|--
name|cnt
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|uncache
argument_list|(
operator|&
name|ccb
operator|.
name|gate
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cnt
operator|>
literal|0
operator|&&
name|ccb
operator|.
name|gate
index|[
literal|0
index|]
operator|==
name|GATE_CLOSED
condition|)
do|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* timeout */
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|cyeof
argument_list|(
name|tp
argument_list|,
name|unit
argument_list|)
specifier|register
expr|struct
name|tpb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tp
operator|->
name|cmd
operator|=
name|WRIT_FM
expr_stmt|;
name|tp
operator|->
name|control
index|[
literal|0
index|]
operator|=
name|unit
operator|<<
name|CW_TSs
expr_stmt|;
name|tp
operator|->
name|control
index|[
literal|1
index|]
operator|=
operator|(
name|CW_100ips
operator||
name|CW_16bits
operator|)
expr_stmt|;
name|tp
operator|->
name|status
index|[
literal|0
index|]
operator|=
name|tp
operator|->
name|status
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|rec_over
operator|=
name|TM_SHORT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|set_pointer
argument_list|(
operator|(
name|int
operator|)
operator|&
name|tpb
index|[
name|unit
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ccb
operator|.
name|pt_tpb
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|gate
index|[
literal|0
index|]
operator|=
name|GATE_CLOSED
expr_stmt|;
name|TM_ATTENTION
argument_list|(
name|cyaddr
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* execute! */
block|}
end_block

begin_expr_stmt
name|cyrewind
argument_list|(
name|tp
argument_list|,
name|unit
argument_list|)
specifier|register
expr|struct
name|tpb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tp
operator|->
name|cmd
operator|=
name|REWD_TA
expr_stmt|;
name|tp
operator|->
name|control
index|[
literal|0
index|]
operator|=
name|unit
operator|<<
name|CW_TSs
expr_stmt|;
name|tp
operator|->
name|control
index|[
literal|1
index|]
operator|=
operator|(
name|CW_100ips
operator||
name|CW_16bits
operator|)
expr_stmt|;
name|tp
operator|->
name|status
index|[
literal|0
index|]
operator|=
name|tp
operator|->
name|status
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|set_pointer
argument_list|(
operator|(
name|int
operator|)
operator|&
name|tpb
index|[
name|unit
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ccb
operator|.
name|pt_tpb
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|gate
index|[
literal|0
index|]
operator|=
name|GATE_CLOSED
expr_stmt|;
name|TM_ATTENTION
argument_list|(
name|cyaddr
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* execute! */
block|}
end_block

begin_function
name|unsigned
name|tminphys
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
sizeof|sizeof
name|cybuf
condition|)
name|bp
operator|->
name|b_bcount
operator|=
sizeof|sizeof
name|cybuf
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

