begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Sony Corp. and Kazumasa Utashiro of Software Research Associates, Inc.  *  * %sccs.include.redist.c%  *  * from: $Hdr: rs.c,v 4.300 91/06/09 06:43:03 root Rel41 $ SONY  *  *	@(#)rs.c	7.4 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*	rs.c	6.1	83/07/29	*/
end_comment

begin_include
include|#
directive|include
file|"rs.h"
end_include

begin_if
if|#
directive|if
name|NRS
operator|>
literal|0
end_if

begin_comment
comment|/*  * RS driver  *  */
end_comment

begin_if
if|#
directive|if
name|NBK
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"bk.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_include
include|#
directive|include
file|<news3400/hbdev/hbvar.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"../iop/iopvar.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<news3400/iop/rsreg.h>
end_include

begin_include
include|#
directive|include
file|<news3400/sio/sccparam.h>
end_include

begin_define
define|#
directive|define
name|RS_RXE
value|RXE
end_define

begin_define
define|#
directive|define
name|RS_TXE
value|TXE
end_define

begin_define
define|#
directive|define
name|RS_ON
value|(RXE|TXE|RTS|DTR)
end_define

begin_define
define|#
directive|define
name|RS_OFF
value|TXE
end_define

begin_define
define|#
directive|define
name|RS_RTS
value|RTS
end_define

begin_define
define|#
directive|define
name|RS_DTR
value|DTR
end_define

begin_define
define|#
directive|define
name|RS_CTS
value|CTS
end_define

begin_define
define|#
directive|define
name|RS_DCD
value|DCD
end_define

begin_define
define|#
directive|define
name|RS_DSR
value|DSR
end_define

begin_define
define|#
directive|define
name|RS_RI
value|RI
end_define

begin_define
define|#
directive|define
name|RS_BRK
value|XBREAK
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_ENABLE
end_ifdef

begin_define
define|#
directive|define
name|RS_AUTO_ENABLE
value|AUTO_ENABLE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_define
define|#
directive|define
name|iop_device
value|hb_device
end_define

begin_define
define|#
directive|define
name|ii_unit
value|hi_unit
end_define

begin_define
define|#
directive|define
name|ii_flags
value|hi_flags
end_define

begin_define
define|#
directive|define
name|ii_alive
value|hi_alive
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Definition of the driver for the auto-configuration program.  */
end_comment

begin_decl_stmt
name|int
name|rsprobe
argument_list|()
decl_stmt|,
name|rsattach
argument_list|()
decl_stmt|,
name|rsrint
argument_list|()
decl_stmt|,
name|rsxint
argument_list|()
decl_stmt|,
name|rssint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iop_device
modifier|*
name|rsinfo
index|[
name|NRS
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_decl_stmt
name|struct
name|hb_driver
name|rsdriver
init|=
block|{
name|rsprobe
block|,
literal|0
block|,
name|rsattach
block|,
literal|0
block|,
literal|0
block|,
literal|"rs"
block|,
name|rsinfo
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|iop_driver
name|rsdriver
init|=
block|{
name|rsprobe
block|,
literal|0
block|,
name|rsattach
block|,
literal|0
block|,
literal|"rs"
block|,
name|rsinfo
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local variables for the driver  */
end_comment

begin_decl_stmt
name|struct
name|tty
name|rs_tty
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|rssoftCAR
index|[
name|NRS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs_flags
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs_param
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|rs_active
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|rs_stopped
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs_rate
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs_average
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|rs_timeout
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|rs_watch
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|int
name|nrs
init|=
name|NRS
operator|*
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used by iostat */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|tty00_is_console
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|rsstart
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ttrstrt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|rsctrl
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|RS_CARR
parameter_list|(
name|unit
parameter_list|)
value|(rssoftCAR[(unit)>> 2]& (1<< ((unit)& 03)))
end_define

begin_define
define|#
directive|define
name|RS_FLAG
parameter_list|(
name|unit
parameter_list|,
name|flag
parameter_list|)
value|(rs_flags[unit]& (flag))
end_define

begin_define
define|#
directive|define
name|RF_FLOWCTL
value|0x0010
end_define

begin_comment
comment|/* use H/W flow control */
end_comment

begin_define
define|#
directive|define
name|RF_EXTCLK
value|0x0100
end_define

begin_comment
comment|/* allow external clock */
end_comment

begin_define
define|#
directive|define
name|RF_NODELAY
value|0x1000
end_define

begin_comment
comment|/* disable interrupt delay */
end_comment

begin_comment
comment|/*  * Routine for configuration  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rsprobe
argument_list|(
argument|ii
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iop_device
modifier|*
name|ii
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|rs_probe
argument_list|(
name|ii
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Routine called to attach a rs.  */
end_comment

begin_expr_stmt
name|rsattach
argument_list|(
name|ii
argument_list|)
specifier|register
expr|struct
name|iop_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|rssoftCAR
index|[
name|ii
operator|->
name|ii_unit
index|]
operator|=
name|ii
operator|->
name|ii_flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|rs_flags
index|[
name|ii
operator|->
name|ii_unit
operator|*
literal|4
operator|+
name|i
index|]
operator|=
operator|(
name|ii
operator|->
name|ii_flags
operator|>>
name|i
operator|)
operator|&
operator|(
name|RF_FLOWCTL
operator||
name|RF_EXTCLK
operator||
name|RF_NODELAY
operator|)
expr_stmt|;
if|if
condition|(
name|rs_watch
operator|==
literal|0
condition|)
block|{
name|rs_watchdog
argument_list|()
expr_stmt|;
name|rs_watch
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rs_watchdog
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NRS
operator|*
literal|4
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
name|rs_active
index|[
name|unit
index|]
operator|==
literal|0
condition|)
continue|continue;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|rs_average
index|[
name|unit
index|]
operator|=
operator|(
name|rs_average
index|[
name|unit
index|]
operator|*
literal|7
operator|+
name|rs_rate
index|[
name|unit
index|]
operator|)
operator|>>
literal|3
expr_stmt|;
name|rs_rate
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
name|rs_watchdog
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Open a RS line. Turn on this rs if this is the first use of it.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rsopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|mode
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|iop_device
modifier|*
name|ii
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRS
operator|*
literal|4
operator|||
operator|(
name|ii
operator|=
name|rsinfo
index|[
name|unit
operator|>>
literal|2
index|]
operator|)
operator|==
literal|0
operator|||
name|ii
operator|->
name|ii_alive
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|rs_active
index|[
name|unit
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rs_init
argument_list|(
name|unit
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|rs_enable
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|rs_active
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|tp
operator|=
operator|&
name|rs_tty
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|curproc
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|tp
operator|->
name|t_addr
operator|=
operator|(
name|caddr_t
operator|)
literal|0
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|rsstart
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* KU:XXX */
name|tp
operator|->
name|t_ctrlproc
operator|=
name|rsctrl
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If this is first open, initialze tty state to default. 	 */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
block|}
name|rsparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait receiver and status interrupt 	 */
comment|/* 	 * Wait for carrier, then process line discipline specific open. 	 */
name|rsmctl
argument_list|(
name|dev
argument_list|,
name|RS_ON
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_param
index|[
name|unit
index|]
operator|&
name|DCD
operator|||
name|RS_CARR
argument_list|(
name|unit
argument_list|)
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* spl5 -> spltty, 90/02/28 sak */
while|while
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* KU:XXX */
if|if
condition|(
name|RS_FLAG
argument_list|(
name|unit
argument_list|,
name|RF_FLOWCTL
argument_list|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_HFLWCTL
expr_stmt|;
name|rsmctl
argument_list|(
name|dev
argument_list|,
name|RS_AUTO_ENABLE
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_HFLWCTL
expr_stmt|;
name|rsmctl
argument_list|(
name|dev
argument_list|,
name|RS_AUTO_ENABLE
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Close a RS line.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rsclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|unit
expr_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|rs_tty
index|[
name|unit
index|]
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|rsmctl
argument_list|(
name|unit
argument_list|,
name|RS_BRK
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|||
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|rsmctl
argument_list|(
name|unit
argument_list|,
name|RS_OFF
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|RS_FLAG
argument_list|(
name|unit
argument_list|,
name|RF_FLOWCTL
argument_list|)
condition|)
operator|(
name|void
operator|)
name|rsmctl
argument_list|(
name|unit
argument_list|,
name|RS_RTS
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rsread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|rs_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|rswrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|rs_tty
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|rsenable
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rs_timeout
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|rs_enable
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * RS receiver interrupt.  */
end_comment

begin_expr_stmt
name|_rsrint
argument_list|(
name|unit
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|iop_device
modifier|*
name|ii
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
function_decl|(
modifier|*
name|rint
function_decl|)
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|notyet
comment|/* KU:XXX */
name|intrcnt
index|[
name|INTR_RS0
operator|+
name|unit
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|ii
operator|=
name|rsinfo
index|[
name|unit
operator|>>
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|ii
operator|==
literal|0
operator|||
name|ii
operator|->
name|ii_alive
operator|==
literal|0
condition|)
return|return;
name|tp
operator|=
operator|&
name|rs_tty
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
goto|goto
name|enable
goto|;
block|}
comment|/* 	 * Loop fetching characters from the silo for this 	 * rs until there are no more in the silo. 	 */
name|rint
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
if|#
directive|if
name|NBK
operator|>
literal|0
if|if
condition|(
name|tp
operator|->
name|t_line
operator|==
name|NETLDISC
condition|)
block|{
name|c
operator|&=
literal|0177
expr_stmt|;
name|BKINPUT
argument_list|(
name|c
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* NBK> 0 */
call|(
modifier|*
name|rint
call|)
argument_list|(
operator|*
name|buf
operator|++
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|enable
label|:
name|rs_rate
index|[
name|unit
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|rs_average
index|[
name|unit
index|]
operator|>=
literal|10
operator|&&
name|RS_FLAG
argument_list|(
name|unit
argument_list|,
name|RF_NODELAY
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rs_timeout
index|[
name|unit
index|]
operator|==
literal|0
condition|)
block|{
name|rs_timeout
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|rsenable
argument_list|,
operator|(
name|caddr_t
operator|)
name|unit
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|rs_enable
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rsioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tp
operator|=
operator|&
name|rs_tty
index|[
name|unit
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
operator|(
name|void
operator|)
name|rsmctl
argument_list|(
name|dev
argument_list|,
name|RS_BRK
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
operator|(
name|void
operator|)
name|rsmctl
argument_list|(
name|dev
argument_list|,
name|RS_BRK
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCSDTR
case|:
operator|(
name|void
operator|)
name|rsmctl
argument_list|(
name|dev
argument_list|,
name|RS_DTR
operator||
name|RS_RTS
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
if|if
condition|(
name|curproc
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|&&
name|curproc
operator|->
name|p_session
operator|->
name|s_ttyp
operator|!=
name|tp
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
operator|(
name|void
operator|)
name|rsmctl
argument_list|(
name|dev
argument_list|,
name|RS_DTR
operator||
name|RS_RTS
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
operator|(
name|void
operator|)
name|rsmctl
argument_list|(
name|dev
argument_list|,
name|dmtors
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
operator|(
name|void
operator|)
name|rsmctl
argument_list|(
name|dev
argument_list|,
name|dmtors
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
operator|(
name|void
operator|)
name|rsmctl
argument_list|(
name|dev
argument_list|,
name|dmtors
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|rstodm
argument_list|(
name|rsmctl
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|DMGET
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|dmtors
argument_list|(
name|bits
argument_list|)
specifier|register
name|int
name|bits
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|b
decl_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|DML_LE
condition|)
name|b
operator||=
name|RS_TXE
operator||
name|RS_RXE
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|DML_DTR
condition|)
name|b
operator||=
name|RS_DTR
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|DML_RTS
condition|)
name|b
operator||=
name|RS_RTS
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|DML_CTS
condition|)
name|b
operator||=
name|RS_CTS
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|DML_CAR
condition|)
name|b
operator||=
name|RS_DCD
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|DML_RNG
condition|)
name|b
operator||=
name|RS_RI
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|DML_DSR
condition|)
name|b
operator||=
name|RS_DSR
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_ENABLE
if|if
condition|(
name|bits
operator|&
name|DML_USR
condition|)
name|b
operator||=
name|RS_AUTO_ENABLE
expr_stmt|;
endif|#
directive|endif
comment|/* AUTO_ENABLE */
return|return
operator|(
name|b
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|rstodm
argument_list|(
name|bits
argument_list|)
specifier|register
name|int
name|bits
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|b
decl_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bits
operator|&
operator|(
name|RS_TXE
operator||
name|RS_RXE
operator|)
condition|)
name|b
operator||=
name|DML_LE
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|RS_DTR
condition|)
name|b
operator||=
name|DML_DTR
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|RS_RTS
condition|)
name|b
operator||=
name|DML_RTS
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|RS_CTS
condition|)
name|b
operator||=
name|DML_CTS
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|RS_DCD
condition|)
name|b
operator||=
name|DML_CAR
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|RS_RI
condition|)
name|b
operator||=
name|DML_RNG
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|RS_DSR
condition|)
name|b
operator||=
name|DML_DSR
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_ENABLE
if|if
condition|(
name|bits
operator|&
name|RS_AUTO_ENABLE
condition|)
name|b
operator||=
name|DML_USR
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|b
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * compat table  */
end_comment

begin_decl_stmt
name|struct
name|speedtab
name|rsspeedtab
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|50
block|,
literal|1
block|,
literal|75
block|,
literal|2
block|,
literal|110
block|,
literal|3
block|,
literal|134
block|,
literal|4
block|,
literal|150
block|,
literal|5
block|,
literal|200
block|,
literal|6
block|,
literal|300
block|,
literal|7
block|,
literal|600
block|,
literal|8
block|,
literal|1200
block|,
literal|9
block|,
literal|1800
block|,
literal|10
block|,
literal|2400
block|,
literal|11
block|,
literal|4800
block|,
literal|12
block|,
literal|9600
block|,
literal|13
block|,
literal|19200
block|,
literal|14
block|,
literal|38400
block|,
literal|15
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set parameters from open or stty into the RS hardware  * registers.  */
end_comment

begin_expr_stmt
name|rsparam
argument_list|(
name|tp
argument_list|,
name|t
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|param
decl_stmt|;
specifier|register
name|int
name|cflag
init|=
name|t
operator|->
name|c_cflag
decl_stmt|;
name|int
name|unit
init|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|ospeed
init|=
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
name|rsspeedtab
argument_list|)
decl_stmt|;
comment|/* check requested parameters */
if|if
condition|(
name|ospeed
operator|<
literal|0
operator|||
operator|(
name|t
operator|->
name|c_ispeed
operator|&&
name|t
operator|->
name|c_ispeed
operator|!=
name|t
operator|->
name|c_ospeed
operator|)
operator|||
operator|(
name|cflag
operator|&
name|CSIZE
operator|)
operator|==
name|CS5
operator|||
operator|(
name|cflag
operator|&
name|CSIZE
operator|)
operator|==
name|CS6
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* and copy to tty */
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|cflag
expr_stmt|;
comment|/* 	 * Block interrupts so parameters will be set 	 * before the line interrupts. 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ospeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_cflag
operator||=
name|HUPCL
expr_stmt|;
operator|(
name|void
operator|)
name|rsmctl
argument_list|(
name|unit
argument_list|,
name|RS_OFF
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|param
operator|=
name|rs_get_param
argument_list|(
name|unit
argument_list|)
operator|&
operator|~
operator|(
name|CHAR_SIZE
operator||
name|PARITY
operator||
name|EVEN
operator||
name|STOPBIT
operator||
name|BAUD_RATE
operator||
name|NOCHECK
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|CREAD
operator|)
operator|==
literal|0
condition|)
name|param
operator|&=
operator|~
name|RXE
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CS6
condition|)
name|param
operator||=
name|C6BIT
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CS7
condition|)
name|param
operator||=
name|C7BIT
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
name|param
operator||=
name|PARITY
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|PARODD
operator|)
operator|==
literal|0
condition|)
name|param
operator||=
name|EVEN
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|INPCK
operator|)
operator|==
literal|0
condition|)
name|param
operator||=
name|NOCHECK
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
name|param
operator||=
name|STOP2
expr_stmt|;
else|else
name|param
operator||=
name|STOP1
expr_stmt|;
name|rs_param
index|[
name|unit
index|]
operator|=
name|param
operator||
name|ospeed
expr_stmt|;
if|if
condition|(
name|RS_FLAG
argument_list|(
name|unit
argument_list|,
name|RF_EXTCLK
argument_list|)
condition|)
name|rs_param
index|[
name|unit
index|]
operator||=
name|EXTCLK_ENABLE
expr_stmt|;
else|else
name|rs_param
index|[
name|unit
index|]
operator|&=
operator|~
name|EXTCLK_ENABLE
expr_stmt|;
name|rs_set_param
argument_list|(
name|unit
argument_list|,
name|rs_param
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * RS transmitter interrupt.  * Restart the idle line.  */
end_comment

begin_macro
name|_rsxint
argument_list|(
argument|unit
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* KU:XXX */
name|intrcnt
index|[
name|INTR_RS0
operator|+
name|unit
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|rs_stopped
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
operator|&
name|rs_tty
index|[
name|unit
index|]
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_FLUSH
condition|)
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_FLUSH
expr_stmt|;
else|else
name|ndflush
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|count
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_line
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
else|else
name|rsstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start (restart) transmission on the given RS line.  */
end_comment

begin_function
name|void
name|rsstart
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|int
name|unit
decl_stmt|,
name|nch
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
comment|/* 	 * Must hold interrupts in following code to prevent 	 * state of the tp from changing. 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* 	 * If it's currently active, or delaying, no need to do anything. 	 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * If ther are still characters in the IOP, 	 * just reenable transmit. 	 */
if|if
condition|(
name|rs_stopped
index|[
name|unit
index|]
condition|)
block|{
name|rs_start
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|rs_stopped
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If there are sleepers, and output has drained below low 	 * water mark, wake up the sleepers. 	 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now restart transmission unless the output queue is 	 * empty. 	 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator|)
condition|)
name|nch
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|nch
operator|=
name|ndqb
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|0200
argument_list|)
expr_stmt|;
comment|/* 		 * If first thing on queue is a delay process it. 		 */
if|if
condition|(
name|nch
operator|==
literal|0
condition|)
block|{
name|nch
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ttrstrt
argument_list|,
operator|(
name|caddr_t
operator|)
name|tp
argument_list|,
operator|(
name|nch
operator|&
literal|0x7f
operator|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_TIMEOUT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * If characters to transmit, restart transmission. 	 */
if|if
condition|(
name|nch
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|rs_output
argument_list|(
name|unit
argument_list|,
name|nch
argument_list|)
expr_stmt|;
block|}
name|out
label|:
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop output on a line, e.g. for ^S/^Q or output flush.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|rsstop
argument_list|(
name|tp
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|,
name|s
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|rs_stop
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rs_stopped
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
name|rs_stop
argument_list|(
name|unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * RS modem control  */
end_comment

begin_macro
name|rsmctl
argument_list|(
argument|dev
argument_list|,
argument|bits
argument_list|,
argument|how
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bits
decl_stmt|,
name|how
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|,
name|mbits
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTO_ENABLE
name|bits
operator|&=
operator|(
name|RS_RXE
operator||
name|RS_TXE
operator||
name|RS_RTS
operator||
name|RS_DTR
operator||
name|RS_BRK
operator||
name|RS_AUTO_ENABLE
operator|)
expr_stmt|;
else|#
directive|else
name|bits
operator|&=
operator|(
name|RS_RXE
operator||
name|RS_TXE
operator||
name|RS_RTS
operator||
name|RS_DTR
operator||
name|RS_BRK
operator|)
expr_stmt|;
endif|#
directive|endif
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* spl5 -> spltty, 90/02/28 sak */
name|mbits
operator|=
name|rs_get_param
argument_list|(
name|unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|DMSET
case|:
name|mbits
operator|=
name|mbits
operator|&
operator|~
operator|(
name|RS_RXE
operator||
name|RS_TXE
operator||
name|RS_RTS
operator||
name|RS_DTR
operator||
name|RS_BRK
operator|)
operator||
name|bits
expr_stmt|;
break|break;
case|case
name|DMBIS
case|:
name|mbits
operator||=
name|bits
expr_stmt|;
break|break;
case|case
name|DMBIC
case|:
name|mbits
operator|&=
operator|~
name|bits
expr_stmt|;
break|break;
case|case
name|DMGET
case|:
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|mbits
operator|)
return|;
block|}
name|rs_param
index|[
name|unit
index|]
operator|=
name|mbits
expr_stmt|;
name|rs_set_param
argument_list|(
name|unit
argument_list|,
name|rs_param
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|mbits
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Reset state of driver if IOP reset was necessary.  * Reset the parameter and status, and  * restart transmitters.  */
end_comment

begin_macro
name|rsreset
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|iop_device
modifier|*
name|ii
decl_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NRS
operator|*
literal|4
condition|;
name|unit
operator|++
control|)
block|{
name|ii
operator|=
name|rsinfo
index|[
name|unit
operator|>>
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|ii
operator|==
literal|0
operator|||
name|ii
operator|->
name|ii_alive
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|" rs%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|rs_tty
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_ISOPEN
operator||
name|TS_WOPEN
operator|)
condition|)
block|{
name|rs_reset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|rsparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rsmctl
argument_list|(
name|unit
argument_list|,
name|RS_ON
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|rsstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * RS status interrupt  */
end_comment

begin_macro
name|_rssint
argument_list|(
argument|unit
argument_list|,
argument|stat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stat
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* KU:XXX */
name|intrcnt
index|[
name|INTR_RS0
operator|+
name|unit
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|tp
operator|=
operator|&
name|rs_tty
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|RS_DCD
condition|)
block|{
name|rs_param
index|[
name|unit
index|]
operator||=
name|RS_DCD
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RS_CARR
argument_list|(
name|unit
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
name|rs_param
index|[
name|unit
index|]
operator|&=
operator|~
operator|(
name|RS_DCD
operator||
name|RS_DTR
operator|)
expr_stmt|;
name|rs_set_param
argument_list|(
name|unit
argument_list|,
name|rs_param
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|OVERRUN_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"rs%d: fifo overflow\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|rs_param
index|[
name|unit
index|]
operator|&=
operator|~
name|OVERRUN_ERROR
expr_stmt|;
name|rs_set_param
argument_list|(
name|unit
argument_list|,
name|rs_param
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|RBREAK
condition|)
block|{
name|rs_param
index|[
name|unit
index|]
operator|&=
operator|~
name|RBREAK
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|RAW
condition|?
literal|'\0'
else|:
name|tp
operator|->
name|t_cc
index|[
name|VINTR
index|]
operator|,
name|tp
operator|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * RS control interrupt  */
end_comment

begin_macro
name|rscint
argument_list|(
argument|rs
argument_list|)
end_macro

begin_decl_stmt
name|int
name|rs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"rscint: %d\n"
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * RS H/W control  */
end_comment

begin_function
name|void
name|rsctrl
parameter_list|(
name|tp
parameter_list|,
name|cmd
parameter_list|,
name|arg
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|arg
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|notyet
comment|/* KU:XXX */
name|int
name|unit
init|=
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TC_HBLOCK
case|:
if|if
condition|(
name|RS_FLAG
argument_list|(
name|unit
argument_list|,
name|RF_FLOWCTL
argument_list|)
condition|)
name|rsflowctl
argument_list|(
name|unit
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_macro
name|rsflowctl
argument_list|(
argument|unit
argument_list|,
argument|block
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|block
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|block
condition|)
name|rs_param
index|[
name|unit
index|]
operator|&=
operator|~
name|RS_RTS
expr_stmt|;
else|else
name|rs_param
index|[
name|unit
index|]
operator||=
name|RS_RTS
expr_stmt|;
name|rs_set_param
argument_list|(
name|unit
argument_list|,
name|rs_param
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Machine dependent functions  *  *	rs_probe()  *	rs_init()  *	rsrint()  *	rsxint()  *	rssint()  *	rs_enable()  *	rs_output()  *	rs_start()  *	rs_stop()  *	rs_reset()  *	rs_get_param()  *	rs_set_param()  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_include
include|#
directive|include
file|<news3400/hbdev/hbvar.h>
end_include

begin_include
include|#
directive|include
file|<news3400/hbdev/rsreg.h>
end_include

begin_include
include|#
directive|include
file|<news3400/sio/scc.h>
end_include

begin_decl_stmt
name|int
name|rslastcount
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scc_unit
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs_unit
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|rs_probe
argument_list|(
argument|hi
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hb_device
modifier|*
name|hi
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|cmax
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|hi
operator|->
name|hi_unit
operator|<<
literal|2
operator|)
operator|,
name|cmax
operator|=
literal|4
init|;
name|cmax
operator|>
literal|0
condition|;
name|cmax
operator|--
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|2
operator|||
name|i
operator|==
literal|3
condition|)
continue|continue;
if|if
condition|(
name|scc_probe
argument_list|(
name|scc_unit
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|rs_init
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|scc_open
argument_list|(
name|scc_unit
index|[
name|unit
index|]
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"rs_init: chan %d open failed.\n"
argument_list|,
name|scc_unit
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rs_enable
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|scc_enable
argument_list|(
name|scc_unit
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rsrint
argument_list|(
argument|scc
argument_list|,
argument|buf
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|scc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|_rsrint
argument_list|(
name|rs_unit
index|[
name|scc
index|]
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rsxint
argument_list|(
argument|scc
argument_list|)
end_macro

begin_decl_stmt
name|int
name|scc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|rs_unit
index|[
name|scc
index|]
decl_stmt|;
name|_rsxint
argument_list|(
name|unit
argument_list|,
name|rslastcount
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rssint
argument_list|(
argument|scc
argument_list|,
argument|stat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|scc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stat
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|_rssint
argument_list|(
name|rs_unit
index|[
name|scc
index|]
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rs_start
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|scc_start
argument_list|(
name|scc_unit
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rs_output
argument_list|(
argument|unit
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rslastcount
index|[
name|unit
index|]
operator|=
name|scc_write
argument_list|(
name|scc_unit
index|[
name|unit
index|]
argument_list|,
name|rs_tty
index|[
name|unit
index|]
operator|.
name|t_outq
operator|.
name|c_cf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rs_stop
argument_list|(
argument|unit
argument_list|,
argument|flush
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flush
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|flush
condition|)
name|scc_flush
argument_list|(
name|scc_unit
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rs_reset
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|scc_reset
argument_list|(
name|scc_unit
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rs_get_param
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|scc_get_param
argument_list|(
name|scc_unit
index|[
name|unit
index|]
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|rs_set_param
argument_list|(
argument|unit
argument_list|,
argument|param
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|param
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|scc_set_param
argument_list|(
name|scc_unit
index|[
name|unit
index|]
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPU_SINGLE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IPC_MRX
end_ifdef

begin_include
include|#
directive|include
file|"../ipc/newsipc.h"
end_include

begin_include
include|#
directive|include
file|"../mrx/h/scc.h"
end_include

begin_include
include|#
directive|include
file|"../mrx/h/cio.h"
end_include

begin_decl_stmt
name|int
name|port_rsrecv
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port_rsxmit
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port_rsstat
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port_rsctrl
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port_recv_iop
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port_xmit_iop
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port_ctrl_iop
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port_stat_iop
index|[
name|NRS
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	minor No: 0 - 12 ----> SCC unit No : 0 - 9  */
end_comment

begin_decl_stmt
name|int
name|scc_unit
index|[]
init|=
block|{
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|5
block|,
literal|4
block|,
literal|7
block|,
literal|6
block|,
literal|9
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|rs_probe
argument_list|(
argument|ii
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iop_device
modifier|*
name|ii
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|base
init|=
name|ii
operator|->
name|ii_unit
operator|<<
literal|2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
define|#
directive|define
name|PT_CREATE
parameter_list|(
name|buf
parameter_list|,
name|name
parameter_list|,
name|unit
parameter_list|,
name|func
parameter_list|,
name|arg
parameter_list|)
define|\
value|port_create(make_name(buf, name, unit), func, arg)
define|#
directive|define
name|OB_QUERY
parameter_list|(
name|buf
parameter_list|,
name|name
parameter_list|,
name|unit
parameter_list|)
define|\
value|object_query(make_name(buf, name, unit))
for|for
control|(
name|i
operator|=
name|base
init|;
name|i
operator|<
name|base
operator|+
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|scc_unit
index|[
name|i
index|]
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|port_recv_iop
index|[
name|i
index|]
operator|=
name|OB_QUERY
argument_list|(
name|buf
argument_list|,
literal|"scc_inputX"
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_recv_iop
index|[
name|i
index|]
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|port_xmit_iop
index|[
name|i
index|]
operator|=
name|OB_QUERY
argument_list|(
name|buf
argument_list|,
literal|"scc_outputX"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|port_ctrl_iop
index|[
name|i
index|]
operator|=
name|OB_QUERY
argument_list|(
name|buf
argument_list|,
literal|"scc_ctrlX"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|port_stat_iop
index|[
name|i
index|]
operator|=
name|OB_QUERY
argument_list|(
name|buf
argument_list|,
literal|"scc_statX"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|port_rsrecv
index|[
name|i
index|]
operator|=
name|PT_CREATE
argument_list|(
name|buf
argument_list|,
literal|"@rsrecvX"
argument_list|,
name|j
argument_list|,
name|rsrint
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|port_rsxmit
index|[
name|i
index|]
operator|=
name|PT_CREATE
argument_list|(
name|buf
argument_list|,
literal|"@rsxmitX"
argument_list|,
name|j
argument_list|,
name|rsxint
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|port_rsctrl
index|[
name|i
index|]
operator|=
name|PT_CREATE
argument_list|(
name|buf
argument_list|,
literal|"@rsctrlX"
argument_list|,
name|j
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port_rsstat
index|[
name|i
index|]
operator|=
name|PT_CREATE
argument_list|(
name|buf
argument_list|,
literal|"@rsstatX"
argument_list|,
name|j
argument_list|,
name|rssint
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|rs_init
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|msg_send
argument_list|(
name|port_stat_iop
index|[
name|unit
index|]
argument_list|,
name|port_rsstat
index|[
name|unit
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rs_enable
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|MAX_CIO
expr_stmt|;
name|msg_send
argument_list|(
name|port_recv_iop
index|[
name|unit
index|]
argument_list|,
name|port_rsrecv
index|[
name|unit
index|]
argument_list|,
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rsrint
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|from
decl_stmt|,
name|len
decl_stmt|;
name|msg_recv
argument_list|(
name|port_rsrecv
index|[
name|unit
index|]
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|mips
name|clean_dcache
argument_list|(
name|addr
argument_list|,
name|len
operator|+
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_rsrint
argument_list|(
name|unit
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rsxint
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|from
decl_stmt|,
modifier|*
name|len
decl_stmt|;
name|msg_recv
argument_list|(
name|port_rsxmit
index|[
name|unit
index|]
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_rsxint
argument_list|(
name|unit
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rssint
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|from
decl_stmt|,
modifier|*
name|reply
decl_stmt|;
name|msg_recv
argument_list|(
name|port_rsstat
index|[
name|unit
index|]
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|reply
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_rssint
argument_list|(
name|unit
argument_list|,
operator|*
name|reply
argument_list|)
expr_stmt|;
name|msg_send
argument_list|(
name|from
argument_list|,
name|port_rsstat
index|[
name|unit
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rs_start
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|func
decl_stmt|;
name|func
operator|=
name|CIO_START
expr_stmt|;
name|msg_send
argument_list|(
name|port_ctrl_iop
index|[
name|unit
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|func
argument_list|,
sizeof|sizeof
argument_list|(
name|func
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rs_output
argument_list|(
argument|unit
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|msg_send
argument_list|(
name|port_xmit_iop
index|[
name|unit
index|]
argument_list|,
name|port_rsxmit
index|[
name|unit
index|]
argument_list|,
name|rs_tty
index|[
name|unit
index|]
operator|.
name|t_outq
operator|.
name|c_cf
argument_list|,
name|min
argument_list|(
name|n
argument_list|,
name|MAX_CIO
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rs_stop
argument_list|(
argument|unit
argument_list|,
argument|flush
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flush
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|func
decl_stmt|;
name|func
operator|=
name|flush
condition|?
name|CIO_FLUSH
else|:
name|CIO_STOP
expr_stmt|;
name|msg_send
argument_list|(
name|port_ctrl_iop
index|[
name|unit
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|func
argument_list|,
sizeof|sizeof
argument_list|(
name|func
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rs_reset
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|func
decl_stmt|;
name|func
operator|=
name|CIO_RESET
expr_stmt|;
name|msg_send
argument_list|(
name|port_ctrl_iop
index|[
name|unit
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|func
argument_list|,
sizeof|sizeof
argument_list|(
name|func
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rs_get_param
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|port
decl_stmt|;
name|struct
name|scc_ctrl_req
name|req
decl_stmt|;
name|int
name|param
decl_stmt|,
modifier|*
name|reply
decl_stmt|;
name|port
operator|=
name|port_rsctrl
index|[
name|unit
index|]
expr_stmt|;
name|req
operator|.
name|scc_func
operator|=
name|CIO_GETPARAMS
expr_stmt|;
comment|/* message length 8 means 2 * sizeof(int) : func and status */
name|msg_send
argument_list|(
name|port_ctrl_iop
index|[
name|unit
index|]
argument_list|,
name|port
argument_list|,
operator|&
name|req
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msg_recv
argument_list|(
name|port
argument_list|,
name|NULL
argument_list|,
operator|&
name|reply
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|param
operator|=
operator|*
name|reply
expr_stmt|;
name|msg_free
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|param
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|rs_set_param
argument_list|(
name|unit
argument_list|,
name|param
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|param
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scc_ctrl_req
name|req
decl_stmt|;
name|req
operator|.
name|scc_func
operator|=
name|CIO_SETPARAMS
expr_stmt|;
name|req
operator|.
name|scc_arg
operator|=
name|param
expr_stmt|;
comment|/* message length 8 means 2 * sizeof(int) : func and param */
name|msg_send
argument_list|(
name|port_ctrl_iop
index|[
name|unit
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPC_MRX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NRS> 0 */
end_comment

end_unit

