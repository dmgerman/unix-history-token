begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Sony Corp. and Kazumasa Utashiro of Software Research Associates, Inc.  *  * %sccs.include.redist.c%  *  * from: $Hdr: iop.c,v 4.300 91/06/09 06:42:37 root Rel41 $ SONY  *  *	@(#)iop.c	7.4 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  *	iop.c / hb.c	ver 0.0  */
end_comment

begin_include
include|#
directive|include
file|<machine/machConst.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/map.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<news3400/iodev/scsireg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_DOUBLE
end_ifdef

begin_include
include|#
directive|include
file|"../iop/iopvar.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_include
include|#
directive|include
file|<news3400/hbdev/hbvar.h>
end_include

begin_include
include|#
directive|include
file|<news3400/hbdev/scsic.h>
end_include

begin_decl_stmt
name|struct
name|scsi_stat
name|scsi_stat
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * dual processor ===> single processor  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_define
define|#
directive|define
name|iopreset
value|hbreset
end_define

begin_define
define|#
directive|define
name|iopbuf
value|hbbuf
end_define

begin_define
define|#
directive|define
name|iopalloc
value|hballoc
end_define

begin_define
define|#
directive|define
name|iopsetup
value|hbsetup
end_define

begin_define
define|#
directive|define
name|iop_ctlr
value|hb_ctlr
end_define

begin_define
define|#
directive|define
name|iop_device
value|hb_device
end_define

begin_define
define|#
directive|define
name|iopgo
value|hbgo
end_define

begin_define
define|#
directive|define
name|im_driver
value|hm_driver
end_define

begin_define
define|#
directive|define
name|im_ctlr
value|hm_ctlr
end_define

begin_define
define|#
directive|define
name|im_alive
value|hm_alive
end_define

begin_define
define|#
directive|define
name|im_addr
value|hm_addr
end_define

begin_define
define|#
directive|define
name|im_intr
value|hm_intr
end_define

begin_define
define|#
directive|define
name|im_scnum
value|hm_scnum
end_define

begin_define
define|#
directive|define
name|im_hd
value|hm_hd
end_define

begin_define
define|#
directive|define
name|im_hbinfo
value|hm_hbinfo
end_define

begin_define
define|#
directive|define
name|im_tab
value|hm_tab
end_define

begin_define
define|#
directive|define
name|ii_driver
value|hi_driver
end_define

begin_define
define|#
directive|define
name|ii_unit
value|hi_unit
end_define

begin_define
define|#
directive|define
name|ii_ctlr
value|hi_ctlr
end_define

begin_define
define|#
directive|define
name|ii_slave
value|hi_slave
end_define

begin_define
define|#
directive|define
name|ii_addr
value|hi_addr
end_define

begin_define
define|#
directive|define
name|ii_intr
value|hi_intr
end_define

begin_define
define|#
directive|define
name|ii_dk
value|hi_dk
end_define

begin_define
define|#
directive|define
name|ii_flags
value|hi_flags
end_define

begin_define
define|#
directive|define
name|ii_alive
value|hi_alive
end_define

begin_define
define|#
directive|define
name|ii_type
value|hi_type
end_define

begin_define
define|#
directive|define
name|ii_forw
value|hi_forw
end_define

begin_define
define|#
directive|define
name|ii_mi
value|hi_mi
end_define

begin_define
define|#
directive|define
name|ii_hd
value|hi_hd
end_define

begin_define
define|#
directive|define
name|id_dgo
value|hd_dgo
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPU_SINGLE */
end_comment

begin_expr_stmt
name|iopgo
argument_list|(
name|ii
argument_list|,
name|map
argument_list|)
specifier|register
expr|struct
name|iop_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|sc_map
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|iop_ctlr
modifier|*
name|im
init|=
name|ii
operator|->
name|ii_mi
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spl6
argument_list|()
expr_stmt|;
if|if
condition|(
name|map
condition|)
operator|(
name|void
operator|)
name|iopsetup
argument_list|(
name|im
operator|->
name|im_tab
operator|.
name|b_actf
operator|->
name|b_actf
argument_list|,
name|map
argument_list|,
name|NSCMAP
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_dk
operator|>=
literal|0
condition|)
block|{
name|unit
operator|=
name|ii
operator|->
name|ii_dk
expr_stmt|;
name|dk_busy
operator||=
literal|1
operator|<<
name|unit
expr_stmt|;
name|dk_xfer
index|[
name|unit
index|]
operator|++
expr_stmt|;
name|dk_wds
index|[
name|unit
index|]
operator|+=
name|im
operator|->
name|im_tab
operator|.
name|b_actf
operator|->
name|b_actf
operator|->
name|b_bcount
operator|>>
literal|6
expr_stmt|;
block|}
if|if
condition|(
name|im
operator|->
name|im_driver
operator|->
name|id_dgo
condition|)
call|(
modifier|*
name|im
operator|->
name|im_driver
operator|->
name|id_dgo
call|)
argument_list|(
name|im
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|iopsetup
argument_list|(
name|bp
argument_list|,
name|map
argument_list|,
name|nmap
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|sc_map
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nmap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|io
decl_stmt|;
name|int
name|o
decl_stmt|,
name|npf
decl_stmt|;
name|o
operator|=
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|&
name|PGOFSET
expr_stmt|;
name|map
operator|->
name|mp_offset
operator|=
name|o
expr_stmt|;
name|npf
operator|=
name|btoc
argument_list|(
name|bp
operator|->
name|b_bcount
operator|+
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|npf
operator|>
name|nmap
condition|)
name|panic
argument_list|(
literal|"sc_map setup: bcount too large"
argument_list|)
expr_stmt|;
name|map
operator|->
name|mp_pages
operator|=
name|npf
expr_stmt|;
name|io
operator|=
name|map
operator|->
name|mp_addr
expr_stmt|;
ifdef|#
directive|ifdef
name|mips
if|if
condition|(
name|MACH_IS_UNMAPPED
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|npf
operator|--
operator|>
literal|0
condition|;
name|i
operator|++
control|)
operator|*
name|io
operator|++
operator|=
operator|(
operator|(
name|MACH_UNMAPPED_TO_PHYS
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
operator|)
operator|>>
name|PGSHIFT
operator|)
operator|+
name|i
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|>=
operator|(
name|caddr_t
operator|)
name|VM_MIN_KERNEL_ADDRESS
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|<
operator|(
name|caddr_t
operator|)
name|VM_MAX_KERNEL_ADDRESS
operator|)
condition|)
block|{
name|pte
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|kvtopte
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|npf
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|pte
operator|->
name|pg_pfnum
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"sc_map setup: zero pfnum"
argument_list|)
expr_stmt|;
operator|*
name|io
operator|++
operator|=
name|pte
operator|++
operator|->
name|pg_pfnum
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"iopsetup: user address is not allowed"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* mips */
name|ERROR
operator|!
name|This
name|code
name|does
name|not
name|work
operator|.
comment|/* KU:XXX */
name|pte
operator|=
name|buftopte
argument_list|(
name|bp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|npf
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|pte
operator|->
name|pg_pfnum
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"sc_map setup: zero pfnum"
argument_list|)
expr_stmt|;
operator|*
name|io
operator|++
operator|=
name|pte
operator|++
operator|->
name|pg_pfnum
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* mips */
block|}
end_block

begin_macro
name|iopalloc
argument_list|(
argument|addr
argument_list|,
argument|bcnt
argument_list|,
argument|map
argument_list|,
argument|nmap
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bcnt
decl_stmt|,
name|nmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sc_map
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buf
name|iopbuf
decl_stmt|;
name|iopbuf
operator|.
name|b_un
operator|.
name|b_addr
operator|=
name|addr
expr_stmt|;
name|iopbuf
operator|.
name|b_flags
operator|=
name|B_BUSY
expr_stmt|;
name|iopbuf
operator|.
name|b_bcount
operator|=
name|bcnt
expr_stmt|;
comment|/* that's all the fields iopsetup() needs */
return|return
operator|(
name|iopsetup
argument_list|(
operator|&
name|iopbuf
argument_list|,
name|map
argument_list|,
name|nmap
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|iopreset
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|cdevsw
modifier|*
name|cdp
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|CPU_DOUBLE
name|s
operator|=
name|spl6
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"iop: reset"
argument_list|)
expr_stmt|;
for|for
control|(
name|cdp
operator|=
name|cdevsw
init|;
name|cdp
operator|<
name|cdevsw
operator|+
name|nchrdev
condition|;
name|cdp
operator|++
control|)
call|(
modifier|*
name|cdp
operator|->
name|d_reset
call|)
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CPU_SINGLE
name|printf
argument_list|(
literal|"hb: reset"
argument_list|)
expr_stmt|;
for|for
control|(
name|cdp
operator|=
name|cdevsw
init|;
name|cdp
operator|<
name|cdevsw
operator|+
name|nchrdev
condition|;
name|cdp
operator|++
control|)
call|(
modifier|*
name|cdp
operator|->
name|d_reset
call|)
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_macro
name|scsend
argument_list|(
argument|chan
argument_list|,
argument|flag
argument_list|,
argument|sc
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|sc_send
argument_list|(
name|chan
argument_list|,
name|flag
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|SCSI_NOTWAIT
condition|)
return|return;
if|if
condition|(
operator|(
name|flag
operator|&
name|SCSI_INTEN
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2000000
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|sc_busy
argument_list|(
name|chan
argument_list|)
condition|)
return|return;
name|printf
argument_list|(
literal|"SCSI: scsend() timeout: intr=0x%x, ie=0x%x, sc=0x%x\n"
argument_list|,
name|chan
argument_list|,
name|flag
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPU_SINGLE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_comment
comment|/*kos000*/
end_comment

begin_decl_stmt
name|int
name|on_iobusintr2
argument_list|(
name|func
argument_list|,
name|arg
argument_list|,
name|pri
argument_list|)
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pri
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|register_hb_intr2
argument_list|(
name|func
argument_list|,
name|arg
argument_list|,
name|pri
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|on_iobusintr4
argument_list|(
name|func
argument_list|,
name|arg
argument_list|,
name|pri
argument_list|)
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pri
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|register_hb_intr4
argument_list|(
name|func
argument_list|,
name|arg
argument_list|,
name|pri
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*kos000*/
end_comment

begin_comment
comment|/*kos111*/
end_comment

begin_struct
struct|struct
name|hb_intr
block|{
name|struct
name|hb_intr
modifier|*
name|forw
decl_stmt|;
name|struct
name|hb_intr
modifier|*
name|back
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
name|int
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|hb_intr
name|hb_intr2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hb_intr
name|hb_intr4
decl_stmt|;
end_decl_stmt

begin_macro
name|init_hb_intr
argument_list|()
end_macro

begin_block
block|{
name|init_hb_intr2
argument_list|()
expr_stmt|;
name|init_hb_intr4
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|init_hb_intr2
argument_list|()
end_macro

begin_block
block|{
name|hb_intr2
operator|.
name|forw
operator|=
name|hb_intr2
operator|.
name|back
operator|=
operator|&
name|hb_intr2
expr_stmt|;
name|hb_intr2
operator|.
name|pri
operator|=
literal|32767
expr_stmt|;
name|hb_intr2
operator|.
name|func
operator|=
literal|0
expr_stmt|;
name|hb_intr2
operator|.
name|arg
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|init_hb_intr4
argument_list|()
end_macro

begin_block
block|{
name|hb_intr4
operator|.
name|forw
operator|=
name|hb_intr4
operator|.
name|back
operator|=
operator|&
name|hb_intr4
expr_stmt|;
name|hb_intr4
operator|.
name|pri
operator|=
literal|32767
expr_stmt|;
name|hb_intr4
operator|.
name|func
operator|=
literal|0
expr_stmt|;
name|hb_intr4
operator|.
name|arg
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|register_hb_intr2
argument_list|(
argument|func
argument_list|,
argument|arg
argument_list|,
argument|pri
argument_list|)
end_macro

begin_function_decl
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pri
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hb_intr
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splclock
argument_list|()
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hb_intr
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|p
operator|->
name|pri
operator|=
name|pri
expr_stmt|;
name|p
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|p
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
for|for
control|(
name|q
operator|=
name|hb_intr2
operator|.
name|forw
init|;
name|q
operator|!=
operator|&
name|hb_intr2
condition|;
name|q
operator|=
name|q
operator|->
name|forw
control|)
if|if
condition|(
name|p
operator|->
name|pri
operator|<
name|q
operator|->
name|pri
condition|)
break|break;
name|insque
argument_list|(
name|p
argument_list|,
name|q
operator|->
name|back
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_function_decl
name|unregister_hb_intr2
function_decl|(
name|func
function_decl|)
name|int
argument_list|(
argument|*func
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|struct
name|hb_intr
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splclock
argument_list|()
decl_stmt|;
for|for
control|(
name|p
operator|=
name|hb_intr2
operator|.
name|forw
init|;
name|p
operator|!=
operator|&
name|hb_intr2
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
if|if
condition|(
name|p
operator|->
name|func
operator|==
name|func
condition|)
block|{
name|remque
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|register_hb_intr4
argument_list|(
argument|func
argument_list|,
argument|arg
argument_list|,
argument|pri
argument_list|)
end_macro

begin_function_decl
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pri
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hb_intr
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splclock
argument_list|()
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hb_intr
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|p
operator|->
name|pri
operator|=
name|pri
expr_stmt|;
name|p
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|p
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
for|for
control|(
name|q
operator|=
name|hb_intr4
operator|.
name|forw
init|;
name|q
operator|!=
operator|&
name|hb_intr4
condition|;
name|q
operator|=
name|q
operator|->
name|forw
control|)
if|if
condition|(
name|p
operator|->
name|pri
operator|<
name|q
operator|->
name|pri
condition|)
break|break;
name|insque
argument_list|(
name|p
argument_list|,
name|q
operator|->
name|back
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_function_decl
name|unregister_hb_intr4
function_decl|(
name|func
function_decl|)
name|int
argument_list|(
argument|*func
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|struct
name|hb_intr
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splclock
argument_list|()
decl_stmt|;
for|for
control|(
name|p
operator|=
name|hb_intr4
operator|.
name|forw
init|;
name|p
operator|!=
operator|&
name|hb_intr4
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
if|if
condition|(
name|p
operator|->
name|func
operator|==
name|func
condition|)
block|{
name|remque
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|struct
name|vmmeter
name|cnt
decl_stmt|;
end_decl_stmt

begin_macro
name|exec_hb_intr2
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|hb_intr
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|hb_intr2
operator|.
name|forw
init|;
name|p
operator|!=
operator|&
name|hb_intr2
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|p
operator|->
name|func
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
operator|*
operator|(
name|p
operator|->
name|func
operator|)
operator|)
operator|(
name|p
operator|->
name|arg
operator|)
condition|)
block|{
name|cnt
operator|.
name|v_intr
operator|++
expr_stmt|;
comment|/* statistics info. */
return|return;
block|}
block|}
name|out
label|:
ifdef|#
directive|ifdef
name|news3400
return|return;
else|#
directive|else
name|printf
argument_list|(
literal|"stray hb intr 2\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|exec_hb_intr4
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|hb_intr
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|hb_intr4
operator|.
name|forw
init|;
name|p
operator|!=
operator|&
name|hb_intr4
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|p
operator|->
name|func
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
operator|*
operator|(
name|p
operator|->
name|func
operator|)
operator|)
operator|(
name|p
operator|->
name|arg
operator|)
condition|)
block|{
name|cnt
operator|.
name|v_intr
operator|++
expr_stmt|;
comment|/* statistics info. */
return|return;
block|}
block|}
name|out
label|:
ifdef|#
directive|ifdef
name|news3400
return|return;
else|#
directive|else
name|printf
argument_list|(
literal|"stray hb intr 4\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*kos111*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPU_SINGLE */
end_comment

end_unit

