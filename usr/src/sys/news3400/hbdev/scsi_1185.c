begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Sony Corp. and Kazumasa Utashiro of Software Research Associates, Inc.  *  * %sccs.include.redist.c%  *  * from: $Hdr: scsi_1185.c,v 4.300 91/06/09 06:22:20 root Rel41 $ SONY  *  *	@(#)scsi_1185.c	7.4 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1989- by SONY Corporation.  */
end_comment

begin_comment
comment|/*  *	scsi_1185.c  *  *	CXD1185Q  *	SCSI bus low level common routines  *				for one cpu machine  */
end_comment

begin_comment
comment|/*  * MODIFY HISTORY:  *  *	DMAC_WAIT	--- DMAC_0266 wo tukau-baai, DMAC mata-wa SCSI-chip ni  *				tuzukete access suru-baai,  *				kanarazu wait wo ireru-beshi !  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/map.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<news3400/hbdev/hbvar.h>
end_include

begin_include
include|#
directive|include
file|<news3400/hbdev/screg_1185.h>
end_include

begin_include
include|#
directive|include
file|<news3400/hbdev/scsic.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|news3400
end_ifdef

begin_include
include|#
directive|include
file|<news3400/hbdev/dmac_0448.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NDMACMAP
end_ifndef

begin_define
define|#
directive|define
name|NDMACMAP
value|144
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<news3400/iodev/scsireg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|mips
end_ifdef

begin_define
define|#
directive|define
name|VOLATILE
value|volatile
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VOLATILE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ABORT_SYNCTR_MES_FROM_TARGET
end_define

begin_define
define|#
directive|define
name|SCSI_1185AQ
end_define

begin_define
define|#
directive|define
name|RESET_RECOVER
end_define

begin_define
define|#
directive|define
name|DMAC_MAP_INIT
end_define

begin_comment
comment|/* for nws-3700 parity error */
end_comment

begin_define
define|#
directive|define
name|APAD_ALWAYS_ON
end_define

begin_define
define|#
directive|define
name|CHECK_LOOP_CNT
value|60
end_define

begin_define
define|#
directive|define
name|RSL_LOOP_CNT
value|60
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DMAC_MAP_INIT
end_ifndef

begin_define
define|#
directive|define
name|MAP_OVER_ACCESS
end_define

begin_comment
comment|/* for nws-3700 parity error */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|CHECK_MRQ
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_SUPPORT_SYNCTR
end_ifdef

begin_define
define|#
directive|define
name|MAX_OFFSET_BYTES
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAX_OFFSET_BYTES
value|MAX_OFFSET
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NTARGET
value|8
end_define

begin_define
define|#
directive|define
name|act_point
value|spoint
end_define

begin_define
define|#
directive|define
name|act_trcnt
value|stcnt
end_define

begin_define
define|#
directive|define
name|act_tag
value|stag
end_define

begin_define
define|#
directive|define
name|act_offset
value|soffset
end_define

begin_define
define|#
directive|define
name|splscsi
value|splsc
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
end_if

begin_define
define|#
directive|define
name|nops
parameter_list|(
name|x
parameter_list|)
value|{ int i; for (i = 0; i< (x); i++) ; }
end_define

begin_define
define|#
directive|define
name|vtophys
parameter_list|(
name|v
parameter_list|)
value|MACH_UNMAPPED_TO_PHYS(v)
end_define

begin_define
define|#
directive|define
name|DMAC_WAIT0
value|;
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DMAC_WAIT0
value|DMAC_WAIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|perr_flag
index|[
name|NTARGET
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOT_SUPPORT_SYNCTR
end_ifndef

begin_decl_stmt
name|VOLATILE
name|char
name|sync_tr
index|[
name|NTARGET
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DMAC_MAP_INIT
end_ifdef

begin_decl_stmt
name|int
name|dmac_map_init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SCSI_1185AQ
end_ifdef

begin_decl_stmt
name|int
name|scsi_1185AQ
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|sc_chan_stat
name|chan_stat
index|[
name|NTARGET
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SCSI channel status */
end_comment

begin_decl_stmt
name|int
name|sel_stat
index|[
name|NTARGET
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target select status */
end_comment

begin_define
define|#
directive|define
name|SEL_WAIT
value|0
end_define

begin_define
define|#
directive|define
name|SEL_START
value|1
end_define

begin_define
define|#
directive|define
name|SEL_TIMEOUT
value|2
end_define

begin_define
define|#
directive|define
name|SEL_ARBF
value|3
end_define

begin_define
define|#
directive|define
name|SEL_SUCCESS
value|4
end_define

begin_define
define|#
directive|define
name|SEL_RSLD
value|5
end_define

begin_define
define|#
directive|define
name|SEL_RSL_WAIT
value|6
end_define

begin_comment
comment|/*  *	command flag status  */
end_comment

begin_define
define|#
directive|define
name|CF_SET
value|1
end_define

begin_define
define|#
directive|define
name|CF_SEND
value|2
end_define

begin_define
define|#
directive|define
name|CF_ENOUGH
value|3
end_define

begin_define
define|#
directive|define
name|CF_EXEC
value|4
end_define

begin_define
define|#
directive|define
name|SEL_TIMEOUT_VALUE
value|0x7a
end_define

begin_decl_stmt
name|VOLATILE
name|int
name|int_stat1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOLATILE
name|int
name|int_stat2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOLATILE
name|int
name|min_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOLATILE
name|char
name|mout_flag
index|[
name|NTARGET
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MOUT_IDENTIFY
value|1
end_define

begin_define
define|#
directive|define
name|MOUT_SYNC_TR
value|2
end_define

begin_decl_stmt
name|VOLATILE
name|int
name|last_cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOLATILE
name|char
name|min_cnt
index|[
name|NTARGET
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOLATILE
name|u_char
modifier|*
name|min_point
index|[
name|NTARGET
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOLATILE
name|int
name|pad_cnt
index|[
name|NTARGET
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOLATILE
specifier|static
name|u_char
modifier|*
name|act_cmd_pointer
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|VOLATILE
expr|struct
name|sc_chan_stat
operator|*
name|wbq_actf
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* forword active pointer */
end_comment

begin_expr_stmt
specifier|static
name|VOLATILE
expr|struct
name|sc_chan_stat
operator|*
name|wbq_actl
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* last active pointer */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ScsiSoftError
index|[]
init|=
literal|"SCSI soft error"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pad_start
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
end_if

begin_define
define|#
directive|define
name|dma_reset
parameter_list|(
name|x
parameter_list|)
value|{ \ 	int s = splscsi(); \ 	dmac_gsel = (x); dmac_cctl = DM_RST; dmac_cctl = 0; \ 	splx(s); \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|WAIT_STATR_BITCLR
argument_list|(
name|bitmask
argument_list|)
specifier|register
name|int
name|bitmask
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|iloop
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|dummy
decl_stmt|;
name|iloop
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|dummy
operator|=
name|sc_statr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|iloop
operator|++
operator|>
name|CHECK_LOOP_CNT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
do|while
condition|(
name|dummy
operator|&
name|bitmask
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|WAIT_STATR_BITSET
argument_list|(
name|bitmask
argument_list|)
specifier|register
name|int
name|bitmask
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|iloop
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|dummy
decl_stmt|;
name|iloop
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|dummy
operator|=
name|sc_statr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|iloop
operator|++
operator|>
name|CHECK_LOOP_CNT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|(
name|dummy
operator|&
name|bitmask
operator|)
operator|==
literal|0
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|SET_CMD
argument_list|(
name|CMD
argument_list|)
specifier|register
name|int
name|CMD
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|WAIT_STATR_BITCLR
argument_list|(
name|R0_CIP
argument_list|)
expr_stmt|;
name|last_cmd
operator|=
operator|(
name|CMD
operator|)
expr_stmt|;
name|sc_comr
operator|=
operator|(
name|CMD
operator|)
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|SET_CNT
argument_list|(
name|COUNT
argument_list|)
specifier|register
name|int
name|COUNT
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|sc_tclow
operator|=
operator|(
name|COUNT
operator|)
operator|&
literal|0xff
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|sc_tcmid
operator|=
operator|(
operator|(
name|COUNT
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|sc_tchi
operator|=
operator|(
operator|(
name|COUNT
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
block|}
end_block

begin_macro
name|GET_CNT
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|VOLATILE
name|int
name|COUNT
decl_stmt|;
name|COUNT
operator|=
name|sc_tclow
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|COUNT
operator|+=
operator|(
name|sc_tcmid
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|COUNT
operator|+=
operator|(
name|sc_tchi
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
return|return
operator|(
name|COUNT
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|GET_INTR
argument_list|(
name|DATA1
argument_list|,
name|DATA2
argument_list|)
specifier|register
name|VOLATILE
name|int
operator|*
name|DATA1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|VOLATILE
name|int
modifier|*
name|DATA2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|VOLATILE
name|int
name|dummy
decl_stmt|;
operator|(
name|void
operator|)
name|WAIT_STATR_BITCLR
argument_list|(
name|R0_CIP
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc_statr
operator|&
name|R0_MIRQ
condition|)
block|{
name|DMAC_WAIT0
expr_stmt|;
operator|*
name|DATA1
operator||=
name|sc_intrq1
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
operator|*
name|DATA2
operator||=
name|sc_intrq2
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|sc_send
argument_list|(
name|chan
argument_list|,
name|ie
argument_list|,
name|sc
argument_list|)
specifier|register
name|int
name|chan
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|ie
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|VOLATILE
expr|struct
name|sc_chan_stat
operator|*
name|cs
expr_stmt|;
specifier|register
name|struct
name|scsi_stat
modifier|*
name|ss
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|cs
operator|=
operator|&
name|chan_stat
index|[
name|chan
index|]
expr_stmt|;
name|ss
operator|=
operator|&
name|scsi_stat
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|cs
operator|->
name|sc
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"SCSI%d:sc_send() NULL sc or NOT NULL cs->sc\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ie=0x%x sc=0x%x cs->sc=0x%x\n"
argument_list|,
name|ie
argument_list|,
name|sc
argument_list|,
name|cs
operator|->
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
condition|)
block|{
name|printf
argument_list|(
literal|"cdb="
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|sc
operator|->
name|sc_cdb
operator|.
name|un_reserved
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|panic
argument_list|(
name|ScsiSoftError
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_cdb
operator|.
name|un_reserved
index|[
literal|0
index|]
operator|==
name|SCOP_RESET
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_cdb
operator|.
name|un_reserved
index|[
literal|1
index|]
operator|==
name|SCOP_RESET
operator|)
condition|)
block|{
comment|/* 		 * SCSI bus reset command procedure 		 *	(vender unique by Sony Corp.) 		 */
ifdef|#
directive|ifdef
name|SCSI_1185AQ
if|if
condition|(
name|sc_idenr
operator|&
literal|0x08
condition|)
block|{
name|scsi_1185AQ
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|cs
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|scsi_hardreset
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_istatus
operator|=
name|INST_EP
expr_stmt|;
name|cs
operator|->
name|sc
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_map
operator|&&
operator|(
name|sc
operator|->
name|sc_map
operator|->
name|mp_pages
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 		 * use map table 		 */
name|sc
operator|->
name|sc_coffset
operator|=
name|sc
operator|->
name|sc_map
operator|->
name|mp_offset
operator|&
name|PGOFSET
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_map
operator|->
name|mp_pages
operator|>
name|NSCMAP
condition|)
block|{
name|printf
argument_list|(
literal|"SCSI%d: map table overflow\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_istatus
operator|=
name|INST_EP
operator||
name|INST_LB
operator||
name|INST_PRE
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* 		 * no use map table 		 */
name|sc
operator|->
name|sc_coffset
operator|=
operator|(
name|u_int
operator|)
name|sc
operator|->
name|sc_cpoint
operator|&
name|PGOFSET
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ctag
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|cs
operator|->
name|comflg
operator|=
name|OFF
expr_stmt|;
name|cs
operator|->
name|intr_flg
operator|=
name|ie
expr_stmt|;
name|cs
operator|->
name|chan_num
operator|=
name|chan
expr_stmt|;
name|perr_flag
index|[
name|chan
index|]
operator|=
literal|0
expr_stmt|;
name|mout_flag
index|[
name|chan
index|]
operator|=
literal|0
expr_stmt|;
name|min_cnt
index|[
name|chan
index|]
operator|=
literal|0
expr_stmt|;
name|sel_stat
index|[
name|chan
index|]
operator|=
name|SEL_WAIT
expr_stmt|;
name|append_wb
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|sc_start
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	SCSI start up routine  */
end_comment

begin_macro
name|sc_start
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|VOLATILE
expr|struct
name|sc_chan_stat
operator|*
name|cs
expr_stmt|;
specifier|register
name|struct
name|scsi_stat
modifier|*
name|ss
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|chan
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|dummy
decl_stmt|;
name|ss
operator|=
operator|&
name|scsi_stat
expr_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|chan
operator|=
name|get_wb_chan
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|chan
operator|<
literal|0
operator|)
operator|||
operator|(
name|ss
operator|->
name|ipc
operator|>=
literal|0
operator|)
condition|)
goto|goto
name|sc_start_exit
goto|;
if|if
condition|(
name|sel_stat
index|[
name|chan
index|]
operator|!=
name|SEL_WAIT
condition|)
block|{
comment|/* 		 * already started 		 */
goto|goto
name|sc_start_exit
goto|;
block|}
name|sel_stat
index|[
name|chan
index|]
operator|=
name|SEL_START
expr_stmt|;
operator|(
name|void
operator|)
name|splscsi
argument_list|()
expr_stmt|;
name|cs
operator|=
operator|&
name|chan_stat
index|[
name|chan
index|]
expr_stmt|;
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|dummy
operator|&
operator|(
name|R4_MBSY
operator||
name|R4_MSEL
operator|)
condition|)
block|{
name|sel_stat
index|[
name|chan
index|]
operator|=
name|SEL_WAIT
expr_stmt|;
goto|goto
name|sc_start_exit
goto|;
block|}
comment|/* 	 *	send SELECT with ATN command 	 */
name|ss
operator|->
name|dma_stat
operator|=
name|OFF
expr_stmt|;
name|pad_start
operator|=
literal|0
expr_stmt|;
name|dummy
operator|=
name|sc_statr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|dummy
operator|&
name|R0_CIP
condition|)
block|{
name|sel_stat
index|[
name|chan
index|]
operator|=
name|SEL_WAIT
expr_stmt|;
goto|goto
name|sc_start_exit
goto|;
block|}
name|sc_idenr
operator|=
operator|(
name|chan
operator|<<
name|SC_TG_SHIFT
operator|)
operator||
name|SC_OWNID
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
ifdef|#
directive|ifdef
name|SCSI_1185AQ
if|if
condition|(
name|scsi_1185AQ
condition|)
name|sc_intok1
operator|=
name|Ra_STO
operator||
name|Ra_ARBF
expr_stmt|;
else|else
name|sc_intok1
operator|=
name|Ra_STO
operator||
name|Ra_RSL
operator||
name|Ra_ARBF
expr_stmt|;
else|#
directive|else
name|sc_intok1
operator|=
name|Ra_STO
operator||
name|Ra_RSL
operator||
name|Ra_ARBF
expr_stmt|;
endif|#
directive|endif
name|DMAC_WAIT0
expr_stmt|;
comment|/* 	 * BUGFIX for signal reflection on BSY 	 *	!Rb_DCNT 	 */
name|sc_intok2
operator|=
name|Rb_FNC
operator||
name|Rb_SRST
operator||
name|Rb_PHC
operator||
name|Rb_SPE
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|dummy
operator|&
operator|(
name|R4_MBSY
operator||
name|R4_MSEL
operator|)
condition|)
block|{
name|sel_stat
index|[
name|chan
index|]
operator|=
name|SEL_WAIT
expr_stmt|;
goto|goto
name|sc_start_exit
goto|;
block|}
name|SET_CMD
argument_list|(
name|SCMD_SEL_ATN
argument_list|)
expr_stmt|;
name|sc_start_exit
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	SCSI interrupt service routine  */
end_comment

begin_macro
name|scintr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|scsi_stat
modifier|*
name|ss
decl_stmt|;
specifier|register
name|int
name|iloop
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|chan
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|dummy
decl_stmt|;
name|int
name|s_int1
decl_stmt|,
name|s_int2
decl_stmt|;
name|scintr_loop
label|:
if|#
directive|if
name|defined
argument_list|(
name|CHECK_MRQ
argument_list|)
operator|&&
name|defined
argument_list|(
name|news3400
argument_list|)
while|while
condition|(
name|dmac_gstat
operator|&
name|CH_MRQ
argument_list|(
name|CH_SCSI
argument_list|)
condition|)
name|DMAC_WAIT
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|iloop
operator|=
literal|0
init|;
name|iloop
operator|<
literal|100
condition|;
name|iloop
operator|++
control|)
block|{
name|dummy
operator|=
name|sc_statr
expr_stmt|;
name|DMAC_WAIT
expr_stmt|;
if|if
condition|(
operator|(
name|dummy
operator|&
name|R0_CIP
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* 	 * get SCSI interrupt request 	 */
while|while
condition|(
name|sc_statr
operator|&
name|R0_MIRQ
condition|)
block|{
name|DMAC_WAIT0
expr_stmt|;
name|s_int1
operator|=
name|sc_intrq1
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|s_int2
operator|=
name|sc_intrq2
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|int_stat1
operator||=
name|s_int1
expr_stmt|;
name|int_stat2
operator||=
name|s_int2
expr_stmt|;
block|}
if|if
condition|(
name|int_stat2
operator|&
name|R3_SRST
condition|)
block|{
comment|/* 		 * RST signal is drived 		 */
name|int_stat2
operator|&=
operator|~
name|R3_SRST
expr_stmt|;
name|scsi_softreset
argument_list|()
expr_stmt|;
goto|goto
name|scintr_exit
goto|;
block|}
name|ss
operator|=
operator|&
name|scsi_stat
expr_stmt|;
if|if
condition|(
operator|(
name|ss
operator|->
name|ipc
operator|<
literal|0
operator|)
operator|&&
operator|(
name|ss
operator|->
name|wrc
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|ss
operator|->
name|wbc
operator|<=
literal|0
operator|)
condition|)
block|{
name|int_stat1
operator|=
literal|0
expr_stmt|;
name|int_stat2
operator|=
literal|0
expr_stmt|;
goto|goto
name|scintr_exit
goto|;
block|}
name|chan
operator|=
name|get_wb_chan
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|chan
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|sel_stat
index|[
name|chan
index|]
operator|==
name|SEL_START
operator|)
operator|&&
operator|(
name|last_cmd
operator|==
name|SCMD_SEL_ATN
operator|)
condition|)
block|{
comment|/* 		 *	Check the result of SELECTION command 		 */
if|if
condition|(
name|int_stat1
operator|&
name|R2_RSL
condition|)
block|{
comment|/* 			 * RESELECTION occur 			 */
if|if
condition|(
name|ss
operator|->
name|wrc
operator|>
literal|0
condition|)
block|{
name|sel_stat
index|[
name|chan
index|]
operator|=
name|SEL_RSLD
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Ghost RESELECTION ??? 				 */
name|int_stat1
operator|&=
operator|~
name|R2_RSL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|int_stat1
operator|&
name|R2_ARBF
condition|)
block|{
comment|/* 			 * ARBITRATION fault 			 */
name|int_stat1
operator|&=
operator|~
name|R2_ARBF
expr_stmt|;
name|sel_stat
index|[
name|chan
index|]
operator|=
name|SEL_ARBF
expr_stmt|;
block|}
if|if
condition|(
name|int_stat1
operator|&
name|R2_STO
condition|)
block|{
comment|/* 			 * SELECTION timeout 			 */
name|int_stat1
operator|&=
operator|~
name|R2_STO
expr_stmt|;
if|if
condition|(
operator|(
name|int_stat2
operator|&
operator|(
name|R3_PHC
operator||
name|R3_RMSG
operator|)
operator|)
operator|!=
operator|(
name|R3_PHC
operator||
name|R3_RMSG
operator|)
condition|)
block|{
name|ss
operator|->
name|ipc
operator|=
name|chan
expr_stmt|;
name|ss
operator|->
name|ip
operator|=
operator|&
name|chan_stat
index|[
name|chan
index|]
expr_stmt|;
name|sel_stat
index|[
name|chan
index|]
operator|=
name|SEL_TIMEOUT
expr_stmt|;
name|chan_stat
index|[
name|chan
index|]
operator|.
name|sc
operator|->
name|sc_istatus
operator|=
name|INST_EP
operator||
name|INST_TO
expr_stmt|;
name|release_wb
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* 		 *	SELECTION command done 		 */
switch|switch
condition|(
name|sel_stat
index|[
name|chan
index|]
condition|)
block|{
case|case
name|SEL_START
case|:
if|if
condition|(
operator|(
name|int_stat2
operator|&
name|R3_FNC
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 			 * SELECTION success 			 */
name|sc_intok2
operator|=
name|Rb_FNC
operator||
name|Rb_DCNT
operator||
name|Rb_SRST
operator||
name|Rb_PHC
operator||
name|Rb_SPE
expr_stmt|;
name|ss
operator|->
name|ipc
operator|=
name|chan
expr_stmt|;
name|ss
operator|->
name|ip
operator|=
operator|&
name|chan_stat
index|[
name|chan
index|]
expr_stmt|;
name|ss
operator|->
name|ip
operator|->
name|sc
operator|->
name|sc_istatus
operator||=
name|INST_IP
expr_stmt|;
name|ss
operator|->
name|dma_stat
operator|=
name|OFF
expr_stmt|;
name|pad_start
operator|=
literal|0
expr_stmt|;
name|sel_stat
index|[
name|chan
index|]
operator|=
name|SEL_SUCCESS
expr_stmt|;
name|release_wb
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NOT_SUPPORT_SYNCTR
name|sc_syncr
operator|=
name|sync_tr
index|[
name|chan
index|]
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
endif|#
directive|endif
name|DMAC_WAIT0
expr_stmt|;
break|break;
case|case
name|SEL_TIMEOUT
case|:
comment|/* 			 * SELECTION time out 			 */
name|sc_discon
argument_list|()
expr_stmt|;
goto|goto
name|scintr_exit
goto|;
comment|/* case SEL_RSLD: */
comment|/* case SEL_ARBF: */
default|default:
comment|/* 			 * SELECTION failed 			 */
name|sel_stat
index|[
name|chan
index|]
operator|=
name|SEL_WAIT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|int_stat1
operator|&
name|R2_RSL
operator|)
operator|==
literal|0
condition|)
name|int_stat2
operator|&=
operator|~
name|R3_FNC
expr_stmt|;
block|}
if|if
condition|(
name|ss
operator|->
name|ip
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * check In Process channel's request 		 */
if|if
condition|(
name|ss
operator|->
name|dma_stat
operator|!=
name|OFF
condition|)
block|{
comment|/* 			 * adjust pointer& counter 			 */
name|adjust_transfer
argument_list|(
name|ss
operator|->
name|ip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|int_stat2
operator|&
name|R3_SPE
condition|)
block|{
specifier|register
name|int
name|VOLATILE
name|statr
decl_stmt|;
specifier|register
name|int
name|VOLATILE
name|cmonr
decl_stmt|;
name|statr
operator|=
name|sc_statr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|cmonr
operator|=
name|sc_cmonr
expr_stmt|;
name|int_stat2
operator|&=
operator|~
name|R3_SPE
expr_stmt|;
name|perr_flag
index|[
name|ss
operator|->
name|ip
operator|->
name|chan_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|int_stat2
operator|&
name|R3_DCNT
condition|)
block|{
comment|/* 		 * Bus Free 		 */
name|sc_discon
argument_list|()
expr_stmt|;
name|int_stat2
operator|&=
operator|~
name|R3_DCNT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ss
operator|->
name|ipc
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|sel_stat
index|[
name|ss
operator|->
name|ipc
index|]
operator|==
name|SEL_RSL_WAIT
operator|)
condition|)
block|{
name|sel_stat
index|[
name|ss
operator|->
name|ipc
index|]
operator|=
name|SEL_RSLD
expr_stmt|;
name|ss
operator|->
name|ipc
operator|=
operator|-
literal|1
expr_stmt|;
name|int_stat1
operator||=
name|R2_RSL
expr_stmt|;
block|}
if|if
condition|(
name|int_stat1
operator|&
name|R2_RSL
condition|)
block|{
comment|/* 		 * Reselection 		 */
name|sc_resel
argument_list|()
expr_stmt|;
name|int_stat1
operator|&=
operator|~
name|R2_RSL
expr_stmt|;
if|if
condition|(
name|sel_stat
index|[
name|ss
operator|->
name|ipc
index|]
operator|==
name|SEL_RSL_WAIT
condition|)
goto|goto
name|scintr_exit
goto|;
block|}
if|if
condition|(
operator|(
name|ss
operator|->
name|ipc
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ss
operator|->
name|ipc
operator|!=
name|SC_OWNID
operator|)
operator|&&
operator|(
name|sel_stat
index|[
name|ss
operator|->
name|ipc
index|]
operator|==
name|SEL_SUCCESS
operator|)
condition|)
block|{
if|if
condition|(
name|int_stat2
operator|&
name|R3_PHC
condition|)
block|{
comment|/* 			 * Phase change 			 */
name|int_stat2
operator|&=
operator|~
operator|(
name|R3_PHC
operator||
name|R3_RMSG
operator|)
expr_stmt|;
name|sc_pmatch
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|int_stat2
operator|&
name|R3_RMSG
condition|)
block|{
comment|/* 			 * message Phase 			 */
if|if
condition|(
name|min_flag
operator|>
literal|0
condition|)
block|{
name|int_stat2
operator|&=
operator|~
operator|(
name|R3_PHC
operator||
name|R3_RMSG
operator|)
expr_stmt|;
name|sc_pmatch
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ss
operator|->
name|dma_stat
operator|!=
name|OFF
condition|)
block|{
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
operator|(
name|dummy
operator|&
operator|(
name|R4_MMSG
operator||
name|R4_MCD
operator||
name|R4_MREQ
operator|)
operator|)
operator|==
name|R4_MREQ
condition|)
block|{
comment|/* 				 * still DATA transfer phase 				 */
name|sc_dio_pad
argument_list|(
name|ss
operator|->
name|ip
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ss
operator|->
name|ip
operator|->
name|comflg
operator|==
name|CF_SEND
condition|)
block|{
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
operator|(
name|dummy
operator|&
name|SC_PMASK
operator|)
operator|==
name|COM_OUT
condition|)
block|{
comment|/* 				 * command out phase 				 */
name|sc_cout
argument_list|(
name|ss
operator|->
name|ip
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|int_stat2
operator|&
operator|(
name|R3_PHC
operator||
name|R3_RMSG
operator|)
condition|)
goto|goto
name|scintr_exit
goto|;
block|}
if|if
condition|(
operator|(
name|int_stat1
operator|&
operator|(
name|R2_STO
operator||
name|R2_RSL
operator||
name|R2_ARBF
operator|)
operator|)
operator|||
operator|(
name|int_stat2
operator|&
operator|(
name|R3_DCNT
operator||
name|R3_SRST
operator||
name|R3_PHC
operator||
name|R3_SPE
operator|)
operator|)
condition|)
block|{
comment|/* 		 * still remain intrq 		 */
goto|goto
name|scintr_loop
goto|;
block|}
name|scintr_exit
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	SCSI bus reset routine  *		scsi_hardreset() is occered a reset interrupt.  *		And call scsi_softreset().  */
end_comment

begin_macro
name|scsi_hardreset
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DMAC_MAP_INIT
specifier|register
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splscsi
argument_list|()
expr_stmt|;
name|scsi_chipreset
argument_list|()
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|int_stat1
operator|=
literal|0
expr_stmt|;
name|int_stat2
operator|=
literal|0
expr_stmt|;
name|SET_CMD
argument_list|(
name|SCMD_AST_RST
argument_list|)
expr_stmt|;
comment|/* assert RST signal */
ifdef|#
directive|ifdef
name|DMAC_MAP_INIT
if|if
condition|(
name|dmac_map_init
operator|==
literal|0
condition|)
block|{
name|dmac_map_init
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDMACMAP
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
name|dmac_gsel
operator|=
name|CH_SCSI
expr_stmt|;
name|dmac_ctag
operator|=
operator|(
name|u_char
operator|)
name|i
expr_stmt|;
name|dmac_cmap
operator|=
operator|(
name|u_short
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * I/O port (sc_ioptr) bit assign  *	  *	Rf_PRT3		-<reserved>  *	Rf_PRT2		-<reserved>  *	Rf_PRT1		out	Floppy Disk Density control  *	Rf_PRT0		out	Floppy Disk Eject control  */
end_comment

begin_macro
name|scsi_chipreset
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|int
name|iloop
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|save_ioptr
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|dummy
decl_stmt|;
name|int
name|s_int1
decl_stmt|,
name|s_int2
decl_stmt|;
name|s
operator|=
name|splscsi
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
name|dmac_gsel
operator|=
name|CH_SCSI
expr_stmt|;
name|dmac_cwid
operator|=
literal|4
expr_stmt|;
comment|/* initialize DMAC SCSI chan */
operator|*
operator|(
name|unsigned
name|VOLATILE
name|char
operator|*
operator|)
name|PINTEN
operator||=
name|DMA_INTEN
expr_stmt|;
name|dma_reset
argument_list|(
name|CH_SCSI
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc_envir
operator|=
literal|0
expr_stmt|;
comment|/* 1/4 clock */
name|DMAC_WAIT0
expr_stmt|;
name|save_ioptr
operator|=
name|sc_ioptr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|last_cmd
operator|=
name|SCMD_CHIP_RST
expr_stmt|;
name|sc_comr
operator|=
name|SCMD_CHIP_RST
expr_stmt|;
comment|/* reset chip */
name|DMAC_WAIT
expr_stmt|;
operator|(
name|void
operator|)
name|WAIT_STATR_BITCLR
argument_list|(
name|R0_CIP
argument_list|)
expr_stmt|;
comment|/* 	 * SCMD_CHIP_RST command reset all register 	 *				except sc_statr<7:6>& sc_cmonr. 	 * So, bit R0_MIRQ& R3_FNC will be not set. 	 */
name|sc_idenr
operator|=
name|SC_OWNID
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|sc_intok1
operator|=
name|Ra_STO
operator||
name|Ra_RSL
operator||
name|Ra_ARBF
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|sc_intok2
operator|=
name|Rb_FNC
operator||
name|Rb_SRST
operator||
name|Rb_PHC
operator||
name|Rb_SPE
operator||
name|Rb_RMSG
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|sc_ioptr
operator|=
name|save_ioptr
expr_stmt|;
name|DMAC_WAIT
expr_stmt|;
name|sc_moder
operator|=
name|Rc_TMSL
expr_stmt|;
comment|/* RST drive time = 25.5 us */
name|DMAC_WAIT0
expr_stmt|;
name|sc_timer
operator|=
literal|0x2
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|sc_moder
operator|=
name|Rc_SPHI
expr_stmt|;
comment|/* selection timeout = 252 ms */
name|DMAC_WAIT0
expr_stmt|;
name|sc_timer
operator|=
name|SEL_TIMEOUT_VALUE
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
ifdef|#
directive|ifdef
name|SCSI_1185AQ
if|if
condition|(
name|scsi_1185AQ
condition|)
name|SET_CMD
argument_list|(
name|SCMD_ENB_SEL
argument_list|)
expr_stmt|;
comment|/* enable reselection */
endif|#
directive|endif
name|int_stat1
operator|&=
operator|~
name|R2_RSL
expr_stmt|;
comment|/* ignore RSL inter request */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|scsi_softreset
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|VOLATILE
expr|struct
name|sc_chan_stat
operator|*
name|cs
expr_stmt|;
specifier|register
name|struct
name|scsi_stat
modifier|*
name|ss
decl_stmt|;
specifier|register
name|int
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|mips
specifier|extern
name|struct
name|sc_data
name|sc_data
index|[]
decl_stmt|;
specifier|register
name|struct
name|sc_data
modifier|*
name|scdp
decl_stmt|;
endif|#
directive|endif
name|wbq_actf
operator|=
name|NULL
expr_stmt|;
name|wbq_actl
operator|=
name|NULL
expr_stmt|;
name|ss
operator|=
operator|&
name|scsi_stat
expr_stmt|;
name|ss
operator|->
name|wbc
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|wrc
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|ip
operator|=
name|NULL
expr_stmt|;
name|ss
operator|->
name|ipc
operator|=
operator|-
literal|1
expr_stmt|;
name|ss
operator|->
name|dma_stat
operator|=
name|OFF
expr_stmt|;
name|pad_start
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTARGET
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
name|SC_OWNID
condition|)
continue|continue;
name|cs
operator|=
operator|&
name|chan_stat
index|[
name|i
index|]
expr_stmt|;
name|cs
operator|->
name|wb_next
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|NOT_SUPPORT_SYNCTR
name|sync_tr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* asynchronous mode */
endif|#
directive|endif
name|sel_stat
index|[
name|i
index|]
operator|=
name|SEL_WAIT
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|sc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cs
operator|->
name|sc
operator|->
name|sc_istatus
operator|&
name|INST_EP
operator|)
operator|==
literal|0
condition|)
name|cs
operator|->
name|sc
operator|->
name|sc_istatus
operator|=
operator|(
name|INST_EP
operator||
name|INST_HE
operator|)
expr_stmt|;
name|cs
operator|->
name|sc
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|mips
name|scdp
operator|=
operator|&
name|sc_data
index|[
name|cs
operator|->
name|chan_num
index|]
expr_stmt|;
name|MachFlushDCache
argument_list|(
name|scdp
operator|->
name|scd_scaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MACH_IS_USPACE
argument_list|(
name|scdp
operator|->
name|scd_vaddr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"scsi_softreset: user address is not supported"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MACH_IS_CACHED
argument_list|(
name|scdp
operator|->
name|scd_vaddr
argument_list|)
condition|)
block|{
name|MachFlushDCache
argument_list|(
name|scdp
operator|->
name|scd_vaddr
argument_list|,
name|scdp
operator|->
name|scd_count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MACH_IS_MAPPED
argument_list|(
name|scdp
operator|->
name|scd_vaddr
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
comment|/* KU:XXX */
name|clean_k2dcache
argument_list|(
name|scdp
operator|->
name|scd_vaddr
argument_list|,
name|scdp
operator|->
name|scd_count
argument_list|)
expr_stmt|;
else|#
directive|else
name|MachFlushCache
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* mips */
if|if
condition|(
operator|(
name|cs
operator|->
name|intr_flg
operator|==
name|SCSI_INTEN
operator|)
operator|&&
operator|(
name|handler
operator|=
name|scintsw
index|[
name|i
index|]
operator|.
name|sci_inthandler
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|noyet
comment|/* KU:XXX */
name|intrcnt
index|[
name|INTR_SCSI00
operator|+
name|i
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|handler
call|)
argument_list|(
name|scintsw
index|[
name|i
index|]
operator|.
name|sci_ctlr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	RESELECTION interrupt service routine  *		( RESELECTION phase )  */
end_comment

begin_macro
name|sc_resel
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|sc_chan_stat
modifier|*
name|cs
decl_stmt|;
specifier|register
name|struct
name|scsi_stat
modifier|*
name|ss
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|chan
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|statr
decl_stmt|;
specifier|register
name|int
name|iloop
decl_stmt|;
name|min_flag
operator|=
literal|0
expr_stmt|;
name|chan
operator|=
operator|(
name|sc_idenr
operator|&
name|R6_SID_MASK
operator|)
operator|>>
name|SC_TG_SHIFT
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|SC_OWNID
condition|)
return|return;
name|statr
operator|=
name|sc_statr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|statr
operator|&
name|R0_CIP
condition|)
block|{
if|if
condition|(
name|last_cmd
operator|==
name|SCMD_SEL_ATN
condition|)
block|{
comment|/* 			 * SELECTION command dead lock ? 			 *	save interrupt request 			 */
while|while
condition|(
name|sc_statr
operator|&
name|R0_MIRQ
condition|)
block|{
name|DMAC_WAIT0
expr_stmt|;
name|int_stat1
operator||=
name|sc_intrq1
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|int_stat2
operator||=
name|sc_intrq2
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
block|}
name|scsi_chipreset
argument_list|()
expr_stmt|;
block|}
block|}
name|cs
operator|=
operator|&
name|chan_stat
index|[
name|chan
index|]
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|sc
operator|==
name|NULL
condition|)
block|{
name|scsi_hardreset
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|cs
operator|->
name|sc
operator|->
name|sc_istatus
operator|&
name|INST_WR
operator|)
operator|==
literal|0
condition|)
block|{
name|scsi_hardreset
argument_list|()
expr_stmt|;
return|return;
block|}
name|ss
operator|=
operator|&
name|scsi_stat
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ipc
operator|>=
literal|0
condition|)
block|{
name|scsi_hardreset
argument_list|()
expr_stmt|;
return|return;
block|}
name|ss
operator|->
name|ip
operator|=
name|cs
expr_stmt|;
name|ss
operator|->
name|ipc
operator|=
name|chan
expr_stmt|;
name|sc_intok2
operator|=
name|Rb_FNC
operator||
name|Rb_DCNT
operator||
name|Rb_SRST
operator||
name|Rb_PHC
operator||
name|Rb_SPE
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|iloop
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|int_stat2
operator|&
name|R3_FNC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Max 6 usec wait 		 */
if|if
condition|(
name|iloop
operator|++
operator|>
name|RSL_LOOP_CNT
condition|)
block|{
name|sel_stat
index|[
name|chan
index|]
operator|=
name|SEL_RSL_WAIT
expr_stmt|;
return|return;
block|}
name|GET_INTR
argument_list|(
operator|&
name|int_stat1
argument_list|,
operator|&
name|int_stat2
argument_list|)
expr_stmt|;
block|}
name|int_stat2
operator|&=
operator|~
name|R3_FNC
expr_stmt|;
name|sel_stat
index|[
name|chan
index|]
operator|=
name|SEL_SUCCESS
expr_stmt|;
name|ss
operator|->
name|wrc
operator|--
expr_stmt|;
name|ss
operator|->
name|dma_stat
operator|=
name|OFF
expr_stmt|;
name|pad_start
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|sc
operator|->
name|sc_istatus
operator||=
name|INST_IP
expr_stmt|;
name|cs
operator|->
name|sc
operator|->
name|sc_istatus
operator|&=
operator|~
name|INST_WR
expr_stmt|;
ifndef|#
directive|ifndef
name|NOT_SUPPORT_SYNCTR
name|sc_syncr
operator|=
name|sync_tr
index|[
name|chan
index|]
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  *	DISCONNECT interrupt service routine  *		( Target disconnect / job done )  */
end_comment

begin_macro
name|sc_discon
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|VOLATILE
expr|struct
name|sc_chan_stat
operator|*
name|cs
expr_stmt|;
specifier|register
name|struct
name|scsi_stat
modifier|*
name|ss
decl_stmt|;
specifier|register
name|int
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
specifier|register
name|VOLATILE
name|int
name|dummy
decl_stmt|;
ifdef|#
directive|ifdef
name|mips
specifier|extern
name|struct
name|sc_data
name|sc_data
index|[]
decl_stmt|;
specifier|register
name|struct
name|sc_data
modifier|*
name|scdp
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Signal reflection on BSY is occured. 	 *	Not Bus Free Phase, ignore. 	 * 	 *	But, CXD1185Q reset INIT bit of sc_statr. 	 *	So, can't issue Transfer Information command. 	 *	 	 *	What shall we do ?  Bus reset ? 	 */
if|if
condition|(
operator|(
name|int_stat2
operator|&
name|R3_DCNT
operator|)
operator|&&
operator|(
operator|(
name|sc_intok2
operator|&
name|Rb_DCNT
operator|)
operator|==
literal|0
operator|)
condition|)
return|return;
name|sc_intok2
operator|=
name|Rb_FNC
operator||
name|Rb_SRST
operator||
name|Rb_PHC
operator||
name|Rb_SPE
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|min_flag
operator|=
literal|0
expr_stmt|;
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|dummy
operator|&
name|R4_MATN
condition|)
block|{
name|SET_CMD
argument_list|(
name|SCMD_NGT_ATN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|WAIT_STATR_BITSET
argument_list|(
name|R0_MIRQ
argument_list|)
expr_stmt|;
name|GET_INTR
argument_list|(
operator|&
name|int_stat1
argument_list|,
operator|&
name|int_stat2
argument_list|)
expr_stmt|;
comment|/* clear interrupt */
block|}
if|if
condition|(
operator|(
name|int_stat1
operator|&
name|R2_RSL
operator|)
operator|==
literal|0
condition|)
name|int_stat2
operator|&=
operator|~
name|R3_FNC
expr_stmt|;
name|ss
operator|=
operator|&
name|scsi_stat
expr_stmt|;
name|cs
operator|=
name|ss
operator|->
name|ip
expr_stmt|;
if|if
condition|(
operator|(
name|cs
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ss
operator|->
name|ipc
operator|<
literal|0
operator|)
condition|)
goto|goto
name|sc_discon_exit
goto|;
if|if
condition|(
operator|(
name|sel_stat
index|[
name|cs
operator|->
name|chan_num
index|]
operator|!=
name|SEL_SUCCESS
operator|)
operator|&&
operator|(
name|sel_stat
index|[
name|cs
operator|->
name|chan_num
index|]
operator|!=
name|SEL_TIMEOUT
operator|)
condition|)
name|printf
argument_list|(
literal|"sc_discon: eh!\n"
argument_list|)
expr_stmt|;
comment|/* 	 * indicate abnormal terminate 	 */
if|if
condition|(
operator|(
name|cs
operator|->
name|sc
operator|->
name|sc_istatus
operator|&
operator|(
name|INST_EP
operator||
name|INST_WR
operator|)
operator|)
operator|==
literal|0
condition|)
name|cs
operator|->
name|sc
operator|->
name|sc_istatus
operator||=
operator|(
name|INST_EP
operator||
name|INST_PRE
operator||
name|INST_LB
operator|)
expr_stmt|;
name|cs
operator|->
name|sc
operator|->
name|sc_istatus
operator|&=
operator|~
name|INST_IP
expr_stmt|;
name|ss
operator|->
name|dma_stat
operator|=
name|OFF
expr_stmt|;
name|pad_start
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|ip
operator|=
name|NULL
expr_stmt|;
name|ss
operator|->
name|ipc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cs
operator|->
name|sc
operator|->
name|sc_istatus
operator|&
name|INST_WR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|perr_flag
index|[
name|cs
operator|->
name|chan_num
index|]
operator|>
literal|0
condition|)
name|cs
operator|->
name|sc
operator|->
name|sc_istatus
operator||=
name|INST_EP
operator||
name|INST_PRE
expr_stmt|;
name|cs
operator|->
name|sc
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|mips
name|scdp
operator|=
operator|&
name|sc_data
index|[
name|cs
operator|->
name|chan_num
index|]
expr_stmt|;
name|MachFlushDCache
argument_list|(
name|scdp
operator|->
name|scd_scaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MACH_IS_USPACE
argument_list|(
name|scdp
operator|->
name|scd_vaddr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"sc_discon: user address is not supported"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MACH_IS_CACHED
argument_list|(
name|scdp
operator|->
name|scd_vaddr
argument_list|)
condition|)
block|{
name|MachFlushDCache
argument_list|(
name|scdp
operator|->
name|scd_vaddr
argument_list|,
name|scdp
operator|->
name|scd_count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MACH_IS_MAPPED
argument_list|(
name|scdp
operator|->
name|scd_vaddr
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
comment|/* KU:XXX */
name|clean_k2dcache
argument_list|(
name|scdp
operator|->
name|scd_vaddr
argument_list|,
name|scdp
operator|->
name|scd_count
argument_list|)
expr_stmt|;
else|#
directive|else
name|MachFlushCache
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* mips */
if|if
condition|(
operator|(
name|cs
operator|->
name|intr_flg
operator|==
name|SCSI_INTEN
operator|)
operator|&&
operator|(
name|handler
operator|=
name|scintsw
index|[
name|cs
operator|->
name|chan_num
index|]
operator|.
name|sci_inthandler
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
comment|/* KU:XXX */
name|intrcnt
index|[
name|INTR_SCSI00
operator|+
name|cs
operator|->
name|chan_num
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|handler
call|)
argument_list|(
name|scintsw
index|[
name|cs
operator|->
name|chan_num
index|]
operator|.
name|sci_ctlr
argument_list|)
expr_stmt|;
block|}
block|}
name|sc_discon_exit
label|:
name|sc_start
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	SCSI phase match interrupt service routine  */
end_comment

begin_macro
name|sc_pmatch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|VOLATILE
expr|struct
name|sc_chan_stat
operator|*
name|cs
expr_stmt|;
specifier|register
name|VOLATILE
name|int
name|phase
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|phase2
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|cmonr
decl_stmt|;
name|int_stat2
operator|&=
operator|~
name|R3_FNC
expr_stmt|;
comment|/* XXXXXXXX */
name|cs
operator|=
name|scsi_stat
operator|.
name|ip
expr_stmt|;
if|if
condition|(
name|cs
operator|==
name|NULL
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
name|dma_reset
argument_list|(
name|CH_SCSI
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|phase
operator|=
name|sc_cmonr
operator|&
name|SC_PMASK
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|phase2
operator|=
name|phase
expr_stmt|;
name|cmonr
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|phase
operator|=
name|cmonr
operator|&
name|SC_PMASK
expr_stmt|;
if|if
condition|(
name|phase
operator|==
name|phase2
condition|)
block|{
if|if
condition|(
operator|(
name|phase
operator|==
name|DAT_IN
operator|)
operator|||
operator|(
name|phase
operator|==
name|DAT_OUT
operator|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|cmonr
operator|&
name|R4_MREQ
condition|)
break|break;
block|}
block|}
name|scsi_stat
operator|.
name|dma_stat
operator|=
name|OFF
expr_stmt|;
name|pad_start
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|phase
operator|==
name|COM_OUT
condition|)
block|{
name|min_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|comflg
operator|!=
name|CF_SEND
condition|)
name|cs
operator|->
name|comflg
operator|=
name|CF_SET
expr_stmt|;
name|sc_cout
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cs
operator|->
name|comflg
operator|=
name|CF_ENOUGH
expr_stmt|;
name|sc_intok2
operator|&=
operator|~
name|Rb_FNC
expr_stmt|;
if|if
condition|(
name|phase
operator|==
name|MES_IN
condition|)
block|{
name|min_flag
operator|++
expr_stmt|;
name|sc_min
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|min_flag
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
name|MES_OUT
case|:
name|sc_mout
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|DAT_IN
case|:
case|case
name|DAT_OUT
case|:
name|sc_dio
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAT_IN
case|:
name|sc_sin
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"SCSI%d: unknown phase\n"
argument_list|,
name|cs
operator|->
name|chan_num
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_block

begin_macro
name|flush_fifo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|VOLATILE
name|int
name|dummy
decl_stmt|;
name|VOLATILE
name|int
name|tmp
decl_stmt|;
name|VOLATILE
name|int
name|tmp0
decl_stmt|;
name|dummy
operator|=
name|sc_ffstr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|dummy
operator|&
name|R5_FIFOREM
condition|)
block|{
comment|/* 		 * flush FIFO 		 */
name|SET_CMD
argument_list|(
name|SCMD_FLSH_FIFO
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
do|do
block|{
do|do
block|{
name|dummy
operator|=
name|sc_statr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
block|}
do|while
condition|(
name|dummy
operator|&
name|R0_CIP
condition|)
do|;
name|GET_INTR
argument_list|(
operator|&
name|tmp0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* clear interrupt */
block|}
do|while
condition|(
operator|(
name|tmp
operator|&
name|R3_FNC
operator|)
operator|==
literal|0
condition|)
do|;
block|}
block|}
end_block

begin_comment
comment|/*  *	SCSI command send routine  */
end_comment

begin_function
name|int
name|sc_cout
parameter_list|(
name|cs
parameter_list|)
specifier|register
name|struct
name|sc_chan_stat
modifier|*
name|cs
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|iloop
decl_stmt|;
specifier|register
name|int
name|cdb_bytes
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|dummy
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|statr
decl_stmt|;
if|if
condition|(
name|cs
operator|->
name|comflg
operator|==
name|CF_SET
condition|)
block|{
name|cs
operator|->
name|comflg
operator|=
name|CF_SEND
expr_stmt|;
name|flush_fifo
argument_list|()
expr_stmt|;
name|sc
operator|=
name|cs
operator|->
name|sc
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_opcode
operator|&
name|CMD_TYPEMASK
condition|)
block|{
case|case
name|CMD_T0
case|:
name|cdb_bytes
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|CMD_T1
case|:
name|cdb_bytes
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|CMD_T5
case|:
name|cdb_bytes
operator|=
literal|12
expr_stmt|;
break|break;
default|default:
name|cdb_bytes
operator|=
literal|6
expr_stmt|;
name|sc_intok2
operator||=
name|Rb_FNC
expr_stmt|;
break|break;
block|}
comment|/* 		 * set Active pointers 		 */
name|act_cmd_pointer
operator|=
name|sc
operator|->
name|sc_cdb
operator|.
name|un_reserved
expr_stmt|;
name|cs
operator|->
name|act_trcnt
operator|=
name|sc
operator|->
name|sc_ctrnscnt
expr_stmt|;
name|cs
operator|->
name|act_point
operator|=
name|sc
operator|->
name|sc_cpoint
expr_stmt|;
name|cs
operator|->
name|act_tag
operator|=
name|sc
operator|->
name|sc_ctag
expr_stmt|;
name|cs
operator|->
name|act_offset
operator|=
name|sc
operator|->
name|sc_coffset
expr_stmt|;
block|}
else|else
block|{
name|cdb_bytes
operator|=
literal|1
expr_stmt|;
name|iloop
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
operator|(
name|dummy
operator|&
name|SC_PMASK
operator|)
operator|!=
name|COM_OUT
condition|)
return|return;
name|statr
operator|=
name|sc_statr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|statr
operator|&
name|R0_MIRQ
condition|)
return|return;
block|}
do|while
condition|(
operator|(
name|dummy
operator|&
name|R4_MREQ
operator|)
operator|==
literal|0
condition|)
do|;
name|statr
operator|=
name|sc_statr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|statr
operator|&
name|R0_MIRQ
condition|)
return|return;
block|}
name|SET_CNT
argument_list|(
name|cdb_bytes
argument_list|)
expr_stmt|;
name|SET_CMD
argument_list|(
name|SCMD_TR_INFO
operator||
name|R0_TRBE
argument_list|)
expr_stmt|;
for|for
control|(
name|iloop
operator|=
literal|0
init|;
name|iloop
operator|<
name|cdb_bytes
condition|;
name|iloop
operator|++
control|)
block|{
do|do
block|{
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
operator|(
name|dummy
operator|&
name|SC_PMASK
operator|)
operator|!=
name|COM_OUT
condition|)
return|return;
block|}
do|while
condition|(
operator|(
name|dummy
operator|&
name|R4_MREQ
operator|)
operator|==
literal|0
condition|)
do|;
name|statr
operator|=
name|sc_statr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|statr
operator|&
name|R0_MIRQ
condition|)
return|return;
name|sc_datr
operator|=
operator|*
name|act_cmd_pointer
operator|++
expr_stmt|;
do|do
block|{
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|dummy
operator|&
name|R4_MACK
operator|)
operator|!=
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|GET_MIN_COUNT
value|127
end_define

begin_comment
comment|/*  *	SCSI message accept routine  */
end_comment

begin_expr_stmt
name|sc_min
argument_list|(
name|cs
argument_list|)
specifier|register
expr|struct
name|sc_chan_stat
operator|*
name|cs
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|scsi_stat
modifier|*
name|ss
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|dummy
decl_stmt|;
name|sc
operator|=
name|cs
operator|->
name|sc
expr_stmt|;
name|ss
operator|=
operator|&
name|scsi_stat
expr_stmt|;
name|sc_intok2
operator|=
name|Rb_FNC
operator||
name|Rb_DCNT
operator||
name|Rb_SRST
operator||
name|Rb_PHC
operator||
name|Rb_SPE
operator||
name|Rb_RMSG
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|min_flag
operator|==
literal|1
condition|)
name|flush_fifo
argument_list|()
expr_stmt|;
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
operator|(
name|dummy
operator|&
name|R4_MREQ
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sc_min: !REQ cmonr=%x\n"
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|print_scsi_stat
argument_list|()
expr_stmt|;
name|scsi_hardreset
argument_list|()
expr_stmt|;
return|return;
block|}
name|retry_cmd_issue
label|:
name|int_stat2
operator|&=
operator|~
name|R3_FNC
expr_stmt|;
name|SET_CMD
argument_list|(
name|SCMD_TR_INFO
argument_list|)
expr_stmt|;
do|do
block|{
do|do
block|{
name|dummy
operator|=
name|sc_statr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
block|}
do|while
condition|(
name|dummy
operator|&
name|R0_CIP
condition|)
do|;
name|GET_INTR
argument_list|(
operator|&
name|int_stat1
argument_list|,
operator|&
name|int_stat2
argument_list|)
expr_stmt|;
comment|/* clear interrupt */
block|}
do|while
condition|(
operator|(
name|int_stat2
operator|&
name|R3_FNC
operator|)
operator|==
literal|0
condition|)
do|;
name|int_stat2
operator|&=
operator|~
name|R3_FNC
expr_stmt|;
name|dummy
operator|=
name|sc_ffstr
expr_stmt|;
if|if
condition|(
name|dummy
operator|&
name|R5_FIE
condition|)
block|{
name|DMAC_WAIT
expr_stmt|;
name|dummy
operator|=
name|sc_ffstr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|dummy
operator|&
name|R5_FIE
condition|)
block|{
name|dummy
operator|=
name|sc_statr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
operator|(
name|dummy
operator|&
name|R0_INIT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * CXD1185 detect BSY false 				 */
name|scsi_hardreset
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
name|dummy
operator|=
name|sc_datr
expr_stmt|;
comment|/* get message byte */
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|min_cnt
index|[
name|cs
operator|->
name|chan_num
index|]
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_message
operator|=
name|sc
operator|->
name|sc_identify
expr_stmt|;
if|if
condition|(
name|dummy
operator|==
name|MSG_EXTND
condition|)
block|{
comment|/* Extended Message */
name|min_cnt
index|[
name|cs
operator|->
name|chan_num
index|]
operator|=
name|GET_MIN_COUNT
expr_stmt|;
name|min_point
index|[
name|cs
operator|->
name|chan_num
index|]
operator|=
name|sc
operator|->
name|sc_param
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_param
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|min_point
index|[
name|cs
operator|->
name|chan_num
index|]
operator|++
operator|=
name|dummy
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
operator|(
name|dummy
operator|&
name|MSG_IDENT
operator|)
condition|?
name|MSG_IDENT
else|:
name|dummy
condition|)
block|{
case|case
name|MSG_CCOMP
case|:
name|sc
operator|->
name|sc_istatus
operator||=
name|INST_EP
expr_stmt|;
break|break;
case|case
name|MSG_MREJ
case|:
ifndef|#
directive|ifndef
name|NOT_SUPPORT_SYNCTR
if|if
condition|(
name|mout_flag
index|[
name|cs
operator|->
name|chan_num
index|]
operator|==
name|MOUT_SYNC_TR
condition|)
name|sync_tr
index|[
name|cs
operator|->
name|chan_num
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|MSG_IDENT
case|:
case|case
name|MSG_RDP
case|:
name|ss
operator|->
name|dma_stat
operator|=
name|OFF
expr_stmt|;
name|pad_start
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|comflg
operator|=
name|OFF
expr_stmt|;
comment|/* 				 * restore the saved value to Active pointers 				 */
name|act_cmd_pointer
operator|=
name|sc
operator|->
name|sc_cdb
operator|.
name|un_reserved
expr_stmt|;
name|cs
operator|->
name|act_trcnt
operator|=
name|sc
operator|->
name|sc_ctrnscnt
expr_stmt|;
name|cs
operator|->
name|act_point
operator|=
name|sc
operator|->
name|sc_cpoint
expr_stmt|;
name|cs
operator|->
name|act_tag
operator|=
name|sc
operator|->
name|sc_ctag
expr_stmt|;
name|cs
operator|->
name|act_offset
operator|=
name|sc
operator|->
name|sc_coffset
expr_stmt|;
break|break;
case|case
name|MSG_SDP
case|:
comment|/* 				 * save Active pointers 				 */
name|sc
operator|->
name|sc_ctrnscnt
operator|=
name|cs
operator|->
name|act_trcnt
expr_stmt|;
name|sc
operator|->
name|sc_ctag
operator|=
name|cs
operator|->
name|act_tag
expr_stmt|;
name|sc
operator|->
name|sc_coffset
operator|=
name|cs
operator|->
name|act_offset
expr_stmt|;
name|sc
operator|->
name|sc_cpoint
operator|=
name|cs
operator|->
name|act_point
expr_stmt|;
break|break;
case|case
name|MSG_DCNT
case|:
name|sc
operator|->
name|sc_istatus
operator||=
name|INST_WR
expr_stmt|;
name|ss
operator|->
name|wrc
operator|++
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|sc_message
operator|=
name|MSG_MREJ
expr_stmt|;
name|SET_CMD
argument_list|(
name|SCMD_AST_ATN
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI%d:sc_min() Unknown mes=0x%x, \n"
argument_list|,
name|cs
operator|->
name|chan_num
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
operator|*
name|min_point
index|[
name|cs
operator|->
name|chan_num
index|]
operator|++
operator|=
name|dummy
expr_stmt|;
if|if
condition|(
name|min_cnt
index|[
name|cs
operator|->
name|chan_num
index|]
operator|==
name|GET_MIN_COUNT
condition|)
name|min_cnt
index|[
name|cs
operator|->
name|chan_num
index|]
operator|=
name|dummy
expr_stmt|;
else|else
name|min_cnt
index|[
name|cs
operator|->
name|chan_num
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|min_cnt
index|[
name|cs
operator|->
name|chan_num
index|]
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|ABORT_SYNCTR_MES_FROM_TARGET
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_param
index|[
literal|2
index|]
operator|==
literal|0x01
operator|)
operator|&&
operator|(
name|mout_flag
index|[
name|cs
operator|->
name|chan_num
index|]
operator|==
name|MOUT_SYNC_TR
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|sc
operator|->
name|sc_param
index|[
literal|2
index|]
operator|==
literal|0x01
condition|)
block|{
comment|/*}*/
endif|#
directive|endif
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 				 * receive Synchronous transfer message reply 				 *	calculate transfer period val 				 *	tpm * 4/1000 us = 4/16 * (tpv + 1) 				 */
define|#
directive|define
name|TPM2TPV
parameter_list|(
name|tpm
parameter_list|)
value|(((tpm)*16 + 999) / 1000 - 1)
ifndef|#
directive|ifndef
name|NOT_SUPPORT_SYNCTR
name|i
operator|=
name|sc
operator|->
name|sc_param
index|[
literal|3
index|]
expr_stmt|;
comment|/* get tpm */
name|i
operator|=
name|TPM2TPV
argument_list|(
name|i
argument_list|)
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_param
index|[
literal|4
index|]
operator|==
literal|0
condition|)
name|sync_tr
index|[
name|cs
operator|->
name|chan_num
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|sync_tr
index|[
name|cs
operator|->
name|chan_num
index|]
operator|=
name|i
operator||
name|sc
operator|->
name|sc_param
index|[
literal|4
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* !NOT_SUPPORT_SYNCTR */
block|}
else|else
block|{
name|sc
operator|->
name|sc_message
operator|=
name|MSG_MREJ
expr_stmt|;
name|SET_CMD
argument_list|(
name|SCMD_AST_ATN
argument_list|)
expr_stmt|;
comment|/* assert ATN */
block|}
block|}
block|}
name|SET_CMD
argument_list|(
name|SCMD_NGT_ACK
argument_list|)
expr_stmt|;
block|}
comment|/*  *	SCSI message send routine  */
name|int
name|sc_mout
parameter_list|(
name|cs
parameter_list|)
specifier|register
name|struct
name|sc_chan_stat
modifier|*
name|cs
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi
modifier|*
name|sc
init|=
name|cs
operator|->
name|sc
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|int
name|iloop
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|dummy
decl_stmt|;
name|VOLATILE
name|int
name|tmp
decl_stmt|;
name|VOLATILE
name|int
name|tmp0
decl_stmt|;
name|flush_fifo
argument_list|()
expr_stmt|;
if|if
condition|(
name|mout_flag
index|[
name|cs
operator|->
name|chan_num
index|]
operator|==
literal|0
condition|)
block|{
name|mout_flag
index|[
name|cs
operator|->
name|chan_num
index|]
operator|=
name|MOUT_IDENTIFY
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_message
operator|!=
literal|0
condition|)
block|{
name|sc_intok2
operator|=
name|Rb_FNC
operator||
name|Rb_DCNT
operator||
name|Rb_SRST
operator||
name|Rb_PHC
operator||
name|Rb_SPE
operator||
name|Rb_RMSG
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_message
operator|==
name|MSG_EXTND
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_param
index|[
literal|2
index|]
operator|==
literal|0x01
operator|)
condition|)
block|{
name|cnt
operator|=
literal|5
expr_stmt|;
name|mp
operator|=
name|sc
operator|->
name|sc_param
expr_stmt|;
name|sc
operator|->
name|sc_param
index|[
literal|3
index|]
operator|=
name|MIN_TP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_param
index|[
literal|4
index|]
operator|>
name|MAX_OFFSET_BYTES
condition|)
name|sc
operator|->
name|sc_param
index|[
literal|4
index|]
operator|=
name|MAX_OFFSET_BYTES
expr_stmt|;
name|mout_flag
index|[
name|cs
operator|->
name|chan_num
index|]
operator|=
name|MOUT_SYNC_TR
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
literal|1
expr_stmt|;
name|mp
operator|=
operator|&
name|sc
operator|->
name|sc_message
expr_stmt|;
block|}
name|SET_CNT
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
name|SET_CMD
argument_list|(
name|SCMD_TR_INFO
operator||
name|R0_TRBE
argument_list|)
expr_stmt|;
name|sc_datr
operator|=
name|sc
operator|->
name|sc_identify
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
for|for
control|(
name|iloop
operator|=
literal|1
init|;
name|iloop
operator|<
name|cnt
condition|;
name|iloop
operator|++
control|)
block|{
name|sc_datr
operator|=
operator|*
name|mp
operator|++
expr_stmt|;
name|DMAC_WAIT
expr_stmt|;
block|}
do|do
block|{
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
operator|(
name|dummy
operator|&
name|R4_MBSY
operator|)
operator|==
literal|0
condition|)
return|return;
name|dummy
operator|=
name|sc_statr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
block|}
do|while
condition|(
name|dummy
operator|&
name|R0_CIP
condition|)
do|;
name|tmp
operator|=
literal|0
expr_stmt|;
name|GET_INTR
argument_list|(
operator|&
name|tmp0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* clear interrupt */
if|if
condition|(
operator|(
name|tmp
operator|&
name|R3_FNC
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|WAIT_STATR_BITSET
argument_list|(
name|R0_MIRQ
argument_list|)
expr_stmt|;
name|GET_INTR
argument_list|(
operator|&
name|tmp0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* clear interrupt */
block|}
do|do
block|{
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
operator|(
name|dummy
operator|&
name|R4_MBSY
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
do|while
condition|(
operator|(
name|dummy
operator|&
name|R4_MREQ
operator|)
operator|==
literal|0
condition|)
do|;
name|SET_CMD
argument_list|(
name|SCMD_NGT_ATN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|WAIT_STATR_BITCLR
argument_list|(
name|R0_CIP
argument_list|)
expr_stmt|;
name|GET_INTR
argument_list|(
operator|&
name|tmp0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* clear interrupt */
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
operator|(
name|dummy
operator|&
name|R4_MREQ
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sc_mout: !REQ cmonr=%x\n"
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|print_scsi_stat
argument_list|()
expr_stmt|;
name|scsi_hardreset
argument_list|()
expr_stmt|;
return|return;
block|}
name|SET_CMD
argument_list|(
name|SCMD_TR_INFO
argument_list|)
expr_stmt|;
name|sc_datr
operator|=
operator|*
name|mp
operator|++
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
block|}
else|else
block|{
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|dummy
operator|&
name|R4_MATN
condition|)
block|{
name|SET_CMD
argument_list|(
name|SCMD_NGT_ATN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|WAIT_STATR_BITCLR
argument_list|(
name|R0_CIP
argument_list|)
expr_stmt|;
name|GET_INTR
argument_list|(
operator|&
name|tmp0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* clear interrupt */
block|}
name|iloop
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|iloop
operator|++
operator|>
name|CHECK_LOOP_CNT
condition|)
break|break;
block|}
do|while
condition|(
operator|(
name|dummy
operator|&
name|R4_MREQ
operator|)
operator|==
literal|0
condition|)
do|;
name|SET_CMD
argument_list|(
name|SCMD_TR_INFO
argument_list|)
expr_stmt|;
name|sc_datr
operator|=
name|sc
operator|->
name|sc_identify
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
block|}
block|}
else|else
block|{
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|dummy
operator|&
name|R4_MATN
condition|)
block|{
name|SET_CMD
argument_list|(
name|SCMD_NGT_ATN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|WAIT_STATR_BITCLR
argument_list|(
name|R0_CIP
argument_list|)
expr_stmt|;
name|GET_INTR
argument_list|(
operator|&
name|tmp0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* clear interrupt */
block|}
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
operator|(
name|dummy
operator|&
name|R4_MREQ
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sc_mout: !REQ cmonr=%x\n"
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|print_scsi_stat
argument_list|()
expr_stmt|;
name|scsi_hardreset
argument_list|()
expr_stmt|;
return|return;
block|}
name|SET_CMD
argument_list|(
name|SCMD_TR_INFO
argument_list|)
expr_stmt|;
name|sc_datr
operator|=
name|sc
operator|->
name|sc_message
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
block|}
block|}
comment|/*  *	SCSI status accept routine  */
name|sc_sin
argument_list|(
name|cs
argument_list|)
specifier|register
name|VOLATILE
expr|struct
name|sc_chan_stat
operator|*
name|cs
expr_stmt|;
block|{
specifier|register
name|VOLATILE
name|int
name|dummy
decl_stmt|;
specifier|register
name|int
name|iloop
decl_stmt|;
name|flush_fifo
argument_list|()
expr_stmt|;
name|dummy
operator|=
name|sc_cmonr
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
operator|(
name|dummy
operator|&
name|R4_MREQ
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sc_sin: !REQ cmonr=%x\n"
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|print_scsi_stat
argument_list|()
expr_stmt|;
name|scsi_hardreset
argument_list|()
expr_stmt|;
return|return;
block|}
name|sc_intok2
operator|=
name|Rb_FNC
operator||
name|Rb_DCNT
operator||
name|Rb_SRST
operator||
name|Rb_PHC
operator||
name|Rb_SPE
operator||
name|Rb_RMSG
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
name|SET_CMD
argument_list|(
name|SCMD_TR_INFO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|WAIT_STATR_BITCLR
argument_list|(
name|R0_CIP
argument_list|)
expr_stmt|;
name|int_stat2
operator|&=
operator|~
name|R3_FNC
expr_stmt|;
name|iloop
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|iloop
operator|++
operator|>
name|CHECK_LOOP_CNT
condition|)
break|break;
name|GET_INTR
argument_list|(
operator|&
name|int_stat1
argument_list|,
operator|&
name|int_stat2
argument_list|)
expr_stmt|;
comment|/* clear interrupt */
block|}
do|while
condition|(
operator|(
name|int_stat2
operator|&
name|R3_FNC
operator|)
operator|==
literal|0
condition|)
do|;
name|int_stat2
operator|&=
operator|~
name|R3_FNC
expr_stmt|;
name|cs
operator|->
name|sc
operator|->
name|sc_tstatus
operator|=
name|sc_datr
expr_stmt|;
comment|/* get status byte */
name|DMAC_WAIT0
expr_stmt|;
block|}
comment|/*  *	SCSI data in/out routine  */
name|sc_dio
argument_list|(
name|cs
argument_list|)
specifier|register
name|VOLATILE
expr|struct
name|sc_chan_stat
operator|*
name|cs
expr_stmt|;
block|{
specifier|register
name|VOLATILE
expr|struct
name|scsi
operator|*
name|sc
expr_stmt|;
specifier|register
name|struct
name|scsi_stat
modifier|*
name|ss
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|pages
decl_stmt|;
specifier|register
name|u_int
name|tag
decl_stmt|;
specifier|register
name|u_int
name|pfn
decl_stmt|;
name|VOLATILE
name|int
name|phase
decl_stmt|;
name|sc
operator|=
name|cs
operator|->
name|sc
expr_stmt|;
name|ss
operator|=
operator|&
name|scsi_stat
expr_stmt|;
name|sc_intok2
operator|=
name|Rb_FNC
operator||
name|Rb_DCNT
operator||
name|Rb_SRST
operator||
name|Rb_PHC
operator||
name|Rb_SPE
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|act_trcnt
operator|<=
literal|0
condition|)
block|{
name|sc_dio_pad
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|sc
operator|->
name|sc_opcode
condition|)
block|{
case|case
name|SCOP_READ
case|:
case|case
name|SCOP_WRITE
case|:
case|case
name|SCOP_EREAD
case|:
case|case
name|SCOP_EWRITE
case|:
name|i
operator|=
operator|(
name|cs
operator|->
name|act_trcnt
operator|+
name|sc
operator|->
name|sc_bytesec
operator|-
literal|1
operator|)
operator|/
name|sc
operator|->
name|sc_bytesec
expr_stmt|;
name|i
operator|*=
name|sc
operator|->
name|sc_bytesec
expr_stmt|;
break|break;
default|default:
name|i
operator|=
name|cs
operator|->
name|act_trcnt
expr_stmt|;
break|break;
block|}
name|SET_CNT
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|pad_cnt
index|[
name|cs
operator|->
name|chan_num
index|]
operator|=
name|i
operator|-
name|cs
operator|->
name|act_trcnt
expr_stmt|;
name|phase
operator|=
name|sc_cmonr
operator|&
name|SC_PMASK
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|phase
operator|==
name|DAT_IN
condition|)
block|{
if|if
condition|(
name|sc_syncr
operator|==
name|OFF
condition|)
block|{
name|DMAC_WAIT0
expr_stmt|;
name|flush_fifo
argument_list|()
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
name|SET_CMD
argument_list|(
name|SCMD_TR_INFO
operator||
name|R0_DMA
operator||
name|R0_TRBE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
name|dmac_gsel
operator|=
name|CH_SCSI
expr_stmt|;
name|dmac_ctrcl
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cs
operator|->
name|act_trcnt
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|dmac_ctrcm
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cs
operator|->
name|act_trcnt
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|dmac_ctrch
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cs
operator|->
name|act_trcnt
operator|>>
literal|16
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|dmac_cofsh
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cs
operator|->
name|act_offset
operator|>>
literal|8
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|dmac_cofsl
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cs
operator|->
name|act_offset
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_map
operator|&&
operator|(
name|sc
operator|->
name|sc_map
operator|->
name|mp_pages
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Set DMAC map entry from map table 		 */
name|pages
operator|=
name|sc
operator|->
name|sc_map
operator|->
name|mp_pages
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cs
operator|->
name|act_tag
init|;
name|i
operator|<
name|pages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pfn
operator|=
name|sc
operator|->
name|sc_map
operator|->
name|mp_addr
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"SCSI:sc_dma() zero entry"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
name|dmac_gsel
operator|=
name|CH_SCSI
expr_stmt|;
name|dmac_ctag
operator|=
operator|(
name|u_char
operator|)
name|tag
operator|++
expr_stmt|;
name|dmac_cmap
operator|=
operator|(
name|u_short
operator|)
name|pfn
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|MAP_OVER_ACCESS
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
name|dmac_gsel
operator|=
name|CH_SCSI
expr_stmt|;
name|dmac_ctag
operator|=
operator|(
name|u_char
operator|)
name|tag
operator|++
expr_stmt|;
name|dmac_cmap
operator|=
operator|(
name|u_short
operator|)
name|pfn
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * Set DMAC map entry from logical address 		 */
name|pfn
operator|=
operator|(
name|u_int
operator|)
name|vtophys
argument_list|(
name|cs
operator|->
name|act_point
argument_list|)
operator|>>
name|PGSHIFT
expr_stmt|;
name|pages
operator|=
operator|(
name|cs
operator|->
name|act_trcnt
operator|>>
name|PGSHIFT
operator|)
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pages
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
name|dmac_gsel
operator|=
name|CH_SCSI
expr_stmt|;
name|dmac_ctag
operator|=
operator|(
name|u_char
operator|)
name|tag
operator|++
expr_stmt|;
name|dmac_cmap
operator|=
operator|(
name|u_short
operator|)
name|pfn
operator|+
name|i
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
name|dmac_gsel
operator|=
name|CH_SCSI
expr_stmt|;
name|dmac_ctag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|phase
operator|==
name|DAT_IN
condition|)
block|{
name|ss
operator|->
name|dma_stat
operator|=
name|SC_DMAC_RD
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
comment|/* 		 * auto pad flag is always on 		 */
name|dmac_gsel
operator|=
name|CH_SCSI
expr_stmt|;
name|dmac_cctl
operator|=
name|DM_MODE
operator||
name|DM_APAD
expr_stmt|;
name|DMAC_WAIT
expr_stmt|;
name|dmac_cctl
operator|=
name|DM_MODE
operator||
name|DM_APAD
operator||
name|DM_ENABLE
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|phase
operator|==
name|DAT_OUT
condition|)
block|{
name|ss
operator|->
name|dma_stat
operator|=
name|SC_DMAC_WR
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
name|dmac_gsel
operator|=
name|CH_SCSI
expr_stmt|;
name|dmac_cctl
operator|=
name|DM_APAD
expr_stmt|;
name|DMAC_WAIT
expr_stmt|;
name|dmac_cctl
operator|=
name|DM_APAD
operator||
name|DM_ENABLE
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
endif|#
directive|endif
comment|/* DMAC start on mem->I/O */
block|}
block|}
define|#
directive|define
name|MAX_TR_CNT24
value|((1<< 24) -1)
name|sc_dio_pad
argument_list|(
name|cs
argument_list|)
specifier|register
name|VOLATILE
expr|struct
name|sc_chan_stat
operator|*
name|cs
expr_stmt|;
block|{
specifier|register
name|VOLATILE
name|int
name|phase
decl_stmt|;
specifier|register
name|int
name|dummy
decl_stmt|;
if|if
condition|(
name|cs
operator|->
name|act_trcnt
operator|>=
literal|0
condition|)
return|return;
name|pad_start
operator|=
literal|1
expr_stmt|;
name|SET_CNT
argument_list|(
name|MAX_TR_CNT24
argument_list|)
expr_stmt|;
name|SET_CMD
argument_list|(
name|SCMD_TR_PAD
operator||
name|R0_TRBE
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|sc_cmonr
operator|&
name|SC_PMASK
expr_stmt|;
name|DMAC_WAIT0
expr_stmt|;
if|if
condition|(
name|dummy
operator|==
name|DAT_IN
condition|)
name|dummy
operator|=
name|sc_datr
expr_stmt|;
comment|/* get data */
else|else
name|sc_datr
operator|=
literal|0
expr_stmt|;
comment|/* send data */
block|}
name|print_scsi_stat
argument_list|()
block|{
specifier|register
name|struct
name|scsi_stat
modifier|*
name|ss
decl_stmt|;
specifier|register
name|VOLATILE
name|int
name|i
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|ss
operator|=
operator|&
name|scsi_stat
expr_stmt|;
name|printf
argument_list|(
literal|"ipc=%d wrc=%d wbc=%d\n"
argument_list|,
name|ss
operator|->
name|ipc
argument_list|,
name|ss
operator|->
name|wrc
argument_list|,
name|ss
operator|->
name|wbc
argument_list|)
expr_stmt|;
block|}
comment|/*  *	return 0 if it was done.  Or retun TRUE if it is busy.  */
name|sc_busy
argument_list|(
name|chan
argument_list|)
specifier|register
name|int
name|chan
expr_stmt|;
block|{
return|return
operator|(
operator|(
name|int
operator|)
name|chan_stat
index|[
name|chan
index|]
operator|.
name|sc
operator|)
return|;
block|}
comment|/*  *	append channel into Waiting Bus_free queue  */
name|append_wb
argument_list|(
name|cs
argument_list|)
specifier|register
name|VOLATILE
expr|struct
name|sc_chan_stat
operator|*
name|cs
expr_stmt|;
block|{
specifier|register
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
comment|/* inhibit process switch */
if|if
condition|(
name|wbq_actf
operator|==
name|NULL
condition|)
name|wbq_actf
operator|=
name|cs
expr_stmt|;
else|else
name|wbq_actl
operator|->
name|wb_next
operator|=
name|cs
expr_stmt|;
name|wbq_actl
operator|=
name|cs
expr_stmt|;
name|cs
operator|->
name|sc
operator|->
name|sc_istatus
operator|=
name|INST_WAIT
expr_stmt|;
name|scsi_stat
operator|.
name|wbc
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*  *	get channel from Waiting Bus_free queue  */
name|get_wb_chan
argument_list|()
block|{
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|int
name|chan
decl_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
comment|/* inhibit process switch */
if|if
condition|(
name|wbq_actf
operator|==
name|NULL
condition|)
block|{
name|chan
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|=
name|wbq_actf
operator|->
name|chan_num
expr_stmt|;
if|if
condition|(
operator|(
name|chan
operator|<
literal|0
operator|)
operator|||
operator|(
name|chan
operator|>=
name|NTARGET
operator|)
operator|||
operator|(
name|chan
operator|==
name|SC_OWNID
operator|)
condition|)
name|chan
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|chan
operator|)
return|;
block|}
comment|/*  *	release channel from Waiting Bus_free queue  */
name|release_wb
argument_list|()
block|{
specifier|register
name|VOLATILE
expr|struct
name|sc_chan_stat
operator|*
name|cs
expr_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
comment|/* inhibit process switch */
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wbq_actf
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cs
operator|=
name|wbq_actf
expr_stmt|;
name|wbq_actf
operator|=
name|cs
operator|->
name|wb_next
expr_stmt|;
name|cs
operator|->
name|wb_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|wbq_actl
operator|==
name|cs
condition|)
name|wbq_actl
operator|=
name|NULL
expr_stmt|;
name|cs
operator|->
name|sc
operator|->
name|sc_istatus
operator|&=
operator|~
name|INST_WAIT
expr_stmt|;
name|scsi_stat
operator|.
name|wbc
operator|--
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|adjust_transfer
argument_list|(
name|cs
argument_list|)
specifier|register
expr|struct
name|sc_chan_stat
operator|*
name|cs
expr_stmt|;
block|{
specifier|register
name|struct
name|scsi
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|scsi_stat
modifier|*
name|ss
decl_stmt|;
specifier|register
name|VOLATILE
name|u_int
name|remain_cnt
decl_stmt|;
specifier|register
name|u_int
name|offset
decl_stmt|;
name|u_int
name|sent_byte
decl_stmt|;
name|sc
operator|=
name|cs
operator|->
name|sc
expr_stmt|;
name|ss
operator|=
operator|&
name|scsi_stat
expr_stmt|;
if|if
condition|(
name|pad_start
condition|)
block|{
name|pad_start
operator|=
literal|0
expr_stmt|;
name|remain_cnt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
name|remain_cnt
operator|=
name|GET_CNT
argument_list|()
expr_stmt|;
name|remain_cnt
operator|-=
name|pad_cnt
index|[
name|cs
operator|->
name|chan_num
index|]
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|dma_stat
operator|==
name|SC_DMAC_WR
condition|)
block|{
comment|/* 			 * adjust counter in the FIFO 			 */
name|remain_cnt
operator|+=
name|sc_ffstr
operator|&
name|R5_FIFOREM
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|sent_byte
operator|=
name|sc
operator|->
name|sc_ctrnscnt
operator|-
name|remain_cnt
expr_stmt|;
name|cs
operator|->
name|act_trcnt
operator|=
name|remain_cnt
expr_stmt|;
name|offset
operator|=
name|sc
operator|->
name|sc_coffset
operator|+
name|sent_byte
expr_stmt|;
name|cs
operator|->
name|act_tag
operator|+=
operator|(
name|offset
operator|>>
name|PGSHIFT
operator|)
expr_stmt|;
name|cs
operator|->
name|act_offset
operator|=
name|offset
operator|&
name|PGOFSET
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_map
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_map
operator|->
name|mp_pages
operator|<=
literal|0
operator|)
condition|)
name|cs
operator|->
name|act_point
operator|+=
name|sent_byte
expr_stmt|;
block|}
end_block

end_unit

