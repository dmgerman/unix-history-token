begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Sony Corp. and Kazumasa Utashiro of Software Research Associates, Inc.  *  * %sccs.include.redist.c%  *  * from: $Hdr: scc.c,v 4.300 91/06/09 06:44:53 root Rel41 $ SONY  *  *	@(#)scc.c	7.4 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * LH8530 SCC (serial communication controller) driver  *  * NOTE: This driver is available only for news700/1200/1700/3400.  *  * Any code and mechanism in this module may not be used  * in any form without permissions.  COPYRIGHT (C) 1989-  * SONY  Corporation,   Super Microsystems Group (SMSG),  * Work Station Division, all rights RESERVED.  */
end_comment

begin_include
include|#
directive|include
file|<machine/adrsmap.h>
end_include

begin_include
include|#
directive|include
file|"rs.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<news3400/sio/sccparam.h>
end_include

begin_include
include|#
directive|include
file|<news3400/sio/sccreg.h>
end_include

begin_include
include|#
directive|include
file|<news3400/sio/scc.h>
end_include

begin_include
include|#
directive|include
file|<news3400/sio/scc.conf>
end_include

begin_define
define|#
directive|define
name|PROBE_DATA
value|0x55
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|mips
end_ifdef

begin_define
define|#
directive|define
name|VOLATILE
value|volatile
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VOLATILE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|tty00_is_console
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SCC_BUFSIZE
value|256
end_define

begin_decl_stmt
name|char
name|scc_buf
index|[
literal|2
index|]
index|[
name|SCC_BUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|scc_open
argument_list|(
argument|chan
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splscc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|scc
operator|->
name|scc_status
operator|&
name|CHAN_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|scc_init
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|<=
name|SCC_REMOTE1
condition|)
name|scc
operator|->
name|r_dma
operator|.
name|dma_addr
operator|=
name|scc_buf
index|[
name|chan
index|]
expr_stmt|;
else|else
name|scc
operator|->
name|r_dma
operator|.
name|dma_addr
operator|=
name|malloc
argument_list|(
name|SCC_BUFSIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|scc
operator|->
name|r_dma
operator|.
name|dma_count
operator|=
literal|0
expr_stmt|;
name|scc
operator|->
name|scc_status
operator||=
name|CHAN_ACTIVE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|scc_probe
argument_list|(
name|chan
argument_list|)
specifier|register
name|int
name|chan
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|VOLATILE
name|struct
name|scc_reg
modifier|*
name|port
init|=
name|sccsw
index|[
name|chan
index|]
operator|.
name|scc_port
decl_stmt|;
name|int
name|s
decl_stmt|,
name|temp
decl_stmt|,
name|probe
decl_stmt|;
if|if
condition|(
name|badaddr
argument_list|(
name|port
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|=
name|splscc
argument_list|()
expr_stmt|;
name|temp
operator|=
name|scc_read_reg
argument_list|(
name|chan
argument_list|,
name|RR12
argument_list|)
expr_stmt|;
name|scc_write_reg
argument_list|(
name|chan
argument_list|,
name|WR12
argument_list|,
name|PROBE_DATA
argument_list|)
expr_stmt|;
name|probe
operator|=
name|scc_read_reg
argument_list|(
name|chan
argument_list|,
name|RR12
argument_list|)
expr_stmt|;
name|scc_write_reg
argument_list|(
name|chan
argument_list|,
name|WR12
argument_list|,
name|temp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|probe
operator|==
name|PROBE_DATA
operator|)
return|;
block|}
end_block

begin_macro
name|scc_getc
argument_list|(
argument|chan
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|VOLATILE
name|struct
name|scc_reg
modifier|*
name|port
init|=
name|sccsw
index|[
name|chan
index|]
operator|.
name|scc_port
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|ctrl
operator|&
name|R0_RxCA
condition|)
block|{
name|SCCWAIT
expr_stmt|;
name|c
operator|=
name|port
operator|->
name|data
expr_stmt|;
name|SCCWAIT
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|SCCWAIT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|notdef
end_ifndef

begin_macro
name|scc_putc
argument_list|(
argument|chan
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|VOLATILE
expr|struct
name|scc_reg
operator|*
name|port
operator|=
name|sccsw
index|[
name|chan
index|]
operator|.
name|scc_port
expr_stmt|;
while|while
condition|(
operator|(
name|port
operator|->
name|ctrl
operator|&
name|R0_TxBE
operator|)
operator|==
literal|0
condition|)
name|SCCWAIT
expr_stmt|;
name|SCCWAIT
expr_stmt|;
name|port
operator|->
name|data
operator|=
name|c
expr_stmt|;
name|SCCWAIT
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_macro
name|scc_putc
argument_list|(
argument|chan
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|VOLATILE
expr|struct
name|scc_reg
operator|*
name|port
operator|=
name|sccsw
index|[
name|chan
index|]
operator|.
name|scc_port
expr_stmt|;
specifier|register
name|VOLATILE
name|u_char
modifier|*
name|ctrl
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
operator|.
name|scc_port
operator|->
name|ctrl
decl_stmt|;
specifier|register
name|VOLATILE
name|u_char
modifier|*
name|data
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
operator|.
name|scc_port
operator|->
name|data
decl_stmt|;
name|SCCWAIT
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|ctrl
operator|&
name|R0_TxBE
operator|)
operator|==
literal|0
condition|)
block|{
name|SCCWAIT
expr_stmt|;
block|}
name|SCCWAIT
expr_stmt|;
operator|*
name|ctrl
operator|=
name|W0_RES_TxINT
expr_stmt|;
name|SCCWAIT
expr_stmt|;
operator|*
name|data
operator|=
call|(
name|char
call|)
argument_list|(
name|c
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|SCCWAIT
expr_stmt|;
name|scc_write_reg
argument_list|(
name|chan
argument_list|,
name|WR1
argument_list|,
name|W1_RxINT_ALL
operator||
name|W1_TxINTE
operator||
name|W1_EXTINTE
operator||
name|W1_PARITY
argument_list|)
expr_stmt|;
name|SCCWAIT
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|scc_init
argument_list|(
argument|chan
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|VOLATILE
expr|struct
name|scc_reg
operator|*
name|port
expr_stmt|;
specifier|register
name|char
modifier|*
name|data
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splscc
argument_list|()
expr_stmt|;
name|data
operator|=
name|scc
operator|->
name|scc_init
expr_stmt|;
name|port
operator|=
name|scc
operator|->
name|scc_port
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_INITDATA
condition|;
name|i
operator|++
control|)
block|{
name|port
operator|->
name|ctrl
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|SCCWAIT
expr_stmt|;
block|}
name|scc_write_reg
argument_list|(
name|chan
argument_list|,
name|WR2
argument_list|,
name|scc
operator|->
name|scc_vec
operator|&
operator|~
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* KU:XXX This must be bug because scc->scc_param is not initialized yet. 	scc_set_param(chan, scc->scc_param); */
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|vec_to_scc
parameter_list|(
name|vec
parameter_list|)
value|((((vec) - SCCVEC0)>> 3)& 0x000f)
end_define

begin_define
define|#
directive|define
name|vec_to_chan
parameter_list|(
name|vec
parameter_list|)
value|scc2chan[vec_to_scc(vec)]
end_define

begin_decl_stmt
name|int
name|scc2chan
index|[]
init|=
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|5
block|,
literal|4
block|,
literal|7
block|,
literal|6
block|,
literal|9
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|scc_rint
argument_list|(
argument|vec
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|chan
init|=
name|vec_to_chan
argument_list|(
name|vec
argument_list|)
decl_stmt|;
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
specifier|register
name|VOLATILE
expr|struct
name|scc_reg
operator|*
name|port
operator|=
name|scc
operator|->
name|scc_port
expr_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|scc
operator|->
name|scc_status
operator|&
name|CHAN_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|scc_reset
argument_list|(
name|chan
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|scc
operator|->
name|scc_status
operator|&
name|LINE_BREAK
condition|)
block|{
name|scc
operator|->
name|scc_status
operator|&=
operator|~
name|LINE_BREAK
expr_stmt|;
name|c
operator|=
name|port
operator|->
name|data
expr_stmt|;
name|SCCWAIT
expr_stmt|;
block|}
while|while
condition|(
name|port
operator|->
name|ctrl
operator|&
name|R0_RxCA
condition|)
block|{
name|SCCWAIT
expr_stmt|;
name|c
operator|=
name|port
operator|->
name|data
expr_stmt|;
name|SCCWAIT
expr_stmt|;
if|#
directive|if
name|NRS
operator|>
literal|0
name|scc_pdma
argument_list|(
name|chan
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|SCCWAIT
expr_stmt|;
name|out
label|:
name|port
operator|->
name|ctrl
operator|=
name|W0_RES_IUS
expr_stmt|;
name|SCCWAIT
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|NRS
operator|>
literal|0
end_if

begin_macro
name|scc_enable
argument_list|(
argument|chan
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splscc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|scc
operator|->
name|r_dma
operator|.
name|dma_count
operator|)
operator|>
literal|0
condition|)
block|{
name|scc
operator|->
name|r_dma
operator|.
name|dma_count
operator|=
literal|0
expr_stmt|;
name|rsrint
argument_list|(
name|chan
argument_list|,
name|scc
operator|->
name|r_dma
operator|.
name|dma_addr
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
name|scc
operator|->
name|scc_status
operator||=
name|ENABLE
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|scc_pdma
argument_list|(
argument|chan
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|scc
operator|->
name|r_dma
operator|.
name|dma_count
operator|>=
name|SCC_BUFSIZE
condition|)
name|printf
argument_list|(
literal|"rs%d soft fifo overflow\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
else|else
name|scc
operator|->
name|r_dma
operator|.
name|dma_addr
index|[
name|scc
operator|->
name|r_dma
operator|.
name|dma_count
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|scc
operator|->
name|scc_status
operator|&
name|ENABLE
operator|||
name|scc
operator|->
name|r_dma
operator|.
name|dma_count
operator|>=
name|SCC_BUFSIZE
condition|)
block|{
name|scc
operator|->
name|scc_status
operator|&=
operator|~
name|ENABLE
expr_stmt|;
name|n
operator|=
name|scc
operator|->
name|r_dma
operator|.
name|dma_count
expr_stmt|;
name|scc
operator|->
name|r_dma
operator|.
name|dma_count
operator|=
literal|0
expr_stmt|;
name|rsrint
argument_list|(
name|chan
argument_list|,
name|scc
operator|->
name|r_dma
operator|.
name|dma_addr
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NRS> 0 */
end_comment

begin_macro
name|scc_xint
argument_list|(
argument|vec
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|chan
init|=
name|vec_to_chan
argument_list|(
name|vec
argument_list|)
decl_stmt|;
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
specifier|register
name|VOLATILE
expr|struct
name|scc_reg
operator|*
name|port
operator|=
name|scc
operator|->
name|scc_port
expr_stmt|;
if|if
condition|(
name|scc
operator|->
name|scc_status
operator|&
name|OSTOP
condition|)
name|scc
operator|->
name|scc_status
operator|&=
operator|~
operator|(
name|OACTIVE
operator||
name|OSTOP
operator|)
expr_stmt|;
if|if
condition|(
name|scc
operator|->
name|scc_status
operator|&
name|OFLUSH
condition|)
block|{
name|scc
operator|->
name|x_dma
operator|.
name|dma_count
operator|=
literal|0
expr_stmt|;
name|scc
operator|->
name|scc_status
operator|&=
operator|~
operator|(
name|OACTIVE
operator||
name|OFLUSH
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scc
operator|->
name|scc_status
operator|&
name|OACTIVE
operator|)
operator|&&
operator|(
name|scc
operator|->
name|x_dma
operator|.
name|dma_count
operator|>
literal|0
operator|)
condition|)
block|{
name|port
operator|->
name|data
operator|=
operator|*
operator|(
name|scc
operator|->
name|x_dma
operator|.
name|dma_addr
operator|)
operator|++
expr_stmt|;
name|SCCWAIT
expr_stmt|;
name|scc
operator|->
name|x_dma
operator|.
name|dma_count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|port
operator|->
name|ctrl
operator|=
name|W0_RES_TxINT
expr_stmt|;
name|SCCWAIT
expr_stmt|;
name|scc
operator|->
name|scc_status
operator|&=
operator|~
name|OACTIVE
expr_stmt|;
if|#
directive|if
name|NRS
operator|>
literal|0
if|if
condition|(
name|scc
operator|->
name|x_dma
operator|.
name|dma_count
operator|==
literal|0
condition|)
name|rsxint
argument_list|(
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|port
operator|->
name|ctrl
operator|=
name|W0_RES_IUS
expr_stmt|;
name|SCCWAIT
expr_stmt|;
block|}
end_block

begin_macro
name|scc_sint
argument_list|(
argument|vec
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|chan
init|=
name|vec_to_chan
argument_list|(
name|vec
argument_list|)
decl_stmt|;
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
specifier|register
name|VOLATILE
expr|struct
name|scc_reg
operator|*
name|port
operator|=
name|scc
operator|->
name|scc_port
expr_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
specifier|register
name|int
name|param
init|=
literal|0
decl_stmt|;
name|port
operator|->
name|ctrl
operator|=
name|W0_RES_EXT
expr_stmt|;
name|SCCWAIT
expr_stmt|;
if|if
condition|(
operator|(
name|scc
operator|->
name|scc_status
operator|&
name|CHAN_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|scc_reset
argument_list|(
name|chan
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|status
operator|=
name|port
operator|->
name|ctrl
expr_stmt|;
name|SCCWAIT
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|R0_DCD
condition|)
name|param
operator||=
name|DCD
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|R0_CTS
condition|)
name|param
operator||=
name|CTS
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|R0_BREAK
condition|)
block|{
name|param
operator||=
name|RBREAK
expr_stmt|;
name|scc
operator|->
name|scc_status
operator||=
name|LINE_BREAK
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scc
operator|->
name|scc_param
operator|&
operator|(
name|DCD
operator||
name|CTS
operator||
name|RBREAK
operator|)
operator|)
operator|!=
name|param
condition|)
block|{
name|scc
operator|->
name|scc_param
operator|=
operator|(
name|scc
operator|->
name|scc_param
operator|&
operator|~
operator|(
name|DCD
operator||
name|CTS
operator||
name|RBREAK
operator|)
operator|)
operator||
name|param
expr_stmt|;
if|#
directive|if
name|NRS
operator|>
literal|0
name|rssint
argument_list|(
name|chan
argument_list|,
name|scc
operator|->
name|scc_param
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|out
label|:
name|port
operator|->
name|ctrl
operator|=
name|W0_RES_IUS
expr_stmt|;
name|SCCWAIT
expr_stmt|;
block|}
end_block

begin_macro
name|scc_cint
argument_list|(
argument|vec
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|chan
init|=
name|vec_to_chan
argument_list|(
name|vec
argument_list|)
decl_stmt|;
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
specifier|register
name|VOLATILE
expr|struct
name|scc_reg
operator|*
name|port
operator|=
name|scc
operator|->
name|scc_port
expr_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|scc
operator|->
name|scc_status
operator|&
name|CHAN_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|scc_reset
argument_list|(
name|chan
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|status
operator|=
name|scc_read_reg
argument_list|(
name|chan
argument_list|,
name|RR1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|R1_CRC
condition|)
name|scc
operator|->
name|scc_param
operator||=
name|FRAMING_ERROR
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|R1_OVRUN
condition|)
block|{
if|if
condition|(
operator|(
name|scc
operator|->
name|scc_param
operator|&
name|OVERRUN_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|scc
operator|->
name|scc_param
operator||=
name|OVERRUN_ERROR
expr_stmt|;
if|#
directive|if
name|NRS
operator|>
literal|0
name|rssint
argument_list|(
name|chan
argument_list|,
name|scc
operator|->
name|scc_param
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|status
operator|&
name|R1_PARITY
condition|)
block|{
name|scc
operator|->
name|scc_param
operator||=
name|SCC_PARITY_ERROR
expr_stmt|;
while|while
condition|(
name|port
operator|->
name|ctrl
operator|&
name|R0_RxCA
condition|)
block|{
name|SCCWAIT
expr_stmt|;
name|c
operator|=
name|port
operator|->
name|data
expr_stmt|;
name|SCCWAIT
expr_stmt|;
if|#
directive|if
name|NRS
operator|>
literal|0
if|if
condition|(
name|scc
operator|->
name|scc_param
operator|&
name|NOCHECK
condition|)
name|scc_pdma
argument_list|(
name|chan
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|SCCWAIT
expr_stmt|;
block|}
name|out
label|:
name|port
operator|->
name|ctrl
operator|=
name|W0_RES_ERROR
expr_stmt|;
name|SCCWAIT
expr_stmt|;
name|port
operator|->
name|ctrl
operator|=
name|W0_RES_IUS
expr_stmt|;
name|SCCWAIT
expr_stmt|;
block|}
end_block

begin_macro
name|scc_write_reg
argument_list|(
argument|chan
argument_list|,
argument|reg
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|,
name|reg
decl_stmt|,
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|VOLATILE
expr|struct
name|scc_reg
operator|*
name|port
operator|=
name|sccsw
index|[
name|chan
index|]
operator|.
name|scc_port
expr_stmt|;
name|port
operator|->
name|ctrl
operator|=
name|reg
expr_stmt|;
name|SCCWAIT
expr_stmt|;
name|port
operator|->
name|ctrl
operator|=
name|data
expr_stmt|;
name|SCCWAIT
expr_stmt|;
block|}
end_block

begin_macro
name|scc_read_reg
argument_list|(
argument|chan
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|,
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|VOLATILE
expr|struct
name|scc_reg
operator|*
name|port
operator|=
name|sccsw
index|[
name|chan
index|]
operator|.
name|scc_port
expr_stmt|;
name|int
name|result
decl_stmt|;
name|port
operator|->
name|ctrl
operator|=
name|reg
expr_stmt|;
name|SCCWAIT
expr_stmt|;
name|result
operator|=
name|port
operator|->
name|ctrl
expr_stmt|;
name|SCCWAIT
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|news3400
end_ifdef

begin_define
define|#
directive|define
name|DSRA
value|0x01
end_define

begin_define
define|#
directive|define
name|RIA
value|0x02
end_define

begin_define
define|#
directive|define
name|DSRB
value|0x04
end_define

begin_define
define|#
directive|define
name|RIB
value|0x08
end_define

begin_define
define|#
directive|define
name|DSRC
value|0x01
end_define

begin_define
define|#
directive|define
name|RIC
value|0x02
end_define

begin_define
define|#
directive|define
name|DSRD
value|0x04
end_define

begin_define
define|#
directive|define
name|RID
value|0x08
end_define

begin_define
define|#
directive|define
name|DSRE
value|0x10
end_define

begin_define
define|#
directive|define
name|RIE
value|0x20
end_define

begin_define
define|#
directive|define
name|DSRF
value|0x40
end_define

begin_define
define|#
directive|define
name|RIF
value|0x80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* news3400 */
end_comment

begin_struct
struct|struct
name|ri_dsr
block|{
name|char
modifier|*
name|status
decl_stmt|;
name|int
name|ri
decl_stmt|;
name|int
name|dsr
decl_stmt|;
block|}
name|ri_dsr
index|[]
init|=
block|{
block|{
operator|(
name|char
operator|*
operator|)
name|SCC_STATUS0
block|,
name|RIA
block|,
name|DSRA
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|SCC_STATUS0
block|,
name|RIB
block|,
name|DSRB
block|}
block|,
if|#
directive|if
operator|!
name|defined
argument_list|(
name|news3200
argument_list|)
block|{
operator|(
name|char
operator|*
operator|)
name|SCC_STATUS1
block|,
name|RIC
block|,
name|DSRC
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|SCC_STATUS1
block|,
name|RID
block|,
name|DSRD
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|SCC_STATUS1
block|,
name|RIE
block|,
name|DSRE
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|SCC_STATUS1
block|,
name|RIF
block|,
name|DSRF
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|SCC_STATUS2
block|,
name|RIC
block|,
name|DSRC
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|SCC_STATUS2
block|,
name|RID
block|,
name|DSRD
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|SCC_STATUS2
block|,
name|RIE
block|,
name|DSRE
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|SCC_STATUS2
block|,
name|RIF
block|,
name|DSRF
block|}
endif|#
directive|endif
comment|/* !news3200 */
block|}
struct|;
end_struct

begin_macro
name|get_ri_dsr
argument_list|(
argument|chan
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ri_dsr
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|,
name|param
decl_stmt|;
name|param
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|&
name|ri_dsr
index|[
name|chan
index|]
expr_stmt|;
name|status
operator|=
operator|*
name|p
operator|->
name|status
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|p
operator|->
name|ri
operator|)
operator|==
literal|0
condition|)
name|param
operator||=
name|RI
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|p
operator|->
name|dsr
operator|)
operator|==
literal|0
condition|)
name|param
operator||=
name|DSR
expr_stmt|;
return|return
operator|(
name|param
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|news3400
argument_list|)
end_if

begin_comment
comment|/*  *	tc0 = floor(4915200 / 32 / baudrate - 2 + 0.5);  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tc0
index|[]
init|=
block|{
literal|0
block|,
comment|/* B0 */
literal|3070
block|,
comment|/* B50 */
literal|2046
block|,
comment|/* B75 */
literal|1394
block|,
comment|/* B110 */
literal|1144
block|,
comment|/* B134 */
literal|1022
block|,
comment|/* B150 */
literal|766
block|,
comment|/* B200 */
literal|510
block|,
comment|/* B300 */
literal|254
block|,
comment|/* B600 */
literal|126
block|,
comment|/* B1200 */
literal|83
block|,
comment|/* B1800 */
literal|62
block|,
comment|/* B2400 */
literal|30
block|,
comment|/* B4800 */
literal|14
block|,
comment|/* B9600 */
literal|6
block|,
comment|/* EXTA (B19200) */
literal|2
comment|/* EXTB (B38400) */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* news3400 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tc1
index|[]
init|=
block|{
comment|/*  *	tc1 = floor(3686400 / 32 / baudrate - 2 + 0.5);  */
literal|0
block|,
comment|/* B0 */
literal|2302
block|,
comment|/* B50 */
literal|1534
block|,
comment|/* B75 */
literal|1045
block|,
comment|/* B110 */
literal|858
block|,
comment|/* B134 */
literal|766
block|,
comment|/* B150 */
literal|574
block|,
comment|/* B200 */
literal|382
block|,
comment|/* B300 */
literal|190
block|,
comment|/* B600 */
literal|94
block|,
comment|/* B1200 */
literal|62
block|,
comment|/* B1800 */
literal|46
block|,
comment|/* B2400 */
literal|22
block|,
comment|/* B4800 */
literal|10
block|,
comment|/* B9600 */
literal|4
block|,
comment|/* B19200 */
literal|1
block|,
comment|/* B38400 */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|scc_set_param
argument_list|(
argument|chan
argument_list|,
argument|param
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|param
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
specifier|register
name|int
name|bit
decl_stmt|,
name|baud
decl_stmt|,
modifier|*
name|tc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splscc
argument_list|()
expr_stmt|;
comment|/* 	 * Baud rate / external clock 	 */
if|if
condition|(
operator|(
name|baud
operator|=
name|param
operator|&
name|BAUD_RATE
operator|)
operator|==
name|EXTB
operator|&&
name|chan
operator|<=
name|SCC_REMOTE1
operator|&&
name|param
operator|&
name|EXTCLK_ENABLE
condition|)
block|{
name|scc_write_reg
argument_list|(
name|chan
argument_list|,
name|WR11
argument_list|,
name|W11_RxC_RTxC
operator||
name|W11_TxC_TRxC
argument_list|)
expr_stmt|;
name|bit
operator|=
name|W4_X1
expr_stmt|;
block|}
else|else
block|{
name|tc
operator|=
operator|(
name|chan
operator|<=
name|SCC_REMOTE1
operator|)
condition|?
name|tc0
else|:
name|tc1
expr_stmt|;
name|scc_write_reg
argument_list|(
name|chan
argument_list|,
name|WR11
argument_list|,
name|W11_RxC_BRG
operator||
name|W11_TxC_BRG
argument_list|)
expr_stmt|;
name|scc_write_reg
argument_list|(
name|chan
argument_list|,
name|WR12
argument_list|,
name|tc
index|[
name|baud
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|scc_write_reg
argument_list|(
name|chan
argument_list|,
name|WR13
argument_list|,
name|tc
index|[
name|baud
index|]
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|bit
operator|=
name|W4_X16
expr_stmt|;
block|}
comment|/* 	 * Clock mode / parity / stop bit 	 */
if|if
condition|(
name|param
operator|&
name|PARITY
condition|)
block|{
name|bit
operator||=
name|W4_PARITY
expr_stmt|;
if|if
condition|(
name|param
operator|&
name|EVEN
condition|)
name|bit
operator||=
name|W4_EVEN
expr_stmt|;
block|}
switch|switch
condition|(
name|param
operator|&
name|STOPBIT
condition|)
block|{
case|case
name|STOP1
case|:
name|bit
operator||=
name|W4_STOP1
expr_stmt|;
break|break;
case|case
name|STOP1_5
case|:
name|bit
operator||=
name|W4_STOP1_5
expr_stmt|;
break|break;
case|case
name|STOP2
case|:
name|bit
operator||=
name|W4_STOP2
expr_stmt|;
break|break;
block|}
name|scc_write_reg
argument_list|(
name|chan
argument_list|,
name|WR4
argument_list|,
name|bit
argument_list|)
expr_stmt|;
comment|/* 	 * Receiver enable / receive character size / auto enable 	 */
name|bit
operator|=
operator|(
name|param
operator|&
name|RXE
condition|?
name|W3_RxE
else|:
literal|0
operator|)
expr_stmt|;
switch|switch
condition|(
name|param
operator|&
name|CHAR_SIZE
condition|)
block|{
case|case
name|C5BIT
case|:
break|break;
case|case
name|C6BIT
case|:
name|bit
operator||=
name|W3_Rx6BIT
expr_stmt|;
break|break;
case|case
name|C7BIT
case|:
name|bit
operator||=
name|W3_Rx7BIT
expr_stmt|;
break|break;
case|case
name|C8BIT
case|:
name|bit
operator||=
name|W3_Rx8BIT
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|AUTO_ENABLE
if|if
condition|(
name|param
operator|&
name|AUTO_ENABLE
condition|)
name|bit
operator||=
name|W3_AUTO
expr_stmt|;
endif|#
directive|endif
comment|/* AUTO_ENABLE */
name|scc_write_reg
argument_list|(
name|chan
argument_list|,
name|WR3
argument_list|,
name|bit
argument_list|)
expr_stmt|;
comment|/* 	 * Transmitter enable / transmit character size / RTS / DTR / BREAK 	 */
name|bit
operator|=
operator|(
name|param
operator|&
name|TXE
condition|?
name|W5_TxE
else|:
literal|0
operator|)
expr_stmt|;
switch|switch
condition|(
name|param
operator|&
name|CHAR_SIZE
condition|)
block|{
case|case
name|C5BIT
case|:
break|break;
case|case
name|C6BIT
case|:
name|bit
operator||=
name|W5_Tx6BIT
expr_stmt|;
break|break;
case|case
name|C7BIT
case|:
name|bit
operator||=
name|W5_Tx7BIT
expr_stmt|;
break|break;
case|case
name|C8BIT
case|:
name|bit
operator||=
name|W5_Tx8BIT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|param
operator|&
name|RTS
condition|)
name|bit
operator||=
name|W5_RTS
expr_stmt|;
if|if
condition|(
name|param
operator|&
name|DTR
condition|)
name|bit
operator||=
name|W5_DTR
expr_stmt|;
if|if
condition|(
name|param
operator|&
name|XBREAK
condition|)
name|bit
operator||=
name|W5_BREAK
expr_stmt|;
name|scc_write_reg
argument_list|(
name|chan
argument_list|,
name|WR5
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|scc
operator|->
name|scc_param
operator|=
name|param
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|scc_get_param
argument_list|(
argument|chan
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
name|scc
operator|->
name|scc_param
operator|=
operator|(
name|scc
operator|->
name|scc_param
operator|&
operator|~
operator|(
name|RI
operator||
name|DSR
operator|)
operator|)
operator||
name|get_ri_dsr
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|scc
operator|->
name|scc_param
operator|)
return|;
block|}
end_block

begin_macro
name|scc_get_status
argument_list|(
argument|chan
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|sccsw
index|[
name|chan
index|]
operator|.
name|scc_status
operator|)
return|;
block|}
end_block

begin_macro
name|scc_set_status
argument_list|(
argument|chan
argument_list|,
argument|stat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|,
name|stat
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sccsw
index|[
name|chan
index|]
operator|.
name|scc_status
operator|=
name|stat
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|scc_flush
argument_list|(
argument|chan
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
if|if
condition|(
name|scc
operator|->
name|scc_status
operator|&
name|OACTIVE
condition|)
name|scc
operator|->
name|scc_status
operator||=
name|OFLUSH
expr_stmt|;
elseif|else
if|if
condition|(
name|scc
operator|->
name|x_dma
operator|.
name|dma_count
operator|>
literal|0
condition|)
block|{
name|scc
operator|->
name|x_dma
operator|.
name|dma_count
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|NRS
operator|>
literal|0
name|rsxint
argument_list|(
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|scc_start
argument_list|(
argument|chan
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|scc
operator|->
name|scc_status
operator|&
name|OACTIVE
operator|)
operator|==
literal|0
operator|&&
name|scc
operator|->
name|x_dma
operator|.
name|dma_count
operator|>
literal|0
condition|)
block|{
name|scc
operator|->
name|scc_port
operator|->
name|data
operator|=
operator|*
operator|(
name|scc
operator|->
name|x_dma
operator|.
name|dma_addr
operator|)
operator|++
expr_stmt|;
name|SCCWAIT
expr_stmt|;
name|scc
operator|->
name|x_dma
operator|.
name|dma_count
operator|--
expr_stmt|;
name|scc
operator|->
name|scc_status
operator||=
name|OACTIVE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|scc_stop
argument_list|(
argument|chan
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
if|if
condition|(
name|scc
operator|->
name|scc_status
operator|&
name|OACTIVE
condition|)
name|scc
operator|->
name|scc_status
operator||=
name|OSTOP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|scc_write
argument_list|(
argument|chan
argument_list|,
argument|buf
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|scc
operator|->
name|x_dma
operator|.
name|dma_addr
operator|=
name|buf
expr_stmt|;
name|scc
operator|->
name|x_dma
operator|.
name|dma_count
operator|=
name|count
expr_stmt|;
name|scc_start
argument_list|(
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_macro
name|scc_error_write
argument_list|(
argument|chan
argument_list|,
argument|buf
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|scc_putc
argument_list|(
name|chan
argument_list|,
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|scc_reset
argument_list|(
argument|chan
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Scc_channel
modifier|*
name|scc
init|=
operator|&
name|sccsw
index|[
name|chan
index|]
decl_stmt|;
while|while
condition|(
name|scc_getc
argument_list|(
name|chan
argument_list|)
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
name|scc
operator|->
name|scc_status
operator|&=
operator|~
name|CHAN_ACTIVE
expr_stmt|;
block|}
end_block

end_unit

