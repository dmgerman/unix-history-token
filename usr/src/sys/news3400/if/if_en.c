begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Sony Corp. and Kazumasa Utashiro of Software Research Associates, Inc.  *  * %sccs.include.redist.c%  *  * from: $Hdr: if_en.c,v 4.300 91/06/09 06:25:54 root Rel41 $ SONY  *  *	@(#)if_en.c	7.7 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"en.h"
end_include

begin_include
include|#
directive|include
file|"rawether.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NEN
operator|>
literal|0
end_if

begin_comment
comment|/*  * Interlan Ethernet Communications Controller interface  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<news3400/if/if_news.h>
end_include

begin_include
include|#
directive|include
file|<news3400/if/if_en.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_include
include|#
directive|include
file|<news3400/hbdev/hbvar.h>
end_include

begin_define
define|#
directive|define
name|iop_device
value|hb_device
end_define

begin_define
define|#
directive|define
name|iop_driver
value|hb_driver
end_define

begin_define
define|#
directive|define
name|ii_unit
value|hi_unit
end_define

begin_define
define|#
directive|define
name|ii_intr
value|hi_intr
end_define

begin_define
define|#
directive|define
name|ii_alive
value|hi_alive
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<news3400/iop/iopvar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|enprobe
argument_list|()
decl_stmt|,
name|enattach
argument_list|()
decl_stmt|,
name|enrint
argument_list|()
decl_stmt|,
name|enxint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|mbuf
modifier|*
name|m_devget
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_decl_stmt
name|struct
name|hb_device
modifier|*
name|eninfo
index|[
name|NEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hb_driver
name|endriver
init|=
block|{
name|enprobe
block|,
literal|0
block|,
name|enattach
block|,
literal|0
block|,
literal|0
block|,
literal|"en"
block|,
name|eninfo
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|iop_device
modifier|*
name|eninfo
index|[
name|NEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iop_driver
name|endriver
init|=
block|{
name|enprobe
block|,
literal|0
block|,
name|enattach
block|,
literal|0
block|,
literal|"en"
block|,
name|eninfo
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ENUNIT
parameter_list|(
name|x
parameter_list|)
value|minor(x)
end_define

begin_decl_stmt
name|int
name|eninit
argument_list|()
decl_stmt|,
name|enioctl
argument_list|()
decl_stmt|,
name|enreset
argument_list|()
decl_stmt|,
name|enwatch
argument_list|()
decl_stmt|,
name|enstart
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|endebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ether_addr
block|{
name|u_char
name|addr
index|[
literal|6
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|ifnet
name|loif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|en_softc
name|en_softc
index|[
name|NEN
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|enprobe
argument_list|(
argument|ii
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iop_device
modifier|*
name|ii
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|en_probe
argument_list|(
name|ii
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  A STATUS command is done to get the ethernet  * address and other interesting data.  */
end_comment

begin_expr_stmt
name|enattach
argument_list|(
name|ii
argument_list|)
specifier|register
expr|struct
name|iop_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|en_softc
modifier|*
name|es
init|=
operator|&
name|en_softc
index|[
name|ii
operator|->
name|ii_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|es
operator|->
name|es_if
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ether_sprintf
parameter_list|()
function_decl|;
name|en_attach
argument_list|(
name|ii
operator|->
name|ii_unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"en%d: hardware address %s\n"
argument_list|,
name|ii
operator|->
name|ii_unit
argument_list|,
name|ether_sprintf
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|es
operator|->
name|es_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|ii
operator|->
name|ii_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"en"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|eninit
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|enioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTDEF
comment|/* KU:XXX if_reset is obsolete */
name|ifp
operator|->
name|if_reset
operator|=
name|enreset
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_start
operator|=
name|enstart
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|es
operator|->
name|es_bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reset of interface after IOP reset.  */
end_comment

begin_macro
name|enreset
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|iop_device
modifier|*
name|ii
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NEN
operator|||
operator|(
name|ii
operator|=
name|eninfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ii
operator|->
name|ii_alive
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|" en%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|en_softc
index|[
name|unit
index|]
operator|.
name|es_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|en_softc
index|[
name|unit
index|]
operator|.
name|es_flags
operator|&=
operator|~
name|ENF_RUNNING
expr_stmt|;
name|eninit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialization of interface; clear recorded pending  * operations, and reinitialize IOP usage.  */
end_comment

begin_macro
name|eninit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|en_softc
modifier|*
name|es
init|=
operator|&
name|en_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|es
operator|->
name|es_if
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* not yet, if address still unknown */
if|if
condition|(
name|ifp
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
if|if
condition|(
name|es
operator|->
name|es_flags
operator|&
name|ENF_RUNNING
condition|)
return|return;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|if_newsinit
argument_list|(
operator|&
name|es
operator|->
name|es_ifnews
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|en_rheader
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|btoc
argument_list|(
name|ETHERMTU
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"en%d: can't initialize\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|es
operator|->
name|es_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_watchdog
operator|=
name|enwatch
expr_stmt|;
name|es
operator|->
name|es_interval
operator|=
name|ENWATCHINTERVAL
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
name|es
operator|->
name|es_interval
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|en_init
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|es
operator|->
name|es_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
operator||
name|IFF_NOTRAILERS
expr_stmt|;
name|es
operator|->
name|es_flags
operator||=
name|ENF_RUNNING
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start output on interface.  * Get another datagram to send off of the interface queue,  * and map it to the interface before starting the output.  */
end_comment

begin_expr_stmt
name|enstart
argument_list|(
name|ifp
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|unit
init|=
name|ifp
operator|->
name|if_unit
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|struct
name|en_softc
modifier|*
name|es
init|=
operator|&
name|en_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|s
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|es
operator|->
name|es_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|CPU_SINGLE
name|es
operator|->
name|es_ifnews
operator|.
name|ifn_waddr
operator|=
operator|(
name|caddr_t
operator|)
name|get_xmit_buffer
argument_list|(
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|if_wnewsput
argument_list|(
operator|&
name|es
operator|->
name|es_ifnews
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure minimum packet length. 	 * This makes the safe assumtion that there are no virtual holes 	 * after the data. 	 * For security, it might be wise to zero out the added bytes, 	 * but we're mainly interested in speed at the moment. 	 */
if|if
condition|(
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|<
name|ETHERMIN
condition|)
name|len
operator|=
name|ETHERMIN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
comment|/* KU:XXX should be gone */
name|en_start
argument_list|(
name|unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|es
operator|->
name|es_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* KU:XXX */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * If bpf is listening on this interface, let it 	 * see the packet before we commit it to the wire. 	 */
if|if
condition|(
name|es
operator|->
name|es_bpf
condition|)
block|{
ifdef|#
directive|ifdef
name|CPU_SINGLE
name|bpf_tap
argument_list|(
name|es
operator|->
name|es_bpf
argument_list|,
name|es
operator|->
name|es_ifnews
operator|.
name|ifn_waddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
name|bpf_mtap
argument_list|(
name|es
operator|->
name|es_bpf
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* NBPFILTER> 0 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Transmit done interrupt.  */
end_comment

begin_macro
name|_enxint
argument_list|(
argument|unit
argument_list|,
argument|error
argument_list|,
argument|collision
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|error
decl_stmt|,
name|collision
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|en_softc
modifier|*
name|es
init|=
operator|&
name|en_softc
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* KU:XXX */
name|intrcnt
index|[
name|INTR_ETHER0
operator|+
name|unit
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|es
operator|->
name|es_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"en%d: stray xmit interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|es
operator|->
name|es_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|es
operator|->
name|es_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|es
operator|->
name|es_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|collision
condition|)
name|es
operator|->
name|es_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
name|enstart
argument_list|(
operator|&
name|es
operator|->
name|es_if
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  * If input error just drop packet.  * Otherwise purge input buffered data path and examine   * packet to determine type.  If can't determine length  * from type, then have to drop packet.  Othewise decapsulate  * packet based on type and pass to type specific higher-level  * input routine.  */
end_comment

begin_macro
name|_enrint
argument_list|(
argument|unit
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|en_softc
modifier|*
name|es
init|=
operator|&
name|en_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|en_rheader
modifier|*
name|en
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|,
name|resid
decl_stmt|,
name|s
decl_stmt|;
name|int
name|type
decl_stmt|;
specifier|register
name|struct
name|ensw
modifier|*
name|esp
decl_stmt|;
specifier|extern
name|struct
name|mbuf
modifier|*
name|if_rnewsget
parameter_list|()
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
name|int
name|bxcopy
parameter_list|()
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notyet
comment|/* KU:XXX */
name|intrcnt
index|[
name|INTR_ETHER0
operator|+
name|unit
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|es
operator|->
name|es_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|es
operator|->
name|es_flags
operator|&
name|ENF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|en
operator|=
operator|(
expr|struct
name|en_rheader
operator|*
operator|)
operator|(
name|es
operator|->
name|es_ifnews
operator|.
name|ifn_raddr
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|ETHERMIN
operator|||
name|len
operator|>
name|ETHERMTU
condition|)
block|{
name|es
operator|->
name|es_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Check if there's a bpf filter listening on this interface. 	 * If so, hand off the raw packet to enet. 	 */
if|if
condition|(
name|es
operator|->
name|es_bpf
condition|)
block|{
name|bpf_tap
argument_list|(
name|es
operator|->
name|es_bpf
argument_list|,
name|es
operator|->
name|es_ifnews
operator|.
name|ifn_raddr
argument_list|,
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|en_rheader
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Note that the interface cannot be in promiscuous mode if 		 * there are no bpf listeners.	And if we are in promiscuous 		 * mode, we have to check if this packet is really ours. 		 * 		 * XXX This test does not support multicasts. 		 */
if|if
condition|(
operator|(
name|es
operator|->
name|es_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|bcmp
argument_list|(
name|en
operator|->
name|enr_dhost
argument_list|,
name|es
operator|->
name|es_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|en
operator|->
name|enr_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|bcmp
argument_list|(
name|en
operator|->
name|enr_dhost
argument_list|,
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|en
operator|->
name|enr_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* NBPFILTER> 0 */
comment|/* 	 * Deal with trailer protocol: if type is trailer type 	 * get true type from first 16-bit word past data. 	 * Remember that type was trailer by setting off. 	 */
name|en
operator|->
name|enr_type
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|en
operator|->
name|enr_type
argument_list|)
expr_stmt|;
define|#
directive|define
name|endataaddr
parameter_list|(
name|en
parameter_list|,
name|off
parameter_list|,
name|type
parameter_list|)
value|((type)(((caddr_t)((en)+1)+(off))))
if|if
condition|(
name|en
operator|->
name|enr_type
operator|>=
name|ETHERTYPE_TRAIL
operator|&&
name|en
operator|->
name|enr_type
operator|<
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
condition|)
block|{
name|off
operator|=
operator|(
name|en
operator|->
name|enr_type
operator|-
name|ETHERTYPE_TRAIL
operator|)
operator|*
literal|512
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|ETHERMTU
condition|)
return|return;
name|en
operator|->
name|enr_type
operator|=
name|ntohs
argument_list|(
operator|*
name|endataaddr
argument_list|(
name|en
argument_list|,
name|off
argument_list|,
name|u_short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|resid
operator|=
name|ntohs
argument_list|(
operator|*
operator|(
name|endataaddr
argument_list|(
name|en
argument_list|,
name|off
operator|+
literal|2
argument_list|,
name|u_short
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|resid
operator|>
name|len
condition|)
return|return;
name|len
operator|=
name|off
operator|+
name|resid
expr_stmt|;
block|}
else|else
name|off
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Pull packet off interface.  Off is nonzero if packet 	 * has trailing header; m_devget will then force this header 	 * information to be at the front, but we still have to drop 	 * the type and length which are at the front of any trailer data. 	 * KU:XXX really? 	 */
name|type
operator|=
name|en
operator|->
name|enr_type
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
name|m
operator|=
name|m_devget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|en
operator|+
literal|1
operator|)
argument_list|,
name|len
argument_list|,
name|off
argument_list|,
operator|&
name|es
operator|->
name|es_if
argument_list|,
name|bxcopy
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|=
name|m_devget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|en
operator|+
literal|1
operator|)
argument_list|,
name|len
argument_list|,
name|off
argument_list|,
operator|&
name|es
operator|->
name|es_if
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|ether_input
argument_list|(
operator|&
name|es
operator|->
name|es_if
argument_list|,
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|en
operator|->
name|enr_dhost
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Watchdog routine, request statistics from board.  */
end_comment

begin_macro
name|enwatch
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|en_softc
modifier|*
name|es
init|=
operator|&
name|en_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|es
operator|->
name|es_if
decl_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
name|es
operator|->
name|es_interval
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_expr_stmt
name|enioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|struct
name|en_softc
modifier|*
name|es
init|=
operator|&
name|en_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ensw
modifier|*
name|esp
decl_stmt|;
specifier|register
name|int
name|family
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|eninit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|es
operator|->
name|es_flags
operator|&
name|ENF_RUNNING
condition|)
block|{
name|es
operator|->
name|es_flags
operator|&=
operator|~
name|ENF_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|es
operator|->
name|es_flags
operator|&
name|ENF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|eninit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|en_prom_mode
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|,
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * set ethernet address for unit  */
end_comment

begin_macro
name|ensetaddr
argument_list|(
argument|physaddr
argument_list|,
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|physaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|en_softc
modifier|*
name|es
init|=
operator|&
name|en_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|es
operator|->
name|es_flags
operator|&
name|ENF_RUNNING
operator|)
condition|)
return|return;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|physaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|es
operator|->
name|es_addr
argument_list|,
sizeof|sizeof
name|es
operator|->
name|es_addr
argument_list|)
expr_stmt|;
name|es
operator|->
name|es_flags
operator|&=
operator|~
name|ENF_RUNNING
expr_stmt|;
name|es
operator|->
name|es_flags
operator||=
name|ENF_SETADDR
expr_stmt|;
name|eninit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Machine dependent functions  *  *	en_probe();  *	en_attach();  *	en_init();  *	enxint();  *	enrint();  *	en_prom_mode()  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_macro
name|en_probe
argument_list|(
argument|hi
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hb_device
modifier|*
name|hi
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|lance_probe
argument_list|(
name|hi
operator|->
name|hi_unit
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|en_attach
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|en_softc
modifier|*
name|es
init|=
operator|&
name|en_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
extern|extern lance_intr(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|news700
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|mips
argument_list|)
end_if

begin_expr_stmt
name|register_hb_intr4
argument_list|(
name|lance_intr
argument_list|,
name|unit
argument_list|,
name|eninfo
index|[
name|unit
index|]
operator|->
name|ii_intr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|lance_open
argument_list|(
name|unit
argument_list|)
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"lance initialize error\n"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|lance_get_addr
argument_list|(
name|unit
argument_list|,
operator|(
name|caddr_t
operator|)
name|es
operator|->
name|es_addr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  en_init
operator|(
name|unit
operator|)
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{  }
end_block

begin_macro
name|en_start
argument_list|(
argument|unit
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lance_transmit
argument_list|(
name|unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|enxint
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|_enxint
argument_list|(
name|unit
argument_list|,
name|lance_xmit_error
argument_list|(
name|unit
argument_list|)
argument_list|,
name|lance_collision
argument_list|(
name|unit
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|enrint
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|en_softc
modifier|*
name|es
init|=
operator|&
name|en_softc
index|[
name|unit
index|]
decl_stmt|;
name|caddr_t
name|get_recv_buffer
parameter_list|()
function_decl|;
while|while
condition|(
name|es
operator|->
name|es_ifnews
operator|.
name|ifn_raddr
operator|=
name|get_recv_buffer
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|_enrint
argument_list|(
name|unit
argument_list|,
name|get_recv_length
argument_list|(
name|unit
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|en_rheader
argument_list|)
argument_list|)
expr_stmt|;
name|free_recv_buffer
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|en_prom_mode
argument_list|(
argument|unit
argument_list|,
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lance_prom_mode
argument_list|(
name|unit
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPU_SINGLE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IPC_MRX
end_ifdef

begin_include
include|#
directive|include
file|"../ipc/newsipc.h"
end_include

begin_include
include|#
directive|include
file|"../mrx/h/lancereg.h"
end_include

begin_include
include|#
directive|include
file|"../mrx/h/lance.h"
end_include

begin_decl_stmt
name|int
name|port_enxmit
index|[
name|NEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port_enrecv
index|[
name|NEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port_enctrl
index|[
name|NEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port_enxmit_iop
index|[
name|NEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port_enrecv_iop
index|[
name|NEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|port_enctrl_iop
index|[
name|NEN
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|en_probe
argument_list|(
name|ii
argument_list|)
specifier|register
expr|struct
name|iop_device
operator|*
name|ii
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|unit
init|=
name|ii
operator|->
name|ii_unit
decl_stmt|;
name|int
name|lance_func
decl_stmt|,
modifier|*
name|reply
decl_stmt|;
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|make_name
parameter_list|()
function_decl|;
if|if
condition|(
name|port_enrecv
index|[
name|unit
index|]
operator|==
literal|0
condition|)
block|{
define|#
directive|define
name|PT_CREATE
parameter_list|(
name|buf
parameter_list|,
name|name
parameter_list|,
name|unit
parameter_list|,
name|func
parameter_list|)
define|\
value|port_create(make_name(buf, name, unit), func, unit)
define|#
directive|define
name|OB_QUERY
parameter_list|(
name|buf
parameter_list|,
name|name
parameter_list|,
name|unit
parameter_list|)
define|\
value|object_query(make_name(buf, name, unit))
name|make_name
argument_list|(
name|name
argument_list|,
literal|"@enrecvX"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|port_enrecv
index|[
name|unit
index|]
operator|=
name|PT_CREATE
argument_list|(
name|name
argument_list|,
literal|"@enrecvX"
argument_list|,
name|unit
argument_list|,
name|enrint
argument_list|)
expr_stmt|;
name|port_enxmit
index|[
name|unit
index|]
operator|=
name|PT_CREATE
argument_list|(
name|name
argument_list|,
literal|"@enxmitX"
argument_list|,
name|unit
argument_list|,
name|enxint
argument_list|)
expr_stmt|;
name|port_enctrl
index|[
name|unit
index|]
operator|=
name|PT_CREATE
argument_list|(
name|name
argument_list|,
literal|"@enctrlX"
argument_list|,
name|unit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* use NULL action port */
name|port_enrecv_iop
index|[
name|unit
index|]
operator|=
name|OB_QUERY
argument_list|(
name|name
argument_list|,
literal|"lance_inputX"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|port_enxmit_iop
index|[
name|unit
index|]
operator|=
name|OB_QUERY
argument_list|(
name|name
argument_list|,
literal|"lance_outputX"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|port_enctrl_iop
index|[
name|unit
index|]
operator|=
name|OB_QUERY
argument_list|(
name|name
argument_list|,
literal|"lance_ctrlX"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port_enctrl_iop
index|[
name|unit
index|]
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
name|lance_func
operator|=
name|EN_START
expr_stmt|;
name|msg_send
argument_list|(
name|port_enctrl_iop
index|[
name|unit
index|]
argument_list|,
name|port_enctrl
index|[
name|unit
index|]
argument_list|,
operator|&
name|lance_func
argument_list|,
sizeof|sizeof
argument_list|(
name|lance_func
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msg_recv
argument_list|(
name|port_enctrl
index|[
name|unit
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|reply
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|reply
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
name|lance_func
operator|=
name|EN_STOP
expr_stmt|;
name|msg_send
argument_list|(
name|port_enctrl_iop
index|[
name|unit
index|]
argument_list|,
name|port_enctrl
index|[
name|unit
index|]
argument_list|,
operator|&
name|lance_func
argument_list|,
sizeof|sizeof
argument_list|(
name|lance_func
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msg_recv
argument_list|(
name|port_enctrl
index|[
name|unit
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|reply
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|bad
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|en_attach
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|en_softc
modifier|*
name|es
init|=
operator|&
name|en_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|lance_func
decl_stmt|;
name|struct
name|ether_addr
modifier|*
name|ether_addr
decl_stmt|;
name|lance_func
operator|=
name|EN_GETADDR
expr_stmt|;
name|msg_send
argument_list|(
name|port_enctrl_iop
index|[
name|unit
index|]
argument_list|,
name|port_enctrl
index|[
name|unit
index|]
argument_list|,
operator|&
name|lance_func
argument_list|,
sizeof|sizeof
argument_list|(
name|lance_func
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msg_recv
argument_list|(
name|port_enctrl
index|[
name|unit
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|ether_addr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ether_addr
argument_list|,
name|es
operator|->
name|es_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_addr
argument_list|)
argument_list|)
expr_stmt|;
name|msg_free
argument_list|(
name|port_enctrl
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|en_init
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|en_softc
modifier|*
name|es
init|=
operator|&
name|en_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|port
decl_stmt|;
name|struct
name|lance_ctrl_req
name|req
decl_stmt|;
name|int
modifier|*
name|reply
decl_stmt|;
name|req
operator|.
name|lance_func
operator|=
name|EN_SETXMITBUF
expr_stmt|;
name|mapsetup
argument_list|(
operator|&
name|req
operator|.
name|lance_map
argument_list|,
name|es
operator|->
name|es_ifnews
operator|.
name|ifn_waddr
argument_list|,
name|ETHERMTU
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|en_rheader
argument_list|)
argument_list|)
expr_stmt|;
name|msg_send
argument_list|(
name|port_enctrl_iop
index|[
name|unit
index|]
argument_list|,
name|port_enctrl
index|[
name|unit
index|]
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msg_recv
argument_list|(
name|port_enctrl
index|[
name|unit
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|reply
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|lance_func
operator|=
name|EN_START
expr_stmt|;
name|msg_send
argument_list|(
name|port_enctrl_iop
index|[
name|unit
index|]
argument_list|,
name|port_enctrl
index|[
name|unit
index|]
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msg_recv
argument_list|(
name|port_enctrl
index|[
name|unit
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|reply
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msg_free
argument_list|(
name|port_enctrl
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|msg_send
argument_list|(
name|port_enrecv_iop
index|[
name|unit
index|]
argument_list|,
name|port_enrecv
index|[
name|unit
index|]
argument_list|,
name|es
operator|->
name|es_ifnews
operator|.
name|ifn_raddr
argument_list|,
name|ETHERMTU
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|en_rheader
argument_list|)
argument_list|,
name|MSG_INDIRECT
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|en_start
argument_list|(
argument|unit
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|msg_send
argument_list|(
name|port_enxmit_iop
index|[
name|unit
index|]
argument_list|,
name|port_enxmit
index|[
name|unit
index|]
argument_list|,
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|enxint
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
modifier|*
name|len
decl_stmt|;
name|struct
name|en_softc
modifier|*
name|es
init|=
operator|&
name|en_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|msg_recv
argument_list|(
name|port_enxmit
index|[
name|unit
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"stray enxint\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|es
operator|->
name|es_ifnews
operator|.
name|ifn_mbuf
condition|)
name|m_freem
argument_list|(
name|es
operator|->
name|es_ifnews
operator|.
name|ifn_mbuf
argument_list|)
expr_stmt|;
name|_enxint
argument_list|(
name|unit
argument_list|,
operator|*
name|len
operator|<
literal|0
argument_list|,
operator|*
name|len
operator|&
literal|0x10000
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|enrint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|int
modifier|*
name|reply
decl_stmt|;
if|if
condition|(
name|msg_recv
argument_list|(
name|port_enrecv
index|[
name|unit
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|reply
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"stray enrint\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
operator|*
name|reply
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|en_rheader
argument_list|)
expr_stmt|;
name|msg_free
argument_list|(
name|port_enrecv
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|mips
comment|/* 	 * cache flush address must aligned long word boundary. 	 * so, add 3 for sanity. 	 */
name|clean_k2dcache
argument_list|(
operator|(
name|int
operator|)
name|en_softc
index|[
name|unit
index|]
operator|.
name|es_ifnews
operator|.
name|ifn_raddr
operator|&
operator|~
literal|03
argument_list|,
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|en_rheader
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_enrint
argument_list|(
name|unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|msg_send
argument_list|(
name|port_enrecv_iop
index|[
name|unit
index|]
argument_list|,
name|port_enrecv
index|[
name|unit
index|]
argument_list|,
name|en_softc
index|[
name|unit
index|]
operator|.
name|es_ifnews
operator|.
name|ifn_raddr
argument_list|,
name|ETHERMTU
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|en_rheader
argument_list|)
argument_list|,
name|MSG_INDIRECT
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|en_prom_mode
argument_list|(
argument|unit
argument_list|,
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|port
decl_stmt|;
name|struct
name|lance_ctrl_req
name|req
decl_stmt|;
specifier|extern
name|int
name|port_enctrl_iop
index|[]
decl_stmt|;
name|req
operator|.
name|lance_func
operator|=
name|EN_PROMMODE
expr_stmt|;
name|req
operator|.
name|lance_mode
operator|=
name|mode
expr_stmt|;
name|msg_send
argument_list|(
name|port_enctrl_iop
index|[
name|unit
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPC_MRX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEN> 0 */
end_comment

end_unit

