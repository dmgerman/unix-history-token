begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Sony Corp. and Kazumasa Utashiro of Software Research Associates, Inc.  *  * %sccs.include.redist.c%  *  * from: $Hdr: vt100.c,v 4.300 91/06/09 06:14:56 root Rel41 $ SONY  *  *	@(#)vt100.c	7.5 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<news3400/iop/framebuf.h>
end_include

begin_include
include|#
directive|include
file|<news3400/iop/kbreg.h>
end_include

begin_include
include|#
directive|include
file|<news3400/iop/keyboard.h>
end_include

begin_include
include|#
directive|include
file|<news3400/fb/fbdefs.h>
end_include

begin_include
include|#
directive|include
file|<news3400/bm/vt100.h>
end_include

begin_include
include|#
directive|include
file|<news3400/bm/bitmapif.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPC_MRX
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_define
define|#
directive|define
name|kbd_ioctl
parameter_list|(
name|chan
parameter_list|,
name|cmd
parameter_list|,
name|argp
parameter_list|)
value|{ \ 	if (kb_ioctl) \ 		(*kb_ioctl)(chan, cmd, argp); \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPC_MRX
end_ifdef

begin_include
include|#
directive|include
file|"mrx.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"console.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_include
include|#
directive|include
file|<news3400/sio/scc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|Key_string
name|key_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|first_code
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPC_MRX
end_ifdef

begin_define
define|#
directive|define
name|SCC_KEYBOARD
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|SCREEN
name|screen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cursor
name|inner_buf_csr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inner_buf_tstat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|c_pos_mess
index|[
name|C_MESS_SIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|csr_buf
name|local_csr_buf
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPC_MRX
end_ifdef

begin_decl_stmt
name|int
name|bitmap_use
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPC_3CPU
end_ifdef

begin_include
include|#
directive|include
file|"../../ubdev/msgio.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|ipc_ready
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPC_3CPU */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|cons_devsw
name|vt100_cons
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPC_MRX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_DOUBLE
end_ifdef

begin_function_decl
name|int
name|auto_dimmer
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CPU_SINGLE
end_if

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern kbd_profun_init(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|lRectangle
name|char_r1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lRectangle
name|font_r1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lRectangle
name|char_r2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lRectangle
name|font_r2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|font_len1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|font_len2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fcolor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bcolor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|font_w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|font_h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|char_w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|char_h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scr_w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scr_h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ch_pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ul_pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x_ofst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y_ofst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rit_m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|btm_m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bell_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dim_cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a_dim_on
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|fbuf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fpn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lPoint
name|fpp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fpa
decl_stmt|;
end_decl_stmt

begin_macro
name|vt100init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|SCREEN
modifier|*
name|sp
init|=
operator|&
name|screen
decl_stmt|;
name|sp
operator|->
name|s_term_mode
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|s_term_mode
operator||=
operator|(
name|SRM
operator||
name|DECSCLM
operator||
name|DECAWM
operator||
name|DECARM
operator||
name|DECCSR_ACTV
operator|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|x
operator|=
name|x_ofst
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|y
operator|=
name|y_ofst
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_attributes
operator|=
name|NORMALM
expr_stmt|;
name|sp
operator|->
name|s_region
operator|.
name|top_margin
operator|=
name|TOP_M
expr_stmt|;
name|sp
operator|->
name|s_region
operator|.
name|btm_margin
operator|=
name|btm_m
expr_stmt|;
name|sp
operator|->
name|s_plane
operator|=
name|consfb
operator|->
name|planemask
expr_stmt|;
name|sp
operator|->
name|s_bgcol
operator|=
literal|0
expr_stmt|;
name|fcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RIT_M_MAX
condition|;
name|i
operator|++
control|)
name|sp
operator|->
name|s_tab_pos
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|<
name|RIT_M_MAX
condition|;
name|i
operator|+=
literal|8
control|)
name|sp
operator|->
name|s_tab_pos
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|esc_store_csr
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|inner_buf_tstat
operator|=
name|sp
operator|->
name|s_term_mode
operator|&
operator|(
name|DECOM
operator||
name|DECAWM
operator|)
expr_stmt|;
name|local_csr_buf
operator|.
name|csr_number
operator|=
literal|1
expr_stmt|;
name|cursor_on
argument_list|(
operator|&
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ncp_str
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|p
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  default parameter set  */
end_comment

begin_macro
name|set_default_param
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|fbdev
modifier|*
name|cfb
init|=
name|consfb
decl_stmt|;
name|font_w
operator|=
name|cfb
operator|->
name|font_w
expr_stmt|;
name|font_h
operator|=
name|cfb
operator|->
name|font_h
expr_stmt|;
name|char_w
operator|=
name|cfb
operator|->
name|char_w
expr_stmt|;
name|char_h
operator|=
name|cfb
operator|->
name|char_h
expr_stmt|;
name|scr_w
operator|=
name|cfb
operator|->
name|scr_w
expr_stmt|;
name|scr_h
operator|=
name|cfb
operator|->
name|scr_h
expr_stmt|;
name|ch_pos
operator|=
name|cfb
operator|->
name|ch_pos
expr_stmt|;
name|ul_pos
operator|=
name|cfb
operator|->
name|ul_pos
expr_stmt|;
name|x_ofst
operator|=
name|cfb
operator|->
name|x_offset
expr_stmt|;
name|y_ofst
operator|=
name|cfb
operator|->
name|y_offset
expr_stmt|;
name|rit_m
operator|=
name|cfb
operator|->
name|rit_m
expr_stmt|;
name|btm_m
operator|=
name|cfb
operator|->
name|btm_m
expr_stmt|;
name|a_dim_on
operator|=
literal|1
expr_stmt|;
name|font_r1
operator|.
name|extent
operator|.
name|x
operator|=
name|font_w
expr_stmt|;
name|font_r1
operator|.
name|extent
operator|.
name|y
operator|=
name|font_h
expr_stmt|;
name|font_r2
operator|.
name|extent
operator|.
name|x
operator|=
name|font_w
operator|*
literal|2
expr_stmt|;
name|font_r2
operator|.
name|extent
operator|.
name|y
operator|=
name|font_h
expr_stmt|;
name|font_len1
operator|=
operator|(
name|font_w
operator|+
literal|0x0f
operator|)
operator|>>
literal|4
expr_stmt|;
name|font_len2
operator|=
operator|(
name|font_w
operator|*
literal|2
operator|+
literal|0x0f
operator|)
operator|>>
literal|4
expr_stmt|;
name|char_r1
operator|.
name|extent
operator|.
name|x
operator|=
name|char_w
expr_stmt|;
name|char_r1
operator|.
name|extent
operator|.
name|y
operator|=
name|char_h
expr_stmt|;
name|char_r2
operator|.
name|extent
operator|.
name|x
operator|=
name|char_w
operator|*
literal|2
expr_stmt|;
name|char_r2
operator|.
name|extent
operator|.
name|y
operator|=
name|char_h
expr_stmt|;
name|dim_cnt
operator|=
name|DIM_CNT_DFLT
expr_stmt|;
name|bell_len
operator|=
name|BELL_LEN_DFLT
expr_stmt|;
block|}
end_block

begin_macro
name|vt100_open
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|only_one
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|ext_fnt_addr
decl_stmt|;
name|set_default_param
argument_list|()
expr_stmt|;
name|vt100init
argument_list|()
expr_stmt|;
name|bitmapinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|only_one
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|IPC_MRX
ifdef|#
directive|ifdef
name|IPC_3CPU
while|while
condition|(
name|ipc_ready
operator|==
literal|0
condition|)
name|proc_sleep_self
argument_list|(
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|bitmap_use
operator|=
name|object_query
argument_list|(
name|BITMAP
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|proc_sleep_self
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|proc_create
argument_list|(
literal|"auto_dimmer"
argument_list|,
name|auto_dimmer
argument_list|,
literal|401
argument_list|,
literal|512
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IPC_MRX */
name|only_one
operator|=
literal|1
expr_stmt|;
block|}
define|#
directive|define
name|INIT_STRING
value|"\033[42;1H"
name|vt100_write
argument_list|(
literal|0
argument_list|,
name|INIT_STRING
argument_list|,
sizeof|sizeof
argument_list|(
name|INIT_STRING
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CPU_SINGLE
name|kbd_open
argument_list|(
name|SCC_KEYBOARD
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|IPC_MRX
end_ifdef

begin_macro
name|vt100_cons_setup
argument_list|()
end_macro

begin_block
block|{
name|int
name|vt100_open
argument_list|()
decl_stmt|,
name|vt100_read
argument_list|()
decl_stmt|,
name|vt100_write
argument_list|()
decl_stmt|,
name|vt100_ioctl
argument_list|()
decl_stmt|;
name|vt100_cons
operator|.
name|open
operator|=
name|vt100_open
expr_stmt|;
name|vt100_cons
operator|.
name|read
operator|=
name|vt100_read
expr_stmt|;
name|vt100_cons
operator|.
name|write
operator|=
name|vt100_write
expr_stmt|;
name|vt100_cons
operator|.
name|ioctl
operator|=
name|vt100_ioctl
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|DIMMER_RESET
value|0
end_define

begin_define
define|#
directive|define
name|DIMMER_ON
value|1
end_define

begin_define
define|#
directive|define
name|DIMMER_OFF
value|2
end_define

begin_define
define|#
directive|define
name|DIMMER_INTERVAL
value|60
end_define

begin_comment
comment|/* sec */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dimmer_stdport
decl_stmt|;
end_decl_stmt

begin_macro
name|auto_dimmer
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|select
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|int
name|dimm_counter
init|=
name|DIM_CNT_DFLT
decl_stmt|;
specifier|register
name|int
name|dimm_level
init|=
literal|0
decl_stmt|;
name|int
name|ports
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|mode
decl_stmt|;
name|spl0
argument_list|()
expr_stmt|;
name|ports
index|[
literal|0
index|]
operator|=
name|dimmer_stdport
operator|=
name|STDPORT
expr_stmt|;
name|ports
index|[
literal|1
index|]
operator|=
name|port_create
argument_list|(
literal|"auto_dimmer_sub"
argument_list|)
expr_stmt|;
name|register_interval
argument_list|(
name|ports
index|[
literal|1
index|]
argument_list|,
name|DIMMER_INTERVAL
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|select
operator|=
name|msg_select
argument_list|(
literal|2
argument_list|,
name|ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
operator|==
literal|0
condition|)
block|{
name|msg_recv
argument_list|(
name|ports
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|mode
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|mode
condition|)
block|{
case|case
name|DIMMER_RESET
case|:
if|if
condition|(
operator|!
name|a_dim_on
condition|)
break|break;
name|dimm_counter
operator|=
name|dim_cnt
expr_stmt|;
if|if
condition|(
name|dimm_level
operator|>
literal|0
condition|)
block|{
name|dimm_level
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfbdev
condition|;
name|i
operator|++
control|)
name|fbbm_set_dimmer
argument_list|(
operator|&
name|fbdev
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIMMER_ON
case|:
name|dimm_counter
operator|=
name|dim_cnt
expr_stmt|;
name|dimm_level
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfbdev
condition|;
name|i
operator|++
control|)
name|fbbm_set_dimmer
argument_list|(
operator|&
name|fbdev
index|[
name|i
index|]
argument_list|,
name|dimm_level
argument_list|)
expr_stmt|;
name|a_dim_on
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DIMMER_OFF
case|:
name|dimm_counter
operator|=
name|dim_cnt
expr_stmt|;
name|dimm_level
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfbdev
condition|;
name|i
operator|++
control|)
name|fbbm_set_dimmer
argument_list|(
operator|&
name|fbdev
index|[
name|i
index|]
argument_list|,
name|dimm_level
argument_list|)
expr_stmt|;
name|a_dim_on
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|msg_recv
argument_list|(
name|ports
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_dim_on
operator|&&
operator|(
name|dimm_counter
operator|--
operator|<=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|dimm_level
operator|<
literal|3
condition|)
block|{
name|dimm_level
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfbdev
condition|;
name|i
operator|++
control|)
name|fbbm_set_dimmer
argument_list|(
operator|&
name|fbdev
index|[
name|i
index|]
argument_list|,
name|dimm_level
argument_list|)
expr_stmt|;
name|dimm_counter
operator|=
name|dim_cnt
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_macro
name|rst_dimmer_cnt
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|diff
decl_stmt|;
specifier|static
name|unsigned
name|last_time
decl_stmt|;
specifier|extern
name|unsigned
name|sys_time
decl_stmt|;
name|int
name|mode
init|=
name|DIMMER_RESET
decl_stmt|;
name|diff
operator|=
name|sys_time
operator|-
name|last_time
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|DIMMER_INTERVAL
operator|*
name|HZ
operator|||
name|diff
operator|<
literal|0
condition|)
block|{
name|dimmer
argument_list|(
name|DIMMER_RESET
argument_list|)
expr_stmt|;
name|last_time
operator|=
name|sys_time
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|auto_dimmer_on
argument_list|()
end_macro

begin_block
block|{
name|dimmer
argument_list|(
name|DIMMER_ON
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|auto_dimmer_off
argument_list|()
end_macro

begin_block
block|{
name|dimmer
argument_list|(
name|DIMMER_OFF
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dimmer
argument_list|(
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|dimmer_stdport
condition|)
name|msg_send
argument_list|(
name|dimmer_stdport
argument_list|,
literal|0
argument_list|,
operator|&
name|mode
argument_list|,
sizeof|sizeof
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IPC_MRX */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dimmer_counter
init|=
name|DIM_CNT_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dim_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_SINGLE
end_ifdef

begin_macro
name|auto_dimmer
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|s
operator|=
name|spl4
argument_list|()
expr_stmt|;
if|if
condition|(
name|a_dim_on
operator|&&
operator|(
name|dimmer_counter
operator|--
operator|<=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|dim_level
operator|<
literal|3
condition|)
name|dim_level
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfbdev
condition|;
name|i
operator|++
control|)
name|fbbm_set_dimmer
argument_list|(
operator|&
name|fbdev
index|[
name|i
index|]
argument_list|,
name|dim_level
argument_list|)
expr_stmt|;
name|dimmer_counter
operator|=
name|dim_cnt
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|auto_dimmer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
literal|60
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|rst_dimmer_cnt
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|a_dim_on
condition|)
return|return;
ifdef|#
directive|ifdef
name|CPU_SINGLE
name|s
operator|=
name|spl4
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|dimmer_counter
operator|=
name|dim_cnt
expr_stmt|;
if|if
condition|(
name|dim_level
operator|>
literal|0
condition|)
block|{
name|dim_level
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfbdev
condition|;
name|i
operator|++
control|)
name|fbbm_set_dimmer
argument_list|(
operator|&
name|fbdev
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|auto_dimmer_on
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|CPU_SINGLE
name|s
operator|=
name|spl4
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|dimmer_counter
operator|=
name|dim_cnt
expr_stmt|;
name|dim_level
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfbdev
condition|;
name|i
operator|++
control|)
name|fbbm_set_dimmer
argument_list|(
operator|&
name|fbdev
index|[
name|i
index|]
argument_list|,
name|dim_level
argument_list|)
expr_stmt|;
name|a_dim_on
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|auto_dimmer_off
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|CPU_SINGLE
name|s
operator|=
name|spl4
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|dimmer_counter
operator|=
name|dim_cnt
expr_stmt|;
name|dim_level
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfbdev
condition|;
name|i
operator|++
control|)
name|fbbm_set_dimmer
argument_list|(
operator|&
name|fbdev
index|[
name|i
index|]
argument_list|,
name|dim_level
argument_list|)
expr_stmt|;
name|a_dim_on
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPC_MRX */
end_comment

begin_comment
comment|/*  *  The routine `_putc(sp, c)' only prints a character c with the cursor  *  attributes by using `copy_char(x, y, c, attributes)'.  *  And when IRM (terminal insertion-replacement mode) is set, the characters  *  righthand side of the cursor are shifted right and lost when they passed  *  beyond the right margin.  *  The position is specified by the sp pointer of the structure SCREEN.  *  */
end_comment

begin_expr_stmt
specifier|static
name|_putc
argument_list|(
name|sp
argument_list|,
name|c
argument_list|,
name|kanji
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|sp
operator|->
name|s_term_mode
operator|&
name|IRM
condition|)
block|{
name|vt_flush
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|s_csr
operator|)
argument_list|)
expr_stmt|;
name|move_chars
argument_list|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
argument_list|,
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
argument_list|,
name|rit_m
operator|-
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|-
operator|(
operator|(
name|kanji
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|+
operator|(
operator|(
name|kanji
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
name|copy_char
argument_list|(
name|sp
argument_list|,
name|c
argument_list|,
name|kanji
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
condition|)
block|{
name|fbuf
index|[
name|fp
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|fpn
operator|+=
name|kanji
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fbuf
index|[
name|fp
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|fpp
operator|=
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
expr_stmt|;
name|fpa
operator|=
name|sp
operator|->
name|s_csr
operator|.
name|csr_attributes
expr_stmt|;
name|fpn
operator|=
name|kanji
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *  Scroll up and down in the scroll region.  *  New oriented line must be cleared with terminal mode, that is whether  *  the screen is reverse mode or not.  */
end_comment

begin_macro
name|scroll_up
argument_list|(
argument|top
argument_list|,
argument|bottom
argument_list|,
argument|revsw
argument_list|,
argument|fcol
argument_list|,
argument|bcol
argument_list|)
end_macro

begin_decl_stmt
name|int
name|top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bottom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|revsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fcol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bcol
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|move_lines
argument_list|(
name|top
operator|+
literal|1
argument_list|,
name|bottom
operator|-
name|top
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|clear_lines
argument_list|(
name|bottom
argument_list|,
literal|1
argument_list|,
name|revsw
argument_list|,
name|fcol
argument_list|,
name|bcol
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|scroll_down
argument_list|(
argument|top
argument_list|,
argument|bottom
argument_list|,
argument|revsw
argument_list|,
argument|fcol
argument_list|,
argument|bcol
argument_list|)
end_macro

begin_decl_stmt
name|int
name|top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bottom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|revsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fcol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bcol
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|move_lines
argument_list|(
name|top
argument_list|,
name|bottom
operator|-
name|top
argument_list|,
name|top
operator|+
literal|1
argument_list|)
expr_stmt|;
name|clear_lines
argument_list|(
name|top
argument_list|,
literal|1
argument_list|,
name|revsw
argument_list|,
name|fcol
argument_list|,
name|bcol
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Back space  *  back_space(sp) moves cursor next to left at current cursor position.  *  The cursor can not move beyond left or right margin.  */
end_comment

begin_expr_stmt
name|back_space
argument_list|(
name|sp
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|cursor
modifier|*
name|spc
init|=
operator|&
name|sp
operator|->
name|s_csr
decl_stmt|;
name|cursor_off
argument_list|()
expr_stmt|;
if|if
condition|(
name|spc
operator|->
name|csr_x
operator|>
name|LFT_M
condition|)
block|{
name|spc
operator|->
name|csr_x
operator|-=
literal|1
expr_stmt|;
name|spc
operator|->
name|csr_p
operator|.
name|x
operator|-=
name|char_w
expr_stmt|;
block|}
name|cursor_on
argument_list|(
operator|&
name|spc
operator|->
name|csr_p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Tab stop  *  next_tab_stop(sp) moves cursor to next tab stop.  */
end_comment

begin_expr_stmt
name|next_tab_stop
argument_list|(
name|sp
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|cursor_off
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|+
literal|1
init|;
name|i
operator|<
name|rit_m
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|s_tab_pos
index|[
name|i
index|]
operator|==
literal|1
condition|)
break|break;
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|=
name|min
argument_list|(
name|i
argument_list|,
name|rit_m
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|x
operator|=
operator|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|-
literal|1
operator|)
operator|*
name|char_w
operator|+
name|x_ofst
expr_stmt|;
name|cursor_on
argument_list|(
operator|&
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Carriage return  *  carriage_ret(sp) moves cursor at beginning of the current line.  */
end_comment

begin_expr_stmt
name|carriage_ret
argument_list|(
name|sp
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|cursor_off
argument_list|()
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|=
name|LFT_M
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|x
operator|=
name|x_ofst
expr_stmt|;
name|cursor_on
argument_list|(
operator|&
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Bell  */
end_comment

begin_expr_stmt
specifier|static
name|bell
argument_list|()
block|{
ifdef|#
directive|ifdef
name|news1800
specifier|static
name|int
name|port
block|;
if|if
condition|(
name|port
operator|==
literal|0
condition|)
name|port
operator|=
name|port_create
argument_list|(
literal|"port_cons_bell"
argument_list|)
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|port
argument_list|,
name|KIOCBELL
argument_list|,
operator|&
name|bell_len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCBELL
argument_list|,
operator|&
name|bell_len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_macro
unit|}  int
name|Putchar
argument_list|(
argument|c
argument_list|,
argument|eob
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SCREEN
modifier|*
name|sp
init|=
operator|&
name|screen
decl_stmt|;
name|unsigned
name|int
name|sftjis_to_jis
parameter_list|()
function_decl|;
name|c
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|eob
condition|)
block|{
name|vt_flush
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|s_csr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|0x1b
condition|)
block|{
comment|/*  c == esc */
name|vt_flush
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|s_csr
operator|)
argument_list|)
expr_stmt|;
name|recover
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator||=
name|ESCAPE
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|s_current_stat
operator|&
name|ESCAPE
condition|)
block|{
call|(
modifier|*
name|sp
operator|->
name|s_esc_handler
call|)
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|s_current_stat
operator|&
name|SKANJI
condition|)
block|{
name|c
operator|=
name|sftjis_to_jis
argument_list|(
name|first_code
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_current_stat
operator|&
name|JKANJI
condition|)
block|{
name|addch
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|s_current_stat
operator||=
name|JKANJI
expr_stmt|;
name|addch
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|JKANJI
expr_stmt|;
block|}
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|SKANJI
expr_stmt|;
goto|goto
name|set_csr
goto|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|s_current_stat
operator|&
name|EKANJI
condition|)
block|{
name|c
operator|=
operator|(
name|c
operator|&
literal|0x7f
operator|)
operator||
operator|(
name|first_code
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_current_stat
operator|&
name|JKANJI
condition|)
block|{
name|addch
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|s_current_stat
operator||=
name|JKANJI
expr_stmt|;
name|addch
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|JKANJI
expr_stmt|;
block|}
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|EKANJI
expr_stmt|;
goto|goto
name|set_csr
goto|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|s_current_stat
operator|&
name|JKANJI
condition|)
block|{
name|jiskanji
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|set_csr
goto|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|s_current_stat
operator|&
name|EKANA
condition|)
block|{
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|EKANA
expr_stmt|;
name|addch
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|set_csr
goto|;
block|}
if|if
condition|(
name|c
operator|<
literal|0x20
condition|)
block|{
comment|/*  control code	*/
name|vt_flush
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|s_csr
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0x00
case|:
comment|/*  ignore  */
break|break;
case|case
literal|0x07
case|:
comment|/*  bell  */
name|bell
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
comment|/*  back space  */
name|back_space
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x09
case|:
comment|/*  tabulation  */
name|next_tab_stop
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0a
case|:
comment|/*  line feed  */
case|case
literal|0x0b
case|:
comment|/*  vertical feed  */
case|case
literal|0x0c
case|:
comment|/*  form feed  */
name|esc_index
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0d
case|:
comment|/*  carriage return  */
name|carriage_ret
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0e
case|:
comment|/*  shift out  */
break|break;
case|case
literal|0x0f
case|:
comment|/*  shift in  */
break|break;
case|case
literal|0x11
case|:
comment|/*  xon  */
break|break;
case|case
literal|0x13
case|:
comment|/*  xoff  */
break|break;
case|case
literal|0x18
case|:
comment|/*  cancel  */
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
break|break;
case|case
literal|0x1b
case|:
comment|/*  escape  */
comment|/*	NOT REACHED	*/
name|recover
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator||=
name|ESCAPE
expr_stmt|;
break|break;
case|case
literal|0x7f
case|:
comment|/*  delete  */
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|tmode
condition|)
block|{
ifdef|#
directive|ifdef
name|KM_SJIS
case|case
name|KM_SJIS
case|:
if|if
condition|(
operator|(
name|c
operator|>=
name|JVR1S
operator|&&
name|c
operator|<=
name|JVR1E
operator|)
operator|||
operator|(
name|c
operator|>=
name|JVR2S
operator|&&
name|c
operator|<=
name|JVR2E
operator|)
condition|)
block|{
name|sp
operator|->
name|s_current_stat
operator||=
name|SKANJI
expr_stmt|;
name|first_code
operator|=
name|c
expr_stmt|;
block|}
else|else
name|addch
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KM_EUC
case|case
name|KM_EUC
case|:
if|if
condition|(
name|c
operator|>=
name|CS1S
operator|&&
name|c
operator|<=
name|CS1E
condition|)
block|{
name|sp
operator|->
name|s_current_stat
operator||=
name|EKANJI
expr_stmt|;
name|first_code
operator|=
name|c
operator|&
literal|0x7f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|SS2
condition|)
name|sp
operator|->
name|s_current_stat
operator||=
name|EKANA
expr_stmt|;
else|else
name|addch
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KM_JIS
case|case
name|KM_JIS
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KM_ASCII
case|case
name|KM_ASCII
case|:
endif|#
directive|endif
default|default:
name|addch
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|set_csr
label|:
name|cursor_on
argument_list|(
operator|&
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
argument_list|)
expr_stmt|;
comment|/*  altered	*/
return|return ;
block|}
end_block

begin_comment
comment|/*  *  A printable character is printed in this routine by using  *  the routine `_putc()'.  *  Anyway, a character is printed in replacement mode or insertion  *  mode and if the terminal is autowrap then it takes place wrapping  *  and if cursor is bottom margin of the scroll region then it takes  *  place scroll up.  *  The escape sequence handling is another routine.  *  */
end_comment

begin_expr_stmt
name|addch
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cursor
modifier|*
name|spc
init|=
operator|&
operator|(
name|sp
operator|->
name|s_csr
operator|)
decl_stmt|;
specifier|register
name|struct
name|region
modifier|*
name|spr
init|=
operator|&
operator|(
name|sp
operator|->
name|s_region
operator|)
decl_stmt|;
if|if
condition|(
name|spc
operator|->
name|csr_x
operator|>=
name|rit_m
operator|||
operator|(
operator|(
name|sp
operator|->
name|s_current_stat
operator|&
name|JKANJI
operator|)
operator|&&
operator|(
name|spc
operator|->
name|csr_x
operator|>=
name|rit_m
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|vt_flush
argument_list|(
name|spc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_term_mode
operator|&
name|DECAWM
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|s_current_stat
operator|&
name|WRAP
operator|)
operator|||
operator|(
name|spc
operator|->
name|csr_x
operator|==
name|rit_m
operator|&&
name|sp
operator|->
name|s_current_stat
operator|&
name|JKANJI
operator|)
condition|)
block|{
if|if
condition|(
name|spc
operator|->
name|csr_y
operator|==
name|spr
operator|->
name|btm_margin
condition|)
block|{
name|cursor_off
argument_list|()
expr_stmt|;
name|scroll_up
argument_list|(
name|spr
operator|->
name|top_margin
argument_list|,
name|spr
operator|->
name|btm_margin
argument_list|,
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
argument_list|,
name|sp
operator|->
name|s_plane
argument_list|,
name|sp
operator|->
name|s_bgcol
argument_list|)
expr_stmt|;
name|cursor_on
argument_list|(
operator|&
operator|(
name|spc
operator|->
name|csr_p
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spc
operator|->
name|csr_y
operator|<
name|btm_m
condition|)
block|{
name|spc
operator|->
name|csr_y
operator|+=
literal|1
expr_stmt|;
name|spc
operator|->
name|csr_p
operator|.
name|y
operator|+=
name|char_h
expr_stmt|;
block|}
name|spc
operator|->
name|csr_x
operator|=
name|LFT_M
expr_stmt|;
name|spc
operator|->
name|csr_p
operator|.
name|x
operator|=
name|x_ofst
expr_stmt|;
name|addch
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|s_current_stat
operator||=
name|WRAP
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|s_current_stat
operator|&
name|JKANJI
condition|)
block|{
if|if
condition|(
name|spc
operator|->
name|csr_x
operator|!=
name|rit_m
condition|)
block|{
name|_putc
argument_list|(
name|sp
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|_putc
argument_list|(
name|sp
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spc
operator|->
name|csr_x
operator|<
name|rit_m
condition|)
block|{
name|spc
operator|->
name|csr_x
operator|+=
literal|1
expr_stmt|;
name|spc
operator|->
name|csr_p
operator|.
name|x
operator|+=
name|char_w
expr_stmt|;
block|}
return|return ;
block|}
if|if
condition|(
name|sp
operator|->
name|s_current_stat
operator|&
name|JKANJI
condition|)
block|{
name|_putc
argument_list|(
name|sp
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|spc
operator|->
name|csr_x
operator|++
expr_stmt|;
name|spc
operator|->
name|csr_p
operator|.
name|x
operator|+=
name|char_w
expr_stmt|;
block|}
else|else
block|{
name|_putc
argument_list|(
name|sp
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|spc
operator|->
name|csr_x
operator|++
expr_stmt|;
comment|/*  altered   */
name|spc
operator|->
name|csr_p
operator|.
name|x
operator|+=
name|char_w
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|WRAP
expr_stmt|;
return|return ;
block|}
end_block

end_unit

