begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Sony Corp. and Kazumasa Utashiro of Software Research Associates, Inc.  *  * %sccs.include.redist.c%  *  * from: $Hdr: vt100esc.c,v 4.300 91/06/09 06:14:59 root Rel41 $ SONY  *  *	@(#)vt100esc.c	7.1 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  *  vt100 escape sequence handler  */
end_comment

begin_include
include|#
directive|include
file|"../include/fix_machine_type.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPC_MRX
end_ifdef

begin_include
include|#
directive|include
file|"../../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../../iop/framebuf.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"../iop/framebuf.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../bm/vt100.h"
end_include

begin_include
include|#
directive|include
file|"../bm/bitmapif.h"
end_include

begin_include
include|#
directive|include
file|"../fb/fbdefs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPC_MRX
end_ifdef

begin_include
include|#
directive|include
file|"../../iop/kbreg.h"
end_include

begin_include
include|#
directive|include
file|"../../iop/keyboard.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"../iop/kbreg.h"
end_include

begin_include
include|#
directive|include
file|"../iop/keyboard.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CPU_SINGLE
end_if

begin_include
include|#
directive|include
file|"../sio/scc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPC_MRX
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_define
define|#
directive|define
name|kbd_ioctl
parameter_list|(
name|chan
parameter_list|,
name|cmd
parameter_list|,
name|argp
parameter_list|)
value|{ \ 	if (kb_ioctl) \ 		(*kb_ioctl)(chan, cmd, argp); \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  escape sequece functions  */
end_comment

begin_function_decl
name|int
name|esc_csi
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_csi_ansi
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_csi_dec
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_store_csr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_restore_csr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_next_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_tab_set
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_rev_index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_numeric_kpad
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_application_kpad
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_line_size
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_char_setr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_char_setl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_kanji_set
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_parm_set
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_pf_define
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|esc_ignore
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|esc_sequence
name|esc_seq_table
index|[]
init|=
block|{
block|{
literal|'['
block|,
literal|"ABCDfgHhJKLlMmnPr"
block|,
name|esc_csi
block|}
block|,
block|{
literal|'7'
block|,
literal|""
block|,
name|esc_store_csr
block|}
block|,
block|{
literal|'8'
block|,
literal|""
block|,
name|esc_restore_csr
block|}
block|,
block|{
literal|'D'
block|,
literal|""
block|,
name|esc_index
block|}
block|,
block|{
literal|'E'
block|,
literal|""
block|,
name|esc_next_line
block|}
block|,
block|{
literal|'H'
block|,
literal|""
block|,
name|esc_tab_set
block|}
block|,
block|{
literal|'M'
block|,
literal|""
block|,
name|esc_rev_index
block|}
block|,
block|{
literal|'='
block|,
literal|""
block|,
name|esc_application_kpad
block|}
block|,
block|{
literal|'>'
block|,
literal|""
block|,
name|esc_numeric_kpad
block|}
block|,
block|{
literal|'#'
block|,
literal|"34568"
block|,
name|esc_line_size
block|}
block|,
block|{
literal|'('
block|,
literal|"0ABJH"
block|,
name|esc_char_setr
block|}
block|,
block|{
literal|')'
block|,
literal|"0AB"
block|,
name|esc_char_setl
block|}
block|,
block|{
literal|'$'
block|,
literal|"B@"
block|,
name|esc_kanji_set
block|}
block|,
block|{
literal|'~'
block|,
literal|"fcpsomdbDiGCBTtE"
block|,
name|esc_parm_set
block|}
block|,
block|{
literal|'P'
block|,
literal|"pPZiI"
block|,
name|esc_pf_define
block|}
block|,
block|{
literal|'\0'
block|,
literal|""
block|,
name|esc_ignore
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|key_pad
name|key_pad
index|[]
init|=
block|{
block|{
literal|'0'
block|,
literal|'p'
block|}
block|,
comment|/*	0	*/
block|{
literal|'1'
block|,
literal|'q'
block|}
block|,
comment|/*	1	*/
block|{
literal|'2'
block|,
literal|'r'
block|}
block|,
comment|/*	2	*/
block|{
literal|'3'
block|,
literal|'s'
block|}
block|,
comment|/*	3	*/
block|{
literal|'4'
block|,
literal|'t'
block|}
block|,
comment|/*	4	*/
block|{
literal|'5'
block|,
literal|'u'
block|}
block|,
comment|/*	5	*/
block|{
literal|'6'
block|,
literal|'v'
block|}
block|,
comment|/*	6	*/
block|{
literal|'7'
block|,
literal|'w'
block|}
block|,
comment|/*	7	*/
block|{
literal|'8'
block|,
literal|'x'
block|}
block|,
comment|/*	8	*/
block|{
literal|'9'
block|,
literal|'y'
block|}
block|,
comment|/*	9	*/
block|{
literal|'.'
block|,
literal|'n'
block|}
block|,
comment|/*  period	*/
block|{
literal|'-'
block|,
literal|'m'
block|}
block|,
comment|/*  minus	*/
block|{
literal|'+'
block|,
literal|'k'
block|}
block|,
comment|/*  plus	*/
block|{
literal|','
block|,
literal|'l'
block|}
block|,
comment|/*  comma	*/
block|{
literal|'\n'
block|,
literal|'M'
block|}
block|,
comment|/*  enter	*/
block|{
literal|'A'
block|,
literal|'A'
block|}
block|,
comment|/*  cursor up	*/
block|{
literal|'B'
block|,
literal|'B'
block|}
block|,
comment|/*  cursor down	*/
block|{
literal|'C'
block|,
literal|'C'
block|}
block|,
comment|/*  cursor right */
block|{
literal|'D'
block|,
literal|'D'
block|}
block|,
comment|/*  cursor left	*/
block|{
literal|'\0'
block|,
literal|'\0'
block|}
comment|/*	*/
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|esc_buf
index|[
name|ESC_BUF_SIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|esc_bp
init|=
name|esc_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|c_pos_mess
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Key_string
name|key_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Pfk_string
name|pfk_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|first_jcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  put out jis-code kanji  */
end_comment

begin_expr_stmt
name|jiskanji
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|first_jcode
condition|)
block|{
name|addch
argument_list|(
name|sp
argument_list|,
name|c
operator||
operator|(
name|first_jcode
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|first_jcode
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|first_jcode
operator|=
name|c
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *  This routine is the command analiser using second character.  *  If a command has found then switch to particular escape handling  *  routine, and directly called by mother routine.   *  The arguments are passed through the routine.  */
end_comment

begin_expr_stmt
name|esc_top_level
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|esc_sequence
modifier|*
name|estp
decl_stmt|;
for|for
control|(
name|estp
operator|=
name|esc_seq_table
init|;
name|estp
operator|->
name|command
condition|;
name|estp
operator|++
control|)
block|{
if|if
condition|(
name|estp
operator|->
name|command
operator|==
name|c
condition|)
block|{
comment|/* command found  */
name|sp
operator|->
name|s_estp
operator|=
name|estp
expr_stmt|;
if|if
condition|(
operator|*
name|estp
operator|->
name|terminators
operator|==
literal|'\0'
condition|)
block|{
call|(
modifier|*
name|estp
operator|->
name|esc_func
call|)
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|s_esc_handler
operator|=
name|estp
operator|->
name|esc_func
expr_stmt|;
block|}
return|return;
block|}
block|}
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Undo the ESCAPE flag, escape buffer  *  and the esc_handler routine  *  This routine has to be called when escape sequence has started.  */
end_comment

begin_expr_stmt
name|recover
argument_list|(
name|sp
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|ip
init|=
operator|(
name|int
operator|*
operator|)
name|esc_buf
decl_stmt|;
specifier|register
name|int
modifier|*
name|sup
init|=
operator|(
name|int
operator|*
operator|)
operator|(
name|esc_buf
operator|+
name|ESC_BUF_SIZ
operator|)
decl_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
name|sp
operator|->
name|s_esc_handler
operator|=
name|esc_top_level
expr_stmt|;
while|while
condition|(
name|ip
operator|<
name|sup
condition|)
operator|*
name|ip
operator|++
operator|=
literal|0
expr_stmt|;
name|esc_bp
operator|=
name|esc_buf
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  This routine in_str(c, string) returns  *  if string contains c then TRUE (1) else FALSE (0)  */
end_comment

begin_macro
name|in_str
argument_list|(
argument|c
argument_list|,
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|string
condition|)
if|if
condition|(
name|c
operator|==
operator|*
name|string
operator|++
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  Control sequence introducer (CSI)  *  Which begins `^[[' and terminates one of `ABCDfgHhJKLlMmPr'  */
end_comment

begin_expr_stmt
name|esc_csi
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|bufc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|in_str
argument_list|(
name|c
argument_list|,
name|sp
operator|->
name|s_estp
operator|->
name|terminators
argument_list|)
condition|)
block|{
name|esc_csi_ansi
argument_list|(
name|sp
argument_list|,
name|esc_bp
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
name|bufc
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*  buffering arguments  */
if|if
condition|(
name|bufc
operator|<
name|ESC_BUF_SIZ
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
operator|*
name|esc_bp
operator|=
operator|*
name|esc_bp
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
name|esc_bp
operator|++
expr_stmt|;
name|bufc
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
name|esc_bp
operator|==
name|esc_buf
condition|)
block|{
name|sp
operator|->
name|s_esc_handler
operator|=
name|esc_csi_dec
expr_stmt|;
block|}
else|else
block|{
name|esc_buf
index|[
literal|0
index|]
operator|=
name|INVALID
expr_stmt|;
block|}
block|}
else|else
block|{
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
name|bufc
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|IPC_MRX
end_ifdef

begin_define
define|#
directive|define
name|SCC_KEYBOARD
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Ansi standard csi handler  */
end_comment

begin_expr_stmt
name|esc_csi_ansi
argument_list|(
name|sp
argument_list|,
name|esc_bp
argument_list|,
name|terminator
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|esc_bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|terminator
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|esc_buf
decl_stmt|;
specifier|register
name|struct
name|cursor
modifier|*
name|spc
init|=
operator|&
name|sp
operator|->
name|s_csr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
name|INVALID
condition|)
return|return;
name|cursor_off
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|terminator
condition|)
block|{
case|case
literal|'A'
case|:
comment|/*  CUU	 */
if|if
condition|(
name|spc
operator|->
name|csr_y
operator|<
name|sp
operator|->
name|s_region
operator|.
name|top_margin
condition|)
block|{
name|spc
operator|->
name|csr_y
operator|=
name|MAX
argument_list|(
name|spc
operator|->
name|csr_y
operator|-
name|MAX
argument_list|(
operator|*
name|cp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TOP_M
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spc
operator|->
name|csr_y
operator|=
name|MAX
argument_list|(
name|spc
operator|->
name|csr_y
operator|-
name|MAX
argument_list|(
operator|*
name|cp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sp
operator|->
name|s_region
operator|.
name|top_margin
argument_list|)
expr_stmt|;
block|}
name|spc
operator|->
name|csr_p
operator|.
name|y
operator|=
operator|(
name|spc
operator|->
name|csr_y
operator|-
literal|1
operator|)
operator|*
name|char_h
operator|+
name|y_ofst
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|WRAP
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/*  CUD	 */
if|if
condition|(
name|spc
operator|->
name|csr_y
operator|>
name|sp
operator|->
name|s_region
operator|.
name|btm_margin
condition|)
block|{
name|spc
operator|->
name|csr_y
operator|=
name|MIN
argument_list|(
name|spc
operator|->
name|csr_y
operator|+
name|MAX
argument_list|(
operator|*
name|cp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|btm_m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spc
operator|->
name|csr_y
operator|=
name|MIN
argument_list|(
name|spc
operator|->
name|csr_y
operator|+
name|MAX
argument_list|(
operator|*
name|cp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sp
operator|->
name|s_region
operator|.
name|btm_margin
argument_list|)
expr_stmt|;
block|}
name|spc
operator|->
name|csr_p
operator|.
name|y
operator|=
operator|(
name|spc
operator|->
name|csr_y
operator|-
literal|1
operator|)
operator|*
name|char_h
operator|+
name|y_ofst
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|WRAP
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/*  CUF	 */
name|spc
operator|->
name|csr_x
operator|=
name|MIN
argument_list|(
name|spc
operator|->
name|csr_x
operator|+
name|MAX
argument_list|(
operator|*
name|cp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|rit_m
argument_list|)
expr_stmt|;
name|spc
operator|->
name|csr_p
operator|.
name|x
operator|=
operator|(
name|spc
operator|->
name|csr_x
operator|-
literal|1
operator|)
operator|*
name|char_w
operator|+
name|x_ofst
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|WRAP
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/*  CUB	 */
name|spc
operator|->
name|csr_x
operator|=
name|MAX
argument_list|(
name|spc
operator|->
name|csr_x
operator|-
name|MAX
argument_list|(
operator|*
name|cp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|LFT_M
argument_list|)
expr_stmt|;
name|spc
operator|->
name|csr_p
operator|.
name|x
operator|=
operator|(
name|spc
operator|->
name|csr_x
operator|-
literal|1
operator|)
operator|*
name|char_w
operator|+
name|x_ofst
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|WRAP
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/*  TBC	 */
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|0
case|:
name|sp
operator|->
name|s_tab_pos
index|[
name|spc
operator|->
name|csr_x
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|3
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|rit_m
condition|;
name|i
operator|++
control|)
name|sp
operator|->
name|s_tab_pos
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|'f'
case|:
comment|/*  HVP	 */
case|case
literal|'H'
case|:
comment|/*  CUP  same as HVP	*/
name|csr_pos
argument_list|(
name|sp
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|WRAP
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/*  ED	*/
name|erase_disp
argument_list|(
name|sp
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|WRAP
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
comment|/*  EL	*/
name|erase_line
argument_list|(
name|sp
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|WRAP
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/*  IL	*/
name|insert_line
argument_list|(
name|sp
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/*  DL	*/
name|delete_line
argument_list|(
name|sp
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/*  DCH	 */
name|delete_char
argument_list|(
name|sp
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|WRAP
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/*  DECSTBM	*/
name|cp
index|[
literal|2
index|]
operator|=
name|MAX
argument_list|(
name|cp
index|[
literal|0
index|]
operator|==
literal|0
condition|?
name|TOP_M
else|:
name|cp
index|[
literal|0
index|]
argument_list|,
name|TOP_M
argument_list|)
expr_stmt|;
name|cp
index|[
literal|3
index|]
operator|=
name|MIN
argument_list|(
name|cp
index|[
literal|1
index|]
operator|==
literal|0
condition|?
name|btm_m
else|:
name|cp
index|[
literal|1
index|]
argument_list|,
name|btm_m
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|2
index|]
operator|>=
name|cp
index|[
literal|3
index|]
condition|)
break|break;
name|sp
operator|->
name|s_region
operator|.
name|top_margin
operator|=
name|cp
index|[
literal|2
index|]
expr_stmt|;
name|sp
operator|->
name|s_region
operator|.
name|btm_margin
operator|=
name|cp
index|[
literal|3
index|]
expr_stmt|;
name|spc
operator|->
name|csr_x
operator|=
name|LFT_M
expr_stmt|;
name|spc
operator|->
name|csr_p
operator|.
name|x
operator|=
name|x_ofst
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_term_mode
operator|&
name|DECOM
condition|)
block|{
name|spc
operator|->
name|csr_y
operator|=
name|sp
operator|->
name|s_region
operator|.
name|top_margin
expr_stmt|;
name|spc
operator|->
name|csr_p
operator|.
name|y
operator|=
operator|(
name|spc
operator|->
name|csr_y
operator|-
literal|1
operator|)
operator|*
name|char_h
operator|+
name|y_ofst
expr_stmt|;
block|}
else|else
block|{
name|spc
operator|->
name|csr_y
operator|=
name|TOP_M
expr_stmt|;
name|spc
operator|->
name|csr_p
operator|.
name|y
operator|=
name|y_ofst
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
comment|/*  CRA	 */
while|while
condition|(
name|cp
operator|<=
name|esc_bp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|0
case|:
name|spc
operator|->
name|csr_attributes
operator|&=
name|NORMALM
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
condition|)
block|{
name|fcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
block|}
else|else
block|{
name|fcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/*  bold	*/
name|spc
operator|->
name|csr_attributes
operator||=
name|BOLD
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/*  under score	 */
name|spc
operator|->
name|csr_attributes
operator||=
name|USCORE
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/*  blinking	*/
name|spc
operator|->
name|csr_attributes
operator||=
name|BLINK
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/*  reverse	*/
name|spc
operator|->
name|csr_attributes
operator||=
name|REVERSE
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
condition|)
block|{
name|fcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
block|}
else|else
block|{
name|fcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
block|}
break|break;
case|case
literal|22
case|:
comment|/*  unbold	*/
name|spc
operator|->
name|csr_attributes
operator|&=
operator|~
name|BOLD
expr_stmt|;
break|break;
case|case
literal|24
case|:
comment|/*  no under score	*/
name|spc
operator|->
name|csr_attributes
operator|&=
operator|~
name|USCORE
expr_stmt|;
break|break;
case|case
literal|25
case|:
comment|/*  no blinking	 */
name|spc
operator|->
name|csr_attributes
operator|&=
operator|~
name|BLINK
expr_stmt|;
break|break;
case|case
literal|27
case|:
comment|/*  re-reverse	*/
name|spc
operator|->
name|csr_attributes
operator|&=
operator|~
name|REVERSE
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
condition|)
block|{
name|fcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
block|}
else|else
block|{
name|fcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
break|break;
case|case
literal|'n'
case|:
while|while
condition|(
name|cp
operator|<=
name|esc_bp
condition|)
block|{
comment|/*  DSR(status request)	*/
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|6
case|:
comment|/*  inquiry cursor position	*/
name|key_str
operator|.
name|key_string
operator|=
name|c_pos_mess
expr_stmt|;
name|key_str
operator|.
name|key_length
operator|=
name|spr
argument_list|(
name|c_pos_mess
argument_list|,
literal|"\033[%d;%dR"
argument_list|,
operator|(
name|sp
operator|->
name|s_term_mode
operator|&
name|DECOM
operator|)
condition|?
name|spc
operator|->
name|csr_y
operator|-
name|sp
operator|->
name|s_region
operator|.
name|top_margin
operator|+
literal|1
else|:
name|spc
operator|->
name|csr_y
argument_list|,
name|spc
operator|->
name|csr_x
argument_list|)
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCBACK
argument_list|,
operator|&
name|key_str
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
case|case
literal|'h'
case|:
comment|/*  SM	*/
while|while
condition|(
name|cp
operator|<=
name|esc_bp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|2
case|:
comment|/*  Keyboard Action	*/
name|sp
operator|->
name|s_term_mode
operator||=
name|KAM
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/*  Insert Replace	*/
name|sp
operator|->
name|s_term_mode
operator||=
name|IRM
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/*  Local echo disable	*/
name|sp
operator|->
name|s_term_mode
operator||=
name|SRM
expr_stmt|;
break|break;
case|case
literal|20
case|:
comment|/*  Linefeed newline	*/
name|sp
operator|->
name|s_term_mode
operator||=
name|LNM
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
case|case
literal|'l'
case|:
comment|/*  RM	*/
while|while
condition|(
name|cp
operator|<=
name|esc_bp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|2
case|:
comment|/*  Keyboard Action	*/
name|sp
operator|->
name|s_term_mode
operator|&=
operator|~
name|KAM
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/*  Insert Replace	*/
name|sp
operator|->
name|s_term_mode
operator|&=
operator|~
name|IRM
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/*  Local echo disable	*/
name|sp
operator|->
name|s_term_mode
operator|&=
operator|~
name|SRM
expr_stmt|;
break|break;
case|case
literal|20
case|:
comment|/*  Linefeed newline	*/
name|sp
operator|->
name|s_term_mode
operator|&=
operator|~
name|LNM
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
default|default:
break|break;
block|}
name|cursor_on
argument_list|(
operator|&
name|spc
operator|->
name|csr_p
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Cursor position.  *  csr_pos(sp, x, y) moves the cursor to (x, y).  */
end_comment

begin_expr_stmt
name|csr_pos
argument_list|(
name|sp
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|sp
operator|->
name|s_term_mode
operator|&
name|DECOM
condition|)
block|{
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|=
name|MIN
argument_list|(
name|sp
operator|->
name|s_region
operator|.
name|top_margin
operator|+
name|MAX
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
argument_list|,
name|sp
operator|->
name|s_region
operator|.
name|btm_margin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|=
name|MIN
argument_list|(
name|TOP_M
operator|+
name|MAX
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
argument_list|,
name|btm_m
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|=
name|MAX
argument_list|(
name|MIN
argument_list|(
name|x
argument_list|,
name|rit_m
argument_list|)
argument_list|,
name|LFT_M
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|x
operator|=
operator|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|-
literal|1
operator|)
operator|*
name|char_w
operator|+
name|x_ofst
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|y
operator|=
operator|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|-
literal|1
operator|)
operator|*
name|char_h
operator|+
name|y_ofst
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Erase in display.  *  erase_disp(sp, pn) erases display from the cursor to the end, from   *  the beginning to the cursor or completely according to pn = 0, 1 or 2  *  respectively.  */
end_comment

begin_expr_stmt
name|erase_disp
argument_list|(
name|sp
argument_list|,
name|pn
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|pn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cursor
modifier|*
name|spc
init|=
operator|&
name|sp
operator|->
name|s_csr
decl_stmt|;
switch|switch
condition|(
name|pn
condition|)
block|{
case|case
literal|0
case|:
comment|/*  cursor to end	*/
name|erase_line
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clear_lines
argument_list|(
name|MIN
argument_list|(
name|spc
operator|->
name|csr_y
operator|+
literal|1
argument_list|,
name|btm_m
argument_list|)
argument_list|,
name|btm_m
operator|-
name|spc
operator|->
name|csr_y
argument_list|,
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
argument_list|,
name|sp
operator|->
name|s_plane
argument_list|,
name|sp
operator|->
name|s_bgcol
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/*  beginning to cursor	*/
name|erase_line
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|clear_lines
argument_list|(
name|TOP_M
argument_list|,
name|spc
operator|->
name|csr_y
operator|-
name|TOP_M
argument_list|,
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
argument_list|,
name|sp
operator|->
name|s_plane
argument_list|,
name|sp
operator|->
name|s_bgcol
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/*  whole	*/
name|clear_lines
argument_list|(
name|TOP_M
argument_list|,
name|btm_m
operator|-
name|TOP_M
operator|+
literal|1
argument_list|,
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
argument_list|,
name|sp
operator|->
name|s_plane
argument_list|,
name|sp
operator|->
name|s_bgcol
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  *  Erase in line.  *  erase_line(sp, pn) erases line from the cursor to the end, from the   *  beginning to the cursor or completely according to pn = 0, 1 or 2  *  respectively.  */
end_comment

begin_expr_stmt
name|erase_line
argument_list|(
name|sp
argument_list|,
name|pn
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|pn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cursor
modifier|*
name|spc
init|=
operator|&
name|sp
operator|->
name|s_csr
decl_stmt|;
switch|switch
condition|(
name|pn
condition|)
block|{
case|case
literal|0
case|:
name|clear_chars
argument_list|(
name|spc
operator|->
name|csr_x
argument_list|,
name|spc
operator|->
name|csr_y
argument_list|,
name|rit_m
operator|-
name|spc
operator|->
name|csr_x
operator|+
literal|1
argument_list|,
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
argument_list|,
name|sp
operator|->
name|s_plane
argument_list|,
name|sp
operator|->
name|s_bgcol
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|clear_chars
argument_list|(
name|LFT_M
argument_list|,
name|spc
operator|->
name|csr_y
argument_list|,
name|spc
operator|->
name|csr_x
operator|-
name|LFT_M
operator|+
literal|1
argument_list|,
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
argument_list|,
name|sp
operator|->
name|s_plane
argument_list|,
name|sp
operator|->
name|s_bgcol
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|clear_lines
argument_list|(
name|spc
operator|->
name|csr_y
argument_list|,
literal|1
argument_list|,
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
argument_list|,
name|sp
operator|->
name|s_plane
argument_list|,
name|sp
operator|->
name|s_bgcol
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  *  Insert line.  *  insert_line(sp, pn) inserts pn lines in scroll region  */
end_comment

begin_expr_stmt
name|insert_line
argument_list|(
name|sp
argument_list|,
name|pn
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|pn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cursor
modifier|*
name|spc
init|=
operator|&
name|sp
operator|->
name|s_csr
decl_stmt|;
specifier|register
name|struct
name|region
modifier|*
name|spr
init|=
operator|&
name|sp
operator|->
name|s_region
decl_stmt|;
name|pn
operator|=
name|MAX
argument_list|(
name|pn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|spc
operator|->
name|csr_y
operator|<
name|spr
operator|->
name|top_margin
operator|||
name|spc
operator|->
name|csr_y
operator|>
name|spr
operator|->
name|btm_margin
condition|)
return|return;
if|if
condition|(
name|pn
operator|<=
name|spr
operator|->
name|btm_margin
operator|-
name|spc
operator|->
name|csr_y
condition|)
block|{
name|move_lines
argument_list|(
name|spc
operator|->
name|csr_y
argument_list|,
name|spr
operator|->
name|btm_margin
operator|-
name|pn
operator|-
name|spc
operator|->
name|csr_y
operator|+
literal|1
argument_list|,
name|spc
operator|->
name|csr_y
operator|+
name|pn
argument_list|)
expr_stmt|;
block|}
name|clear_lines
argument_list|(
name|spc
operator|->
name|csr_y
argument_list|,
name|MIN
argument_list|(
name|spc
operator|->
name|csr_y
operator|+
name|pn
operator|-
literal|1
argument_list|,
name|spr
operator|->
name|btm_margin
argument_list|)
operator|-
name|spc
operator|->
name|csr_y
operator|+
literal|1
argument_list|,
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
argument_list|,
name|sp
operator|->
name|s_plane
argument_list|,
name|sp
operator|->
name|s_bgcol
argument_list|)
expr_stmt|;
name|spc
operator|->
name|csr_x
operator|=
name|LFT_M
expr_stmt|;
name|spc
operator|->
name|csr_p
operator|.
name|x
operator|=
name|x_ofst
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Delete line.  *  delete_line(sp, pn) deletes pn lines in scroll region  */
end_comment

begin_expr_stmt
name|delete_line
argument_list|(
name|sp
argument_list|,
name|pn
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|pn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cursor
modifier|*
name|spc
init|=
operator|&
name|sp
operator|->
name|s_csr
decl_stmt|;
specifier|register
name|struct
name|region
modifier|*
name|spr
init|=
operator|&
name|sp
operator|->
name|s_region
decl_stmt|;
specifier|register
name|int
name|aux
decl_stmt|;
name|pn
operator|=
name|MAX
argument_list|(
name|pn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|spc
operator|->
name|csr_y
operator|<
name|spr
operator|->
name|top_margin
operator|||
name|spc
operator|->
name|csr_y
operator|>
name|spr
operator|->
name|btm_margin
condition|)
return|return;
if|if
condition|(
name|pn
operator|<=
name|spr
operator|->
name|btm_margin
operator|-
name|spc
operator|->
name|csr_y
condition|)
block|{
name|aux
operator|=
name|spc
operator|->
name|csr_y
operator|+
name|pn
expr_stmt|;
name|move_lines
argument_list|(
name|aux
argument_list|,
name|spr
operator|->
name|btm_margin
operator|-
name|aux
operator|+
literal|1
argument_list|,
name|spc
operator|->
name|csr_y
argument_list|)
expr_stmt|;
block|}
name|aux
operator|=
name|MAX
argument_list|(
name|spr
operator|->
name|btm_margin
operator|-
name|pn
operator|+
literal|1
argument_list|,
name|spc
operator|->
name|csr_y
argument_list|)
expr_stmt|;
name|clear_lines
argument_list|(
name|aux
argument_list|,
name|spr
operator|->
name|btm_margin
operator|-
name|aux
operator|+
literal|1
argument_list|,
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
argument_list|,
name|sp
operator|->
name|s_plane
argument_list|,
name|sp
operator|->
name|s_bgcol
argument_list|)
expr_stmt|;
name|spc
operator|->
name|csr_x
operator|=
name|LFT_M
expr_stmt|;
name|spc
operator|->
name|csr_p
operator|.
name|x
operator|=
name|x_ofst
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Delete character.  *  delete_char(sp, pn) deletes pn characters right side of the cursor.  */
end_comment

begin_expr_stmt
name|delete_char
argument_list|(
name|sp
argument_list|,
name|pn
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|pn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cursor
modifier|*
name|spc
init|=
operator|&
name|sp
operator|->
name|s_csr
decl_stmt|;
specifier|register
name|int
name|aux
decl_stmt|;
name|pn
operator|=
name|MAX
argument_list|(
name|pn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|<
name|rit_m
operator|-
name|spc
operator|->
name|csr_x
operator|+
literal|1
condition|)
block|{
name|move_chars
argument_list|(
name|spc
operator|->
name|csr_x
operator|+
name|pn
argument_list|,
name|spc
operator|->
name|csr_y
argument_list|,
name|rit_m
operator|-
name|spc
operator|->
name|csr_x
operator|-
name|pn
operator|+
literal|1
argument_list|,
name|spc
operator|->
name|csr_x
argument_list|)
expr_stmt|;
block|}
name|aux
operator|=
name|MAX
argument_list|(
name|rit_m
operator|-
name|pn
operator|+
literal|1
argument_list|,
name|spc
operator|->
name|csr_x
argument_list|)
expr_stmt|;
name|clear_chars
argument_list|(
name|aux
argument_list|,
name|spc
operator|->
name|csr_y
argument_list|,
name|rit_m
operator|-
name|aux
operator|+
literal|1
argument_list|,
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
argument_list|,
name|sp
operator|->
name|s_plane
argument_list|,
name|sp
operator|->
name|s_bgcol
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  This escape control sequence begins `^[[?' and ends `h' or `l'  */
end_comment

begin_expr_stmt
name|esc_csi_dec
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|in_str
argument_list|(
name|c
argument_list|,
name|sp
operator|->
name|s_estp
operator|->
name|terminators
argument_list|)
condition|)
block|{
if|if
condition|(
name|esc_buf
index|[
literal|0
index|]
operator|!=
name|INVALID
condition|)
block|{
name|cursor_off
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'h'
case|:
comment|/*  set mode	*/
for|for
control|(
name|cp
operator|=
name|esc_buf
init|;
name|cp
operator|<=
name|esc_bp
condition|;
name|cp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|1
case|:
comment|/*  cursor key application  */
name|sp
operator|->
name|s_term_mode
operator||=
name|DECCKM
expr_stmt|;
name|change_csr_key_pad
argument_list|(
name|APPLIC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/*  132 column mode	*/
name|sp
operator|->
name|s_term_mode
operator||=
name|DECCOLM
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/*  jump scroll	*/
name|sp
operator|->
name|s_term_mode
operator||=
name|DECSCLM
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/*  reverse	*/
if|if
condition|(
operator|(
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
operator|)
operator|==
literal|0
condition|)
name|reverse_rec
argument_list|(
name|sp
operator|->
name|s_bgcol
argument_list|,
name|sp
operator|->
name|s_plane
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_term_mode
operator||=
name|DECSCNM
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_attributes
operator|&
name|REVERSE
condition|)
block|{
name|fcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
block|}
else|else
block|{
name|fcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
comment|/*  origin	*/
name|sp
operator|->
name|s_term_mode
operator||=
name|DECOM
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|=
name|LFT_M
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|=
name|sp
operator|->
name|s_region
operator|.
name|top_margin
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|x
operator|=
name|x_ofst
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|y
operator|=
operator|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|-
literal|1
operator|)
operator|*
name|char_h
operator|+
name|y_ofst
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/*  auto wrap	*/
name|sp
operator|->
name|s_term_mode
operator||=
name|DECAWM
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/*  auto repeat	 */
if|if
condition|(
operator|(
name|sp
operator|->
name|s_term_mode
operator|&
name|DECARM
operator|)
operator|==
literal|0
condition|)
block|{
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCREPT
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|s_term_mode
operator||=
name|DECARM
expr_stmt|;
break|break;
case|case
literal|25
case|:
comment|/* cursor active */
name|sp
operator|->
name|s_term_mode
operator||=
name|DECCSR_ACTV
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
case|case
literal|'l'
case|:
comment|/*  reset mode	*/
for|for
control|(
name|cp
operator|=
name|esc_buf
init|;
name|cp
operator|<=
name|esc_bp
condition|;
name|cp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|1
case|:
comment|/*  cursor key application  */
name|sp
operator|->
name|s_term_mode
operator|&=
operator|~
name|DECCKM
expr_stmt|;
name|change_csr_key_pad
argument_list|(
name|NUMERIC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/*  132 column mode	*/
name|sp
operator|->
name|s_term_mode
operator|&=
operator|~
name|DECCOLM
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/*  jump scroll	*/
name|sp
operator|->
name|s_term_mode
operator|&=
operator|~
name|DECSCLM
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/*  reverse	*/
if|if
condition|(
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
condition|)
name|reverse_rec
argument_list|(
name|sp
operator|->
name|s_plane
argument_list|,
name|sp
operator|->
name|s_bgcol
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_term_mode
operator|&=
operator|~
name|DECSCNM
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_attributes
operator|&
name|REVERSE
condition|)
block|{
name|fcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
block|}
else|else
block|{
name|fcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
comment|/*  origin	*/
name|sp
operator|->
name|s_term_mode
operator|&=
operator|~
name|DECOM
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|=
name|LFT_M
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|=
name|TOP_M
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|x
operator|=
name|x_ofst
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|y
operator|=
name|y_ofst
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/*  auto wrap	*/
name|sp
operator|->
name|s_term_mode
operator|&=
operator|~
name|DECAWM
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/*  auto repeat	 */
if|if
condition|(
name|sp
operator|->
name|s_term_mode
operator|&
name|DECARM
condition|)
block|{
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCNRPT
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|s_term_mode
operator|&=
operator|~
name|DECARM
expr_stmt|;
break|break;
case|case
literal|25
case|:
comment|/* cursor non-active */
name|sp
operator|->
name|s_term_mode
operator|&=
operator|~
name|DECCSR_ACTV
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
default|default:
break|break;
block|}
name|cursor_on
argument_list|(
operator|&
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
block|}
else|else
block|{
comment|/*  buffering  arguments	*/
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
operator|*
name|esc_bp
operator|=
operator|*
name|esc_bp
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
name|esc_bp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
block|{
name|esc_buf
index|[
literal|0
index|]
operator|=
name|INVALID
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *  changes cursor key pad to ansi_ctl  */
end_comment

begin_expr_stmt
specifier|static
name|change_csr_key_pad
argument_list|(
name|applic
argument_list|)
specifier|register
name|int
name|applic
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|pad
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|Pfk_string
modifier|*
name|pfk
init|=
operator|&
name|pfk_str
decl_stmt|;
specifier|register
name|Key_string
modifier|*
name|kys
init|=
operator|&
name|pfk_str
operator|.
name|pfk_string
decl_stmt|;
specifier|register
name|struct
name|key_pad
modifier|*
name|kpd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|kpd
operator|=
operator|&
name|key_pad
index|[
name|UP
operator|-
name|N0
index|]
expr_stmt|;
name|pad
index|[
literal|0
index|]
operator|=
literal|'\033'
expr_stmt|;
name|pad
index|[
literal|1
index|]
operator|=
operator|(
name|applic
operator|)
condition|?
literal|'O'
else|:
literal|'['
expr_stmt|;
for|for
control|(
name|i
operator|=
name|UP
init|;
name|i
operator|<=
name|LEFT
condition|;
name|i
operator|++
control|)
block|{
name|pfk
operator|->
name|pfk_num
operator|=
name|i
expr_stmt|;
name|kys
operator|->
name|key_length
operator|=
operator|(
name|applic
operator|)
condition|?
literal|3
else|:
literal|3
expr_stmt|;
name|pad
index|[
literal|2
index|]
operator|=
operator|(
name|applic
operator|)
condition|?
name|kpd
operator|->
name|kpd_applic
else|:
name|kpd
operator|->
name|kpd_numeric
expr_stmt|;
name|kys
operator|->
name|key_string
operator|=
name|pad
expr_stmt|;
name|kpd
operator|++
expr_stmt|;
name|pfk
operator|->
name|pfk_shift
operator|=
name|PF_NORMAL
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCSETS
argument_list|,
name|pfk
argument_list|)
expr_stmt|;
name|pfk
operator|->
name|pfk_shift
operator|=
name|PF_SHIFT
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCSETS
argument_list|,
name|pfk
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|extern
name|struct
name|cursor
name|inner_buf_csr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|inner_buf_tstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Store cursor position and attributes.  *  The SCREEN structure is stored inner structure.  */
end_comment

begin_expr_stmt
name|esc_store_csr
argument_list|(
name|sp
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|inner_buf_csr
operator|=
name|sp
operator|->
name|s_csr
expr_stmt|;
name|inner_buf_tstat
operator|=
operator|(
name|DECOM
operator||
name|DECAWM
operator|)
operator|&
name|sp
operator|->
name|s_term_mode
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Restore cursor position and attributes.  *  The SCREEN structure  is restored from inner structure.  *  Prevail error from unexpected use of this command, inner structure  *  must be initialized.  */
end_comment

begin_expr_stmt
name|esc_restore_csr
argument_list|(
name|sp
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|cursor_off
argument_list|()
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|=
name|inner_buf_csr
expr_stmt|;
name|sp
operator|->
name|s_term_mode
operator|=
operator|(
name|sp
operator|->
name|s_term_mode
operator|&
operator|~
operator|(
name|DECOM
operator||
name|DECAWM
operator|)
operator|)
operator||
name|inner_buf_tstat
expr_stmt|;
name|cursor_on
argument_list|(
operator|&
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  index()  *  esc_index(sp) moves the cursor down if the cursor is not at  *  bottom margin. If the cursor is at the bottom margin then  *  scroll up.  */
end_comment

begin_expr_stmt
name|esc_index
argument_list|(
name|sp
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|cursor_off
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|==
name|sp
operator|->
name|s_region
operator|.
name|btm_margin
condition|)
name|scroll_up
argument_list|(
name|sp
operator|->
name|s_region
operator|.
name|top_margin
argument_list|,
name|sp
operator|->
name|s_region
operator|.
name|btm_margin
argument_list|,
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
argument_list|,
name|sp
operator|->
name|s_plane
argument_list|,
name|sp
operator|->
name|s_bgcol
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|<
name|btm_m
condition|)
block|{
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|+=
literal|1
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|y
operator|+=
name|char_h
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|WRAP
expr_stmt|;
name|cursor_on
argument_list|(
operator|&
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  next line  *  esc_next_line(sp) moves the cursor down like index but the cursor  *  position is the beginning of the next line.  */
end_comment

begin_expr_stmt
name|esc_next_line
argument_list|(
name|sp
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|=
name|LFT_M
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|x
operator|=
name|x_ofst
expr_stmt|;
name|esc_index
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  tabulation set  *  esc_tab_set(sp) sets tabulation stop at the current cursor point.  */
end_comment

begin_expr_stmt
name|esc_tab_set
argument_list|(
name|sp
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|sp
operator|->
name|s_tab_pos
index|[
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  reverse index  *  esc_rev_index(sp) moves the cursor up if the cursor is not at the top   *  margin. If the cursor is at the top margin then the screen takes place  *  scroll down.  */
end_comment

begin_expr_stmt
name|esc_rev_index
argument_list|(
name|sp
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|cursor_off
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|==
name|sp
operator|->
name|s_region
operator|.
name|top_margin
condition|)
name|scroll_down
argument_list|(
name|sp
operator|->
name|s_region
operator|.
name|top_margin
argument_list|,
name|sp
operator|->
name|s_region
operator|.
name|btm_margin
argument_list|,
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
argument_list|,
name|sp
operator|->
name|s_plane
argument_list|,
name|sp
operator|->
name|s_bgcol
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|>
name|TOP_M
condition|)
block|{
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|-=
literal|1
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|y
operator|-=
name|char_h
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|WRAP
expr_stmt|;
name|cursor_on
argument_list|(
operator|&
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  numeric key pad  *  esc_numeric_kpad(sp) changes key pad of cursor to numeric one.  *  This sequence is used in vi.  *  currently not supported  */
end_comment

begin_expr_stmt
name|esc_numeric_kpad
argument_list|(
name|sp
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|change_aux_key_pad
argument_list|(
name|NUMERIC
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  application key pad  *  esc_application_kpad(sp) changes key pad of cursor to application one.  *  This sequence is also used in vi.  *  currently not supported.  */
end_comment

begin_expr_stmt
name|esc_application_kpad
argument_list|(
name|sp
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|change_aux_key_pad
argument_list|(
name|APPLIC
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  change auxiliary keypad  */
end_comment

begin_expr_stmt
specifier|static
name|change_aux_key_pad
argument_list|(
name|applic
argument_list|)
specifier|register
name|int
name|applic
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|pad
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|Pfk_string
modifier|*
name|pfk
init|=
operator|&
name|pfk_str
decl_stmt|;
specifier|register
name|Key_string
modifier|*
name|kys
init|=
operator|&
name|pfk_str
operator|.
name|pfk_string
decl_stmt|;
specifier|register
name|struct
name|key_pad
modifier|*
name|kpd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|kpd
operator|=
operator|&
name|key_pad
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|applic
condition|)
block|{
name|pad
index|[
literal|0
index|]
operator|=
literal|'\033'
expr_stmt|;
name|pad
index|[
literal|1
index|]
operator|=
literal|'O'
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|N0
init|;
name|i
operator|<=
name|NENTER
condition|;
name|i
operator|++
control|)
block|{
name|pfk
operator|->
name|pfk_num
operator|=
name|i
expr_stmt|;
name|kys
operator|->
name|key_length
operator|=
operator|(
name|applic
operator|)
condition|?
literal|3
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|applic
condition|)
block|{
name|pad
index|[
literal|2
index|]
operator|=
name|kpd
operator|->
name|kpd_applic
expr_stmt|;
block|}
else|else
block|{
name|pad
index|[
literal|0
index|]
operator|=
name|kpd
operator|->
name|kpd_numeric
expr_stmt|;
block|}
name|kys
operator|->
name|key_string
operator|=
name|pad
expr_stmt|;
name|kpd
operator|++
expr_stmt|;
name|pfk
operator|->
name|pfk_shift
operator|=
name|PF_NORMAL
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCSETS
argument_list|,
name|pfk
argument_list|)
expr_stmt|;
name|pfk
operator|->
name|pfk_shift
operator|=
name|PF_SHIFT
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCSETS
argument_list|,
name|pfk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|applic
condition|)
block|{
name|pfk
operator|->
name|pfk_shift
operator|=
name|PF_SHIFT
expr_stmt|;
name|kys
operator|->
name|key_length
operator|=
literal|1
expr_stmt|;
name|pfk
operator|->
name|pfk_num
operator|=
name|MINUS
expr_stmt|;
name|kys
operator|->
name|key_string
operator|=
literal|"/"
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCSETS
argument_list|,
name|pfk
argument_list|)
expr_stmt|;
name|pfk
operator|->
name|pfk_num
operator|=
name|PLUS
expr_stmt|;
name|kys
operator|->
name|key_string
operator|=
literal|"*"
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCSETS
argument_list|,
name|pfk
argument_list|)
expr_stmt|;
name|pfk
operator|->
name|pfk_num
operator|=
name|COMMA
expr_stmt|;
name|kys
operator|->
name|key_string
operator|=
literal|"="
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCSETS
argument_list|,
name|pfk
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|extern
name|struct
name|csr_buf
name|local_csr_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  change line size  *  esc_line_size(sp, pn) changes line size.  *	c = `3'	double side double height(top half)  *	c = `4'	double side double height(bottom half)  *	c = `5'	sigle width line  *	c = `6'	double width line  *  currently not supported  */
end_comment

begin_expr_stmt
name|esc_line_size
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|save_f
decl_stmt|,
name|save_b
decl_stmt|;
name|cursor_off
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'5'
case|:
name|local_csr_buf
operator|.
name|csr_number
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|local_csr_buf
operator|.
name|csr_number
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|sp
operator|->
name|s_region
operator|.
name|top_margin
operator|=
name|TOP_M
expr_stmt|;
name|sp
operator|->
name|s_region
operator|.
name|btm_margin
operator|=
name|btm_m
expr_stmt|;
name|save_f
operator|=
name|fcolor
expr_stmt|;
name|save_b
operator|=
name|bcolor
expr_stmt|;
name|fcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|y
operator|=
name|y_ofst
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TOP_M
init|;
name|i
operator|<=
name|btm_m
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|x
operator|=
name|x_ofst
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
name|LFT_M
init|;
name|j
operator|<=
name|rit_m
condition|;
name|j
operator|++
control|)
block|{
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|=
name|j
expr_stmt|;
name|copy_char
argument_list|(
name|sp
argument_list|,
literal|'E'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|x
operator|+=
name|char_w
expr_stmt|;
block|}
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|y
operator|+=
name|char_h
expr_stmt|;
block|}
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|=
name|LFT_M
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|=
name|TOP_M
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|x
operator|=
name|x_ofst
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|y
operator|=
name|y_ofst
expr_stmt|;
name|fcolor
operator|=
name|save_f
expr_stmt|;
name|bcolor
operator|=
name|save_b
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|cursor_on
argument_list|(
operator|&
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  character set  *  esc_char_setr sets which character set you use in right graphic set.  *  currently not supported  */
end_comment

begin_expr_stmt
name|esc_char_setr
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPC_MRX
argument_list|)
operator|||
name|defined
argument_list|(
name|CPU_SINGLE
argument_list|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'J'
case|:
case|case
literal|'H'
case|:
name|font_jisroman
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CPU_SINGLE
name|font_jisroman24
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|JKANJI
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|font_ascii
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CPU_SINGLE
name|font_ascii24
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|JKANJI
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/* IPC_MRX || CPU_SINGLE */
if|if
condition|(
name|c
operator|==
literal|'B'
operator|||
name|c
operator|==
literal|'J'
operator|||
name|c
operator|==
literal|'H'
condition|)
block|{
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|JKANJI
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPC_MRX || CPU_SINGLE */
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  character set to left graphic set  *  esc_char_setl sets which character set you use in left graphic set.  *  currently not supported  */
end_comment

begin_expr_stmt
name|esc_char_setl
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
block|}
end_block

begin_extern
extern|extern tmode;
end_extern

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|first_jcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  character set to kanji  *  esc_kanji_set sets kanji  */
end_comment

begin_expr_stmt
name|esc_kanji_set
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|KM_JIS
if|if
condition|(
name|tmode
operator|==
name|KM_JIS
operator|&&
operator|(
name|c
operator|==
literal|'B'
operator|||
name|c
operator|==
literal|'@'
operator|)
condition|)
block|{
name|sp
operator|->
name|s_current_stat
operator||=
name|JKANJI
expr_stmt|;
name|first_jcode
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|short
name|parm_buf
index|[
name|PARM_BUF_SIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|parm_bp
init|=
name|parm_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sensitive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pval
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  terminal parameter set command  *  esc_parm_set(sp, c)  sets terminal parameters such as font-width,   *  font-height, character-width, character-height, character-position,  *  underlind-position, screen-width, screen-height, x-offset, y-offset,  *  right-mergin, bottom-mergin, dimmer-count, bell-length.  */
end_comment

begin_expr_stmt
name|esc_parm_set
argument_list|(
name|sp
argument_list|,
name|c
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|bufc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|in_str
argument_list|(
name|c
argument_list|,
name|sp
operator|->
name|s_estp
operator|->
name|terminators
argument_list|)
condition|)
block|{
if|if
condition|(
name|sensitive
condition|)
block|{
operator|*
name|parm_bp
operator|++
operator|=
name|pval
expr_stmt|;
block|}
else|else
block|{
operator|*
name|parm_bp
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
name|parm_bp
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
name|parm_set
argument_list|(
name|sp
argument_list|,
name|parm_buf
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
name|sensitive
operator|=
name|pval
operator|=
literal|0
expr_stmt|;
name|parm_bp
operator|=
name|parm_buf
expr_stmt|;
name|bufc
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*  buffering arguments  */
if|if
condition|(
name|bufc
operator|<
name|PARM_BUF_SIZ
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|pval
operator|=
name|pval
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|sensitive
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
name|sensitive
condition|)
block|{
operator|*
name|parm_bp
operator|++
operator|=
name|pval
expr_stmt|;
block|}
else|else
block|{
operator|*
name|parm_bp
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|sensitive
operator|=
name|pval
operator|=
literal|0
expr_stmt|;
name|bufc
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
name|sensitive
operator|=
name|pval
operator|=
literal|0
expr_stmt|;
name|parm_bp
operator|=
name|parm_buf
expr_stmt|;
name|bufc
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|an_buf
index|[
name|AN_BUF_SIZ
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|parm_set
argument_list|(
argument|sp
argument_list|,
argument|parm
argument_list|,
argument|terminator
argument_list|)
end_macro

begin_decl_stmt
name|SCREEN
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|parm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|terminator
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|bp
init|=
name|an_buf
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|terminator
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
name|parm
index|[
literal|0
index|]
operator|>=
name|FONT_W_MIN
operator|&&
name|parm
index|[
literal|0
index|]
operator|<=
name|consfb
operator|->
name|font_w
operator|&&
name|parm
index|[
literal|0
index|]
operator|<
name|char_w
condition|)
name|font_w
operator|=
name|parm
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|parm
index|[
literal|1
index|]
operator|>=
name|FONT_H_MIN
operator|&&
name|parm
index|[
literal|1
index|]
operator|<=
name|consfb
operator|->
name|font_h
operator|&&
name|parm
index|[
literal|1
index|]
operator|<=
operator|(
name|char_h
operator|-
name|ch_pos
operator|)
condition|)
name|font_h
operator|=
name|parm
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|parm
index|[
literal|0
index|]
operator|>=
name|CHAR_W_MIN
operator|&&
name|parm
index|[
literal|0
index|]
operator|>
name|font_w
operator|&&
name|parm
index|[
literal|0
index|]
operator|<=
name|CHAR_W_MAX
condition|)
name|char_w
operator|=
name|parm
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|parm
index|[
literal|1
index|]
operator|>=
name|CHAR_H_MIN
operator|&&
name|parm
index|[
literal|1
index|]
operator|>=
operator|(
name|font_h
operator|+
name|ch_pos
operator|)
operator|&&
name|parm
index|[
literal|1
index|]
operator|>
name|ul_pos
operator|&&
name|parm
index|[
literal|1
index|]
operator|<=
name|CHAR_H_MAX
condition|)
name|char_h
operator|=
name|parm
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|parm
index|[
literal|0
index|]
operator|>=
name|UL_POS_MIN
operator|&&
name|parm
index|[
literal|0
index|]
operator|<=
name|UL_POS_MAX
operator|&&
name|parm
index|[
literal|0
index|]
operator|<
name|char_h
condition|)
block|{
name|ul_pos
operator|=
name|parm
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|parm
index|[
literal|1
index|]
operator|>=
name|CH_POS_MIN
operator|&&
name|parm
index|[
literal|1
index|]
operator|<=
name|CH_POS_MAX
operator|&&
name|parm
index|[
literal|1
index|]
operator|<
operator|(
name|char_h
operator|-
name|font_h
operator|)
condition|)
block|{
name|ch_pos
operator|=
name|parm
index|[
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|parm
index|[
literal|0
index|]
operator|>
name|SCR_W_MIN
operator|&&
name|parm
index|[
literal|0
index|]
operator|<=
name|consfb
operator|->
name|scr_w
condition|)
name|scr_w
operator|=
operator|(
name|parm
index|[
literal|0
index|]
operator|<
name|char_w
operator|)
condition|?
name|char_w
else|:
name|parm
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|parm
index|[
literal|1
index|]
operator|>
name|SCR_H_MIN
operator|&&
name|parm
index|[
literal|1
index|]
operator|<=
name|consfb
operator|->
name|scr_h
condition|)
name|scr_h
operator|=
operator|(
name|parm
index|[
literal|1
index|]
operator|<
name|char_h
operator|)
condition|?
name|char_h
else|:
name|parm
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|parm
index|[
literal|0
index|]
operator|>=
name|X_OFST_MIN
operator|&&
name|parm
index|[
literal|0
index|]
operator|<=
name|X_OFST_MAX
condition|)
name|x_ofst
operator|=
operator|(
name|parm
index|[
literal|0
index|]
operator|>
name|scr_w
operator|-
name|char_w
operator|)
condition|?
operator|(
name|scr_w
operator|-
name|char_w
operator|)
else|:
name|parm
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|parm
index|[
literal|1
index|]
operator|>=
name|Y_OFST_MIN
operator|&&
name|parm
index|[
literal|1
index|]
operator|<=
name|Y_OFST_MAX
condition|)
name|y_ofst
operator|=
operator|(
name|parm
index|[
literal|1
index|]
operator|>
name|scr_h
operator|-
name|char_h
operator|)
condition|?
operator|(
name|scr_h
operator|-
name|char_h
operator|)
else|:
name|parm
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|parm
index|[
literal|0
index|]
operator|>=
name|RIT_M_MIN
condition|)
block|{
if|if
condition|(
name|parm
index|[
literal|0
index|]
operator|>
name|RIT_M_MAX
comment|/* consfb->rit_m */
condition|)
block|{
name|parm
index|[
literal|0
index|]
operator|=
name|consfb
operator|->
name|rit_m
expr_stmt|;
block|}
name|rit_m
operator|=
operator|(
name|parm
index|[
literal|0
index|]
operator|>
operator|(
name|scr_w
operator|-
name|x_ofst
operator|)
operator|/
name|char_w
operator|)
condition|?
operator|(
name|scr_w
operator|-
name|x_ofst
operator|)
operator|/
name|char_w
else|:
name|parm
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|parm
index|[
literal|1
index|]
operator|>=
name|BTM_M_MIN
condition|)
block|{
if|if
condition|(
name|parm
index|[
literal|1
index|]
operator|>
name|BTM_M_MAX
comment|/* consfb->btm_m */
condition|)
block|{
name|parm
index|[
literal|1
index|]
operator|=
name|consfb
operator|->
name|btm_m
expr_stmt|;
block|}
name|btm_m
operator|=
operator|(
name|parm
index|[
literal|1
index|]
operator|>
operator|(
name|scr_h
operator|-
name|y_ofst
operator|)
operator|/
name|char_h
operator|)
condition|?
operator|(
name|scr_h
operator|-
name|y_ofst
operator|)
operator|/
name|char_h
else|:
name|parm
index|[
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|parm
index|[
literal|0
index|]
operator|>=
name|DIM_CNT_MIN
operator|&&
name|parm
index|[
literal|0
index|]
operator|<=
name|DIM_CNT_MAX
condition|)
name|dim_cnt
operator|=
name|a_dim_on
operator|=
name|parm
index|[
literal|0
index|]
expr_stmt|;
else|else
name|a_dim_on
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|parm
index|[
literal|0
index|]
operator|>=
name|BELL_LEN_MIN
operator|&&
name|parm
index|[
literal|0
index|]
operator|<=
name|BELL_LEN_MAX
condition|)
name|bell_len
operator|=
name|parm
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|set_default_param
argument_list|()
expr_stmt|;
name|vt100init
argument_list|()
expr_stmt|;
name|bitmapinit
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|cursor_off
argument_list|()
expr_stmt|;
name|csr_pos
argument_list|(
name|sp
argument_list|,
name|LFT_M
argument_list|,
name|TOP_M
argument_list|)
expr_stmt|;
name|key_str
operator|.
name|key_string
operator|=
name|c_pos_mess
expr_stmt|;
name|key_str
operator|.
name|key_length
operator|=
name|spr
argument_list|(
name|c_pos_mess
argument_list|,
literal|"f=(%d,%d), "
argument_list|,
name|font_w
argument_list|,
name|font_h
argument_list|)
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCBACK
argument_list|,
operator|&
name|key_str
argument_list|)
expr_stmt|;
name|key_str
operator|.
name|key_length
operator|=
name|spr
argument_list|(
name|c_pos_mess
argument_list|,
literal|"c=(%d,%d), "
argument_list|,
name|char_w
argument_list|,
name|char_h
argument_list|)
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCBACK
argument_list|,
operator|&
name|key_str
argument_list|)
expr_stmt|;
name|csr_pos
argument_list|(
name|sp
argument_list|,
name|LFT_M
argument_list|,
operator|(
name|TOP_M
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|key_str
operator|.
name|key_string
operator|=
name|c_pos_mess
expr_stmt|;
name|key_str
operator|.
name|key_length
operator|=
name|spr
argument_list|(
name|c_pos_mess
argument_list|,
literal|"p=(%d,%d), "
argument_list|,
name|ul_pos
argument_list|,
name|ch_pos
argument_list|)
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCBACK
argument_list|,
operator|&
name|key_str
argument_list|)
expr_stmt|;
name|key_str
operator|.
name|key_length
operator|=
name|spr
argument_list|(
name|c_pos_mess
argument_list|,
literal|"s=(%d,%d), "
argument_list|,
name|scr_w
argument_list|,
name|scr_h
argument_list|)
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCBACK
argument_list|,
operator|&
name|key_str
argument_list|)
expr_stmt|;
name|csr_pos
argument_list|(
name|sp
argument_list|,
name|LFT_M
argument_list|,
operator|(
name|TOP_M
operator|-
literal|2
operator|)
argument_list|)
expr_stmt|;
name|key_str
operator|.
name|key_string
operator|=
name|c_pos_mess
expr_stmt|;
name|key_str
operator|.
name|key_length
operator|=
name|spr
argument_list|(
name|c_pos_mess
argument_list|,
literal|"o=(%d,%d), "
argument_list|,
name|x_ofst
argument_list|,
name|y_ofst
argument_list|)
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCBACK
argument_list|,
operator|&
name|key_str
argument_list|)
expr_stmt|;
name|key_str
operator|.
name|key_length
operator|=
name|spr
argument_list|(
name|c_pos_mess
argument_list|,
literal|"m=(%d,%d)"
argument_list|,
name|rit_m
argument_list|,
name|btm_m
argument_list|)
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCBACK
argument_list|,
operator|&
name|key_str
argument_list|)
expr_stmt|;
name|cursor_on
argument_list|(
operator|&
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'G'
case|:
name|line
argument_list|(
name|parm
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'C'
case|:
if|if
condition|(
name|parm
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|sp
operator|->
name|s_plane
operator|=
name|fbbm_get_pixel
argument_list|(
name|consfb
argument_list|,
name|parm
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parm
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
block|{
name|sp
operator|->
name|s_bgcol
operator|=
name|fbbm_get_pixel
argument_list|(
name|consfb
argument_list|,
name|parm
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|cursor_off
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_attributes
operator|&
name|REVERSE
operator|)
operator|^
operator|(
name|sp
operator|->
name|s_term_mode
operator|&
name|DECSCNM
operator|)
condition|)
block|{
name|fcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
block|}
else|else
block|{
name|fcolor
operator|=
name|sp
operator|->
name|s_plane
expr_stmt|;
name|bcolor
operator|=
name|sp
operator|->
name|s_bgcol
expr_stmt|;
block|}
name|cursor_on
argument_list|(
operator|&
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
if|if
condition|(
name|parm
index|[
literal|0
index|]
operator|<
literal|0
operator|||
name|consfb
operator|->
name|Mono
condition|)
return|return;
comment|/* 		 *  what value is defined on pallet N? 		 *    put string in an_buf 		 */
operator|*
name|bp
operator|++
operator|=
literal|'\033'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'~'
expr_stmt|;
name|bp
operator|+=
name|itoa
argument_list|(
name|bm_pallet_read
argument_list|(
name|parm
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|10
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'a'
expr_stmt|;
name|key_str
operator|.
name|key_length
operator|=
name|bp
operator|-
name|an_buf
expr_stmt|;
name|key_str
operator|.
name|key_string
operator|=
name|an_buf
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCBACK
argument_list|,
operator|&
name|key_str
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'t'
case|:
if|if
condition|(
name|parm
index|[
literal|0
index|]
operator|>=
literal|0
operator|&&
operator|!
name|consfb
operator|->
name|Mono
condition|)
block|{
name|bm_pallet_write
argument_list|(
name|parm
index|[
literal|0
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|parm
index|[
literal|1
index|]
operator|<<
literal|16
operator||
operator|(
name|unsigned
operator|)
name|parm
index|[
literal|2
index|]
operator|<<
literal|8
operator||
operator|(
name|unsigned
operator|)
name|parm
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
return|return;
block|}
if|if
condition|(
name|char_w
operator|<
name|font_w
condition|)
name|char_w
operator|=
name|font_w
expr_stmt|;
if|if
condition|(
name|char_h
operator|<
name|font_h
condition|)
name|char_h
operator|=
name|font_h
expr_stmt|;
if|if
condition|(
name|ch_pos
operator|>
name|char_h
operator|-
name|font_h
condition|)
block|{
name|ch_pos
operator|=
name|char_h
operator|-
name|font_h
expr_stmt|;
name|ul_pos
operator|=
name|char_h
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rit_m
operator|>
operator|(
name|scr_w
operator|-
name|x_ofst
operator|)
operator|/
name|char_w
condition|)
name|rit_m
operator|=
operator|(
name|scr_w
operator|-
name|x_ofst
operator|)
operator|/
name|char_w
expr_stmt|;
if|if
condition|(
name|btm_m
operator|>
operator|(
name|scr_h
operator|-
name|y_ofst
operator|)
operator|/
name|char_h
condition|)
name|btm_m
operator|=
operator|(
name|scr_h
operator|-
name|y_ofst
operator|)
operator|/
name|char_h
expr_stmt|;
name|sp
operator|->
name|s_region
operator|.
name|top_margin
operator|=
name|TOP_M
expr_stmt|;
name|sp
operator|->
name|s_region
operator|.
name|btm_margin
operator|=
name|btm_m
expr_stmt|;
name|font_r1
operator|.
name|extent
operator|.
name|x
operator|=
name|font_w
expr_stmt|;
name|font_r1
operator|.
name|extent
operator|.
name|y
operator|=
name|font_h
expr_stmt|;
name|font_r2
operator|.
name|extent
operator|.
name|x
operator|=
name|font_w
operator|*
literal|2
expr_stmt|;
name|font_r2
operator|.
name|extent
operator|.
name|y
operator|=
name|font_h
expr_stmt|;
name|font_len1
operator|=
operator|(
name|font_w
operator|+
literal|0x0f
operator|)
operator|>>
literal|4
expr_stmt|;
name|font_len2
operator|=
operator|(
name|font_w
operator|*
literal|2
operator|+
literal|0x0f
operator|)
operator|>>
literal|4
expr_stmt|;
name|cursor_off
argument_list|()
expr_stmt|;
name|char_r1
operator|.
name|extent
operator|.
name|x
operator|=
name|char_w
expr_stmt|;
name|char_r1
operator|.
name|extent
operator|.
name|y
operator|=
name|char_h
expr_stmt|;
name|char_r2
operator|.
name|extent
operator|.
name|x
operator|=
name|char_w
operator|*
literal|2
expr_stmt|;
name|char_r2
operator|.
name|extent
operator|.
name|y
operator|=
name|char_h
expr_stmt|;
name|csr_pos
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
argument_list|,
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|x
operator|=
operator|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_x
operator|-
literal|1
operator|)
operator|*
name|char_w
operator|+
name|x_ofst
expr_stmt|;
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
operator|.
name|y
operator|=
operator|(
name|sp
operator|->
name|s_csr
operator|.
name|csr_y
operator|-
literal|1
operator|)
operator|*
name|char_h
operator|+
name|y_ofst
expr_stmt|;
name|cursor_on
argument_list|(
operator|&
name|sp
operator|->
name|s_csr
operator|.
name|csr_p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS */
end_comment

begin_expr_stmt
name|spr
argument_list|(
name|s
argument_list|,
name|fmt
argument_list|,
name|ad
argument_list|,
name|dummy
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|fmt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|ad
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|b
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|u_int
modifier|*
name|adx
init|=
operator|&
name|ad
decl_stmt|;
name|char
modifier|*
name|base
init|=
name|s
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|!=
literal|'%'
condition|)
block|{
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|s
operator|-
name|base
operator|-
literal|1
operator|)
return|;
block|}
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|b
operator|=
literal|16
expr_stmt|;
goto|goto
name|number
goto|;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|b
operator|=
literal|10
expr_stmt|;
goto|goto
name|number
goto|;
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|b
operator|=
literal|8
expr_stmt|;
name|number
label|:
name|s
operator|+=
name|itoa
argument_list|(
operator|*
name|adx
argument_list|,
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
operator|*
name|s
operator|++
operator|=
operator|*
name|adx
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|adx
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|pfn
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|active_buf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  define the programable function keys and answer back message.  *  the vt100 facilities do not contain this command!  *  command sequence is as follows:  *       "^[Pn|n1;n2;...;nmp"		(normal mode)  *  or  *       "^[Pn|n1;n2;...;nmP"		(shift mode)  *  or  *       "^[Pn|n1;n2;...;nmZ"		(answer backe message)  *  where, `n' denotes the decimal number asigned to function key,  *          from `n1' to `nm' denote hexa number, finally,  *	    `p' , `E' or `Z' tells that the sequence has terminated.  *  remark:  *	  when the terminator is `Z', the function number `n' can be omitted,  *	  and even though the number is specified, there is no affection to   *	  the result.  *  *  *  ADDITION:  *	  there is a question: what strings are defined in programable function  *	  key of key-number n?  *	  in order to anwer this question, another escape sequence has appended.  *	  command sequence is as follows:  *  *	   "^[Pn|i"			(normal mode)  *  or  *	   "^[Pn|I"			(shift	mode)  *  *	  then the answer is   *  *	   "^[Pn|n1;n2;...;nmr"		(normal	mode)  *  or  *	   "^[Pn|n1;n2;...;nmR"		(shift	mode)  *  */
end_comment

begin_macro
name|esc_pf_define
argument_list|(
argument|sp
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|SCREEN
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|bufc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|in_str
argument_list|(
name|c
argument_list|,
name|sp
operator|->
name|s_estp
operator|->
name|terminators
argument_list|)
condition|)
block|{
name|pf_define
argument_list|(
name|pfn
argument_list|,
name|esc_bp
operator|-
name|esc_buf
operator|+
name|active_buf
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
name|active_buf
operator|=
literal|0
expr_stmt|;
name|pfn
operator|=
operator|-
literal|1
expr_stmt|;
name|bufc
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*  buffering arguments  */
if|if
condition|(
name|bufc
operator|<
name|ESC_BUF_SIZ
condition|)
block|{
if|if
condition|(
name|pfn
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
operator|*
name|esc_bp
operator|=
operator|*
name|esc_bp
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'|'
condition|)
block|{
name|pfn
operator|=
operator|*
name|esc_bp
expr_stmt|;
operator|*
name|esc_bp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
name|active_buf
operator|=
literal|0
expr_stmt|;
name|pfn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|active_buf
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
operator|*
name|esc_bp
operator|=
operator|*
name|esc_bp
operator|*
literal|16
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
block|{
operator|*
name|esc_bp
operator|=
operator|*
name|esc_bp
operator|*
literal|16
operator|+
operator|(
name|c
operator|-
literal|'a'
operator|+
literal|10
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
block|{
operator|*
name|esc_bp
operator|=
operator|*
name|esc_bp
operator|*
literal|16
operator|+
operator|(
name|c
operator|-
literal|'A'
operator|+
literal|10
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
name|esc_bp
operator|++
expr_stmt|;
name|bufc
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
name|pfn
operator|=
operator|-
literal|1
expr_stmt|;
name|active_buf
operator|=
literal|0
expr_stmt|;
name|bufc
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|active_buf
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|pf_define
argument_list|(
argument|pfn
argument_list|,
argument|length
argument_list|,
argument|terminator
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pfn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|terminator
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Pfk_string
modifier|*
name|pfk
init|=
operator|&
name|pfk_str
decl_stmt|;
specifier|register
name|Key_string
modifier|*
name|kys
init|=
operator|&
name|pfk_str
operator|.
name|pfk_string
decl_stmt|;
if|if
condition|(
name|terminator
operator|==
literal|'Z'
condition|)
return|return;
if|if
condition|(
name|pfn
operator|<
literal|0
operator|||
name|pfn
operator|>
name|N_PFK
condition|)
return|return;
if|if
condition|(
name|terminator
operator|==
literal|'i'
operator|||
name|terminator
operator|==
literal|'I'
condition|)
block|{
name|pf_answer
argument_list|(
name|pfn
argument_list|,
name|terminator
argument_list|)
expr_stmt|;
return|return;
block|}
name|pfk
operator|->
name|pfk_num
operator|=
name|pfn
condition|?
name|pfn
else|:
literal|1
expr_stmt|;
name|pfk
operator|->
name|pfk_shift
operator|=
operator|(
name|terminator
operator|==
literal|'p'
operator|)
condition|?
name|PF_NORMAL
else|:
name|PF_SHIFT
expr_stmt|;
name|kys
operator|->
name|key_length
operator|=
name|length
expr_stmt|;
name|kys
operator|->
name|key_string
operator|=
name|esc_buf
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCSETS
argument_list|,
name|pfk
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  pf_answer(pfn, terminator)  *  this routine answers what strings defined on pfn.  */
end_comment

begin_decl_stmt
name|char
name|def_seq
index|[
name|ESC_BUF_SIZ
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|pf_answer
argument_list|(
argument|pfn
argument_list|,
argument|terminator
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pfn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|terminator
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Pfk_string
modifier|*
name|pfk
init|=
operator|&
name|pfk_str
decl_stmt|;
specifier|register
name|Key_string
modifier|*
name|kys
init|=
operator|&
name|pfk_str
operator|.
name|pfk_string
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
init|=
name|an_buf
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|def_seq
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
comment|/* 	 *  function key inquiry 	 *    get string in def_seq 	 */
name|pfk
operator|->
name|pfk_num
operator|=
name|pfn
condition|?
name|pfn
else|:
literal|1
expr_stmt|;
name|pfk
operator|->
name|pfk_shift
operator|=
operator|(
name|terminator
operator|==
literal|'i'
operator|)
condition|?
name|PF_NORMAL
else|:
name|PF_SHIFT
expr_stmt|;
name|kys
operator|->
name|key_length
operator|=
name|ESC_BUF_SIZ
expr_stmt|;
name|kys
operator|->
name|key_string
operator|=
name|def_seq
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCGETS
argument_list|,
name|pfk
argument_list|)
expr_stmt|;
name|length
operator|=
name|kys
operator|->
name|key_length
expr_stmt|;
comment|/* 	 *  function key answer 	 *    put string in an_buf 	 */
operator|*
name|bp
operator|++
operator|=
literal|'\033'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'P'
expr_stmt|;
name|bp
operator|+=
name|itoa
argument_list|(
name|pfn
argument_list|,
literal|10
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'|'
expr_stmt|;
name|key_str
operator|.
name|key_length
operator|=
name|bp
operator|-
name|an_buf
expr_stmt|;
name|key_str
operator|.
name|key_string
operator|=
name|an_buf
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCBACK
argument_list|,
operator|&
name|key_str
argument_list|)
expr_stmt|;
name|bp
operator|=
name|an_buf
expr_stmt|;
if|if
condition|(
name|length
operator|--
condition|)
block|{
name|bp
operator|+=
name|itoa
argument_list|(
operator|*
name|p
operator|++
operator|&
literal|0xff
argument_list|,
literal|16
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|<
literal|10
operator|)
operator|&&
operator|(
name|length
operator|--
operator|>
literal|0
operator|)
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|';'
expr_stmt|;
name|bp
operator|+=
name|itoa
argument_list|(
operator|*
name|p
operator|++
operator|&
literal|0xff
argument_list|,
literal|16
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|key_str
operator|.
name|key_length
operator|=
name|bp
operator|-
name|an_buf
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCBACK
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|key_str
argument_list|)
expr_stmt|;
name|bp
operator|=
name|an_buf
expr_stmt|;
block|}
operator|*
name|bp
operator|++
operator|=
operator|(
name|terminator
operator|==
literal|'i'
operator|)
condition|?
literal|'r'
else|:
literal|'R'
expr_stmt|;
name|key_str
operator|.
name|key_length
operator|=
name|bp
operator|-
name|an_buf
expr_stmt|;
name|kbd_ioctl
argument_list|(
name|SCC_KEYBOARD
argument_list|,
name|KIOCBACK
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|key_str
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  ignore  *  esc_ignore(sp) is not called ordinally work.  */
end_comment

begin_expr_stmt
name|esc_ignore
argument_list|(
name|sp
argument_list|)
specifier|register
name|SCREEN
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|sp
operator|->
name|s_current_stat
operator|&=
operator|~
name|ESCAPE
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nmr
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  itoa  *  this routine converts binary to ascii decimal or hexa number  *  according to mod.  */
end_comment

begin_expr_stmt
specifier|static
name|itoa
argument_list|(
name|n
argument_list|,
name|mod
argument_list|,
name|buf
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|mod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|int
name|k
decl_stmt|;
name|n
operator|&=
literal|0xffff
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|mod
operator|*
name|mod
operator|*
name|mod
operator|*
name|mod
operator|*
name|mod
operator|*
name|mod
operator|*
name|mod
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|/=
name|mod
control|)
block|{
name|k
operator|=
name|n
operator|/
name|cnt
expr_stmt|;
name|n
operator|-=
name|k
operator|*
name|cnt
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|first
operator|==
literal|0
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|nmr
index|[
name|k
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|buf
operator|++
operator|=
name|nmr
index|[
name|k
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
operator|==
literal|1
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
literal|'0'
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

end_unit

