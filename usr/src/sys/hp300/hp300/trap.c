begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: trap.c 1.28 89/09/25$  *  *	@(#)trap.c	7.2 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"cpu.h"
end_include

begin_include
include|#
directive|include
file|"psl.h"
end_include

begin_include
include|#
directive|include
file|"reg.h"
end_include

begin_include
include|#
directive|include
file|"pte.h"
end_include

begin_include
include|#
directive|include
file|"mtpr.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"seg.h"
end_include

begin_include
include|#
directive|include
file|"trap.h"
end_include

begin_include
include|#
directive|include
file|"acct.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|"ktrace.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HPUXCOMPAT
end_ifdef

begin_include
include|#
directive|include
file|"../hpux/hpux.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|USER
value|040
end_define

begin_comment
comment|/* user-mode flag added to type */
end_comment

begin_decl_stmt
name|struct
name|sysent
name|sysent
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsysent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|trap_type
index|[]
init|=
block|{
literal|"Bus error"
block|,
literal|"Address error"
block|,
literal|"Illegal instruction"
block|,
literal|"Zero divide"
block|,
literal|"CHK instruction"
block|,
literal|"TRAPV instruction"
block|,
literal|"Privilege violation"
block|,
literal|"Trace trap"
block|,
literal|"MMU fault"
block|,
literal|"SSIR trap"
block|,
literal|"Format error"
block|,
literal|"68881 exception"
block|,
literal|"Coprocessor violation"
block|,
literal|"Async system trap"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRAP_TYPES
value|(sizeof trap_type / sizeof trap_type[0])
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|mmudebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Called from the trap handler when a processor trap occurs.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|trap
argument_list|(
argument|type
argument_list|,
argument|code
argument_list|,
argument|v
argument_list|,
argument|frame
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|v
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frame
name|frame
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|ucode
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|u
operator|.
name|u_procp
decl_stmt|;
name|struct
name|timeval
name|syst
decl_stmt|;
name|unsigned
name|ncode
decl_stmt|;
name|cnt
operator|.
name|v_trap
operator|++
expr_stmt|;
name|syst
operator|=
name|u
operator|.
name|u_ru
operator|.
name|ru_stime
expr_stmt|;
if|if
condition|(
name|USERMODE
argument_list|(
name|frame
operator|.
name|f_sr
argument_list|)
condition|)
block|{
name|type
operator||=
name|USER
expr_stmt|;
name|u
operator|.
name|u_ar0
operator|=
name|frame
operator|.
name|f_regs
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|dopanic
label|:
ifdef|#
directive|ifdef
name|KGDB
if|if
condition|(
operator|!
name|panicstr
operator|&&
name|kgdb_trap
argument_list|(
name|type
argument_list|,
name|code
argument_list|,
name|v
argument_list|,
operator|&
name|frame
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|printf
argument_list|(
literal|"trap type %d, code = %x, v = %x\n"
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|regdump
argument_list|(
name|frame
operator|.
name|f_regs
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|type
operator|&=
operator|~
name|USER
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|type
operator|<
name|TRAP_TYPES
condition|)
name|panic
argument_list|(
name|trap_type
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
case|case
name|T_BUSERR
case|:
comment|/* kernel bus error */
if|if
condition|(
operator|!
name|u
operator|.
name|u_pcb
operator|.
name|pcb_onfault
condition|)
goto|goto
name|dopanic
goto|;
comment|/* 		 * If we have arranged to catch this fault in any of the 		 * copy to/from user space routines, set PC to return to 		 * indicated location and set flag informing buserror code 		 * that it may need to clean up stack frame. 		 */
name|copyfault
label|:
name|frame
operator|.
name|f_pc
operator|=
operator|(
name|int
operator|)
name|u
operator|.
name|u_pcb
operator|.
name|pcb_onfault
expr_stmt|;
name|frame
operator|.
name|f_stackadj
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
case|case
name|T_BUSERR
operator|+
name|USER
case|:
comment|/* bus error */
case|case
name|T_ADDRERR
operator|+
name|USER
case|:
comment|/* address error */
name|i
operator|=
name|SIGBUS
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FPCOPROC
case|case
name|T_COPERR
case|:
comment|/* kernel coprocessor violation */
endif|#
directive|endif
case|case
name|T_FMTERR
case|:
comment|/* kernel format error */
comment|/* 	 * The user has most likely trashed the RTE or FP state info 	 * in the stack frame of a signal handler. 	 */
name|type
operator||=
name|USER
expr_stmt|;
name|printf
argument_list|(
literal|"pid %d: kernel %s exception\n"
argument_list|,
name|u
operator|.
name|u_procp
operator|->
name|p_pid
argument_list|,
name|type
operator|==
name|T_COPERR
condition|?
literal|"coprocessor"
else|:
literal|"format"
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_signal
index|[
name|SIGILL
index|]
operator|=
name|SIG_DFL
expr_stmt|;
name|i
operator|=
name|sigmask
argument_list|(
name|SIGILL
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_sigignore
operator|&=
operator|~
name|i
expr_stmt|;
name|p
operator|->
name|p_sigcatch
operator|&=
operator|~
name|i
expr_stmt|;
name|p
operator|->
name|p_sigmask
operator|&=
operator|~
name|i
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was ILL_RESAD_FAULT */
break|break;
ifdef|#
directive|ifdef
name|FPCOPROC
case|case
name|T_COPERR
operator|+
name|USER
case|:
comment|/* user coprocessor violation */
comment|/* What is a proper response here? */
name|ucode
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_FPERR
operator|+
name|USER
case|:
comment|/* 68881 exceptions */
comment|/* 	 * We pass along the 68881 status register which locore stashed 	 * in code for us.  Note that there is a possibility that the 	 * bit pattern of this register will conflict with one of the 	 * FPE_* codes defined in signal.h.  Fortunately for us, the 	 * only such codes we use are all in the range 1-7 and the low 	 * 3 bits of the status register are defined as 0 so there is 	 * no clash. 	 */
name|ucode
operator|=
name|code
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|T_ILLINST
operator|+
name|USER
case|:
comment|/* illegal instruction fault */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
block|{
name|ucode
operator|=
name|HPUX_ILL_ILLINST_TRAP
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
block|}
comment|/* fall through */
endif|#
directive|endif
case|case
name|T_PRIVINST
operator|+
name|USER
case|:
comment|/* privileged instruction fault */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
name|ucode
operator|=
name|HPUX_ILL_PRIV_TRAP
expr_stmt|;
else|else
endif|#
directive|endif
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was ILL_PRIVIN_FAULT */
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_ZERODIV
operator|+
name|USER
case|:
comment|/* Divide by zero */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
name|ucode
operator|=
name|HPUX_FPE_INTDIV_TRAP
expr_stmt|;
else|else
endif|#
directive|endif
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was FPE_INTDIV_TRAP */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_CHKINST
operator|+
name|USER
case|:
comment|/* CHK instruction trap */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
block|{
comment|/* handled differently under hp-ux */
name|i
operator|=
name|SIGILL
expr_stmt|;
name|ucode
operator|=
name|HPUX_ILL_CHK_TRAP
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was FPE_SUBRNG_TRAP */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_TRAPVINST
operator|+
name|USER
case|:
comment|/* TRAPV instruction trap */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
block|{
comment|/* handled differently under hp-ux */
name|i
operator|=
name|SIGILL
expr_stmt|;
name|ucode
operator|=
name|HPUX_ILL_TRAPV_TRAP
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was FPE_INTOVF_TRAP */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
comment|/* 	 * XXX: Trace traps are a nightmare. 	 * 	 *	HP-UX uses trap #1 for breakpoints, 	 *	HPBSD uses trap #2, 	 *	SUN 3.x uses trap #15, 	 *	KGDB uses trap #15 (for kernel breakpoints). 	 * 	 * HPBSD and HP-UX traps both get mapped by locore.s into T_TRACE. 	 * SUN 3.x traps get passed through as T_TRAP15 and are not really 	 * supported yet.  KGDB traps are also passed through as T_TRAP15 	 * and are not used yet. 	 */
case|case
name|T_TRACE
case|:
comment|/* kernel trace trap */
case|case
name|T_TRAP15
case|:
comment|/* SUN (or KGDB) kernel trace trap */
ifdef|#
directive|ifdef
name|KGDB
if|if
condition|(
name|kgdb_trap
argument_list|(
name|type
argument_list|,
name|code
argument_list|,
name|v
argument_list|,
operator|&
name|frame
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|frame
operator|.
name|f_sr
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|T_TRACE
operator|+
name|USER
case|:
comment|/* user trace trap */
case|case
name|T_TRAP15
operator|+
name|USER
case|:
comment|/* SUN user trace trap */
ifdef|#
directive|ifdef
name|SUNCOMPAT
comment|/* 		 * Trap #2 is used to signal a cache flush. 		 * Should we also flush data cache? 		 */
if|if
condition|(
name|type
operator|==
name|T_TRACE
operator|+
name|USER
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SSUN
operator|)
condition|)
block|{
name|ICIA
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
name|frame
operator|.
name|f_sr
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|T_AST
case|:
comment|/* system async trap, cannot happen */
goto|goto
name|dopanic
goto|;
case|case
name|T_AST
operator|+
name|USER
case|:
comment|/* user async trap */
name|astoff
argument_list|()
expr_stmt|;
comment|/* 		 * We check for software interrupts first.  This is because 		 * they are at a higher level than ASTs, and on a VAX would 		 * interrupt the AST.  We assume that if we are processing 		 * an AST that we must be at IPL0 so we don't bother to 		 * check.  Note that we ensure that we are at least at SIR 		 * IPL while processing the SIR. 		 */
name|spl1
argument_list|()
expr_stmt|;
comment|/* fall into... */
case|case
name|T_SSIR
case|:
comment|/* software interrupt */
case|case
name|T_SSIR
operator|+
name|USER
case|:
if|if
condition|(
name|ssir
operator|&
name|SIR_NET
condition|)
block|{
name|siroff
argument_list|(
name|SIR_NET
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
name|netintr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ssir
operator|&
name|SIR_CLOCK
condition|)
block|{
name|siroff
argument_list|(
name|SIR_CLOCK
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
name|softclock
argument_list|(
operator|(
name|caddr_t
operator|)
name|frame
operator|.
name|f_pc
argument_list|,
operator|(
name|int
operator|)
name|frame
operator|.
name|f_sr
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If this was not an AST trap, we are all done. 		 */
if|if
condition|(
name|type
operator|!=
name|T_AST
operator|+
name|USER
condition|)
block|{
name|cnt
operator|.
name|v_trap
operator|--
expr_stmt|;
return|return;
block|}
name|spl0
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|PROFTIMER
if|if
condition|(
operator|(
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&
name|SOWEUPC
operator|)
operator|&&
name|u
operator|.
name|u_prof
operator|.
name|pr_scale
condition|)
block|{
name|addupc
argument_list|(
name|frame
operator|.
name|f_pc
argument_list|,
operator|&
name|u
operator|.
name|u_prof
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&=
operator|~
name|SOWEUPC
expr_stmt|;
block|}
endif|#
directive|endif
goto|goto
name|out
goto|;
case|case
name|T_MMUFLT
case|:
comment|/* kernel mode page fault */
comment|/* 		 * Could be caused by a page fault in one of the copy to/from 		 * user space routines.  If so, we will have a catch address. 		 */
if|if
condition|(
operator|!
name|u
operator|.
name|u_pcb
operator|.
name|pcb_onfault
condition|)
goto|goto
name|dopanic
goto|;
comment|/* fall into ... */
case|case
name|T_MMUFLT
operator|+
name|USER
case|:
comment|/* page fault */
comment|/* 		printf("trap: T_MMUFLT pid %d, code %x, v %x, pc %x, ps %x\n", 		       p->p_pid, code, v, frame.f_pc, frame.f_sr); */
if|if
condition|(
name|v
operator|>=
name|USRSTACK
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
condition|)
goto|goto
name|copyfault
goto|;
name|i
operator|=
name|SIGSEGV
expr_stmt|;
break|break;
block|}
name|ncode
operator|=
name|code
operator|>>
literal|16
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HP330
argument_list|)
operator|||
name|defined
argument_list|(
name|HP360
argument_list|)
operator|||
name|defined
argument_list|(
name|HP370
argument_list|)
comment|/* 		 * Crudely map PMMU faults into HP MMU faults. 		 */
if|if
condition|(
name|mmutype
operator|!=
name|MMU_HP
condition|)
block|{
name|int
name|ocode
init|=
name|ncode
decl_stmt|;
name|ncode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ocode
operator|&
name|PMMU_WP
condition|)
name|ncode
operator||=
name|MMU_WPF
expr_stmt|;
elseif|else
if|if
condition|(
name|ocode
operator|&
name|PMMU_INV
condition|)
block|{
if|if
condition|(
operator|(
name|ocode
operator|&
name|PMMU_LVLMASK
operator|)
operator|==
literal|2
condition|)
name|ncode
operator||=
name|MMU_PF
expr_stmt|;
else|else
name|ncode
operator||=
name|MMU_PTF
expr_stmt|;
block|}
comment|/* 			 * RMW cycle, must load ATC by hand 			 */
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
operator|(
name|SSW_DF
operator||
name|SSW_RM
operator|)
operator|)
operator|==
operator|(
name|SSW_DF
operator||
name|SSW_RM
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"RMW fault at %x: MMUSR %x SSW %x\n"
argument_list|,
name|v
argument_list|,
name|ocode
argument_list|,
name|code
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ploadw
argument_list|(
operator|(
name|caddr_t
operator|)
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 			 * Fault with no fault bits, should indicate bad 			 * hardware but we see this on 340s using starbase 			 * sometimes (faults accessing catseye registers) 			 */
else|else
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Bad PMMU fault at %x: MMUSR %x SSW %x\n"
argument_list|,
name|v
argument_list|,
name|ocode
argument_list|,
name|code
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|mmudebug
operator|&&
name|mmudebug
operator|==
name|p
operator|->
name|p_pid
condition|)
name|printf
argument_list|(
literal|"MMU %d: v%x, os%x, ns%x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|v
argument_list|,
name|ocode
argument_list|,
name|ncode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|ncode
operator|&
operator|(
name|MMU_PTF
operator||
name|MMU_PF
operator||
name|MMU_WPF
operator||
name|MMU_FPE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"T_MMUFLT with no fault bits\n"
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ncode
operator|&
name|MMU_PTF
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
comment|/* 			 * NOTE: we use a u_int instead of an ste since the 			 * current compiler generates bogus code for some 			 * bitfield operations (i.e. attempts to access last 			 * word of a page as a longword causing fault). 			 */
specifier|extern
name|struct
name|ste
modifier|*
name|vtoste
parameter_list|()
function_decl|;
name|u_int
modifier|*
name|ste
init|=
operator|(
name|u_int
operator|*
operator|)
name|vtoste
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|ste
operator|&
name|SG_V
condition|)
block|{
if|if
condition|(
name|ncode
operator|&
name|MMU_WPF
condition|)
block|{
name|printf
argument_list|(
literal|"PTF|WPF...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
condition|)
goto|goto
name|copyfault
goto|;
name|i
operator|=
name|SIGBUS
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"MMU_PTF with sg_v, ste@%x = %x\n"
argument_list|,
name|ste
argument_list|,
operator|*
name|ste
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|ISHPMMADDR
argument_list|(
name|v
argument_list|)
condition|)
block|{
specifier|extern
name|struct
name|ste
modifier|*
name|vtoste
parameter_list|()
function_decl|;
name|u_int
modifier|*
name|bste
decl_stmt|,
modifier|*
name|nste
decl_stmt|;
name|bste
operator|=
operator|(
name|u_int
operator|*
operator|)
name|vtoste
argument_list|(
name|p
argument_list|,
name|HPMMBASEADDR
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|nste
operator|=
operator|(
name|u_int
operator|*
operator|)
name|vtoste
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|bste
operator|&
name|SG_V
operator|)
operator|&&
operator|*
name|nste
operator|==
name|SG_NV
condition|)
block|{
operator|*
name|nste
operator|=
operator|*
name|bste
expr_stmt|;
name|TBIAU
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|growit
label|:
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
condition|)
goto|goto
name|copyfault
goto|;
if|if
condition|(
name|grow
argument_list|(
operator|(
name|unsigned
operator|)
name|frame
operator|.
name|f_regs
index|[
name|SP
index|]
argument_list|)
operator|||
name|grow
argument_list|(
name|v
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|i
operator|=
name|SIGSEGV
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|ISHPMMADDR
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|TBIS
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|HPMMBASEADDR
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * NOTE: WPF without PG_V is possible 		 * (e.g. attempt to write shared text which is paged out) 		 */
if|if
condition|(
name|ncode
operator|&
name|MMU_WPF
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
specifier|extern
name|struct
name|ste
modifier|*
name|vtoste
parameter_list|()
function_decl|;
name|u_int
modifier|*
name|ste
init|=
operator|(
name|u_int
operator|*
operator|)
name|vtoste
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|ste
operator|&
name|SG_V
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"MMU_WPF without sg_v, ste@%x = %x\n"
argument_list|,
name|ste
argument_list|,
operator|*
name|ste
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
condition|)
goto|goto
name|copyfault
goto|;
name|i
operator|=
name|SIGBUS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ncode
operator|&
name|MMU_PF
condition|)
block|{
specifier|register
name|u_int
name|vp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
specifier|extern
name|struct
name|ste
modifier|*
name|vtoste
parameter_list|()
function_decl|;
name|u_int
modifier|*
name|ste
init|=
operator|(
name|u_int
operator|*
operator|)
name|vtoste
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
decl_stmt|;
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|ste
operator|&
name|SG_V
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"MMU_PF without sg_v, ste@%x = %x\n"
argument_list|,
name|ste
argument_list|,
operator|*
name|ste
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
endif|#
directive|endif
name|vp
operator|=
name|btop
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|>=
name|dptov
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_dsize
argument_list|)
operator|&&
name|vp
operator|<
name|sptov
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_ssize
operator|-
literal|1
argument_list|)
condition|)
goto|goto
name|growit
goto|;
ifdef|#
directive|ifdef
name|DEBUG
name|pte
operator|=
name|vtopte
argument_list|(
name|p
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|u_int
operator|*
operator|)
name|pte
operator|&
name|PG_V
condition|)
block|{
name|printf
argument_list|(
literal|"MMU_PF with pg_v, pte = %x\n"
argument_list|,
operator|*
operator|(
name|u_int
operator|*
operator|)
name|pte
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
endif|#
directive|endif
name|i
operator|=
name|u
operator|.
name|u_error
expr_stmt|;
name|pagein
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
condition|)
return|return;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"T_MMUFLT: unrecognized scenerio\n"
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
endif|#
directive|endif
block|}
name|trapsignal
argument_list|(
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|USER
operator|)
operator|==
literal|0
condition|)
return|return;
name|out
label|:
name|p
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_pri
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
if|if
condition|(
name|runrun
condition|)
block|{
comment|/* 		 * Since we are u.u_procp, clock will normally just change 		 * our priority without moving us from one queue to another 		 * (since the running process is not on a queue.) 		 * If that happened after we setrq ourselves but before we 		 * swtch()'ed, we might not be on the queue indicated by 		 * our priority. 		 */
operator|(
name|void
operator|)
name|splclock
argument_list|()
expr_stmt|;
name|setrq
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|swtch
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|u
operator|.
name|u_prof
operator|.
name|pr_scale
condition|)
block|{
name|int
name|ticks
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|&
name|u
operator|.
name|u_ru
operator|.
name|ru_stime
decl_stmt|;
name|ticks
operator|=
operator|(
operator|(
name|tv
operator|->
name|tv_sec
operator|-
name|syst
operator|.
name|tv_sec
operator|)
operator|*
literal|1000
operator|+
operator|(
name|tv
operator|->
name|tv_usec
operator|-
name|syst
operator|.
name|tv_usec
operator|)
operator|/
literal|1000
operator|)
operator|/
operator|(
name|tick
operator|/
literal|1000
operator|)
expr_stmt|;
if|if
condition|(
name|ticks
condition|)
block|{
ifdef|#
directive|ifdef
name|PROFTIMER
specifier|extern
name|int
name|profscale
decl_stmt|;
name|addupc
argument_list|(
name|frame
operator|.
name|f_pc
argument_list|,
operator|&
name|u
operator|.
name|u_prof
argument_list|,
name|ticks
operator|*
name|profscale
argument_list|)
expr_stmt|;
else|#
directive|else
name|addupc
argument_list|(
name|frame
operator|.
name|f_pc
argument_list|,
operator|&
name|u
operator|.
name|u_prof
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|curpri
operator|=
name|p
operator|->
name|p_pri
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Called from the trap handler when a system call occurs  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|syscall
argument_list|(
name|code
argument_list|,
name|frame
argument_list|)
specifier|volatile
name|int
name|code
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|frame
name|frame
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|caddr_t
name|params
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|u
operator|.
name|u_procp
decl_stmt|;
specifier|register
name|struct
name|user
modifier|*
name|up
decl_stmt|;
name|int
name|error
decl_stmt|,
name|opc
decl_stmt|,
name|numsys
decl_stmt|;
name|struct
name|timeval
name|syst
decl_stmt|;
name|struct
name|sysent
modifier|*
name|systab
decl_stmt|;
ifdef|#
directive|ifdef
name|HPUXCOMPAT
specifier|extern
name|struct
name|sysent
name|hpuxsysent
index|[]
decl_stmt|;
specifier|extern
name|int
name|hpuxnsysent
decl_stmt|,
name|notimp
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|up
operator|=
operator|&
name|u
expr_stmt|;
comment|/* this should probably be deleted */
name|cnt
operator|.
name|v_syscall
operator|++
expr_stmt|;
name|syst
operator|=
name|up
operator|->
name|u_ru
operator|.
name|ru_stime
expr_stmt|;
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|frame
operator|.
name|f_sr
argument_list|)
condition|)
name|panic
argument_list|(
literal|"syscall"
argument_list|)
expr_stmt|;
name|up
operator|->
name|u_ar0
operator|=
name|frame
operator|.
name|f_regs
expr_stmt|;
name|up
operator|->
name|u_error
operator|=
literal|0
expr_stmt|;
name|opc
operator|=
name|frame
operator|.
name|f_pc
operator|-
literal|2
expr_stmt|;
name|systab
operator|=
name|sysent
expr_stmt|;
name|numsys
operator|=
name|nsysent
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
block|{
name|systab
operator|=
name|hpuxsysent
expr_stmt|;
name|numsys
operator|=
name|hpuxnsysent
expr_stmt|;
block|}
endif|#
directive|endif
name|params
operator|=
operator|(
name|caddr_t
operator|)
name|frame
operator|.
name|f_regs
index|[
name|SP
index|]
operator|+
name|NBPW
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
block|{
comment|/* indir */
name|code
operator|=
name|fuword
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|+=
name|NBPW
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|>=
name|numsys
condition|)
name|callp
operator|=
operator|&
name|systab
index|[
literal|0
index|]
expr_stmt|;
comment|/* indir (illegal) */
else|else
name|callp
operator|=
operator|&
name|systab
index|[
name|code
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|callp
operator|->
name|sy_narg
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|params
argument_list|,
operator|(
name|caddr_t
operator|)
name|up
operator|->
name|u_arg
argument_list|,
operator|(
name|u_int
operator|)
name|i
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
name|error
operator|=
name|bsdtohpuxerrno
argument_list|(
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|frame
operator|.
name|f_regs
index|[
name|D0
index|]
operator|=
operator|(
name|u_char
operator|)
name|error
expr_stmt|;
name|frame
operator|.
name|f_sr
operator||=
name|PSL_C
expr_stmt|;
comment|/* carry bit */
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|up
operator|->
name|u_r
operator|.
name|r_val1
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|u_r
operator|.
name|r_val2
operator|=
name|frame
operator|.
name|f_regs
index|[
name|D0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXCOMPAT
comment|/* debug kludge */
if|if
condition|(
name|callp
operator|->
name|sy_call
operator|==
name|notimp
condition|)
name|error
operator|=
name|notimp
argument_list|(
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|error
operator|=
operator|(
operator|*
operator|(
name|callp
operator|->
name|sy_call
operator|)
operator|)
operator|(
name|up
operator|)
expr_stmt|;
name|error
operator|=
name|u
operator|.
name|u_error
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|frame
operator|.
name|f_pc
operator|=
name|opc
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|!=
name|EJUSTRETURN
condition|)
block|{
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
name|error
operator|=
name|bsdtohpuxerrno
argument_list|(
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|frame
operator|.
name|f_regs
index|[
name|D0
index|]
operator|=
operator|(
name|u_char
operator|)
name|error
expr_stmt|;
name|frame
operator|.
name|f_sr
operator||=
name|PSL_C
expr_stmt|;
comment|/* carry bit */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
comment|/* there are some HPUX calls where we change u_ap */
comment|/* is this still needed? */
if|if
condition|(
name|up
operator|->
name|u_ap
operator|!=
name|up
operator|->
name|u_arg
condition|)
block|{
name|up
operator|->
name|u_ap
operator|=
name|up
operator|->
name|u_arg
expr_stmt|;
name|printf
argument_list|(
literal|"syscall(%d): u_ap changed\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|frame
operator|.
name|f_regs
index|[
name|D0
index|]
operator|=
name|up
operator|->
name|u_r
operator|.
name|r_val1
expr_stmt|;
name|frame
operator|.
name|f_regs
index|[
name|D1
index|]
operator|=
name|up
operator|->
name|u_r
operator|.
name|r_val2
expr_stmt|;
name|frame
operator|.
name|f_sr
operator|&=
operator|~
name|PSL_C
expr_stmt|;
block|}
block|}
comment|/* else if (error == EJUSTRETURN) */
comment|/* nothing to do */
name|done
label|:
comment|/* 	 * Reinitialize proc pointer `p' as it may be different 	 * if this is a child returning from fork syscall. 	 */
name|p
operator|=
name|up
operator|->
name|u_procp
expr_stmt|;
ifdef|#
directive|ifdef
name|I_DONT_UNDERSTAND
comment|/* XXX XXX */
comment|/* 	 * The check for sigreturn (code 103) ensures that we don't 	 * attempt to set up a call to a signal handler (sendsig) before 	 * we have cleaned up the stack from the last call (sigreturn). 	 * Allowing this seems to lock up the machine in certain scenarios. 	 * What should really be done is to clean up the signal handling 	 * so that this is not a problem. 	 */
if|if
condition|(
name|code
operator|!=
literal|103
operator|&&
operator|(
name|p
operator|->
name|p_cursig
operator|||
name|ISSIG
argument_list|(
name|p
argument_list|)
operator|)
condition|)
name|psig
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|p_pri
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
if|if
condition|(
name|runrun
condition|)
block|{
comment|/* 		 * Since we are u.u_procp, clock will normally just change 		 * our priority without moving us from one queue to another 		 * (since the running process is not on a queue.) 		 * If that happened after we setrq ourselves but before we 		 * swtch()'ed, we might not be on the queue indicated by 		 * our priority. 		 */
operator|(
name|void
operator|)
name|splclock
argument_list|()
expr_stmt|;
name|setrq
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|up
operator|->
name|u_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|swtch
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|up
operator|->
name|u_prof
operator|.
name|pr_scale
condition|)
block|{
name|int
name|ticks
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|&
name|up
operator|->
name|u_ru
operator|.
name|ru_stime
decl_stmt|;
name|ticks
operator|=
operator|(
operator|(
name|tv
operator|->
name|tv_sec
operator|-
name|syst
operator|.
name|tv_sec
operator|)
operator|*
literal|1000
operator|+
operator|(
name|tv
operator|->
name|tv_usec
operator|-
name|syst
operator|.
name|tv_usec
operator|)
operator|/
literal|1000
operator|)
operator|/
operator|(
name|tick
operator|/
literal|1000
operator|)
expr_stmt|;
if|if
condition|(
name|ticks
condition|)
block|{
ifdef|#
directive|ifdef
name|PROFTIMER
specifier|extern
name|int
name|profscale
decl_stmt|;
name|addupc
argument_list|(
name|frame
operator|.
name|f_pc
argument_list|,
operator|&
name|up
operator|->
name|u_prof
argument_list|,
name|ticks
operator|*
name|profscale
argument_list|)
expr_stmt|;
else|#
directive|else
name|addupc
argument_list|(
name|frame
operator|.
name|f_pc
argument_list|,
operator|&
name|up
operator|->
name|u_prof
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|curpri
operator|=
name|p
operator|->
name|p_pri
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

end_unit

