begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: trap.c 1.32 91/04/06$  *  *	@(#)trap.c	7.16 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"seg.h"
end_include

begin_include
include|#
directive|include
file|"acct.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"signalvar.h"
end_include

begin_include
include|#
directive|include
file|"resourcevar.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|"ktrace.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../include/psl.h"
end_include

begin_include
include|#
directive|include
file|"../include/trap.h"
end_include

begin_include
include|#
directive|include
file|"../include/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../include/reg.h"
end_include

begin_include
include|#
directive|include
file|"../include/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_include
include|#
directive|include
file|"vm/pmap.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HPUXCOMPAT
end_ifdef

begin_include
include|#
directive|include
file|"../hpux/hpux.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|sysent
name|sysent
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsysent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|trap_type
index|[]
init|=
block|{
literal|"Bus error"
block|,
literal|"Address error"
block|,
literal|"Illegal instruction"
block|,
literal|"Zero divide"
block|,
literal|"CHK instruction"
block|,
literal|"TRAPV instruction"
block|,
literal|"Privilege violation"
block|,
literal|"Trace trap"
block|,
literal|"MMU fault"
block|,
literal|"SSIR trap"
block|,
literal|"Format error"
block|,
literal|"68881 exception"
block|,
literal|"Coprocessor violation"
block|,
literal|"Async system trap"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRAP_TYPES
value|(sizeof trap_type / sizeof trap_type[0])
end_define

begin_comment
comment|/*  * Size of various exception stack frames (minus the standard 8 bytes)  */
end_comment

begin_decl_stmt
name|short
name|exframesize
index|[]
init|=
block|{
name|FMT0SIZE
block|,
comment|/* type 0 - normal (68020/030/040) */
name|FMT1SIZE
block|,
comment|/* type 1 - throwaway (68020/030/040) */
name|FMT2SIZE
block|,
comment|/* type 2 - normal 6-word (68020/030/040) */
operator|-
literal|1
block|,
comment|/* type 3 - FP post-instruction (68040) */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* type 4-6 - undefined */
operator|-
literal|1
block|,
comment|/* type 7 - access error (68040) */
literal|58
block|,
comment|/* type 8 - bus fault (68010) */
name|FMT9SIZE
block|,
comment|/* type 9 - coprocessor mid-instruction (68020/030) */
name|FMTASIZE
block|,
comment|/* type A - short bus fault (68020/030) */
name|FMTBSIZE
block|,
comment|/* type B - long bus fault (68020/030) */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
comment|/* type C-F - undefined */
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|mmudebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Trap is called from locore to handle most types of processor traps,  * including events such as simulated software interrupts/AST's.  * System calls are broken out for efficiency.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|trap
argument_list|(
argument|type
argument_list|,
argument|code
argument_list|,
argument|v
argument_list|,
argument|frame
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|v
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frame
name|frame
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|ucode
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|struct
name|timeval
name|syst
decl_stmt|;
name|unsigned
name|ncode
decl_stmt|;
name|int
name|s
decl_stmt|;
name|cnt
operator|.
name|v_trap
operator|++
expr_stmt|;
name|syst
operator|=
name|p
operator|->
name|p_stime
expr_stmt|;
if|if
condition|(
name|USERMODE
argument_list|(
name|frame
operator|.
name|f_sr
argument_list|)
condition|)
block|{
name|type
operator||=
name|T_USER
expr_stmt|;
name|p
operator|->
name|p_regs
operator|=
name|frame
operator|.
name|f_regs
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|dopanic
label|:
name|printf
argument_list|(
literal|"trap type %d, code = %x, v = %x\n"
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|regdump
argument_list|(
name|frame
operator|.
name|f_regs
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|type
operator|&=
operator|~
name|T_USER
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|type
operator|<
name|TRAP_TYPES
condition|)
name|panic
argument_list|(
name|trap_type
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
case|case
name|T_BUSERR
case|:
comment|/* kernel bus error */
if|if
condition|(
operator|!
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
condition|)
goto|goto
name|dopanic
goto|;
comment|/* 		 * If we have arranged to catch this fault in any of the 		 * copy to/from user space routines, set PC to return to 		 * indicated location and set flag informing buserror code 		 * that it may need to clean up stack frame. 		 */
name|copyfault
label|:
name|frame
operator|.
name|f_stackadj
operator|=
name|exframesize
index|[
name|frame
operator|.
name|f_format
index|]
expr_stmt|;
name|frame
operator|.
name|f_format
operator|=
name|frame
operator|.
name|f_vector
operator|=
literal|0
expr_stmt|;
name|frame
operator|.
name|f_pc
operator|=
operator|(
name|int
operator|)
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
expr_stmt|;
return|return;
case|case
name|T_BUSERR
operator||
name|T_USER
case|:
comment|/* bus error */
case|case
name|T_ADDRERR
operator||
name|T_USER
case|:
comment|/* address error */
name|i
operator|=
name|SIGBUS
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FPCOPROC
case|case
name|T_COPERR
case|:
comment|/* kernel coprocessor violation */
endif|#
directive|endif
case|case
name|T_FMTERR
case|:
comment|/* kernel format error */
comment|/* 	 * The user has most likely trashed the RTE or FP state info 	 * in the stack frame of a signal handler. 	 */
name|type
operator||=
name|T_USER
expr_stmt|;
name|printf
argument_list|(
literal|"pid %d: kernel %s exception\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|type
operator|==
name|T_COPERR
condition|?
literal|"coprocessor"
else|:
literal|"format"
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigact
index|[
name|SIGILL
index|]
operator|=
name|SIG_DFL
expr_stmt|;
name|i
operator|=
name|sigmask
argument_list|(
name|SIGILL
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_sigignore
operator|&=
operator|~
name|i
expr_stmt|;
name|p
operator|->
name|p_sigcatch
operator|&=
operator|~
name|i
expr_stmt|;
name|p
operator|->
name|p_sigmask
operator|&=
operator|~
name|i
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was ILL_RESAD_FAULT */
break|break;
ifdef|#
directive|ifdef
name|FPCOPROC
case|case
name|T_COPERR
operator||
name|T_USER
case|:
comment|/* user coprocessor violation */
comment|/* What is a proper response here? */
name|ucode
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_FPERR
operator||
name|T_USER
case|:
comment|/* 68881 exceptions */
comment|/* 	 * We pass along the 68881 status register which locore stashed 	 * in code for us.  Note that there is a possibility that the 	 * bit pattern of this register will conflict with one of the 	 * FPE_* codes defined in signal.h.  Fortunately for us, the 	 * only such codes we use are all in the range 1-7 and the low 	 * 3 bits of the status register are defined as 0 so there is 	 * no clash. 	 */
name|ucode
operator|=
name|code
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|T_ILLINST
operator||
name|T_USER
case|:
comment|/* illegal instruction fault */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
block|{
name|ucode
operator|=
name|HPUX_ILL_ILLINST_TRAP
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
block|}
comment|/* fall through */
endif|#
directive|endif
case|case
name|T_PRIVINST
operator||
name|T_USER
case|:
comment|/* privileged instruction fault */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
name|ucode
operator|=
name|HPUX_ILL_PRIV_TRAP
expr_stmt|;
else|else
endif|#
directive|endif
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was ILL_PRIVIN_FAULT */
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_ZERODIV
operator||
name|T_USER
case|:
comment|/* Divide by zero */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
name|ucode
operator|=
name|HPUX_FPE_INTDIV_TRAP
expr_stmt|;
else|else
endif|#
directive|endif
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was FPE_INTDIV_TRAP */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_CHKINST
operator||
name|T_USER
case|:
comment|/* CHK instruction trap */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
block|{
comment|/* handled differently under hp-ux */
name|i
operator|=
name|SIGILL
expr_stmt|;
name|ucode
operator|=
name|HPUX_ILL_CHK_TRAP
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was FPE_SUBRNG_TRAP */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_TRAPVINST
operator||
name|T_USER
case|:
comment|/* TRAPV instruction trap */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
block|{
comment|/* handled differently under hp-ux */
name|i
operator|=
name|SIGILL
expr_stmt|;
name|ucode
operator|=
name|HPUX_ILL_TRAPV_TRAP
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was FPE_INTOVF_TRAP */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
comment|/* 	 * XXX: Trace traps are a nightmare. 	 * 	 *	HP-UX uses trap #1 for breakpoints, 	 *	HPBSD uses trap #2, 	 *	SUN 3.x uses trap #15, 	 *	KGDB uses trap #15 (for kernel breakpoints; handled elsewhere). 	 * 	 * HPBSD and HP-UX traps both get mapped by locore.s into T_TRACE. 	 * SUN 3.x traps get passed through as T_TRAP15 and are not really 	 * supported yet. 	 */
case|case
name|T_TRACE
case|:
comment|/* kernel trace trap */
case|case
name|T_TRAP15
case|:
comment|/* SUN trace trap */
name|frame
operator|.
name|f_sr
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|T_TRACE
operator||
name|T_USER
case|:
comment|/* user trace trap */
case|case
name|T_TRAP15
operator||
name|T_USER
case|:
comment|/* SUN user trace trap */
name|frame
operator|.
name|f_sr
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|T_ASTFLT
case|:
comment|/* system async trap, cannot happen */
goto|goto
name|dopanic
goto|;
case|case
name|T_ASTFLT
operator||
name|T_USER
case|:
comment|/* user async trap */
name|astpending
operator|=
literal|0
expr_stmt|;
comment|/* 		 * We check for software interrupts first.  This is because 		 * they are at a higher level than ASTs, and on a VAX would 		 * interrupt the AST.  We assume that if we are processing 		 * an AST that we must be at IPL0 so we don't bother to 		 * check.  Note that we ensure that we are at least at SIR 		 * IPL while processing the SIR. 		 */
name|spl1
argument_list|()
expr_stmt|;
comment|/* fall into... */
case|case
name|T_SSIR
case|:
comment|/* software interrupt */
case|case
name|T_SSIR
operator||
name|T_USER
case|:
if|if
condition|(
name|ssir
operator|&
name|SIR_NET
condition|)
block|{
name|siroff
argument_list|(
name|SIR_NET
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
name|netintr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ssir
operator|&
name|SIR_CLOCK
condition|)
block|{
name|siroff
argument_list|(
name|SIR_CLOCK
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
name|softclock
argument_list|(
operator|(
name|caddr_t
operator|)
name|frame
operator|.
name|f_pc
argument_list|,
operator|(
name|int
operator|)
name|frame
operator|.
name|f_sr
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If this was not an AST trap, we are all done. 		 */
if|if
condition|(
name|type
operator|!=
operator|(
name|T_ASTFLT
operator||
name|T_USER
operator|)
condition|)
block|{
name|cnt
operator|.
name|v_trap
operator|--
expr_stmt|;
return|return;
block|}
name|spl0
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|PROFTIMER
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SOWEUPC
operator|)
operator|&&
name|p
operator|->
name|p_stats
operator|->
name|p_prof
operator|.
name|pr_scale
condition|)
block|{
name|addupc
argument_list|(
name|frame
operator|.
name|f_pc
argument_list|,
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_prof
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|SOWEUPC
expr_stmt|;
block|}
endif|#
directive|endif
goto|goto
name|out
goto|;
case|case
name|T_MMUFLT
case|:
comment|/* kernel mode page fault */
comment|/* fall into ... */
case|case
name|T_MMUFLT
operator||
name|T_USER
case|:
comment|/* page fault */
block|{
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
specifier|register
name|vm_map_t
name|map
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
specifier|extern
name|vm_map_t
name|kernel_map
decl_stmt|;
comment|/* 		 * It is only a kernel address space fault iff: 		 * 	1. (type& T_USER) == 0  and 		 * 	2. pcb_onfault not set or 		 *	3. pcb_onfault set but supervisor space data fault 		 * The last can occur during an exec() copyin where the 		 * argument space is lazy-allocated. 		 */
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
operator|&&
operator|(
operator|!
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
operator|||
operator|(
name|code
operator|&
operator|(
name|SSW_DF
operator||
name|FC_SUPERD
operator|)
operator|)
operator|==
operator|(
name|SSW_DF
operator||
name|FC_SUPERD
operator|)
operator|)
condition|)
name|map
operator|=
name|kernel_map
expr_stmt|;
else|else
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
operator|(
name|SSW_DF
operator||
name|SSW_RW
operator|)
operator|)
operator|==
name|SSW_DF
condition|)
comment|/* what about RMW? */
name|ftype
operator|=
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
expr_stmt|;
else|else
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|v
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|map
operator|==
name|kernel_map
operator|&&
name|va
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"trap: bad kernel access at %x\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
endif|#
directive|endif
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 		 * If this was a stack access we keep track of the maximum 		 * accessed stack size.  Also, if vm_fault gets a protection 		 * failure it is due to accessing the stack region outside 		 * the current limit and we need to reflect that as an access 		 * error. 		 */
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|va
operator|>=
name|vm
operator|->
name|vm_maxsaddr
operator|&&
name|map
operator|!=
name|kernel_map
condition|)
block|{
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|unsigned
name|nss
decl_stmt|;
name|nss
operator|=
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|USRSTACK
operator|-
operator|(
name|unsigned
operator|)
name|va
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nss
operator|>
name|vm
operator|->
name|vm_ssize
condition|)
name|vm
operator|->
name|vm_ssize
operator|=
name|nss
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
condition|)
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
condition|)
return|return;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
condition|)
goto|goto
name|copyfault
goto|;
name|printf
argument_list|(
literal|"vm_fault(%x, %x, %x, 0) -> %x\n"
argument_list|,
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  type %x, code [mmu,,ssw]: %x\n"
argument_list|,
name|type
argument_list|,
name|code
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
name|ucode
operator|=
name|v
expr_stmt|;
name|i
operator|=
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
expr_stmt|;
break|break;
block|}
block|}
name|trapsignal
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|T_USER
operator|)
operator|==
literal|0
condition|)
return|return;
name|out
label|:
while|while
condition|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_pri
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
if|if
condition|(
name|want_resched
condition|)
block|{
comment|/* 		 * Since we are curproc, clock will normally just change 		 * our priority without moving us from one queue to another 		 * (since the running process is not on a queue.) 		 * If that happened after we setrq ourselves but before we 		 * swtch()'ed, we might not be on the queue indicated by 		 * our priority. 		 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setrq
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|swtch
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_stats
operator|->
name|p_prof
operator|.
name|pr_scale
condition|)
block|{
name|int
name|ticks
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|&
name|p
operator|->
name|p_stime
decl_stmt|;
name|ticks
operator|=
operator|(
operator|(
name|tv
operator|->
name|tv_sec
operator|-
name|syst
operator|.
name|tv_sec
operator|)
operator|*
literal|1000
operator|+
operator|(
name|tv
operator|->
name|tv_usec
operator|-
name|syst
operator|.
name|tv_usec
operator|)
operator|/
literal|1000
operator|)
operator|/
operator|(
name|tick
operator|/
literal|1000
operator|)
expr_stmt|;
if|if
condition|(
name|ticks
condition|)
block|{
ifdef|#
directive|ifdef
name|PROFTIMER
specifier|extern
name|int
name|profscale
decl_stmt|;
name|addupc
argument_list|(
name|frame
operator|.
name|f_pc
argument_list|,
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_prof
argument_list|,
name|ticks
operator|*
name|profscale
argument_list|)
expr_stmt|;
else|#
directive|else
name|addupc
argument_list|(
name|frame
operator|.
name|f_pc
argument_list|,
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_prof
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|curpri
operator|=
name|p
operator|->
name|p_pri
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Proces a system call.  */
end_comment

begin_expr_stmt
name|syscall
argument_list|(
name|code
argument_list|,
name|frame
argument_list|)
specifier|volatile
name|int
name|code
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|frame
name|frame
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|caddr_t
name|params
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|opc
decl_stmt|,
name|numsys
decl_stmt|,
name|s
decl_stmt|;
struct|struct
name|args
block|{
name|int
name|i
index|[
literal|8
index|]
decl_stmt|;
block|}
name|args
struct|;
name|int
name|rval
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|timeval
name|syst
decl_stmt|;
name|struct
name|sysent
modifier|*
name|systab
decl_stmt|;
ifdef|#
directive|ifdef
name|HPUXCOMPAT
specifier|extern
name|struct
name|sysent
name|hpuxsysent
index|[]
decl_stmt|;
specifier|extern
name|int
name|hpuxnsysent
decl_stmt|,
name|notimp
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_syscall
operator|++
expr_stmt|;
name|syst
operator|=
name|p
operator|->
name|p_stime
expr_stmt|;
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|frame
operator|.
name|f_sr
argument_list|)
condition|)
name|panic
argument_list|(
literal|"syscall"
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_regs
operator|=
name|frame
operator|.
name|f_regs
expr_stmt|;
name|opc
operator|=
name|frame
operator|.
name|f_pc
operator|-
literal|2
expr_stmt|;
name|systab
operator|=
name|sysent
expr_stmt|;
name|numsys
operator|=
name|nsysent
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
block|{
name|systab
operator|=
name|hpuxsysent
expr_stmt|;
name|numsys
operator|=
name|hpuxnsysent
expr_stmt|;
block|}
endif|#
directive|endif
name|params
operator|=
operator|(
name|caddr_t
operator|)
name|frame
operator|.
name|f_regs
index|[
name|SP
index|]
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
block|{
comment|/* indir */
name|code
operator|=
name|fuword
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|>=
name|numsys
condition|)
name|callp
operator|=
operator|&
name|systab
index|[
literal|0
index|]
expr_stmt|;
comment|/* indir (illegal) */
else|else
name|callp
operator|=
operator|&
name|systab
index|[
name|code
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|callp
operator|->
name|sy_narg
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|params
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|,
operator|(
name|u_int
operator|)
name|i
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
name|error
operator|=
name|bsdtohpuxerrno
argument_list|(
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|frame
operator|.
name|f_regs
index|[
name|D0
index|]
operator|=
name|error
expr_stmt|;
name|frame
operator|.
name|f_sr
operator||=
name|PSL_C
expr_stmt|;
comment|/* carry bit */
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rval
index|[
literal|1
index|]
operator|=
name|frame
operator|.
name|f_regs
index|[
name|D1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXCOMPAT
comment|/* debug kludge */
if|if
condition|(
name|callp
operator|->
name|sy_call
operator|==
name|notimp
condition|)
name|error
operator|=
name|notimp
argument_list|(
name|p
argument_list|,
name|args
operator|.
name|i
argument_list|,
name|rval
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|error
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|p
argument_list|,
operator|&
name|args
argument_list|,
name|rval
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|curproc
operator|->
name|p_spare
index|[
literal|0
index|]
condition|)
name|panic
argument_list|(
literal|"syscall: M_NAMEI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
operator|->
name|p_spare
index|[
literal|1
index|]
condition|)
name|panic
argument_list|(
literal|"syscall: STARTSAVE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
operator|->
name|p_spare
index|[
literal|2
index|]
condition|)
name|panic
argument_list|(
literal|"syscall: LOCK COUNT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|frame
operator|.
name|f_pc
operator|=
name|opc
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|!=
name|EJUSTRETURN
condition|)
block|{
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SHPUX
condition|)
name|error
operator|=
name|bsdtohpuxerrno
argument_list|(
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|frame
operator|.
name|f_regs
index|[
name|D0
index|]
operator|=
name|error
expr_stmt|;
name|frame
operator|.
name|f_sr
operator||=
name|PSL_C
expr_stmt|;
comment|/* carry bit */
block|}
else|else
block|{
name|frame
operator|.
name|f_regs
index|[
name|D0
index|]
operator|=
name|rval
index|[
literal|0
index|]
expr_stmt|;
name|frame
operator|.
name|f_regs
index|[
name|D1
index|]
operator|=
name|rval
index|[
literal|1
index|]
expr_stmt|;
name|frame
operator|.
name|f_sr
operator|&=
operator|~
name|PSL_C
expr_stmt|;
block|}
block|}
comment|/* else if (error == EJUSTRETURN) */
comment|/* nothing to do */
name|done
label|:
comment|/* 	 * Reinitialize proc pointer `p' as it may be different 	 * if this is a child returning from fork syscall. 	 */
name|p
operator|=
name|curproc
expr_stmt|;
while|while
condition|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_pri
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
if|if
condition|(
name|want_resched
condition|)
block|{
comment|/* 		 * Since we are curproc, clock will normally just change 		 * our priority without moving us from one queue to another 		 * (since the running process is not on a queue.) 		 * If that happened after we setrq ourselves but before we 		 * swtch()'ed, we might not be on the queue indicated by 		 * our priority. 		 */
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setrq
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|swtch
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
condition|)
name|psig
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_stats
operator|->
name|p_prof
operator|.
name|pr_scale
condition|)
block|{
name|int
name|ticks
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|&
name|p
operator|->
name|p_stime
decl_stmt|;
name|ticks
operator|=
operator|(
operator|(
name|tv
operator|->
name|tv_sec
operator|-
name|syst
operator|.
name|tv_sec
operator|)
operator|*
literal|1000
operator|+
operator|(
name|tv
operator|->
name|tv_usec
operator|-
name|syst
operator|.
name|tv_usec
operator|)
operator|/
literal|1000
operator|)
operator|/
operator|(
name|tick
operator|/
literal|1000
operator|)
expr_stmt|;
if|if
condition|(
name|ticks
condition|)
block|{
ifdef|#
directive|ifdef
name|PROFTIMER
specifier|extern
name|int
name|profscale
decl_stmt|;
name|addupc
argument_list|(
name|frame
operator|.
name|f_pc
argument_list|,
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_prof
argument_list|,
name|ticks
operator|*
name|profscale
argument_list|)
expr_stmt|;
else|#
directive|else
name|addupc
argument_list|(
name|frame
operator|.
name|f_pc
argument_list|,
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_prof
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|curpri
operator|=
name|p
operator|->
name|p_pri
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|error
argument_list|,
name|rval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

end_unit

