begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1982, 1986, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: trap.c 1.37 92/12/20$  *  *	@(#)trap.c	8.6 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/acct.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/trap.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/mtpr.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HPUXCOMPAT
end_ifdef

begin_include
include|#
directive|include
file|<hp/hpux/hpux.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|sysent
name|sysent
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsysent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|trap_type
index|[]
init|=
block|{
literal|"Bus error"
block|,
literal|"Address error"
block|,
literal|"Illegal instruction"
block|,
literal|"Zero divide"
block|,
literal|"CHK instruction"
block|,
literal|"TRAPV instruction"
block|,
literal|"Privilege violation"
block|,
literal|"Trace trap"
block|,
literal|"MMU fault"
block|,
literal|"SSIR trap"
block|,
literal|"Format error"
block|,
literal|"68881 exception"
block|,
literal|"Coprocessor violation"
block|,
literal|"Async system trap"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRAP_TYPES
value|(sizeof trap_type / sizeof trap_type[0])
end_define

begin_comment
comment|/*  * Size of various exception stack frames (minus the standard 8 bytes)  */
end_comment

begin_decl_stmt
name|short
name|exframesize
index|[]
init|=
block|{
name|FMT0SIZE
block|,
comment|/* type 0 - normal (68020/030/040) */
name|FMT1SIZE
block|,
comment|/* type 1 - throwaway (68020/030/040) */
name|FMT2SIZE
block|,
comment|/* type 2 - normal 6-word (68020/030/040) */
name|FMT3SIZE
block|,
comment|/* type 3 - FP post-instruction (68040) */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* type 4-6 - undefined */
name|FMT7SIZE
block|,
comment|/* type 7 - access error (68040) */
literal|58
block|,
comment|/* type 8 - bus fault (68010) */
name|FMT9SIZE
block|,
comment|/* type 9 - coprocessor mid-instruction (68020/030) */
name|FMTASIZE
block|,
comment|/* type A - short bus fault (68020/030) */
name|FMTBSIZE
block|,
comment|/* type B - long bus fault (68020/030) */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
comment|/* type C-F - undefined */
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HP380
end_ifdef

begin_define
define|#
directive|define
name|KDFAULT
parameter_list|(
name|c
parameter_list|)
value|(mmutype == MMU_68040 ? \ 			    ((c)& SSW4_TMMASK) == SSW4_TMKD : \ 			    ((c)& (SSW_DF|FC_SUPERD)) == (SSW_DF|FC_SUPERD))
end_define

begin_define
define|#
directive|define
name|WRFAULT
parameter_list|(
name|c
parameter_list|)
value|(mmutype == MMU_68040 ? \ 			    ((c)& SSW4_RW) == 0 : \ 			    ((c)& (SSW_DF|SSW_RW)) == SSW_DF)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KDFAULT
parameter_list|(
name|c
parameter_list|)
value|(((c)& (SSW_DF|SSW_FCMASK)) == (SSW_DF|FC_SUPERD))
end_define

begin_define
define|#
directive|define
name|WRFAULT
parameter_list|(
name|c
parameter_list|)
value|(((c)& (SSW_DF|SSW_RW)) == SSW_DF)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|mmudebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mmupid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MDB_FOLLOW
value|1
end_define

begin_define
define|#
directive|define
name|MDB_WBFOLLOW
value|2
end_define

begin_define
define|#
directive|define
name|MDB_WBFAILED
value|4
end_define

begin_define
define|#
directive|define
name|MDB_ISPID
parameter_list|(
name|p
parameter_list|)
value|(p) == mmupid
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * trap and syscall both need the following work done before returning  * to user mode.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|userret
parameter_list|(
name|p
parameter_list|,
name|fp
parameter_list|,
name|oticks
parameter_list|,
name|faultaddr
parameter_list|,
name|fromtrap
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|frame
modifier|*
name|fp
decl_stmt|;
name|u_quad_t
name|oticks
decl_stmt|;
name|u_int
name|faultaddr
decl_stmt|;
name|int
name|fromtrap
decl_stmt|;
block|{
name|int
name|sig
decl_stmt|,
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|HP380
name|int
name|beenhere
init|=
literal|0
decl_stmt|;
name|again
label|:
endif|#
directive|endif
comment|/* take pending signals */
while|while
condition|(
operator|(
name|sig
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|postsig
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_priority
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
if|if
condition|(
name|want_resched
condition|)
block|{
comment|/* 		 * Since we are curproc, clock will normally just change 		 * our priority without moving us from one queue to another 		 * (since the running process is not on a queue.) 		 * If that happened after we put ourselves on the run queue 		 * but before we mi_switch()'ed, we might not be on the queue 		 * indicated by our priority. 		 */
name|s
operator|=
name|splstatclock
argument_list|()
expr_stmt|;
name|setrunqueue
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sig
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|postsig
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If profiling, charge system time to the trapped pc. 	 */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_PROFIL
condition|)
block|{
specifier|extern
name|int
name|psratio
decl_stmt|;
name|addupc_task
argument_list|(
name|p
argument_list|,
name|fp
operator|->
name|f_pc
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|->
name|p_sticks
operator|-
name|oticks
argument_list|)
operator|*
name|psratio
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HP380
comment|/* 	 * Deal with user mode writebacks (from trap, or from sigreturn). 	 * If any writeback fails, go back and attempt signal delivery. 	 * unless we have already been here and attempted the writeback 	 * (e.g. bad address with user ignoring SIGSEGV).  In that case 	 * we just return to the user without sucessfully completing 	 * the writebacks.  Maybe we should just drop the sucker? 	 */
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
operator|&&
name|fp
operator|->
name|f_format
operator|==
name|FMT7
condition|)
block|{
if|if
condition|(
name|beenhere
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|mmudebug
operator|&
name|MDB_WBFAILED
condition|)
name|printf
argument_list|(
name|fromtrap
condition|?
literal|"pid %d(%s): writeback aborted, pc=%x, fa=%x\n"
else|:
literal|"pid %d(%s): writeback aborted in sigreturn, pc=%x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|fp
operator|->
name|f_pc
argument_list|,
name|faultaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|sig
operator|=
name|writeback
argument_list|(
name|fp
argument_list|,
name|fromtrap
argument_list|)
condition|)
block|{
name|beenhere
operator|=
literal|1
expr_stmt|;
name|oticks
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
name|trapsignal
argument_list|(
name|p
argument_list|,
name|sig
argument_list|,
name|faultaddr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
endif|#
directive|endif
name|curpriority
operator|=
name|p
operator|->
name|p_priority
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trap is called from locore to handle most types of processor traps,  * including events such as simulated software interrupts/AST's.  * System calls are broken out for efficiency.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|trap
argument_list|(
argument|type
argument_list|,
argument|code
argument_list|,
argument|v
argument_list|,
argument|frame
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|v
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frame
name|frame
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
name|fswintr
index|[]
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|u_int
name|ucode
decl_stmt|;
name|u_quad_t
name|sticks
decl_stmt|;
name|cnt
operator|.
name|v_trap
operator|++
expr_stmt|;
name|p
operator|=
name|curproc
expr_stmt|;
name|ucode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|USERMODE
argument_list|(
name|frame
operator|.
name|f_sr
argument_list|)
condition|)
block|{
name|type
operator||=
name|T_USER
expr_stmt|;
name|sticks
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|=
name|frame
operator|.
name|f_regs
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|dopanic
label|:
name|printf
argument_list|(
literal|"trap type %d, code = %x, v = %x\n"
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|regdump
argument_list|(
operator|&
name|frame
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|type
operator|&=
operator|~
name|T_USER
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|type
operator|<
name|TRAP_TYPES
condition|)
name|panic
argument_list|(
name|trap_type
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
case|case
name|T_BUSERR
case|:
comment|/* kernel bus error */
if|if
condition|(
operator|!
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
condition|)
goto|goto
name|dopanic
goto|;
comment|/* 		 * If we have arranged to catch this fault in any of the 		 * copy to/from user space routines, set PC to return to 		 * indicated location and set flag informing buserror code 		 * that it may need to clean up stack frame. 		 */
name|copyfault
label|:
name|frame
operator|.
name|f_stackadj
operator|=
name|exframesize
index|[
name|frame
operator|.
name|f_format
index|]
expr_stmt|;
name|frame
operator|.
name|f_format
operator|=
name|frame
operator|.
name|f_vector
operator|=
literal|0
expr_stmt|;
name|frame
operator|.
name|f_pc
operator|=
operator|(
name|int
operator|)
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
expr_stmt|;
return|return;
case|case
name|T_BUSERR
operator||
name|T_USER
case|:
comment|/* bus error */
case|case
name|T_ADDRERR
operator||
name|T_USER
case|:
comment|/* address error */
name|ucode
operator|=
name|v
expr_stmt|;
name|i
operator|=
name|SIGBUS
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HP380
case|case
name|T_ADDRERR
case|:
comment|/* 		 * Yow!  Looks like we get a kernel exception if the PC 		 * in the RTE frame is odd on a 68040 (not on a 68030). 		 * It comes through as a user exception for access faults 		 * (T_MMUFLT). 		 */
if|if
condition|(
operator|*
operator|(
name|short
operator|*
operator|)
name|frame
operator|.
name|f_pc
operator|!=
literal|0x4e73
condition|)
goto|goto
name|dopanic
goto|;
comment|/* fall through */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FPCOPROC
case|case
name|T_COPERR
case|:
comment|/* kernel coprocessor violation */
endif|#
directive|endif
case|case
name|T_FMTERR
operator||
name|T_USER
case|:
comment|/* do all RTE errors come in as T_USER? */
case|case
name|T_FMTERR
case|:
comment|/* ...just in case... */
comment|/* 		 * The user has most likely trashed the RTE or FP state info 		 * in the stack frame of a signal handler. 		 */
name|type
operator||=
name|T_USER
expr_stmt|;
name|printf
argument_list|(
literal|"pid %d: kernel %s exception\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|type
operator|==
name|T_COPERR
operator||
name|T_USER
operator|)
condition|?
literal|"coprocessor"
else|:
operator|(
name|type
operator|==
name|T_ADDRERR
operator||
name|T_USER
operator|)
condition|?
literal|"RTE address"
else|:
literal|"RTE format"
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigact
index|[
name|SIGILL
index|]
operator|=
name|SIG_DFL
expr_stmt|;
name|i
operator|=
name|sigmask
argument_list|(
name|SIGILL
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_sigignore
operator|&=
operator|~
name|i
expr_stmt|;
name|p
operator|->
name|p_sigcatch
operator|&=
operator|~
name|i
expr_stmt|;
name|p
operator|->
name|p_sigmask
operator|&=
operator|~
name|i
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was ILL_RESAD_FAULT */
break|break;
ifdef|#
directive|ifdef
name|FPCOPROC
case|case
name|T_COPERR
operator||
name|T_USER
case|:
comment|/* user coprocessor violation */
comment|/* What is a proper response here? */
name|ucode
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_FPERR
operator||
name|T_USER
case|:
comment|/* 68881 exceptions */
comment|/* 	 * We pass along the 68881 status register which locore stashed 	 * in code for us.  Note that there is a possibility that the 	 * bit pattern of this register will conflict with one of the 	 * FPE_* codes defined in signal.h.  Fortunately for us, the 	 * only such codes we use are all in the range 1-7 and the low 	 * 3 bits of the status register are defined as 0 so there is 	 * no clash. 	 */
name|ucode
operator|=
name|code
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HP380
case|case
name|T_FPEMULI
operator||
name|T_USER
case|:
comment|/* unimplemented FP instuction */
case|case
name|T_FPEMULD
operator||
name|T_USER
case|:
comment|/* unimplemented FP data type */
comment|/* XXX need to FSAVE */
name|printf
argument_list|(
literal|"pid %d(%s): unimplemented FP %s at %x (EA %x)\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|frame
operator|.
name|f_format
operator|==
literal|2
condition|?
literal|"instruction"
else|:
literal|"data type"
argument_list|,
name|frame
operator|.
name|f_pc
argument_list|,
name|frame
operator|.
name|f_fmt2
operator|.
name|f_iaddr
argument_list|)
expr_stmt|;
comment|/* XXX need to FRESTORE */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|T_ILLINST
operator||
name|T_USER
case|:
comment|/* illegal instruction fault */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_HPUX
condition|)
block|{
name|ucode
operator|=
name|HPUX_ILL_ILLINST_TRAP
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
block|}
comment|/* fall through */
endif|#
directive|endif
case|case
name|T_PRIVINST
operator||
name|T_USER
case|:
comment|/* privileged instruction fault */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_HPUX
condition|)
name|ucode
operator|=
name|HPUX_ILL_PRIV_TRAP
expr_stmt|;
else|else
endif|#
directive|endif
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was ILL_PRIVIN_FAULT */
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_ZERODIV
operator||
name|T_USER
case|:
comment|/* Divide by zero */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_HPUX
condition|)
name|ucode
operator|=
name|HPUX_FPE_INTDIV_TRAP
expr_stmt|;
else|else
endif|#
directive|endif
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was FPE_INTDIV_TRAP */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_CHKINST
operator||
name|T_USER
case|:
comment|/* CHK instruction trap */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_HPUX
condition|)
block|{
comment|/* handled differently under hp-ux */
name|i
operator|=
name|SIGILL
expr_stmt|;
name|ucode
operator|=
name|HPUX_ILL_CHK_TRAP
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was FPE_SUBRNG_TRAP */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_TRAPVINST
operator||
name|T_USER
case|:
comment|/* TRAPV instruction trap */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_HPUX
condition|)
block|{
comment|/* handled differently under hp-ux */
name|i
operator|=
name|SIGILL
expr_stmt|;
name|ucode
operator|=
name|HPUX_ILL_TRAPV_TRAP
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|ucode
operator|=
name|frame
operator|.
name|f_format
expr_stmt|;
comment|/* XXX was FPE_INTOVF_TRAP */
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
comment|/* 	 * XXX: Trace traps are a nightmare. 	 * 	 *	HP-UX uses trap #1 for breakpoints, 	 *	HPBSD uses trap #2, 	 *	SUN 3.x uses trap #15, 	 *	KGDB uses trap #15 (for kernel breakpoints; handled elsewhere). 	 * 	 * HPBSD and HP-UX traps both get mapped by locore.s into T_TRACE. 	 * SUN 3.x traps get passed through as T_TRAP15 and are not really 	 * supported yet. 	 */
case|case
name|T_TRACE
case|:
comment|/* kernel trace trap */
case|case
name|T_TRAP15
case|:
comment|/* SUN trace trap */
name|frame
operator|.
name|f_sr
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|T_TRACE
operator||
name|T_USER
case|:
comment|/* user trace trap */
case|case
name|T_TRAP15
operator||
name|T_USER
case|:
comment|/* SUN user trace trap */
name|frame
operator|.
name|f_sr
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|T_ASTFLT
case|:
comment|/* system async trap, cannot happen */
goto|goto
name|dopanic
goto|;
case|case
name|T_ASTFLT
operator||
name|T_USER
case|:
comment|/* user async trap */
name|astpending
operator|=
literal|0
expr_stmt|;
comment|/* 		 * We check for software interrupts first.  This is because 		 * they are at a higher level than ASTs, and on a VAX would 		 * interrupt the AST.  We assume that if we are processing 		 * an AST that we must be at IPL0 so we don't bother to 		 * check.  Note that we ensure that we are at least at SIR 		 * IPL while processing the SIR. 		 */
name|spl1
argument_list|()
expr_stmt|;
comment|/* fall into... */
case|case
name|T_SSIR
case|:
comment|/* software interrupt */
case|case
name|T_SSIR
operator||
name|T_USER
case|:
if|if
condition|(
name|ssir
operator|&
name|SIR_NET
condition|)
block|{
name|siroff
argument_list|(
name|SIR_NET
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
name|netintr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ssir
operator|&
name|SIR_CLOCK
condition|)
block|{
name|siroff
argument_list|(
name|SIR_CLOCK
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
name|softclock
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * If this was not an AST trap, we are all done. 		 */
if|if
condition|(
name|type
operator|!=
operator|(
name|T_ASTFLT
operator||
name|T_USER
operator|)
condition|)
block|{
name|cnt
operator|.
name|v_trap
operator|--
expr_stmt|;
return|return;
block|}
name|spl0
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_OWEUPC
condition|)
block|{
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_OWEUPC
expr_stmt|;
name|ADDUPROF
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
case|case
name|T_MMUFLT
case|:
comment|/* kernel mode page fault */
comment|/* 		 * If we were doing profiling ticks or other user mode 		 * stuff from interrupt code, Just Say No. 		 */
if|if
condition|(
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
operator|==
name|fswintr
condition|)
goto|goto
name|copyfault
goto|;
comment|/* fall into ... */
case|case
name|T_MMUFLT
operator||
name|T_USER
case|:
comment|/* page fault */
block|{
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
specifier|register
name|vm_map_t
name|map
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
specifier|extern
name|vm_map_t
name|kernel_map
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|mmudebug
operator|&
name|MDB_WBFOLLOW
operator|)
operator|||
name|MDB_ISPID
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
condition|)
name|printf
argument_list|(
literal|"trap: T_MMUFLT pid=%d, code=%x, v=%x, pc=%x, sr=%x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|code
argument_list|,
name|v
argument_list|,
name|frame
operator|.
name|f_pc
argument_list|,
name|frame
operator|.
name|f_sr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * It is only a kernel address space fault iff: 		 * 	1. (type& T_USER) == 0  and 		 * 	2. pcb_onfault not set or 		 *	3. pcb_onfault set but supervisor space data fault 		 * The last can occur during an exec() copyin where the 		 * argument space is lazy-allocated. 		 */
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
operator|&&
operator|(
operator|!
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
operator|||
name|KDFAULT
argument_list|(
name|code
argument_list|)
operator|)
condition|)
name|map
operator|=
name|kernel_map
expr_stmt|;
else|else
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
if|if
condition|(
name|WRFAULT
argument_list|(
name|code
argument_list|)
condition|)
name|ftype
operator|=
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
expr_stmt|;
else|else
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|v
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|map
operator|==
name|kernel_map
operator|&&
name|va
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"trap: bad kernel access at %x\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|ISHPMMADDR
argument_list|(
name|va
argument_list|)
condition|)
block|{
name|vm_offset_t
name|bva
decl_stmt|;
name|rv
operator|=
name|pmap_mapmulti
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|bva
operator|=
name|HPMMBASEADDR
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|bva
argument_list|,
name|ftype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
operator|(
name|void
operator|)
name|pmap_mapmulti
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rv
operator|&&
name|MDB_ISPID
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
condition|)
name|printf
argument_list|(
literal|"vm_fault(%x, %x, %x, 0) -> %x\n"
argument_list|,
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|rv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If this was a stack access we keep track of the maximum 		 * accessed stack size.  Also, if vm_fault gets a protection 		 * failure it is due to accessing the stack region outside 		 * the current limit and we need to reflect that as an access 		 * error. 		 */
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|va
operator|>=
name|vm
operator|->
name|vm_maxsaddr
operator|&&
name|map
operator|!=
name|kernel_map
condition|)
block|{
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|unsigned
name|nss
decl_stmt|;
name|nss
operator|=
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|USRSTACK
operator|-
operator|(
name|unsigned
operator|)
name|va
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nss
operator|>
name|vm
operator|->
name|vm_ssize
condition|)
name|vm
operator|->
name|vm_ssize
operator|=
name|nss
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
condition|)
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
condition|)
block|{
ifdef|#
directive|ifdef
name|HP380
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
condition|)
operator|(
name|void
operator|)
name|writeback
argument_list|(
operator|&
name|frame
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|T_MMUFLT
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
condition|)
goto|goto
name|copyfault
goto|;
name|printf
argument_list|(
literal|"vm_fault(%x, %x, %x, 0) -> %x\n"
argument_list|,
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  type %x, code [mmu,,ssw]: %x\n"
argument_list|,
name|type
argument_list|,
name|code
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
name|ucode
operator|=
name|v
expr_stmt|;
name|i
operator|=
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
expr_stmt|;
break|break;
block|}
block|}
name|trapsignal
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|T_USER
operator|)
operator|==
literal|0
condition|)
return|return;
name|out
label|:
name|userret
argument_list|(
name|p
argument_list|,
operator|&
name|frame
argument_list|,
name|sticks
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HP380
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_struct
struct|struct
name|writebackstats
block|{
name|int
name|calls
decl_stmt|;
name|int
name|cpushes
decl_stmt|;
name|int
name|move16s
decl_stmt|;
name|int
name|wb1s
decl_stmt|,
name|wb2s
decl_stmt|,
name|wb3s
decl_stmt|;
name|int
name|wbsize
index|[
literal|4
index|]
decl_stmt|;
block|}
name|wbstats
struct|;
end_struct

begin_decl_stmt
name|char
modifier|*
name|f7sz
index|[]
init|=
block|{
literal|"longword"
block|,
literal|"byte"
block|,
literal|"word"
block|,
literal|"line"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f7tt
index|[]
init|=
block|{
literal|"normal"
block|,
literal|"MOVE16"
block|,
literal|"AFC"
block|,
literal|"ACK"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f7tm
index|[]
init|=
block|{
literal|"d-push"
block|,
literal|"u-data"
block|,
literal|"u-code"
block|,
literal|"M-data"
block|,
literal|"M-code"
block|,
literal|"k-data"
block|,
literal|"k-code"
block|,
literal|"RES"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|wberrstr
index|[]
init|=
literal|"WARNING: pid %d(%s) writeback [%s] failed, pc=%x fa=%x wba=%x wbd=%x\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|writeback
argument_list|(
argument|fp
argument_list|,
argument|docachepush
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|frame
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|docachepush
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|fmt7
modifier|*
name|f
init|=
operator|&
name|fp
operator|->
name|f_fmt7
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u_int
name|fa
decl_stmt|;
name|caddr_t
name|oonfault
init|=
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|mmudebug
operator|&
name|MDB_WBFOLLOW
operator|)
operator|||
name|MDB_ISPID
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" pid=%d, fa=%x,"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|f
operator|->
name|f_fa
argument_list|)
expr_stmt|;
name|dumpssw
argument_list|(
name|f
operator|->
name|f_ssw
argument_list|)
expr_stmt|;
block|}
name|wbstats
operator|.
name|calls
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Deal with special cases first. 	 */
if|if
condition|(
operator|(
name|f
operator|->
name|f_ssw
operator|&
name|SSW4_TMMASK
operator|)
operator|==
name|SSW4_TMDCP
condition|)
block|{
comment|/* 		 * Dcache push fault. 		 * Line-align the address and write out the push data to 		 * the indicated physical address. 		 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|mmudebug
operator|&
name|MDB_WBFOLLOW
operator|)
operator|||
name|MDB_ISPID
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" pushing %s to PA %x, data %x"
argument_list|,
name|f7sz
index|[
operator|(
name|f
operator|->
name|f_ssw
operator|&
name|SSW4_SZMASK
operator|)
operator|>>
literal|5
index|]
argument_list|,
name|f
operator|->
name|f_fa
argument_list|,
name|f
operator|->
name|f_pd0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|f_ssw
operator|&
name|SSW4_SZMASK
operator|)
operator|==
name|SSW4_SZLN
condition|)
name|printf
argument_list|(
literal|"/%x/%x/%x"
argument_list|,
name|f
operator|->
name|f_pd1
argument_list|,
name|f
operator|->
name|f_pd2
argument_list|,
name|f
operator|->
name|f_pd3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|f_wb1s
operator|&
name|SSW4_WBSV
condition|)
name|panic
argument_list|(
literal|"writeback: cache push with WB1S valid"
argument_list|)
expr_stmt|;
name|wbstats
operator|.
name|cpushes
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * XXX there are security problems if we attempt to do a 		 * cache push after a signal handler has been called. 		 */
if|if
condition|(
name|docachepush
condition|)
block|{
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|vmmap
argument_list|,
name|trunc_page
argument_list|(
name|f
operator|->
name|f_fa
argument_list|)
argument_list|,
name|VM_PROT_WRITE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|fa
operator|=
operator|(
name|u_int
operator|)
operator|&
name|vmmap
index|[
operator|(
name|f
operator|->
name|f_fa
operator|&
name|PGOFSET
operator|)
operator|&
operator|~
literal|0xF
index|]
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|f
operator|->
name|f_pd0
argument_list|,
operator|(
name|caddr_t
operator|)
name|fa
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|DCFL
argument_list|(
name|pmap_extract
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|fa
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_remove
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|vmmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
operator|&
name|vmmap
index|[
name|NBPG
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"WARNING: pid %d(%s) uid %d: CPUSH not done\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|->
name|f_ssw
operator|&
operator|(
name|SSW4_RW
operator||
name|SSW4_TTMASK
operator|)
operator|)
operator|==
name|SSW4_TTM16
condition|)
block|{
comment|/* 		 * MOVE16 fault. 		 * Line-align the address and write out the push data to 		 * the indicated virtual address. 		 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|mmudebug
operator|&
name|MDB_WBFOLLOW
operator|)
operator|||
name|MDB_ISPID
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
condition|)
name|printf
argument_list|(
literal|" MOVE16 to VA %x(%x), data %x/%x/%x/%x\n"
argument_list|,
name|f
operator|->
name|f_fa
argument_list|,
name|f
operator|->
name|f_fa
operator|&
operator|~
literal|0xF
argument_list|,
name|f
operator|->
name|f_pd0
argument_list|,
name|f
operator|->
name|f_pd1
argument_list|,
name|f
operator|->
name|f_pd2
argument_list|,
name|f
operator|->
name|f_pd3
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|f_wb1s
operator|&
name|SSW4_WBSV
condition|)
name|panic
argument_list|(
literal|"writeback: MOVE16 with WB1S valid"
argument_list|)
expr_stmt|;
name|wbstats
operator|.
name|move16s
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|KDFAULT
argument_list|(
name|f
operator|->
name|f_wb1s
argument_list|)
condition|)
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|f
operator|->
name|f_pd0
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|f
operator|->
name|f_fa
operator|&
operator|~
literal|0xF
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|suline
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|f
operator|->
name|f_fa
operator|&
operator|~
literal|0xF
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|f
operator|->
name|f_pd0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|fa
operator|=
name|f
operator|->
name|f_fa
operator|&
operator|~
literal|0xF
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|mmudebug
operator|&
name|MDB_WBFAILED
condition|)
name|printf
argument_list|(
name|wberrstr
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
literal|"MOVE16"
argument_list|,
name|fp
operator|->
name|f_pc
argument_list|,
name|f
operator|->
name|f_fa
argument_list|,
name|f
operator|->
name|f_fa
operator|&
operator|~
literal|0xF
argument_list|,
name|f
operator|->
name|f_pd0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|->
name|f_wb1s
operator|&
name|SSW4_WBSV
condition|)
block|{
comment|/* 		 * Writeback #1. 		 * Position the "memory-aligned" data and write it out. 		 */
specifier|register
name|u_int
name|wb1d
init|=
name|f
operator|->
name|f_wb1d
decl_stmt|;
specifier|register
name|int
name|off
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|mmudebug
operator|&
name|MDB_WBFOLLOW
operator|)
operator|||
name|MDB_ISPID
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
condition|)
name|dumpwb
argument_list|(
literal|1
argument_list|,
name|f
operator|->
name|f_wb1s
argument_list|,
name|f
operator|->
name|f_wb1a
argument_list|,
name|f
operator|->
name|f_wb1d
argument_list|)
expr_stmt|;
name|wbstats
operator|.
name|wb1s
operator|++
expr_stmt|;
name|wbstats
operator|.
name|wbsize
index|[
operator|(
name|f
operator|->
name|f_wb2s
operator|&
name|SSW4_SZMASK
operator|)
operator|>>
literal|5
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|off
operator|=
operator|(
name|f
operator|->
name|f_wb1a
operator|&
literal|3
operator|)
operator|*
literal|8
expr_stmt|;
switch|switch
condition|(
name|f
operator|->
name|f_wb1s
operator|&
name|SSW4_SZMASK
condition|)
block|{
case|case
name|SSW4_SZLW
case|:
if|if
condition|(
name|off
condition|)
name|wb1d
operator|=
operator|(
name|wb1d
operator|>>
operator|(
literal|32
operator|-
name|off
operator|)
operator|)
operator||
operator|(
name|wb1d
operator|<<
name|off
operator|)
expr_stmt|;
if|if
condition|(
name|KDFAULT
argument_list|(
name|f
operator|->
name|f_wb1s
argument_list|)
condition|)
operator|*
operator|(
name|long
operator|*
operator|)
name|f
operator|->
name|f_wb1a
operator|=
name|wb1d
expr_stmt|;
else|else
name|err
operator|=
name|suword
argument_list|(
operator|(
name|caddr_t
operator|)
name|f
operator|->
name|f_wb1a
argument_list|,
name|wb1d
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSW4_SZB
case|:
name|off
operator|=
literal|24
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|off
condition|)
name|wb1d
operator|>>=
name|off
expr_stmt|;
if|if
condition|(
name|KDFAULT
argument_list|(
name|f
operator|->
name|f_wb1s
argument_list|)
condition|)
operator|*
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|f_wb1a
operator|=
name|wb1d
expr_stmt|;
else|else
name|err
operator|=
name|subyte
argument_list|(
operator|(
name|caddr_t
operator|)
name|f
operator|->
name|f_wb1a
argument_list|,
name|wb1d
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSW4_SZW
case|:
name|off
operator|=
operator|(
name|off
operator|+
literal|16
operator|)
operator|%
literal|32
expr_stmt|;
if|if
condition|(
name|off
condition|)
name|wb1d
operator|=
operator|(
name|wb1d
operator|>>
operator|(
literal|32
operator|-
name|off
operator|)
operator|)
operator||
operator|(
name|wb1d
operator|<<
name|off
operator|)
expr_stmt|;
if|if
condition|(
name|KDFAULT
argument_list|(
name|f
operator|->
name|f_wb1s
argument_list|)
condition|)
operator|*
operator|(
name|short
operator|*
operator|)
name|f
operator|->
name|f_wb1a
operator|=
name|wb1d
expr_stmt|;
else|else
name|err
operator|=
name|susword
argument_list|(
operator|(
name|caddr_t
operator|)
name|f
operator|->
name|f_wb1a
argument_list|,
name|wb1d
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|fa
operator|=
name|f
operator|->
name|f_wb1a
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|mmudebug
operator|&
name|MDB_WBFAILED
condition|)
name|printf
argument_list|(
name|wberrstr
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
literal|"#1"
argument_list|,
name|fp
operator|->
name|f_pc
argument_list|,
name|f
operator|->
name|f_fa
argument_list|,
name|f
operator|->
name|f_wb1a
argument_list|,
name|f
operator|->
name|f_wb1d
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* 	 * Deal with the "normal" writebacks. 	 * 	 * XXX writeback2 is known to reflect a LINE size writeback after 	 * a MOVE16 was already dealt with above.  Ignore it. 	 */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|(
name|f
operator|->
name|f_wb2s
operator|&
name|SSW4_WBSV
operator|)
operator|&&
operator|(
name|f
operator|->
name|f_wb2s
operator|&
name|SSW4_SZMASK
operator|)
operator|!=
name|SSW4_SZLN
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|mmudebug
operator|&
name|MDB_WBFOLLOW
operator|)
operator|||
name|MDB_ISPID
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
condition|)
name|dumpwb
argument_list|(
literal|2
argument_list|,
name|f
operator|->
name|f_wb2s
argument_list|,
name|f
operator|->
name|f_wb2a
argument_list|,
name|f
operator|->
name|f_wb2d
argument_list|)
expr_stmt|;
name|wbstats
operator|.
name|wb2s
operator|++
expr_stmt|;
name|wbstats
operator|.
name|wbsize
index|[
operator|(
name|f
operator|->
name|f_wb2s
operator|&
name|SSW4_SZMASK
operator|)
operator|>>
literal|5
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|f
operator|->
name|f_wb2s
operator|&
name|SSW4_SZMASK
condition|)
block|{
case|case
name|SSW4_SZLW
case|:
if|if
condition|(
name|KDFAULT
argument_list|(
name|f
operator|->
name|f_wb2s
argument_list|)
condition|)
operator|*
operator|(
name|long
operator|*
operator|)
name|f
operator|->
name|f_wb2a
operator|=
name|f
operator|->
name|f_wb2d
expr_stmt|;
else|else
name|err
operator|=
name|suword
argument_list|(
operator|(
name|caddr_t
operator|)
name|f
operator|->
name|f_wb2a
argument_list|,
name|f
operator|->
name|f_wb2d
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSW4_SZB
case|:
if|if
condition|(
name|KDFAULT
argument_list|(
name|f
operator|->
name|f_wb2s
argument_list|)
condition|)
operator|*
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|f_wb2a
operator|=
name|f
operator|->
name|f_wb2d
expr_stmt|;
else|else
name|err
operator|=
name|subyte
argument_list|(
operator|(
name|caddr_t
operator|)
name|f
operator|->
name|f_wb2a
argument_list|,
name|f
operator|->
name|f_wb2d
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSW4_SZW
case|:
if|if
condition|(
name|KDFAULT
argument_list|(
name|f
operator|->
name|f_wb2s
argument_list|)
condition|)
operator|*
operator|(
name|short
operator|*
operator|)
name|f
operator|->
name|f_wb2a
operator|=
name|f
operator|->
name|f_wb2d
expr_stmt|;
else|else
name|err
operator|=
name|susword
argument_list|(
operator|(
name|caddr_t
operator|)
name|f
operator|->
name|f_wb2a
argument_list|,
name|f
operator|->
name|f_wb2d
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|fa
operator|=
name|f
operator|->
name|f_wb2a
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|mmudebug
operator|&
name|MDB_WBFAILED
condition|)
block|{
name|printf
argument_list|(
name|wberrstr
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
literal|"#2"
argument_list|,
name|fp
operator|->
name|f_pc
argument_list|,
name|f
operator|->
name|f_fa
argument_list|,
name|f
operator|->
name|f_wb2a
argument_list|,
name|f
operator|->
name|f_wb2d
argument_list|)
expr_stmt|;
name|dumpssw
argument_list|(
name|f
operator|->
name|f_ssw
argument_list|)
expr_stmt|;
name|dumpwb
argument_list|(
literal|2
argument_list|,
name|f
operator|->
name|f_wb2s
argument_list|,
name|f
operator|->
name|f_wb2a
argument_list|,
name|f
operator|->
name|f_wb2d
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|(
name|f
operator|->
name|f_wb3s
operator|&
name|SSW4_WBSV
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|mmudebug
operator|&
name|MDB_WBFOLLOW
operator|)
operator|||
name|MDB_ISPID
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
condition|)
name|dumpwb
argument_list|(
literal|3
argument_list|,
name|f
operator|->
name|f_wb3s
argument_list|,
name|f
operator|->
name|f_wb3a
argument_list|,
name|f
operator|->
name|f_wb3d
argument_list|)
expr_stmt|;
name|wbstats
operator|.
name|wb3s
operator|++
expr_stmt|;
name|wbstats
operator|.
name|wbsize
index|[
operator|(
name|f
operator|->
name|f_wb3s
operator|&
name|SSW4_SZMASK
operator|)
operator|>>
literal|5
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|f
operator|->
name|f_wb3s
operator|&
name|SSW4_SZMASK
condition|)
block|{
case|case
name|SSW4_SZLW
case|:
if|if
condition|(
name|KDFAULT
argument_list|(
name|f
operator|->
name|f_wb3s
argument_list|)
condition|)
operator|*
operator|(
name|long
operator|*
operator|)
name|f
operator|->
name|f_wb3a
operator|=
name|f
operator|->
name|f_wb3d
expr_stmt|;
else|else
name|err
operator|=
name|suword
argument_list|(
operator|(
name|caddr_t
operator|)
name|f
operator|->
name|f_wb3a
argument_list|,
name|f
operator|->
name|f_wb3d
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSW4_SZB
case|:
if|if
condition|(
name|KDFAULT
argument_list|(
name|f
operator|->
name|f_wb3s
argument_list|)
condition|)
operator|*
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|f_wb3a
operator|=
name|f
operator|->
name|f_wb3d
expr_stmt|;
else|else
name|err
operator|=
name|subyte
argument_list|(
operator|(
name|caddr_t
operator|)
name|f
operator|->
name|f_wb3a
argument_list|,
name|f
operator|->
name|f_wb3d
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSW4_SZW
case|:
if|if
condition|(
name|KDFAULT
argument_list|(
name|f
operator|->
name|f_wb3s
argument_list|)
condition|)
operator|*
operator|(
name|short
operator|*
operator|)
name|f
operator|->
name|f_wb3a
operator|=
name|f
operator|->
name|f_wb3d
expr_stmt|;
else|else
name|err
operator|=
name|susword
argument_list|(
operator|(
name|caddr_t
operator|)
name|f
operator|->
name|f_wb3a
argument_list|,
name|f
operator|->
name|f_wb3d
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
name|SSW4_SZLN
case|:
name|panic
argument_list|(
literal|"writeback: wb3s indicates LINE write"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|err
condition|)
block|{
name|fa
operator|=
name|f
operator|->
name|f_wb3a
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|mmudebug
operator|&
name|MDB_WBFAILED
condition|)
name|printf
argument_list|(
name|wberrstr
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
literal|"#3"
argument_list|,
name|fp
operator|->
name|f_pc
argument_list|,
name|f
operator|->
name|f_fa
argument_list|,
name|f
operator|->
name|f_wb3a
argument_list|,
name|f
operator|->
name|f_wb3d
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
operator|=
name|oonfault
expr_stmt|;
comment|/* 	 * Determine the cause of the failure if any translating to 	 * a signal.  If the corresponding VA is valid and RO it is 	 * a protection fault (SIGBUS) otherwise consider it an 	 * illegal reference (SIGSEGV). 	 */
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|vm_map_check_protection
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|trunc_page
argument_list|(
name|fa
argument_list|)
argument_list|,
name|round_page
argument_list|(
name|fa
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|)
operator|&&
operator|!
name|vm_map_check_protection
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|trunc_page
argument_list|(
name|fa
argument_list|)
argument_list|,
name|round_page
argument_list|(
name|fa
argument_list|)
argument_list|,
name|VM_PROT_WRITE
argument_list|)
condition|)
name|err
operator|=
name|SIGBUS
expr_stmt|;
else|else
name|err
operator|=
name|SIGSEGV
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_expr_stmt
name|dumpssw
argument_list|(
name|ssw
argument_list|)
specifier|register
name|u_short
name|ssw
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|printf
argument_list|(
literal|" SSW: %x: "
argument_list|,
name|ssw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssw
operator|&
name|SSW4_CP
condition|)
name|printf
argument_list|(
literal|"CP,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssw
operator|&
name|SSW4_CU
condition|)
name|printf
argument_list|(
literal|"CU,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssw
operator|&
name|SSW4_CT
condition|)
name|printf
argument_list|(
literal|"CT,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssw
operator|&
name|SSW4_CM
condition|)
name|printf
argument_list|(
literal|"CM,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssw
operator|&
name|SSW4_MA
condition|)
name|printf
argument_list|(
literal|"MA,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssw
operator|&
name|SSW4_ATC
condition|)
name|printf
argument_list|(
literal|"ATC,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssw
operator|&
name|SSW4_LK
condition|)
name|printf
argument_list|(
literal|"LK,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssw
operator|&
name|SSW4_RW
condition|)
name|printf
argument_list|(
literal|"RW,"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" SZ=%s, TT=%s, TM=%s\n"
argument_list|,
name|f7sz
index|[
operator|(
name|ssw
operator|&
name|SSW4_SZMASK
operator|)
operator|>>
literal|5
index|]
argument_list|,
name|f7tt
index|[
operator|(
name|ssw
operator|&
name|SSW4_TTMASK
operator|)
operator|>>
literal|3
index|]
argument_list|,
name|f7tm
index|[
name|ssw
operator|&
name|SSW4_TMMASK
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dumpwb
argument_list|(
argument|num
argument_list|,
argument|s
argument_list|,
argument|a
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|a
decl_stmt|,
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|printf
argument_list|(
literal|" writeback #%d: VA %x, data %x, SZ=%s, TT=%s, TM=%s\n"
argument_list|,
name|num
argument_list|,
name|a
argument_list|,
name|d
argument_list|,
name|f7sz
index|[
operator|(
name|s
operator|&
name|SSW4_SZMASK
operator|)
operator|>>
literal|5
index|]
argument_list|,
name|f7tt
index|[
operator|(
name|s
operator|&
name|SSW4_TTMASK
operator|)
operator|>>
literal|3
index|]
argument_list|,
name|f7tm
index|[
name|s
operator|&
name|SSW4_TMMASK
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"               PA "
argument_list|)
expr_stmt|;
name|pa
operator|=
name|pmap_extract
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"<invalid address>"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%x, current value %x"
argument_list|,
name|pa
argument_list|,
name|fuword
argument_list|(
operator|(
name|caddr_t
operator|)
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Proces a system call.  */
end_comment

begin_macro
name|syscall
argument_list|(
argument|code
argument_list|,
argument|frame
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frame
name|frame
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|caddr_t
name|params
decl_stmt|;
specifier|register
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|,
name|opc
decl_stmt|,
name|numsys
decl_stmt|;
name|u_int
name|argsize
decl_stmt|;
struct|struct
name|args
block|{
name|int
name|i
index|[
literal|8
index|]
decl_stmt|;
block|}
name|args
struct|;
name|int
name|rval
index|[
literal|2
index|]
decl_stmt|;
name|u_quad_t
name|sticks
decl_stmt|;
ifdef|#
directive|ifdef
name|HPUXCOMPAT
specifier|extern
name|struct
name|sysent
name|hpuxsysent
index|[]
decl_stmt|;
specifier|extern
name|int
name|hpuxnsysent
decl_stmt|,
name|notimp
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_syscall
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|USERMODE
argument_list|(
name|frame
operator|.
name|f_sr
argument_list|)
condition|)
name|panic
argument_list|(
literal|"syscall"
argument_list|)
expr_stmt|;
name|p
operator|=
name|curproc
expr_stmt|;
name|sticks
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|=
name|frame
operator|.
name|f_regs
expr_stmt|;
name|opc
operator|=
name|frame
operator|.
name|f_pc
operator|-
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_HPUX
condition|)
name|callp
operator|=
name|hpuxsysent
operator|,
name|numsys
operator|=
name|hpuxnsysent
expr_stmt|;
else|else
endif|#
directive|endif
name|callp
operator|=
name|sysent
operator|,
name|numsys
operator|=
name|nsysent
expr_stmt|;
name|params
operator|=
operator|(
name|caddr_t
operator|)
name|frame
operator|.
name|f_regs
index|[
name|SP
index|]
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SYS_syscall
case|:
comment|/* 		 * Code is first argument, followed by actual args. 		 */
name|code
operator|=
name|fuword
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* 		 * XXX sigreturn requires special stack manipulation 		 * that is only done if entered via the sigreturn 		 * trap.  Cannot allow it here so make sure we fail. 		 */
if|if
condition|(
name|code
operator|==
name|SYS_sigreturn
condition|)
name|code
operator|=
name|numsys
expr_stmt|;
break|break;
case|case
name|SYS___syscall
case|:
comment|/* 		 * Like syscall, but code is a quad, so as to maintain 		 * quad alignment for the rest of the arguments. 		 */
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_HPUX
condition|)
break|break;
endif|#
directive|endif
name|code
operator|=
name|fuword
argument_list|(
name|params
operator|+
name|_QUAD_LOWWORD
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|+=
sizeof|sizeof
argument_list|(
name|quad_t
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* nothing to do by default */
break|break;
block|}
if|if
condition|(
name|code
operator|<
name|numsys
condition|)
name|callp
operator|+=
name|code
expr_stmt|;
else|else
name|callp
operator|+=
name|SYS_syscall
expr_stmt|;
comment|/* => nosys */
name|argsize
operator|=
name|callp
operator|->
name|sy_narg
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|argsize
operator|&&
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|params
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|,
name|argsize
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|,
name|args
operator|.
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rval
index|[
literal|1
index|]
operator|=
name|frame
operator|.
name|f_regs
index|[
name|D1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXCOMPAT
comment|/* debug kludge */
if|if
condition|(
name|callp
operator|->
name|sy_call
operator|==
name|notimp
condition|)
name|error
operator|=
name|notimp
argument_list|(
name|p
argument_list|,
name|args
operator|.
name|i
argument_list|,
name|rval
argument_list|,
name|code
argument_list|,
name|callp
operator|->
name|sy_narg
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|error
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|p
argument_list|,
operator|&
name|args
argument_list|,
name|rval
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
comment|/* 		 * Reinitialize proc pointer `p' as it may be different 		 * if this is a child returning from fork syscall. 		 */
name|p
operator|=
name|curproc
expr_stmt|;
name|frame
operator|.
name|f_regs
index|[
name|D0
index|]
operator|=
name|rval
index|[
literal|0
index|]
expr_stmt|;
name|frame
operator|.
name|f_regs
index|[
name|D1
index|]
operator|=
name|rval
index|[
literal|1
index|]
expr_stmt|;
name|frame
operator|.
name|f_sr
operator|&=
operator|~
name|PSL_C
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
name|frame
operator|.
name|f_pc
operator|=
name|opc
expr_stmt|;
break|break;
case|case
name|EJUSTRETURN
case|:
break|break;
comment|/* nothing to do */
default|default:
name|bad
label|:
ifdef|#
directive|ifdef
name|HPUXCOMPAT
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_HPUX
condition|)
name|error
operator|=
name|bsdtohpuxerrno
argument_list|(
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|frame
operator|.
name|f_regs
index|[
name|D0
index|]
operator|=
name|error
expr_stmt|;
name|frame
operator|.
name|f_sr
operator||=
name|PSL_C
expr_stmt|;
break|break;
block|}
name|userret
argument_list|(
name|p
argument_list|,
operator|&
name|frame
argument_list|,
name|sticks
argument_list|,
operator|(
name|u_int
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|error
argument_list|,
name|rval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

end_unit

