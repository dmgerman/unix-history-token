begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1982, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: clock.c 1.18 91/01/21$  *  *	@(#)clock.c	8.2 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * HPs use the MC6840 PTM with the following arrangement:  *	Timers 1 and 3 are externally driver from a 25Mhz source.  *	Output from timer 3 is tied to the input of timer 2.  * The latter makes it possible to use timers 3 and 2 together to get  * a 32-bit countdown timer.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/hilreg.h>
end_include

begin_include
include|#
directive|include
file|<hp300/hp300/clockreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GPROF
end_ifdef

begin_include
include|#
directive|include
file|<sys/gmon.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|clkstd
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|clkint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clock interval, as loaded */
end_comment

begin_comment
comment|/*  * Statistics clock interval and variance, in usec.  Variance must be a  * power of two.  Since this gives us an even number, not an odd number,  * we discard one case and compensate.  That is, a variance of 1024 would  * give us offsets in [0..1023].  Instead, we take offsets in [1..1023].  * This is symmetric about the point 512, or statvar/2, and thus averages  * to that value (assuming uniform random numbers).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|statvar
init|=
literal|1024
operator|/
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* {stat,prof}clock variance */
end_comment

begin_decl_stmt
specifier|static
name|int
name|statmin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* statclock interval - variance/2 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|profmin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* profclock interval - variance/2 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|timer3min
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current, from above choices */
end_comment

begin_decl_stmt
specifier|static
name|int
name|statprev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous value in stat timer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|month_days
index|[
literal|12
index|]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|bbc_tm
modifier|*
name|gmt_to_bbc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|u_char
name|bbc_registers
index|[
literal|13
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|write_bbc_reg
argument_list|()
decl_stmt|,
name|read_bbc_reg
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hil_dev
modifier|*
name|bbcaddr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Machine-dependent clock routines.  *  * A note on the real-time clock:  * We actually load the clock with interval-1 instead of interval.  * This is because the counter decrements to zero after N+1 enabled clock  * periods where N is the value loaded into the counter.  *  * The frequencies of the HP300 clocks must be a multiple of four  * microseconds (since the clock counts in 4 us units).  */
end_comment

begin_define
define|#
directive|define
name|COUNTS_PER_SEC
value|(1000000 / CLK_RESOLUTION)
end_define

begin_comment
comment|/*  * Set up the real-time and statistics clocks.  Leave stathz 0 only if  * no alternative timer is available.  *  */
end_comment

begin_macro
name|cpu_initclocks
argument_list|()
end_macro

begin_block
block|{
specifier|register
specifier|volatile
name|struct
name|clkreg
modifier|*
name|clk
decl_stmt|;
specifier|register
name|int
name|intvl
decl_stmt|,
name|statint
decl_stmt|,
name|profint
decl_stmt|,
name|minint
decl_stmt|;
name|clkstd
index|[
literal|0
index|]
operator|=
name|IIOV
argument_list|(
literal|0x5F8000
argument_list|)
expr_stmt|;
comment|/* XXX grot */
name|clk
operator|=
operator|(
specifier|volatile
expr|struct
name|clkreg
operator|*
operator|)
name|clkstd
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|COUNTS_PER_SEC
operator|%
name|hz
condition|)
block|{
name|printf
argument_list|(
literal|"cannot get %d Hz clock; using 100 Hz\n"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|hz
operator|=
literal|100
expr_stmt|;
block|}
comment|/* 	 * Clock has several counters, so we can always use separate 	 * statclock. 	 */
if|if
condition|(
name|stathz
operator|==
literal|0
condition|)
comment|/* XXX should be set in param.c */
name|stathz
operator|=
name|hz
expr_stmt|;
elseif|else
if|if
condition|(
name|COUNTS_PER_SEC
operator|%
name|stathz
condition|)
block|{
name|printf
argument_list|(
literal|"cannot get %d Hz statclock; using 100 Hz\n"
argument_list|,
name|stathz
argument_list|)
expr_stmt|;
name|stathz
operator|=
literal|100
expr_stmt|;
block|}
if|if
condition|(
name|profhz
operator|==
literal|0
condition|)
comment|/* XXX should be set in param.c */
name|profhz
operator|=
name|stathz
operator|*
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|profhz
operator|<
name|stathz
operator|||
name|COUNTS_PER_SEC
operator|%
name|profhz
condition|)
block|{
name|printf
argument_list|(
literal|"cannot get %d Hz profclock; using %d Hz\n"
argument_list|,
name|profhz
argument_list|,
name|stathz
argument_list|)
expr_stmt|;
name|profhz
operator|=
name|stathz
expr_stmt|;
block|}
name|intvl
operator|=
name|COUNTS_PER_SEC
operator|/
name|hz
expr_stmt|;
name|statint
operator|=
name|COUNTS_PER_SEC
operator|/
name|stathz
expr_stmt|;
name|profint
operator|=
name|COUNTS_PER_SEC
operator|/
name|profhz
expr_stmt|;
name|minint
operator|=
name|statint
operator|/
literal|2
operator|+
literal|100
expr_stmt|;
while|while
condition|(
name|statvar
operator|>
name|minint
condition|)
name|statvar
operator|>>=
literal|1
expr_stmt|;
name|tick
operator|=
name|intvl
operator|*
name|CLK_RESOLUTION
expr_stmt|;
comment|/* adjust interval counts, per note above */
name|intvl
operator|--
expr_stmt|;
name|statint
operator|--
expr_stmt|;
name|profint
operator|--
expr_stmt|;
comment|/* calculate base reload values */
name|clkint
operator|=
name|intvl
expr_stmt|;
name|statmin
operator|=
name|statint
operator|-
operator|(
name|statvar
operator|>>
literal|1
operator|)
expr_stmt|;
name|profmin
operator|=
name|profint
operator|-
operator|(
name|statvar
operator|>>
literal|1
operator|)
expr_stmt|;
name|timer3min
operator|=
name|statmin
expr_stmt|;
name|statprev
operator|=
name|statint
expr_stmt|;
comment|/* finally, load hardware */
name|clk
operator|->
name|clk_cr2
operator|=
name|CLK_CR1
expr_stmt|;
name|clk
operator|->
name|clk_cr1
operator|=
name|CLK_RESET
expr_stmt|;
asm|asm
specifier|volatile
asm|(" movpw %0,%1@(5)" : : "d" (intvl), "a" (clk));
asm|asm
specifier|volatile
asm|(" movpw %0,%1@(9)" : : "d" (0), "a" (clk));
asm|asm
specifier|volatile
asm|(" movpw %0,%1@(13)" : : "d" (statint), "a" (clk));
name|clk
operator|->
name|clk_cr2
operator|=
name|CLK_CR1
expr_stmt|;
name|clk
operator|->
name|clk_cr1
operator|=
name|CLK_IENAB
expr_stmt|;
name|clk
operator|->
name|clk_cr2
operator|=
name|CLK_CR3
expr_stmt|;
name|clk
operator|->
name|clk_cr3
operator|=
name|CLK_IENAB
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * We assume newhz is either stathz or profhz, and that neither will  * change after being set up above.  Could recalculate intervals here  * but that would be a drag.  */
end_comment

begin_function
name|void
name|setstatclockrate
parameter_list|(
name|newhz
parameter_list|)
name|int
name|newhz
decl_stmt|;
block|{
if|if
condition|(
name|newhz
operator|==
name|stathz
condition|)
name|timer3min
operator|=
name|statmin
expr_stmt|;
else|else
name|timer3min
operator|=
name|profmin
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Statistics/profiling clock interrupt.  Compute a new interval.  * Interrupt has already been cleared.  *  * DO THIS INLINE IN locore.s?  */
end_comment

begin_function
name|void
name|statintr
parameter_list|(
name|fp
parameter_list|)
name|struct
name|clockframe
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|clkreg
modifier|*
name|clk
decl_stmt|;
specifier|register
name|int
name|newint
decl_stmt|,
name|r
decl_stmt|,
name|var
decl_stmt|;
name|clk
operator|=
operator|(
specifier|volatile
expr|struct
name|clkreg
operator|*
operator|)
name|clkstd
index|[
literal|0
index|]
expr_stmt|;
name|var
operator|=
name|statvar
expr_stmt|;
do|do
block|{
name|r
operator|=
name|random
argument_list|()
operator|&
operator|(
name|var
operator|-
literal|1
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|r
operator|==
literal|0
condition|)
do|;
name|newint
operator|=
name|timer3min
operator|+
name|r
expr_stmt|;
comment|/* 	 * The timer was automatically reloaded with the previous latch 	 * value at the time of the interrupt.  Compensate now for the 	 * amount of time that has run off since then (minimum of 2-12 	 * timer ticks depending on CPU type) plus one tick roundoff. 	 * This should keep us closer to the mean. 	 */
asm|asm
specifier|volatile
asm|(" clrl %0; movpw %1@(13),%0" : "=d" (r) : "a" (clk));
name|newint
operator|-=
operator|(
name|statprev
operator|-
name|r
operator|+
literal|1
operator|)
expr_stmt|;
asm|asm
specifier|volatile
asm|(" movpw %0,%1@(13)" : : "d" (newint), "a" (clk));
name|statprev
operator|=
name|newint
expr_stmt|;
name|statclock
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the best possible estimate of the current time.  */
end_comment

begin_expr_stmt
name|microtime
argument_list|(
name|tvp
argument_list|)
specifier|register
expr|struct
name|timeval
operator|*
name|tvp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
specifier|volatile
name|struct
name|clkreg
modifier|*
name|clk
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|u
decl_stmt|,
name|t
decl_stmt|,
name|u2
decl_stmt|,
name|s2
decl_stmt|;
comment|/* 	 * Read registers from slowest-changing to fastest-changing, 	 * then re-read out to slowest.  If the values read before the 	 * innermost match those read after, the innermost value is 	 * consistent with the outer values.  If not, it may not be and 	 * we must retry.  Typically this loop runs only once; occasionally 	 * it runs twice, and only rarely does it run longer. 	 * 	 * (Using this loop avoids the need to block interrupts.) 	 */
name|clk
operator|=
operator|(
specifier|volatile
expr|struct
name|clkreg
operator|*
operator|)
name|clkstd
index|[
literal|0
index|]
expr_stmt|;
do|do
block|{
name|s
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|u
operator|=
name|time
operator|.
name|tv_usec
expr_stmt|;
asm|asm
specifier|volatile
asm|(" clrl %0; movpw %1@(5),%0" 			      : "=d" (t) : "a" (clk));
name|u2
operator|=
name|time
operator|.
name|tv_usec
expr_stmt|;
name|s2
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
block|}
do|while
condition|(
name|u
operator|!=
name|u2
operator|||
name|s
operator|!=
name|s2
condition|)
do|;
name|u
operator|+=
operator|(
name|clkint
operator|-
name|t
operator|)
operator|*
name|CLK_RESOLUTION
expr_stmt|;
if|if
condition|(
name|u
operator|>=
literal|1000000
condition|)
block|{
comment|/* normalize */
name|s
operator|++
expr_stmt|;
name|u
operator|-=
literal|1000000
expr_stmt|;
block|}
name|tvp
operator|->
name|tv_sec
operator|=
name|s
expr_stmt|;
name|tvp
operator|->
name|tv_usec
operator|=
name|u
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialize the time of day register, based on the time base which is, e.g.  * from a filesystem.  */
end_comment

begin_macro
name|inittodr
argument_list|(
argument|base
argument_list|)
end_macro

begin_decl_stmt
name|time_t
name|base
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_long
name|timbuf
init|=
name|base
decl_stmt|;
comment|/* assume no battery clock exists */
specifier|static
name|int
name|bbcinited
init|=
literal|0
decl_stmt|;
comment|/* XXX */
if|if
condition|(
operator|!
name|bbcinited
condition|)
block|{
if|if
condition|(
name|badbaddr
argument_list|(
operator|&
name|BBCADDR
operator|->
name|hil_stat
argument_list|)
condition|)
name|printf
argument_list|(
literal|"WARNING: no battery clock\n"
argument_list|)
expr_stmt|;
else|else
name|bbcaddr
operator|=
name|BBCADDR
expr_stmt|;
name|bbcinited
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * bbc_to_gmt converts and stores the gmt in timbuf. 	 * If an error is detected in bbc_to_gmt, or if the filesystem 	 * time is more recent than the gmt time in the clock, 	 * then use the filesystem time and warn the user.  	 */
if|if
condition|(
operator|!
name|bbc_to_gmt
argument_list|(
operator|&
name|timbuf
argument_list|)
operator|||
name|timbuf
operator|<
name|base
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: bad date in battery clock\n"
argument_list|)
expr_stmt|;
name|timbuf
operator|=
name|base
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|<
literal|5
operator|*
name|SECYR
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: preposterous time in file system"
argument_list|)
expr_stmt|;
name|timbuf
operator|=
literal|6
operator|*
name|SECYR
operator|+
literal|186
operator|*
name|SECDAY
operator|+
name|SECDAY
operator|/
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|" -- CHECK AND RESET THE DATE!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Battery clock does not store usec's, so forget about it. */
name|time
operator|.
name|tv_sec
operator|=
name|timbuf
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Restore the time of day hardware after a time change.  */
end_comment

begin_macro
name|resettodr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|bbc_tm
modifier|*
name|tmptr
decl_stmt|;
name|tmptr
operator|=
name|gmt_to_bbc
argument_list|(
name|time
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|decimal_to_bbc
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|tmptr
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|decimal_to_bbc
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|,
name|tmptr
operator|->
name|tm_min
argument_list|)
expr_stmt|;
name|decimal_to_bbc
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|,
name|tmptr
operator|->
name|tm_hour
argument_list|)
expr_stmt|;
name|decimal_to_bbc
argument_list|(
literal|7
argument_list|,
literal|8
argument_list|,
name|tmptr
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|decimal_to_bbc
argument_list|(
literal|9
argument_list|,
literal|10
argument_list|,
name|tmptr
operator|->
name|tm_mon
argument_list|)
expr_stmt|;
name|decimal_to_bbc
argument_list|(
literal|11
argument_list|,
literal|12
argument_list|,
name|tmptr
operator|->
name|tm_year
argument_list|)
expr_stmt|;
comment|/* Some bogusness to deal with seemingly broken hardware. Nonsense */
name|bbc_registers
index|[
literal|5
index|]
operator|=
operator|(
operator|(
name|tmptr
operator|->
name|tm_hour
operator|/
literal|10
operator|)
operator|&
literal|0x03
operator|)
operator|+
literal|8
expr_stmt|;
name|write_bbc_reg
argument_list|(
literal|15
argument_list|,
literal|13
argument_list|)
expr_stmt|;
comment|/* reset prescalar */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NUM_BBC_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bbc_registers
index|[
name|i
index|]
operator|!=
name|write_bbc_reg
argument_list|(
name|i
argument_list|,
name|bbc_registers
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot set battery backed clock\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_function
name|struct
name|bbc_tm
modifier|*
name|gmt_to_bbc
parameter_list|(
name|tim
parameter_list|)
name|long
name|tim
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|hms
decl_stmt|,
name|day
decl_stmt|;
specifier|static
name|struct
name|bbc_tm
name|rt
decl_stmt|;
name|day
operator|=
name|tim
operator|/
name|SECDAY
expr_stmt|;
name|hms
operator|=
name|tim
operator|%
name|SECDAY
expr_stmt|;
comment|/* Hours, minutes, seconds are easy */
name|rt
operator|.
name|tm_hour
operator|=
name|hms
operator|/
literal|3600
expr_stmt|;
name|rt
operator|.
name|tm_min
operator|=
operator|(
name|hms
operator|%
literal|3600
operator|)
operator|/
literal|60
expr_stmt|;
name|rt
operator|.
name|tm_sec
operator|=
operator|(
name|hms
operator|%
literal|3600
operator|)
operator|%
literal|60
expr_stmt|;
comment|/* Number of years in days */
for|for
control|(
name|i
operator|=
name|STARTOFTIME
operator|-
literal|1900
init|;
name|day
operator|>=
name|days_in_year
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
name|day
operator|-=
name|days_in_year
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|rt
operator|.
name|tm_year
operator|=
name|i
expr_stmt|;
comment|/* Number of months in days left */
if|if
condition|(
name|leapyear
argument_list|(
name|rt
operator|.
name|tm_year
argument_list|)
condition|)
name|days_in_month
argument_list|(
name|FEBRUARY
argument_list|)
operator|=
literal|29
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|day
operator|>=
name|days_in_month
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
name|day
operator|-=
name|days_in_month
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|days_in_month
argument_list|(
name|FEBRUARY
argument_list|)
operator|=
literal|28
expr_stmt|;
name|rt
operator|.
name|tm_mon
operator|=
name|i
expr_stmt|;
comment|/* Days are what is left over (+1) from all that. */
name|rt
operator|.
name|tm_mday
operator|=
name|day
operator|+
literal|1
expr_stmt|;
return|return
operator|(
operator|&
name|rt
operator|)
return|;
block|}
end_function

begin_macro
name|bbc_to_gmt
argument_list|(
argument|timbuf
argument_list|)
end_macro

begin_decl_stmt
name|u_long
modifier|*
name|timbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_long
name|tmp
decl_stmt|;
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|min
decl_stmt|,
name|sec
decl_stmt|;
name|read_bbc
argument_list|()
expr_stmt|;
name|sec
operator|=
name|bbc_to_decimal
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|min
operator|=
name|bbc_to_decimal
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Hours are different for some reason. Makes no sense really. 	 */
name|hour
operator|=
operator|(
operator|(
name|bbc_registers
index|[
literal|5
index|]
operator|&
literal|0x03
operator|)
operator|*
literal|10
operator|)
operator|+
name|bbc_registers
index|[
literal|4
index|]
expr_stmt|;
name|day
operator|=
name|bbc_to_decimal
argument_list|(
literal|8
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|month
operator|=
name|bbc_to_decimal
argument_list|(
literal|10
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|year
operator|=
name|bbc_to_decimal
argument_list|(
literal|12
argument_list|,
literal|11
argument_list|)
operator|+
literal|1900
expr_stmt|;
name|range_test
argument_list|(
name|hour
argument_list|,
literal|0
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|range_test
argument_list|(
name|day
argument_list|,
literal|1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|range_test
argument_list|(
name|month
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|range_test
argument_list|(
name|year
argument_list|,
name|STARTOFTIME
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|STARTOFTIME
init|;
name|i
operator|<
name|year
condition|;
name|i
operator|++
control|)
name|tmp
operator|+=
name|days_in_year
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|leapyear
argument_list|(
name|year
argument_list|)
operator|&&
name|month
operator|>
name|FEBRUARY
condition|)
name|tmp
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|month
condition|;
name|i
operator|++
control|)
name|tmp
operator|+=
name|days_in_month
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tmp
operator|+=
operator|(
name|day
operator|-
literal|1
operator|)
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
name|tmp
operator|*
literal|24
operator|+
name|hour
operator|)
operator|*
literal|60
operator|+
name|min
operator|)
operator|*
literal|60
operator|+
name|sec
expr_stmt|;
operator|*
name|timbuf
operator|=
name|tmp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|read_bbc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|read_okay
decl_stmt|;
name|read_okay
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|read_okay
condition|)
block|{
name|read_okay
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NUM_BBC_REGS
condition|;
name|i
operator|++
control|)
name|bbc_registers
index|[
name|i
index|]
operator|=
name|read_bbc_reg
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NUM_BBC_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bbc_registers
index|[
name|i
index|]
operator|!=
name|read_bbc_reg
argument_list|(
name|i
argument_list|)
condition|)
name|read_okay
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_function
name|u_char
name|read_bbc_reg
parameter_list|(
name|reg
parameter_list|)
name|int
name|reg
decl_stmt|;
block|{
name|u_char
name|data
init|=
name|reg
decl_stmt|;
if|if
condition|(
name|bbcaddr
condition|)
block|{
name|send_hil_cmd
argument_list|(
name|bbcaddr
argument_list|,
name|BBC_SET_REG
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|bbcaddr
argument_list|,
name|BBC_READ_REG
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
name|u_char
name|write_bbc_reg
parameter_list|(
name|reg
parameter_list|,
name|data
parameter_list|)
name|int
name|reg
decl_stmt|;
name|u_int
name|data
decl_stmt|;
block|{
name|u_char
name|tmp
decl_stmt|;
name|tmp
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|data
operator|<<
name|HIL_SSHIFT
operator|)
operator||
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bbcaddr
condition|)
block|{
name|send_hil_cmd
argument_list|(
name|bbcaddr
argument_list|,
name|BBC_SET_REG
argument_list|,
operator|&
name|tmp
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|bbcaddr
argument_list|,
name|BBC_WRITE_REG
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|send_hil_cmd
argument_list|(
name|bbcaddr
argument_list|,
name|BBC_READ_REG
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tmp
operator|)
return|;
block|}
end_function

end_unit

