begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1982, 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: srt0.c 1.8 88/12/03$  *  *	@(#)srt0.c	7.1 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Startup code for standalone system  */
end_comment

begin_expr_stmt
operator|.
name|globl
name|begin
operator|.
name|globl
name|_end
operator|.
name|globl
name|_edata
operator|.
name|globl
name|_main
operator|.
name|globl
name|_configure
operator|.
name|globl
name|_openfirst
operator|.
name|globl
name|__rtt
operator|.
name|globl
name|_lowram
operator|,
name|_howto
operator|,
name|_devtype
name|STACK
operator|=
literal|0xfffff000
operator||
name|below
name|the
name|ROM
name|page
name|BOOTTYPE
operator|=
literal|0xfffffdc0
name|LOWRAM
operator|=
literal|0xfffffdce
name|MSUS
operator|=
literal|0xfffffedc
operator||
name|MSUS
argument_list|(
argument|?
argument_list|)
name|structure
name|VECTORS
operator|=
literal|0xfffffee0
operator||
name|beginning
name|of
name|jump
name|vectors
name|NMIRESET
operator|=
literal|0xffffff9c
operator||
name|reset
name|vector
name|BUSERR
operator|=
literal|0xfffffffc
name|MAXADDR
operator|=
literal|0xfffff000
name|NBPG
operator|=
literal|4096
operator|.
name|data
name|_lowram
operator|:
operator|.
name|long
literal|0
name|_howto
operator|:
operator|.
name|long
literal|0
name|_devtype
operator|:
operator|.
name|long
literal|0
operator|.
name|text
name|begin
operator|:
name|movl
operator|#
name|STACK
operator|,
name|sp
name|moveq
operator|#
literal|47
operator|,
name|d0
operator||
operator|#
name|of
name|vectors
operator|-
literal|1
name|movl
operator|#
name|VECTORS
operator|+
literal|2
operator|,
name|a0
operator||
name|addr
name|part
name|of
name|first
name|vector
name|vecloop
operator|:
name|movl
operator|#
name|trap
operator|,
name|a0
expr|@
operator||
name|make
name|it
name|direct
name|to
name|trap
name|addql
operator|#
literal|6
operator|,
name|a0
operator||
name|move
name|to
name|next
name|vector
name|addr
name|dbf
name|d0
operator|,
name|vecloop
operator||
name|go
name|til
name|done
name|movl
operator|#
name|NMIRESET
operator|,
name|a0
operator||
name|NMI
name|keyboard
name|reset
name|addr
name|movl
operator|#
name|nmi
operator|,
name|a0
expr|@
operator||
name|catch
name|in
name|reset
name|routine
name|cmpw
operator|#
literal|12
operator|,
name|BOOTTYPE
operator||
name|is
name|this
name|a
name|reboot
argument_list|(
name|REQ_REBOOT
argument_list|)
condition|?
name|jne
name|notreboot
operator||
name|no
operator|,
name|skip
name|movl
operator|#
name|MAXADDR
operator|,
name|a0
operator||
name|find
name|last
name|page
name|movl
name|a0
expr|@
operator|+
operator|,
name|d7
operator||
name|and
name|extract
name|howto
operator|,
name|devtype
name|movl
name|a0
expr|@
operator|+
operator|,
name|d6
operator||
name|from
name|where
name|doboot
argument_list|()
name|left
name|them
name|jra
name|boot1
comment|/*  * At this point we do not know which logical hpib the given select  * code refers to.  So we just put the select code in the adaptor field  * where hpibinit() can replace it with the logical hpib number.  * Note that this may clobber the B_DEVMAGIC field but that isn't set  * til later anyway.  */
name|notreboot
operator|:
name|cmpw
operator|#
literal|18
operator|,
name|BOOTTYPE
operator||
name|does
name|the
name|user
name|want
name|to
name|interact
condition|?
name|jeq
name|askme
operator||
name|yes
operator|,
name|go
name|to
name|it
name|movl
name|MSUS
operator|,
name|d1
operator||
name|no
operator|,
name|get
name|rom
name|info
name|movw
name|d1
operator|,
name|d6
operator||
name|MSUS
name|comes
name|with
name|SC
name|in
name|upper
operator|,
name|unit
name|in
name|lower
name|swap
name|d6
operator||
name|put
name|in
name|place
name|movw
operator|#
literal|2
operator|,
name|d6
operator||
name|assume
literal|'a'
name|partition
name|of
name|rd
name|disk
name|moveq
operator|#
literal|0
operator|,
name|d7
operator||
expr|default
name|to
name|RB_AUTOBOOT
name|jra
name|boot1
name|askme
operator|:
name|moveq
operator|#
literal|7
operator|,
name|d6
operator||
expr|default
name|to
name|HP
operator|-
name|IB
name|at
name|sc7
name|lslw
operator|#
literal|8
operator|,
name|d6
operator||
name|position
name|as
name|adaptor
name|number
name|swap
name|d6
operator||
name|put
name|in
name|place
argument_list|(
argument|note implied unit
literal|0
argument_list|)
name|movw
operator|#
literal|2
operator|,
name|d6
operator||
name|assume
literal|'a'
name|partition
name|of
name|rd
name|disk
name|moveq
operator|#
literal|3
operator|,
name|d7
operator||
expr|default
name|to
name|RB_SINGLE
operator||
name|RB_ASKNAME
name|boot1
operator|:
name|movl
name|d6
operator|,
name|_devtype
operator||
name|save
name|devtype
name|and
name|howto
name|movl
name|d7
operator|,
name|_howto
operator||
name|globally
name|so
name|all
name|can
name|access
name|movl
name|LOWRAM
operator|,
name|d0
operator||
name|read
name|lowram
name|value
name|from
name|bootrom
name|addl
operator|#
name|NBPG
operator|,
name|d0
operator||
name|must
name|preserve
name|this
end_expr_stmt

begin_for
for|for bootrom to reboot 	andl	#0xfffff000
operator|,
name|d0
operator||
name|round
name|to
name|next
name|page
name|movl
name|d0
operator|,
name|_lowram
operator||
name|stash
name|that
name|value
name|start
operator|:
name|movl
operator|#
name|_edata
operator|,
name|a2
operator||
name|start
name|of
name|BSS
name|movl
operator|#
name|_end
operator|,
name|a3
operator||
name|end
name|clr
operator|:
name|clrb
name|a2
expr|@
operator|+
operator||
name|clear
name|BSS
name|cmpl
name|a2
operator|,
name|a3
operator||
name|done
condition|?
name|bne
name|clr
operator||
name|no
operator|,
name|keep
name|going
name|jsr
name|_configure
operator||
name|configure
name|critical
name|devices
name|movl
operator|#
literal|1
operator|,
name|_openfirst
operator||
name|mark
name|this
name|as
name|the
name|first
name|open
name|jsr
name|_main
operator||
name|lets
name|go
name|__rtt
operator|:
name|movl
operator|#
literal|3
operator|,
name|_howto
operator||
name|restarts
name|get
name|RB_SINGLE
operator||
name|RB_ASKNAME
name|jmp
name|start
comment|/*  * probe a location and see if it causes a bus error  */
operator|.
name|globl
name|_badaddr
name|_badaddr
operator|:
name|movl
name|BUSERR
operator|,
name|__bsave
operator||
name|save
name|ROM
name|bus
name|error
name|handler
name|address
name|movl
name|sp
operator|,
name|__ssave
operator||
name|and
name|current
name|stack
name|pointer
name|movl
operator|#
name|catchbad
operator|,
name|BUSERR
operator||
name|plug
name|in
name|our
name|handler
name|movl
name|sp
expr|@
operator|(
literal|4
operator|)
operator|,
name|a0
operator||
name|address
name|to
name|probe
name|movw
name|a0
expr|@
operator|,
name|d1
operator||
end_for

begin_do
do|do
name|it
name|movl
name|__bsave
decl_stmt|,
name|BUSERR
decl|| if
name|we
name|got
name|here
decl_stmt|,
name|it
name|didn
decl|'
end_do

unit|t fault 	clrl	d0		| return that this was not a bad addr 	rts  catchbad: 	movl	__bsave,BUSERR	| got a bus error, so restore old handler 	movl	__ssave,sp	| manually restore stack 	moveq	#1,d0		| indicate that we got a fault 	rts			| return to caller of badaddr()  __bsave: 	.long	0 __ssave: 	.long	0  	.globl	_trap trap: 	moveml	#0xFFFF,sp@-	| save registers 	movl	sp,sp@-		| push pointer to frame 	jsr	_trap		| call C routine to deal with it 	stop	#0x2700		| stop cold  nmi: 	movw	#18,BOOTTYPE	| mark as system switch 	jsr	_kbdnmi		| clear the interrupt 	jra	begin		| start over  #ifdef ROMPRF 	.globl	_romout _romout: 	movl	sp@(4),d0	| line number 	movl	sp@(8),a0	| string 	jsr	0x150		| do it 	rts #endif
end_unit

