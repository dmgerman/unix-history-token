begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: autoconf.c 1.16 92/05/29$  *  *	@(#)autoconf.c	7.7 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<hp300/stand/samachdep.h>
end_include

begin_include
include|#
directive|include
file|<hp300/stand/rominfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/grfreg.h>
end_include

begin_comment
comment|/*  * Mapping of ROM MSUS types to BSD major device numbers  * WARNING: major numbers must match bdevsw indices in hp300/conf.c.  */
end_comment

begin_decl_stmt
name|char
name|rom2mdev
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0-13: none */
literal|4
block|,
comment|/* 14: SCSI disk */
literal|0
block|,
comment|/* 15: none */
literal|2
block|,
comment|/* 16: CS/80 device on HPIB */
literal|2
block|,
comment|/* 17: CS/80 device on HPIB */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 18-31: none */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hp_hw
name|sc_table
index|[
name|MAXCTLRS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cpuspeed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|internalhpib
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|printrominfo() { 	struct rominfo *rp = (struct rominfo *)ROMADDR;  	printf("boottype %x, name %s, lowram %x, sysflag %x\n", 	       rp->boottype, rp->name, rp->lowram, rp->sysflag&0xff); 	printf("rambase %x, ndrives %x, sysflag2 %x, msus %x\n", 	       rp->rambase, rp->ndrives, rp->sysflag2&0xff, rp->msus); }
endif|#
directive|endif
end_endif

begin_macro
name|configure
argument_list|()
end_macro

begin_block
block|{
name|u_long
name|msustobdev
parameter_list|()
function_decl|;
switch|switch
condition|(
name|machineid
condition|)
block|{
case|case
name|HP_320
case|:
case|case
name|HP_330
case|:
case|case
name|HP_340
case|:
name|cpuspeed
operator|=
name|MHZ_16
expr_stmt|;
break|break;
case|case
name|HP_350
case|:
case|case
name|HP_360
case|:
name|cpuspeed
operator|=
name|MHZ_25
expr_stmt|;
break|break;
case|case
name|HP_370
case|:
name|cpuspeed
operator|=
name|MHZ_33
expr_stmt|;
break|break;
case|case
name|HP_375
case|:
name|cpuspeed
operator|=
name|MHZ_50
expr_stmt|;
break|break;
case|case
name|HP_380
case|:
name|cpuspeed
operator|=
name|MHZ_25
operator|*
literal|2
expr_stmt|;
comment|/* XXX */
break|break;
default|default:
comment|/* assume the slowest */
name|cpuspeed
operator|=
name|MHZ_16
expr_stmt|;
break|break;
block|}
name|find_devs
argument_list|()
expr_stmt|;
name|cninit
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|printrominfo();
endif|#
directive|endif
name|hpibinit
argument_list|()
expr_stmt|;
name|scsiinit
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|bootdev
operator|&
name|B_MAGICMASK
operator|)
operator|!=
name|B_DEVMAGIC
condition|)
name|bootdev
operator|=
name|msustobdev
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Convert HP MSUS to a valid bootdev layout:  *	TYPE comes from MSUS device type as mapped by rom2mdev  *	PARTITION is set to 0 ('a')  *	UNIT comes from MSUS unit (almost always 0)  *	CONTROLLER comes from MSUS primary address  *	ADAPTOR comes from SCSI/HPIB driver logical unit number  *		(passed back via unused hw_pa field)  */
end_comment

begin_function
name|u_long
name|msustobdev
parameter_list|()
block|{
name|struct
name|rominfo
modifier|*
name|rp
init|=
operator|(
expr|struct
name|rominfo
operator|*
operator|)
name|ROMADDR
decl_stmt|;
name|u_long
name|bdev
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|hp_hw
modifier|*
name|hw
decl_stmt|;
name|int
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
name|rp
operator|->
name|msus
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
for|for
control|(
name|hw
operator|=
name|sc_table
init|;
name|hw
operator|<
operator|&
name|sc_table
index|[
name|MAXCTLRS
index|]
condition|;
name|hw
operator|++
control|)
if|if
condition|(
name|hw
operator|->
name|hw_sc
operator|==
name|sc
condition|)
break|break;
name|bdev
operator||=
name|rom2mdev
index|[
operator|(
name|rp
operator|->
name|msus
operator|>>
literal|24
operator|)
operator|&
literal|0x1F
index|]
operator|<<
name|B_TYPESHIFT
expr_stmt|;
name|bdev
operator||=
literal|0
operator|<<
name|B_PARTITIONSHIFT
expr_stmt|;
name|bdev
operator||=
operator|(
operator|(
name|rp
operator|->
name|msus
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
operator|)
operator|<<
name|B_UNITSHIFT
expr_stmt|;
name|bdev
operator||=
operator|(
name|rp
operator|->
name|msus
operator|&
literal|0xFF
operator|)
operator|<<
name|B_CONTROLLERSHIFT
expr_stmt|;
name|bdev
operator||=
operator|(
name|int
operator|)
name|hw
operator|->
name|hw_pa
operator|<<
name|B_ADAPTORSHIFT
expr_stmt|;
name|bdev
operator||=
name|B_DEVMAGIC
expr_stmt|;
if|#
directive|if
literal|0
block|printf("msus %x -> bdev %x\n", rp->msus, bdev);
endif|#
directive|endif
return|return
operator|(
name|bdev
operator|)
return|;
block|}
end_function

begin_macro
name|sctoaddr
argument_list|(
argument|sc
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|sc
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|GRFIADDR
operator|)
return|;
if|if
condition|(
name|sc
operator|==
literal|7
operator|&&
name|internalhpib
condition|)
return|return
operator|(
name|internalhpib
operator|)
return|;
if|if
condition|(
name|sc
operator|<
literal|32
condition|)
return|return
operator|(
name|DIOBASE
operator|+
name|sc
operator|*
name|DIOCSIZE
operator|)
return|;
if|if
condition|(
name|sc
operator|>=
literal|132
condition|)
return|return
operator|(
name|DIOIIBASE
operator|+
operator|(
name|sc
operator|-
literal|132
operator|)
operator|*
name|DIOIICSIZE
operator|)
return|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Probe all DIO select codes (0 - 32), the internal display address,  * and DIO-II select codes (132 - 256).  *  * Note that we only care about displays, SCSIs and HP-IBs.  */
end_comment

begin_macro
name|find_devs
argument_list|()
end_macro

begin_block
block|{
name|short
name|sc
decl_stmt|,
name|sctop
decl_stmt|;
name|u_char
modifier|*
name|id_reg
decl_stmt|;
specifier|register
name|caddr_t
name|addr
decl_stmt|;
specifier|register
name|struct
name|hp_hw
modifier|*
name|hw
decl_stmt|;
name|hw
operator|=
name|sc_table
expr_stmt|;
name|sctop
operator|=
name|machineid
operator|==
name|HP_320
condition|?
literal|32
else|:
literal|256
expr_stmt|;
for|for
control|(
name|sc
operator|=
operator|-
literal|1
init|;
name|sc
operator|<
name|sctop
condition|;
name|sc
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|>=
literal|32
operator|&&
name|sc
operator|<
literal|132
condition|)
continue|continue;
name|addr
operator|=
operator|(
name|caddr_t
operator|)
name|sctoaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|badaddr
argument_list|(
name|addr
argument_list|)
condition|)
continue|continue;
name|id_reg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|addr
expr_stmt|;
name|hw
operator|->
name|hw_pa
operator|=
literal|0
expr_stmt|;
comment|/* XXX used to pass back LUN from driver */
if|if
condition|(
name|sc
operator|>=
literal|132
condition|)
name|hw
operator|->
name|hw_size
operator|=
operator|(
name|id_reg
index|[
literal|0x101
index|]
operator|+
literal|1
operator|)
operator|*
literal|0x100000
expr_stmt|;
else|else
name|hw
operator|->
name|hw_size
operator|=
name|DIOCSIZE
expr_stmt|;
name|hw
operator|->
name|hw_kva
operator|=
name|addr
expr_stmt|;
name|hw
operator|->
name|hw_id
operator|=
name|id_reg
index|[
literal|1
index|]
expr_stmt|;
name|hw
operator|->
name|hw_sc
operator|=
name|sc
expr_stmt|;
comment|/* 		 * Not all internal HP-IBs respond rationally to id requests 		 * so we just go by the "internal HPIB" indicator in SYSFLAG. 		 */
if|if
condition|(
name|sc
operator|==
literal|7
operator|&&
name|internalhpib
condition|)
block|{
name|hw
operator|->
name|hw_type
operator|=
name|C_HPIB
expr_stmt|;
name|hw
operator|++
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|hw
operator|->
name|hw_id
condition|)
block|{
case|case
literal|5
case|:
comment|/* 98642A */
case|case
literal|5
operator|+
literal|128
case|:
comment|/* 98642A remote */
name|hw
operator|->
name|hw_type
operator|=
name|D_COMMDCM
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* 98625B */
case|case
literal|128
case|:
comment|/* 98624A */
name|hw
operator|->
name|hw_type
operator|=
name|C_HPIB
expr_stmt|;
break|break;
case|case
literal|57
case|:
comment|/* Displays */
name|hw
operator|->
name|hw_type
operator|=
name|D_BITMAP
expr_stmt|;
name|hw
operator|->
name|hw_secid
operator|=
name|id_reg
index|[
literal|0x15
index|]
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|hw_secid
condition|)
block|{
case|case
literal|4
case|:
comment|/* renaissance */
case|case
literal|8
case|:
comment|/* davinci */
name|sc
operator|++
expr_stmt|;
comment|/* occupy 2 select codes */
break|break;
block|}
break|break;
case|case
literal|9
case|:
name|hw
operator|->
name|hw_type
operator|=
name|D_KEYBOARD
expr_stmt|;
break|break;
case|case
literal|7
case|:
case|case
literal|7
operator|+
literal|32
case|:
case|case
literal|7
operator|+
literal|64
case|:
case|case
literal|7
operator|+
literal|96
case|:
name|hw
operator|->
name|hw_type
operator|=
name|C_SCSI
expr_stmt|;
break|break;
default|default:
comment|/* who cares */
name|hw
operator|->
name|hw_type
operator|=
name|D_MISC
expr_stmt|;
break|break;
block|}
name|hw
operator|++
expr_stmt|;
block|}
block|}
end_block

end_unit

