begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and Mark Davies of the Department of Computer  * Science, Victoria University of Wellington, New Zealand.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: ite_hy.c 1.1 92/01/22$  *  *	@(#)ite_hy.c	8.1 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<hp300/stand/samachdep.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ITECONSOLE
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/itevar.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/itereg.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/grf_hyreg.h>
end_include

begin_define
define|#
directive|define
name|REGBASE
value|((struct hyboxfb *)(ip->regbase))
end_define

begin_define
define|#
directive|define
name|WINDOWMOVER
value|hyper_windowmove
end_define

begin_undef
undef|#
directive|undef
name|charX
end_undef

begin_define
define|#
directive|define
name|charX
parameter_list|(
name|ip
parameter_list|,
name|c
parameter_list|)
define|\
value|(((c) % (ip)->cpl) * ((((ip)->ftwidth + 7) / 8) * 8) + (ip)->fontx)
end_define

begin_expr_stmt
name|hyper_init
argument_list|(
name|ip
argument_list|)
specifier|register
expr|struct
name|ite_softc
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|width
decl_stmt|;
name|ite_fontinfo
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|width
operator|=
operator|(
operator|(
name|ip
operator|->
name|ftwidth
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|*
literal|8
expr_stmt|;
name|ip
operator|->
name|cpl
operator|=
operator|(
name|ip
operator|->
name|fbwidth
operator|-
name|ip
operator|->
name|dwidth
operator|)
operator|/
name|width
expr_stmt|;
name|ip
operator|->
name|cblanky
operator|=
name|ip
operator|->
name|fonty
operator|+
operator|(
operator|(
literal|128
operator|/
name|ip
operator|->
name|cpl
operator|)
operator|+
literal|1
operator|)
operator|*
name|ip
operator|->
name|ftheight
expr_stmt|;
name|REGBASE
operator|->
name|nblank
operator|=
literal|0x05
expr_stmt|;
comment|/* 	 * Clear the framebuffer on all planes. 	 */
name|hyper_windowmove
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ip
operator|->
name|fbheight
argument_list|,
name|ip
operator|->
name|fbwidth
argument_list|,
name|RR_CLEAR
argument_list|)
expr_stmt|;
name|hyper_ite_fontinit
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * Stash the inverted cursor. 	 */
name|hyper_windowmove
argument_list|(
name|ip
argument_list|,
name|charY
argument_list|(
name|ip
argument_list|,
literal|' '
argument_list|)
argument_list|,
name|charX
argument_list|(
name|ip
argument_list|,
literal|' '
argument_list|)
argument_list|,
name|ip
operator|->
name|cblanky
argument_list|,
name|ip
operator|->
name|cblankx
argument_list|,
name|ip
operator|->
name|ftheight
argument_list|,
name|ip
operator|->
name|ftwidth
argument_list|,
name|RR_COPYINVERTED
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hyper_ite_fontinit
argument_list|(
name|ip
argument_list|)
specifier|register
expr|struct
name|ite_softc
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|fbmem
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|l
decl_stmt|,
name|b
decl_stmt|;
name|int
name|stride
decl_stmt|,
name|width
decl_stmt|;
name|dp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|getword
argument_list|(
name|ip
argument_list|,
name|getword
argument_list|(
name|ip
argument_list|,
name|FONTROM
argument_list|)
operator|+
name|FONTADDR
argument_list|)
operator|+
name|ip
operator|->
name|regbase
operator|)
operator|+
name|FONTDATA
expr_stmt|;
name|stride
operator|=
name|ip
operator|->
name|fbwidth
operator|>>
literal|3
expr_stmt|;
name|width
operator|=
operator|(
name|ip
operator|->
name|ftwidth
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|128
condition|;
name|c
operator|++
control|)
block|{
name|fbmem
operator|=
operator|(
name|u_char
operator|*
operator|)
name|FBBASE
operator|+
operator|(
name|ip
operator|->
name|fonty
operator|+
operator|(
name|c
operator|/
name|ip
operator|->
name|cpl
operator|)
operator|*
name|ip
operator|->
name|ftheight
operator|)
operator|*
name|stride
expr_stmt|;
name|fbmem
operator|+=
operator|(
name|ip
operator|->
name|fontx
operator|>>
literal|3
operator|)
operator|+
operator|(
name|c
operator|%
name|ip
operator|->
name|cpl
operator|)
operator|*
name|width
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|ip
operator|->
name|ftheight
condition|;
name|l
operator|++
control|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|width
condition|;
name|b
operator|++
control|)
block|{
operator|*
name|fbmem
operator|++
operator|=
operator|*
name|dp
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
block|}
name|fbmem
operator|-=
name|width
expr_stmt|;
name|fbmem
operator|+=
name|stride
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|hyper_putc
argument_list|(
name|ip
argument_list|,
name|c
argument_list|,
name|dy
argument_list|,
name|dx
argument_list|,
name|mode
argument_list|)
specifier|register
expr|struct
name|ite_softc
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|dy
decl_stmt|,
name|dx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|c
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|hyper_windowmove
argument_list|(
name|ip
argument_list|,
name|charY
argument_list|(
name|ip
argument_list|,
name|c
argument_list|)
argument_list|,
name|charX
argument_list|(
name|ip
argument_list|,
name|c
argument_list|)
argument_list|,
name|dy
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|dx
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|ip
operator|->
name|ftheight
argument_list|,
name|ip
operator|->
name|ftwidth
argument_list|,
name|RR_COPY
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hyper_cursor
argument_list|(
name|ip
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|ite_softc
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|MOVE_CURSOR
case|:
name|erase_cursor
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* fall through ... */
case|case
name|DRAW_CURSOR
case|:
name|draw_cursor
argument_list|(
name|ip
argument_list|)
expr_stmt|;
break|break;
default|default:
name|erase_cursor
argument_list|(
name|ip
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|hyper_clear
argument_list|(
argument|ip
argument_list|,
argument|sy
argument_list|,
argument|sx
argument_list|,
argument|h
argument_list|,
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ite_softc
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|sy
decl_stmt|,
name|sx
decl_stmt|,
name|h
decl_stmt|,
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|hyper_windowmove
argument_list|(
name|ip
argument_list|,
name|sy
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|sx
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|sy
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|sx
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|h
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|w
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|RR_CLEAR
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hyper_scroll
argument_list|(
name|ip
argument_list|,
name|sy
argument_list|,
name|sx
argument_list|,
name|count
argument_list|,
name|dir
argument_list|)
specifier|register
expr|struct
name|ite_softc
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|sy
decl_stmt|,
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dir
decl_stmt|,
name|sx
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|dy
init|=
name|sy
operator|-
name|count
decl_stmt|;
specifier|register
name|int
name|height
init|=
name|ip
operator|->
name|rows
operator|-
name|sy
decl_stmt|;
name|hyper_cursor
argument_list|(
name|ip
argument_list|,
name|ERASE_CURSOR
argument_list|)
expr_stmt|;
name|hyper_windowmove
argument_list|(
name|ip
argument_list|,
name|sy
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|sx
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|dy
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|sx
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|height
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|ip
operator|->
name|cols
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|RR_COPY
argument_list|)
expr_stmt|;
block|}
end_block

begin_include
include|#
directive|include
file|<hp300/dev/maskbits.h>
end_include

begin_comment
comment|/* NOTE:  * the first element in starttab could be 0xffffffff.  making it 0  * lets us deal with a full first word in the middle loop, rather  * than having to do the multiple reads and masks that we'd  * have to do if we thought it was partial.  */
end_comment

begin_decl_stmt
name|int
name|starttab
index|[
literal|32
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x7FFFFFFF
block|,
literal|0x3FFFFFFF
block|,
literal|0x1FFFFFFF
block|,
literal|0x0FFFFFFF
block|,
literal|0x07FFFFFF
block|,
literal|0x03FFFFFF
block|,
literal|0x01FFFFFF
block|,
literal|0x00FFFFFF
block|,
literal|0x007FFFFF
block|,
literal|0x003FFFFF
block|,
literal|0x001FFFFF
block|,
literal|0x000FFFFF
block|,
literal|0x0007FFFF
block|,
literal|0x0003FFFF
block|,
literal|0x0001FFFF
block|,
literal|0x0000FFFF
block|,
literal|0x00007FFF
block|,
literal|0x00003FFF
block|,
literal|0x00001FFF
block|,
literal|0x00000FFF
block|,
literal|0x000007FF
block|,
literal|0x000003FF
block|,
literal|0x000001FF
block|,
literal|0x000000FF
block|,
literal|0x0000007F
block|,
literal|0x0000003F
block|,
literal|0x0000001F
block|,
literal|0x0000000F
block|,
literal|0x00000007
block|,
literal|0x00000003
block|,
literal|0x00000001
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|endtab
index|[
literal|32
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x80000000
block|,
literal|0xC0000000
block|,
literal|0xE0000000
block|,
literal|0xF0000000
block|,
literal|0xF8000000
block|,
literal|0xFC000000
block|,
literal|0xFE000000
block|,
literal|0xFF000000
block|,
literal|0xFF800000
block|,
literal|0xFFC00000
block|,
literal|0xFFE00000
block|,
literal|0xFFF00000
block|,
literal|0xFFF80000
block|,
literal|0xFFFC0000
block|,
literal|0xFFFE0000
block|,
literal|0xFFFF0000
block|,
literal|0xFFFF8000
block|,
literal|0xFFFFC000
block|,
literal|0xFFFFE000
block|,
literal|0xFFFFF000
block|,
literal|0xFFFFF800
block|,
literal|0xFFFFFC00
block|,
literal|0xFFFFFE00
block|,
literal|0xFFFFFF00
block|,
literal|0xFFFFFF80
block|,
literal|0xFFFFFFC0
block|,
literal|0xFFFFFFE0
block|,
literal|0xFFFFFFF0
block|,
literal|0xFFFFFFF8
block|,
literal|0xFFFFFFFC
block|,
literal|0xFFFFFFFE
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|hyper_windowmove
argument_list|(
argument|ip
argument_list|,
argument|sy
argument_list|,
argument|sx
argument_list|,
argument|dy
argument_list|,
argument|dx
argument_list|,
argument|h
argument_list|,
argument|w
argument_list|,
argument|func
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ite_softc
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sy
decl_stmt|,
name|sx
decl_stmt|,
name|dy
decl_stmt|,
name|dx
decl_stmt|,
name|h
decl_stmt|,
name|w
decl_stmt|,
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
modifier|*
name|psrcBase
decl_stmt|,
modifier|*
name|pdstBase
decl_stmt|;
comment|/* start of src and dst bitmaps */
name|int
name|width
decl_stmt|;
comment|/* add to get to same position in next line */
name|unsigned
name|int
modifier|*
name|psrcLine
decl_stmt|,
modifier|*
name|pdstLine
decl_stmt|;
comment|/* pointers to line with current src and dst */
specifier|register
name|unsigned
name|int
modifier|*
name|psrc
decl_stmt|;
comment|/* pointer to current src longword */
specifier|register
name|unsigned
name|int
modifier|*
name|pdst
decl_stmt|;
comment|/* pointer to current dst longword */
comment|/* following used for looping through a line */
name|unsigned
name|int
name|startmask
decl_stmt|,
name|endmask
decl_stmt|;
comment|/* masks for writing ends of dst */
name|int
name|nlMiddle
decl_stmt|;
comment|/* whole longwords in dst */
specifier|register
name|int
name|nl
decl_stmt|;
comment|/* temp copy of nlMiddle */
specifier|register
name|unsigned
name|int
name|tmpSrc
decl_stmt|;
comment|/* place to store full source word */
specifier|register
name|int
name|xoffSrc
decl_stmt|;
comment|/* offset (>= 0,< 32) from which to                                    fetch whole longwords fetched                                    in src */
name|int
name|nstart
decl_stmt|;
comment|/* number of ragged bits at start of dst */
name|int
name|nend
decl_stmt|;
comment|/* number of ragged bits at end of dst */
name|int
name|srcStartOver
decl_stmt|;
comment|/* pulling nstart bits from src                                    overflows into the next word? */
if|if
condition|(
name|h
operator|==
literal|0
operator|||
name|w
operator|==
literal|0
condition|)
return|return;
name|width
operator|=
name|ip
operator|->
name|fbwidth
operator|>>
literal|5
expr_stmt|;
name|psrcLine
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ip
operator|->
name|fbbase
operator|)
operator|+
operator|(
name|sy
operator|*
name|width
operator|)
expr_stmt|;
name|pdstLine
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ip
operator|->
name|fbbase
operator|)
operator|+
operator|(
name|dy
operator|*
name|width
operator|)
expr_stmt|;
comment|/* x direction doesn't matter for< 1 longword */
if|if
condition|(
name|w
operator|<=
literal|32
condition|)
block|{
name|int
name|srcBit
decl_stmt|,
name|dstBit
decl_stmt|;
comment|/* bit offset of src and dst */
name|pdstLine
operator|+=
operator|(
name|dx
operator|>>
literal|5
operator|)
expr_stmt|;
name|psrcLine
operator|+=
operator|(
name|sx
operator|>>
literal|5
operator|)
expr_stmt|;
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
name|srcBit
operator|=
name|sx
operator|&
literal|0x1f
expr_stmt|;
name|dstBit
operator|=
name|dx
operator|&
literal|0x1f
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|getandputrop
argument_list|(
argument|psrc
argument_list|,
argument|srcBit
argument_list|,
argument|dstBit
argument_list|,
argument|w
argument_list|,
argument|pdst
argument_list|,
argument|func
argument_list|)
name|pdst
operator|+=
name|width
expr_stmt|;
name|psrc
operator|+=
name|width
expr_stmt|;
block|}
block|}
else|else
block|{
name|maskbits
argument_list|(
argument|dx
argument_list|,
argument|w
argument_list|,
argument|startmask
argument_list|,
argument|endmask
argument_list|,
argument|nlMiddle
argument_list|)
if|if
condition|(
name|startmask
condition|)
name|nstart
operator|=
literal|32
operator|-
operator|(
name|dx
operator|&
literal|0x1f
operator|)
expr_stmt|;
else|else
name|nstart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|endmask
condition|)
name|nend
operator|=
operator|(
name|dx
operator|+
name|w
operator|)
operator|&
literal|0x1f
expr_stmt|;
else|else
name|nend
operator|=
literal|0
expr_stmt|;
name|xoffSrc
operator|=
operator|(
operator|(
name|sx
operator|&
literal|0x1f
operator|)
operator|+
name|nstart
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|srcStartOver
operator|=
operator|(
operator|(
name|sx
operator|&
literal|0x1f
operator|)
operator|+
name|nstart
operator|)
operator|>
literal|31
expr_stmt|;
name|pdstLine
operator|+=
operator|(
name|dx
operator|>>
literal|5
operator|)
expr_stmt|;
name|psrcLine
operator|+=
operator|(
name|sx
operator|>>
literal|5
operator|)
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
if|if
condition|(
name|startmask
condition|)
block|{
name|getandputrop
argument_list|(
argument|psrc
argument_list|,
argument|(sx&
literal|0x1f
argument|)
argument_list|,
argument|(dx&
literal|0x1f
argument|)
argument_list|,
argument|nstart
argument_list|,
argument|pdst
argument_list|,
argument|func
argument_list|)
name|pdst
operator|++
expr_stmt|;
if|if
condition|(
name|srcStartOver
condition|)
name|psrc
operator|++
expr_stmt|;
block|}
comment|/* special case for aligned operations */
if|if
condition|(
name|xoffSrc
operator|==
literal|0
condition|)
block|{
name|nl
operator|=
name|nlMiddle
expr_stmt|;
while|while
condition|(
name|nl
operator|--
condition|)
block|{
name|DoRop
argument_list|(
operator|*
name|pdst
argument_list|,
name|func
argument_list|,
operator|*
name|psrc
operator|++
argument_list|,
operator|*
name|pdst
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|nl
operator|=
name|nlMiddle
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|--
name|nl
condition|)
block|{
name|getunalignedword
argument_list|(
argument|psrc
argument_list|,
argument|xoffSrc
argument_list|,
argument|tmpSrc
argument_list|)
name|DoRop
argument_list|(
operator|*
name|pdst
argument_list|,
name|func
argument_list|,
name|tmpSrc
argument_list|,
operator|*
name|pdst
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
name|psrc
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|endmask
condition|)
block|{
name|getandputrop0
argument_list|(
name|psrc
argument_list|,
name|xoffSrc
argument_list|,
name|nend
argument_list|,
name|pdst
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
name|pdstLine
operator|+=
name|width
expr_stmt|;
name|psrcLine
operator|+=
name|width
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

