begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1990 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)ppi.c	8.1 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Printer/Plotter HPIB interface  */
end_comment

begin_include
include|#
directive|include
file|"ppi.h"
end_include

begin_if
if|#
directive|if
name|NPPI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/ppiioctl.h>
end_include

begin_decl_stmt
name|int
name|ppiattach
argument_list|()
decl_stmt|,
name|ppistart
argument_list|()
decl_stmt|,
name|ppitimo
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|driver
name|ppidriver
init|=
block|{
name|ppiattach
block|,
literal|"ppi"
block|,
name|ppistart
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ppi_softc
block|{
name|int
name|sc_flags
decl_stmt|;
name|struct
name|devqueue
name|sc_dq
decl_stmt|;
name|struct
name|hp_device
modifier|*
name|sc_hd
decl_stmt|;
name|struct
name|ppiparam
name|sc_param
decl_stmt|;
define|#
directive|define
name|sc_burst
value|sc_param.burst
define|#
directive|define
name|sc_timo
value|sc_param.timo
define|#
directive|define
name|sc_delay
value|sc_param.delay
name|int
name|sc_sec
decl_stmt|;
block|}
name|ppi_softc
index|[
name|NPPI
index|]
struct|;
end_struct

begin_comment
comment|/* sc_flags values */
end_comment

begin_define
define|#
directive|define
name|PPIF_ALIVE
value|0x01
end_define

begin_define
define|#
directive|define
name|PPIF_OPEN
value|0x02
end_define

begin_define
define|#
directive|define
name|PPIF_UIO
value|0x04
end_define

begin_define
define|#
directive|define
name|PPIF_TIMO
value|0x08
end_define

begin_define
define|#
directive|define
name|PPIF_DELAY
value|0x10
end_define

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|minor(x)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|ppidebug
init|=
literal|0x80
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PDB_FOLLOW
value|0x01
end_define

begin_define
define|#
directive|define
name|PDB_IO
value|0x02
end_define

begin_define
define|#
directive|define
name|PDB_NOCHECK
value|0x80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|ppiattach
argument_list|(
name|hd
argument_list|)
specifier|register
expr|struct
name|hp_device
operator|*
name|hd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|ppi_softc
modifier|*
name|sc
init|=
operator|&
name|ppi_softc
index|[
name|hd
operator|->
name|hp_unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|ppidebug
operator|&
name|PDB_NOCHECK
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
comment|/* 	 * XXX: the printer/plotter doesn't seem to really return 	 * an ID but this will at least prevent us from mistaking 	 * a cs80 disk or tape for a ppi device. 	 */
if|if
condition|(
name|hpibid
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|)
operator|&
literal|0x200
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_flags
operator|=
name|PPIF_ALIVE
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_ctlr
operator|=
name|hd
operator|->
name|hp_ctlr
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_unit
operator|=
name|hd
operator|->
name|hp_unit
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_slave
operator|=
name|hd
operator|->
name|hp_slave
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_driver
operator|=
operator|&
name|ppidriver
expr_stmt|;
name|sc
operator|->
name|sc_hd
operator|=
name|hd
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|ppiopen
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|ppi_softc
modifier|*
name|sc
init|=
operator|&
name|ppi_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NPPI
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|PPIF_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppidebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"ppiopen(%x, %x): flags %x\n"
argument_list|,
name|dev
argument_list|,
name|flags
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|PPIF_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|->
name|sc_flags
operator||=
name|PPIF_OPEN
expr_stmt|;
name|sc
operator|->
name|sc_burst
operator|=
name|PPI_BURST
expr_stmt|;
name|sc
operator|->
name|sc_timo
operator|=
name|ppimstohz
argument_list|(
name|PPI_TIMO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_delay
operator|=
name|ppimstohz
argument_list|(
name|PPI_DELAY
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sec
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|ppiclose
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|ppi_softc
modifier|*
name|sc
init|=
operator|&
name|ppi_softc
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppidebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"ppiclose(%x, %x): flags %x\n"
argument_list|,
name|dev
argument_list|,
name|flags
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|PPIF_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|ppistart
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppidebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"ppistart(%x)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ppi_softc
index|[
name|unit
index|]
operator|.
name|sc_flags
operator|&=
operator|~
name|PPIF_DELAY
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|ppi_softc
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ppitimo
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppidebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"ppitimo(%x)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ppi_softc
index|[
name|unit
index|]
operator|.
name|sc_flags
operator|&=
operator|~
operator|(
name|PPIF_UIO
operator||
name|PPIF_TIMO
operator|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|ppi_softc
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ppiread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppidebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"ppiread(%x, %x)\n"
argument_list|,
name|dev
argument_list|,
name|uio
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ppirw
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|ppiwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppidebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"ppiwrite(%x, %x)\n"
argument_list|,
name|dev
argument_list|,
name|uio
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ppirw
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|ppirw
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|ppi_softc
modifier|*
name|sc
init|=
operator|&
name|ppi_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|cnt
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|gotdata
init|=
literal|0
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppidebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_IO
operator|)
condition|)
name|printf
argument_list|(
literal|"ppirw(%x, %x, %c): burst %d, timo %d, resid %x\n"
argument_list|,
name|dev
argument_list|,
name|uio
argument_list|,
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_READ
condition|?
literal|'R'
else|:
literal|'W'
argument_list|,
name|sc
operator|->
name|sc_burst
argument_list|,
name|sc
operator|->
name|sc_timo
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buflen
operator|=
name|min
argument_list|(
name|sc
operator|->
name|sc_burst
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|PPIF_UIO
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_timo
operator|>
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|PPIF_TIMO
expr_stmt|;
name|timeout
argument_list|(
name|ppitimo
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_timo
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|min
argument_list|(
name|buflen
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_WRITE
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|cp
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|again
label|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|PPIF_UIO
operator|)
operator|&&
name|hpibreq
argument_list|(
operator|&
name|sc
operator|->
name|sc_dq
argument_list|)
operator|==
literal|0
condition|)
name|sleep
argument_list|(
name|sc
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Check if we timed out during sleep or uiomove 		 */
operator|(
name|void
operator|)
name|splsoftclock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|PPIF_UIO
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppidebug
operator|&
name|PDB_IO
condition|)
name|printf
argument_list|(
literal|"ppirw: uiomove/sleep timo, flags %x\n"
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|PPIF_TIMO
condition|)
block|{
name|untimeout
argument_list|(
name|ppitimo
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|PPIF_TIMO
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * Perform the operation 		 */
if|if
condition|(
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_WRITE
condition|)
name|cnt
operator|=
name|hpibsend
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|sc
operator|->
name|sc_sec
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|cnt
operator|=
name|hpibrecv
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|sc
operator|->
name|sc_sec
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|hpibfree
argument_list|(
operator|&
name|sc
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppidebug
operator|&
name|PDB_IO
condition|)
name|printf
argument_list|(
literal|"ppirw: %s(%d, %d, %x, %x, %d) -> %d\n"
argument_list|,
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_READ
condition|?
literal|"recv"
else|:
literal|"send"
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|sc
operator|->
name|sc_sec
argument_list|,
name|cp
argument_list|,
name|len
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_READ
condition|)
block|{
if|if
condition|(
name|cnt
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|cp
argument_list|,
name|cnt
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|gotdata
operator|++
expr_stmt|;
block|}
comment|/* 			 * Didn't get anything this time, but did in the past. 			 * Consider us done. 			 */
elseif|else
if|if
condition|(
name|gotdata
condition|)
break|break;
block|}
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
comment|/* 		 * Operation timeout (or non-blocking), quit now. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|PPIF_UIO
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppidebug
operator|&
name|PDB_IO
condition|)
name|printf
argument_list|(
literal|"ppirw: timeout/done\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Implement inter-read delay 		 */
if|if
condition|(
name|sc
operator|->
name|sc_delay
operator|>
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|PPIF_DELAY
expr_stmt|;
name|timeout
argument_list|(
name|ppistart
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_delay
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PCATCH
operator||
name|PZERO
operator|+
literal|1
argument_list|,
literal|"hpib"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * Must not call uiomove again til we've used all data 		 * that we already grabbed. 		 */
if|if
condition|(
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_WRITE
operator|&&
name|cnt
operator|!=
name|len
condition|)
block|{
name|cp
operator|+=
name|cnt
expr_stmt|;
name|len
operator|-=
name|cnt
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|PPIF_TIMO
condition|)
block|{
name|untimeout
argument_list|(
name|ppitimo
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|PPIF_TIMO
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|PPIF_DELAY
condition|)
block|{
name|untimeout
argument_list|(
name|ppistart
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|PPIF_DELAY
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Adjust for those chars that we uiomove'ed but never wrote 	 */
if|if
condition|(
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_WRITE
operator|&&
name|cnt
operator|!=
name|len
condition|)
block|{
name|uio
operator|->
name|uio_resid
operator|+=
operator|(
name|len
operator|-
name|cnt
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppidebug
operator|&
name|PDB_IO
condition|)
name|printf
argument_list|(
literal|"ppirw: short write, adjust by %d\n"
argument_list|,
name|len
operator|-
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ppidebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_IO
operator|)
condition|)
name|printf
argument_list|(
literal|"ppirw: return %d, resid %d\n"
argument_list|,
name|error
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|ppiioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ppi_softc
modifier|*
name|sc
init|=
operator|&
name|ppi_softc
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|struct
name|ppiparam
modifier|*
name|pp
decl_stmt|,
modifier|*
name|upp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PPIIOCGPARAM
case|:
name|pp
operator|=
operator|&
name|sc
operator|->
name|sc_param
expr_stmt|;
name|upp
operator|=
operator|(
expr|struct
name|ppiparam
operator|*
operator|)
name|data
expr_stmt|;
name|upp
operator|->
name|burst
operator|=
name|pp
operator|->
name|burst
expr_stmt|;
name|upp
operator|->
name|timo
operator|=
name|ppihztoms
argument_list|(
name|pp
operator|->
name|timo
argument_list|)
expr_stmt|;
name|upp
operator|->
name|delay
operator|=
name|ppihztoms
argument_list|(
name|pp
operator|->
name|delay
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPIIOCSPARAM
case|:
name|pp
operator|=
operator|&
name|sc
operator|->
name|sc_param
expr_stmt|;
name|upp
operator|=
operator|(
expr|struct
name|ppiparam
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|upp
operator|->
name|burst
operator|<
name|PPI_BURST_MIN
operator|||
name|upp
operator|->
name|burst
operator|>
name|PPI_BURST_MAX
operator|||
name|upp
operator|->
name|delay
operator|<
name|PPI_DELAY_MIN
operator|||
name|upp
operator|->
name|delay
operator|>
name|PPI_DELAY_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pp
operator|->
name|burst
operator|=
name|upp
operator|->
name|burst
expr_stmt|;
name|pp
operator|->
name|timo
operator|=
name|ppimstohz
argument_list|(
name|upp
operator|->
name|timo
argument_list|)
expr_stmt|;
name|pp
operator|->
name|delay
operator|=
name|ppimstohz
argument_list|(
name|upp
operator|->
name|delay
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPIIOCSSEC
case|:
name|sc
operator|->
name|sc_sec
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|ppihztoms
argument_list|(
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|int
name|h
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|hz
decl_stmt|;
specifier|register
name|int
name|m
init|=
name|h
decl_stmt|;
if|if
condition|(
name|m
operator|>
literal|0
condition|)
name|m
operator|=
name|m
operator|*
literal|1000
operator|/
name|hz
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_block

begin_macro
name|ppimstohz
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|int
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|hz
decl_stmt|;
specifier|register
name|int
name|h
init|=
name|m
decl_stmt|;
if|if
condition|(
name|h
operator|>
literal|0
condition|)
block|{
name|h
operator|=
name|h
operator|*
name|hz
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
name|h
operator|=
literal|1000
operator|/
name|hz
expr_stmt|;
block|}
return|return
operator|(
name|h
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

