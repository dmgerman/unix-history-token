begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Van Jacobson of Lawrence Berkeley Laboratory.  *  * %sccs.include.redist.c%  *  *	@(#)scsi.c	7.9 (Berkeley) %G%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * HP9000/3xx 98658 SCSI host adaptor driver.  */
end_comment

begin_include
include|#
directive|include
file|"scsi.h"
end_include

begin_if
if|#
directive|if
name|NSCSI
operator|>
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/src/sys/hp300/dev/RCS/scsi.c,v 1.2 92/04/10 20:48:29 mike Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/scsivar.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/scsireg.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/dmavar.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<hp300/hp300/isr.h>
end_include

begin_comment
comment|/*  * SCSI delays  * In u-seconds, primarily for state changes on the SPC.  */
end_comment

begin_define
define|#
directive|define
name|SCSI_CMD_WAIT
value|1000
end_define

begin_comment
comment|/* wait per step of 'immediate' cmds */
end_comment

begin_define
define|#
directive|define
name|SCSI_DATA_WAIT
value|1000
end_define

begin_comment
comment|/* wait per data in/out step */
end_comment

begin_define
define|#
directive|define
name|SCSI_INIT_WAIT
value|50000
end_define

begin_comment
comment|/* wait per step (both) during init */
end_comment

begin_function_decl
specifier|extern
name|void
name|isrlink
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_insque
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_remque
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|scsiinit
argument_list|()
decl_stmt|,
name|scsigo
argument_list|()
decl_stmt|,
name|scsiintr
argument_list|()
decl_stmt|,
name|scsixfer
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|scsistart
argument_list|()
decl_stmt|,
name|scsidone
argument_list|()
decl_stmt|,
name|scsifree
argument_list|()
decl_stmt|,
name|scsireset
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|driver
name|scsidriver
init|=
block|{
name|scsiinit
block|,
literal|"scsi"
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|scsistart
block|,
name|scsigo
block|,
name|scsiintr
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|scsidone
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scsi_softc
name|scsi_softc
index|[
name|NSCSI
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isr
name|scsi_isr
index|[
name|NSCSI
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scsi_cmd_wait
init|=
name|SCSI_CMD_WAIT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scsi_data_wait
init|=
name|SCSI_DATA_WAIT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scsi_init_wait
init|=
name|SCSI_INIT_WAIT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scsi_nosync
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inhibit sync xfers if 1 */
end_comment

begin_decl_stmt
name|int
name|scsi_pridma
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use "priority" dma */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|scsi_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WAITHIST
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WAITHIST
end_ifdef

begin_define
define|#
directive|define
name|MAXWAIT
value|1022
end_define

begin_decl_stmt
name|u_int
name|ixstart_wait
index|[
name|MAXWAIT
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|ixin_wait
index|[
name|MAXWAIT
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|ixout_wait
index|[
name|MAXWAIT
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|mxin_wait
index|[
name|MAXWAIT
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|mxin2_wait
index|[
name|MAXWAIT
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|cxin_wait
index|[
name|MAXWAIT
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|fxfr_wait
index|[
name|MAXWAIT
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|sgo_wait
index|[
name|MAXWAIT
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HIST
parameter_list|(
name|h
parameter_list|,
name|w
parameter_list|)
value|(++h[((w)>MAXWAIT? MAXWAIT : ((w)< 0 ? -1 : (w))) + 1]);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HIST
parameter_list|(
name|h
parameter_list|,
name|w
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_function
specifier|static
name|void
name|scsiabort
parameter_list|(
name|hs
parameter_list|,
name|hd
parameter_list|,
name|where
parameter_list|)
specifier|register
name|struct
name|scsi_softc
modifier|*
name|hs
decl_stmt|;
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|int
name|maxtries
decl_stmt|;
comment|/* XXX - kludge till I understand whats *supposed* to happen */
name|int
name|startlen
decl_stmt|;
comment|/* XXX - kludge till I understand whats *supposed* to happen */
name|u_char
name|junk
decl_stmt|;
name|printf
argument_list|(
literal|"scsi%d: abort from %s: phase=0x%x, ssts=0x%x, ints=0x%x\n"
argument_list|,
name|hs
operator|->
name|sc_hc
operator|->
name|hp_unit
argument_list|,
name|where
argument_list|,
name|hd
operator|->
name|scsi_psns
argument_list|,
name|hd
operator|->
name|scsi_ssts
argument_list|,
name|hd
operator|->
name|scsi_ints
argument_list|)
expr_stmt|;
name|hd
operator|->
name|scsi_ints
operator|=
name|hd
operator|->
name|scsi_ints
expr_stmt|;
name|hd
operator|->
name|scsi_csr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|scsi_psns
operator|==
literal|0
operator|||
operator|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_INITIATOR
operator|)
operator|==
literal|0
condition|)
comment|/* no longer connected to scsi target */
return|return;
comment|/* get the number of bytes remaining in current xfer + fudge */
name|len
operator|=
operator|(
name|hd
operator|->
name|scsi_tch
operator|<<
literal|16
operator|)
operator||
operator|(
name|hd
operator|->
name|scsi_tcm
operator|<<
literal|8
operator|)
operator||
name|hd
operator|->
name|scsi_tcl
expr_stmt|;
comment|/* for that many bus cycles, try to send an abort msg */
for|for
control|(
name|startlen
operator|=
operator|(
name|len
operator|+=
literal|1024
operator|)
init|;
operator|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_INITIATOR
operator|)
operator|&&
operator|--
name|len
operator|>=
literal|0
condition|;
control|)
block|{
name|hd
operator|->
name|scsi_scmd
operator|=
name|SCMD_SET_ATN
expr_stmt|;
name|maxtries
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
operator|(
name|hd
operator|->
name|scsi_psns
operator|&
name|PSNS_REQ
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_INITIATOR
operator|)
condition|)
goto|goto
name|out
goto|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|maxtries
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"-- scsiabort gave up after 1000 tries (startlen = %d len = %d)\n"
argument_list|,
name|startlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
block|}
name|out2
label|:
if|if
condition|(
operator|(
name|hd
operator|->
name|scsi_psns
operator|&
name|PHASE
operator|)
operator|==
name|MESG_OUT_PHASE
condition|)
name|hd
operator|->
name|scsi_scmd
operator|=
name|SCMD_RST_ATN
expr_stmt|;
name|hd
operator|->
name|scsi_pctl
operator|=
name|hd
operator|->
name|scsi_psns
operator|&
name|PHASE
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|scsi_psns
operator|&
name|PHASE_IO
condition|)
block|{
comment|/* one of the input phases - read& discard a byte */
name|hd
operator|->
name|scsi_scmd
operator|=
name|SCMD_SET_ACK
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|scsi_tmod
operator|==
literal|0
condition|)
while|while
condition|(
name|hd
operator|->
name|scsi_psns
operator|&
name|PSNS_REQ
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|junk
operator|=
name|hd
operator|->
name|scsi_temp
expr_stmt|;
block|}
else|else
block|{
comment|/* one of the output phases - send an abort msg */
name|hd
operator|->
name|scsi_temp
operator|=
name|MSG_ABORT
expr_stmt|;
name|hd
operator|->
name|scsi_scmd
operator|=
name|SCMD_SET_ACK
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|scsi_tmod
operator|==
literal|0
condition|)
while|while
condition|(
name|hd
operator|->
name|scsi_psns
operator|&
name|PSNS_REQ
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hd
operator|->
name|scsi_scmd
operator|=
name|SCMD_RST_ACK
expr_stmt|;
block|}
name|out
label|:
comment|/* 	 * Either the abort was successful& the bus is disconnected or 	 * the device didn't listen.  If the latter, announce the problem. 	 * Either way, reset the card& the SPC. 	 */
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
name|hs
condition|)
name|printf
argument_list|(
literal|"scsi%d: abort failed.  phase=0x%x, ssts=0x%x\n"
argument_list|,
name|hs
operator|->
name|sc_hc
operator|->
name|hp_unit
argument_list|,
name|hd
operator|->
name|scsi_psns
argument_list|,
name|hd
operator|->
name|scsi_ssts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|junk
operator|=
name|hd
operator|->
name|scsi_ints
operator|)
operator|&
name|INTS_RESEL
operator|)
condition|)
block|{
name|hd
operator|->
name|scsi_sctl
operator||=
name|SCTL_CTRLRST
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hd
operator|->
name|scsi_sctl
operator|&=
operator|~
name|SCTL_CTRLRST
expr_stmt|;
name|hd
operator|->
name|scsi_hconf
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|scsi_ints
operator|=
name|hd
operator|->
name|scsi_ints
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * XXX Set/reset long delays.  *  * if delay == 0, reset default delays  * if delay< 0,  set both delays to default long initialization values  * if delay> 0,  set both delays to this value  *  * Used when a devices is expected to respond slowly (e.g. during  * initialization).  */
end_comment

begin_function
name|void
name|scsi_delay
parameter_list|(
name|delay
parameter_list|)
name|int
name|delay
decl_stmt|;
block|{
specifier|static
name|int
name|saved_cmd_wait
decl_stmt|,
name|saved_data_wait
decl_stmt|;
if|if
condition|(
name|delay
condition|)
block|{
name|saved_cmd_wait
operator|=
name|scsi_cmd_wait
expr_stmt|;
name|saved_data_wait
operator|=
name|scsi_data_wait
expr_stmt|;
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
name|scsi_cmd_wait
operator|=
name|scsi_data_wait
operator|=
name|delay
expr_stmt|;
else|else
name|scsi_cmd_wait
operator|=
name|scsi_data_wait
operator|=
name|scsi_init_wait
expr_stmt|;
block|}
else|else
block|{
name|scsi_cmd_wait
operator|=
name|saved_cmd_wait
expr_stmt|;
name|scsi_data_wait
operator|=
name|saved_data_wait
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|scsiinit
parameter_list|(
name|hc
parameter_list|)
specifier|register
name|struct
name|hp_ctlr
modifier|*
name|hc
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_softc
modifier|*
name|hs
init|=
operator|&
name|scsi_softc
index|[
name|hc
operator|->
name|hp_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
init|=
operator|(
expr|struct
name|scsidevice
operator|*
operator|)
name|hc
operator|->
name|hp_addr
decl_stmt|;
if|if
condition|(
operator|(
name|hd
operator|->
name|scsi_id
operator|&
name|ID_MASK
operator|)
operator|!=
name|SCSI_ID
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|hc
operator|->
name|hp_ipl
operator|=
name|SCSI_IPL
argument_list|(
name|hd
operator|->
name|scsi_csr
argument_list|)
expr_stmt|;
name|hs
operator|->
name|sc_hc
operator|=
name|hc
expr_stmt|;
name|hs
operator|->
name|sc_dq
operator|.
name|dq_unit
operator|=
name|hc
operator|->
name|hp_unit
expr_stmt|;
name|hs
operator|->
name|sc_dq
operator|.
name|dq_driver
operator|=
operator|&
name|scsidriver
expr_stmt|;
name|hs
operator|->
name|sc_sq
operator|.
name|dq_forw
operator|=
name|hs
operator|->
name|sc_sq
operator|.
name|dq_back
operator|=
operator|&
name|hs
operator|->
name|sc_sq
expr_stmt|;
name|scsi_isr
index|[
name|hc
operator|->
name|hp_unit
index|]
operator|.
name|isr_intr
operator|=
name|scsiintr
expr_stmt|;
name|scsi_isr
index|[
name|hc
operator|->
name|hp_unit
index|]
operator|.
name|isr_ipl
operator|=
name|hc
operator|->
name|hp_ipl
expr_stmt|;
name|scsi_isr
index|[
name|hc
operator|->
name|hp_unit
index|]
operator|.
name|isr_arg
operator|=
name|hc
operator|->
name|hp_unit
expr_stmt|;
name|isrlink
argument_list|(
operator|&
name|scsi_isr
index|[
name|hc
operator|->
name|hp_unit
index|]
argument_list|)
expr_stmt|;
name|scsireset
argument_list|(
name|hc
operator|->
name|hp_unit
argument_list|)
expr_stmt|;
comment|/* 	 * XXX scale initialization wait according to CPU speed. 	 * Should we do this for all wait?  Should we do this at all? 	 */
name|scsi_init_wait
operator|*=
name|cpuspeed
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scsireset
parameter_list|(
name|unit
parameter_list|)
specifier|register
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_softc
modifier|*
name|hs
init|=
operator|&
name|scsi_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
init|=
operator|(
expr|struct
name|scsidevice
operator|*
operator|)
name|hs
operator|->
name|sc_hc
operator|->
name|hp_addr
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|hs
operator|->
name|sc_flags
operator|&
name|SCSI_ALIVE
condition|)
name|scsiabort
argument_list|(
name|hs
argument_list|,
name|hd
argument_list|,
literal|"reset"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"scsi%d: "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|hd
operator|->
name|scsi_id
operator|=
literal|0xFF
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 	 * Disable interrupts then reset the FUJI chip. 	 */
name|hd
operator|->
name|scsi_csr
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|scsi_sctl
operator|=
name|SCTL_DISABLE
operator||
name|SCTL_CTRLRST
expr_stmt|;
name|hd
operator|->
name|scsi_scmd
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|scsi_tmod
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|scsi_pctl
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|scsi_temp
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|scsi_tch
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|scsi_tcm
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|scsi_tcl
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|scsi_ints
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|hd
operator|->
name|scsi_id
operator|&
name|ID_WORD_DMA
operator|)
operator|==
literal|0
condition|)
block|{
name|hs
operator|->
name|sc_flags
operator||=
name|SCSI_DMA32
expr_stmt|;
name|printf
argument_list|(
literal|"32 bit dma, "
argument_list|)
expr_stmt|;
block|}
comment|/* Determine Max Synchronous Transfer Rate */
if|if
condition|(
name|scsi_nosync
condition|)
name|i
operator|=
literal|3
expr_stmt|;
else|else
name|i
operator|=
name|SCSI_SYNC_XFER
argument_list|(
name|hd
operator|->
name|scsi_hconf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|hs
operator|->
name|sc_sync
operator|=
name|TMOD_SYNC
operator||
literal|0x3e
expr_stmt|;
comment|/* 250 nsecs */
name|printf
argument_list|(
literal|"250ns sync"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|hs
operator|->
name|sc_sync
operator|=
name|TMOD_SYNC
operator||
literal|0x5e
expr_stmt|;
comment|/* 375 nsecs */
name|printf
argument_list|(
literal|"375ns sync"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|hs
operator|->
name|sc_sync
operator|=
name|TMOD_SYNC
operator||
literal|0x7d
expr_stmt|;
comment|/* 500 nsecs */
name|printf
argument_list|(
literal|"500ns sync"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|hs
operator|->
name|sc_sync
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"async"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Configure the FUJI chip with its SCSI address, all 	 * interrupts enabled& appropriate parity. 	 */
name|i
operator|=
operator|(
operator|~
name|hd
operator|->
name|scsi_hconf
operator|)
operator|&
literal|0x7
expr_stmt|;
name|hs
operator|->
name|sc_scsi_addr
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
name|hd
operator|->
name|scsi_bdid
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|scsi_hconf
operator|&
name|HCONF_PARITY
condition|)
name|hd
operator|->
name|scsi_sctl
operator|=
name|SCTL_DISABLE
operator||
name|SCTL_ABRT_ENAB
operator||
name|SCTL_SEL_ENAB
operator||
name|SCTL_RESEL_ENAB
operator||
name|SCTL_INTR_ENAB
operator||
name|SCTL_PARITY_ENAB
expr_stmt|;
else|else
block|{
name|hd
operator|->
name|scsi_sctl
operator|=
name|SCTL_DISABLE
operator||
name|SCTL_ABRT_ENAB
operator||
name|SCTL_SEL_ENAB
operator||
name|SCTL_RESEL_ENAB
operator||
name|SCTL_INTR_ENAB
expr_stmt|;
name|printf
argument_list|(
literal|", no parity"
argument_list|)
expr_stmt|;
block|}
name|hd
operator|->
name|scsi_sctl
operator|&=
operator|~
name|SCTL_DISABLE
expr_stmt|;
name|printf
argument_list|(
literal|", scsi id %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|hs
operator|->
name|sc_flags
operator||=
name|SCSI_ALIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scsierror
parameter_list|(
name|hs
parameter_list|,
name|hd
parameter_list|,
name|ints
parameter_list|)
specifier|register
name|struct
name|scsi_softc
modifier|*
name|hs
decl_stmt|;
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
decl_stmt|;
name|u_char
name|ints
decl_stmt|;
block|{
name|int
name|unit
init|=
name|hs
operator|->
name|sc_hc
operator|->
name|hp_unit
decl_stmt|;
name|char
modifier|*
name|sep
init|=
literal|""
decl_stmt|;
name|printf
argument_list|(
literal|"scsi%d: "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|INTS_RST
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|hd
operator|->
name|scsi_hconf
operator|&
name|HCONF_SD
condition|)
name|printf
argument_list|(
literal|"spurious RST interrupt"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"hardware error - check fuse"
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ints
operator|&
name|INTS_HARD_ERR
operator|)
operator|||
name|hd
operator|->
name|scsi_serr
condition|)
block|{
if|if
condition|(
name|hd
operator|->
name|scsi_serr
operator|&
name|SERR_SCSI_PAR
condition|)
block|{
name|printf
argument_list|(
literal|"%sparity err"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|hd
operator|->
name|scsi_serr
operator|&
name|SERR_SPC_PAR
condition|)
block|{
name|printf
argument_list|(
literal|"%sSPC parity err"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|hd
operator|->
name|scsi_serr
operator|&
name|SERR_TC_PAR
condition|)
block|{
name|printf
argument_list|(
literal|"%sTC parity err"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|hd
operator|->
name|scsi_serr
operator|&
name|SERR_PHASE_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"%sphase err"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|hd
operator|->
name|scsi_serr
operator|&
name|SERR_SHORT_XFR
condition|)
block|{
name|printf
argument_list|(
literal|"%ssync short transfer err"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|hd
operator|->
name|scsi_serr
operator|&
name|SERR_OFFSET
condition|)
block|{
name|printf
argument_list|(
literal|"%ssync offset error"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ints
operator|&
name|INTS_TIMEOUT
condition|)
name|printf
argument_list|(
literal|"%sSPC select timeout error"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|INTS_SRV_REQ
condition|)
name|printf
argument_list|(
literal|"%sspurious SRV_REQ interrupt"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|INTS_CMD_DONE
condition|)
name|printf
argument_list|(
literal|"%sspurious CMD_DONE interrupt"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|INTS_DISCON
condition|)
name|printf
argument_list|(
literal|"%sspurious disconnect interrupt"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|INTS_RESEL
condition|)
name|printf
argument_list|(
literal|"%sspurious reselect interrupt"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|INTS_SEL
condition|)
name|printf
argument_list|(
literal|"%sspurious select interrupt"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|issue_select
parameter_list|(
name|hd
parameter_list|,
name|target
parameter_list|,
name|our_addr
parameter_list|)
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
decl_stmt|;
name|u_char
name|target
decl_stmt|,
name|our_addr
decl_stmt|;
block|{
if|if
condition|(
name|hd
operator|->
name|scsi_ssts
operator|&
operator|(
name|SSTS_INITIATOR
operator||
name|SSTS_TARGET
operator||
name|SSTS_BUSY
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|hd
operator|->
name|scsi_ints
operator|&
name|INTS_DISCON
condition|)
name|hd
operator|->
name|scsi_ints
operator|=
name|INTS_DISCON
expr_stmt|;
name|hd
operator|->
name|scsi_pctl
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|scsi_temp
operator|=
operator|(
literal|1
operator|<<
name|target
operator|)
operator||
name|our_addr
expr_stmt|;
comment|/* select timeout is hardcoded to 2ms */
name|hd
operator|->
name|scsi_tch
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|scsi_tcm
operator|=
literal|32
expr_stmt|;
name|hd
operator|->
name|scsi_tcl
operator|=
literal|4
expr_stmt|;
name|hd
operator|->
name|scsi_scmd
operator|=
name|SCMD_SELECT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wait_for_select
parameter_list|(
name|hd
parameter_list|)
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
decl_stmt|;
block|{
name|u_char
name|ints
decl_stmt|;
while|while
condition|(
operator|(
name|ints
operator|=
name|hd
operator|->
name|scsi_ints
operator|)
operator|==
literal|0
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hd
operator|->
name|scsi_ints
operator|=
name|ints
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_INITIATOR
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixfer_start
parameter_list|(
name|hd
parameter_list|,
name|len
parameter_list|,
name|phase
parameter_list|,
name|wait
parameter_list|)
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_char
name|phase
decl_stmt|;
specifier|register
name|int
name|wait
decl_stmt|;
block|{
name|hd
operator|->
name|scsi_tch
operator|=
name|len
operator|>>
literal|16
expr_stmt|;
name|hd
operator|->
name|scsi_tcm
operator|=
name|len
operator|>>
literal|8
expr_stmt|;
name|hd
operator|->
name|scsi_tcl
operator|=
name|len
expr_stmt|;
name|hd
operator|->
name|scsi_pctl
operator|=
name|phase
expr_stmt|;
name|hd
operator|->
name|scsi_tmod
operator|=
literal|0
expr_stmt|;
comment|/*XXX*/
name|hd
operator|->
name|scsi_scmd
operator|=
name|SCMD_XFR
operator||
name|SCMD_PROG_XFR
expr_stmt|;
comment|/* wait for xfer to start or svc_req interrupt */
while|while
condition|(
operator|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hd
operator|->
name|scsi_ints
operator|||
operator|--
name|wait
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|scsi_debug
condition|)
name|printf
argument_list|(
literal|"ixfer_start fail: i%x, w%d\n"
argument_list|,
name|hd
operator|->
name|scsi_ints
argument_list|,
name|wait
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|HIST
argument_list|(
argument|ixstart_wait
argument_list|,
argument|wait
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|HIST
argument_list|(
argument|ixstart_wait
argument_list|,
argument|wait
argument_list|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixfer_out
parameter_list|(
name|hd
parameter_list|,
name|len
parameter_list|,
name|buf
parameter_list|)
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|wait
init|=
name|scsi_data_wait
decl_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
control|)
block|{
while|while
condition|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_DREG_FULL
condition|)
block|{
if|if
condition|(
name|hd
operator|->
name|scsi_ints
operator|||
operator|--
name|wait
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|scsi_debug
condition|)
name|printf
argument_list|(
literal|"ixfer_out fail: l%d i%x w%d\n"
argument_list|,
name|len
argument_list|,
name|hd
operator|->
name|scsi_ints
argument_list|,
name|wait
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|HIST
argument_list|(
argument|ixout_wait
argument_list|,
argument|wait
argument_list|)
return|return
operator|(
name|len
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hd
operator|->
name|scsi_dreg
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
block|}
name|HIST
argument_list|(
argument|ixout_wait
argument_list|,
argument|wait
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixfer_in
parameter_list|(
name|hd
parameter_list|,
name|len
parameter_list|,
name|buf
parameter_list|)
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|wait
init|=
name|scsi_data_wait
decl_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
control|)
block|{
while|while
condition|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_DREG_EMPTY
condition|)
block|{
if|if
condition|(
name|hd
operator|->
name|scsi_ints
operator|||
operator|--
name|wait
operator|<
literal|0
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_DREG_EMPTY
operator|)
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|hd
operator|->
name|scsi_dreg
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|scsi_debug
condition|)
name|printf
argument_list|(
literal|"ixfer_in fail: l%d i%x w%d\n"
argument_list|,
name|len
argument_list|,
name|hd
operator|->
name|scsi_ints
argument_list|,
name|wait
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|HIST
argument_list|(
argument|ixin_wait
argument_list|,
argument|wait
argument_list|)
return|return;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|buf
operator|++
operator|=
name|hd
operator|->
name|scsi_dreg
expr_stmt|;
block|}
name|HIST
argument_list|(
argument|ixin_wait
argument_list|,
argument|wait
argument_list|)
block|}
end_function

begin_function
specifier|static
name|int
name|mxfer_in
parameter_list|(
name|hd
parameter_list|,
name|len
parameter_list|,
name|buf
parameter_list|,
name|phase
parameter_list|)
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|u_char
name|phase
decl_stmt|;
block|{
specifier|register
name|int
name|wait
init|=
name|scsi_cmd_wait
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|hd
operator|->
name|scsi_tmod
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
comment|/* 		 * manual sez: reset ATN before ACK is sent. 		 */
if|if
condition|(
name|hd
operator|->
name|scsi_psns
operator|&
name|PSNS_ATN
condition|)
name|hd
operator|->
name|scsi_scmd
operator|=
name|SCMD_RST_ATN
expr_stmt|;
comment|/* 		 * wait for the request line (which says the target 		 * wants to give us data).  If the phase changes while 		 * we're waiting, we're done. 		 */
while|while
condition|(
operator|(
name|hd
operator|->
name|scsi_psns
operator|&
name|PSNS_REQ
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|wait
operator|<
literal|0
condition|)
block|{
name|HIST
argument_list|(
argument|mxin_wait
argument_list|,
argument|wait
argument_list|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hd
operator|->
name|scsi_psns
operator|&
name|PHASE
operator|)
operator|!=
name|phase
operator|||
operator|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_INITIATOR
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * set ack (which says we're ready for the data, wait for 		 * req to go away (target says data is available), grab the 		 * data, then reset ack (say we've got the data). 		 */
name|hd
operator|->
name|scsi_pctl
operator|=
name|phase
expr_stmt|;
name|hd
operator|->
name|scsi_scmd
operator|=
name|SCMD_SET_ACK
expr_stmt|;
while|while
condition|(
name|hd
operator|->
name|scsi_psns
operator|&
name|PSNS_REQ
condition|)
block|{
if|if
condition|(
operator|--
name|wait
operator|<
literal|0
condition|)
block|{
name|HIST
argument_list|(
argument|mxin_wait
argument_list|,
argument|wait
argument_list|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|buf
operator|++
operator|=
name|hd
operator|->
name|scsi_temp
expr_stmt|;
name|hd
operator|->
name|scsi_scmd
operator|=
name|SCMD_RST_ACK
expr_stmt|;
block|}
name|out
label|:
name|HIST
argument_list|(
argument|mxin_wait
argument_list|,
argument|wait
argument_list|)
comment|/* 	 * Wait for manual transfer to finish. 	 * Avoids occasional "unexpected phase" errors in finishxfer 	 * formerly addressed by per-slave delays. 	 */
name|wait
operator|=
name|scsi_cmd_wait
expr_stmt|;
while|while
condition|(
operator|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_ACTIVE
operator|)
operator|==
name|SSTS_INITIATOR
condition|)
block|{
if|if
condition|(
operator|--
name|wait
operator|<
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|HIST
argument_list|(
argument|mxin2_wait
argument_list|,
argument|wait
argument_list|)
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SCSI 'immediate' command:  issue a command to some SCSI device  * and get back an 'immediate' response (i.e., do programmed xfer  * to get the response data).  'cbuf' is a buffer containing a scsi  * command of length clen bytes.  'buf' is a buffer of length 'len'  * bytes for data.  The transfer direction is determined by the device  * (i.e., by the scsi bus data xfer phase).  If 'len' is zero, the  * command must supply no data.  'xferphase' is the bus phase the  * caller expects to happen after the command is issued.  It should  * be one of DATA_IN_PHASE, DATA_OUT_PHASE or STATUS_PHASE.  */
end_comment

begin_function
specifier|static
name|int
name|scsiicmd
parameter_list|(
name|hs
parameter_list|,
name|target
parameter_list|,
name|cbuf
parameter_list|,
name|clen
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|xferphase
parameter_list|)
name|struct
name|scsi_softc
modifier|*
name|hs
decl_stmt|;
name|int
name|target
decl_stmt|;
name|u_char
modifier|*
name|cbuf
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_char
name|xferphase
decl_stmt|;
block|{
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
init|=
operator|(
expr|struct
name|scsidevice
operator|*
operator|)
name|hs
operator|->
name|sc_hc
operator|->
name|hp_addr
decl_stmt|;
name|u_char
name|phase
decl_stmt|,
name|ints
decl_stmt|;
specifier|register
name|int
name|wait
decl_stmt|;
comment|/* select the SCSI bus (it's an error if bus isn't free) */
if|if
condition|(
name|issue_select
argument_list|(
name|hd
argument_list|,
name|target
argument_list|,
name|hs
operator|->
name|sc_scsi_addr
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|wait_for_select
argument_list|(
name|hd
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Wait for a phase change (or error) then let the device 	 * sequence us through the various SCSI phases. 	 */
name|hs
operator|->
name|sc_stat
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
name|hs
operator|->
name|sc_msg
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
name|phase
operator|=
name|CMD_PHASE
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|wait
operator|=
name|scsi_cmd_wait
expr_stmt|;
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
name|CMD_PHASE
case|:
if|if
condition|(
name|ixfer_start
argument_list|(
name|hd
argument_list|,
name|clen
argument_list|,
name|phase
argument_list|,
name|wait
argument_list|)
condition|)
if|if
condition|(
name|ixfer_out
argument_list|(
name|hd
argument_list|,
name|clen
argument_list|,
name|cbuf
argument_list|)
condition|)
goto|goto
name|abort
goto|;
name|phase
operator|=
name|xferphase
expr_stmt|;
break|break;
case|case
name|DATA_IN_PHASE
case|:
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
goto|goto
name|abort
goto|;
name|wait
operator|=
name|scsi_data_wait
expr_stmt|;
if|if
condition|(
name|ixfer_start
argument_list|(
name|hd
argument_list|,
name|len
argument_list|,
name|phase
argument_list|,
name|wait
argument_list|)
operator|||
operator|!
operator|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_DREG_EMPTY
operator|)
condition|)
name|ixfer_in
argument_list|(
name|hd
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|phase
operator|=
name|STATUS_PHASE
expr_stmt|;
break|break;
case|case
name|DATA_OUT_PHASE
case|:
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
goto|goto
name|abort
goto|;
name|wait
operator|=
name|scsi_data_wait
expr_stmt|;
if|if
condition|(
name|ixfer_start
argument_list|(
name|hd
argument_list|,
name|len
argument_list|,
name|phase
argument_list|,
name|wait
argument_list|)
condition|)
block|{
if|if
condition|(
name|ixfer_out
argument_list|(
name|hd
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
condition|)
goto|goto
name|abort
goto|;
block|}
name|phase
operator|=
name|STATUS_PHASE
expr_stmt|;
break|break;
case|case
name|STATUS_PHASE
case|:
name|wait
operator|=
name|scsi_data_wait
expr_stmt|;
if|if
condition|(
name|ixfer_start
argument_list|(
name|hd
argument_list|,
sizeof|sizeof
argument_list|(
name|hs
operator|->
name|sc_stat
argument_list|)
argument_list|,
name|phase
argument_list|,
name|wait
argument_list|)
operator|||
operator|!
operator|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_DREG_EMPTY
operator|)
condition|)
name|ixfer_in
argument_list|(
name|hd
argument_list|,
sizeof|sizeof
argument_list|(
name|hs
operator|->
name|sc_stat
argument_list|)
argument_list|,
name|hs
operator|->
name|sc_stat
argument_list|)
expr_stmt|;
name|phase
operator|=
name|MESG_IN_PHASE
expr_stmt|;
break|break;
case|case
name|MESG_IN_PHASE
case|:
if|if
condition|(
name|ixfer_start
argument_list|(
name|hd
argument_list|,
sizeof|sizeof
argument_list|(
name|hs
operator|->
name|sc_msg
argument_list|)
argument_list|,
name|phase
argument_list|,
name|wait
argument_list|)
operator|||
operator|!
operator|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_DREG_EMPTY
operator|)
condition|)
block|{
name|ixfer_in
argument_list|(
name|hd
argument_list|,
sizeof|sizeof
argument_list|(
name|hs
operator|->
name|sc_msg
argument_list|)
argument_list|,
name|hs
operator|->
name|sc_msg
argument_list|)
expr_stmt|;
name|hd
operator|->
name|scsi_scmd
operator|=
name|SCMD_RST_ACK
expr_stmt|;
block|}
name|phase
operator|=
name|BUS_FREE_PHASE
expr_stmt|;
break|break;
case|case
name|BUS_FREE_PHASE
case|:
goto|goto
name|out
goto|;
default|default:
name|printf
argument_list|(
literal|"scsi%d: unexpected phase %d in icmd from %d\n"
argument_list|,
name|hs
operator|->
name|sc_hc
operator|->
name|hp_unit
argument_list|,
name|phase
argument_list|,
name|target
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
comment|/* wait for last command to complete */
while|while
condition|(
operator|(
name|ints
operator|=
name|hd
operator|->
name|scsi_ints
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|wait
operator|<
literal|0
condition|)
block|{
name|HIST
argument_list|(
argument|cxin_wait
argument_list|,
argument|wait
argument_list|)
goto|goto
name|abort
goto|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|HIST
argument_list|(
argument|cxin_wait
argument_list|,
argument|wait
argument_list|)
name|hd
operator|->
name|scsi_ints
operator|=
name|ints
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|INTS_SRV_REQ
condition|)
name|phase
operator|=
name|hd
operator|->
name|scsi_psns
operator|&
name|PHASE
expr_stmt|;
elseif|else
if|if
condition|(
name|ints
operator|&
name|INTS_DISCON
condition|)
goto|goto
name|out
goto|;
elseif|else
if|if
condition|(
operator|(
name|ints
operator|&
name|INTS_CMD_DONE
operator|)
operator|==
literal|0
condition|)
block|{
name|scsierror
argument_list|(
name|hs
argument_list|,
name|hd
argument_list|,
name|ints
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
block|}
name|abort
label|:
name|scsiabort
argument_list|(
name|hs
argument_list|,
name|hd
argument_list|,
literal|"icmd"
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|hs
operator|->
name|sc_stat
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finish SCSI xfer command:  After the completion interrupt from  * a read/write operation, sequence through the final phases in  * programmed i/o.  This routine is a lot like scsiicmd except we  * skip (and don't allow) the select, cmd out and data in/out phases.  */
end_comment

begin_function
specifier|static
name|void
name|finishxfer
parameter_list|(
name|hs
parameter_list|,
name|hd
parameter_list|,
name|target
parameter_list|)
name|struct
name|scsi_softc
modifier|*
name|hs
decl_stmt|;
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
decl_stmt|;
name|int
name|target
decl_stmt|;
block|{
name|u_char
name|phase
decl_stmt|,
name|ints
decl_stmt|;
comment|/* 	 * We specified padding xfer so we ended with either a phase 	 * change interrupt (normal case) or an error interrupt (handled 	 * elsewhere).  Reset the board dma logic then try to get the 	 * completion status& command done msg.  The reset confuses 	 * the SPC REQ/ACK logic so we have to do any status/msg input 	 * operations via 'manual xfer'. 	 */
if|if
condition|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_BUSY
condition|)
block|{
name|int
name|wait
init|=
name|scsi_cmd_wait
decl_stmt|;
comment|/* wait for dma operation to finish */
while|while
condition|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_BUSY
condition|)
block|{
if|if
condition|(
operator|--
name|wait
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|scsi_debug
condition|)
name|printf
argument_list|(
literal|"finishxfer fail: ssts %x\n"
argument_list|,
name|hd
operator|->
name|scsi_ssts
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|HIST
argument_list|(
argument|fxfr_wait
argument_list|,
argument|wait
argument_list|)
goto|goto
name|abort
goto|;
block|}
block|}
name|HIST
argument_list|(
argument|fxfr_wait
argument_list|,
argument|wait
argument_list|)
block|}
name|hd
operator|->
name|scsi_scmd
operator||=
name|SCMD_PROG_XFR
expr_stmt|;
name|hd
operator|->
name|scsi_sctl
operator||=
name|SCTL_CTRLRST
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hd
operator|->
name|scsi_sctl
operator|&=
operator|~
name|SCTL_CTRLRST
expr_stmt|;
name|hd
operator|->
name|scsi_hconf
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The following delay is definitely needed when trying to 	 * write on a write protected disk (in the optical jukebox anyways), 	 * but we shall see if other unexplained machine freezeups 	 * also stop occuring...  A value of 5 seems to work but 	 * 10 seems safer considering the potential consequences. 	 */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|hs
operator|->
name|sc_stat
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
name|hs
operator|->
name|sc_msg
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
name|hd
operator|->
name|scsi_csr
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|scsi_ints
operator|=
name|ints
operator|=
name|hd
operator|->
name|scsi_ints
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|phase
operator|=
name|hd
operator|->
name|scsi_psns
operator|&
name|PHASE
expr_stmt|;
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
name|STATUS_PHASE
case|:
if|if
condition|(
name|mxfer_in
argument_list|(
name|hd
argument_list|,
sizeof|sizeof
argument_list|(
name|hs
operator|->
name|sc_stat
argument_list|)
argument_list|,
name|hs
operator|->
name|sc_stat
argument_list|,
name|phase
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|abort
goto|;
break|break;
case|case
name|MESG_IN_PHASE
case|:
if|if
condition|(
name|mxfer_in
argument_list|(
name|hd
argument_list|,
sizeof|sizeof
argument_list|(
name|hs
operator|->
name|sc_msg
argument_list|)
argument_list|,
name|hs
operator|->
name|sc_msg
argument_list|,
name|phase
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|abort
goto|;
break|break;
case|case
name|BUS_FREE_PHASE
case|:
return|return;
default|default:
name|printf
argument_list|(
literal|"scsi%d: unexpected phase %d in finishxfer from %d\n"
argument_list|,
name|hs
operator|->
name|sc_hc
operator|->
name|hp_unit
argument_list|,
name|phase
argument_list|,
name|target
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
if|if
condition|(
name|ints
operator|=
name|hd
operator|->
name|scsi_ints
condition|)
block|{
name|hd
operator|->
name|scsi_ints
operator|=
name|ints
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|INTS_DISCON
condition|)
return|return;
elseif|else
if|if
condition|(
name|ints
operator|&
operator|~
operator|(
name|INTS_SRV_REQ
operator||
name|INTS_CMD_DONE
operator|)
condition|)
block|{
name|scsierror
argument_list|(
name|hs
argument_list|,
name|hd
argument_list|,
name|ints
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_INITIATOR
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
name|abort
label|:
name|scsiabort
argument_list|(
name|hs
argument_list|,
name|hd
argument_list|,
literal|"finishxfer"
argument_list|)
expr_stmt|;
name|hs
operator|->
name|sc_stat
index|[
literal|0
index|]
operator|=
literal|0xfe
expr_stmt|;
block|}
end_function

begin_function
name|int
name|scsi_test_unit_rdy
parameter_list|(
name|ctlr
parameter_list|,
name|slave
parameter_list|,
name|unit
parameter_list|)
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_softc
modifier|*
name|hs
init|=
operator|&
name|scsi_softc
index|[
name|ctlr
index|]
decl_stmt|;
specifier|static
name|struct
name|scsi_cdb6
name|cdb
init|=
block|{
name|CMD_TEST_UNIT_READY
block|}
decl_stmt|;
name|cdb
operator|.
name|lun
operator|=
name|unit
expr_stmt|;
return|return
operator|(
name|scsiicmd
argument_list|(
name|hs
argument_list|,
name|slave
argument_list|,
operator|&
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|STATUS_PHASE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scsi_request_sense
parameter_list|(
name|ctlr
parameter_list|,
name|slave
parameter_list|,
name|unit
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|unit
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_softc
modifier|*
name|hs
init|=
operator|&
name|scsi_softc
index|[
name|ctlr
index|]
decl_stmt|;
specifier|static
name|struct
name|scsi_cdb6
name|cdb
init|=
block|{
name|CMD_REQUEST_SENSE
block|}
decl_stmt|;
name|cdb
operator|.
name|lun
operator|=
name|unit
expr_stmt|;
name|cdb
operator|.
name|len
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|scsiicmd
argument_list|(
name|hs
argument_list|,
name|slave
argument_list|,
operator|&
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb
argument_list|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|DATA_IN_PHASE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scsi_immed_command
parameter_list|(
name|ctlr
parameter_list|,
name|slave
parameter_list|,
name|unit
parameter_list|,
name|cdb
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|rd
parameter_list|)
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|unit
decl_stmt|;
name|struct
name|scsi_fmt_cdb
modifier|*
name|cdb
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_softc
modifier|*
name|hs
init|=
operator|&
name|scsi_softc
index|[
name|ctlr
index|]
decl_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|1
index|]
operator||=
name|unit
operator|<<
literal|5
expr_stmt|;
return|return
operator|(
name|scsiicmd
argument_list|(
name|hs
argument_list|,
name|slave
argument_list|,
name|cdb
operator|->
name|cdb
argument_list|,
name|cdb
operator|->
name|len
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|rd
operator|!=
literal|0
condition|?
name|DATA_IN_PHASE
else|:
name|DATA_OUT_PHASE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The following routines are test-and-transfer i/o versions of read/write  * for things like reading disk labels and writing core dumps.  The  * routine scsigo should be used for normal data transfers, NOT these  * routines.  */
end_comment

begin_function
name|int
name|scsi_tt_read
parameter_list|(
name|ctlr
parameter_list|,
name|slave
parameter_list|,
name|unit
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|blk
parameter_list|,
name|bshift
parameter_list|)
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|unit
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
name|int
name|bshift
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_softc
modifier|*
name|hs
init|=
operator|&
name|scsi_softc
index|[
name|ctlr
index|]
decl_stmt|;
name|struct
name|scsi_cdb10
name|cdb
decl_stmt|;
name|int
name|stat
decl_stmt|;
name|int
name|old_wait
init|=
name|scsi_data_wait
decl_stmt|;
name|scsi_data_wait
operator|=
literal|300000
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
name|cdb
operator|.
name|cmd
operator|=
name|CMD_READ_EXT
expr_stmt|;
name|cdb
operator|.
name|lun
operator|=
name|unit
expr_stmt|;
name|blk
operator|>>=
name|bshift
expr_stmt|;
name|cdb
operator|.
name|lbah
operator|=
name|blk
operator|>>
literal|24
expr_stmt|;
name|cdb
operator|.
name|lbahm
operator|=
name|blk
operator|>>
literal|16
expr_stmt|;
name|cdb
operator|.
name|lbalm
operator|=
name|blk
operator|>>
literal|8
expr_stmt|;
name|cdb
operator|.
name|lbal
operator|=
name|blk
expr_stmt|;
name|cdb
operator|.
name|lenh
operator|=
name|len
operator|>>
operator|(
literal|8
operator|+
name|DEV_BSHIFT
operator|+
name|bshift
operator|)
expr_stmt|;
name|cdb
operator|.
name|lenl
operator|=
name|len
operator|>>
operator|(
name|DEV_BSHIFT
operator|+
name|bshift
operator|)
expr_stmt|;
name|stat
operator|=
name|scsiicmd
argument_list|(
name|hs
argument_list|,
name|slave
argument_list|,
operator|&
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb
argument_list|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|DATA_IN_PHASE
argument_list|)
expr_stmt|;
name|scsi_data_wait
operator|=
name|old_wait
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scsi_tt_write
parameter_list|(
name|ctlr
parameter_list|,
name|slave
parameter_list|,
name|unit
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|blk
parameter_list|,
name|bshift
parameter_list|)
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|unit
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
name|int
name|bshift
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_softc
modifier|*
name|hs
init|=
operator|&
name|scsi_softc
index|[
name|ctlr
index|]
decl_stmt|;
name|struct
name|scsi_cdb10
name|cdb
decl_stmt|;
name|int
name|stat
decl_stmt|;
name|int
name|old_wait
init|=
name|scsi_data_wait
decl_stmt|;
name|scsi_data_wait
operator|=
literal|300000
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
name|cdb
operator|.
name|cmd
operator|=
name|CMD_WRITE_EXT
expr_stmt|;
name|cdb
operator|.
name|lun
operator|=
name|unit
expr_stmt|;
name|blk
operator|>>=
name|bshift
expr_stmt|;
name|cdb
operator|.
name|lbah
operator|=
name|blk
operator|>>
literal|24
expr_stmt|;
name|cdb
operator|.
name|lbahm
operator|=
name|blk
operator|>>
literal|16
expr_stmt|;
name|cdb
operator|.
name|lbalm
operator|=
name|blk
operator|>>
literal|8
expr_stmt|;
name|cdb
operator|.
name|lbal
operator|=
name|blk
expr_stmt|;
name|cdb
operator|.
name|lenh
operator|=
name|len
operator|>>
operator|(
literal|8
operator|+
name|DEV_BSHIFT
operator|+
name|bshift
operator|)
expr_stmt|;
name|cdb
operator|.
name|lenl
operator|=
name|len
operator|>>
operator|(
name|DEV_BSHIFT
operator|+
name|bshift
operator|)
expr_stmt|;
name|stat
operator|=
name|scsiicmd
argument_list|(
name|hs
argument_list|,
name|slave
argument_list|,
operator|&
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb
argument_list|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|DATA_OUT_PHASE
argument_list|)
expr_stmt|;
name|scsi_data_wait
operator|=
name|old_wait
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scsireq
parameter_list|(
name|dq
parameter_list|)
specifier|register
name|struct
name|devqueue
modifier|*
name|dq
decl_stmt|;
block|{
specifier|register
name|struct
name|devqueue
modifier|*
name|hq
decl_stmt|;
name|hq
operator|=
operator|&
name|scsi_softc
index|[
name|dq
operator|->
name|dq_ctlr
index|]
operator|.
name|sc_sq
expr_stmt|;
name|insque
argument_list|(
name|dq
argument_list|,
name|hq
operator|->
name|dq_back
argument_list|)
expr_stmt|;
if|if
condition|(
name|dq
operator|->
name|dq_back
operator|==
name|hq
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scsiustart
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_softc
modifier|*
name|hs
init|=
operator|&
name|scsi_softc
index|[
name|unit
index|]
decl_stmt|;
name|hs
operator|->
name|sc_dq
operator|.
name|dq_ctlr
operator|=
name|DMA0
operator||
name|DMA1
expr_stmt|;
name|hs
operator|->
name|sc_flags
operator||=
name|SCSI_HAVEDMA
expr_stmt|;
if|if
condition|(
name|dmareq
argument_list|(
operator|&
name|hs
operator|->
name|sc_dq
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scsistart
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|devqueue
modifier|*
name|dq
decl_stmt|;
name|dq
operator|=
name|scsi_softc
index|[
name|unit
index|]
operator|.
name|sc_sq
operator|.
name|dq_forw
expr_stmt|;
call|(
name|dq
operator|->
name|dq_driver
operator|->
name|d_go
call|)
argument_list|(
name|dq
operator|->
name|dq_unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|scsigo
parameter_list|(
name|ctlr
parameter_list|,
name|slave
parameter_list|,
name|unit
parameter_list|,
name|bp
parameter_list|,
name|cdb
parameter_list|,
name|pad
parameter_list|)
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|unit
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|scsi_fmt_cdb
modifier|*
name|cdb
decl_stmt|;
name|int
name|pad
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_softc
modifier|*
name|hs
init|=
operator|&
name|scsi_softc
index|[
name|ctlr
index|]
decl_stmt|;
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
init|=
operator|(
expr|struct
name|scsidevice
operator|*
operator|)
name|hs
operator|->
name|sc_hc
operator|->
name|hp_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dmaflags
decl_stmt|;
name|u_char
name|phase
decl_stmt|,
name|ints
decl_stmt|,
name|cmd
decl_stmt|;
name|cdb
operator|->
name|cdb
index|[
literal|1
index|]
operator||=
name|unit
operator|<<
literal|5
expr_stmt|;
comment|/* select the SCSI bus (it's an error if bus isn't free) */
if|if
condition|(
name|issue_select
argument_list|(
name|hd
argument_list|,
name|slave
argument_list|,
name|hs
operator|->
name|sc_scsi_addr
argument_list|)
operator|||
name|wait_for_select
argument_list|(
name|hd
argument_list|)
condition|)
block|{
if|if
condition|(
name|hs
operator|->
name|sc_flags
operator|&
name|SCSI_HAVEDMA
condition|)
block|{
name|hs
operator|->
name|sc_flags
operator|&=
operator|~
name|SCSI_HAVEDMA
expr_stmt|;
name|dmafree
argument_list|(
operator|&
name|hs
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Wait for a phase change (or error) then let the device 	 * sequence us through command phase (we may have to take 	 * a msg in/out before doing the command).  If the disk has 	 * to do a seek, it may be a long time until we get a change 	 * to data phase so, in the absense of an explicit phase 	 * change, we assume data phase will be coming up and tell 	 * the SPC to start a transfer whenever it does.  We'll get 	 * a service required interrupt later if this assumption is 	 * wrong.  Otherwise we'll get a service required int when 	 * the transfer changes to status phase. 	 */
name|phase
operator|=
name|CMD_PHASE
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|int
name|wait
init|=
name|scsi_cmd_wait
decl_stmt|;
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
name|CMD_PHASE
case|:
if|if
condition|(
name|ixfer_start
argument_list|(
name|hd
argument_list|,
name|cdb
operator|->
name|len
argument_list|,
name|phase
argument_list|,
name|wait
argument_list|)
condition|)
if|if
condition|(
name|ixfer_out
argument_list|(
name|hd
argument_list|,
name|cdb
operator|->
name|len
argument_list|,
name|cdb
operator|->
name|cdb
argument_list|)
condition|)
goto|goto
name|abort
goto|;
break|break;
case|case
name|MESG_IN_PHASE
case|:
if|if
condition|(
name|ixfer_start
argument_list|(
name|hd
argument_list|,
sizeof|sizeof
argument_list|(
name|hs
operator|->
name|sc_msg
argument_list|)
argument_list|,
name|phase
argument_list|,
name|wait
argument_list|)
operator|||
operator|!
operator|(
name|hd
operator|->
name|scsi_ssts
operator|&
name|SSTS_DREG_EMPTY
operator|)
condition|)
block|{
name|ixfer_in
argument_list|(
name|hd
argument_list|,
sizeof|sizeof
argument_list|(
name|hs
operator|->
name|sc_msg
argument_list|)
argument_list|,
name|hs
operator|->
name|sc_msg
argument_list|)
expr_stmt|;
name|hd
operator|->
name|scsi_scmd
operator|=
name|SCMD_RST_ACK
expr_stmt|;
block|}
name|phase
operator|=
name|BUS_FREE_PHASE
expr_stmt|;
break|break;
case|case
name|DATA_IN_PHASE
case|:
case|case
name|DATA_OUT_PHASE
case|:
goto|goto
name|out
goto|;
default|default:
name|printf
argument_list|(
literal|"scsi%d: unexpected phase %d in go from %d\n"
argument_list|,
name|hs
operator|->
name|sc_hc
operator|->
name|hp_unit
argument_list|,
name|phase
argument_list|,
name|slave
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
while|while
condition|(
operator|(
name|ints
operator|=
name|hd
operator|->
name|scsi_ints
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|wait
operator|<
literal|0
condition|)
block|{
name|HIST
argument_list|(
argument|sgo_wait
argument_list|,
argument|wait
argument_list|)
goto|goto
name|abort
goto|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|HIST
argument_list|(
argument|sgo_wait
argument_list|,
argument|wait
argument_list|)
name|hd
operator|->
name|scsi_ints
operator|=
name|ints
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|INTS_SRV_REQ
condition|)
name|phase
operator|=
name|hd
operator|->
name|scsi_psns
operator|&
name|PHASE
expr_stmt|;
elseif|else
if|if
condition|(
name|ints
operator|&
name|INTS_CMD_DONE
condition|)
goto|goto
name|out
goto|;
else|else
block|{
name|scsierror
argument_list|(
name|hs
argument_list|,
name|hd
argument_list|,
name|ints
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
block|}
name|out
label|:
comment|/* 	 * Reset the card dma logic, setup the dma channel then 	 * get the dio part of the card set for a dma xfer. 	 */
name|hd
operator|->
name|scsi_hconf
operator|=
literal|0
expr_stmt|;
name|cmd
operator|=
name|CSR_IE
expr_stmt|;
name|dmaflags
operator|=
name|DMAGO_NOINT
expr_stmt|;
if|if
condition|(
name|scsi_pridma
condition|)
name|dmaflags
operator||=
name|DMAGO_PRI
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|dmaflags
operator||=
name|DMAGO_READ
expr_stmt|;
if|if
condition|(
operator|(
name|hs
operator|->
name|sc_flags
operator|&
name|SCSI_DMA32
operator|)
operator|&&
operator|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bp
operator|->
name|b_bcount
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
block|{
name|cmd
operator||=
name|CSR_DMA32
expr_stmt|;
name|dmaflags
operator||=
name|DMAGO_LWORD
expr_stmt|;
block|}
else|else
name|dmaflags
operator||=
name|DMAGO_WORD
expr_stmt|;
name|dmago
argument_list|(
name|hs
operator|->
name|sc_dq
operator|.
name|dq_ctlr
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|dmaflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|cmd
operator||=
name|CSR_DMAIN
expr_stmt|;
name|phase
operator|=
name|DATA_IN_PHASE
expr_stmt|;
block|}
else|else
name|phase
operator|=
name|DATA_OUT_PHASE
expr_stmt|;
comment|/* 	 * DMA enable bits must be set after size and direction bits. 	 */
name|hd
operator|->
name|scsi_csr
operator|=
name|cmd
expr_stmt|;
name|hd
operator|->
name|scsi_csr
operator||=
operator|(
name|CSR_DE0
operator|<<
name|hs
operator|->
name|sc_dq
operator|.
name|dq_ctlr
operator|)
expr_stmt|;
comment|/* 	 * Setup the SPC for the transfer.  We don't want to take 	 * first a command complete then a service required interrupt 	 * at the end of the transfer so we try to disable the cmd 	 * complete by setting the transfer counter to more bytes 	 * than we expect.  (XXX - This strategy may have to be 	 * modified to deal with devices that return variable length 	 * blocks, e.g., some tape drives.) 	 */
name|cmd
operator|=
name|SCMD_XFR
expr_stmt|;
name|i
operator|=
operator|(
name|unsigned
operator|)
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|pad
condition|)
block|{
name|cmd
operator||=
name|SCMD_PAD
expr_stmt|;
comment|/* 		 * XXX - If we don't do this, the last 2 or 4 bytes 		 * (depending on word/lword DMA) of a read get trashed. 		 * It looks like it is necessary for the DMA to complete 		 * before the SPC goes into "pad mode"???  Note: if we 		 * also do this on a write, the request never completes. 		 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|i
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|hs
operator|->
name|sc_flags
operator||=
name|SCSI_PAD
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|printf
argument_list|(
literal|"scsi%d: odd byte count: %d bytes @ %d\n"
argument_list|,
name|ctlr
argument_list|,
name|i
argument_list|,
name|bp
operator|->
name|b_cylin
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|i
operator|+=
literal|4
expr_stmt|;
name|hd
operator|->
name|scsi_tch
operator|=
name|i
operator|>>
literal|16
expr_stmt|;
name|hd
operator|->
name|scsi_tcm
operator|=
name|i
operator|>>
literal|8
expr_stmt|;
name|hd
operator|->
name|scsi_tcl
operator|=
name|i
expr_stmt|;
name|hd
operator|->
name|scsi_pctl
operator|=
name|phase
expr_stmt|;
name|hd
operator|->
name|scsi_tmod
operator|=
literal|0
expr_stmt|;
name|hd
operator|->
name|scsi_scmd
operator|=
name|cmd
expr_stmt|;
name|hs
operator|->
name|sc_flags
operator||=
name|SCSI_IO
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|abort
label|:
name|scsiabort
argument_list|(
name|hs
argument_list|,
name|hd
argument_list|,
literal|"go"
argument_list|)
expr_stmt|;
name|hs
operator|->
name|sc_flags
operator|&=
operator|~
name|SCSI_HAVEDMA
expr_stmt|;
name|dmafree
argument_list|(
operator|&
name|hs
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scsidone
parameter_list|(
name|unit
parameter_list|)
specifier|register
name|int
name|unit
decl_stmt|;
block|{
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
init|=
operator|(
expr|struct
name|scsidevice
operator|*
operator|)
name|scsi_softc
index|[
name|unit
index|]
operator|.
name|sc_hc
operator|->
name|hp_addr
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|scsi_debug
condition|)
name|printf
argument_list|(
literal|"scsi%d: done called!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* dma operation is done -- turn off card dma */
name|hd
operator|->
name|scsi_csr
operator|&=
operator|~
operator|(
name|CSR_DE1
operator||
name|CSR_DE0
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|scsiintr
parameter_list|(
name|unit
parameter_list|)
specifier|register
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_softc
modifier|*
name|hs
init|=
operator|&
name|scsi_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|volatile
specifier|register
name|struct
name|scsidevice
modifier|*
name|hd
init|=
operator|(
expr|struct
name|scsidevice
operator|*
operator|)
name|hs
operator|->
name|sc_hc
operator|->
name|hp_addr
decl_stmt|;
specifier|register
name|u_char
name|ints
decl_stmt|;
specifier|register
name|struct
name|devqueue
modifier|*
name|dq
decl_stmt|;
if|if
condition|(
operator|(
name|hd
operator|->
name|scsi_csr
operator|&
operator|(
name|CSR_IE
operator||
name|CSR_IR
operator|)
operator|)
operator|!=
operator|(
name|CSR_IE
operator||
name|CSR_IR
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ints
operator|=
name|hd
operator|->
name|scsi_ints
expr_stmt|;
if|if
condition|(
operator|(
name|ints
operator|&
name|INTS_SRV_REQ
operator|)
operator|&&
operator|(
name|hs
operator|->
name|sc_flags
operator|&
name|SCSI_IO
operator|)
condition|)
block|{
comment|/* 		 * this should be the normal i/o completion case. 		 * get the status& cmd complete msg then let the 		 * device driver look at what happened. 		 */
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|len
init|=
operator|(
name|hd
operator|->
name|scsi_tch
operator|<<
literal|16
operator|)
operator||
operator|(
name|hd
operator|->
name|scsi_tcm
operator|<<
literal|8
operator|)
operator||
name|hd
operator|->
name|scsi_tcl
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|hs
operator|->
name|sc_flags
operator|&
name|SCSI_PAD
operator|)
condition|)
name|len
operator|-=
literal|4
expr_stmt|;
name|hs
operator|->
name|sc_flags
operator|&=
operator|~
name|SCSI_PAD
expr_stmt|;
endif|#
directive|endif
name|dq
operator|=
name|hs
operator|->
name|sc_sq
operator|.
name|dq_forw
expr_stmt|;
name|finishxfer
argument_list|(
name|hs
argument_list|,
name|hd
argument_list|,
name|dq
operator|->
name|dq_slave
argument_list|)
expr_stmt|;
name|hs
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|SCSI_IO
operator||
name|SCSI_HAVEDMA
operator|)
expr_stmt|;
name|dmafree
argument_list|(
operator|&
name|hs
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
call|(
name|dq
operator|->
name|dq_driver
operator|->
name|d_intr
call|)
argument_list|(
name|dq
operator|->
name|dq_unit
argument_list|,
name|hs
operator|->
name|sc_stat
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Something unexpected happened -- deal with it. */
name|hd
operator|->
name|scsi_ints
operator|=
name|ints
expr_stmt|;
name|hd
operator|->
name|scsi_csr
operator|=
literal|0
expr_stmt|;
name|scsierror
argument_list|(
name|hs
argument_list|,
name|hd
argument_list|,
name|ints
argument_list|)
expr_stmt|;
name|scsiabort
argument_list|(
name|hs
argument_list|,
name|hd
argument_list|,
literal|"intr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hs
operator|->
name|sc_flags
operator|&
name|SCSI_IO
condition|)
block|{
name|hs
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|SCSI_IO
operator||
name|SCSI_HAVEDMA
operator|)
expr_stmt|;
name|dmafree
argument_list|(
operator|&
name|hs
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
name|dq
operator|=
name|hs
operator|->
name|sc_sq
operator|.
name|dq_forw
expr_stmt|;
call|(
name|dq
operator|->
name|dq_driver
operator|->
name|d_intr
call|)
argument_list|(
name|dq
operator|->
name|dq_unit
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scsifree
parameter_list|(
name|dq
parameter_list|)
specifier|register
name|struct
name|devqueue
modifier|*
name|dq
decl_stmt|;
block|{
specifier|register
name|struct
name|devqueue
modifier|*
name|hq
decl_stmt|;
name|hq
operator|=
operator|&
name|scsi_softc
index|[
name|dq
operator|->
name|dq_ctlr
index|]
operator|.
name|sc_sq
expr_stmt|;
name|remque
argument_list|(
name|dq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dq
operator|=
name|hq
operator|->
name|dq_forw
operator|)
operator|!=
name|hq
condition|)
call|(
name|dq
operator|->
name|dq_driver
operator|->
name|d_start
call|)
argument_list|(
name|dq
operator|->
name|dq_unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * (XXX) The following routine is needed for the SCSI tape driver  * to read odd-size records.  */
end_comment

begin_include
include|#
directive|include
file|"st.h"
end_include

begin_if
if|#
directive|if
name|NST
operator|>
literal|0
end_if

begin_function
name|int
name|scsi_tt_oddio
parameter_list|(
name|ctlr
parameter_list|,
name|slave
parameter_list|,
name|unit
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|b_flags
parameter_list|,
name|freedma
parameter_list|)
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|unit
decl_stmt|,
name|b_flags
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_softc
modifier|*
name|hs
init|=
operator|&
name|scsi_softc
index|[
name|ctlr
index|]
decl_stmt|;
name|struct
name|scsi_cdb6
name|cdb
decl_stmt|;
name|u_char
name|iphase
decl_stmt|;
name|int
name|stat
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|freedma
operator|&&
operator|(
name|hs
operator|->
name|sc_flags
operator|&
name|SCSI_HAVEDMA
operator|)
operator|==
literal|0
operator|||
operator|!
name|freedma
operator|&&
operator|(
name|hs
operator|->
name|sc_flags
operator|&
name|SCSI_HAVEDMA
operator|)
condition|)
name|printf
argument_list|(
literal|"oddio: freedma (%d) inconsistency (flags=%x)\n"
argument_list|,
name|freedma
argument_list|,
name|hs
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * First free any DMA channel that was allocated. 	 * We can't use DMA to do this transfer. 	 */
if|if
condition|(
name|freedma
condition|)
block|{
name|hs
operator|->
name|sc_flags
operator|&=
operator|~
name|SCSI_HAVEDMA
expr_stmt|;
name|dmafree
argument_list|(
name|hs
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize command block 	 */
name|bzero
argument_list|(
operator|&
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
name|cdb
operator|.
name|lun
operator|=
name|unit
expr_stmt|;
name|cdb
operator|.
name|lbam
operator|=
operator|(
name|len
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|cdb
operator|.
name|lbal
operator|=
operator|(
name|len
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|cdb
operator|.
name|len
operator|=
name|len
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|cdb
operator|.
name|cmd
operator|=
name|CMD_SPACE
expr_stmt|;
name|cdb
operator|.
name|lun
operator||=
literal|0x00
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|iphase
operator|=
name|MESG_IN_PHASE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|cdb
operator|.
name|cmd
operator|=
name|CMD_READ
expr_stmt|;
name|iphase
operator|=
name|DATA_IN_PHASE
expr_stmt|;
block|}
else|else
block|{
name|cdb
operator|.
name|cmd
operator|=
name|CMD_WRITE
expr_stmt|;
name|iphase
operator|=
name|DATA_OUT_PHASE
expr_stmt|;
block|}
comment|/* 	 * Perform command (with very long delays) 	 */
name|scsi_delay
argument_list|(
literal|30000000
argument_list|)
expr_stmt|;
name|stat
operator|=
name|scsiicmd
argument_list|(
name|hs
argument_list|,
name|slave
argument_list|,
operator|&
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb
argument_list|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|iphase
argument_list|)
expr_stmt|;
name|scsi_delay
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

