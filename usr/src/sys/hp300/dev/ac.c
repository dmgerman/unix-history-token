begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 University of Utah.  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: ac.c 1.5 92/01/21$  *  *	@(#)ac.c	8.2 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * SCSI driver for MO autochanger.  *  * Very crude.  Because of the lack of connect/disconnect support in the  * scsi driver, this driver can tie up the SCSI bus for a long time.  It  * also grabs a DMA channel and holds it for the duration even though it  * never uses it.  */
end_comment

begin_include
include|#
directive|include
file|"ac.h"
end_include

begin_if
if|#
directive|if
name|NAC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/scsireg.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/acioctl.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/acvar.h>
end_include

begin_function_decl
specifier|extern
name|int
name|scsi_test_unit_rdy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|scsi_request_sense
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|scsiustart
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|scsigo
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|scsifree
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|scsireset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|scsi_delay
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|scsi_immed_command
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|acinit
argument_list|()
decl_stmt|,
name|acstart
argument_list|()
decl_stmt|,
name|acgo
argument_list|()
decl_stmt|,
name|acintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|driver
name|acdriver
init|=
block|{
name|acinit
block|,
literal|"ac"
block|,
name|acstart
block|,
name|acgo
block|,
name|acintr
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ac_softc
name|ac_softc
index|[
name|NAC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|buf
name|acbuf
index|[
name|NAC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_fmt_cdb
name|accmd
index|[
name|NAC
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|ac_debug
init|=
literal|0x0000
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ACD_FOLLOW
value|0x0001
end_define

begin_define
define|#
directive|define
name|ACD_OPEN
value|0x0002
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|acinit
argument_list|(
name|hd
argument_list|)
specifier|register
expr|struct
name|hp_device
operator|*
name|hd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|unit
init|=
name|hd
operator|->
name|hp_unit
decl_stmt|;
specifier|register
name|struct
name|ac_softc
modifier|*
name|sc
init|=
operator|&
name|ac_softc
index|[
name|unit
index|]
decl_stmt|;
name|sc
operator|->
name|sc_hd
operator|=
name|hd
expr_stmt|;
name|sc
operator|->
name|sc_punit
operator|=
name|hd
operator|->
name|hp_flags
operator|&
literal|7
expr_stmt|;
if|if
condition|(
name|acident
argument_list|(
name|sc
argument_list|,
name|hd
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_ctlr
operator|=
name|hd
operator|->
name|hp_ctlr
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_slave
operator|=
name|hd
operator|->
name|hp_slave
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_driver
operator|=
operator|&
name|acdriver
expr_stmt|;
name|sc
operator|->
name|sc_bp
operator|=
operator|&
name|acbuf
index|[
name|unit
index|]
expr_stmt|;
name|sc
operator|->
name|sc_cmd
operator|=
operator|&
name|accmd
index|[
name|unit
index|]
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|ACF_ALIVE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|acident
argument_list|(
name|sc
argument_list|,
name|hd
argument_list|)
specifier|register
expr|struct
name|ac_softc
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hp_device
modifier|*
name|hd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|;
name|int
name|i
decl_stmt|,
name|stat
decl_stmt|;
name|int
name|tries
init|=
literal|5
decl_stmt|;
name|char
name|idstr
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|scsi_inquiry
name|inqbuf
decl_stmt|;
specifier|static
name|struct
name|scsi_fmt_cdb
name|inq
init|=
block|{
literal|6
block|,
name|CMD_INQUIRY
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|inqbuf
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|ctlr
operator|=
name|hd
operator|->
name|hp_ctlr
expr_stmt|;
name|slave
operator|=
name|hd
operator|->
name|hp_slave
expr_stmt|;
name|unit
operator|=
name|sc
operator|->
name|sc_punit
expr_stmt|;
name|scsi_delay
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * See if device is ready 	 */
while|while
condition|(
operator|(
name|i
operator|=
name|scsi_test_unit_rdy
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|-
literal|1
operator|||
operator|--
name|tries
operator|<
literal|0
condition|)
comment|/* doesn't exist or not a CCS device */
goto|goto
name|failed
goto|;
if|if
condition|(
name|i
operator|==
name|STS_CHECKCOND
condition|)
block|{
name|u_char
name|sensebuf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|scsi_xsense
modifier|*
name|sp
decl_stmt|;
name|scsi_request_sense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
name|sensebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sensebuf
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|scsi_xsense
operator|*
operator|)
name|sensebuf
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|class
operator|==
literal|7
operator|&&
name|sp
operator|->
name|key
operator|==
literal|6
condition|)
comment|/* drive doing an RTZ -- give it a while */
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find out if it is an autochanger 	 */
if|if
condition|(
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
operator|&
name|inq
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|inqbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|inqbuf
argument_list|)
argument_list|,
name|B_READ
argument_list|)
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|inqbuf
operator|.
name|type
operator|!=
literal|8
operator|||
name|inqbuf
operator|.
name|qual
operator|!=
literal|0x80
operator|||
name|inqbuf
operator|.
name|version
operator|!=
literal|2
condition|)
goto|goto
name|failed
goto|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|inqbuf
operator|.
name|vendor_id
argument_list|,
operator|(
name|caddr_t
operator|)
name|idstr
argument_list|,
literal|28
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|27
init|;
name|i
operator|>
literal|23
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|idstr
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
break|break;
name|idstr
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|23
init|;
name|i
operator|>
literal|7
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|idstr
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
break|break;
name|idstr
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|idstr
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
break|break;
name|idstr
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"ac%d: %s %s rev %s\n"
argument_list|,
name|hd
operator|->
name|hp_unit
argument_list|,
operator|&
name|idstr
index|[
literal|0
index|]
argument_list|,
operator|&
name|idstr
index|[
literal|8
index|]
argument_list|,
operator|&
name|idstr
index|[
literal|24
index|]
argument_list|)
expr_stmt|;
name|scsi_delay
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|inqbuf
operator|.
name|type
operator|)
return|;
name|failed
label|:
name|scsi_delay
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|acopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|mode
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|ac_softc
modifier|*
name|sc
init|=
operator|&
name|ac_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NAC
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|ACF_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|ACF_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* 	 * Since acgeteinfo can block we mark the changer open now. 	 */
name|sc
operator|->
name|sc_flags
operator||=
name|ACF_OPEN
expr_stmt|;
if|if
condition|(
name|acgeteinfo
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ACF_OPEN
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|acclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|mode
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ac_softc
modifier|*
name|sc
init|=
operator|&
name|ac_softc
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ACF_OPEN
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|ACRESLEN
parameter_list|(
name|ep
parameter_list|)
define|\
value|(8 + (ep)->nmte*12 + (ep)->nse*12 + (ep)->niee*12 + (ep)->ndte*20)
end_define

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|acioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ac_softc
modifier|*
name|sc
init|=
operator|&
name|ac_softc
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
name|int
name|dlen
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* perform an init element status and mode sense to reset state */
case|case
name|ACIOCINIT
case|:
name|error
operator|=
name|accommand
argument_list|(
name|dev
argument_list|,
name|ACCMD_INITES
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|acgeteinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
comment|/* copy internal element information */
case|case
name|ACIOCGINFO
case|:
operator|*
operator|(
expr|struct
name|acinfo
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_einfo
expr_stmt|;
break|break;
case|case
name|ACIOCRAWES
case|:
block|{
name|struct
name|acbuffer
modifier|*
name|acbp
init|=
operator|(
expr|struct
name|acbuffer
operator|*
operator|)
name|data
decl_stmt|;
name|dlen
operator|=
name|ACRESLEN
argument_list|(
operator|&
name|sc
operator|->
name|sc_einfo
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|dlen
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|accommand
argument_list|(
name|dev
argument_list|,
name|ACCMD_READES
argument_list|,
name|dp
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|dlen
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|dp
index|[
literal|4
index|]
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|dlen
operator|>
name|acbp
operator|->
name|buflen
condition|)
name|dlen
operator|=
name|acbp
operator|->
name|buflen
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|dp
argument_list|,
name|acbp
operator|->
name|bufptr
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|ACIOCGSTAT
case|:
block|{
name|struct
name|acbuffer
modifier|*
name|acbp
init|=
operator|(
expr|struct
name|acbuffer
operator|*
operator|)
name|data
decl_stmt|;
name|dlen
operator|=
name|ACRESLEN
argument_list|(
operator|&
name|sc
operator|->
name|sc_einfo
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|dlen
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|accommand
argument_list|(
name|dev
argument_list|,
name|ACCMD_READES
argument_list|,
name|dp
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|int
name|ne
decl_stmt|;
name|char
modifier|*
name|tbuf
decl_stmt|;
name|ne
operator|=
name|sc
operator|->
name|sc_einfo
operator|.
name|nmte
operator|+
name|sc
operator|->
name|sc_einfo
operator|.
name|nse
operator|+
name|sc
operator|->
name|sc_einfo
operator|.
name|niee
operator|+
name|sc
operator|->
name|sc_einfo
operator|.
name|ndte
expr_stmt|;
name|dlen
operator|=
name|ne
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aceltstat
argument_list|)
expr_stmt|;
name|tbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|dlen
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|acconvert
argument_list|(
name|dp
argument_list|,
name|tbuf
argument_list|,
name|ne
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlen
operator|>
name|acbp
operator|->
name|buflen
condition|)
name|dlen
operator|=
name|acbp
operator|->
name|buflen
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|tbuf
argument_list|,
name|acbp
operator|->
name|bufptr
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tbuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ACIOCMOVE
case|:
name|error
operator|=
name|accommand
argument_list|(
name|dev
argument_list|,
name|ACCMD_MOVEM
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|acmove
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|accommand
argument_list|(
argument|dev
argument_list|,
argument|command
argument_list|,
argument|bufp
argument_list|,
argument|buflen
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|buflen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|ac_softc
modifier|*
name|sc
init|=
operator|&
name|ac_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|sc
operator|->
name|sc_bp
decl_stmt|;
specifier|register
name|struct
name|scsi_fmt_cdb
modifier|*
name|cmd
init|=
name|sc
operator|->
name|sc_cmd
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ac_debug
operator|&
name|ACD_FOLLOW
condition|)
name|printf
argument_list|(
literal|"accommand(dev=%x, cmd=%x, buf=%x, buflen=%x)\n"
argument_list|,
name|dev
argument_list|,
name|command
argument_list|,
name|bufp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|ACF_ACTIVE
condition|)
name|panic
argument_list|(
literal|"accommand: active!"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|ACF_ACTIVE
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|cmd
operator|->
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
operator|->
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
name|command
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|ACCMD_INITES
case|:
name|cmd
operator|->
name|len
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|ACCMD_READES
case|:
name|cmd
operator|->
name|len
operator|=
literal|12
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|4
index|]
operator|=
name|sc
operator|->
name|sc_einfo
operator|.
name|nmte
operator|+
name|sc
operator|->
name|sc_einfo
operator|.
name|nse
operator|+
name|sc
operator|->
name|sc_einfo
operator|.
name|niee
operator|+
name|sc
operator|->
name|sc_einfo
operator|.
name|ndte
expr_stmt|;
name|cmd
operator|->
name|cdb
index|[
literal|7
index|]
operator|=
name|buflen
operator|>>
literal|16
expr_stmt|;
name|cmd
operator|->
name|cdb
index|[
literal|8
index|]
operator|=
name|buflen
operator|>>
literal|8
expr_stmt|;
name|cmd
operator|->
name|cdb
index|[
literal|9
index|]
operator|=
name|buflen
expr_stmt|;
break|break;
case|case
name|ACCMD_MODESENSE
case|:
name|cmd
operator|->
name|len
operator|=
literal|6
expr_stmt|;
name|cmd
operator|->
name|cdb
index|[
literal|2
index|]
operator|=
literal|0x3F
expr_stmt|;
comment|/* all pages */
name|cmd
operator|->
name|cdb
index|[
literal|4
index|]
operator|=
name|buflen
expr_stmt|;
break|break;
case|case
name|ACCMD_MOVEM
case|:
name|cmd
operator|->
name|len
operator|=
literal|12
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|2
index|]
operator|=
name|sc
operator|->
name|sc_picker
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|4
index|]
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|bufp
index|[
literal|0
index|]
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|6
index|]
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|bufp
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|bufp
index|[
literal|4
index|]
operator|&
name|AC_INVERT
condition|)
name|cmd
operator|->
name|cdb
index|[
literal|10
index|]
operator|=
literal|1
expr_stmt|;
name|bufp
operator|=
literal|0
expr_stmt|;
name|buflen
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"accommand: bad command"
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
name|bufp
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|buflen
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scsireq
argument_list|(
operator|&
name|sc
operator|->
name|sc_dq
argument_list|)
condition|)
name|acstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ACF_ACTIVE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|acstart
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ac_debug
operator|&
name|ACD_FOLLOW
condition|)
name|printf
argument_list|(
literal|"acstart(unit=%x)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scsiustart
argument_list|(
name|ac_softc
index|[
name|unit
index|]
operator|.
name|sc_hd
operator|->
name|hp_ctlr
argument_list|)
condition|)
name|acgo
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|acgo
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ac_softc
modifier|*
name|sc
init|=
operator|&
name|ac_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|sc
operator|->
name|sc_bp
decl_stmt|;
name|struct
name|hp_device
modifier|*
name|hp
init|=
name|sc
operator|->
name|sc_hd
decl_stmt|;
name|int
name|stat
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ac_debug
operator|&
name|ACD_FOLLOW
condition|)
name|printf
argument_list|(
literal|"acgo(unit=%x): "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stat
operator|=
name|scsigo
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|sc
operator|->
name|sc_punit
argument_list|,
name|bp
argument_list|,
name|sc
operator|->
name|sc_cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ac_debug
operator|&
name|ACD_FOLLOW
condition|)
name|printf
argument_list|(
literal|"scsigo returns %x\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stat
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
operator|(
name|void
operator|)
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|scsifree
argument_list|(
operator|&
name|sc
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|acintr
argument_list|(
argument|unit
argument_list|,
argument|stat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|stat
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ac_softc
modifier|*
name|sc
init|=
operator|&
name|ac_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|sc
operator|->
name|sc_bp
decl_stmt|;
name|u_char
name|sensebuf
index|[
literal|78
index|]
decl_stmt|;
name|struct
name|scsi_xsense
modifier|*
name|sp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ac_debug
operator|&
name|ACD_FOLLOW
condition|)
name|printf
argument_list|(
literal|"acintr(unit=%x, stat=%x)\n"
argument_list|,
name|unit
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|stat
condition|)
block|{
case|case
literal|0
case|:
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|STS_CHECKCOND
case|:
name|scsi_request_sense
argument_list|(
name|sc
operator|->
name|sc_hd
operator|->
name|hp_ctlr
argument_list|,
name|sc
operator|->
name|sc_hd
operator|->
name|hp_slave
argument_list|,
name|sc
operator|->
name|sc_punit
argument_list|,
name|sensebuf
argument_list|,
sizeof|sizeof
name|sensebuf
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|scsi_xsense
operator|*
operator|)
name|sensebuf
expr_stmt|;
name|printf
argument_list|(
literal|"ac%d: acintr sense key=%x, ac=%x, acq=%x\n"
argument_list|,
name|unit
argument_list|,
name|sp
operator|->
name|key
argument_list|,
name|sp
operator|->
name|info4
argument_list|,
name|sp
operator|->
name|len
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ac%d: acintr unknown status 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|biodone
argument_list|(
name|sc
operator|->
name|sc_bp
argument_list|)
expr_stmt|;
name|scsifree
argument_list|(
operator|&
name|sc
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|acgeteinfo
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ac_softc
modifier|*
name|sc
init|=
operator|&
name|ac_softc
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|msbuf
index|[
literal|48
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bzero
argument_list|(
name|msbuf
argument_list|,
sizeof|sizeof
name|msbuf
argument_list|)
expr_stmt|;
name|error
operator|=
name|accommand
argument_list|(
name|dev
argument_list|,
name|ACCMD_MODESENSE
argument_list|,
name|msbuf
argument_list|,
sizeof|sizeof
name|msbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bp
operator|=
operator|&
name|msbuf
index|[
literal|4
index|]
expr_stmt|;
while|while
condition|(
name|bp
operator|<
operator|&
name|msbuf
index|[
literal|48
index|]
condition|)
block|{
switch|switch
condition|(
name|bp
index|[
literal|0
index|]
operator|&
literal|0x3F
condition|)
block|{
case|case
literal|0x1D
case|:
name|sc
operator|->
name|sc_einfo
operator|=
operator|*
operator|(
expr|struct
name|acinfo
operator|*
operator|)
operator|&
name|bp
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|sc_picker
operator|=
name|sc
operator|->
name|sc_einfo
operator|.
name|fmte
expr_stmt|;
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1E
case|:
name|bp
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|0x1F
case|:
name|bp
operator|+=
literal|20
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"acgeteinfo: bad page type %x\n"
argument_list|,
name|bp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_block

begin_macro
name|acconvert
argument_list|(
argument|sbuf
argument_list|,
argument|dbuf
argument_list|,
argument|ne
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sbuf
decl_stmt|,
modifier|*
name|dbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ne
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|aceltstat
modifier|*
name|ep
init|=
operator|(
expr|struct
name|aceltstat
operator|*
operator|)
name|dbuf
decl_stmt|;
specifier|register
name|struct
name|ac_restatphdr
modifier|*
name|phdr
decl_stmt|;
specifier|register
name|struct
name|ac_restatdb
modifier|*
name|dbp
decl_stmt|;
name|struct
name|ac_restathdr
modifier|*
name|hdr
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
specifier|register
name|int
name|bcount
decl_stmt|;
endif|#
directive|endif
name|hdr
operator|=
operator|(
expr|struct
name|ac_restathdr
operator|*
operator|)
operator|&
name|sbuf
index|[
literal|0
index|]
expr_stmt|;
name|sbuf
operator|+=
sizeof|sizeof
expr|*
name|hdr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ac_debug
operator|&
name|ACD_FOLLOW
condition|)
name|printf
argument_list|(
literal|"element status: first=%d, num=%d, len=%d\n"
argument_list|,
name|hdr
operator|->
name|ac_felt
argument_list|,
name|hdr
operator|->
name|ac_nelt
argument_list|,
name|hdr
operator|->
name|ac_bcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|ac_nelt
operator|!=
name|ne
condition|)
block|{
name|printf
argument_list|(
literal|"acconvert: # of elements, %d != %d\n"
argument_list|,
name|hdr
operator|->
name|ac_nelt
argument_list|,
name|ne
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|ac_nelt
operator|<
name|ne
condition|)
name|ne
operator|=
name|hdr
operator|->
name|ac_nelt
expr_stmt|;
block|}
name|bcount
operator|=
name|hdr
operator|->
name|ac_bcount
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|ne
condition|)
block|{
name|phdr
operator|=
operator|(
expr|struct
name|ac_restatphdr
operator|*
operator|)
name|sbuf
expr_stmt|;
name|sbuf
operator|+=
sizeof|sizeof
expr|*
name|phdr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|bcount
operator|-=
sizeof|sizeof
expr|*
name|phdr
expr_stmt|;
endif|#
directive|endif
name|dbp
operator|=
operator|(
expr|struct
name|ac_restatdb
operator|*
operator|)
name|sbuf
expr_stmt|;
name|sbuf
operator|+=
name|phdr
operator|->
name|ac_bcount
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|bcount
operator|-=
name|phdr
operator|->
name|ac_bcount
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|dbp
operator|<
operator|(
expr|struct
name|ac_restatdb
operator|*
operator|)
name|sbuf
condition|)
block|{
name|ep
operator|->
name|type
operator|=
name|phdr
operator|->
name|ac_type
expr_stmt|;
name|ep
operator|->
name|eaddr
operator|=
name|dbp
operator|->
name|ac_eaddr
expr_stmt|;
name|ep
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dbp
operator|->
name|ac_full
condition|)
name|ep
operator|->
name|flags
operator||=
name|AC_FULL
expr_stmt|;
if|if
condition|(
name|dbp
operator|->
name|ac_exc
condition|)
name|ep
operator|->
name|flags
operator||=
name|AC_ERROR
expr_stmt|;
if|if
condition|(
name|dbp
operator|->
name|ac_acc
condition|)
name|ep
operator|->
name|flags
operator||=
name|AC_ACCESS
expr_stmt|;
name|dbp
operator|=
operator|(
expr|struct
name|ac_restatdb
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dbp
operator|+
name|phdr
operator|->
name|ac_dlen
operator|)
expr_stmt|;
name|ep
operator|++
expr_stmt|;
name|ne
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ne
operator|<
literal|0
operator|||
name|bcount
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"acconvert: inconsistant"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

