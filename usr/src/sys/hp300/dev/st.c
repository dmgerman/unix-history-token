begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990 University of Utah.  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: st.c 1.11 92/01/21$  *  *      @(#)st.c	8.5 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * SCSI CCS (Command Command Set) tape driver.  *  * Specific to Exabyte:  * mt status: residual="Mbytes to LEOM"  * minor bit 4 [b1bbbb] (aka /dev/rst16) selects short filemarks  * minor bit 5 [1bbbbb] (aka /dev/rst32) selects fix block mode, 1k blocks.  *  * Archive drive:  * can read both QIC-24 and QIC-II. But only writes  * QIC-24.  *   * Supports Archive Viper QIC-150 tape drive, but scsi.c reports selection  * errors.  *  * Supports Archive Python DAT drive, but will sometimes hang machine.  *  * Supports HP 35450A DAT drive, but will sometimes hang machine.  * Partitioning of tape not supported.  * Vendor unique support has not been added.  *  *  * Supports Archive VIPER (QIC-150).  * Mostly Supports Archive PYTHON (DAT).   *     Hangs if write after spin down.   *     Need scsi.c that does connect/disconnect.  */
end_comment

begin_comment
comment|/*  * support for the block device not implemented   */
end_comment

begin_include
include|#
directive|include
file|"st.h"
end_include

begin_if
if|#
directive|if
name|NST
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/tprintf.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/scsireg.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/stvar.h>
end_include

begin_function_decl
specifier|extern
name|int
name|scsi_test_unit_rdy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|scsi_request_sense
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|scsiustart
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|scsigo
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|scsifree
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|scsireset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|scsi_delay
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|scsi_tt_oddio
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|scsi_immed_command
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|stinit
argument_list|()
decl_stmt|,
name|ststart
argument_list|()
decl_stmt|,
name|stgo
argument_list|()
decl_stmt|,
name|stintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|driver
name|stdriver
init|=
block|{
name|stinit
block|,
literal|"st"
block|,
name|ststart
block|,
name|stgo
block|,
name|stintr
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|st_softc
block|{
name|struct
name|hp_device
modifier|*
name|sc_hd
decl_stmt|;
name|struct
name|devqueue
name|sc_dq
decl_stmt|;
name|long
name|sc_blkno
decl_stmt|;
comment|/* (possible block device support?) */
name|long
name|sc_resid
decl_stmt|;
comment|/* (possible block device support?) */
name|int
name|sc_flags
decl_stmt|;
name|int
name|sc_blklen
decl_stmt|;
comment|/* 0 = variable len records */
name|int
name|sc_filepos
decl_stmt|;
comment|/* file position on tape */
name|long
name|sc_numblks
decl_stmt|;
comment|/* number of blocks on tape */
name|short
name|sc_type
decl_stmt|;
comment|/* ansi scsi type */
name|short
name|sc_punit
decl_stmt|;
comment|/* physical unit (scsi lun) */
name|short
name|sc_tapeid
decl_stmt|;
comment|/* tape drive id */
name|char
name|sc_datalen
index|[
literal|32
index|]
decl_stmt|;
comment|/* additional data length on some commands */
name|short
name|sc_tticntdwn
decl_stmt|;
comment|/* interrupts between TTi display updates */
name|tpr_t
name|sc_ctty
decl_stmt|;
name|struct
name|buf
modifier|*
name|sc_bp
decl_stmt|;
name|u_char
name|sc_cmd
decl_stmt|;
block|}
name|st_softc
index|[
name|NST
index|]
struct|;
end_struct

begin_comment
comment|/* softc flags */
end_comment

begin_define
define|#
directive|define
name|STF_ALIVE
value|0x0001
end_define

begin_define
define|#
directive|define
name|STF_OPEN
value|0x0002
end_define

begin_define
define|#
directive|define
name|STF_WMODE
value|0x0004
end_define

begin_define
define|#
directive|define
name|STF_WRTTN
value|0x0008
end_define

begin_define
define|#
directive|define
name|STF_CMD
value|0x0010
end_define

begin_define
define|#
directive|define
name|STF_LEOT
value|0x0020
end_define

begin_define
define|#
directive|define
name|STF_MOVED
value|0x0040
end_define

begin_decl_stmt
name|struct
name|st_mode
name|st_mode
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Maybe this should not be global, but gives chance to get  * tape remaining, Rewrites/ECC, etc outside the driver   */
end_comment

begin_struct
specifier|static
struct|struct
name|st_xsense
block|{
name|struct
name|scsi_xsense
name|sc_xsense
decl_stmt|;
comment|/* data from sense */
name|struct
name|exb_xsense
name|exb_xsense
decl_stmt|;
comment|/* additional info from exabyte */
block|}
name|st_xsense
index|[
name|NST
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|scsi_fmt_cdb
name|stcmd
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_fmt_cdb
name|st_read_cmd
init|=
block|{
literal|6
block|,
name|CMD_READ
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_fmt_cdb
name|st_write_cmd
init|=
block|{
literal|6
block|,
name|CMD_WRITE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|sttab
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|stbuf
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|(minor(x)& 3)
end_define

begin_define
define|#
directive|define
name|stpunit
parameter_list|(
name|x
parameter_list|)
value|((x)& 7)
end_define

begin_define
define|#
directive|define
name|STDEV_NOREWIND
value|0x04
end_define

begin_define
define|#
directive|define
name|STDEV_HIDENSITY
value|0x08
end_define

begin_define
define|#
directive|define
name|STDEV_EXSFMK
value|0x10
end_define

begin_define
define|#
directive|define
name|STDEV_FIXEDBLK
value|0x20
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|st_debug
init|=
literal|0x0000
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ST_OPEN
value|0x0001
end_define

begin_define
define|#
directive|define
name|ST_GO
value|0x0002
end_define

begin_define
define|#
directive|define
name|ST_FMKS
value|0x0004
end_define

begin_define
define|#
directive|define
name|ST_OPENSTAT
value|0x0008
end_define

begin_define
define|#
directive|define
name|ST_BRESID
value|0x0010
end_define

begin_define
define|#
directive|define
name|ST_ODDIO
value|0x0020
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Patchable variable.  If an even length read is requested a dma transfer is  * used.  Only after the read will we find out if the read had an odd number  * of bytes.  The HP98658 hardware cannot do odd length transfers, the last  * byte of the data will always be 0x00.  Normally, the driver will complain  * about such transfers and return EIO.  However, if st_dmaoddretry is non-  * zero, the driver will try and issue a BSR and then re-read the data using  * 'programmed transfer mode'.  In most cases this works, however for unknown  * reasons it will hang the machine in certain cases.  *  * Note:  * Odd length read requests are always done using programmed transfer mode.  */
end_comment

begin_decl_stmt
name|int
name|st_dmaoddretry
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Exabyte only:  * From adb can have access to fixed vs. variable length modes.  * Use 0x400 for 1k (best capacity) fixed length records.  * In st_open, if minor bit 4 set then 1k records are used.  * If st_exblken is set to anything other then 0 we are in fixed length mode.  * Minor bit 5 requests 1K fixed-length, overriding any setting of st_exblklen.  */
end_comment

begin_decl_stmt
name|int
name|st_exblklen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exabyte here for adb access, set at open time */
end_comment

begin_define
define|#
directive|define
name|EX_CT
value|0x80
end_define

begin_comment
comment|/* international cart - more space W/P6  */
end_comment

begin_define
define|#
directive|define
name|EX_ND
value|0x20
end_define

begin_comment
comment|/* no disconnect  */
end_comment

begin_define
define|#
directive|define
name|EX_NBE
value|0x08
end_define

begin_comment
comment|/* no busy enable  */
end_comment

begin_define
define|#
directive|define
name|EX_EBD
value|0x04
end_define

begin_comment
comment|/* even byte disconnect  */
end_comment

begin_define
define|#
directive|define
name|EX_PE
value|0x02
end_define

begin_comment
comment|/* parity enable  */
end_comment

begin_define
define|#
directive|define
name|EX_NAL
value|0x01
end_define

begin_comment
comment|/* no auto load  */
end_comment

begin_decl_stmt
name|int
name|st_exvup
init|=
operator|(
name|EX_CT
operator||
name|EX_ND
operator||
name|EX_NBE
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* vendor unique parameters */
end_comment

begin_comment
comment|/*  * motion and reconnect thresholds guidelines:  * write operation; lower motion threshold for faster transfer  *                  raise reconnect threshold for slower transfer  * read operation; lower motion threshold for slower transfer  *                 raise reconnect threshold for faster transfer  */
end_comment

begin_decl_stmt
name|int
name|st_exmotthr
init|=
literal|0x80
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* motion threshold, 0x80 default */
end_comment

begin_decl_stmt
name|int
name|st_exreconthr
init|=
literal|0xa0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reconnect threshold, 0xa0 default */
end_comment

begin_decl_stmt
name|int
name|st_exgapthr
init|=
literal|7
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gap threshold, 7 default */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TTI
end_ifdef

begin_decl_stmt
name|int
name|st_extti
init|=
literal|0x01
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bitmask of unit numbers, do extra */
end_comment

begin_comment
comment|/* sensing so TTi display gets updated */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|stinit
argument_list|(
name|hd
argument_list|)
specifier|register
expr|struct
name|hp_device
operator|*
name|hd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|hd
operator|->
name|hp_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|sttab
init|;
name|bp
operator|<
operator|&
name|sttab
index|[
name|NST
index|]
condition|;
name|bp
operator|++
control|)
name|bp
operator|->
name|b_actb
operator|=
operator|&
name|bp
operator|->
name|b_actf
expr_stmt|;
name|sc
operator|->
name|sc_hd
operator|=
name|hd
expr_stmt|;
name|sc
operator|->
name|sc_punit
operator|=
name|stpunit
argument_list|(
name|hd
operator|->
name|hp_flags
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_type
operator|=
name|stident
argument_list|(
name|sc
argument_list|,
name|hd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_type
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_ctlr
operator|=
name|hd
operator|->
name|hp_ctlr
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_unit
operator|=
name|hd
operator|->
name|hp_unit
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_slave
operator|=
name|hd
operator|->
name|hp_slave
expr_stmt|;
name|sc
operator|->
name|sc_dq
operator|.
name|dq_driver
operator|=
operator|&
name|stdriver
expr_stmt|;
name|sc
operator|->
name|sc_blkno
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|STF_ALIVE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|stident
argument_list|(
name|sc
argument_list|,
name|hd
argument_list|)
specifier|register
expr|struct
name|st_softc
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hp_device
modifier|*
name|hd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
decl_stmt|;
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|;
name|int
name|i
decl_stmt|,
name|stat
decl_stmt|,
name|inqlen
decl_stmt|;
name|char
name|idstr
index|[
literal|32
index|]
decl_stmt|;
specifier|static
name|int
name|havest
init|=
literal|0
decl_stmt|;
struct|struct
name|st_inquiry
block|{
name|struct
name|scsi_inquiry
name|inqbuf
decl_stmt|;
name|struct
name|exb_inquiry
name|exb_inquiry
decl_stmt|;
block|}
name|st_inqbuf
struct|;
specifier|static
name|struct
name|scsi_fmt_cdb
name|st_inq
init|=
block|{
literal|6
block|,
name|CMD_INQUIRY
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|st_inqbuf
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|ctlr
operator|=
name|hd
operator|->
name|hp_ctlr
expr_stmt|;
name|slave
operator|=
name|hd
operator|->
name|hp_slave
expr_stmt|;
name|unit
operator|=
name|sc
operator|->
name|sc_punit
expr_stmt|;
name|scsi_delay
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|inqlen
operator|=
literal|0x05
expr_stmt|;
comment|/* min */
name|st_inq
operator|.
name|cdb
index|[
literal|4
index|]
operator|=
literal|0x05
expr_stmt|;
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
operator|&
name|st_inq
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|st_inqbuf
argument_list|,
name|inqlen
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
comment|/* do twice as first command on some scsi tapes always fails */
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
operator|&
name|st_inq
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|st_inqbuf
argument_list|,
name|inqlen
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
operator|-
literal|1
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
operator|(
name|st_inqbuf
operator|.
name|inqbuf
operator|.
name|type
operator|!=
literal|0x01
operator|||
comment|/* sequential access device */
name|st_inqbuf
operator|.
name|inqbuf
operator|.
name|qual
operator|!=
literal|0x80
operator|||
comment|/* removable media */
operator|(
name|st_inqbuf
operator|.
name|inqbuf
operator|.
name|version
operator|!=
literal|0x01
operator|&&
comment|/* current ANSI SCSI spec */
name|st_inqbuf
operator|.
name|inqbuf
operator|.
name|version
operator|!=
literal|0x02
operator|)
operator|)
comment|/* 0x02 is for HP DAT */
operator|&&
operator|(
name|st_inqbuf
operator|.
name|inqbuf
operator|.
name|type
operator|!=
literal|0x01
operator|||
comment|/* M4 ??! */
comment|/* 	      * the M4 is a little too smart (ass?) for its own good: 	      * qual codes: 	      * 0x80: you can take the tape out (unit not online) 	      * 0xf8: online and at 6250bpi 	      * 0xf9: online and at 1600bpi 	      */
name|st_inqbuf
operator|.
name|inqbuf
operator|.
name|version
operator|!=
literal|0x09
operator|)
condition|)
comment|/* M4 tape */
block|{
name|printf
argument_list|(
literal|"st: wrong specs: type %x qual %x version %d\n"
argument_list|,
name|st_inqbuf
operator|.
name|inqbuf
operator|.
name|type
argument_list|,
name|st_inqbuf
operator|.
name|inqbuf
operator|.
name|qual
argument_list|,
name|st_inqbuf
operator|.
name|inqbuf
operator|.
name|version
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* now get additonal info */
name|inqlen
operator|=
literal|0x05
operator|+
name|st_inqbuf
operator|.
name|inqbuf
operator|.
name|len
expr_stmt|;
name|st_inq
operator|.
name|cdb
index|[
literal|4
index|]
operator|=
name|inqlen
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|st_inqbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|st_inqbuf
argument_list|)
argument_list|)
expr_stmt|;
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
operator|&
name|st_inq
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|st_inqbuf
argument_list|,
name|inqlen
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_inqbuf
operator|.
name|inqbuf
operator|.
name|len
operator|>=
literal|28
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|st_inqbuf
operator|.
name|inqbuf
operator|.
name|vendor_id
argument_list|,
operator|(
name|caddr_t
operator|)
name|idstr
argument_list|,
literal|28
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|27
init|;
name|i
operator|>
literal|23
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|idstr
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
break|break;
name|idstr
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|23
init|;
name|i
operator|>
literal|7
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|idstr
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
break|break;
name|idstr
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|idstr
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
break|break;
name|idstr
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"st%d: %s, %s rev %s\n"
argument_list|,
name|hd
operator|->
name|hp_unit
argument_list|,
name|idstr
argument_list|,
operator|&
name|idstr
index|[
literal|8
index|]
argument_list|,
operator|&
name|idstr
index|[
literal|24
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inqlen
operator|==
literal|5
condition|)
comment|/* great it's a stupid device, doesn't know it's know name */
name|idstr
index|[
literal|0
index|]
operator|=
name|idstr
index|[
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|idstr
index|[
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: Cant handle this tape drive\n"
argument_list|,
name|hd
operator|->
name|hp_unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
literal|"EXB-8200"
argument_list|,
operator|&
name|idstr
index|[
literal|8
index|]
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_tapeid
operator|=
name|MT_ISEXABYTE
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_REQUEST_SENSE
index|]
operator|=
literal|26
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_INQUIRY
index|]
operator|=
literal|52
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SELECT
index|]
operator|=
literal|17
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SENSE
index|]
operator|=
literal|17
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
literal|"VIPER 150"
argument_list|,
operator|&
name|idstr
index|[
literal|8
index|]
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_tapeid
operator|=
name|MT_ISVIPER1
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_REQUEST_SENSE
index|]
operator|=
literal|14
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_INQUIRY
index|]
operator|=
literal|36
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SELECT
index|]
operator|=
literal|12
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SENSE
index|]
operator|=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
literal|"Python 25501"
argument_list|,
operator|&
name|idstr
index|[
literal|8
index|]
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_tapeid
operator|=
name|MT_ISPYTHON
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_REQUEST_SENSE
index|]
operator|=
literal|14
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_INQUIRY
index|]
operator|=
literal|36
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SELECT
index|]
operator|=
literal|12
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SENSE
index|]
operator|=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
literal|"HP35450A"
argument_list|,
operator|&
name|idstr
index|[
literal|8
index|]
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX "extra" stat makes the HP drive happy at boot time */
name|stat
operator|=
name|scsi_test_unit_rdy
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tapeid
operator|=
name|MT_ISHPDAT
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_REQUEST_SENSE
index|]
operator|=
literal|14
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_INQUIRY
index|]
operator|=
literal|36
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SELECT
index|]
operator|=
literal|12
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SENSE
index|]
operator|=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
literal|"123107 SCSI"
argument_list|,
operator|&
name|idstr
index|[
literal|8
index|]
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
operator|||
name|bcmp
argument_list|(
literal|"OPEN REEL TAPE"
argument_list|,
operator|&
name|idstr
index|[
literal|8
index|]
argument_list|,
literal|14
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_tapeid
operator|=
name|MT_ISMFOUR
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_REQUEST_SENSE
index|]
operator|=
literal|8
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_INQUIRY
index|]
operator|=
literal|5
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SELECT
index|]
operator|=
literal|12
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SENSE
index|]
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|idstr
index|[
literal|8
index|]
operator|==
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"st%d: No ID, assuming Archive\n"
argument_list|,
name|hd
operator|->
name|hp_unit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"st%d: Unsupported tape device\n"
argument_list|,
name|hd
operator|->
name|hp_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tapeid
operator|=
name|MT_ISAR
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_REQUEST_SENSE
index|]
operator|=
literal|8
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_INQUIRY
index|]
operator|=
literal|5
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SELECT
index|]
operator|=
literal|12
expr_stmt|;
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SENSE
index|]
operator|=
literal|12
expr_stmt|;
block|}
name|sc
operator|->
name|sc_filepos
operator|=
literal|0
expr_stmt|;
comment|/* load xsense */
name|stxsense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|scsi_delay
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX if we have a tape, we must up the delays in the HA driver */
if|if
condition|(
operator|!
name|havest
condition|)
block|{
name|havest
operator|=
literal|1
expr_stmt|;
name|scsi_delay
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|st_inqbuf
operator|.
name|inqbuf
operator|.
name|type
operator|)
return|;
name|failed
label|:
name|scsi_delay
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|stopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|type
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|st_xsense
modifier|*
name|xsense
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|stat
decl_stmt|;
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|unit
decl_stmt|;
name|struct
name|mode_select_data
name|msd
decl_stmt|;
name|struct
name|mode_sense
name|mode
decl_stmt|;
name|int
name|modlen
decl_stmt|;
name|int
name|error
decl_stmt|;
specifier|static
name|struct
name|scsi_fmt_cdb
name|modsel
init|=
block|{
literal|6
block|,
name|CMD_MODE_SELECT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|msd
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|struct
name|scsi_fmt_cdb
name|modsense
init|=
block|{
literal|6
block|,
name|CMD_MODE_SENSE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|mode
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|ctlr
operator|=
name|sc
operator|->
name|sc_dq
operator|.
name|dq_ctlr
expr_stmt|;
name|slave
operator|=
name|sc
operator|->
name|sc_dq
operator|.
name|dq_slave
expr_stmt|;
name|unit
operator|=
name|sc
operator|->
name|sc_punit
expr_stmt|;
name|xsense
operator|=
operator|&
name|st_xsense
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|UNIT
argument_list|(
name|dev
argument_list|)
operator|>
name|NST
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|STF_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|STF_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* 	 * Be prepared to print error messages 	 */
name|sc
operator|->
name|sc_ctty
operator|=
name|tprintf_open
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* do a mode sense to get current */
name|modlen
operator|=
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SENSE
index|]
expr_stmt|;
name|modsense
operator|.
name|cdb
index|[
literal|4
index|]
operator|=
name|modlen
expr_stmt|;
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
operator|&
name|modsense
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mode
argument_list|,
name|modlen
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
comment|/* do a mode sense to get current */
name|modlen
operator|=
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SENSE
index|]
expr_stmt|;
name|modsense
operator|.
name|cdb
index|[
literal|4
index|]
operator|=
name|modlen
expr_stmt|;
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
operator|&
name|modsense
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mode
argument_list|,
name|modlen
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
comment|/* set record length */
switch|switch
condition|(
name|sc
operator|->
name|sc_tapeid
condition|)
block|{
case|case
name|MT_ISAR
case|:
name|sc
operator|->
name|sc_blklen
operator|=
literal|512
expr_stmt|;
break|break;
case|case
name|MT_ISEXABYTE
case|:
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|STDEV_FIXEDBLK
condition|)
name|sc
operator|->
name|sc_blklen
operator|=
literal|0x400
expr_stmt|;
else|else
name|sc
operator|->
name|sc_blklen
operator|=
name|st_exblklen
expr_stmt|;
break|break;
case|case
name|MT_ISHPDAT
case|:
name|sc
operator|->
name|sc_blklen
operator|=
literal|512
expr_stmt|;
break|break;
case|case
name|MT_ISVIPER1
case|:
name|sc
operator|->
name|sc_blklen
operator|=
literal|512
expr_stmt|;
break|break;
case|case
name|MT_ISPYTHON
case|:
name|sc
operator|->
name|sc_blklen
operator|=
literal|512
expr_stmt|;
break|break;
case|case
name|MT_ISMFOUR
case|:
name|sc
operator|->
name|sc_blklen
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|mode
operator|.
name|md
operator|.
name|blklen2
operator|<<
literal|16
operator||
name|mode
operator|.
name|md
operator|.
name|blklen1
operator|<<
literal|8
operator||
name|mode
operator|.
name|md
operator|.
name|blklen0
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_blklen
operator|=
name|mode
operator|.
name|md
operator|.
name|blklen2
operator|<<
literal|16
operator||
name|mode
operator|.
name|md
operator|.
name|blklen1
operator|<<
literal|8
operator||
name|mode
operator|.
name|md
operator|.
name|blklen0
expr_stmt|;
else|else
name|sc
operator|->
name|sc_blklen
operator|=
literal|512
expr_stmt|;
block|}
comment|/* setup for mode select */
name|msd
operator|.
name|rsvd1
operator|=
literal|0
expr_stmt|;
name|msd
operator|.
name|rsvd2
operator|=
literal|0
expr_stmt|;
name|msd
operator|.
name|rsvd3
operator|=
literal|0
expr_stmt|;
name|msd
operator|.
name|buff
operator|=
literal|1
expr_stmt|;
name|msd
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
name|msd
operator|.
name|blkdeslen
operator|=
literal|0x08
expr_stmt|;
name|msd
operator|.
name|density
operator|=
literal|0
expr_stmt|;
name|msd
operator|.
name|blks2
operator|=
literal|0
expr_stmt|;
name|msd
operator|.
name|blks1
operator|=
literal|0
expr_stmt|;
name|msd
operator|.
name|blks0
operator|=
literal|0
expr_stmt|;
name|msd
operator|.
name|rsvd4
operator|=
literal|0
expr_stmt|;
name|msd
operator|.
name|blklen2
operator|=
operator|(
name|sc
operator|->
name|sc_blklen
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|msd
operator|.
name|blklen1
operator|=
operator|(
name|sc
operator|->
name|sc_blklen
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|msd
operator|.
name|blklen0
operator|=
name|sc
operator|->
name|sc_blklen
operator|&
literal|0xff
expr_stmt|;
comment|/* 	 * Do we have any density problems? 	 */
switch|switch
condition|(
name|sc
operator|->
name|sc_tapeid
condition|)
block|{
case|case
name|MT_ISAR
case|:
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|STDEV_HIDENSITY
condition|)
name|msd
operator|.
name|density
operator|=
literal|0x5
expr_stmt|;
else|else
block|{
if|if
condition|(
name|flag
operator|&
name|FWRITE
condition|)
block|{
name|uprintf
argument_list|(
literal|"Can only write QIC-24\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|msd
operator|.
name|density
operator|=
literal|0x4
expr_stmt|;
block|}
break|break;
case|case
name|MT_ISEXABYTE
case|:
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|STDEV_HIDENSITY
condition|)
name|uprintf
argument_list|(
literal|"EXB-8200 density support only\n"
argument_list|)
expr_stmt|;
name|msd
operator|.
name|vupb
operator|=
operator|(
name|u_char
operator|)
name|st_exvup
expr_stmt|;
name|msd
operator|.
name|rsvd5
operator|=
literal|0
expr_stmt|;
name|msd
operator|.
name|p5
operator|=
literal|0
expr_stmt|;
name|msd
operator|.
name|motionthres
operator|=
operator|(
name|u_char
operator|)
name|st_exmotthr
expr_stmt|;
name|msd
operator|.
name|reconthres
operator|=
operator|(
name|u_char
operator|)
name|st_exreconthr
expr_stmt|;
name|msd
operator|.
name|gapthres
operator|=
operator|(
name|u_char
operator|)
name|st_exgapthr
expr_stmt|;
break|break;
case|case
name|MT_ISHPDAT
case|:
case|case
name|MT_ISVIPER1
case|:
case|case
name|MT_ISPYTHON
case|:
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|STDEV_HIDENSITY
condition|)
name|uprintf
argument_list|(
literal|"Only one density supported\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MT_ISMFOUR
case|:
break|break;
comment|/* XXX could do density select? */
default|default:
name|uprintf
argument_list|(
literal|"Unsupported drive\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|modlen
operator|=
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SELECT
index|]
expr_stmt|;
name|modsel
operator|.
name|cdb
index|[
literal|4
index|]
operator|=
name|modlen
expr_stmt|;
comment|/* mode select */
name|count
operator|=
literal|0
expr_stmt|;
name|retryselect
label|:
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
operator|&
name|modsel
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|msd
argument_list|,
name|modlen
argument_list|,
name|B_WRITE
argument_list|)
expr_stmt|;
comment|/* 	 * First command after power cycle, bus reset or tape change  	 * will error. Try command again 	 */
if|if
condition|(
name|stat
operator|==
name|STS_CHECKCOND
condition|)
block|{
name|sc
operator|->
name|sc_filepos
operator|=
literal|0
expr_stmt|;
name|stxsense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
operator|&
name|modsel
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|msd
argument_list|,
name|modlen
argument_list|,
name|B_WRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|stat
operator|&&
operator|(
name|st_debug
operator|&
name|ST_OPEN
operator|)
condition|)
name|printf
argument_list|(
literal|"stopen: stat on mode select 0x%x second try\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stat
operator|==
name|STS_CHECKCOND
condition|)
block|{
name|stxsense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|prtkey
argument_list|(
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|stat
operator|==
operator|-
literal|1
operator|||
name|stat
operator|==
name|STS_BUSY
condition|)
block|{
comment|/* 		 * XXX it might just be that the bus is busy because 		 * another tape is doing a command. This would change 		 * with connect/disconnect, ie. the other drive would 		 * not hold onto the bus. 		 * 		 * Sleep on lbolt for up to 20 minutes (max time to FSF 		 * an exabyte to EOT: 16:xx minutes) 		 */
if|if
condition|(
operator|++
name|count
operator|>
literal|60
operator|*
literal|20
condition|)
block|{
name|uprintf
argument_list|(
literal|"SCSI bus timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"st_scsiwait"
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
goto|goto
name|retryselect
goto|;
block|}
comment|/* drive ready ? */
name|stat
operator|=
name|scsi_test_unit_rdy
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|STS_CHECKCOND
condition|)
block|{
name|stxsense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_tapeid
condition|)
block|{
case|case
name|MT_ISEXABYTE
case|:
if|if
condition|(
operator|(
name|xsense
operator|->
name|sc_xsense
operator|.
name|key
operator|&
name|XSK_NOTRDY
operator|)
operator|&&
name|xsense
operator|->
name|exb_xsense
operator|.
name|tnp
condition|)
name|uprintf
argument_list|(
literal|"no cartridge\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xsense
operator|->
name|sc_xsense
operator|.
name|key
operator|&
name|XSK_NOTRDY
condition|)
name|uprintf
argument_list|(
literal|"cartridge not loaded\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xsense
operator|->
name|sc_xsense
operator|.
name|key
operator|&
name|XSK_UNTATTEN
condition|)
block|{
name|uprintf
argument_list|(
literal|"new cart/power interrupt\n"
argument_list|)
expr_stmt|;
name|stat
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|xsense
operator|->
name|sc_xsense
operator|.
name|key
operator|&
name|XSK_UNTATTEN
operator|)
operator|&&
name|xsense
operator|->
name|exb_xsense
operator|.
name|tnp
condition|)
name|uprintf
argument_list|(
literal|"cartridge unloading\n"
argument_list|)
expr_stmt|;
else|else
name|prtkey
argument_list|(
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MT_ISMFOUR
case|:
case|case
name|MT_ISAR
case|:
if|if
condition|(
name|xsense
operator|->
name|sc_xsense
operator|.
name|key
operator|&
name|XSK_UNTATTEN
condition|)
name|stat
operator|=
name|scsi_test_unit_rdy
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|STS_CHECKCOND
condition|)
block|{
name|stxsense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsense
operator|->
name|sc_xsense
operator|.
name|key
condition|)
name|prtkey
argument_list|(
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_filepos
operator|=
literal|0
expr_stmt|;
comment|/* new tape */
name|stat
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|MT_ISHPDAT
case|:
case|case
name|MT_ISVIPER1
case|:
case|case
name|MT_ISPYTHON
case|:
if|if
condition|(
name|xsense
operator|->
name|sc_xsense
operator|.
name|key
operator|&
name|XSK_UNTATTEN
condition|)
name|stat
operator|=
name|scsi_test_unit_rdy
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|STS_CHECKCOND
condition|)
block|{
name|stxsense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsense
operator|->
name|sc_xsense
operator|.
name|key
condition|)
name|prtkey
argument_list|(
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|uprintf
argument_list|(
literal|"st%d: not ready\n"
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|prtkey
argument_list|(
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stat
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* mode sense */
name|modlen
operator|=
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_MODE_SENSE
index|]
expr_stmt|;
name|modsense
operator|.
name|cdb
index|[
literal|4
index|]
operator|=
name|modlen
expr_stmt|;
name|stat
operator|=
name|scsi_immed_command
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
operator|&
name|modsense
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mode
argument_list|,
name|modlen
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|st_debug
operator|&
name|ST_OPENSTAT
condition|)
name|prtmodstat
argument_list|(
operator|&
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stat
operator|==
name|STS_CHECKCOND
condition|)
block|{
name|stxsense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|st_debug
operator|&
name|ST_OPEN
condition|)
name|dumpxsense
argument_list|(
name|xsense
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|stat
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
name|mode
operator|.
name|md
operator|.
name|wp
condition|)
block|{
name|uprintf
argument_list|(
literal|"st:%d write protected\n"
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
comment|/* save total number of blocks on tape */
name|sc
operator|->
name|sc_numblks
operator|=
name|mode
operator|.
name|md
operator|.
name|numblk2
operator|<<
literal|16
operator||
name|mode
operator|.
name|md
operator|.
name|numblk1
operator|<<
literal|8
operator||
name|mode
operator|.
name|md
operator|.
name|numblk0
expr_stmt|;
if|if
condition|(
name|xsense
operator|->
name|sc_xsense
operator|.
name|eom
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|STF_LEOT
operator|)
condition|)
name|sc
operator|->
name|sc_filepos
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|st_debug
operator|&
name|ST_FMKS
condition|)
name|printf
argument_list|(
literal|"st%d: open filepos = %d\n"
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_filepos
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_flags
operator||=
operator|(
name|STF_OPEN
operator|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|FWRITE
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|STF_WMODE
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|STF_MOVED
expr_stmt|;
ifdef|#
directive|ifdef
name|TTI
comment|/* make stats available, also lit up TTi display */
name|sc
operator|->
name|sc_tticntdwn
operator|=
literal|100
expr_stmt|;
endif|#
directive|endif
name|stxsense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|stclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|int
name|hit
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|STF_WMODE
operator||
name|STF_WRTTN
operator|)
operator|)
operator|==
operator|(
name|STF_WMODE
operator||
name|STF_WRTTN
operator|)
condition|)
block|{
comment|/* 		 * Cartridge tapes don't do double EOFs on EOT. 		 * We assume that variable-block devices use double EOF. 		 */
name|stcommand
argument_list|(
name|dev
argument_list|,
name|MTWEOF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_blklen
operator|==
literal|0
condition|)
block|{
name|stcommand
argument_list|(
name|dev
argument_list|,
name|MTWEOF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcommand
argument_list|(
name|dev
argument_list|,
name|MTBSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|hit
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|STDEV_NOREWIND
operator|)
operator|==
literal|0
condition|)
block|{
name|stcommand
argument_list|(
name|dev
argument_list|,
name|MTREW
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hit
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOTDEF
comment|/* wait until more stable before trying [XXX Needed ?] */
if|if
condition|(
operator|!
name|hit
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SFT_WMODE
operator|)
condition|)
comment|/* force out any any bufferd write data */
name|stcommand
argument_list|(
name|dev
argument_list|,
name|MTFSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* make stats available */
name|stxsense
argument_list|(
name|sc
operator|->
name|sc_dq
operator|.
name|dq_ctlr
argument_list|,
name|sc
operator|->
name|sc_dq
operator|.
name|dq_slave
argument_list|,
name|sc
operator|->
name|sc_punit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|STF_OPEN
operator||
name|STF_WMODE
operator||
name|STF_WRTTN
operator|)
expr_stmt|;
name|tprintf_close
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX */
block|}
end_block

begin_function
name|void
name|ststrategy
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|s
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|&
name|sttab
index|[
name|unit
index|]
expr_stmt|;
name|bp
operator|->
name|b_actf
operator|=
name|NULL
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bp
operator|->
name|b_actb
operator|=
name|dp
operator|->
name|b_actb
expr_stmt|;
operator|*
name|dp
operator|->
name|b_actb
operator|=
name|bp
expr_stmt|;
name|dp
operator|->
name|b_actb
operator|=
operator|&
name|bp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
block|{
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
name|stustart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|stustart
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|scsireq
argument_list|(
operator|&
name|st_softc
index|[
name|unit
index|]
operator|.
name|sc_dq
argument_list|)
condition|)
name|ststart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ststart
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|hp_device
modifier|*
name|hp
init|=
name|st_softc
index|[
name|unit
index|]
operator|.
name|sc_hd
decl_stmt|;
if|if
condition|(
name|scsiustart
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|)
condition|)
name|stgo
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|stgo
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|scsi_fmt_cdb
modifier|*
name|cmd
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|sttab
index|[
name|unit
index|]
operator|.
name|b_actf
decl_stmt|;
name|struct
name|hp_device
modifier|*
name|hp
init|=
name|sc
operator|->
name|sc_hd
decl_stmt|;
name|int
name|pad
decl_stmt|,
name|stat
decl_stmt|;
name|long
name|nblks
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|STF_CMD
condition|)
block|{
name|cmd
operator|=
operator|&
name|stcmd
index|[
name|unit
index|]
expr_stmt|;
name|pad
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
operator|&
name|st_read_cmd
else|:
operator|&
name|st_write_cmd
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_blklen
condition|)
name|cmd
operator|->
name|cdb
index|[
literal|1
index|]
operator||=
literal|0x01
expr_stmt|;
comment|/* fixed mode */
else|else
name|cmd
operator|->
name|cdb
index|[
literal|1
index|]
operator|&=
literal|0xfe
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|STF_WRTTN
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator||=
name|STF_WRTTN
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_blklen
condition|)
block|{
comment|/* fixed mode */
name|nblks
operator|=
name|bp
operator|->
name|b_bcount
operator|/
name|sc
operator|->
name|sc_blklen
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|%
name|sc
operator|->
name|sc_blklen
condition|)
block|{
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: I/O not block aligned %d/%ld\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_blklen
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cdb
index|[
literal|1
index|]
operator|&=
literal|0xfe
expr_stmt|;
comment|/* force error */
block|}
block|}
else|else
comment|/* variable len */
name|nblks
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|2
index|]
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|nblks
operator|>>
literal|16
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|3
index|]
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|nblks
operator|>>
literal|8
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|4
index|]
operator|)
operator|=
operator|(
name|u_char
operator|)
name|nblks
expr_stmt|;
comment|/* 		 * Always Zero. We are either writing in variable 		 * length mode we are writing in fixed block mode, 		 * or we are going to do odd length IO and are not 		 * going to use DMA. 		 */
name|pad
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|st_debug
operator|&
name|ST_GO
condition|)
name|printf
argument_list|(
literal|"stgo: cmd len %d [0]0x%x [1]0x%x [2]0x%x [3]0x%x [4]0x%x [5]0x%x\n"
argument_list|,
name|cmd
operator|->
name|len
argument_list|,
name|cmd
operator|->
name|cdb
index|[
literal|0
index|]
argument_list|,
name|cmd
operator|->
name|cdb
index|[
literal|1
index|]
argument_list|,
name|cmd
operator|->
name|cdb
index|[
literal|2
index|]
argument_list|,
name|cmd
operator|->
name|cdb
index|[
literal|3
index|]
argument_list|,
name|cmd
operator|->
name|cdb
index|[
literal|4
index|]
argument_list|,
name|cmd
operator|->
name|cdb
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_flags
operator||=
name|STF_MOVED
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|&
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|st_debug
operator|&
name|ST_ODDIO
condition|)
name|printf
argument_list|(
literal|"stgo%d: odd count %d using manual transfer\n"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stat
operator|=
name|scsi_tt_oddio
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|sc
operator|->
name|sc_punit
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|stfinish
argument_list|(
name|unit
argument_list|,
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|stat
operator|=
name|scsigo
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|sc
operator|->
name|sc_punit
argument_list|,
name|bp
argument_list|,
name|cmd
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|stxsense
argument_list|(
name|sc
operator|->
name|sc_dq
operator|.
name|dq_ctlr
argument_list|,
name|sc
operator|->
name|sc_dq
operator|.
name|dq_slave
argument_list|,
name|sc
operator|->
name|sc_punit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sterror
argument_list|(
name|unit
argument_list|,
name|sc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|stfinish
argument_list|(
name|unit
argument_list|,
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|stfinish
argument_list|(
argument|unit
argument_list|,
argument|sc
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|st_softc
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|sttab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|=
name|bp
operator|->
name|b_actf
condition|)
name|dp
operator|->
name|b_actb
operator|=
name|bp
operator|->
name|b_actb
expr_stmt|;
else|else
name|sttab
index|[
name|unit
index|]
operator|.
name|b_actb
operator|=
name|bp
operator|->
name|b_actb
expr_stmt|;
operator|*
name|bp
operator|->
name|b_actb
operator|=
name|dp
expr_stmt|;
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|scsifree
argument_list|(
operator|&
name|sc
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sttab
index|[
name|unit
index|]
operator|.
name|b_actf
condition|)
name|stustart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
else|else
name|sttab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|stread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|ststrategy
argument_list|,
operator|&
name|stbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|stwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|physio
argument_list|(
name|ststrategy
argument_list|,
operator|&
name|stbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|stdump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|stioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|struct
name|mtget
modifier|*
name|mtget
decl_stmt|;
specifier|register
name|struct
name|st_xsense
modifier|*
name|xp
init|=
operator|&
name|st_xsense
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|mtop
modifier|*
name|op
decl_stmt|;
name|long
name|resid
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* tape operation */
case|case
name|MTIOCTOP
case|:
name|op
operator|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|mt_op
condition|)
block|{
case|case
name|MTBSR
case|:
case|case
name|MTFSR
case|:
if|if
condition|(
name|sc
operator|->
name|sc_tapeid
operator|==
name|MT_ISAR
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
case|case
name|MTWEOF
case|:
case|case
name|MTFSF
case|:
case|case
name|MTBSF
case|:
name|cnt
operator|=
operator|(
name|int
operator|)
name|op
operator|->
name|mt_count
expr_stmt|;
break|break;
case|case
name|MTREW
case|:
case|case
name|MTOFFL
case|:
name|cnt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MTNOP
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|stcommand
argument_list|(
name|dev
argument_list|,
operator|(
name|u_int
operator|)
name|op
operator|->
name|mt_op
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
break|break;
comment|/* drive status */
case|case
name|MTIOCGET
case|:
name|mtget
operator|=
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|data
expr_stmt|;
name|stxsense
argument_list|(
name|sc
operator|->
name|sc_dq
operator|.
name|dq_ctlr
argument_list|,
name|sc
operator|->
name|sc_dq
operator|.
name|dq_slave
argument_list|,
name|sc
operator|->
name|sc_punit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mtget
operator|->
name|mt_type
operator|=
name|sc
operator|->
name|sc_tapeid
expr_stmt|;
name|mtget
operator|->
name|mt_dsreg
operator|=
literal|0
expr_stmt|;
name|mtget
operator|->
name|mt_erreg
operator|=
operator|(
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|valid
operator|<<
literal|15
operator|)
operator||
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|filemark
operator|<<
literal|14
operator|)
operator||
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|eom
operator|<<
literal|13
operator|)
operator||
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|ili
operator|<<
literal|12
operator|)
operator||
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|key
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tapeid
operator|==
name|MT_ISEXABYTE
condition|)
block|{
name|mtget
operator|->
name|mt_dsreg
operator|=
name|sc
operator|->
name|sc_flags
expr_stmt|;
name|resid
operator|=
operator|(
name|xp
operator|->
name|exb_xsense
operator|.
name|tplft2
operator|<<
literal|16
operator||
name|xp
operator|->
name|exb_xsense
operator|.
name|tplft1
operator|<<
literal|8
operator||
name|xp
operator|->
name|exb_xsense
operator|.
name|tplft0
operator|)
expr_stmt|;
name|mtget
operator|->
name|mt_resid
operator|=
name|resid
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_numblks
operator|-
name|resid
condition|)
name|mtget
operator|->
name|mt_erreg
operator||=
operator|(
operator|(
operator|(
name|xp
operator|->
name|exb_xsense
operator|.
name|rwerrcnt2
operator|<<
literal|16
operator||
name|xp
operator|->
name|exb_xsense
operator|.
name|rwerrcnt1
operator|<<
literal|8
operator||
name|xp
operator|->
name|exb_xsense
operator|.
name|rwerrcnt0
operator|)
operator|*
literal|100
operator|)
operator|/
operator|(
name|sc
operator|->
name|sc_numblks
operator|-
name|resid
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xp
operator|->
name|sc_xsense
operator|.
name|valid
condition|)
block|{
name|resid
operator|=
operator|(
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|info1
operator|<<
literal|24
operator|)
operator||
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|info2
operator|<<
literal|16
operator|)
operator||
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|info3
operator|<<
literal|8
operator|)
operator||
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|info4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_blklen
condition|)
comment|/* if fixed mode */
name|resid
operator|*=
name|sc
operator|->
name|sc_blklen
expr_stmt|;
name|mtget
operator|->
name|mt_resid
operator|=
name|resid
expr_stmt|;
block|}
else|else
name|mtget
operator|->
name|mt_resid
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|stintr
argument_list|(
argument|unit
argument_list|,
argument|stat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|stat
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|st_xsense
modifier|*
name|xp
init|=
operator|&
name|st_xsense
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|sttab
index|[
name|unit
index|]
operator|.
name|b_actf
decl_stmt|;
name|struct
name|hp_device
modifier|*
name|hp
init|=
name|sc
operator|->
name|sc_hd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: bp == NULL\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|stat
condition|)
block|{
comment|/* scsi command completed ok */
case|case
literal|0
case|:
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* more status */
case|case
name|STS_CHECKCOND
case|:
name|stxsense
argument_list|(
name|sc
operator|->
name|sc_dq
operator|.
name|dq_ctlr
argument_list|,
name|sc
operator|->
name|sc_dq
operator|.
name|dq_slave
argument_list|,
name|sc
operator|->
name|sc_punit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|sc_xsense
operator|.
name|valid
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
call|(
name|u_long
call|)
argument_list|(
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|info1
operator|<<
literal|24
operator|)
operator||
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|info2
operator|<<
literal|16
operator|)
operator||
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|info3
operator|<<
literal|8
operator|)
operator||
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|info4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_blklen
condition|)
comment|/* fixed mode */
name|bp
operator|->
name|b_resid
operator|*=
name|sc
operator|->
name|sc_blklen
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|->
name|sc_xsense
operator|.
name|filemark
condition|)
block|{
name|sc
operator|->
name|sc_filepos
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xp
operator|->
name|sc_xsense
operator|.
name|key
operator|!=
name|XSK_NOSENCE
operator|&&
name|xp
operator|->
name|sc_xsense
operator|.
name|key
operator|!=
name|XSK_NOTUSED1
operator|&&
name|xp
operator|->
name|sc_xsense
operator|.
name|key
operator|!=
name|XSK_NOTUSEDC
operator|&&
name|xp
operator|->
name|sc_xsense
operator|.
name|key
operator|!=
name|XSK_NOTUSEDE
condition|)
block|{
name|sterror
argument_list|(
name|unit
argument_list|,
name|sc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xp
operator|->
name|sc_xsense
operator|.
name|ili
condition|)
block|{
comment|/* 			 * Fixed length blocks, an error. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_blklen
condition|)
block|{
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: Incorrect Length Indicator, blkcnt diff %d\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_blklen
operator|-
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
comment|/* 			 * Variable length but read more than requested, 			 * an error.  (XXX ??? wrong for 9 track?) 			 */
if|if
condition|(
name|bp
operator|->
name|b_resid
operator|<
literal|0
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
comment|/* 			 * Variable length and odd, may require special 			 * handling. 			 */
if|if
condition|(
name|bp
operator|->
name|b_resid
operator|&
literal|1
operator|&&
operator|(
name|sc
operator|->
name|sc_tapeid
operator|!=
name|MT_ISAR
operator|)
condition|)
block|{
comment|/* 				 * Normal behavior, treat as an error. 				 */
if|if
condition|(
operator|!
name|st_dmaoddretry
condition|)
block|{
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: Odd length read %d\n"
argument_list|,
name|UNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
name|bp
operator|->
name|b_bcount
operator|-
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
break|break;
block|}
comment|/* 				 * Attempt to back up and re-read using oddio. 				 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|st_debug
operator|&
name|ST_ODDIO
condition|)
name|printf
argument_list|(
literal|"st%d: stintr odd count %d, do BSR then oddio\n"
argument_list|,
name|UNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
name|bp
operator|->
name|b_bcount
operator|-
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stat
operator|=
name|scsi_tt_oddio
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|sc
operator|->
name|sc_punit
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
name|stat
operator|=
name|scsi_tt_oddio
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|sc
operator|->
name|sc_punit
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
operator|-
name|bp
operator|->
name|b_resid
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|stxsense
argument_list|(
name|sc
operator|->
name|sc_dq
operator|.
name|dq_ctlr
argument_list|,
name|sc
operator|->
name|sc_dq
operator|.
name|dq_slave
argument_list|,
name|sc
operator|->
name|sc_punit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sterror
argument_list|(
name|unit
argument_list|,
name|sc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|xp
operator|->
name|sc_xsense
operator|.
name|eom
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENOSPC
expr_stmt|;
break|break;
block|}
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: unknown scsi error\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"st%d: stintr unknown stat 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|st_debug
operator|&
name|ST_BRESID
operator|)
operator|&&
name|bp
operator|->
name|b_resid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"b_resid %d b_flags 0x%x b_error 0x%x\n"
argument_list|,
name|bp
operator|->
name|b_resid
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* asked for more filemarks then on tape */
if|if
condition|(
name|bp
operator|->
name|b_resid
operator|!=
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|STF_CMD
operator|)
operator|&&
name|sc
operator|->
name|sc_cmd
operator|==
name|CMD_SPACE
condition|)
block|{
name|sc
operator|->
name|sc_filepos
operator|-=
name|bp
operator|->
name|b_resid
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_filepos
operator|<
literal|0
condition|)
name|sc
operator|->
name|sc_filepos
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TTI
if|if
condition|(
name|st_extti
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
operator|&&
name|sc
operator|->
name|sc_type
operator|==
name|MT_ISEXABYTE
condition|)
comment|/* to make display lit up */
comment|/* 		 * XXX severe performance penality for this. 		 * Try and throttle by not calling stxsense on every intr. 		 * Mostly for TTi we, get a stxsense call in open and close. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_tticntdwn
operator|--
operator|==
literal|0
condition|)
block|{
name|stxsense
argument_list|(
name|sc
operator|->
name|sc_dq
operator|.
name|dq_ctlr
argument_list|,
name|sc
operator|->
name|sc_dq
operator|.
name|dq_slave
argument_list|,
name|sc
operator|->
name|sc_punit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tticntdwn
operator|=
literal|100
expr_stmt|;
block|}
endif|#
directive|endif
name|stfinish
argument_list|(
name|unit
argument_list|,
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|stcommand
argument_list|(
argument|dev
argument_list|,
argument|command
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|st_softc
modifier|*
name|sc
init|=
operator|&
name|st_softc
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
operator|&
name|stbuf
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|scsi_fmt_cdb
modifier|*
name|cmd
init|=
operator|&
name|stcmd
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|cmdcnt
expr_stmt|;
name|int
name|s
decl_stmt|;
name|cmd
operator|->
name|len
operator|=
literal|6
expr_stmt|;
comment|/* all tape commands are cdb6 */
name|cmd
operator|->
name|cdb
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|sc_punit
expr_stmt|;
name|cmd
operator|->
name|cdb
index|[
literal|2
index|]
operator|=
name|cmd
operator|->
name|cdb
index|[
literal|3
index|]
operator|=
name|cmd
operator|->
name|cdb
index|[
literal|4
index|]
operator|=
name|cmd
operator|->
name|cdb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|cmdcnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * XXX Assumption is that everything except Archive can take 	 * repeat count in cdb block. 	 */
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|MTWEOF
case|:
name|cmd
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
name|CMD_WRITE_FILEMARK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tapeid
operator|!=
name|MT_ISAR
condition|)
block|{
name|cmdcnt
operator|=
name|cnt
expr_stmt|;
name|cnt
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|cmdcnt
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|2
index|]
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cmdcnt
operator|>>
literal|16
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|3
index|]
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cmdcnt
operator|>>
literal|8
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|4
index|]
operator|)
operator|=
operator|(
name|u_char
operator|)
name|cmdcnt
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tapeid
operator|==
name|MT_ISEXABYTE
operator|&&
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|STDEV_EXSFMK
operator|)
condition|)
comment|/* short filemarks */
name|cmd
operator|->
name|cdb
index|[
literal|5
index|]
operator||=
literal|0x80
expr_stmt|;
else|else
name|cmd
operator|->
name|cdb
index|[
literal|5
index|]
operator|&=
literal|0x7f
expr_stmt|;
break|break;
case|case
name|MTBSF
case|:
comment|/* Archive can't back up, will not get to BSR case */
if|if
condition|(
name|sc
operator|->
name|sc_tapeid
operator|==
name|MT_ISAR
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_filepos
operator|-
name|cnt
operator|)
operator|<
literal|0
condition|)
block|{
name|stcommand
argument_list|(
name|dev
argument_list|,
name|MTREW
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|cmdcnt
operator|=
name|sc
operator|->
name|sc_filepos
operator|-
name|cnt
operator|+
literal|1
expr_stmt|;
name|stcommand
argument_list|(
name|dev
argument_list|,
name|MTREW
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcommand
argument_list|(
name|dev
argument_list|,
name|MTFSF
argument_list|,
name|cmdcnt
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|MTBSR
case|:
case|case
name|MTFSR
case|:
case|case
name|MTFSF
case|:
if|if
condition|(
name|command
operator|==
name|MTBSF
operator|||
name|command
operator|==
name|MTBSR
condition|)
name|cnt
operator|=
name|cnt
operator|*
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* backward move */
if|if
condition|(
name|command
operator|==
name|MTFSF
operator|||
name|command
operator|==
name|MTBSF
condition|)
name|cmd
operator|->
name|cdb
index|[
literal|1
index|]
operator||=
literal|0x01
expr_stmt|;
comment|/* filemarks */
else|else
name|cmd
operator|->
name|cdb
index|[
literal|1
index|]
operator||=
literal|0x00
expr_stmt|;
comment|/* logical blocks */
if|if
condition|(
name|sc
operator|->
name|sc_tapeid
operator|!=
name|MT_ISAR
condition|)
block|{
name|cmdcnt
operator|=
name|cnt
expr_stmt|;
name|cnt
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|cmdcnt
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|2
index|]
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cmdcnt
operator|>>
literal|16
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|3
index|]
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cmdcnt
operator|>>
literal|8
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|cmd
operator|->
name|cdb
index|[
literal|4
index|]
operator|)
operator|=
operator|(
name|u_char
operator|)
name|cmdcnt
expr_stmt|;
name|cmd
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
name|CMD_SPACE
expr_stmt|;
break|break;
case|case
name|MTREW
case|:
name|cmd
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
name|CMD_REWIND
expr_stmt|;
name|sc
operator|->
name|sc_filepos
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MTOFFL
case|:
name|cmd
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
name|CMD_LOADUNLOAD
expr_stmt|;
name|sc
operator|->
name|sc_filepos
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"st%d: stcommand bad command 0x%x\n"
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator||=
name|STF_CMD
expr_stmt|;
name|sc
operator|->
name|sc_cmd
operator|=
name|cmd
operator|->
name|cdb
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|sc_bp
operator|=
name|bp
expr_stmt|;
name|again
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|st_debug
operator|&
name|ST_FMKS
condition|)
name|printf
argument_list|(
literal|"st%d: stcommand filepos %d cmdcnt %d cnt %d\n"
argument_list|,
name|UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_filepos
argument_list|,
name|cmdcnt
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
condition|)
break|break;
name|bp
operator|->
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|ststrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|iowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
name|B_ERROR
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|MTWEOF
operator|||
name|command
operator|==
name|MTFSF
operator|||
name|command
operator|==
name|MTBSF
condition|)
name|sc
operator|->
name|sc_filepos
operator|+=
name|cmdcnt
expr_stmt|;
if|if
condition|(
operator|--
name|cnt
operator|>
literal|0
condition|)
goto|goto
name|again
goto|;
name|sc
operator|->
name|sc_flags
operator||=
name|STF_MOVED
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|STF_CMD
operator||
name|STF_WRTTN
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|sterror
argument_list|(
argument|unit
argument_list|,
argument|sc
argument_list|,
argument|stat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|stat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|st_softc
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* stxsense must have been called before sterror() */
if|if
condition|(
name|stat
operator|&
name|STS_CHECKCOND
condition|)
name|prtkey
argument_list|(
name|unit
argument_list|,
name|sc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: bad scsi status 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|STF_CMD
operator|)
operator|&&
name|sc
operator|->
name|sc_cmd
operator|==
name|CMD_SPACE
condition|)
comment|/* fsf */
name|sc
operator|->
name|sc_filepos
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|stxsense
argument_list|(
argument|ctlr
argument_list|,
argument|slave
argument_list|,
argument|unit
argument_list|,
argument|sc
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|st_softc
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_char
modifier|*
name|sensebuf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|sensebuf
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|st_xsense
index|[
name|sc
operator|->
name|sc_dq
operator|.
name|dq_unit
index|]
expr_stmt|;
name|len
operator|=
name|sc
operator|->
name|sc_datalen
index|[
name|CMD_REQUEST_SENSE
index|]
expr_stmt|;
name|scsi_request_sense
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|unit
argument_list|,
name|sensebuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|prtkey
argument_list|(
argument|unit
argument_list|,
argument|sc
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|st_softc
modifier|*
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|st_xsense
modifier|*
name|xp
init|=
operator|&
name|st_xsense
index|[
name|unit
index|]
decl_stmt|;
switch|switch
condition|(
name|xp
operator|->
name|sc_xsense
operator|.
name|key
condition|)
block|{
case|case
name|XSK_NOSENCE
case|:
break|break;
case|case
name|XSK_NOTUSED1
case|:
case|case
name|XSK_NOTUSEDC
case|:
case|case
name|XSK_NOTUSEDE
case|:
break|break;
case|case
name|XSK_REVERVED
case|:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: Reserved sense key 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|xp
operator|->
name|sc_xsense
operator|.
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSK_NOTRDY
case|:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: NOT READY\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSK_MEDERR
case|:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: MEDIUM ERROR\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSK_HRDWERR
case|:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: HARDWARE ERROR\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSK_ILLREQ
case|:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: ILLEGAL REQUEST\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSK_UNTATTEN
case|:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: UNIT ATTENTION\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSK_DATAPROT
case|:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: DATA PROTECT\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSK_BLNKCHK
case|:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: BLANK CHECK\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSK_VENDOR
case|:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: VENDER UNIQUE SENSE KEY "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_tapeid
condition|)
block|{
case|case
name|MT_ISEXABYTE
case|:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"Exabyte: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|xfr
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"Transfer Abort Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|tmd
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"Tape Mark Detect Error\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XSK_CPYABORT
case|:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: COPY ABORTED\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSK_ABORTCMD
case|:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: ABORTED COMMAND\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|XSK_VOLOVER
case|:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: VOLUME OVERFLOW\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: unknown sense key 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|xp
operator|->
name|sc_xsense
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_tapeid
operator|==
name|MT_ISEXABYTE
condition|)
block|{
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|bpe
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: Bus Parity Errorn"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|fpe
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: Formatted Buffer Parity Errorn"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|eco
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: Error Counter Overflown"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|tme
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: Tape Motion Errorn"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|xfr
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: Transfer About Errorn"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|tmd
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: Tape Mark Detect Errorn"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|fmke
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: Filemark Errorn"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|ure
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: Under Run Errorn"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|sse
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: Servo System Errorn"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|fe
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: Formatter Errorn"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|wseb
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: WSEB Errorn"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|exb_xsense
operator|.
name|wseo
condition|)
name|tprintf
argument_list|(
name|sc
operator|->
name|sc_ctty
argument_list|,
literal|"st%d: WSEO Errorn"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|dumpxsense
argument_list|(
argument|sensebuf
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|st_xsense
modifier|*
name|sensebuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|st_xsense
modifier|*
name|xp
init|=
name|sensebuf
decl_stmt|;
name|printf
argument_list|(
literal|"valid 0x%x errorclass 0x%x errorcode 0x%x\n"
argument_list|,
name|xp
operator|->
name|sc_xsense
operator|.
name|valid
argument_list|,
name|xp
operator|->
name|sc_xsense
operator|.
name|class
argument_list|,
name|xp
operator|->
name|sc_xsense
operator|.
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"seg number 0x%x\n"
argument_list|,
name|xp
operator|->
name|sc_xsense
operator|.
name|segment
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FMK 0x%x EOM 0x%x ILI 0x%x RSVD 0x%x sensekey 0x%x\n"
argument_list|,
name|xp
operator|->
name|sc_xsense
operator|.
name|filemark
argument_list|,
name|xp
operator|->
name|sc_xsense
operator|.
name|eom
argument_list|,
name|xp
operator|->
name|sc_xsense
operator|.
name|ili
argument_list|,
name|xp
operator|->
name|sc_xsense
operator|.
name|rsvd
argument_list|,
name|xp
operator|->
name|sc_xsense
operator|.
name|key
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"info 0x%lx\n"
argument_list|,
call|(
name|u_long
call|)
argument_list|(
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|info1
operator|<<
literal|24
operator|)
operator||
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|info2
operator|<<
literal|16
operator|)
operator||
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|info3
operator|<<
literal|8
operator|)
operator||
operator|(
name|xp
operator|->
name|sc_xsense
operator|.
name|info4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ASenseL 0x%x\n"
argument_list|,
name|xp
operator|->
name|sc_xsense
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|sc_xsense
operator|.
name|len
operator|!=
literal|0x12
condition|)
comment|/* MT_ISEXB Exabyte only ?? */
return|return;
comment|/* What about others */
name|printf
argument_list|(
literal|"ASenseC 0x%x\n"
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|addsens
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"AsenseQ 0x%x\n"
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|addsensq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"R/W Errors 0x%lx\n"
argument_list|,
call|(
name|u_long
call|)
argument_list|(
operator|(
name|xp
operator|->
name|exb_xsense
operator|.
name|rwerrcnt2
operator|<<
literal|16
operator|)
operator||
operator|(
name|xp
operator|->
name|exb_xsense
operator|.
name|rwerrcnt1
operator|<<
literal|8
operator|)
operator||
operator|(
name|xp
operator|->
name|exb_xsense
operator|.
name|rwerrcnt1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PF   0x%x BPE  0x%x FPE 0x%x ME   0x%x ECO 0x%x TME 0x%x TNP 0x%x BOT 0x%x\n"
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|pf
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|bpe
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|fpe
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|me
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|eco
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|tme
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|tnp
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|bot
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"XFR  0x%x TMD  0x%x WP  0x%x FMKE 0x%x URE 0x%x WE1 0x%x SSE 0x%x FE  0x%x\n"
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|xfr
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|tmd
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|wp
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|fmke
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|ure
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|we1
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|sse
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|fe
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"WSEB 0x%x WSEO 0x%x\n"
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|wseb
argument_list|,
name|xp
operator|->
name|exb_xsense
operator|.
name|wseo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Remaining Tape 0x%lx\n"
argument_list|,
call|(
name|u_long
call|)
argument_list|(
operator|(
name|xp
operator|->
name|exb_xsense
operator|.
name|tplft2
operator|<<
literal|16
operator|)
operator||
operator|(
name|xp
operator|->
name|exb_xsense
operator|.
name|tplft1
operator|<<
literal|8
operator|)
operator||
operator|(
name|xp
operator|->
name|exb_xsense
operator|.
name|tplft0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|prtmodsel
argument_list|(
argument|msd
argument_list|,
argument|modlen
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mode_select_data
modifier|*
name|msd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|modlen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"Modsel command. len is 0x%x.\n"
argument_list|,
name|modlen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rsvd1 0x%x rsvd2 0x%x rsvd3 0x%x bufferd 0x%x speed 0x%x bckdeslen 0x%x\n"
argument_list|,
name|msd
operator|->
name|rsvd1
argument_list|,
name|msd
operator|->
name|rsvd2
argument_list|,
name|msd
operator|->
name|rsvd3
argument_list|,
name|msd
operator|->
name|buff
argument_list|,
name|msd
operator|->
name|speed
argument_list|,
name|msd
operator|->
name|blkdeslen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"density 0x%x blks2 0x%x blks1 0x%x blks0 0x%x rsvd 0x%x blklen2 0x%x blklen1 0x%x blklen0 0x%x\n"
argument_list|,
name|msd
operator|->
name|density
argument_list|,
name|msd
operator|->
name|blks2
argument_list|,
name|msd
operator|->
name|blks1
argument_list|,
name|msd
operator|->
name|blks0
argument_list|,
name|msd
operator|->
name|rsvd4
argument_list|,
name|msd
operator|->
name|blklen2
argument_list|,
name|msd
operator|->
name|blklen1
argument_list|,
name|msd
operator|->
name|blklen0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vupb 0x%x rsvd 0x%x p5 0x%x motionthres 0x%x reconthres 0x%x gapthres 0x%x \n"
argument_list|,
name|msd
operator|->
name|vupb
argument_list|,
name|msd
operator|->
name|rsvd5
argument_list|,
name|msd
operator|->
name|p5
argument_list|,
name|msd
operator|->
name|motionthres
argument_list|,
name|msd
operator|->
name|reconthres
argument_list|,
name|msd
operator|->
name|gapthres
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|prtmodstat
argument_list|(
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mode_sense
modifier|*
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"Mode Status\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sdl 0x%x medtype 0x%x wp 0x%x bfmd 0x%x speed 0x%x bdl 0x%x\n"
argument_list|,
name|mode
operator|->
name|md
operator|.
name|sdl
argument_list|,
name|mode
operator|->
name|md
operator|.
name|medtype
argument_list|,
name|mode
operator|->
name|md
operator|.
name|wp
argument_list|,
name|mode
operator|->
name|md
operator|.
name|bfmd
argument_list|,
name|mode
operator|->
name|md
operator|.
name|speed
argument_list|,
name|mode
operator|->
name|md
operator|.
name|bdl
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dencod 0x%x numblk 0x%x blklen 0x%x\n"
argument_list|,
name|mode
operator|->
name|md
operator|.
name|dencod
argument_list|,
operator|(
name|mode
operator|->
name|md
operator|.
name|numblk2
operator|<<
literal|16
operator|)
operator||
operator|(
name|mode
operator|->
name|md
operator|.
name|numblk1
operator|<<
literal|8
operator|)
operator||
operator|(
name|mode
operator|->
name|md
operator|.
name|numblk0
operator|)
argument_list|,
operator|(
name|mode
operator|->
name|md
operator|.
name|blklen2
operator|<<
literal|16
operator|)
operator||
operator|(
name|mode
operator|->
name|md
operator|.
name|blklen1
operator|<<
literal|8
operator|)
operator||
operator|(
name|mode
operator|->
name|md
operator|.
name|blklen0
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ct 0x%x nd 0x%x nbe 0x%x edb 0x%x pe 0x%x nal 0x%x p5 0x%x\n"
argument_list|,
name|mode
operator|->
name|ex
operator|.
name|ct
argument_list|,
name|mode
operator|->
name|ex
operator|.
name|nd
argument_list|,
name|mode
operator|->
name|ex
operator|.
name|nbe
argument_list|,
name|mode
operator|->
name|ex
operator|.
name|ebd
argument_list|,
name|mode
operator|->
name|ex
operator|.
name|pe
argument_list|,
name|mode
operator|->
name|ex
operator|.
name|nal
argument_list|,
name|mode
operator|->
name|ex
operator|.
name|p5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"motionthres 0x%x reconthres 0x%x gapthres 0x%x\n"
argument_list|,
name|mode
operator|->
name|ex
operator|.
name|motionthres
argument_list|,
name|mode
operator|->
name|ex
operator|.
name|reconthres
argument_list|,
name|mode
operator|->
name|ex
operator|.
name|gapthres
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

