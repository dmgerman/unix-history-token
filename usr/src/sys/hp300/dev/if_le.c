begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1990 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)if_le.c	7.16 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"le.h"
end_include

begin_if
if|#
directive|if
name|NLE
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_comment
comment|/*  * AMD 7990 LANCE  *  * This driver will accept tailer encapsulated packets even  * though it buys us nothing.  The motivation was to avoid incompatibilities  * with VAXen, SUNs, and others that handle and benefit from them.  * This reasoning is dubious.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CCITT
argument_list|)
operator|&&
name|defined
argument_list|(
name|LLC
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/x25.h>
end_include

begin_extern
extern|extern llc_ctlinput(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|cons_rtrequest
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<hp300/hp300/isr.h>
end_include

begin_include
include|#
directive|include
file|<machine/mtpr.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/if_lereg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USELEDS
end_ifdef

begin_include
include|#
directive|include
file|<hp300/hp300/led.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* offsets for:	   ID,   REGS,    MEM,  NVRAM */
end_comment

begin_decl_stmt
name|int
name|lestd
index|[]
init|=
block|{
literal|0
block|,
literal|0x4000
block|,
literal|0x8000
block|,
literal|0xC008
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|leattach
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|driver
name|ledriver
init|=
block|{
name|leattach
block|,
literal|"le"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isr
name|le_isr
index|[
name|NLE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ledebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* console error messages */
end_comment

begin_decl_stmt
name|int
name|leintr
argument_list|()
decl_stmt|,
name|leinit
argument_list|()
decl_stmt|,
name|leioctl
argument_list|()
decl_stmt|,
name|lestart
argument_list|()
decl_stmt|,
name|ether_output
argument_list|()
decl_stmt|,
name|lereset
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|mbuf
modifier|*
name|m_devget
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|ifnet
name|loif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Ethernet software status per interface.  *  * Each interface is referenced by a network interface structure,  * le_if, which the routing code uses to locate the interface.  * This structure contains the output queue for the interface, its address, ...  */
end_comment

begin_struct
struct|struct
name|le_softc
block|{
name|struct
name|arpcom
name|sc_ac
decl_stmt|;
comment|/* common Ethernet structures */
define|#
directive|define
name|sc_if
value|sc_ac.ac_if
comment|/* network-visible interface */
define|#
directive|define
name|sc_addr
value|sc_ac.ac_enaddr
comment|/* hardware Ethernet address */
name|struct
name|lereg0
modifier|*
name|sc_r0
decl_stmt|;
comment|/* DIO registers */
name|struct
name|lereg1
modifier|*
name|sc_r1
decl_stmt|;
comment|/* LANCE registers */
name|struct
name|lereg2
modifier|*
name|sc_r2
decl_stmt|;
comment|/* dual-port RAM */
name|int
name|sc_rmd
decl_stmt|;
comment|/* predicted next rmd to process */
name|int
name|sc_tmd
decl_stmt|;
comment|/* next available tmd */
name|int
name|sc_txcnt
decl_stmt|;
comment|/* # of transmit buffers in use */
comment|/* stats */
name|int
name|sc_runt
decl_stmt|;
name|int
name|sc_jab
decl_stmt|;
name|int
name|sc_merr
decl_stmt|;
name|int
name|sc_babl
decl_stmt|;
name|int
name|sc_cerr
decl_stmt|;
name|int
name|sc_miss
decl_stmt|;
name|int
name|sc_rown
decl_stmt|;
name|int
name|sc_xown
decl_stmt|;
name|int
name|sc_xown2
decl_stmt|;
name|int
name|sc_uflo
decl_stmt|;
name|int
name|sc_rxlen
decl_stmt|;
name|int
name|sc_rxoff
decl_stmt|;
name|int
name|sc_txoff
decl_stmt|;
name|int
name|sc_busy
decl_stmt|;
name|short
name|sc_iflags
decl_stmt|;
block|}
name|le_softc
index|[
name|NLE
index|]
struct|;
end_struct

begin_comment
comment|/* access LANCE registers */
end_comment

begin_define
define|#
directive|define
name|LERDWR
parameter_list|(
name|cntl
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
define|\
value|do { \ 		(dst) = (src); \ 	} while (((cntl)->ler0_status& LE_ACK) == 0);
end_define

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_macro
name|leattach
argument_list|(
argument|hd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hp_device
modifier|*
name|hd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|lereg0
modifier|*
name|ler0
decl_stmt|;
specifier|register
name|struct
name|lereg2
modifier|*
name|ler2
decl_stmt|;
name|struct
name|lereg2
modifier|*
name|lemem
init|=
literal|0
decl_stmt|;
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|hd
operator|->
name|hp_unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|le
operator|->
name|sc_if
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ler0
operator|=
name|le
operator|->
name|sc_r0
operator|=
operator|(
expr|struct
name|lereg0
operator|*
operator|)
operator|(
name|lestd
index|[
literal|0
index|]
operator|+
operator|(
name|int
operator|)
name|hd
operator|->
name|hp_addr
operator|)
expr_stmt|;
name|le
operator|->
name|sc_r1
operator|=
operator|(
expr|struct
name|lereg1
operator|*
operator|)
operator|(
name|lestd
index|[
literal|1
index|]
operator|+
operator|(
name|int
operator|)
name|hd
operator|->
name|hp_addr
operator|)
expr_stmt|;
name|ler2
operator|=
name|le
operator|->
name|sc_r2
operator|=
operator|(
expr|struct
name|lereg2
operator|*
operator|)
operator|(
name|lestd
index|[
literal|2
index|]
operator|+
operator|(
name|int
operator|)
name|hd
operator|->
name|hp_addr
operator|)
expr_stmt|;
if|if
condition|(
name|ler0
operator|->
name|ler0_id
operator|!=
name|LEID
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|le_isr
index|[
name|hd
operator|->
name|hp_unit
index|]
operator|.
name|isr_intr
operator|=
name|leintr
expr_stmt|;
name|hd
operator|->
name|hp_ipl
operator|=
name|le_isr
index|[
name|hd
operator|->
name|hp_unit
index|]
operator|.
name|isr_ipl
operator|=
name|LE_IPL
argument_list|(
name|ler0
operator|->
name|ler0_status
argument_list|)
expr_stmt|;
name|le_isr
index|[
name|hd
operator|->
name|hp_unit
index|]
operator|.
name|isr_arg
operator|=
name|hd
operator|->
name|hp_unit
expr_stmt|;
name|ler0
operator|->
name|ler0_id
operator|=
literal|0xFF
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 	 * Read the ethernet address off the board, one nibble at a time. 	 */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lestd
index|[
literal|3
index|]
operator|+
operator|(
name|int
operator|)
name|hd
operator|->
name|hp_addr
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|le
operator|->
name|sc_addr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|le
operator|->
name|sc_addr
index|[
name|i
index|]
operator|=
operator|(
operator|*
operator|++
name|cp
operator|&
literal|0xF
operator|)
operator|<<
literal|4
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|le
operator|->
name|sc_addr
index|[
name|i
index|]
operator||=
operator|*
operator|++
name|cp
operator|&
literal|0xF
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"le%d: hardware address %s\n"
argument_list|,
name|hd
operator|->
name|hp_unit
argument_list|,
name|ether_sprintf
argument_list|(
name|le
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Setup for transmit/receive 	 */
name|ler2
operator|->
name|ler2_mode
operator|=
name|LE_MODE
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_rlen
operator|=
name|LE_RLEN
expr_stmt|;
name|ler2
operator|->
name|ler2_rdra
operator|=
operator|(
name|int
operator|)
name|lemem
operator|->
name|ler2_rmd
expr_stmt|;
name|ler2
operator|->
name|ler2_tlen
operator|=
name|LE_TLEN
expr_stmt|;
name|ler2
operator|->
name|ler2_tdra
operator|=
operator|(
name|int
operator|)
name|lemem
operator|->
name|ler2_tmd
expr_stmt|;
name|isrlink
argument_list|(
operator|&
name|le_isr
index|[
name|hd
operator|->
name|hp_unit
index|]
argument_list|)
expr_stmt|;
name|ler0
operator|->
name|ler0_status
operator|=
name|LE_IE
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|hd
operator|->
name|hp_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"le"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|leinit
expr_stmt|;
name|ifp
operator|->
name|if_reset
operator|=
name|lereset
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|leioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|lestart
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTICAST
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|ifp
operator|->
name|if_bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|MULTICAST
end_ifdef

begin_comment
comment|/*  * Setup the logical address filter  */
end_comment

begin_function
name|void
name|lesetladrf
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|le_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
specifier|volatile
name|struct
name|lereg2
modifier|*
name|ler2
init|=
name|sc
operator|->
name|sc_r2
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
specifier|register
name|struct
name|ether_multi
modifier|*
name|enm
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|u_long
name|crc
decl_stmt|;
specifier|register
name|u_long
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|ether_multistep
name|step
decl_stmt|;
comment|/* 	 * Set up multicast address filter by passing all multicast 	 * addresses through a crc generator, and then using the high 	 * order 6 bits as a index into the 64 bit logical address 	 * filter. The high order two bits select the word, while the 	 * rest of the bits select the bit within the word. 	 */
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_ALLMULTI
expr_stmt|;
name|ETHER_FIRST_MULTI
argument_list|(
name|step
argument_list|,
operator|&
name|sc
operator|->
name|sc_ac
argument_list|,
name|enm
argument_list|)
expr_stmt|;
while|while
condition|(
name|enm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|enm
operator|->
name|enm_addrlo
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|enm
operator|->
name|enm_addrhi
argument_list|,
sizeof|sizeof
argument_list|(
name|enm
operator|->
name|enm_addrlo
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We must listen to a range of multicast 			 * addresses. For now, just accept all 			 * multicasts, rather than trying to set only 			 * those filter bits needed to match the range. 			 * (At this time, the only use of address 			 * ranges is for IP multicast routing, for 			 * which the range is big enough to require all 			 * bits set.) 			 */
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|0
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|1
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
return|return;
block|}
name|cp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|enm
operator|->
name|enm_addrlo
expr_stmt|;
name|c
operator|=
operator|*
name|cp
expr_stmt|;
name|crc
operator|=
literal|0xffffffff
expr_stmt|;
name|len
operator|=
literal|6
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|cp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|&
literal|0x01
operator|)
operator|^
operator|(
name|crc
operator|&
literal|0x01
operator|)
condition|)
block|{
name|crc
operator|>>=
literal|1
expr_stmt|;
name|crc
operator|=
name|crc
operator|^
literal|0xedb88320
expr_stmt|;
block|}
else|else
name|crc
operator|>>=
literal|1
expr_stmt|;
name|c
operator|>>=
literal|1
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
comment|/* Just want the 6 most significant bits. */
name|crc
operator|=
name|crc
operator|>>
literal|26
expr_stmt|;
comment|/* Turn on the corresponding bit in the filter. */
name|ler2
operator|->
name|ler2_ladrf
index|[
name|crc
operator|>>
literal|5
index|]
operator||=
literal|1
operator|<<
operator|(
name|crc
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|ETHER_NEXT_MULTI
argument_list|(
name|step
argument_list|,
name|enm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|ledrinit
argument_list|(
name|ler2
argument_list|,
name|le
argument_list|)
specifier|register
expr|struct
name|lereg2
operator|*
name|ler2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|le_softc
modifier|*
name|le
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|lereg2
modifier|*
name|lemem
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|ler2
operator|->
name|ler2_padr
index|[
literal|0
index|]
operator|=
name|le
operator|->
name|sc_addr
index|[
literal|1
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_padr
index|[
literal|1
index|]
operator|=
name|le
operator|->
name|sc_addr
index|[
literal|0
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_padr
index|[
literal|2
index|]
operator|=
name|le
operator|->
name|sc_addr
index|[
literal|3
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_padr
index|[
literal|3
index|]
operator|=
name|le
operator|->
name|sc_addr
index|[
literal|2
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_padr
index|[
literal|4
index|]
operator|=
name|le
operator|->
name|sc_addr
index|[
literal|5
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_padr
index|[
literal|5
index|]
operator|=
name|le
operator|->
name|sc_addr
index|[
literal|4
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LERBUF
condition|;
name|i
operator|++
control|)
block|{
name|ler2
operator|->
name|ler2_rmd
index|[
name|i
index|]
operator|.
name|rmd0
operator|=
operator|(
name|int
operator|)
name|lemem
operator|->
name|ler2_rbuf
index|[
name|i
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_rmd
index|[
name|i
index|]
operator|.
name|rmd1
operator|=
name|LE_OWN
expr_stmt|;
name|ler2
operator|->
name|ler2_rmd
index|[
name|i
index|]
operator|.
name|rmd2
operator|=
operator|-
name|LEMTU
expr_stmt|;
name|ler2
operator|->
name|ler2_rmd
index|[
name|i
index|]
operator|.
name|rmd3
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LETBUF
condition|;
name|i
operator|++
control|)
block|{
name|ler2
operator|->
name|ler2_tmd
index|[
name|i
index|]
operator|.
name|tmd0
operator|=
operator|(
name|int
operator|)
name|lemem
operator|->
name|ler2_tbuf
index|[
name|i
index|]
expr_stmt|;
name|ler2
operator|->
name|ler2_tmd
index|[
name|i
index|]
operator|.
name|tmd1
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_tmd
index|[
name|i
index|]
operator|.
name|tmd2
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_tmd
index|[
name|i
index|]
operator|.
name|tmd3
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Setup the logical address filter */
ifdef|#
directive|ifdef
name|MULTICAST
name|lesetladrf
argument_list|(
name|le
argument_list|)
expr_stmt|;
else|#
directive|else
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ler2
operator|->
name|ler2_ladrf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|lereset
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|lereg0
modifier|*
name|ler0
init|=
name|le
operator|->
name|sc_r0
decl_stmt|;
specifier|register
name|struct
name|lereg1
modifier|*
name|ler1
init|=
name|le
operator|->
name|sc_r1
decl_stmt|;
specifier|register
name|struct
name|lereg2
modifier|*
name|lemem
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|timo
init|=
literal|100000
decl_stmt|;
specifier|register
name|int
name|stat
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|stat
operator|=
name|unit
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
comment|/* set the promiscuous bit */
name|le
operator|->
name|sc_r2
operator|->
name|ler2_mode
operator|=
name|LE_MODE
operator||
literal|0x8000
expr_stmt|;
else|else
name|le
operator|->
name|sc_r2
operator|->
name|ler2_mode
operator|=
name|LE_MODE
expr_stmt|;
endif|#
directive|endif
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_CSR0
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_STOP
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|ledrinit
argument_list|(
name|le
operator|->
name|sc_r2
argument_list|,
name|le
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_rmd
operator|=
name|le
operator|->
name|sc_tmd
operator|=
literal|0
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_CSR1
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|lemem
operator|->
name|ler2_mode
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_CSR2
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
literal|0
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_CSR0
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_INIT
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|--
name|timo
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"le%d: init timeout, stat = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
block|}
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|stat
operator|&
name|LE_IDON
operator|)
operator|==
literal|0
condition|)
do|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_STOP
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_CSR3
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_BSWP
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_CSR0
argument_list|,
name|ler1
operator|->
name|ler1_rap
argument_list|)
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_STRT
operator||
name|LE_INEA
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|le
operator|->
name|sc_txcnt
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialization of interface  */
end_comment

begin_macro
name|leinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
operator|.
name|sc_if
decl_stmt|;
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* not yet, if address still unknown */
for|for
control|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
init|;
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
if|if
condition|(
name|ifa
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|&&
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
break|break;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lestart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Start output on interface.  Get another datagram to send  * off of the interface queue, and copy it to the interface  * before starting the output.  */
end_comment

begin_macro
name|lestart
argument_list|(
argument|ifp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|letmd
modifier|*
name|tmd
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tmd
operator|=
operator|&
name|le
operator|->
name|sc_r2
operator|->
name|ler2_tmd
index|[
name|le
operator|->
name|sc_tmd
index|]
expr_stmt|;
do|do
block|{
if|if
condition|(
name|tmd
operator|->
name|tmd1
operator|&
name|LE_OWN
condition|)
block|{
name|le
operator|->
name|sc_xown2
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|le
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|len
operator|=
name|leput
argument_list|(
name|le
operator|->
name|sc_r2
operator|->
name|ler2_tbuf
index|[
name|le
operator|->
name|sc_tmd
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/*  		 * If bpf is listening on this interface, let it  		 * see the packet before we commit it to the wire. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_tap
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|,
name|le
operator|->
name|sc_r2
operator|->
name|ler2_tbuf
index|[
name|le
operator|->
name|sc_tmd
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmd
operator|->
name|tmd3
operator|=
literal|0
expr_stmt|;
name|tmd
operator|->
name|tmd2
operator|=
operator|-
name|len
expr_stmt|;
name|tmd
operator|->
name|tmd1
operator|=
name|LE_OWN
operator||
name|LE_STP
operator||
name|LE_ENP
expr_stmt|;
if|if
condition|(
operator|++
name|le
operator|->
name|sc_tmd
operator|==
name|LETBUF
condition|)
block|{
name|le
operator|->
name|sc_tmd
operator|=
literal|0
expr_stmt|;
name|tmd
operator|=
name|le
operator|->
name|sc_r2
operator|->
name|ler2_tmd
expr_stmt|;
block|}
else|else
name|tmd
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|le
operator|->
name|sc_txcnt
operator|<
name|LETBUF
condition|)
do|;
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|leintr
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|lereg0
modifier|*
name|ler0
init|=
name|le
operator|->
name|sc_r0
decl_stmt|;
specifier|register
name|struct
name|lereg1
modifier|*
name|ler1
decl_stmt|;
specifier|register
name|int
name|stat
decl_stmt|;
if|if
condition|(
operator|(
name|ler0
operator|->
name|ler0_status
operator|&
name|LE_IR
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ler0
operator|->
name|ler0_status
operator|&
name|LE_JAB
condition|)
block|{
name|le
operator|->
name|sc_jab
operator|++
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ler1
operator|=
name|le
operator|->
name|sc_r1
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|LE_SERR
condition|)
block|{
name|leerror
argument_list|(
name|unit
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|LE_MERR
condition|)
block|{
name|le
operator|->
name|sc_merr
operator|++
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|stat
operator|&
name|LE_BABL
condition|)
name|le
operator|->
name|sc_babl
operator|++
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|LE_CERR
condition|)
name|le
operator|->
name|sc_cerr
operator|++
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|LE_MISS
condition|)
name|le
operator|->
name|sc_miss
operator|++
expr_stmt|;
name|LERDWR
argument_list|(
name|ler0
argument_list|,
name|LE_BABL
operator||
name|LE_CERR
operator||
name|LE_MISS
operator||
name|LE_INEA
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|LE_RXON
operator|)
operator|==
literal|0
condition|)
block|{
name|le
operator|->
name|sc_rxoff
operator|++
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|LE_TXON
operator|)
operator|==
literal|0
condition|)
block|{
name|le
operator|->
name|sc_txoff
operator|++
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|stat
operator|&
name|LE_RINT
condition|)
name|lerint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|LE_TINT
condition|)
name|lexint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Ethernet interface transmitter interrupt.  * Start another output if more data to send.  */
end_comment

begin_expr_stmt
name|lexint
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|letmd
modifier|*
name|tmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|gotone
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|USELEDS
if|if
condition|(
name|inledcontrol
operator|==
literal|0
condition|)
name|ledcontrol
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|LED_LANXMT
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|le
operator|->
name|sc_tmd
operator|-
name|le
operator|->
name|sc_txcnt
operator|)
operator|<
literal|0
condition|)
name|i
operator|+=
name|LETBUF
expr_stmt|;
name|tmd
operator|=
operator|&
name|le
operator|->
name|sc_r2
operator|->
name|ler2_tmd
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tmd
operator|->
name|tmd1
operator|&
name|LE_OWN
condition|)
block|{
if|if
condition|(
name|gotone
condition|)
break|break;
name|le
operator|->
name|sc_xown
operator|++
expr_stmt|;
return|return;
block|}
comment|/* clear interrupt */
name|LERDWR
argument_list|(
name|le
operator|->
name|sc_r0
argument_list|,
name|LE_TINT
operator||
name|LE_INEA
argument_list|,
name|le
operator|->
name|sc_r1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
comment|/* XXX documentation says BUFF not included in ERR */
if|if
condition|(
operator|(
name|tmd
operator|->
name|tmd1
operator|&
name|LE_ERR
operator|)
operator|||
operator|(
name|tmd
operator|->
name|tmd3
operator|&
name|LE_TBUFF
operator|)
condition|)
block|{
name|lexerror
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|tmd
operator|->
name|tmd3
operator|&
operator|(
name|LE_TBUFF
operator||
name|LE_UFLO
operator|)
condition|)
block|{
name|le
operator|->
name|sc_uflo
operator|++
expr_stmt|;
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmd
operator|->
name|tmd3
operator|&
name|LE_LCOL
condition|)
name|le
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|tmd
operator|->
name|tmd3
operator|&
name|LE_RTRY
condition|)
name|le
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmd
operator|->
name|tmd1
operator|&
name|LE_ONE
condition|)
name|le
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|tmd
operator|->
name|tmd1
operator|&
name|LE_MORE
condition|)
comment|/* what is the real number? */
name|le
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
literal|2
expr_stmt|;
else|else
name|le
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|gotone
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|le
operator|->
name|sc_txcnt
operator|>
literal|0
condition|)
do|;
name|le
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
operator|(
name|void
operator|)
name|lestart
argument_list|(
operator|&
name|le
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|LENEXTRMP
define|\
value|if (++bix == LERBUF) bix = 0, rmd = le->sc_r2->ler2_rmd; else ++rmd
end_define

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  * If input error just drop packet.  * Decapsulate packet based on type and pass to type specific  * higher-level input routine.  */
end_comment

begin_macro
name|lerint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|bix
init|=
name|le
operator|->
name|sc_rmd
decl_stmt|;
specifier|register
name|struct
name|lermd
modifier|*
name|rmd
init|=
operator|&
name|le
operator|->
name|sc_r2
operator|->
name|ler2_rmd
index|[
name|bix
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|USELEDS
if|if
condition|(
name|inledcontrol
operator|==
literal|0
condition|)
name|ledcontrol
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|LED_LANRCV
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Out of sync with hardware, should never happen? 	 */
if|if
condition|(
name|rmd
operator|->
name|rmd1
operator|&
name|LE_OWN
condition|)
block|{
name|le
operator|->
name|sc_rown
operator|++
expr_stmt|;
name|LERDWR
argument_list|(
name|le
operator|->
name|sc_r0
argument_list|,
name|LE_RINT
operator||
name|LE_INEA
argument_list|,
name|le
operator|->
name|sc_r1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Process all buffers with valid data 	 */
while|while
condition|(
operator|(
name|rmd
operator|->
name|rmd1
operator|&
name|LE_OWN
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
init|=
name|rmd
operator|->
name|rmd3
decl_stmt|;
comment|/* Clear interrupt to avoid race condition */
name|LERDWR
argument_list|(
name|le
operator|->
name|sc_r0
argument_list|,
name|LE_RINT
operator||
name|LE_INEA
argument_list|,
name|le
operator|->
name|sc_r1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmd
operator|->
name|rmd1
operator|&
name|LE_ERR
condition|)
block|{
name|le
operator|->
name|sc_rmd
operator|=
name|bix
expr_stmt|;
name|lererror
argument_list|(
name|unit
argument_list|,
literal|"bad packet"
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rmd
operator|->
name|rmd1
operator|&
operator|(
name|LE_STP
operator||
name|LE_ENP
operator|)
operator|)
operator|!=
operator|(
name|LE_STP
operator||
name|LE_ENP
operator|)
condition|)
block|{
comment|/* 			 * Find the end of the packet so we can see how long 			 * it was.  We still throw it away. 			 */
do|do
block|{
name|LERDWR
argument_list|(
name|le
operator|->
name|sc_r0
argument_list|,
name|LE_RINT
operator||
name|LE_INEA
argument_list|,
name|le
operator|->
name|sc_r1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|rmd
operator|->
name|rmd3
operator|=
literal|0
expr_stmt|;
name|rmd
operator|->
name|rmd1
operator|=
name|LE_OWN
expr_stmt|;
name|LENEXTRMP
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|rmd
operator|->
name|rmd1
operator|&
operator|(
name|LE_OWN
operator||
name|LE_ERR
operator||
name|LE_STP
operator||
name|LE_ENP
operator|)
operator|)
condition|)
do|;
name|le
operator|->
name|sc_rmd
operator|=
name|bix
expr_stmt|;
name|lererror
argument_list|(
name|unit
argument_list|,
literal|"chained buffer"
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_rxlen
operator|++
expr_stmt|;
comment|/* 			 * If search terminated without successful completion 			 * we reset the hardware (conservative). 			 */
if|if
condition|(
operator|(
name|rmd
operator|->
name|rmd1
operator|&
operator|(
name|LE_OWN
operator||
name|LE_ERR
operator||
name|LE_STP
operator||
name|LE_ENP
operator|)
operator|)
operator|!=
name|LE_ENP
condition|)
block|{
name|lereset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|leread
argument_list|(
name|unit
argument_list|,
name|le
operator|->
name|sc_r2
operator|->
name|ler2_rbuf
index|[
name|bix
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rmd
operator|->
name|rmd3
operator|=
literal|0
expr_stmt|;
name|rmd
operator|->
name|rmd1
operator|=
name|LE_OWN
expr_stmt|;
name|LENEXTRMP
expr_stmt|;
block|}
name|le
operator|->
name|sc_rmd
operator|=
name|bix
expr_stmt|;
block|}
end_block

begin_macro
name|leread
argument_list|(
argument|unit
argument_list|,
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ether_header
modifier|*
name|et
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|,
name|resid
decl_stmt|,
name|flags
decl_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|et
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|buf
expr_stmt|;
name|et
operator|->
name|ether_type
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|et
operator|->
name|ether_type
argument_list|)
expr_stmt|;
comment|/* adjust input length to account for header and CRC */
name|len
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
literal|4
expr_stmt|;
define|#
directive|define
name|ledataaddr
parameter_list|(
name|et
parameter_list|,
name|off
parameter_list|,
name|type
parameter_list|)
value|((type)(((caddr_t)((et)+1)+(off))))
if|if
condition|(
name|et
operator|->
name|ether_type
operator|>=
name|ETHERTYPE_TRAIL
operator|&&
name|et
operator|->
name|ether_type
operator|<
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
condition|)
block|{
name|off
operator|=
operator|(
name|et
operator|->
name|ether_type
operator|-
name|ETHERTYPE_TRAIL
operator|)
operator|*
literal|512
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|ETHERMTU
condition|)
return|return;
comment|/* sanity */
name|et
operator|->
name|ether_type
operator|=
name|ntohs
argument_list|(
operator|*
name|ledataaddr
argument_list|(
name|et
argument_list|,
name|off
argument_list|,
name|u_short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|resid
operator|=
name|ntohs
argument_list|(
operator|*
operator|(
name|ledataaddr
argument_list|(
name|et
argument_list|,
name|off
operator|+
literal|2
argument_list|,
name|u_short
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|resid
operator|>
name|len
condition|)
return|return;
comment|/* sanity */
name|len
operator|=
name|off
operator|+
name|resid
expr_stmt|;
block|}
else|else
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|ledebug
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"le%d: ierror(runt packet): from %s: len=%d\n"
argument_list|,
name|unit
argument_list|,
name|ether_sprintf
argument_list|(
name|et
operator|->
name|ether_shost
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|le
operator|->
name|sc_runt
operator|++
expr_stmt|;
name|le
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|etherbroadcastaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|et
operator|->
name|ether_dhost
argument_list|,
sizeof|sizeof
argument_list|(
name|etherbroadcastaddr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|M_BCAST
expr_stmt|;
if|if
condition|(
name|et
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
condition|)
name|flags
operator||=
name|M_MCAST
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Check if there's a bpf filter listening on this interface. 	 * If so, hand off the raw packet to enet. 	 */
if|if
condition|(
name|le
operator|->
name|sc_if
operator|.
name|if_bpf
condition|)
block|{
name|bpf_tap
argument_list|(
name|le
operator|->
name|sc_if
operator|.
name|if_bpf
argument_list|,
name|buf
argument_list|,
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Keep the packet if it's a broadcast or has our 		 * physical ethernet address (or if we support 		 * multicast and it's one). 		 */
if|if
condition|(
ifdef|#
directive|ifdef
name|MULTICAST
operator|(
name|flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
operator|&&
else|#
directive|else
operator|(
name|flags
operator|&
name|M_BCAST
operator|)
operator|==
literal|0
operator|&&
endif|#
directive|endif
name|bcmp
argument_list|(
name|et
operator|->
name|ether_dhost
argument_list|,
name|le
operator|->
name|sc_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|et
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Pull packet off interface.  Off is nonzero if packet 	 * has trailing header; m_devget will then force this header 	 * information to be at the front, but we still have to drop 	 * the type and length which are at the front of any trailer data. 	 */
name|m
operator|=
name|m_devget
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|et
operator|+
literal|1
operator|)
argument_list|,
name|len
argument_list|,
name|off
argument_list|,
operator|&
name|le
operator|->
name|sc_if
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|m
operator|->
name|m_flags
operator||=
name|flags
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|le
operator|->
name|sc_if
argument_list|,
name|et
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Routine to copy from mbuf chain to transmit  * buffer in board local memory.  */
end_comment

begin_expr_stmt
name|leput
argument_list|(
name|lebuf
argument_list|,
name|m
argument_list|)
specifier|register
name|char
operator|*
name|lebuf
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|tlen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
name|len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
name|tlen
operator|+=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|mp
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|lebuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lebuf
operator|+=
name|len
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|<
name|LEMINSIZE
condition|)
block|{
name|bzero
argument_list|(
name|lebuf
argument_list|,
name|LEMINSIZE
operator|-
name|tlen
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|LEMINSIZE
expr_stmt|;
block|}
return|return
operator|(
name|tlen
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_expr_stmt
name|leioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|lereg1
modifier|*
name|ler1
init|=
name|le
operator|->
name|sc_r1
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|le
operator|->
name|sc_addr
operator|)
expr_stmt|;
else|else
block|{
comment|/*  				 * The manual says we can't change the address  				 * while the receiver is armed, 				 * so reset everything 				 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|LERDWR
argument_list|(
name|le
operator|->
name|sc_r0
argument_list|,
name|LE_STOP
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|le
operator|->
name|sc_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|le
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* does le_setaddr() */
break|break;
block|}
endif|#
directive|endif
default|default:
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
if|#
directive|if
name|defined
argument_list|(
name|CCITT
argument_list|)
operator|&&
name|defined
argument_list|(
name|LLC
argument_list|)
case|case
name|SIOCSIFCONF_X25
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|ifa
operator|->
name|ifa_rtrequest
operator|=
name|cons_rtrequest
expr_stmt|;
name|error
operator|=
name|x25_llcglue
argument_list|(
name|PRC_IFUP
argument_list|,
name|ifa
operator|->
name|ifa_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* CCITT&& LLC */
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|LERDWR
argument_list|(
name|le
operator|->
name|sc_r0
argument_list|,
name|LE_STOP
argument_list|,
name|ler1
operator|->
name|ler1_rdp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|leinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* 		 * If the state of the promiscuous bit changes, the interface 		 * must be reset to effect the change. 		 */
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|le
operator|->
name|sc_iflags
operator|)
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|le
operator|->
name|sc_iflags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|lereset
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|lestart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|MULTICAST
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* Update our multicast list  */
name|error
operator|=
operator|(
name|cmd
operator|==
name|SIOCADDMULTI
operator|)
condition|?
name|ether_addmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|le
operator|->
name|sc_ac
argument_list|)
else|:
name|ether_delmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|le
operator|->
name|sc_ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
comment|/* 			 * Multicast list has changed; set the hardware 			 * filter accordingly. 			 */
name|lereset
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|leerror
argument_list|(
argument|unit
argument_list|,
argument|stat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stat
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|ledebug
condition|)
return|return;
comment|/* 	 * Not all transceivers implement heartbeat 	 * so we only log CERR once. 	 */
if|if
condition|(
operator|(
name|stat
operator|&
name|LE_CERR
operator|)
operator|&&
name|le_softc
index|[
name|unit
index|]
operator|.
name|sc_cerr
condition|)
return|return;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"le%d: error: stat=%b\n"
argument_list|,
name|unit
argument_list|,
name|stat
argument_list|,
literal|"\20\20ERR\17BABL\16CERR\15MISS\14MERR\13RINT\12TINT\11IDON\10INTR\07INEA\06RXON\05TXON\04TDMD\03STOP\02STRT\01INIT"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lererror
argument_list|(
argument|unit
argument_list|,
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|lermd
modifier|*
name|rmd
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ledebug
condition|)
return|return;
name|rmd
operator|=
operator|&
name|le
operator|->
name|sc_r2
operator|->
name|ler2_rmd
index|[
name|le
operator|->
name|sc_rmd
index|]
expr_stmt|;
name|len
operator|=
name|rmd
operator|->
name|rmd3
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"le%d: ierror(%s): from %s: buf=%d, len=%d, rmd1=%b\n"
argument_list|,
name|unit
argument_list|,
name|msg
argument_list|,
name|len
operator|>
literal|11
condition|?
name|ether_sprintf
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|le
operator|->
name|sc_r2
operator|->
name|ler2_rbuf
index|[
name|le
operator|->
name|sc_rmd
index|]
index|[
literal|6
index|]
argument_list|)
else|:
literal|"unknown"
argument_list|,
name|le
operator|->
name|sc_rmd
argument_list|,
name|len
argument_list|,
name|rmd
operator|->
name|rmd1
argument_list|,
literal|"\20\20OWN\17ERR\16FRAM\15OFLO\14CRC\13RBUF\12STP\11ENP"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lexerror
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|le_softc
modifier|*
name|le
init|=
operator|&
name|le_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|letmd
modifier|*
name|tmd
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ledebug
condition|)
return|return;
name|tmd
operator|=
name|le
operator|->
name|sc_r2
operator|->
name|ler2_tmd
expr_stmt|;
name|len
operator|=
operator|-
name|tmd
operator|->
name|tmd2
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"le%d: oerror: to %s: buf=%d, len=%d, tmd1=%b, tmd3=%b\n"
argument_list|,
name|unit
argument_list|,
name|len
operator|>
literal|5
condition|?
name|ether_sprintf
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|le
operator|->
name|sc_r2
operator|->
name|ler2_tbuf
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
else|:
literal|"unknown"
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|tmd
operator|->
name|tmd1
argument_list|,
literal|"\20\20OWN\17ERR\16RES\15MORE\14ONE\13DEF\12STP\11ENP"
argument_list|,
name|tmd
operator|->
name|tmd3
argument_list|,
literal|"\20\20BUFF\17UFLO\16RES\15LCOL\14LCAR\13RTRY"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

