begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1990 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)dma.c	7.1 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * DMA driver  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"dmareg.h"
end_include

begin_include
include|#
directive|include
file|"dmavar.h"
end_include

begin_include
include|#
directive|include
file|"device.h"
end_include

begin_include
include|#
directive|include
file|"machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"machine/isr.h"
end_include

begin_function_decl
specifier|extern
name|void
name|isrlink
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|printf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|panic
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_insque
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_remque
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|timeout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|splbio
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|splx
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int
name|kvtop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|PCIA
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * The largest single request will be MAXPHYS bytes which will require  * at most MAXPHYS/NBPG+1 chain elements to describe, i.e. if none of  * the buffer pages are physically contiguous (MAXPHYS/NBPG) and the  * buffer is not page aligned (+1).  */
end_comment

begin_define
define|#
directive|define
name|DMAMAXIO
value|(MAXPHYS/NBPG+1)
end_define

begin_define
define|#
directive|define
name|DMATIMO
value|15
end_define

begin_struct
struct|struct
name|dma_softc
block|{
name|struct
name|dmadevice
modifier|*
name|sc_hwaddr
decl_stmt|;
name|struct
name|dmaBdevice
modifier|*
name|sc_Bhwaddr
decl_stmt|;
name|int
name|sc_type
decl_stmt|;
name|int
name|sc_cur
decl_stmt|;
name|int
name|sc_cmd
decl_stmt|;
name|int
name|sc_timo
decl_stmt|;
name|int
name|sc_count
index|[
name|DMAMAXIO
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|sc_addr
index|[
name|DMAMAXIO
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|dma_softc
index|[
name|NDMA
index|]
struct|;
end_struct

begin_comment
comment|/* types */
end_comment

begin_define
define|#
directive|define
name|DMA_B
value|0
end_define

begin_define
define|#
directive|define
name|DMA_C
value|1
end_define

begin_decl_stmt
name|struct
name|devqueue
name|dmachan
index|[
name|NDMA
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|dmaintr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmatimo
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|dmadebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DDB_WORD
value|0x01
end_define

begin_comment
comment|/* same as DMAGO_WORD */
end_comment

begin_define
define|#
directive|define
name|DDB_LWORD
value|0x02
end_define

begin_comment
comment|/* same as DMAGO_LWORD */
end_comment

begin_define
define|#
directive|define
name|DDB_FOLLOW
value|0x04
end_define

begin_define
define|#
directive|define
name|DDB_IO
value|0x08
end_define

begin_decl_stmt
name|long
name|dmahits
index|[
name|NDMA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dmamisses
index|[
name|NDMA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dmabyte
index|[
name|NDMA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dmaword
index|[
name|NDMA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dmalword
index|[
name|NDMA
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|dmainit
parameter_list|()
block|{
specifier|register
name|struct
name|dmareg
modifier|*
name|dma
init|=
operator|(
expr|struct
name|dmareg
operator|*
operator|)
name|DMA_BASE
decl_stmt|;
specifier|register
name|struct
name|dma_softc
modifier|*
name|dc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|rev
decl_stmt|;
comment|/* 	 * Determine the DMA type. 	 * Don't know how to easily differentiate the A and B cards, 	 * so we just hope nobody has an A card (A cards will work if 	 * DMAINTLVL is set to 3). 	 */
if|if
condition|(
operator|!
name|badbaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_id
index|[
literal|2
index|]
argument_list|)
condition|)
name|rev
operator|=
name|dma
operator|->
name|dma_id
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
name|rev
operator|=
literal|'B'
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HP320
argument_list|)
name|panic
argument_list|(
literal|"dmainit: DMA card requires hp320 support"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|dc
operator|=
operator|&
name|dma_softc
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDMA
condition|;
name|i
operator|++
control|)
block|{
name|dc
operator|->
name|sc_hwaddr
operator|=
operator|(
name|i
operator|&
literal|1
operator|)
condition|?
operator|&
name|dma
operator|->
name|dma_chan1
else|:
operator|&
name|dma
operator|->
name|dma_chan0
expr_stmt|;
name|dc
operator|->
name|sc_Bhwaddr
operator|=
operator|(
name|i
operator|&
literal|1
operator|)
condition|?
operator|&
name|dma
operator|->
name|dma_Bchan1
else|:
operator|&
name|dma
operator|->
name|dma_Bchan0
expr_stmt|;
name|dc
operator|->
name|sc_type
operator|=
name|rev
operator|==
literal|'B'
condition|?
name|DMA_B
else|:
name|DMA_C
expr_stmt|;
name|dc
operator|++
expr_stmt|;
name|dmachan
index|[
name|i
index|]
operator|.
name|dq_forw
operator|=
name|dmachan
index|[
name|i
index|]
operator|.
name|dq_back
operator|=
operator|&
name|dmachan
index|[
name|i
index|]
expr_stmt|;
block|}
name|dmachan
index|[
name|i
index|]
operator|.
name|dq_forw
operator|=
name|dmachan
index|[
name|i
index|]
operator|.
name|dq_back
operator|=
operator|&
name|dmachan
index|[
name|i
index|]
expr_stmt|;
name|timeout
argument_list|(
name|dmatimo
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|DMATIMO
operator|*
name|hz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dma: 98620%c with 2 channels, %d bit DMA\n"
argument_list|,
name|rev
argument_list|,
name|rev
operator|==
literal|'B'
condition|?
literal|16
else|:
literal|32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmareq
parameter_list|(
name|dq
parameter_list|)
specifier|register
name|struct
name|devqueue
modifier|*
name|dq
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|chan
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|chan
operator|=
name|dq
operator|->
name|dq_ctlr
expr_stmt|;
name|i
operator|=
name|NDMA
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|chan
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dmachan
index|[
name|i
index|]
operator|.
name|dq_forw
operator|!=
operator|&
name|dmachan
index|[
name|i
index|]
condition|)
continue|continue;
name|insque
argument_list|(
name|dq
argument_list|,
operator|&
name|dmachan
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dq
operator|->
name|dq_ctlr
operator|=
name|i
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|insque
argument_list|(
name|dq
argument_list|,
name|dmachan
index|[
name|NDMA
index|]
operator|.
name|dq_back
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmafree
parameter_list|(
name|dq
parameter_list|)
specifier|register
name|struct
name|devqueue
modifier|*
name|dq
decl_stmt|;
block|{
name|int
name|unit
init|=
name|dq
operator|->
name|dq_ctlr
decl_stmt|;
specifier|register
name|struct
name|dma_softc
modifier|*
name|dc
init|=
operator|&
name|dma_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|devqueue
modifier|*
name|dn
decl_stmt|;
specifier|register
name|int
name|chan
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|dc
operator|->
name|sc_timo
operator|=
literal|0
expr_stmt|;
name|DMA_CLEAR
argument_list|(
name|dc
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|dq
argument_list|)
expr_stmt|;
name|chan
operator|=
literal|1
operator|<<
name|unit
expr_stmt|;
for|for
control|(
name|dn
operator|=
name|dmachan
index|[
name|NDMA
index|]
operator|.
name|dq_forw
init|;
name|dn
operator|!=
operator|&
name|dmachan
index|[
name|NDMA
index|]
condition|;
name|dn
operator|=
name|dn
operator|->
name|dq_forw
control|)
block|{
if|if
condition|(
name|dn
operator|->
name|dq_ctlr
operator|&
name|chan
condition|)
block|{
name|remque
argument_list|(
operator|(
name|caddr_t
operator|)
name|dn
argument_list|)
expr_stmt|;
name|insque
argument_list|(
operator|(
name|caddr_t
operator|)
name|dn
argument_list|,
operator|(
name|caddr_t
operator|)
name|dq
operator|->
name|dq_back
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dq_ctlr
operator|=
name|dq
operator|->
name|dq_ctlr
expr_stmt|;
call|(
name|dn
operator|->
name|dq_driver
operator|->
name|d_start
call|)
argument_list|(
name|dn
operator|->
name|dq_unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmago
parameter_list|(
name|unit
parameter_list|,
name|addr
parameter_list|,
name|count
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|;
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|struct
name|dma_softc
modifier|*
name|dc
init|=
operator|&
name|dma_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|dmaend
init|=
name|NULL
decl_stmt|;
specifier|register
name|int
name|tcount
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dmadebug
operator|&
name|DDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"dmago(%d, %x, %x, %x)\n"
argument_list|,
name|unit
argument_list|,
name|addr
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DMAGO_LWORD
condition|)
name|dmalword
index|[
name|unit
index|]
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DMAGO_WORD
condition|)
name|dmaword
index|[
name|unit
index|]
operator|++
expr_stmt|;
else|else
name|dmabyte
index|[
name|unit
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HP320
argument_list|)
if|if
condition|(
name|dc
operator|->
name|sc_type
operator|==
name|DMA_B
operator|&&
operator|(
name|flags
operator|&
name|DMAGO_LWORD
operator|)
condition|)
name|panic
argument_list|(
literal|"dmago: no can do 32-bit DMA"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Build the DMA chain 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DMAMAXIO
operator|&&
name|count
condition|;
name|i
operator|++
control|)
block|{
name|dc
operator|->
name|sc_addr
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|kvtop
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|tcount
operator|=
name|dc
operator|->
name|sc_count
index|[
name|i
index|]
operator|=
name|MIN
argument_list|(
name|count
argument_list|,
name|NBPG
operator|-
operator|(
operator|(
name|int
operator|)
name|addr
operator|&
name|PGOFSET
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|dc
operator|->
name|sc_count
index|[
name|i
index|]
expr_stmt|;
name|count
operator|-=
name|tcount
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|DMAGO_WORD
operator||
name|DMAGO_LWORD
operator|)
condition|)
name|tcount
operator|>>=
operator|(
name|flags
operator|&
name|DMAGO_WORD
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
if|if
condition|(
name|dc
operator|->
name|sc_addr
index|[
name|i
index|]
operator|==
name|dmaend
if|#
directive|if
name|defined
argument_list|(
name|HP320
argument_list|)
comment|/* only 16-bit count on 98620B */
operator|&&
operator|(
name|dc
operator|->
name|sc_type
operator|!=
name|DMA_B
operator|||
name|dc
operator|->
name|sc_count
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|tcount
operator|<=
literal|65536
operator|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dmahits
index|[
name|unit
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|dmaend
operator|+=
name|dc
operator|->
name|sc_count
index|[
name|i
index|]
expr_stmt|;
name|dc
operator|->
name|sc_count
index|[
name|i
operator|-
literal|1
index|]
operator|+=
name|tcount
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dmamisses
index|[
name|unit
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|dmaend
operator|=
name|dc
operator|->
name|sc_addr
index|[
name|i
index|]
operator|+
name|dc
operator|->
name|sc_count
index|[
name|i
index|]
expr_stmt|;
name|dc
operator|->
name|sc_count
index|[
name|i
index|]
operator|=
name|tcount
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
condition|)
name|panic
argument_list|(
literal|"dmago maxphys"
argument_list|)
expr_stmt|;
name|dc
operator|->
name|sc_count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|dc
operator|->
name|sc_cur
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set up the command word based on flags 	 */
name|dc
operator|->
name|sc_cmd
operator|=
name|DMA_ENAB
operator||
name|DMA_IPL
argument_list|(
name|DMAINTLVL
argument_list|)
operator||
name|DMA_START
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAGO_READ
operator|)
operator|==
literal|0
condition|)
name|dc
operator|->
name|sc_cmd
operator||=
name|DMA_WRT
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DMAGO_LWORD
condition|)
name|dc
operator|->
name|sc_cmd
operator||=
name|DMA_LWORD
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DMAGO_WORD
condition|)
name|dc
operator|->
name|sc_cmd
operator||=
name|DMA_WORD
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DMAGO_PRI
condition|)
name|dc
operator|->
name|sc_cmd
operator||=
name|DMA_PRI
expr_stmt|;
comment|/* 	 * We should be able to skip the dma completion interrupt 	 * if we only have one segment in the chain since many 	 * devices generate their own completion interrupt. 	 * However, on a 370 we have to take the interrupt on 	 * read transfers to invalidate the external cache. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAGO_NOINT
operator|)
operator|&&
name|i
operator|==
literal|1
if|#
directive|if
name|defined
argument_list|(
name|HP370
argument_list|)
operator|&&
operator|(
operator|(
name|flags
operator|&
name|DMAGO_READ
operator|)
operator|==
literal|0
operator|||
name|ectype
operator|!=
name|EC_PHYS
operator|)
endif|#
directive|endif
condition|)
name|dc
operator|->
name|sc_cmd
operator|&=
operator|~
name|DMA_ENAB
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|#
directive|if
name|defined
argument_list|(
name|HP320
argument_list|)
comment|/* would this hurt? */
if|if
condition|(
name|dc
operator|->
name|sc_type
operator|==
name|DMA_B
condition|)
name|dc
operator|->
name|sc_cmd
operator|&=
operator|~
name|DMA_START
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dmadebug
operator|&
name|DDB_IO
condition|)
if|if
condition|(
operator|(
name|dmadebug
operator|&
name|DDB_WORD
operator|)
operator|&&
operator|(
name|dc
operator|->
name|sc_cmd
operator|&
name|DMA_WORD
operator|)
operator|||
operator|(
name|dmadebug
operator|&
name|DDB_LWORD
operator|)
operator|&&
operator|(
name|dc
operator|->
name|sc_cmd
operator|&
name|DMA_LWORD
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"dmago: cmd %x\n"
argument_list|,
name|dc
operator|->
name|sc_cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dc
operator|->
name|sc_count
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"  %d: %d@%x\n"
argument_list|,
name|i
argument_list|,
name|dc
operator|->
name|sc_count
index|[
name|i
index|]
argument_list|,
name|dc
operator|->
name|sc_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Load and arm the channel 	 */
name|dc
operator|->
name|sc_timo
operator|=
literal|1
expr_stmt|;
name|DMA_ARM
argument_list|(
name|dc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmastop
parameter_list|(
name|unit
parameter_list|)
specifier|register
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|dma_softc
modifier|*
name|dc
init|=
operator|&
name|dma_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|devqueue
modifier|*
name|dq
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dmadebug
operator|&
name|DDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"dmastop(%d)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dc
operator|->
name|sc_timo
operator|=
literal|0
expr_stmt|;
name|DMA_CLEAR
argument_list|(
name|dc
argument_list|)
expr_stmt|;
comment|/* 	 * We may get this interrupt after a device service routine 	 * has freed the dma channel.  So, ignore the intr if there's 	 * nothing on the queue. 	 */
name|dq
operator|=
name|dmachan
index|[
name|unit
index|]
operator|.
name|dq_forw
expr_stmt|;
if|if
condition|(
name|dq
operator|!=
operator|&
name|dmachan
index|[
name|unit
index|]
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HP370
argument_list|)
comment|/* 		 * The 370 has an 64k external physical address cache. 		 * In theory, we should only need to flush it when 		 * DMAing to memory. 		 */
if|if
condition|(
name|ectype
operator|==
name|EC_PHYS
operator|&&
operator|(
name|dc
operator|->
name|sc_cmd
operator|&
name|DMA_WRT
operator|)
operator|==
literal|0
condition|)
name|PCIA
argument_list|()
expr_stmt|;
endif|#
directive|endif
call|(
name|dq
operator|->
name|dq_driver
operator|->
name|d_done
call|)
argument_list|(
name|dq
operator|->
name|dq_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|dmaintr
parameter_list|()
block|{
specifier|register
name|struct
name|dma_softc
modifier|*
name|dc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|stat
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dmadebug
operator|&
name|DDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"dmaintr\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dc
operator|=
name|dma_softc
init|;
name|i
operator|<
name|NDMA
condition|;
name|i
operator|++
operator|,
name|dc
operator|++
control|)
block|{
name|stat
operator|=
name|DMA_STAT
argument_list|(
name|dc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|DMA_INTR
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|found
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dmadebug
operator|&
name|DDB_IO
condition|)
block|{
if|if
condition|(
operator|(
name|dmadebug
operator|&
name|DDB_WORD
operator|)
operator|&&
operator|(
name|dc
operator|->
name|sc_cmd
operator|&
name|DMA_WORD
operator|)
operator|||
operator|(
name|dmadebug
operator|&
name|DDB_LWORD
operator|)
operator|&&
operator|(
name|dc
operator|->
name|sc_cmd
operator|&
name|DMA_LWORD
operator|)
condition|)
name|printf
argument_list|(
literal|"dmaintr: unit %d stat %x next %d\n"
argument_list|,
name|i
argument_list|,
name|stat
argument_list|,
name|dc
operator|->
name|sc_cur
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|DMA_ARMED
condition|)
name|printf
argument_list|(
literal|"dma%d: intr when armed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|j
operator|=
operator|++
name|dc
operator|->
name|sc_cur
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|DMAMAXIO
operator|&&
name|dc
operator|->
name|sc_count
index|[
name|j
index|]
condition|)
block|{
name|dc
operator|->
name|sc_timo
operator|=
literal|1
expr_stmt|;
name|DMA_CLEAR
argument_list|(
name|dc
argument_list|)
expr_stmt|;
name|DMA_ARM
argument_list|(
name|dc
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
else|else
name|dmastop
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmatimo
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
specifier|register
name|struct
name|dma_softc
modifier|*
name|dc
init|=
operator|&
name|dma_softc
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDMA
condition|;
name|i
operator|++
operator|,
name|dc
operator|++
control|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|dc
operator|->
name|sc_timo
condition|)
block|{
if|if
condition|(
name|dc
operator|->
name|sc_timo
operator|==
literal|1
condition|)
name|dc
operator|->
name|sc_timo
operator|++
expr_stmt|;
else|else
name|dmastop
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
name|dmatimo
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|DMATIMO
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

