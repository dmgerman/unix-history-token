begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1990 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)dma.c	7.7 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * DMA driver  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/dmareg.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/dmavar.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<hp300/hp300/isr.h>
end_include

begin_function_decl
specifier|extern
name|void
name|isrlink
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_insque
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_remque
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|timeout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int
name|kvtop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|PCIA
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * The largest single request will be MAXPHYS bytes which will require  * at most MAXPHYS/NBPG+1 chain elements to describe, i.e. if none of  * the buffer pages are physically contiguous (MAXPHYS/NBPG) and the  * buffer is not page aligned (+1).  */
end_comment

begin_define
define|#
directive|define
name|DMAMAXIO
value|(MAXPHYS/NBPG+1)
end_define

begin_struct
struct|struct
name|dma_chain
block|{
name|int
name|dc_count
decl_stmt|;
name|char
modifier|*
name|dc_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dma_softc
block|{
name|struct
name|dmadevice
modifier|*
name|sc_hwaddr
decl_stmt|;
name|struct
name|dmaBdevice
modifier|*
name|sc_Bhwaddr
decl_stmt|;
name|char
name|sc_type
decl_stmt|;
name|char
name|sc_flags
decl_stmt|;
name|u_short
name|sc_cmd
decl_stmt|;
name|struct
name|dma_chain
modifier|*
name|sc_cur
decl_stmt|;
name|struct
name|dma_chain
modifier|*
name|sc_last
decl_stmt|;
name|struct
name|dma_chain
name|sc_chain
index|[
name|DMAMAXIO
index|]
decl_stmt|;
block|}
name|dma_softc
index|[
name|NDMA
index|]
struct|;
end_struct

begin_comment
comment|/* types */
end_comment

begin_define
define|#
directive|define
name|DMA_B
value|0
end_define

begin_define
define|#
directive|define
name|DMA_C
value|1
end_define

begin_comment
comment|/* flags */
end_comment

begin_define
define|#
directive|define
name|DMAF_PCFLUSH
value|0x01
end_define

begin_define
define|#
directive|define
name|DMAF_VCFLUSH
value|0x02
end_define

begin_define
define|#
directive|define
name|DMAF_NOINTR
value|0x04
end_define

begin_decl_stmt
name|struct
name|devqueue
name|dmachan
index|[
name|NDMA
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|dmaintr
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|dmadebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DDB_WORD
value|0x01
end_define

begin_comment
comment|/* same as DMAGO_WORD */
end_comment

begin_define
define|#
directive|define
name|DDB_LWORD
value|0x02
end_define

begin_comment
comment|/* same as DMAGO_LWORD */
end_comment

begin_define
define|#
directive|define
name|DDB_FOLLOW
value|0x04
end_define

begin_define
define|#
directive|define
name|DDB_IO
value|0x08
end_define

begin_function_decl
name|void
name|dmatimeout
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|dmatimo
index|[
name|NDMA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dmahits
index|[
name|NDMA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dmamisses
index|[
name|NDMA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dmabyte
index|[
name|NDMA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dmaword
index|[
name|NDMA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dmalword
index|[
name|NDMA
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|dmainit
parameter_list|()
block|{
specifier|register
name|struct
name|dmareg
modifier|*
name|dma
init|=
operator|(
expr|struct
name|dmareg
operator|*
operator|)
name|DMA_BASE
decl_stmt|;
specifier|register
name|struct
name|dma_softc
modifier|*
name|dc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|rev
decl_stmt|;
comment|/* 	 * Determine the DMA type. 	 * Don't know how to easily differentiate the A and B cards, 	 * so we just hope nobody has an A card (A cards will work if 	 * DMAINTLVL is set to 3). 	 */
if|if
condition|(
operator|!
name|badbaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_id
index|[
literal|2
index|]
argument_list|)
condition|)
name|rev
operator|=
name|dma
operator|->
name|dma_id
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
name|rev
operator|=
literal|'B'
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HP320
argument_list|)
name|panic
argument_list|(
literal|"dmainit: DMA card requires hp320 support"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|dc
operator|=
operator|&
name|dma_softc
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDMA
condition|;
name|i
operator|++
control|)
block|{
name|dc
operator|->
name|sc_hwaddr
operator|=
operator|(
name|i
operator|&
literal|1
operator|)
condition|?
operator|&
name|dma
operator|->
name|dma_chan1
else|:
operator|&
name|dma
operator|->
name|dma_chan0
expr_stmt|;
name|dc
operator|->
name|sc_Bhwaddr
operator|=
operator|(
name|i
operator|&
literal|1
operator|)
condition|?
operator|&
name|dma
operator|->
name|dma_Bchan1
else|:
operator|&
name|dma
operator|->
name|dma_Bchan0
expr_stmt|;
name|dc
operator|->
name|sc_type
operator|=
name|rev
operator|==
literal|'B'
condition|?
name|DMA_B
else|:
name|DMA_C
expr_stmt|;
name|dc
operator|++
expr_stmt|;
name|dmachan
index|[
name|i
index|]
operator|.
name|dq_forw
operator|=
name|dmachan
index|[
name|i
index|]
operator|.
name|dq_back
operator|=
operator|&
name|dmachan
index|[
name|i
index|]
expr_stmt|;
block|}
name|dmachan
index|[
name|i
index|]
operator|.
name|dq_forw
operator|=
name|dmachan
index|[
name|i
index|]
operator|.
name|dq_back
operator|=
operator|&
name|dmachan
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* make sure timeout is really not needed */
name|timeout
argument_list|(
name|dmatimeout
argument_list|,
literal|0
argument_list|,
literal|30
operator|*
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"dma: 98620%c with 2 channels, %d bit DMA\n"
argument_list|,
name|rev
argument_list|,
name|rev
operator|==
literal|'B'
condition|?
literal|16
else|:
literal|32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmareq
parameter_list|(
name|dq
parameter_list|)
specifier|register
name|struct
name|devqueue
modifier|*
name|dq
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|chan
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|chan
operator|=
name|dq
operator|->
name|dq_ctlr
expr_stmt|;
name|i
operator|=
name|NDMA
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|chan
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dmachan
index|[
name|i
index|]
operator|.
name|dq_forw
operator|!=
operator|&
name|dmachan
index|[
name|i
index|]
condition|)
continue|continue;
name|insque
argument_list|(
name|dq
argument_list|,
operator|&
name|dmachan
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dq
operator|->
name|dq_ctlr
operator|=
name|i
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|insque
argument_list|(
name|dq
argument_list|,
name|dmachan
index|[
name|NDMA
index|]
operator|.
name|dq_back
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmafree
parameter_list|(
name|dq
parameter_list|)
specifier|register
name|struct
name|devqueue
modifier|*
name|dq
decl_stmt|;
block|{
name|int
name|unit
init|=
name|dq
operator|->
name|dq_ctlr
decl_stmt|;
specifier|register
name|struct
name|dma_softc
modifier|*
name|dc
init|=
operator|&
name|dma_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|devqueue
modifier|*
name|dn
decl_stmt|;
specifier|register
name|int
name|chan
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dmatimo
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|DMA_CLEAR
argument_list|(
name|dc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HP360
argument_list|)
operator|||
name|defined
argument_list|(
name|HP370
argument_list|)
operator|||
name|defined
argument_list|(
name|HP380
argument_list|)
comment|/* 	 * XXX we may not always go thru the flush code in dmastop() 	 */
if|if
condition|(
name|dc
operator|->
name|sc_flags
operator|&
name|DMAF_PCFLUSH
condition|)
block|{
name|PCIA
argument_list|()
expr_stmt|;
name|dc
operator|->
name|sc_flags
operator|&=
operator|~
name|DMAF_PCFLUSH
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HP320
argument_list|)
operator|||
name|defined
argument_list|(
name|HP350
argument_list|)
if|if
condition|(
name|dc
operator|->
name|sc_flags
operator|&
name|DMAF_VCFLUSH
condition|)
block|{
comment|/* 		 * 320/350s have VACs that may also need flushing. 		 * In our case we only flush the supervisor side 		 * because we know that if we are DMAing to user 		 * space, the physical pages will also be mapped 		 * in kernel space (via vmapbuf) and hence cache- 		 * inhibited by the pmap module due to the multiple 		 * mapping. 		 */
name|DCIS
argument_list|()
expr_stmt|;
name|dc
operator|->
name|sc_flags
operator|&=
operator|~
name|DMAF_VCFLUSH
expr_stmt|;
block|}
endif|#
directive|endif
name|remque
argument_list|(
name|dq
argument_list|)
expr_stmt|;
name|chan
operator|=
literal|1
operator|<<
name|unit
expr_stmt|;
for|for
control|(
name|dn
operator|=
name|dmachan
index|[
name|NDMA
index|]
operator|.
name|dq_forw
init|;
name|dn
operator|!=
operator|&
name|dmachan
index|[
name|NDMA
index|]
condition|;
name|dn
operator|=
name|dn
operator|->
name|dq_forw
control|)
block|{
if|if
condition|(
name|dn
operator|->
name|dq_ctlr
operator|&
name|chan
condition|)
block|{
name|remque
argument_list|(
operator|(
name|caddr_t
operator|)
name|dn
argument_list|)
expr_stmt|;
name|insque
argument_list|(
operator|(
name|caddr_t
operator|)
name|dn
argument_list|,
operator|(
name|caddr_t
operator|)
name|dq
operator|->
name|dq_back
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dq_ctlr
operator|=
name|dq
operator|->
name|dq_ctlr
expr_stmt|;
call|(
name|dn
operator|->
name|dq_driver
operator|->
name|d_start
call|)
argument_list|(
name|dn
operator|->
name|dq_unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmago
parameter_list|(
name|unit
parameter_list|,
name|addr
parameter_list|,
name|count
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|;
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|struct
name|dma_softc
modifier|*
name|dc
init|=
operator|&
name|dma_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|dma_chain
modifier|*
name|dcp
decl_stmt|;
specifier|register
name|char
modifier|*
name|dmaend
init|=
name|NULL
decl_stmt|;
specifier|register
name|int
name|tcount
decl_stmt|;
if|if
condition|(
name|count
operator|>
name|MAXPHYS
condition|)
name|panic
argument_list|(
literal|"dmago: count> MAXPHYS"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HP320
argument_list|)
if|if
condition|(
name|dc
operator|->
name|sc_type
operator|==
name|DMA_B
operator|&&
operator|(
name|flags
operator|&
name|DMAGO_LWORD
operator|)
condition|)
name|panic
argument_list|(
literal|"dmago: no can do 32-bit DMA"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dmadebug
operator|&
name|DDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"dmago(%d, %x, %x, %x)\n"
argument_list|,
name|unit
argument_list|,
name|addr
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DMAGO_LWORD
condition|)
name|dmalword
index|[
name|unit
index|]
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DMAGO_WORD
condition|)
name|dmaword
index|[
name|unit
index|]
operator|++
expr_stmt|;
else|else
name|dmabyte
index|[
name|unit
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Build the DMA chain 	 */
for|for
control|(
name|dcp
operator|=
name|dc
operator|->
name|sc_chain
init|;
name|count
operator|>
literal|0
condition|;
name|dcp
operator|++
control|)
block|{
name|dcp
operator|->
name|dc_addr
operator|=
operator|(
name|char
operator|*
operator|)
name|kvtop
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
comment|/* 		 * Push back dirty cache lines 		 */
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
condition|)
name|DCFP
argument_list|(
name|dcp
operator|->
name|dc_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|count
operator|<
operator|(
name|tcount
operator|=
name|NBPG
operator|-
operator|(
operator|(
name|int
operator|)
name|addr
operator|&
name|PGOFSET
operator|)
operator|)
condition|)
name|tcount
operator|=
name|count
expr_stmt|;
name|dcp
operator|->
name|dc_count
operator|=
name|tcount
expr_stmt|;
name|addr
operator|+=
name|tcount
expr_stmt|;
name|count
operator|-=
name|tcount
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DMAGO_LWORD
condition|)
name|tcount
operator|>>=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DMAGO_WORD
condition|)
name|tcount
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|dcp
operator|->
name|dc_addr
operator|==
name|dmaend
if|#
directive|if
name|defined
argument_list|(
name|HP320
argument_list|)
comment|/* only 16-bit count on 98620B */
operator|&&
operator|(
name|dc
operator|->
name|sc_type
operator|!=
name|DMA_B
operator|||
operator|(
name|dcp
operator|-
literal|1
operator|)
operator|->
name|dc_count
operator|+
name|tcount
operator|<=
literal|65536
operator|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dmahits
index|[
name|unit
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|dmaend
operator|+=
name|dcp
operator|->
name|dc_count
expr_stmt|;
operator|(
operator|--
name|dcp
operator|)
operator|->
name|dc_count
operator|+=
name|tcount
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dmamisses
index|[
name|unit
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|dmaend
operator|=
name|dcp
operator|->
name|dc_addr
operator|+
name|dcp
operator|->
name|dc_count
expr_stmt|;
name|dcp
operator|->
name|dc_count
operator|=
name|tcount
expr_stmt|;
block|}
block|}
name|dc
operator|->
name|sc_cur
operator|=
name|dc
operator|->
name|sc_chain
expr_stmt|;
name|dc
operator|->
name|sc_last
operator|=
operator|--
name|dcp
expr_stmt|;
name|dc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set up the command word based on flags 	 */
name|dc
operator|->
name|sc_cmd
operator|=
name|DMA_ENAB
operator||
name|DMA_IPL
argument_list|(
name|DMAINTLVL
argument_list|)
operator||
name|DMA_START
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAGO_READ
operator|)
operator|==
literal|0
condition|)
name|dc
operator|->
name|sc_cmd
operator||=
name|DMA_WRT
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DMAGO_LWORD
condition|)
name|dc
operator|->
name|sc_cmd
operator||=
name|DMA_LWORD
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DMAGO_WORD
condition|)
name|dc
operator|->
name|sc_cmd
operator||=
name|DMA_WORD
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DMAGO_PRI
condition|)
name|dc
operator|->
name|sc_cmd
operator||=
name|DMA_PRI
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HP380
argument_list|)
comment|/* 	 * On the 68040 we need to flush (push) the data cache before a 	 * DMA (already done above) and flush again after DMA completes. 	 * In theory we should only need to flush prior to a write DMA 	 * and purge after a read DMA but if the entire page is not 	 * involved in the DMA we might purge some valid data. 	 */
if|if
condition|(
name|mmutype
operator|==
name|MMU_68040
operator|&&
operator|(
name|flags
operator|&
name|DMAGO_READ
operator|)
condition|)
name|dc
operator|->
name|sc_flags
operator||=
name|DMAF_PCFLUSH
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HP360
argument_list|)
operator|||
name|defined
argument_list|(
name|HP370
argument_list|)
comment|/* 	 * Remember if we need to flush external physical cache when 	 * DMA is done.  We only do this if we are reading (writing memory). 	 */
if|if
condition|(
name|ectype
operator|==
name|EC_PHYS
operator|&&
operator|(
name|flags
operator|&
name|DMAGO_READ
operator|)
condition|)
name|dc
operator|->
name|sc_flags
operator||=
name|DMAF_PCFLUSH
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HP320
argument_list|)
operator|||
name|defined
argument_list|(
name|HP350
argument_list|)
if|if
condition|(
name|ectype
operator|==
name|EC_VIRT
operator|&&
operator|(
name|flags
operator|&
name|DMAGO_READ
operator|)
condition|)
name|dc
operator|->
name|sc_flags
operator||=
name|DMAF_VCFLUSH
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Remember if we can skip the dma completion interrupt on 	 * the last segment in the chain. 	 */
if|if
condition|(
name|flags
operator|&
name|DMAGO_NOINT
condition|)
block|{
if|if
condition|(
name|dc
operator|->
name|sc_cur
operator|==
name|dc
operator|->
name|sc_last
condition|)
name|dc
operator|->
name|sc_cmd
operator|&=
operator|~
name|DMA_ENAB
expr_stmt|;
else|else
name|dc
operator|->
name|sc_flags
operator||=
name|DMAF_NOINTR
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dmadebug
operator|&
name|DDB_IO
condition|)
if|if
condition|(
operator|(
name|dmadebug
operator|&
name|DDB_WORD
operator|)
operator|&&
operator|(
name|dc
operator|->
name|sc_cmd
operator|&
name|DMA_WORD
operator|)
operator|||
operator|(
name|dmadebug
operator|&
name|DDB_LWORD
operator|)
operator|&&
operator|(
name|dc
operator|->
name|sc_cmd
operator|&
name|DMA_LWORD
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"dmago: cmd %x, flags %x\n"
argument_list|,
name|dc
operator|->
name|sc_cmd
argument_list|,
name|dc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|dcp
operator|=
name|dc
operator|->
name|sc_chain
init|;
name|dcp
operator|<=
name|dc
operator|->
name|sc_last
condition|;
name|dcp
operator|++
control|)
name|printf
argument_list|(
literal|"  %d: %d@%x\n"
argument_list|,
name|dcp
operator|-
name|dc
operator|->
name|sc_chain
argument_list|,
name|dcp
operator|->
name|dc_count
argument_list|,
name|dcp
operator|->
name|dc_addr
argument_list|)
expr_stmt|;
block|}
name|dmatimo
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|DMA_ARM
argument_list|(
name|dc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmastop
parameter_list|(
name|unit
parameter_list|)
specifier|register
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|dma_softc
modifier|*
name|dc
init|=
operator|&
name|dma_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|devqueue
modifier|*
name|dq
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dmadebug
operator|&
name|DDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"dmastop(%d)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|dmatimo
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|DMA_CLEAR
argument_list|(
name|dc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HP360
argument_list|)
operator|||
name|defined
argument_list|(
name|HP370
argument_list|)
operator|||
name|defined
argument_list|(
name|HP380
argument_list|)
if|if
condition|(
name|dc
operator|->
name|sc_flags
operator|&
name|DMAF_PCFLUSH
condition|)
block|{
name|PCIA
argument_list|()
expr_stmt|;
name|dc
operator|->
name|sc_flags
operator|&=
operator|~
name|DMAF_PCFLUSH
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HP320
argument_list|)
operator|||
name|defined
argument_list|(
name|HP350
argument_list|)
if|if
condition|(
name|dc
operator|->
name|sc_flags
operator|&
name|DMAF_VCFLUSH
condition|)
block|{
comment|/* 		 * 320/350s have VACs that may also need flushing. 		 * In our case we only flush the supervisor side 		 * because we know that if we are DMAing to user 		 * space, the physical pages will also be mapped 		 * in kernel space (via vmapbuf) and hence cache- 		 * inhibited by the pmap module due to the multiple 		 * mapping. 		 */
name|DCIS
argument_list|()
expr_stmt|;
name|dc
operator|->
name|sc_flags
operator|&=
operator|~
name|DMAF_VCFLUSH
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * We may get this interrupt after a device service routine 	 * has freed the dma channel.  So, ignore the intr if there's 	 * nothing on the queue. 	 */
name|dq
operator|=
name|dmachan
index|[
name|unit
index|]
operator|.
name|dq_forw
expr_stmt|;
if|if
condition|(
name|dq
operator|!=
operator|&
name|dmachan
index|[
name|unit
index|]
condition|)
call|(
name|dq
operator|->
name|dq_driver
operator|->
name|d_done
call|)
argument_list|(
name|dq
operator|->
name|dq_unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmaintr
parameter_list|()
block|{
specifier|register
name|struct
name|dma_softc
modifier|*
name|dc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|stat
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dmadebug
operator|&
name|DDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"dmaintr\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dc
operator|=
name|dma_softc
init|;
name|i
operator|<
name|NDMA
condition|;
name|i
operator|++
operator|,
name|dc
operator|++
control|)
block|{
name|stat
operator|=
name|DMA_STAT
argument_list|(
name|dc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|DMA_INTR
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|found
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dmadebug
operator|&
name|DDB_IO
condition|)
block|{
if|if
condition|(
operator|(
name|dmadebug
operator|&
name|DDB_WORD
operator|)
operator|&&
operator|(
name|dc
operator|->
name|sc_cmd
operator|&
name|DMA_WORD
operator|)
operator|||
operator|(
name|dmadebug
operator|&
name|DDB_LWORD
operator|)
operator|&&
operator|(
name|dc
operator|->
name|sc_cmd
operator|&
name|DMA_LWORD
operator|)
condition|)
name|printf
argument_list|(
literal|"dmaintr: unit %d stat %x next %d\n"
argument_list|,
name|i
argument_list|,
name|stat
argument_list|,
operator|(
name|dc
operator|->
name|sc_cur
operator|-
name|dc
operator|->
name|sc_chain
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|DMA_ARMED
condition|)
name|printf
argument_list|(
literal|"dma%d: intr when armed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|++
name|dc
operator|->
name|sc_cur
operator|<=
name|dc
operator|->
name|sc_last
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dmatimo
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Last chain segment, disable DMA interrupt. 			 */
if|if
condition|(
name|dc
operator|->
name|sc_cur
operator|==
name|dc
operator|->
name|sc_last
operator|&&
operator|(
name|dc
operator|->
name|sc_flags
operator|&
name|DMAF_NOINTR
operator|)
condition|)
name|dc
operator|->
name|sc_cmd
operator|&=
operator|~
name|DMA_ENAB
expr_stmt|;
name|DMA_CLEAR
argument_list|(
name|dc
argument_list|)
expr_stmt|;
name|DMA_ARM
argument_list|(
name|dc
argument_list|)
expr_stmt|;
block|}
else|else
name|dmastop
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|dmatimeout
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDMA
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|dmatimo
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|dmatimo
index|[
name|i
index|]
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"dma%d: timeout #%d\n"
argument_list|,
name|i
argument_list|,
name|dmatimo
index|[
name|i
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dmatimo
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
name|dmatimeout
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
literal|30
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

