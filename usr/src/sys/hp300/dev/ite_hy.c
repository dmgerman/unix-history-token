begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 University of Utah.  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and Mark Davies of the Department of Computer  * Science, Victoria University of Wellington, New Zealand.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * from: Utah $Hdr: ite_hy.c 1.2 92/12/20$  *  *	@(#)ite_hy.c	8.1 (Berkeley) 6/10/93  */
end_comment

begin_include
include|#
directive|include
file|"ite.h"
end_include

begin_if
if|#
directive|if
name|NITE
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/grf_hyreg.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/itereg.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/itevar.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<hp/dev/grfioctl.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/grfvar.h>
end_include

begin_define
define|#
directive|define
name|REGBASE
value|((struct hyboxfb *)(ip->regbase))
end_define

begin_define
define|#
directive|define
name|WINDOWMOVER
value|hyper_windowmove
end_define

begin_undef
undef|#
directive|undef
name|charX
end_undef

begin_define
define|#
directive|define
name|charX
parameter_list|(
name|ip
parameter_list|,
name|c
parameter_list|)
define|\
value|(((c) % (ip)->cpl) * ((((ip)->ftwidth + 7) / 8) * 8) + (ip)->fontx)
end_define

begin_expr_stmt
name|hyper_init
argument_list|(
name|ip
argument_list|)
specifier|register
expr|struct
name|ite_softc
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|width
decl_stmt|;
comment|/* XXX */
if|if
condition|(
name|ip
operator|->
name|regbase
operator|==
name|NULL
condition|)
block|{
name|struct
name|grf_softc
modifier|*
name|gp
init|=
name|ip
operator|->
name|grf
decl_stmt|;
name|ip
operator|->
name|regbase
operator|=
name|gp
operator|->
name|g_regkva
expr_stmt|;
name|ip
operator|->
name|fbbase
operator|=
name|gp
operator|->
name|g_fbkva
expr_stmt|;
name|ip
operator|->
name|fbwidth
operator|=
name|gp
operator|->
name|g_display
operator|.
name|gd_fbwidth
expr_stmt|;
name|ip
operator|->
name|fbheight
operator|=
name|gp
operator|->
name|g_display
operator|.
name|gd_fbheight
expr_stmt|;
name|ip
operator|->
name|dwidth
operator|=
name|gp
operator|->
name|g_display
operator|.
name|gd_dwidth
expr_stmt|;
name|ip
operator|->
name|dheight
operator|=
name|gp
operator|->
name|g_display
operator|.
name|gd_dheight
expr_stmt|;
block|}
name|ite_fontinfo
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|width
operator|=
operator|(
operator|(
name|ip
operator|->
name|ftwidth
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|*
literal|8
expr_stmt|;
name|ip
operator|->
name|cpl
operator|=
operator|(
name|ip
operator|->
name|fbwidth
operator|-
name|ip
operator|->
name|dwidth
operator|)
operator|/
name|width
expr_stmt|;
name|ip
operator|->
name|cblanky
operator|=
name|ip
operator|->
name|fonty
operator|+
operator|(
operator|(
literal|128
operator|/
name|ip
operator|->
name|cpl
operator|)
operator|+
literal|1
operator|)
operator|*
name|ip
operator|->
name|ftheight
expr_stmt|;
comment|/* 	 * Clear the framebuffer on all planes. 	 */
name|hyper_windowmove
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ip
operator|->
name|fbheight
argument_list|,
name|ip
operator|->
name|fbwidth
argument_list|,
name|RR_CLEAR
argument_list|)
expr_stmt|;
name|hyper_ite_fontinit
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|REGBASE
operator|->
name|nblank
operator|=
literal|0x05
expr_stmt|;
comment|/* 	 * Stash the inverted cursor. 	 */
name|hyper_windowmove
argument_list|(
name|ip
argument_list|,
name|charY
argument_list|(
name|ip
argument_list|,
literal|' '
argument_list|)
argument_list|,
name|charX
argument_list|(
name|ip
argument_list|,
literal|' '
argument_list|)
argument_list|,
name|ip
operator|->
name|cblanky
argument_list|,
name|ip
operator|->
name|cblankx
argument_list|,
name|ip
operator|->
name|ftheight
argument_list|,
name|ip
operator|->
name|ftwidth
argument_list|,
name|RR_COPYINVERTED
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hyper_deinit
argument_list|(
name|ip
argument_list|)
specifier|register
expr|struct
name|ite_softc
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|hyper_windowmove
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ip
operator|->
name|fbheight
argument_list|,
name|ip
operator|->
name|fbwidth
argument_list|,
name|RR_CLEAR
argument_list|)
expr_stmt|;
name|REGBASE
operator|->
name|nblank
operator|=
literal|0x05
expr_stmt|;
name|ip
operator|->
name|flags
operator|&=
operator|~
name|ITE_INITED
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hyper_ite_fontinit
argument_list|(
name|ip
argument_list|)
specifier|register
expr|struct
name|ite_softc
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|fbmem
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|l
decl_stmt|,
name|b
decl_stmt|;
name|int
name|stride
decl_stmt|,
name|width
decl_stmt|;
name|dp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|getword
argument_list|(
name|ip
argument_list|,
name|getword
argument_list|(
name|ip
argument_list|,
name|FONTROM
argument_list|)
operator|+
name|FONTADDR
argument_list|)
operator|+
name|ip
operator|->
name|regbase
operator|)
operator|+
name|FONTDATA
expr_stmt|;
name|stride
operator|=
name|ip
operator|->
name|fbwidth
operator|>>
literal|3
expr_stmt|;
name|width
operator|=
operator|(
name|ip
operator|->
name|ftwidth
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|128
condition|;
name|c
operator|++
control|)
block|{
name|fbmem
operator|=
operator|(
name|u_char
operator|*
operator|)
name|FBBASE
operator|+
operator|(
name|ip
operator|->
name|fonty
operator|+
operator|(
name|c
operator|/
name|ip
operator|->
name|cpl
operator|)
operator|*
name|ip
operator|->
name|ftheight
operator|)
operator|*
name|stride
expr_stmt|;
name|fbmem
operator|+=
operator|(
name|ip
operator|->
name|fontx
operator|>>
literal|3
operator|)
operator|+
operator|(
name|c
operator|%
name|ip
operator|->
name|cpl
operator|)
operator|*
name|width
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|ip
operator|->
name|ftheight
condition|;
name|l
operator|++
control|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|width
condition|;
name|b
operator|++
control|)
block|{
operator|*
name|fbmem
operator|++
operator|=
operator|*
name|dp
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
block|}
name|fbmem
operator|-=
name|width
expr_stmt|;
name|fbmem
operator|+=
name|stride
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|hyper_putc
argument_list|(
name|ip
argument_list|,
name|c
argument_list|,
name|dy
argument_list|,
name|dx
argument_list|,
name|mode
argument_list|)
specifier|register
expr|struct
name|ite_softc
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|c
decl_stmt|,
name|dy
decl_stmt|,
name|dx
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|wmrr
init|=
operator|(
operator|(
name|mode
operator|==
name|ATTR_INV
operator|)
condition|?
name|RR_COPYINVERTED
else|:
name|RR_COPY
operator|)
decl_stmt|;
name|hyper_windowmove
argument_list|(
name|ip
argument_list|,
name|charY
argument_list|(
name|ip
argument_list|,
name|c
argument_list|)
argument_list|,
name|charX
argument_list|(
name|ip
argument_list|,
name|c
argument_list|)
argument_list|,
name|dy
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|dx
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|ip
operator|->
name|ftheight
argument_list|,
name|ip
operator|->
name|ftwidth
argument_list|,
name|wmrr
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hyper_cursor
argument_list|(
name|ip
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|ite_softc
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|flag
operator|==
name|DRAW_CURSOR
condition|)
name|draw_cursor
argument_list|(
argument|ip
argument_list|)
elseif|else
if|if
condition|(
name|flag
operator|==
name|MOVE_CURSOR
condition|)
block|{
name|erase_cursor
argument_list|(
argument|ip
argument_list|)
name|draw_cursor
argument_list|(
argument|ip
argument_list|)
block|}
else|else
name|erase_cursor
argument_list|(
argument|ip
argument_list|)
block|}
end_block

begin_expr_stmt
name|hyper_clear
argument_list|(
name|ip
argument_list|,
name|sy
argument_list|,
name|sx
argument_list|,
name|h
argument_list|,
name|w
argument_list|)
specifier|register
expr|struct
name|ite_softc
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|sy
decl_stmt|,
name|sx
decl_stmt|,
name|h
decl_stmt|,
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|hyper_windowmove
argument_list|(
name|ip
argument_list|,
name|sy
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|sx
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|sy
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|sx
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|h
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|w
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|RR_CLEAR
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hyper_scroll
argument_list|(
name|ip
argument_list|,
name|sy
argument_list|,
name|sx
argument_list|,
name|count
argument_list|,
name|dir
argument_list|)
specifier|register
expr|struct
name|ite_softc
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|sy
decl_stmt|,
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dir
decl_stmt|,
name|sx
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|dy
decl_stmt|;
specifier|register
name|int
name|dx
init|=
name|sx
decl_stmt|;
specifier|register
name|int
name|height
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|width
init|=
name|ip
operator|->
name|cols
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|SCROLL_UP
condition|)
block|{
name|dy
operator|=
name|sy
operator|-
name|count
expr_stmt|;
name|height
operator|=
name|ip
operator|->
name|rows
operator|-
name|sy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|==
name|SCROLL_DOWN
condition|)
block|{
name|dy
operator|=
name|sy
operator|+
name|count
expr_stmt|;
name|height
operator|=
name|ip
operator|->
name|rows
operator|-
name|dy
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|==
name|SCROLL_RIGHT
condition|)
block|{
name|dy
operator|=
name|sy
expr_stmt|;
name|dx
operator|=
name|sx
operator|+
name|count
expr_stmt|;
name|width
operator|=
name|ip
operator|->
name|cols
operator|-
name|dx
expr_stmt|;
block|}
else|else
block|{
name|dy
operator|=
name|sy
expr_stmt|;
name|dx
operator|=
name|sx
operator|-
name|count
expr_stmt|;
name|width
operator|=
name|ip
operator|->
name|cols
operator|-
name|sx
expr_stmt|;
block|}
name|hyper_windowmove
argument_list|(
name|ip
argument_list|,
name|sy
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|sx
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|dy
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|dx
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|height
operator|*
name|ip
operator|->
name|ftheight
argument_list|,
name|width
operator|*
name|ip
operator|->
name|ftwidth
argument_list|,
name|RR_COPY
argument_list|)
expr_stmt|;
block|}
end_block

begin_include
include|#
directive|include
file|<hp300/dev/maskbits.h>
end_include

begin_comment
comment|/* NOTE:  * the first element in starttab could be 0xffffffff.  making it 0  * lets us deal with a full first word in the middle loop, rather  * than having to do the multiple reads and masks that we'd  * have to do if we thought it was partial.  */
end_comment

begin_decl_stmt
name|int
name|starttab
index|[
literal|32
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x7FFFFFFF
block|,
literal|0x3FFFFFFF
block|,
literal|0x1FFFFFFF
block|,
literal|0x0FFFFFFF
block|,
literal|0x07FFFFFF
block|,
literal|0x03FFFFFF
block|,
literal|0x01FFFFFF
block|,
literal|0x00FFFFFF
block|,
literal|0x007FFFFF
block|,
literal|0x003FFFFF
block|,
literal|0x001FFFFF
block|,
literal|0x000FFFFF
block|,
literal|0x0007FFFF
block|,
literal|0x0003FFFF
block|,
literal|0x0001FFFF
block|,
literal|0x0000FFFF
block|,
literal|0x00007FFF
block|,
literal|0x00003FFF
block|,
literal|0x00001FFF
block|,
literal|0x00000FFF
block|,
literal|0x000007FF
block|,
literal|0x000003FF
block|,
literal|0x000001FF
block|,
literal|0x000000FF
block|,
literal|0x0000007F
block|,
literal|0x0000003F
block|,
literal|0x0000001F
block|,
literal|0x0000000F
block|,
literal|0x00000007
block|,
literal|0x00000003
block|,
literal|0x00000001
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|endtab
index|[
literal|32
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x80000000
block|,
literal|0xC0000000
block|,
literal|0xE0000000
block|,
literal|0xF0000000
block|,
literal|0xF8000000
block|,
literal|0xFC000000
block|,
literal|0xFE000000
block|,
literal|0xFF000000
block|,
literal|0xFF800000
block|,
literal|0xFFC00000
block|,
literal|0xFFE00000
block|,
literal|0xFFF00000
block|,
literal|0xFFF80000
block|,
literal|0xFFFC0000
block|,
literal|0xFFFE0000
block|,
literal|0xFFFF0000
block|,
literal|0xFFFF8000
block|,
literal|0xFFFFC000
block|,
literal|0xFFFFE000
block|,
literal|0xFFFFF000
block|,
literal|0xFFFFF800
block|,
literal|0xFFFFFC00
block|,
literal|0xFFFFFE00
block|,
literal|0xFFFFFF00
block|,
literal|0xFFFFFF80
block|,
literal|0xFFFFFFC0
block|,
literal|0xFFFFFFE0
block|,
literal|0xFFFFFFF0
block|,
literal|0xFFFFFFF8
block|,
literal|0xFFFFFFFC
block|,
literal|0xFFFFFFFE
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|hyper_windowmove
argument_list|(
argument|ip
argument_list|,
argument|sy
argument_list|,
argument|sx
argument_list|,
argument|dy
argument_list|,
argument|dx
argument_list|,
argument|h
argument_list|,
argument|w
argument_list|,
argument|func
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ite_softc
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sy
decl_stmt|,
name|sx
decl_stmt|,
name|dy
decl_stmt|,
name|dx
decl_stmt|,
name|h
decl_stmt|,
name|w
decl_stmt|,
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|width
decl_stmt|;
comment|/* add to get to same position in next line */
name|unsigned
name|int
modifier|*
name|psrcLine
decl_stmt|,
modifier|*
name|pdstLine
decl_stmt|;
comment|/* pointers to line with current src and dst */
specifier|register
name|unsigned
name|int
modifier|*
name|psrc
decl_stmt|;
comment|/* pointer to current src longword */
specifier|register
name|unsigned
name|int
modifier|*
name|pdst
decl_stmt|;
comment|/* pointer to current dst longword */
comment|/* following used for looping through a line */
name|unsigned
name|int
name|startmask
decl_stmt|,
name|endmask
decl_stmt|;
comment|/* masks for writing ends of dst */
name|int
name|nlMiddle
decl_stmt|;
comment|/* whole longwords in dst */
specifier|register
name|int
name|nl
decl_stmt|;
comment|/* temp copy of nlMiddle */
specifier|register
name|unsigned
name|int
name|tmpSrc
decl_stmt|;
comment|/* place to store full source word */
specifier|register
name|int
name|xoffSrc
decl_stmt|;
comment|/* offset (>= 0,< 32) from which to                                    fetch whole longwords fetched                                    in src */
name|int
name|nstart
decl_stmt|;
comment|/* number of ragged bits at start of dst */
name|int
name|nend
decl_stmt|;
comment|/* number of ragged bits at end of dst */
name|int
name|srcStartOver
decl_stmt|;
comment|/* pulling nstart bits from src                                    overflows into the next word? */
if|if
condition|(
name|h
operator|==
literal|0
operator|||
name|w
operator|==
literal|0
condition|)
return|return;
name|width
operator|=
name|ip
operator|->
name|fbwidth
operator|>>
literal|5
expr_stmt|;
if|if
condition|(
name|sy
operator|<
name|dy
condition|)
comment|/* start at last scanline of rectangle */
block|{
name|psrcLine
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ip
operator|->
name|fbbase
operator|)
operator|+
operator|(
operator|(
name|sy
operator|+
name|h
operator|-
literal|1
operator|)
operator|*
name|width
operator|)
expr_stmt|;
name|pdstLine
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ip
operator|->
name|fbbase
operator|)
operator|+
operator|(
operator|(
name|dy
operator|+
name|h
operator|-
literal|1
operator|)
operator|*
name|width
operator|)
expr_stmt|;
name|width
operator|=
operator|-
name|width
expr_stmt|;
block|}
else|else
comment|/* start at first scanline */
block|{
name|psrcLine
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ip
operator|->
name|fbbase
operator|)
operator|+
operator|(
name|sy
operator|*
name|width
operator|)
expr_stmt|;
name|pdstLine
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ip
operator|->
name|fbbase
operator|)
operator|+
operator|(
name|dy
operator|*
name|width
operator|)
expr_stmt|;
block|}
comment|/* x direction doesn't matter for< 1 longword */
if|if
condition|(
name|w
operator|<=
literal|32
condition|)
block|{
name|int
name|srcBit
decl_stmt|,
name|dstBit
decl_stmt|;
comment|/* bit offset of src and dst */
name|pdstLine
operator|+=
operator|(
name|dx
operator|>>
literal|5
operator|)
expr_stmt|;
name|psrcLine
operator|+=
operator|(
name|sx
operator|>>
literal|5
operator|)
expr_stmt|;
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
name|srcBit
operator|=
name|sx
operator|&
literal|0x1f
expr_stmt|;
name|dstBit
operator|=
name|dx
operator|&
literal|0x1f
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|getandputrop
argument_list|(
argument|psrc
argument_list|,
argument|srcBit
argument_list|,
argument|dstBit
argument_list|,
argument|w
argument_list|,
argument|pdst
argument_list|,
argument|func
argument_list|)
name|pdst
operator|+=
name|width
expr_stmt|;
name|psrc
operator|+=
name|width
expr_stmt|;
block|}
block|}
else|else
block|{
name|maskbits
argument_list|(
argument|dx
argument_list|,
argument|w
argument_list|,
argument|startmask
argument_list|,
argument|endmask
argument_list|,
argument|nlMiddle
argument_list|)
if|if
condition|(
name|startmask
condition|)
name|nstart
operator|=
literal|32
operator|-
operator|(
name|dx
operator|&
literal|0x1f
operator|)
expr_stmt|;
else|else
name|nstart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|endmask
condition|)
name|nend
operator|=
operator|(
name|dx
operator|+
name|w
operator|)
operator|&
literal|0x1f
expr_stmt|;
else|else
name|nend
operator|=
literal|0
expr_stmt|;
name|xoffSrc
operator|=
operator|(
operator|(
name|sx
operator|&
literal|0x1f
operator|)
operator|+
name|nstart
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|srcStartOver
operator|=
operator|(
operator|(
name|sx
operator|&
literal|0x1f
operator|)
operator|+
name|nstart
operator|)
operator|>
literal|31
expr_stmt|;
if|if
condition|(
name|sx
operator|>=
name|dx
condition|)
comment|/* move left to right */
block|{
name|pdstLine
operator|+=
operator|(
name|dx
operator|>>
literal|5
operator|)
expr_stmt|;
name|psrcLine
operator|+=
operator|(
name|sx
operator|>>
literal|5
operator|)
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
if|if
condition|(
name|startmask
condition|)
block|{
name|getandputrop
argument_list|(
argument|psrc
argument_list|,
argument|(sx&
literal|0x1f
argument|)
argument_list|,
argument|(dx&
literal|0x1f
argument|)
argument_list|,
argument|nstart
argument_list|,
argument|pdst
argument_list|,
argument|func
argument_list|)
name|pdst
operator|++
expr_stmt|;
if|if
condition|(
name|srcStartOver
condition|)
name|psrc
operator|++
expr_stmt|;
block|}
comment|/* special case for aligned operations */
if|if
condition|(
name|xoffSrc
operator|==
literal|0
condition|)
block|{
name|nl
operator|=
name|nlMiddle
expr_stmt|;
while|while
condition|(
name|nl
operator|--
condition|)
block|{
name|DoRop
argument_list|(
operator|*
name|pdst
argument_list|,
name|func
argument_list|,
operator|*
name|psrc
operator|++
argument_list|,
operator|*
name|pdst
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|nl
operator|=
name|nlMiddle
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|--
name|nl
condition|)
block|{
name|getunalignedword
argument_list|(
argument|psrc
argument_list|,
argument|xoffSrc
argument_list|,
argument|tmpSrc
argument_list|)
name|DoRop
argument_list|(
operator|*
name|pdst
argument_list|,
name|func
argument_list|,
name|tmpSrc
argument_list|,
operator|*
name|pdst
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
name|psrc
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|endmask
condition|)
block|{
name|getandputrop0
argument_list|(
name|psrc
argument_list|,
name|xoffSrc
argument_list|,
name|nend
argument_list|,
name|pdst
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
name|pdstLine
operator|+=
name|width
expr_stmt|;
name|psrcLine
operator|+=
name|width
expr_stmt|;
block|}
block|}
else|else
comment|/* move right to left */
block|{
name|pdstLine
operator|+=
operator|(
name|dx
operator|+
name|w
operator|>>
literal|5
operator|)
expr_stmt|;
name|psrcLine
operator|+=
operator|(
name|sx
operator|+
name|w
operator|>>
literal|5
operator|)
expr_stmt|;
comment|/* if fetch of last partial bits from source crosses 		   a longword boundary, start at the previous longword 		   */
if|if
condition|(
name|xoffSrc
operator|+
name|nend
operator|>=
literal|32
condition|)
operator|--
name|psrcLine
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
if|if
condition|(
name|endmask
condition|)
block|{
name|getandputrop0
argument_list|(
name|psrc
argument_list|,
name|xoffSrc
argument_list|,
name|nend
argument_list|,
name|pdst
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
name|nl
operator|=
name|nlMiddle
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|--
name|nl
condition|)
block|{
operator|--
name|psrc
expr_stmt|;
operator|--
name|pdst
expr_stmt|;
name|getunalignedword
argument_list|(
argument|psrc
argument_list|,
argument|xoffSrc
argument_list|,
argument|tmpSrc
argument_list|)
name|DoRop
argument_list|(
operator|*
name|pdst
argument_list|,
name|func
argument_list|,
name|tmpSrc
argument_list|,
operator|*
name|pdst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|startmask
condition|)
block|{
if|if
condition|(
name|srcStartOver
condition|)
operator|--
name|psrc
expr_stmt|;
operator|--
name|pdst
expr_stmt|;
name|getandputrop
argument_list|(
argument|psrc
argument_list|,
argument|(sx&
literal|0x1f
argument|)
argument_list|,
argument|(dx&
literal|0x1f
argument|)
argument_list|,
argument|nstart
argument_list|,
argument|pdst
argument_list|,
argument|func
argument_list|)
block|}
name|pdstLine
operator|+=
name|width
expr_stmt|;
name|psrcLine
operator|+=
name|width
expr_stmt|;
block|}
block|}
comment|/* move right to left */
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

