begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1982, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * %sccs.include.redist.c%  *  * from: Utah $Hdr: rd.c 1.44 92/12/26$  *  *	@(#)rd.c	8.2 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * CS80/SS80 disk driver  */
end_comment

begin_include
include|#
directive|include
file|"rd.h"
end_include

begin_if
if|#
directive|if
name|NRD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<hp/dev/device.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/rdreg.h>
end_include

begin_include
include|#
directive|include
file|<hp300/dev/rdvar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USELEDS
end_ifdef

begin_include
include|#
directive|include
file|<hp300/hp300/led.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_decl_stmt
name|int
name|rdinit
argument_list|()
decl_stmt|,
name|rdstart
argument_list|()
decl_stmt|,
name|rdgo
argument_list|()
decl_stmt|,
name|rdintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|rdstrategy
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|driver
name|rddriver
init|=
block|{
name|rdinit
block|,
literal|"rd"
block|,
name|rdstart
block|,
name|rdgo
block|,
name|rdintr
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rd_softc
name|rd_softc
index|[
name|NRD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|rdtab
index|[
name|NRD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rderrthresh
init|=
name|RDRETRY
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* when to start reporting errors */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* error message tables */
end_comment

begin_decl_stmt
name|char
modifier|*
name|err_reject
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|"channel parity error"
block|,
comment|/* 0x2000 */
literal|0
block|,
literal|0
block|,
literal|"illegal opcode"
block|,
comment|/* 0x0400 */
literal|"module addressing"
block|,
comment|/* 0x0200 */
literal|"address bounds"
block|,
comment|/* 0x0100 */
literal|"parameter bounds"
block|,
comment|/* 0x0080 */
literal|"illegal parameter"
block|,
comment|/* 0x0040 */
literal|"message sequence"
block|,
comment|/* 0x0020 */
literal|0
block|,
literal|"message length"
block|,
comment|/* 0x0008 */
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|err_fault
index|[]
init|=
block|{
literal|0
block|,
literal|"cross unit"
block|,
comment|/* 0x4000 */
literal|0
block|,
literal|"controller fault"
block|,
comment|/* 0x1000 */
literal|0
block|,
literal|0
block|,
literal|"unit fault"
block|,
comment|/* 0x0200 */
literal|0
block|,
literal|"diagnostic result"
block|,
comment|/* 0x0080 */
literal|0
block|,
literal|"operator release request"
block|,
comment|/* 0x0020 */
literal|"diagnostic release request"
block|,
comment|/* 0x0010 */
literal|"internal maintenance release request"
block|,
comment|/* 0x0008 */
literal|0
block|,
literal|"power fail"
block|,
comment|/* 0x0002 */
literal|"retransmit"
comment|/* 0x0001 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|err_access
index|[]
init|=
block|{
literal|"illegal parallel operation"
block|,
comment|/* 0x8000 */
literal|"uninitialized media"
block|,
comment|/* 0x4000 */
literal|"no spares available"
block|,
comment|/* 0x2000 */
literal|"not ready"
block|,
comment|/* 0x1000 */
literal|"write protect"
block|,
comment|/* 0x0800 */
literal|"no data found"
block|,
comment|/* 0x0400 */
literal|0
block|,
literal|0
block|,
literal|"unrecoverable data overflow"
block|,
comment|/* 0x0080 */
literal|"unrecoverable data"
block|,
comment|/* 0x0040 */
literal|0
block|,
literal|"end of file"
block|,
comment|/* 0x0010 */
literal|"end of volume"
block|,
comment|/* 0x0008 */
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|err_info
index|[]
init|=
block|{
literal|"operator release request"
block|,
comment|/* 0x8000 */
literal|"diagnostic release request"
block|,
comment|/* 0x4000 */
literal|"internal maintenance release request"
block|,
comment|/* 0x2000 */
literal|"media wear"
block|,
comment|/* 0x1000 */
literal|"latency induced"
block|,
comment|/* 0x0800 */
literal|0
block|,
literal|0
block|,
literal|"auto sparing invoked"
block|,
comment|/* 0x0100 */
literal|0
block|,
literal|"recoverable data overflow"
block|,
comment|/* 0x0040 */
literal|"marginal data"
block|,
comment|/* 0x0020 */
literal|"recoverable data"
block|,
comment|/* 0x0010 */
literal|0
block|,
literal|"maintenance track overflow"
block|,
comment|/* 0x0004 */
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rdstats
name|rdstats
index|[
name|NRD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rddebug
init|=
literal|0x80
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RDB_FOLLOW
value|0x01
end_define

begin_define
define|#
directive|define
name|RDB_STATUS
value|0x02
end_define

begin_define
define|#
directive|define
name|RDB_IDENT
value|0x04
end_define

begin_define
define|#
directive|define
name|RDB_IO
value|0x08
end_define

begin_define
define|#
directive|define
name|RDB_ASYNC
value|0x10
end_define

begin_define
define|#
directive|define
name|RDB_ERROR
value|0x80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Misc. HW description, indexed by sc_type.  * Nothing really critical here, could do without it.  */
end_comment

begin_decl_stmt
name|struct
name|rdidentinfo
name|rdidentinfo
index|[]
init|=
block|{
block|{
name|RD7946AID
block|,
literal|0
block|,
literal|"7945A"
block|,
literal|108416
block|}
block|,
block|{
name|RD9134DID
block|,
literal|1
block|,
literal|"9134D"
block|,
literal|29088
block|}
block|,
block|{
name|RD9134LID
block|,
literal|1
block|,
literal|"9122S"
block|,
literal|1232
block|}
block|,
block|{
name|RD7912PID
block|,
literal|0
block|,
literal|"7912P"
block|,
literal|128128
block|}
block|,
block|{
name|RD7914PID
block|,
literal|0
block|,
literal|"7914P"
block|,
literal|258048
block|}
block|,
block|{
name|RD7958AID
block|,
literal|0
block|,
literal|"7958A"
block|,
literal|255276
block|}
block|,
block|{
name|RD7957AID
block|,
literal|0
block|,
literal|"7957A"
block|,
literal|159544
block|}
block|,
block|{
name|RD7933HID
block|,
literal|0
block|,
literal|"7933H"
block|,
literal|789958
block|}
block|,
block|{
name|RD9134LID
block|,
literal|1
block|,
literal|"9134L"
block|,
literal|77840
block|}
block|,
block|{
name|RD7936HID
block|,
literal|0
block|,
literal|"7936H"
block|,
literal|600978
block|}
block|,
block|{
name|RD7937HID
block|,
literal|0
block|,
literal|"7937H"
block|,
literal|1116102
block|}
block|,
block|{
name|RD7914CTID
block|,
literal|0
block|,
literal|"7914CT"
block|,
literal|258048
block|}
block|,
block|{
name|RD7946AID
block|,
literal|0
block|,
literal|"7946A"
block|,
literal|108416
block|}
block|,
block|{
name|RD9134LID
block|,
literal|1
block|,
literal|"9122D"
block|,
literal|1232
block|}
block|,
block|{
name|RD7957BID
block|,
literal|0
block|,
literal|"7957B"
block|,
literal|159894
block|}
block|,
block|{
name|RD7958BID
block|,
literal|0
block|,
literal|"7958B"
block|,
literal|297108
block|}
block|,
block|{
name|RD7959BID
block|,
literal|0
block|,
literal|"7959B"
block|,
literal|594216
block|}
block|,
block|{
name|RD2200AID
block|,
literal|0
block|,
literal|"2200A"
block|,
literal|654948
block|}
block|,
block|{
name|RD2203AID
block|,
literal|0
block|,
literal|"2203A"
block|,
literal|1309896
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numrdidentinfo
init|=
sizeof|sizeof
argument_list|(
name|rdidentinfo
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rdidentinfo
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|rdinit
argument_list|(
name|hd
argument_list|)
specifier|register
expr|struct
name|hp_device
operator|*
name|hd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|hd
operator|->
name|hp_unit
index|]
decl_stmt|;
name|rs
operator|->
name|sc_hd
operator|=
name|hd
expr_stmt|;
name|rs
operator|->
name|sc_punit
operator|=
name|rdpunit
argument_list|(
name|hd
operator|->
name|hp_flags
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_type
operator|=
name|rdident
argument_list|(
name|rs
argument_list|,
name|hd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|sc_type
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rs
operator|->
name|sc_dq
operator|.
name|dq_ctlr
operator|=
name|hd
operator|->
name|hp_ctlr
expr_stmt|;
name|rs
operator|->
name|sc_dq
operator|.
name|dq_unit
operator|=
name|hd
operator|->
name|hp_unit
expr_stmt|;
name|rs
operator|->
name|sc_dq
operator|.
name|dq_slave
operator|=
name|hd
operator|->
name|hp_slave
expr_stmt|;
name|rs
operator|->
name|sc_dq
operator|.
name|dq_driver
operator|=
operator|&
name|rddriver
expr_stmt|;
name|rs
operator|->
name|sc_flags
operator|=
name|RDF_ALIVE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* always report errors */
if|if
condition|(
name|rddebug
operator|&
name|RDB_ERROR
condition|)
name|rderrthresh
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|rdident
argument_list|(
argument|rs
argument_list|,
argument|hd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|rd_softc
modifier|*
name|rs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hp_device
modifier|*
name|hd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|rd_describe
name|desc
decl_stmt|;
name|u_char
name|stat
decl_stmt|,
name|cmd
index|[
literal|3
index|]
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|lunit
decl_stmt|;
name|char
name|name
index|[
literal|7
index|]
decl_stmt|;
specifier|register
name|int
name|ctlr
decl_stmt|,
name|slave
decl_stmt|,
name|id
decl_stmt|,
name|i
decl_stmt|;
name|ctlr
operator|=
name|hd
operator|->
name|hp_ctlr
expr_stmt|;
name|slave
operator|=
name|hd
operator|->
name|hp_slave
expr_stmt|;
name|unit
operator|=
name|rs
operator|->
name|sc_punit
expr_stmt|;
name|lunit
operator|=
name|hd
operator|->
name|hp_unit
expr_stmt|;
comment|/* 	 * Grab device id and make sure: 	 * 1. It is a CS80 device. 	 * 2. It is one of the types we support. 	 * 3. If it is a 7946, we are accessing the disk unit (0) 	 */
name|id
operator|=
name|hpibid
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_IDENT
condition|)
name|printf
argument_list|(
literal|"hpibid(%d, %d) -> %x\n"
argument_list|,
name|ctlr
argument_list|,
name|slave
argument_list|,
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|id
operator|&
literal|0x200
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numrdidentinfo
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|id
operator|==
name|rdidentinfo
index|[
name|i
index|]
operator|.
name|ri_hwid
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|numrdidentinfo
operator|||
name|unit
operator|>
name|rdidentinfo
index|[
name|i
index|]
operator|.
name|ri_maxunum
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|id
operator|=
name|i
expr_stmt|;
comment|/* 	 * Reset drive and collect device description. 	 * Don't really use the description info right now but 	 * might come in handy in the future (for disk labels). 	 */
name|rdreset
argument_list|(
name|rs
argument_list|,
name|hd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|C_SUNIT
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|1
index|]
operator|=
name|C_SVOL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|C_DESC
expr_stmt|;
name|hpibsend
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|C_CMD
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|C_EXEC
argument_list|,
operator|&
name|desc
argument_list|,
literal|37
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|ctlr
argument_list|,
name|slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat
condition|)
block|{
specifier|register
name|int
name|n
init|=
name|desc
operator|.
name|d_name
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|5
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|name
index|[
name|i
index|]
operator|=
operator|(
name|n
operator|&
literal|0xf
operator|)
operator|+
literal|'0'
expr_stmt|;
name|n
operator|>>=
literal|4
expr_stmt|;
block|}
comment|/* use drive characteristics to calculate xfer rate */
name|rs
operator|->
name|sc_wpms
operator|=
literal|1000000
operator|*
operator|(
name|desc
operator|.
name|d_sectsize
operator|/
literal|2
operator|)
operator|/
name|desc
operator|.
name|d_blocktime
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_IDENT
condition|)
block|{
name|printf
argument_list|(
literal|"rd%d: name: %x ('%s')\n"
argument_list|,
name|lunit
argument_list|,
name|desc
operator|.
name|d_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  iuw %x, maxxfr %d, ctype %d\n"
argument_list|,
name|desc
operator|.
name|d_iuw
argument_list|,
name|desc
operator|.
name|d_cmaxxfr
argument_list|,
name|desc
operator|.
name|d_ctype
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  utype %d, bps %d, blkbuf %d, burst %d, blktime %d\n"
argument_list|,
name|desc
operator|.
name|d_utype
argument_list|,
name|desc
operator|.
name|d_sectsize
argument_list|,
name|desc
operator|.
name|d_blkbuf
argument_list|,
name|desc
operator|.
name|d_burstsize
argument_list|,
name|desc
operator|.
name|d_blocktime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  avxfr %d, ort %d, atp %d, maxint %d, fv %x, rv %x\n"
argument_list|,
name|desc
operator|.
name|d_uavexfr
argument_list|,
name|desc
operator|.
name|d_retry
argument_list|,
name|desc
operator|.
name|d_access
argument_list|,
name|desc
operator|.
name|d_maxint
argument_list|,
name|desc
operator|.
name|d_fvbyte
argument_list|,
name|desc
operator|.
name|d_rvbyte
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  maxcyl/head/sect %d/%d/%d, maxvsect %d, inter %d\n"
argument_list|,
name|desc
operator|.
name|d_maxcyl
argument_list|,
name|desc
operator|.
name|d_maxhead
argument_list|,
name|desc
operator|.
name|d_maxsect
argument_list|,
name|desc
operator|.
name|d_maxvsectl
argument_list|,
name|desc
operator|.
name|d_interleave
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Take care of a couple of anomolies: 	 * 1. 7945A and 7946A both return same HW id 	 * 2. 9122S and 9134D both return same HW id 	 * 3. 9122D and 9134L both return same HW id 	 */
switch|switch
condition|(
name|rdidentinfo
index|[
name|id
index|]
operator|.
name|ri_hwid
condition|)
block|{
case|case
name|RD7946AID
case|:
if|if
condition|(
name|bcmp
argument_list|(
name|name
argument_list|,
literal|"079450"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|id
operator|=
name|RD7945A
expr_stmt|;
else|else
name|id
operator|=
name|RD7946A
expr_stmt|;
break|break;
case|case
name|RD9134LID
case|:
if|if
condition|(
name|bcmp
argument_list|(
name|name
argument_list|,
literal|"091340"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|id
operator|=
name|RD9134L
expr_stmt|;
else|else
name|id
operator|=
name|RD9122D
expr_stmt|;
break|break;
case|case
name|RD9134DID
case|:
if|if
condition|(
name|bcmp
argument_list|(
name|name
argument_list|,
literal|"091220"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|id
operator|=
name|RD9122S
expr_stmt|;
else|else
name|id
operator|=
name|RD9134D
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"rd%d: %s\n"
argument_list|,
name|lunit
argument_list|,
name|rdidentinfo
index|[
name|id
index|]
operator|.
name|ri_desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|rdreset
argument_list|(
name|rs
argument_list|,
name|hd
argument_list|)
specifier|register
expr|struct
name|rd_softc
operator|*
name|rs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hp_device
modifier|*
name|hd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_char
name|stat
decl_stmt|;
name|rs
operator|->
name|sc_clear
operator|.
name|c_unit
operator|=
name|C_SUNIT
argument_list|(
name|rs
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_clear
operator|.
name|c_cmd
operator|=
name|C_CLEAR
expr_stmt|;
name|hpibsend
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_TCMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_clear
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_clear
argument_list|)
argument_list|)
expr_stmt|;
name|hpibswait
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_src
operator|.
name|c_unit
operator|=
name|C_SUNIT
argument_list|(
name|RDCTLR
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_src
operator|.
name|c_nop
operator|=
name|C_NOP
expr_stmt|;
name|rs
operator|->
name|sc_src
operator|.
name|c_cmd
operator|=
name|C_SREL
expr_stmt|;
name|rs
operator|->
name|sc_src
operator|.
name|c_param
operator|=
name|C_REL
expr_stmt|;
name|hpibsend
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_src
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_src
argument_list|)
argument_list|)
expr_stmt|;
name|hpibswait
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ssmc
operator|.
name|c_unit
operator|=
name|C_SUNIT
argument_list|(
name|rs
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ssmc
operator|.
name|c_cmd
operator|=
name|C_SSM
expr_stmt|;
name|rs
operator|->
name|sc_ssmc
operator|.
name|c_refm
operator|=
name|REF_MASK
expr_stmt|;
name|rs
operator|->
name|sc_ssmc
operator|.
name|c_fefm
operator|=
name|FEF_MASK
expr_stmt|;
name|rs
operator|->
name|sc_ssmc
operator|.
name|c_aefm
operator|=
name|AEF_MASK
expr_stmt|;
name|rs
operator|->
name|sc_ssmc
operator|.
name|c_iefm
operator|=
name|IEF_MASK
expr_stmt|;
name|hpibsend
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_ssmc
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_ssmc
argument_list|)
argument_list|)
expr_stmt|;
name|hpibswait
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|hd
operator|->
name|hp_ctlr
argument_list|,
name|hd
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|rdstats
index|[
name|hd
operator|->
name|hp_unit
index|]
operator|.
name|rdresets
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Read or constuct a disklabel  */
end_comment

begin_function
name|int
name|rdgetinfo
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|rdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|rs
operator|->
name|sc_info
operator|.
name|ri_label
decl_stmt|;
specifier|register
name|struct
name|partition
modifier|*
name|pi
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|readdisklabel
argument_list|()
decl_stmt|;
comment|/* 	 * Set some default values to use while reading the label 	 * or to use if there isn't a label. 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|lp
argument_list|,
sizeof|sizeof
expr|*
name|lp
argument_list|)
expr_stmt|;
name|lp
operator|->
name|d_type
operator|=
name|DTYPE_HPIB
expr_stmt|;
name|lp
operator|->
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|lp
operator|->
name|d_nsectors
operator|=
literal|32
expr_stmt|;
name|lp
operator|->
name|d_ntracks
operator|=
literal|20
expr_stmt|;
name|lp
operator|->
name|d_ncylinders
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|d_secpercyl
operator|=
literal|32
operator|*
literal|20
expr_stmt|;
name|lp
operator|->
name|d_npartitions
operator|=
literal|3
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|2
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
literal|2
index|]
operator|.
name|p_size
operator|=
name|LABELSECTOR
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Now try to read the disklabel 	 */
name|msg
operator|=
name|readdisklabel
argument_list|(
name|rdlabdev
argument_list|(
name|dev
argument_list|)
argument_list|,
name|rdstrategy
argument_list|,
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pi
operator|=
name|lp
operator|->
name|d_partitions
expr_stmt|;
name|printf
argument_list|(
literal|"rd%d: WARNING: %s, "
argument_list|,
name|unit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_NOLABEL
name|printf
argument_list|(
literal|"using old default partitioning\n"
argument_list|)
expr_stmt|;
name|rdmakedisklabel
argument_list|(
name|unit
argument_list|,
name|lp
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"defining `c' partition as entire disk\n"
argument_list|)
expr_stmt|;
name|pi
index|[
literal|2
index|]
operator|.
name|p_size
operator|=
name|rdidentinfo
index|[
name|rs
operator|->
name|sc_type
index|]
operator|.
name|ri_nblocks
expr_stmt|;
comment|/* XXX reset other info since readdisklabel screws with it */
name|lp
operator|->
name|d_npartitions
operator|=
literal|3
expr_stmt|;
name|pi
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rdopen
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|rdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRD
operator|||
operator|(
name|rs
operator|->
name|sc_flags
operator|&
name|RDF_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Wait for any pending opens/closes to complete 	 */
while|while
condition|(
name|rs
operator|->
name|sc_flags
operator|&
operator|(
name|RDF_OPENING
operator||
name|RDF_CLOSING
operator|)
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|rs
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
comment|/* 	 * On first open, get label and partition info. 	 * We may block reading the label, so be careful 	 * to stop any other opens. 	 */
if|if
condition|(
name|rs
operator|->
name|sc_info
operator|.
name|ri_open
operator|==
literal|0
condition|)
block|{
name|rs
operator|->
name|sc_flags
operator||=
name|RDF_OPENING
expr_stmt|;
name|error
operator|=
name|rdgetinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_flags
operator|&=
operator|~
name|RDF_OPENING
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|rs
operator|->
name|sc_hd
operator|->
name|hp_dk
operator|>=
literal|0
condition|)
block|{
comment|/* guess at xfer rate based on 3600 rpm (60 rps) */
if|if
condition|(
name|rs
operator|->
name|sc_wpms
operator|==
literal|0
condition|)
name|rs
operator|->
name|sc_wpms
operator|=
literal|60
operator|*
name|rs
operator|->
name|sc_info
operator|.
name|ri_label
operator|.
name|d_nsectors
operator|*
name|DEV_BSIZE
operator|/
literal|2
expr_stmt|;
name|dk_wpms
index|[
name|rs
operator|->
name|sc_hd
operator|->
name|hp_dk
index|]
operator|=
name|rs
operator|->
name|sc_wpms
expr_stmt|;
block|}
name|mask
operator|=
literal|1
operator|<<
name|rdpart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|S_IFCHR
condition|)
name|rs
operator|->
name|sc_info
operator|.
name|ri_copen
operator||=
name|mask
expr_stmt|;
else|else
name|rs
operator|->
name|sc_info
operator|.
name|ri_bopen
operator||=
name|mask
expr_stmt|;
name|rs
operator|->
name|sc_info
operator|.
name|ri_open
operator||=
name|mask
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rdclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|unit
init|=
name|rdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|rdinfo
modifier|*
name|ri
init|=
operator|&
name|rs
operator|->
name|sc_info
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|s
decl_stmt|;
name|mask
operator|=
literal|1
operator|<<
name|rdpart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|S_IFCHR
condition|)
name|ri
operator|->
name|ri_copen
operator|&=
operator|~
name|mask
expr_stmt|;
else|else
name|ri
operator|->
name|ri_bopen
operator|&=
operator|~
name|mask
expr_stmt|;
name|ri
operator|->
name|ri_open
operator|=
name|ri
operator|->
name|ri_bopen
operator||
name|ri
operator|->
name|ri_copen
expr_stmt|;
comment|/* 	 * On last close, we wait for all activity to cease since 	 * the label/parition info will become invalid.  Since we 	 * might sleep, we must block any opens while we are here. 	 * Note we don't have to about other closes since we know 	 * we are the last one. 	 */
if|if
condition|(
name|ri
operator|->
name|ri_open
operator|==
literal|0
condition|)
block|{
name|rs
operator|->
name|sc_flags
operator||=
name|RDF_CLOSING
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_active
condition|)
block|{
name|rs
operator|->
name|sc_flags
operator||=
name|RDF_WANTED
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rdtab
index|[
name|unit
index|]
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|RDF_CLOSING
operator||
name|RDF_WLABEL
operator|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|rs
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rdstrategy
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|unit
init|=
name|rdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
init|=
operator|&
name|rdtab
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|partition
modifier|*
name|pinfo
decl_stmt|;
specifier|register
name|daddr_t
name|bn
decl_stmt|;
specifier|register
name|int
name|sz
decl_stmt|,
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"rdstrategy(%x): dev %x, bn %x, bcount %x, %c\n"
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|b_dev
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|'R'
else|:
literal|'W'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bn
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|sz
operator|=
name|howmany
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
name|pinfo
operator|=
operator|&
name|rs
operator|->
name|sc_info
operator|.
name|ri_label
operator|.
name|d_partitions
index|[
name|rdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|bn
operator|<
literal|0
operator|||
name|bn
operator|+
name|sz
operator|>
name|pinfo
operator|->
name|p_size
condition|)
block|{
name|sz
operator|=
name|pinfo
operator|->
name|p_size
operator|-
name|bn
expr_stmt|;
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bp
operator|->
name|b_bcount
operator|=
name|dbtob
argument_list|(
name|sz
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for write to write protected label 	 */
if|if
condition|(
name|bn
operator|+
name|pinfo
operator|->
name|p_offset
operator|<=
name|LABELSECTOR
operator|&&
if|#
directive|if
name|LABELSECTOR
operator|!=
literal|0
name|bn
operator|+
name|pinfo
operator|->
name|p_offset
operator|+
name|sz
operator|>
name|LABELSECTOR
operator|&&
endif|#
directive|endif
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|&&
operator|!
operator|(
name|rs
operator|->
name|sc_flags
operator|&
name|RDF_WLABEL
operator|)
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bp
operator|->
name|b_cylin
operator|=
name|bn
operator|+
name|pinfo
operator|->
name|p_offset
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
block|{
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
name|rdustart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from timeout() when handling maintenance releases  */
end_comment

begin_function
name|void
name|rdrestart
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|rdustart
argument_list|(
operator|(
name|int
operator|)
name|arg
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|rdustart
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
name|bp
operator|=
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
expr_stmt|;
name|rs
operator|->
name|sc_addr
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|rs
operator|->
name|sc_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|hpibreq
argument_list|(
operator|&
name|rs
operator|->
name|sc_dq
argument_list|)
condition|)
name|rdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|buf
modifier|*
name|rdfinish
parameter_list|(
name|unit
parameter_list|,
name|rs
parameter_list|,
name|bp
parameter_list|)
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
init|=
operator|&
name|rdtab
index|[
name|unit
index|]
decl_stmt|;
name|dp
operator|->
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|hpibfree
argument_list|(
operator|&
name|rs
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
return|return
operator|(
name|dp
operator|->
name|b_actf
operator|)
return|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|sc_flags
operator|&
name|RDF_WANTED
condition|)
block|{
name|rs
operator|->
name|sc_flags
operator|&=
operator|~
name|RDF_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|rdstart
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
decl_stmt|;
specifier|register
name|struct
name|hp_device
modifier|*
name|hp
init|=
name|rs
operator|->
name|sc_hd
decl_stmt|;
specifier|register
name|int
name|part
decl_stmt|;
name|again
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"rdstart(%d): bp %x, %c\n"
argument_list|,
name|unit
argument_list|,
name|bp
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|'R'
else|:
literal|'W'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|part
operator|=
name|rdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_flags
operator||=
name|RDF_SEEK
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_unit
operator|=
name|C_SUNIT
argument_list|(
name|rs
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_volume
operator|=
name|C_SVOL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_saddr
operator|=
name|C_SADDR
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_hiaddr
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_addr
operator|=
name|RDBTOS
argument_list|(
name|bp
operator|->
name|b_cylin
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_nop2
operator|=
name|C_NOP
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_slen
operator|=
name|C_SLEN
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_len
operator|=
name|rs
operator|->
name|sc_resid
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_cmd
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
name|C_READ
else|:
name|C_WRITE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_IO
condition|)
name|printf
argument_list|(
literal|"rdstart: hpibsend(%x, %x, %x, %x, %x)\n"
argument_list|,
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_unit
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_ioc
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hpibsend
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_unit
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_ioc
argument_list|)
operator|-
literal|2
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_ioc
argument_list|)
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|hp_dk
operator|>=
literal|0
condition|)
block|{
name|dk_busy
operator||=
literal|1
operator|<<
name|hp
operator|->
name|hp_dk
expr_stmt|;
name|dk_seek
index|[
name|hp
operator|->
name|hp_dk
index|]
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_IO
condition|)
name|printf
argument_list|(
literal|"rdstart: hpibawait(%x)\n"
argument_list|,
name|hp
operator|->
name|hp_ctlr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hpibawait
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Experience has shown that the hpibwait in this hpibsend will 	 * occasionally timeout.  It appears to occur mostly on old 7914 	 * drives with full maintenance tracks.  We should probably 	 * integrate this with the backoff code in rderror. 	 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_ERROR
condition|)
name|printf
argument_list|(
literal|"rd%d: rdstart: cmd %x adr %d blk %d len %d ecnt %d\n"
argument_list|,
name|unit
argument_list|,
name|rs
operator|->
name|sc_ioc
operator|.
name|c_cmd
argument_list|,
name|rs
operator|->
name|sc_ioc
operator|.
name|c_addr
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|rs
operator|->
name|sc_resid
argument_list|,
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
argument_list|)
expr_stmt|;
name|rdstats
index|[
name|unit
index|]
operator|.
name|rdretries
operator|++
expr_stmt|;
endif|#
directive|endif
name|rs
operator|->
name|sc_flags
operator|&=
operator|~
name|RDF_SEEK
expr_stmt|;
name|rdreset
argument_list|(
name|rs
argument_list|,
name|hp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|++
operator|<
name|RDRETRY
condition|)
goto|goto
name|again
goto|;
name|printf
argument_list|(
literal|"rd%d: rdstart err: cmd 0x%x sect %d blk %d len %d\n"
argument_list|,
name|unit
argument_list|,
name|rs
operator|->
name|sc_ioc
operator|.
name|c_cmd
argument_list|,
name|rs
operator|->
name|sc_ioc
operator|.
name|c_addr
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|rs
operator|->
name|sc_resid
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|=
name|rdfinish
argument_list|(
name|unit
argument_list|,
name|rs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
block|{
name|rs
operator|->
name|sc_addr
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|rs
operator|->
name|sc_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|hpibreq
argument_list|(
operator|&
name|rs
operator|->
name|sc_dq
argument_list|)
condition|)
goto|goto
name|again
goto|;
block|}
block|}
end_block

begin_expr_stmt
name|rdgo
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hp_device
modifier|*
name|hp
init|=
name|rs
operator|->
name|sc_hd
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
decl_stmt|;
if|if
condition|(
name|hp
operator|->
name|hp_dk
operator|>=
literal|0
condition|)
block|{
name|dk_busy
operator||=
literal|1
operator|<<
name|hp
operator|->
name|hp_dk
expr_stmt|;
name|dk_xfer
index|[
name|hp
operator|->
name|hp_dk
index|]
operator|++
expr_stmt|;
name|dk_wds
index|[
name|hp
operator|->
name|hp_dk
index|]
operator|+=
name|rs
operator|->
name|sc_resid
operator|>>
literal|6
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USELEDS
if|if
condition|(
name|inledcontrol
operator|==
literal|0
condition|)
name|ledcontrol
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|LED_DISK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hpibgo
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_EXEC
argument_list|,
name|rs
operator|->
name|sc_addr
argument_list|,
name|rs
operator|->
name|sc_resid
argument_list|,
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rdintr
argument_list|(
name|unit
argument_list|)
specifier|register
name|int
name|unit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
decl_stmt|;
specifier|register
name|struct
name|hp_device
modifier|*
name|hp
init|=
name|rs
operator|->
name|sc_hd
decl_stmt|;
name|u_char
name|stat
init|=
literal|13
decl_stmt|;
comment|/* in case hpibrecv fails */
name|int
name|rv
decl_stmt|,
name|restart
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"rdintr(%d): bp %x, %c, flags %x\n"
argument_list|,
name|unit
argument_list|,
name|bp
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|'R'
else|:
literal|'W'
argument_list|,
name|rs
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rd%d: bp == NULL\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|hp
operator|->
name|hp_dk
operator|>=
literal|0
condition|)
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|hp
operator|->
name|hp_dk
operator|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|sc_flags
operator|&
name|RDF_SEEK
condition|)
block|{
name|rs
operator|->
name|sc_flags
operator|&=
operator|~
name|RDF_SEEK
expr_stmt|;
if|if
condition|(
name|hpibustart
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|)
condition|)
name|rdgo
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|rs
operator|->
name|sc_flags
operator|&
name|RDF_SWAIT
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|rdstats
index|[
name|unit
index|]
operator|.
name|rdpolltries
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hpibpptest
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|rdstats
index|[
name|unit
index|]
operator|.
name|rdpollwaits
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hp
operator|->
name|hp_dk
operator|>=
literal|0
condition|)
name|dk_busy
operator||=
literal|1
operator|<<
name|hp
operator|->
name|hp_dk
expr_stmt|;
name|rs
operator|->
name|sc_flags
operator||=
name|RDF_SWAIT
expr_stmt|;
name|hpibawait
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|rs
operator|->
name|sc_flags
operator|&=
operator|~
name|RDF_SWAIT
expr_stmt|;
name|rv
operator|=
name|hpibrecv
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|1
operator|||
name|stat
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_ERROR
condition|)
name|printf
argument_list|(
literal|"rdintr: recv failed or bad stat %d\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|restart
operator|=
name|rderror
argument_list|(
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|rdstats
index|[
name|unit
index|]
operator|.
name|rdretries
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|++
operator|<
name|RDRETRY
condition|)
block|{
if|if
condition|(
name|restart
condition|)
name|rdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
block|}
if|if
condition|(
name|rdfinish
argument_list|(
name|unit
argument_list|,
name|rs
argument_list|,
name|bp
argument_list|)
condition|)
name|rdustart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rdstatus
argument_list|(
name|rs
argument_list|)
specifier|register
expr|struct
name|rd_softc
operator|*
name|rs
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|s
decl_stmt|;
name|u_char
name|stat
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|c
operator|=
name|rs
operator|->
name|sc_hd
operator|->
name|hp_ctlr
expr_stmt|;
name|s
operator|=
name|rs
operator|->
name|sc_hd
operator|->
name|hp_slave
expr_stmt|;
name|rs
operator|->
name|sc_rsc
operator|.
name|c_unit
operator|=
name|C_SUNIT
argument_list|(
name|rs
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_rsc
operator|.
name|c_sram
operator|=
name|C_SRAM
expr_stmt|;
name|rs
operator|->
name|sc_rsc
operator|.
name|c_ram
operator|=
name|C_RAM
expr_stmt|;
name|rs
operator|->
name|sc_rsc
operator|.
name|c_cmd
operator|=
name|C_STATUS
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rs
operator|->
name|sc_stat
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_stat
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|hpibsend
argument_list|(
name|c
argument_list|,
name|s
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_rsc
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_rsc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_rsc
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_STATUS
condition|)
name|printf
argument_list|(
literal|"rdstatus: send C_CMD failed %d != %d\n"
argument_list|,
name|rv
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_rsc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rv
operator|=
name|hpibrecv
argument_list|(
name|c
argument_list|,
name|s
argument_list|,
name|C_EXEC
argument_list|,
operator|&
name|rs
operator|->
name|sc_stat
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_stat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_stat
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_STATUS
condition|)
name|printf
argument_list|(
literal|"rdstatus: send C_EXEC failed %d != %d\n"
argument_list|,
name|rv
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_stat
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rv
operator|=
name|hpibrecv
argument_list|(
name|c
argument_list|,
name|s
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|1
operator|||
name|stat
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_STATUS
condition|)
name|printf
argument_list|(
literal|"rdstatus: recv failed %d or bad stat %d\n"
argument_list|,
name|rv
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Deal with errors.  * Returns 1 if request should be restarted,  * 0 if we should just quietly give up.  */
end_comment

begin_macro
name|rderror
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|rd_stat
modifier|*
name|sp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|hwbn
decl_stmt|,
name|pbn
decl_stmt|;
if|if
condition|(
name|rdstatus
argument_list|(
name|rs
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"rd%d: couldn't get status\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rdreset
argument_list|(
name|rs
argument_list|,
name|rs
operator|->
name|sc_hd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sp
operator|=
operator|&
name|rs
operator|->
name|sc_stat
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|c_fef
operator|&
name|FEF_REXMT
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|c_fef
operator|&
name|FEF_PF
condition|)
block|{
name|rdreset
argument_list|(
name|rs
argument_list|,
name|rs
operator|->
name|sc_hd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Unit requests release for internal maintenance. 	 * We just delay awhile and try again later.  Use expontially 	 * increasing backoff ala ethernet drivers since we don't really 	 * know how long the maintenance will take.  With RDWAITC and 	 * RDRETRY as defined, the range is 1 to 32 seconds. 	 */
if|if
condition|(
name|sp
operator|->
name|c_fef
operator|&
name|FEF_IMR
condition|)
block|{
specifier|extern
name|int
name|hz
decl_stmt|;
name|int
name|rdtimo
init|=
name|RDWAITC
operator|<<
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"rd%d: internal maintenance, %d second timeout\n"
argument_list|,
name|unit
argument_list|,
name|rdtimo
argument_list|)
expr_stmt|;
name|rdstats
index|[
name|unit
index|]
operator|.
name|rdtimeouts
operator|++
expr_stmt|;
endif|#
directive|endif
name|hpibfree
argument_list|(
operator|&
name|rs
operator|->
name|sc_dq
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|rdrestart
argument_list|,
operator|(
name|void
operator|*
operator|)
name|unit
argument_list|,
name|rdtimo
operator|*
name|hz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Only report error if we have reached the error reporting 	 * threshhold.  By default, this will only report after the 	 * retry limit has been exceeded. 	 */
if|if
condition|(
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|<
name|rderrthresh
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * First conjure up the block number at which the error occured. 	 * Note that not all errors report a block number, in that case 	 * we just use b_blkno.  	 */
name|bp
operator|=
name|rdtab
index|[
name|unit
index|]
operator|.
name|b_actf
expr_stmt|;
name|pbn
operator|=
name|rs
operator|->
name|sc_info
operator|.
name|ri_label
operator|.
name|d_partitions
index|[
name|rdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|p_offset
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|c_fef
operator|&
name|FEF_CU
operator|)
operator|||
operator|(
name|sp
operator|->
name|c_fef
operator|&
name|FEF_DR
operator|)
operator|||
operator|(
name|sp
operator|->
name|c_ief
operator|&
name|IEF_RRMASK
operator|)
condition|)
block|{
name|hwbn
operator|=
name|RDBTOS
argument_list|(
name|pbn
operator|+
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|pbn
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
block|}
else|else
block|{
name|hwbn
operator|=
name|sp
operator|->
name|c_blk
expr_stmt|;
name|pbn
operator|=
name|RDSTOB
argument_list|(
name|hwbn
argument_list|)
operator|-
name|pbn
expr_stmt|;
block|}
comment|/* 	 * Now output a generic message suitable for badsect. 	 * Note that we don't use harderr cuz it just prints 	 * out b_blkno which is just the beginning block number 	 * of the transfer, not necessary where the error occured. 	 */
name|printf
argument_list|(
literal|"rd%d%c: hard error sn%d\n"
argument_list|,
name|rdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
literal|'a'
operator|+
name|rdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
name|pbn
argument_list|)
expr_stmt|;
comment|/* 	 * Now report the status as returned by the hardware with 	 * attempt at interpretation (unless debugging). 	 */
name|printf
argument_list|(
literal|"rd%d %s error:"
argument_list|,
name|unit
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rddebug
operator|&
name|RDB_ERROR
condition|)
block|{
comment|/* status info */
name|printf
argument_list|(
literal|"\n    volume: %d, unit: %d\n"
argument_list|,
operator|(
name|sp
operator|->
name|c_vu
operator|>>
literal|4
operator|)
operator|&
literal|0xF
argument_list|,
name|sp
operator|->
name|c_vu
operator|&
literal|0xF
argument_list|)
expr_stmt|;
name|rdprinterr
argument_list|(
literal|"reject"
argument_list|,
name|sp
operator|->
name|c_ref
argument_list|,
name|err_reject
argument_list|)
expr_stmt|;
name|rdprinterr
argument_list|(
literal|"fault"
argument_list|,
name|sp
operator|->
name|c_fef
argument_list|,
name|err_fault
argument_list|)
expr_stmt|;
name|rdprinterr
argument_list|(
literal|"access"
argument_list|,
name|sp
operator|->
name|c_aef
argument_list|,
name|err_access
argument_list|)
expr_stmt|;
name|rdprinterr
argument_list|(
literal|"info"
argument_list|,
name|sp
operator|->
name|c_ief
argument_list|,
name|err_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    block: %d, P1-P10: "
argument_list|,
name|hwbn
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|sp
operator|->
name|c_raw
index|[
literal|0
index|]
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|sp
operator|->
name|c_raw
index|[
literal|4
index|]
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|sp
operator|->
name|c_raw
index|[
literal|8
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* command */
name|printf
argument_list|(
literal|"    ioc: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_pad
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_hiaddr
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_addr
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_nop2
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_len
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_cmd
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|printf
argument_list|(
literal|" v%d u%d, R0x%x F0x%x A0x%x I0x%x\n"
argument_list|,
operator|(
name|sp
operator|->
name|c_vu
operator|>>
literal|4
operator|)
operator|&
literal|0xF
argument_list|,
name|sp
operator|->
name|c_vu
operator|&
literal|0xF
argument_list|,
name|sp
operator|->
name|c_ref
argument_list|,
name|sp
operator|->
name|c_fef
argument_list|,
name|sp
operator|->
name|c_aef
argument_list|,
name|sp
operator|->
name|c_ief
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"P1-P10: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|sp
operator|->
name|c_raw
index|[
literal|0
index|]
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|sp
operator|->
name|c_raw
index|[
literal|4
index|]
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|hexstr
argument_list|(
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|sp
operator|->
name|c_raw
index|[
literal|8
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|int
name|rdread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flags
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
return|return
operator|(
name|physio
argument_list|(
name|rdstrategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rdwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flags
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
return|return
operator|(
name|physio
argument_list|(
name|rdstrategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rdioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|unit
init|=
name|rdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|sc
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
init|=
operator|&
name|sc
operator|->
name|sc_info
operator|.
name|ri_label
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
operator|=
operator|*
name|lp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|DIOCGPART
case|:
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|disklab
operator|=
name|lp
expr_stmt|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|part
operator|=
operator|&
name|lp
operator|->
name|d_partitions
index|[
name|rdpart
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|DIOCWLABEL
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|RDF_WLABEL
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RDF_WLABEL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|DIOCSDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
return|return
operator|(
name|setdisklabel
argument_list|(
name|lp
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
argument_list|,
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|RDF_WLABEL
operator|)
condition|?
literal|0
else|:
name|sc
operator|->
name|sc_info
operator|.
name|ri_open
argument_list|)
operator|)
return|;
case|case
name|DIOCWDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|error
operator|=
name|setdisklabel
argument_list|(
name|lp
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|data
argument_list|,
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|RDF_WLABEL
operator|)
condition|?
literal|0
else|:
name|sc
operator|->
name|sc_info
operator|.
name|ri_open
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|flags
operator|=
name|sc
operator|->
name|sc_flags
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|RDF_ALIVE
operator||
name|RDF_WLABEL
expr_stmt|;
name|error
operator|=
name|writedisklabel
argument_list|(
name|rdlabdev
argument_list|(
name|dev
argument_list|)
argument_list|,
name|rdstrategy
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rdsize
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|rdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|psize
decl_stmt|,
name|didopen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NRD
operator|||
operator|(
name|rs
operator|->
name|sc_flags
operator|&
name|RDF_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * We get called very early on (via swapconf) 	 * without the device being open so we may need 	 * to handle it here. 	 */
if|if
condition|(
name|rs
operator|->
name|sc_info
operator|.
name|ri_open
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rdopen
argument_list|(
name|dev
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|S_IFBLK
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|didopen
operator|=
literal|1
expr_stmt|;
block|}
name|psize
operator|=
name|rs
operator|->
name|sc_info
operator|.
name|ri_label
operator|.
name|d_partitions
index|[
name|rdpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
expr_stmt|;
if|if
condition|(
name|didopen
condition|)
operator|(
name|void
operator|)
name|rdclose
argument_list|(
name|dev
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|S_IFBLK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|psize
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|rdprinterr
argument_list|(
argument|str
argument_list|,
argument|err
argument_list|,
argument|tab
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|err
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tab
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|printed
decl_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"    %s error field:"
argument_list|,
name|str
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|printed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|err
operator|&
operator|(
literal|0x8000
operator|>>
name|i
operator|)
condition|)
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|printed
operator|++
condition|?
literal|" + "
else|:
literal|" "
argument_list|,
name|tab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Non-interrupt driven, non-dma dump routine.  */
end_comment

begin_function
name|int
name|rddump
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
name|int
name|part
init|=
name|rdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
name|rdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|rd_softc
modifier|*
name|rs
init|=
operator|&
name|rd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hp_device
modifier|*
name|hp
init|=
name|rs
operator|->
name|sc_hd
decl_stmt|;
specifier|register
name|struct
name|partition
modifier|*
name|pinfo
decl_stmt|;
specifier|register
name|daddr_t
name|baddr
decl_stmt|;
specifier|register
name|int
name|maddr
decl_stmt|,
name|pages
decl_stmt|,
name|i
decl_stmt|;
name|char
name|stat
decl_stmt|;
specifier|extern
name|int
name|lowram
decl_stmt|,
name|dumpsize
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
specifier|extern
name|int
name|pmapdebug
decl_stmt|;
name|pmapdebug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* is drive ok? */
if|if
condition|(
name|unit
operator|>=
name|NRD
operator|||
operator|(
name|rs
operator|->
name|sc_flags
operator|&
name|RDF_ALIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pinfo
operator|=
operator|&
name|rs
operator|->
name|sc_info
operator|.
name|ri_label
operator|.
name|d_partitions
index|[
name|part
index|]
expr_stmt|;
comment|/* dump parameters in range? */
if|if
condition|(
name|dumplo
operator|<
literal|0
operator|||
name|dumplo
operator|>=
name|pinfo
operator|->
name|p_size
operator|||
name|pinfo
operator|->
name|p_fstype
operator|!=
name|FS_SWAP
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pages
operator|=
name|dumpsize
expr_stmt|;
if|if
condition|(
name|dumplo
operator|+
name|ctod
argument_list|(
name|pages
argument_list|)
operator|>
name|pinfo
operator|->
name|p_size
condition|)
name|pages
operator|=
name|dtoc
argument_list|(
name|pinfo
operator|->
name|p_size
operator|-
name|dumplo
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|lowram
expr_stmt|;
name|baddr
operator|=
name|dumplo
operator|+
name|pinfo
operator|->
name|p_offset
expr_stmt|;
comment|/* HPIB idle? */
if|if
condition|(
operator|!
name|hpibreq
argument_list|(
operator|&
name|rs
operator|->
name|sc_dq
argument_list|)
condition|)
block|{
name|hpibreset
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|)
expr_stmt|;
name|rdreset
argument_list|(
name|rs
argument_list|,
name|rs
operator|->
name|sc_hd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[ drive %d reset ] "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pages
condition|;
name|i
operator|++
control|)
block|{
define|#
directive|define
name|NPGMB
value|(1024*1024/NBPG)
comment|/* print out how many Mbs we have dumped */
if|if
condition|(
name|i
operator|&&
operator|(
name|i
operator|%
name|NPGMB
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|i
operator|/
name|NPGMB
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|NPBMG
name|rs
operator|->
name|sc_ioc
operator|.
name|c_unit
operator|=
name|C_SUNIT
argument_list|(
name|rs
operator|->
name|sc_punit
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_volume
operator|=
name|C_SVOL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_saddr
operator|=
name|C_SADDR
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_hiaddr
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_addr
operator|=
name|RDBTOS
argument_list|(
name|baddr
argument_list|)
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_nop2
operator|=
name|C_NOP
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_slen
operator|=
name|C_SLEN
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_len
operator|=
name|NBPG
expr_stmt|;
name|rs
operator|->
name|sc_ioc
operator|.
name|c_cmd
operator|=
name|C_WRITE
expr_stmt|;
name|hpibsend
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_CMD
argument_list|,
operator|&
name|rs
operator|->
name|sc_ioc
operator|.
name|c_unit
argument_list|,
sizeof|sizeof
argument_list|(
name|rs
operator|->
name|sc_ioc
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpibswait
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|vmmap
argument_list|,
name|maddr
argument_list|,
name|VM_PROT_READ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|hpibsend
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_EXEC
argument_list|,
name|vmmap
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hpibswait
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|)
expr_stmt|;
name|hpibrecv
argument_list|(
name|hp
operator|->
name|hp_ctlr
argument_list|,
name|hp
operator|->
name|hp_slave
argument_list|,
name|C_QSTAT
argument_list|,
operator|&
name|stat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|maddr
operator|+=
name|NBPG
expr_stmt|;
name|baddr
operator|+=
name|ctod
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

