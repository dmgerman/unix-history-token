begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	if_hy.c	6.1	83/07/29	*/
end_comment

begin_include
include|#
directive|include
file|"hy.h"
end_include

begin_if
if|#
directive|if
name|NHY
operator|>
literal|0
end_if

begin_comment
comment|/*  * Network Systems Copropration Hyperchanel interface  *  * UNTESTED WITH 4.2  */
end_comment

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/vmmac.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/time.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../h/ioctl.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip_var.h"
end_include

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_include
include|#
directive|include
file|"../vaxif/if_hy.h"
end_include

begin_include
include|#
directive|include
file|"../vaxif/if_hyreg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxif/if_uba.h"
end_include

begin_define
define|#
directive|define
name|HYROUTE
end_define

begin_define
define|#
directive|define
name|HYELOG
end_define

begin_define
define|#
directive|define
name|HYMTU
value|576
end_define

begin_decl_stmt
name|int
name|hyprobe
argument_list|()
decl_stmt|,
name|hyattach
argument_list|()
decl_stmt|,
name|hyinit
argument_list|()
decl_stmt|,
name|hyioctl
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hyoutput
argument_list|()
decl_stmt|,
name|hyreset
argument_list|()
decl_stmt|,
name|hywatch
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|hyinfo
index|[
name|NHY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|hystd
index|[]
init|=
block|{
literal|0772410
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|hydriver
init|=
block|{
name|hyprobe
block|,
literal|0
block|,
name|hyattach
block|,
literal|0
block|,
name|hystd
block|,
literal|"hy"
block|,
name|hyinfo
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hyperchannel software status per interface.  *  * Each interface is referenced by a network interface structure,  * hy_if, which the routing code uses to locate the interface.  * This structure contains the output queue for the interface, its address, ...  * We also have, for each interface, a UBA interface structure, which  * contains information about the UNIBUS resources held by the interface:  * map registers, buffered data paths, etc.  Information is cached in this  * structure for use by the if_uba.c routines in running the interface  * efficiently.  */
end_comment

begin_struct
struct|struct
name|hy_softc
block|{
name|struct
name|ifnet
name|hy_if
decl_stmt|;
comment|/* network-visible interface */
name|struct
name|ifuba
name|hy_ifuba
decl_stmt|;
comment|/* UNIBUS resources */
name|short
name|hy_flags
decl_stmt|;
comment|/* flags */
name|short
name|hy_state
decl_stmt|;
comment|/* driver state */
name|int
name|hy_ilen
decl_stmt|;
comment|/* mp length on input */
name|int
name|hy_olen
decl_stmt|;
comment|/* packet length on output */
name|int
name|hy_lastwcr
decl_stmt|;
comment|/* last command's word count */
name|short
name|hy_savedstate
decl_stmt|;
comment|/* saved for reissue after status */
name|short
name|hy_savedcmd
decl_stmt|;
comment|/* saved command for reissue */
name|int
name|hy_savedcount
decl_stmt|;
comment|/* saved byte count for reissue */
name|int
name|hy_savedaddr
decl_stmt|;
comment|/* saved unibus address for reissue */
name|int
name|hy_ntime
decl_stmt|;
comment|/* number of timeouts since last cmd */
name|int
name|hy_retry
decl_stmt|;
comment|/* retry counter */
name|struct
name|hy_stat
name|hy_stat
decl_stmt|;
comment|/* statistics */
name|struct
name|hy_status
name|hy_status
decl_stmt|;
comment|/* status */
block|}
name|hy_softc
index|[
name|NHY
index|]
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|HYELOG
end_ifdef

begin_define
define|#
directive|define
name|HYE_MAX
value|0x18
end_define

begin_decl_stmt
name|u_long
name|hy_elog
index|[
operator|(
name|HYE_MAX
operator|+
literal|1
operator|)
operator|*
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|printL
value|lprintf
end_define

begin_define
define|#
directive|define
name|printD
value|if (hy_debug_flag) lprintf
end_define

begin_decl_stmt
name|int
name|hy_debug_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * hy_nodebug bit 0x01	set hy_debug_flag on hycancel  * hy_nodebug bit 0x02	set hy_debug_flag on command reissue  * hy_nodebug bit 0x04	set hy_debug_flag on abnormal interrupt  * hy_nodebug bit 0x08	set hy_debug_flag on hyouput  * hy_nodebug bit 0x10	set hy_debug_flag on hyouput with associated data  */
end_comment

begin_decl_stmt
name|int
name|hy_nodebug
init|=
literal|0x0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|printD
value|hyvoid
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Requests for service (in order by descending priority).  */
end_comment

begin_define
define|#
directive|define
name|RQ_ENDOP
value|001
end_define

begin_comment
comment|/* end the last adapter function */
end_comment

begin_define
define|#
directive|define
name|RQ_REISSUE
value|002
end_define

begin_comment
comment|/* reissue previous cmd after status */
end_comment

begin_define
define|#
directive|define
name|RQ_STATUS
value|004
end_define

begin_comment
comment|/* get the status of the adapter */
end_comment

begin_define
define|#
directive|define
name|RQ_STATISTICS
value|010
end_define

begin_comment
comment|/* get the statistics of the adapter */
end_comment

begin_define
define|#
directive|define
name|RQ_MARKDOWN
value|020
end_define

begin_comment
comment|/* mark this adapter port down */
end_comment

begin_define
define|#
directive|define
name|RQ_MARKUP
value|040
end_define

begin_comment
comment|/* mark this interface up */
end_comment

begin_define
define|#
directive|define
name|RQ_XASSOC
value|0100
end_define

begin_comment
comment|/* associated data to transmit */
end_comment

begin_comment
comment|/*   * Driver states.  */
end_comment

begin_define
define|#
directive|define
name|STARTUP
value|0
end_define

begin_comment
comment|/* initial state (before fully there) */
end_comment

begin_define
define|#
directive|define
name|IDLE
value|1
end_define

begin_comment
comment|/* idle state */
end_comment

begin_define
define|#
directive|define
name|STATSENT
value|2
end_define

begin_comment
comment|/* status cmd sent to adapter */
end_comment

begin_define
define|#
directive|define
name|ENDOPSENT
value|3
end_define

begin_comment
comment|/* end operation cmd sent */
end_comment

begin_define
define|#
directive|define
name|RECVSENT
value|4
end_define

begin_comment
comment|/* input message cmd sent */
end_comment

begin_define
define|#
directive|define
name|RECVDATASENT
value|5
end_define

begin_comment
comment|/* input data cmd sent */
end_comment

begin_define
define|#
directive|define
name|XMITSENT
value|6
end_define

begin_comment
comment|/* transmit message cmd sent */
end_comment

begin_define
define|#
directive|define
name|XMITDATASENT
value|7
end_define

begin_comment
comment|/* transmit data cmd sent */
end_comment

begin_define
define|#
directive|define
name|WAITING
value|8
end_define

begin_comment
comment|/* waiting for messages */
end_comment

begin_define
define|#
directive|define
name|CLEARSENT
value|9
end_define

begin_comment
comment|/* clear wait for message cmd sent */
end_comment

begin_define
define|#
directive|define
name|MARKPORT
value|10
end_define

begin_comment
comment|/* mark this host's adapter port down issued */
end_comment

begin_define
define|#
directive|define
name|RSTATSENT
value|11
end_define

begin_comment
comment|/* read statistics cmd sent to adapter */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|hy_state_names
index|[]
init|=
block|{
literal|"Startup"
block|,
literal|"Idle"
block|,
literal|"Status Sent"
block|,
literal|"End op Sent"
block|,
literal|"Recieve Message Proper Sent"
block|,
literal|"Recieve Data Sent"
block|,
literal|"Transmit Message Proper Sent"
block|,
literal|"Transmit Data Sent"
block|,
literal|"Wait for Message Sent"
block|,
literal|"Clear Wait for Message Sent"
block|,
literal|"Mark Port Down Sent"
block|,
literal|"Read Statistics Sent"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SCANINTERVAL
value|10
end_define

begin_comment
comment|/* seconds */
end_comment

begin_define
define|#
directive|define
name|MAXINTERVAL
value|20
end_define

begin_comment
comment|/* seconds (max action) */
end_comment

begin_comment
comment|/*  * Cause a device interrupt.  This code uses a buffer starting at  * location zero on the unibus (which is already mapped by the  * autoconfigure code in the kernel).  */
end_comment

begin_macro
name|hyprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* r11, r10 value-result */
specifier|register
name|struct
name|hydevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|hydevice
operator|*
operator|)
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|hyint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * request adapter status to a buffer starting at unibus location 0 	 */
name|addr
operator|->
name|hyd_bar
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|hyd_wcr
operator|=
operator|-
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|hy_status
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|addr
operator|->
name|hyd_dbuf
operator|=
name|HYF_STATUS
expr_stmt|;
ifdef|#
directive|ifdef
name|PI13
name|addr
operator|->
name|hyd_csr
operator||=
name|S_GO
operator||
name|S_IE
operator||
name|S_IATTN
expr_stmt|;
else|#
directive|else
name|addr
operator|->
name|hyd_csr
operator||=
name|S_GO
operator||
name|S_IE
expr_stmt|;
endif|#
directive|endif
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PI13
name|addr
operator|->
name|hyd_csr
operator||=
name|S_CLRINT
expr_stmt|;
comment|/* clear any stacked interrupts */
endif|#
directive|endif
name|addr
operator|->
name|hyd_csr
operator|&=
operator|~
operator|(
name|S_IE
operator||
name|S_CLRINT
operator|)
expr_stmt|;
comment|/* disable further interrupts */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_macro
name|hyattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|is
operator|->
name|hy_if
decl_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|ui
operator|->
name|ui_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"hy"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|HYMTU
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|STARTUP
expr_stmt|;
comment|/* don't allow state transitions yet */
name|ifp
operator|->
name|if_init
operator|=
name|hyinit
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|hyioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|hyoutput
expr_stmt|;
name|ifp
operator|->
name|if_reset
operator|=
name|hyreset
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|hywatch
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
name|SCANINTERVAL
expr_stmt|;
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_flags
operator|=
name|UBA_CANTWAIT
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_flags
operator||=
name|UBA_NEEDBDP
expr_stmt|;
endif|#
directive|endif
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reset of interface after UNIBUS reset.  * If interface is on specified uba, reset its state.  */
end_comment

begin_macro
name|hyreset
argument_list|(
argument|unit
argument_list|,
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|hyinfo
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NHY
operator|||
name|ui
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_ubanum
operator|!=
name|uban
condition|)
return|return;
name|printf
argument_list|(
literal|" hy%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|hyinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialization of interface; clear recorded pending  * operations, and reinitialize UNIBUS usage.  */
end_comment

begin_macro
name|hyinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|hyinfo
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|is
operator|->
name|hy_if
operator|.
name|if_addr
expr_stmt|;
if|if
condition|(
name|in_netof
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|if_ubainit
argument_list|(
operator|&
name|is
operator|->
name|hy_ifuba
argument_list|,
name|ui
operator|->
name|ui_ubanum
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hy_hdr
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|btoc
argument_list|(
name|HYMTU
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hy_nodebug
operator|&
literal|4
condition|)
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"hy%d: can't initialize\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
return|return;
block|}
name|is
operator|->
name|hy_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
comment|/* 	 * Issue wait for message and start the state machine 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
name|is
operator|->
name|hy_flags
operator|=
name|RQ_STATUS
operator||
name|RQ_STATISTICS
operator||
name|RQ_MARKUP
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
name|hyact
argument_list|(
name|ui
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Issue a command to the adapter  */
end_comment

begin_macro
name|hystart
argument_list|(
argument|ui
argument_list|,
argument|cmd
argument_list|,
argument|count
argument_list|,
argument|ubaddr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|,
name|count
decl_stmt|,
name|ubaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hydevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|hydevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: hystart cmd = 0x%x count=%d ubaddr=0x%x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|cmd
argument_list|,
name|count
argument_list|,
name|ubaddr
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|"hy%d: - csr = 0x%b, bar = 0x%x, wcr = 0x%x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|addr
operator|->
name|hyd_csr
argument_list|,
name|HY_CSR_BITS
argument_list|,
name|addr
operator|->
name|hyd_bar
argument_list|,
name|addr
operator|->
name|hyd_wcr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|is
operator|->
name|hy_flags
operator|&
name|RQ_REISSUE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|HYF_STATUS
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|HYF_END_OP
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|HYF_RSTATS
operator|)
condition|)
block|{
name|is
operator|->
name|hy_savedstate
operator|=
name|is
operator|->
name|hy_state
expr_stmt|;
name|is
operator|->
name|hy_savedcmd
operator|=
name|cmd
expr_stmt|;
name|is
operator|->
name|hy_savedcount
operator|=
name|count
expr_stmt|;
name|is
operator|->
name|hy_savedaddr
operator|=
name|ubaddr
expr_stmt|;
block|}
name|addr
operator|->
name|hyd_bar
operator|=
name|ubaddr
operator|&
literal|0xffff
expr_stmt|;
name|addr
operator|->
name|hyd_wcr
operator|=
name|is
operator|->
name|hy_lastwcr
operator|=
operator|-
operator|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|addr
operator|->
name|hyd_dbuf
operator|=
name|cmd
expr_stmt|;
ifdef|#
directive|ifdef
name|PI13
name|addr
operator|->
name|hyd_csr
operator|=
operator|(
operator|(
name|ubaddr
operator|>>
name|XBASHIFT
operator|)
operator|&
name|S_XBA
operator|)
operator||
name|S_GO
operator||
name|S_IE
operator||
name|S_IATTN
expr_stmt|;
else|#
directive|else
name|addr
operator|->
name|hyd_csr
operator|=
operator|(
operator|(
name|ubaddr
operator|>>
name|XBASHIFT
operator|)
operator|&
name|S_XBA
operator|)
operator||
name|S_GO
operator||
name|S_IE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: exit hystart - csr = 0x%b, bar = 0x%x, wcr = 0x%x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|addr
operator|->
name|hyd_csr
argument_list|,
name|HY_CSR_BITS
argument_list|,
name|addr
operator|->
name|hyd_bar
argument_list|,
name|addr
operator|->
name|hyd_wcr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HYLOG
block|{
struct|struct
block|{
name|u_char
name|hcmd
decl_stmt|;
name|u_char
name|hstate
decl_stmt|;
name|short
name|hcount
decl_stmt|;
block|}
name|hcl
struct|;
name|hcl
operator|.
name|hcmd
operator|=
name|cmd
expr_stmt|;
name|hcl
operator|.
name|hstate
operator|=
name|is
operator|->
name|hy_state
expr_stmt|;
name|hcl
operator|.
name|hcount
operator|=
name|count
expr_stmt|;
name|hylog
argument_list|(
name|HYL_CMD
argument_list|,
sizeof|sizeof
argument_list|(
name|hcl
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hcl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|is
operator|->
name|hy_ntime
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|hyint_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set during hy interrupt */
end_comment

begin_comment
comment|/*  * Hyperchannel interface interrupt.  *  * An interrupt can occur for many reasons.  Examine the status of  * the hyperchannel status bits to determine what to do next.  *  * If input error just drop packet.  * Otherwise purge input buffered data path and examine   * packet to determine type.  Othewise decapsulate  * packet based on type and pass to type specific higher-level  * input routine.  */
end_comment

begin_macro
name|hyint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|hyinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hydevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|hydevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
if|if
condition|(
name|hyint_active
condition|)
name|panic
argument_list|(
literal|"RECURSIVE HYPERCHANNEL INTERRUPT"
argument_list|)
expr_stmt|;
name|hyint_active
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: hyint enter - csr = 0x%b, bar = 0x%x, wcr = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|addr
operator|->
name|hyd_csr
argument_list|,
name|HY_CSR_BITS
argument_list|,
name|addr
operator|->
name|hyd_bar
argument_list|,
name|addr
operator|->
name|hyd_wcr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HYLOG
name|logit
label|:
block|{
struct|struct
block|{
name|u_char
name|hstate
decl_stmt|;
name|u_char
name|hflags
decl_stmt|;
name|short
name|hcsr
decl_stmt|;
name|short
name|hwcr
decl_stmt|;
block|}
name|hil
struct|;
name|hil
operator|.
name|hstate
operator|=
name|is
operator|->
name|hy_state
expr_stmt|;
name|hil
operator|.
name|hflags
operator|=
name|is
operator|->
name|hy_flags
expr_stmt|;
name|hil
operator|.
name|hcsr
operator|=
name|addr
operator|->
name|hyd_csr
expr_stmt|;
name|hil
operator|.
name|hwcr
operator|=
name|addr
operator|->
name|hyd_wcr
expr_stmt|;
name|hylog
argument_list|(
name|HYL_INT
argument_list|,
sizeof|sizeof
argument_list|(
name|hil
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hil
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|HYS_ERROR
argument_list|(
name|addr
argument_list|)
operator|&&
operator|(
operator|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_ATTN
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Error bit set, some sort of error in the interface. 		 * 		 * The adapter sets attn on command completion so that's not 		 * a real error even though the interface considers it one. 		 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hy_nodebug
operator|&
literal|4
condition|)
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"csr = 0x%b\nbar = 0x%x\nwcr = 0x%x\n"
argument_list|,
name|addr
operator|->
name|hyd_csr
argument_list|,
name|HY_CSR_BITS
argument_list|,
name|addr
operator|->
name|hyd_bar
argument_list|,
name|addr
operator|->
name|hyd_wcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_NEX
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: NEX - Non Existant Memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PI13
name|addr
operator|->
name|hyd_csr
operator||=
name|S_NEX
expr_stmt|;
comment|/* as per PI13 manual */
else|#
directive|else
name|addr
operator|->
name|hyd_csr
operator|&=
operator|~
name|S_NEX
expr_stmt|;
endif|#
directive|endif
name|hycancel
argument_list|(
name|ui
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PI13
block|}
elseif|else
if|if
condition|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_POWEROFF
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: Power Off bit set, trying to reset\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|addr
operator|->
name|hyd_csr
operator||=
name|S_POWEROFF
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_POWEROFF
condition|)
block|{
name|if_down
argument_list|(
operator|&
name|is
operator|->
name|hy_if
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|STARTUP
expr_stmt|;
name|printf
argument_list|(
literal|"hy%d: Power Off Error, network shutdown\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|printf
argument_list|(
literal|"hy%d:  BAR overflow\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|hycancel
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|HYS_NORMAL
argument_list|(
name|addr
argument_list|)
condition|)
block|{
comment|/* 		 * Normal interrupt, bump state machine unless in state 		 * waiting and no data present (assumed to be word count 		 * zero interrupt or other hardware botch). 		 */
if|if
condition|(
name|is
operator|->
name|hy_state
operator|!=
name|WAITING
operator|||
name|HYS_RECVDATA
argument_list|(
name|addr
argument_list|)
condition|)
name|hyact
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HYS_ABNORMAL
argument_list|(
name|addr
argument_list|)
condition|)
block|{
comment|/* 		 * Abnormal termination. 		 * bump error counts, retry the last function 		 * 'MAXRETRY' times before kicking the bucket. 		 * 		 * Don't reissue the cmd if in certain states, abnormal 		 * on a reissued cmd or max retry exceeded. 		 */
ifdef|#
directive|ifdef
name|HYLOG
if|if
condition|(
name|hy_log
operator|.
name|hyl_enable
operator|!=
name|hy_log
operator|.
name|hyl_onerr
condition|)
block|{
name|hy_log
operator|.
name|hyl_enable
operator|=
name|hy_log
operator|.
name|hyl_onerr
expr_stmt|;
goto|goto
name|logit
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hy_nodebug
operator|&
literal|4
condition|)
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
name|printD
argument_list|(
literal|"hy%d: abnormal interrupt, driver state \"%s\" (%d)\n"
argument_list|,
name|unit
argument_list|,
name|hy_state_names
index|[
name|is
operator|->
name|hy_state
index|]
argument_list|,
name|is
operator|->
name|hy_state
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|"\tflags 0x%x ilen %d olen %d lastwcr %d retry %d\n"
argument_list|,
name|is
operator|->
name|hy_flags
argument_list|,
name|is
operator|->
name|hy_ilen
argument_list|,
name|is
operator|->
name|hy_olen
argument_list|,
name|is
operator|->
name|hy_lastwcr
argument_list|,
name|is
operator|->
name|hy_retry
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|"\tsaved: state %d count %d cmd 0x%x ptr 0x%x\n"
argument_list|,
name|is
operator|->
name|hy_savedstate
argument_list|,
name|is
operator|->
name|hy_savedcount
argument_list|,
name|is
operator|->
name|hy_savedaddr
argument_list|,
name|is
operator|->
name|hy_savedcmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PI13
name|addr
operator|->
name|hyd_csr
operator|&=
operator|~
name|S_C
expr_stmt|;
comment|/* clear the damned PI-13 */
endif|#
directive|endif
if|if
condition|(
name|is
operator|->
name|hy_state
operator|==
name|XMITSENT
operator|||
name|is
operator|->
name|hy_state
operator|==
name|XMITDATASENT
condition|)
name|is
operator|->
name|hy_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_state
operator|==
name|RECVSENT
operator|||
name|is
operator|->
name|hy_state
operator|==
name|RECVDATASENT
condition|)
name|is
operator|->
name|hy_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_state
operator|==
name|XMITDATASENT
operator|||
name|is
operator|->
name|hy_state
operator|==
name|RECVSENT
operator|||
name|is
operator|->
name|hy_state
operator|==
name|RECVDATASENT
operator|||
operator|(
name|is
operator|->
name|hy_flags
operator|&
name|RQ_REISSUE
operator|)
operator|!=
literal|0
operator|||
name|is
operator|->
name|hy_retry
operator|>
name|MAXRETRY
condition|)
name|hycancel
argument_list|(
name|ui
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hy_nodebug
operator|&
literal|2
condition|)
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|is
operator|->
name|hy_retry
operator|++
expr_stmt|;
name|is
operator|->
name|hy_flags
operator||=
name|RQ_ENDOP
operator||
name|RQ_STATUS
operator||
name|RQ_REISSUE
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
name|hyact
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Interrupt is neither normal, abnormal, or interface error. 		 * Ignore it. It's either stacked or a word count 0. 		 */
ifdef|#
directive|ifdef
name|HYLOG
if|if
condition|(
name|hy_log
operator|.
name|hyl_enable
operator|!=
name|hy_log
operator|.
name|hyl_onerr
condition|)
block|{
name|hy_log
operator|.
name|hyl_enable
operator|=
name|hy_log
operator|.
name|hyl_onerr
expr_stmt|;
goto|goto
name|logit
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: possible stacked interrupt ignored\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: hyint exit\n\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hyint_active
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Encapsulate a packet of type family for the local net.  */
end_comment

begin_macro
name|hyoutput
argument_list|(
argument|ifp
argument_list|,
argument|m0
argument_list|,
argument|dst
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hym_hdr
modifier|*
name|hym
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|HYROUTE
specifier|register
name|struct
name|hyroute
modifier|*
name|r
init|=
operator|&
name|hy_route
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
endif|#
directive|endif
name|short
name|dtype
decl_stmt|;
comment|/* packet type */
name|int
name|dhost
decl_stmt|;
comment|/* destination adapter address */
name|int
name|dlen
decl_stmt|;
name|int
name|mplen
init|=
literal|0
decl_stmt|;
comment|/* message proper length */
name|short
name|loopback
init|=
literal|0
decl_stmt|;
comment|/* hardware loopback requested */
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hy_nodebug
operator|&
literal|8
condition|)
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|dlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|dlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
decl_stmt|;
specifier|register
name|long
name|hostaddr
init|=
name|in_lnaof
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
decl_stmt|;
name|dhost
operator|=
name|hostaddr
operator|&
literal|0xffff
expr_stmt|;
name|dtype
operator|=
name|HYLINK_IP
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: output to host %x, dhost %x\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|dhost
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Debugging loopback support: 		 * upper byte of 24 bit host number interpreted as follows 		 *	0x00 --> no loopback 		 *	0x01 --> hardware loop through remote adapter 		 *	other --> software loop through remote ip layer 		 */
if|if
condition|(
name|hostaddr
operator|&
literal|0xff0000
condition|)
block|{
name|struct
name|in_addr
name|temp
decl_stmt|;
name|temp
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|(
name|hostaddr
operator|&
literal|0xff0000
operator|)
operator|==
literal|0x10000
condition|)
name|loopback
operator|=
name|H_LOOPBK
expr_stmt|;
block|}
comment|/* 		 * If entire packet won't fit in message proper, just 		 * send hyperchannel hardware header and ip header in 		 * message proper.  If that won't fit either, just send 		 * the maximum message proper. 		 * 		 * This insures that the associated data is at least a 		 * TCP/UDP header in length and thus prevents potential 		 * problems with very short word counts. 		 */
if|if
condition|(
name|dlen
operator|>
name|MPSIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|hy_hdr
argument_list|)
condition|)
block|{
name|mplen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|hy_hdr
argument_list|)
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|mplen
operator|>
name|MPSIZE
condition|)
name|mplen
operator|=
name|MPSIZE
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"hy%d: can't handle af%d\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hy_nodebug
operator|&
literal|4
condition|)
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* 	 * Add the software and hardware hyperchannel headers. 	 * If there's not enough space in the first mbuf, allocate another. 	 * If that should fail, drop this sucker. 	 * No extra space for headers is allocated. 	 */
if|if
condition|(
name|m
operator|->
name|m_off
operator|>
name|MMAXOFF
operator|||
name|MMINOFF
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
operator|>
name|m
operator|->
name|m_off
condition|)
block|{
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|m0
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMINOFF
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
expr_stmt|;
block|}
name|hym
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|hym_hdr
operator|*
argument_list|)
expr_stmt|;
name|hym
operator|->
name|hym_mplen
operator|=
name|mplen
expr_stmt|;
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_type
operator|=
name|dtype
expr_stmt|;
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_off
operator|=
literal|0
expr_stmt|;
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_from
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|ifp
operator|->
name|if_host
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_param
operator|=
name|loopback
expr_stmt|;
ifdef|#
directive|ifdef
name|HYROUTE
if|if
condition|(
name|r
operator|->
name|hyr_lasttime
operator|.
name|tv_sec
operator|!=
literal|0
condition|)
block|{
specifier|register
name|struct
name|hy_hash
modifier|*
name|rh
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|HYRHASH
argument_list|(
name|dhost
argument_list|)
expr_stmt|;
name|rh
operator|=
operator|&
name|r
operator|->
name|hyr_hash
index|[
name|i
index|]
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rh
operator|->
name|hyr_key
operator|!=
name|dhost
condition|)
block|{
name|rh
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|rh
operator|>
operator|&
name|r
operator|->
name|hyr_hash
index|[
name|HYRSIZE
index|]
condition|)
name|rh
operator|=
operator|&
name|r
operator|->
name|hyr_hash
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|rh
operator|->
name|hyr_flags
operator|==
literal|0
operator|||
name|i
operator|>
name|HYRSIZE
condition|)
goto|goto
name|notfound
goto|;
block|}
if|if
condition|(
name|rh
operator|->
name|hyr_flags
operator|&
name|HYR_GATE
condition|)
block|{
name|loopback
operator|=
literal|0
expr_stmt|;
comment|/* no hardware loopback on gateways */
name|i
operator|=
name|rh
operator|->
name|hyr_nextgate
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|rh
operator|->
name|hyr_egate
condition|)
name|rh
operator|->
name|hyr_nextgate
operator|=
name|rh
operator|->
name|hyr_pgate
expr_stmt|;
else|else
name|rh
operator|->
name|hyr_nextgate
operator|++
expr_stmt|;
name|rh
operator|=
operator|&
name|r
operator|->
name|hyr_hash
index|[
name|r
operator|->
name|hyr_gateway
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rh
operator|->
name|hyr_flags
operator|&
name|HYR_DIR
operator|)
operator|==
literal|0
condition|)
goto|goto
name|notfound
goto|;
block|}
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_ctl
operator|=
name|rh
operator|->
name|hyr_ctl
expr_stmt|;
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_access
operator|=
name|rh
operator|->
name|hyr_access
expr_stmt|;
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_to
operator|=
name|rh
operator|->
name|hyr_dst
expr_stmt|;
block|}
else|else
block|{
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_ctl
operator|=
name|H_XTRUNKS
operator||
name|H_RTRUNKS
expr_stmt|;
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_access
operator|=
literal|0
expr_stmt|;
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_to
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|dhost
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_ctl
operator|=
name|H_XTRUNKS
operator||
name|H_RTRUNKS
expr_stmt|;
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_access
operator|=
literal|0
expr_stmt|;
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_to
operator|=
name|htons
argument_list|(
name|dhost
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hym
operator|->
name|hym_mplen
condition|)
block|{
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_ctl
operator||=
name|H_ASSOC
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hy_nodebug
operator|&
literal|16
condition|)
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_ctl
operator|&=
operator|~
name|H_ASSOC
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: output mplen=%x ctl=%x access=%x to=%x"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|hym
operator|->
name|hym_mplen
argument_list|,
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_ctl
argument_list|,
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_access
argument_list|,
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_to
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|" (adapter %x) from=%x param=%x type=%x off=%x\n"
argument_list|,
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_to_adapter
argument_list|,
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_from
argument_list|,
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_param
argument_list|,
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_type
argument_list|,
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_off
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|hy_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|hy_state
operator|==
name|WAITING
condition|)
name|hyact
argument_list|(
name|hyinfo
index|[
name|ifp
operator|->
name|if_unit
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|notfound
label|:
name|error
operator|=
name|ENETUNREACH
expr_stmt|;
comment|/* XXX */
name|drop
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|hyact
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hydevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|hydevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
name|actloop
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: hyact, enter state \"%s\"\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|hy_state_names
index|[
name|is
operator|->
name|hy_state
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|is
operator|->
name|hy_state
condition|)
block|{
case|case
name|STARTUP
case|:
goto|goto
name|endintr
goto|;
case|case
name|IDLE
case|:
block|{
specifier|register
name|rq
operator|=
name|is
operator|->
name|hy_flags
expr_stmt|;
if|if
condition|(
name|rq
operator|&
name|RQ_STATUS
condition|)
block|{
name|is
operator|->
name|hy_flags
operator|&=
operator|~
name|RQ_STATUS
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|STATSENT
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_STATUS
argument_list|,
sizeof|sizeof
argument_list|(
name|is
operator|->
name|hy_status
argument_list|)
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|&
name|RQ_ENDOP
condition|)
block|{
name|is
operator|->
name|hy_flags
operator|&=
operator|~
name|RQ_ENDOP
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|ENDOPSENT
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_END_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|&
name|RQ_STATISTICS
condition|)
block|{
name|is
operator|->
name|hy_flags
operator|&=
operator|~
name|RQ_STATISTICS
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|RSTATSENT
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_RSTATS
argument_list|,
sizeof|sizeof
argument_list|(
name|is
operator|->
name|hy_stat
argument_list|)
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HYS_RECVDATA
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|is
operator|->
name|hy_state
operator|=
name|RECVSENT
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_INPUTMSG
argument_list|,
name|MPSIZE
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|&
name|RQ_REISSUE
condition|)
block|{
name|is
operator|->
name|hy_flags
operator|&=
operator|~
name|RQ_REISSUE
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|is
operator|->
name|hy_savedstate
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: reissue cmd=0x%x count=%d"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|is
operator|->
name|hy_savedcmd
argument_list|,
name|is
operator|->
name|hy_savedcount
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|" ubaddr=0x%x retry=%d\n"
argument_list|,
name|is
operator|->
name|hy_savedaddr
argument_list|,
name|is
operator|->
name|hy_retry
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hystart
argument_list|(
name|ui
argument_list|,
name|is
operator|->
name|hy_savedcmd
argument_list|,
name|is
operator|->
name|hy_savedcount
argument_list|,
name|is
operator|->
name|hy_savedaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|is
operator|->
name|hy_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|struct
name|hym_hdr
modifier|*
name|hym
decl_stmt|;
specifier|register
name|int
name|mplen
decl_stmt|;
specifier|register
name|int
name|cmd
decl_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|XMITSENT
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
name|hym
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|hym_hdr
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HYLOG
name|hylog
argument_list|(
name|HYL_XMIT
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hym
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mplen
operator|=
name|hym
operator|->
name|hym_mplen
expr_stmt|;
if|if
condition|(
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_to_adapter
operator|==
name|hym
operator|->
name|hym_hdr
operator|.
name|hyh_from_adapter
condition|)
name|cmd
operator|=
name|HYF_XMITLOCMSG
expr_stmt|;
else|else
name|cmd
operator|=
name|HYF_XMITMSG
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: hym_hdr = "
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|hy_debug_flag
condition|)
name|hyprintdata
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 				 * Strip off the software part of 				 * the hyperchannel header 				 */
name|m
operator|->
name|m_off
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|hym_data
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|hym_data
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_olen
operator|=
name|if_wubaput
argument_list|(
operator|&
name|is
operator|->
name|hy_ifuba
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_uba
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: sending packet (mplen = %d, hy_olen = %d) data = "
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|mplen
argument_list|,
name|is
operator|->
name|hy_olen
argument_list|)
expr_stmt|;
if|if
condition|(
name|hy_debug_flag
condition|)
name|hyprintdata
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_addr
argument_list|,
name|is
operator|->
name|hy_olen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hystart
argument_list|(
name|ui
argument_list|,
name|cmd
argument_list|,
operator|(
name|mplen
operator|==
literal|0
operator|)
condition|?
name|is
operator|->
name|hy_olen
else|:
name|mplen
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|mplen
operator|!=
literal|0
condition|)
name|is
operator|->
name|hy_flags
operator||=
name|RQ_XASSOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|&
name|RQ_MARKDOWN
condition|)
block|{
name|is
operator|->
name|hy_flags
operator|&=
operator|~
operator|(
name|RQ_MARKUP
operator||
name|RQ_MARKDOWN
operator|)
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|MARKPORT
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Port number is taken from status data 				 */
name|hystart
argument_list|(
name|ui
argument_list|,
call|(
name|int
call|)
argument_list|(
name|HYF_MARKP0
operator||
operator|(
name|PORTNUM
argument_list|(
operator|&
name|is
operator|->
name|hy_status
argument_list|)
operator|<<
literal|2
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|&
name|RQ_MARKUP
condition|)
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|is
operator|->
name|hy_if
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifp
operator|->
name|if_addr
decl_stmt|;
name|is
operator|->
name|hy_flags
operator|&=
operator|~
name|RQ_MARKUP
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Fill in the host number 				 * from the status buffer 				 */
name|printf
argument_list|(
literal|"hy%d: unit number 0x%x port %d type %x microcode level 0x%x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_uaddr
argument_list|,
name|PORTNUM
argument_list|(
operator|&
name|is
operator|->
name|hy_status
argument_list|)
argument_list|,
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|1
index|]
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_host
index|[
literal|0
index|]
operator|=
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_uaddr
operator|<<
literal|8
operator|)
operator||
name|PORTNUM
argument_list|(
operator|&
name|is
operator|->
name|hy_status
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|if_makeaddr
argument_list|(
name|ifp
operator|->
name|if_net
argument_list|,
name|ifp
operator|->
name|if_host
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|if_rtinit
argument_list|(
name|ifp
argument_list|,
name|RTF_UP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HYLOG
name|hylog
argument_list|(
name|HYL_UP
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|is
operator|->
name|hy_state
operator|=
name|WAITING
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_WAITFORMSG
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|STATSENT
case|:
name|bcopy
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|is
operator|->
name|hy_status
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hy_status
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: status - %x %x %x %x %x %x %x %x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_gen_status
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_last_fcn
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_resp_trunk
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_status_trunk
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_recd_resp
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_error
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_caddr
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_pad
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
ifdef|#
directive|ifdef
name|HYLOG
name|hylog
argument_list|(
name|HYL_STATUS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hy_status
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|is
operator|->
name|hy_status
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HYELOG
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|is
operator|->
name|hy_status
operator|.
name|hys_error
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|HYE_MAX
condition|)
name|i
operator|=
name|HYE_MAX
expr_stmt|;
switch|switch
condition|(
name|is
operator|->
name|hy_status
operator|.
name|hys_last_fcn
condition|)
block|{
case|case
name|HYF_XMITLOCMSG
case|:
name|i
operator|+=
name|HYE_MAX
operator|+
literal|1
expr_stmt|;
comment|/* fall through */
case|case
name|HYF_XMITLSTDATA
case|:
name|i
operator|+=
name|HYE_MAX
operator|+
literal|1
expr_stmt|;
comment|/* fall through */
case|case
name|HYF_XMITMSG
case|:
name|i
operator|+=
name|HYE_MAX
operator|+
literal|1
expr_stmt|;
block|}
name|hy_elog
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|RSTATSENT
case|:
block|{
specifier|register
name|struct
name|hy_stat
modifier|*
name|p
init|=
operator|(
expr|struct
name|hy_stat
operator|*
operator|)
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
decl_stmt|;
name|is
operator|->
name|hy_stat
operator|.
name|hyc_msgcnt
operator|=
name|ntohl
argument_list|(
name|p
operator|->
name|hyc_msgcnt
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_stat
operator|.
name|hyc_dbcnt
operator|=
name|ntohl
argument_list|(
name|p
operator|->
name|hyc_dbcnt
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_stat
operator|.
name|hyc_tbusy
operator|=
name|ntohl
argument_list|(
name|p
operator|->
name|hyc_tbusy
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_stat
operator|.
name|hyc_hwret
operator|=
name|ntohl
argument_list|(
name|p
operator|->
name|hyc_hwret
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_stat
operator|.
name|hyc_crcbad
operator|=
name|ntohl
argument_list|(
name|p
operator|->
name|hyc_crcbad
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_stat
operator|.
name|hyc_mcret
operator|=
name|ntohl
argument_list|(
name|p
operator|->
name|hyc_mcret
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_stat
operator|.
name|hyc_tdabort
operator|=
name|ntohl
argument_list|(
name|p
operator|->
name|hyc_tdabort
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|hyc_atype
index|[
literal|0
index|]
expr_stmt|;
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|1
index|]
operator|=
name|p
operator|->
name|hyc_atype
index|[
literal|1
index|]
expr_stmt|;
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|2
index|]
operator|=
name|p
operator|->
name|hyc_atype
index|[
literal|2
index|]
expr_stmt|;
name|is
operator|->
name|hy_stat
operator|.
name|hyc_uaddr
operator|=
name|p
operator|->
name|hyc_uaddr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: statistics - msgcnt %d dbcnt %d hwret %d tbusy %d crcbad %d\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_msgcnt
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_dbcnt
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_tbusy
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_hwret
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_crcbad
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|"	mcret %d tdabort %d atype %x %x %x uaddr %x\n"
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_mcret
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_tdabort
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|0
index|]
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|1
index|]
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|2
index|]
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_uaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
ifdef|#
directive|ifdef
name|HYLOG
name|hylog
argument_list|(
name|HYL_STATISTICS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hy_stat
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|is
operator|->
name|hy_stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|CLEARSENT
case|:
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
break|break;
case|case
name|ENDOPSENT
case|:
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
break|break;
case|case
name|RECVSENT
case|:
block|{
specifier|register
name|struct
name|hy_hdr
modifier|*
name|hyh
decl_stmt|;
specifier|register
name|unsigned
name|len
decl_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_uba
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
name|hyh
operator|=
operator|(
expr|struct
name|hy_hdr
operator|*
operator|)
operator|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
operator|)
expr_stmt|;
name|len
operator|=
operator|(
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|hyd_wcr
operator|-
name|is
operator|->
name|hy_lastwcr
operator|)
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MPSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: RECVD MP> MPSIZE (%d)\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
name|printD
argument_list|(
literal|"hy%d: csr = 0x%b, bar = 0x%x, wcr = 0x%x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|addr
operator|->
name|hyd_csr
argument_list|,
name|HY_CSR_BITS
argument_list|,
name|addr
operator|->
name|hyd_bar
argument_list|,
name|addr
operator|->
name|hyd_wcr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: recvd mp, len = %d, data = "
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hy_debug_flag
condition|)
name|hyprintdata
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hyh
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hyh
operator|->
name|hyh_ctl
operator|&
name|H_ASSOC
condition|)
block|{
name|is
operator|->
name|hy_state
operator|=
name|RECVDATASENT
expr_stmt|;
name|is
operator|->
name|hy_ilen
operator|=
name|len
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_INPUTDATA
argument_list|,
call|(
name|int
call|)
argument_list|(
name|HYMTU
operator|-
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|hy_hdr
argument_list|)
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
operator|+
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hyrecvdata
argument_list|(
name|ui
argument_list|,
name|hyh
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
block|}
break|break;
block|}
case|case
name|RECVDATASENT
case|:
block|{
specifier|register
name|struct
name|hy_hdr
modifier|*
name|hyh
decl_stmt|;
specifier|register
name|unsigned
name|len
decl_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_uba
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
name|hyh
operator|=
operator|(
expr|struct
name|hy_hdr
operator|*
operator|)
operator|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
operator|)
expr_stmt|;
name|len
operator|=
operator|(
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|hyd_wcr
operator|-
name|is
operator|->
name|hy_lastwcr
operator|)
operator|)
operator|<<
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: recvd assoc data, len = %d, data = "
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hy_debug_flag
condition|)
name|hyprintdata
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hyh
operator|+
name|is
operator|->
name|hy_ilen
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hyrecvdata
argument_list|(
name|ui
argument_list|,
name|hyh
argument_list|,
call|(
name|int
call|)
argument_list|(
name|len
operator|+
name|is
operator|->
name|hy_ilen
argument_list|)
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
break|break;
block|}
case|case
name|XMITSENT
case|:
if|if
condition|(
name|is
operator|->
name|hy_flags
operator|&
name|RQ_XASSOC
condition|)
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|is
operator|->
name|hy_flags
operator|&=
operator|~
name|RQ_XASSOC
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|XMITDATASENT
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
name|len
operator|=
operator|(
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|hyd_wcr
operator|-
name|is
operator|->
name|hy_lastwcr
operator|)
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|is
operator|->
name|hy_olen
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: xmit error - len> hy_olen [%d> %d]\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|len
argument_list|,
name|is
operator|->
name|hy_olen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_XMITLSTDATA
argument_list|,
name|is
operator|->
name|hy_olen
operator|-
name|len
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_info
operator|+
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall through to ... */
case|case
name|XMITDATASENT
case|:
name|hyxmitdata
argument_list|(
name|ui
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
break|break;
case|case
name|WAITING
case|:
comment|/* wait for message complete or output requested */
if|if
condition|(
name|HYS_RECVDATA
argument_list|(
name|addr
argument_list|)
condition|)
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
else|else
block|{
name|is
operator|->
name|hy_state
operator|=
name|CLEARSENT
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_CLRWFMSG
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MARKPORT
case|:
name|is
operator|->
name|hy_state
operator|=
name|STARTUP
expr_stmt|;
name|is
operator|->
name|hy_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
goto|goto
name|endintr
goto|;
default|default:
name|printf
argument_list|(
literal|"hy%d: DRIVER BUG - INVALID STATE %d\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|is
operator|->
name|hy_state
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"HYPERCHANNEL IN INVALID STATE"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|is
operator|->
name|hy_state
operator|==
name|IDLE
condition|)
goto|goto
name|actloop
goto|;
name|endintr
label|:
empty_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: hyact, exit at \"%s\"\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|hy_state_names
index|[
name|is
operator|->
name|hy_state
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Called from device interrupt when receiving data.  * Examine packet to determine type.  Decapsulate packet  * based on type and pass to type specific higher-level  * input routine.  */
end_comment

begin_macro
name|hyrecvdata
argument_list|(
argument|ui
argument_list|,
argument|hyh
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|hy_hdr
modifier|*
name|hyh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|inq
decl_stmt|;
name|is
operator|->
name|hy_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: recieved packet, len = %d (actual %d)\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|len
argument_list|,
name|len
operator|-
operator|(
name|hyh
operator|->
name|hyh_off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|hy_hdr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HYLOG
block|{
struct|struct
block|{
name|short
name|hlen
decl_stmt|;
name|struct
name|hy_hdr
name|hhdr
decl_stmt|;
block|}
name|hh
struct|;
name|hh
operator|.
name|hlen
operator|=
name|len
expr_stmt|;
name|hh
operator|.
name|hhdr
operator|=
operator|*
name|hyh
expr_stmt|;
name|hylog
argument_list|(
name|HYL_RECV
argument_list|,
sizeof|sizeof
argument_list|(
name|hh
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hh
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
name|HYMTU
operator|+
name|MPSIZE
operator|||
name|len
operator|==
literal|0
condition|)
return|return;
comment|/* sanity */
comment|/* 	 * Pull packet off interface. 	 */
name|m
operator|=
name|if_rubaget
argument_list|(
operator|&
name|is
operator|->
name|hy_ifuba
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|hyh
operator|->
name|hyh_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|HYLINK_IP
case|:
comment|/* 		 * Strip the variable portion of the hyperchannel header 		 * (fixed portion stripped in if_rubaget). 		 */
name|m
operator|->
name|m_len
operator|-=
name|hyh
operator|->
name|hyh_off
expr_stmt|;
name|m
operator|->
name|m_off
operator|+=
name|hyh
operator|->
name|hyh_off
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|IF_QFULL
argument_list|(
name|inq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|inq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|IF_ENQUEUE
argument_list|(
name|inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Transmit done, release resources, bump counters.  */
end_comment

begin_macro
name|hyxmitdata
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
name|is
operator|->
name|hy_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_xtofree
condition|)
block|{
name|m_freem
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_xtofree
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_xtofree
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|hycancel
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_xtofree
condition|)
block|{
name|m_freem
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_xtofree
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_xtofree
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hy_nodebug
operator|&
literal|1
condition|)
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: cancel from state \"%s\" cmd=0x%x count=%d ptr=0x%x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|hy_state_names
index|[
name|is
operator|->
name|hy_state
index|]
argument_list|,
name|is
operator|->
name|hy_savedcmd
argument_list|,
name|is
operator|->
name|hy_savedcount
argument_list|,
name|is
operator|->
name|hy_savedaddr
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|"\tflags 0x%x ilen %d olen %d lastwcr %d retry %d\n"
argument_list|,
name|is
operator|->
name|hy_flags
argument_list|,
name|is
operator|->
name|hy_ilen
argument_list|,
name|is
operator|->
name|hy_olen
argument_list|,
name|is
operator|->
name|hy_lastwcr
argument_list|,
name|is
operator|->
name|hy_retry
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|"\tsaved: state %d count %d ptr 0x%x cmd 0x%x\n"
argument_list|,
name|is
operator|->
name|hy_savedstate
argument_list|,
name|is
operator|->
name|hy_savedcount
argument_list|,
name|is
operator|->
name|hy_savedaddr
argument_list|,
name|is
operator|->
name|hy_savedcmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
name|is
operator|->
name|hy_flags
operator||=
operator|(
name|RQ_ENDOP
operator||
name|RQ_STATUS
operator|)
expr_stmt|;
name|hyact
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_expr_stmt
name|hyprintdata
argument_list|(
name|cp
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|count
init|=
literal|16
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|static
name|char
name|regfmt
index|[]
init|=
literal|"\n\t %x"
decl_stmt|;
name|fmt
operator|=
operator|&
name|regfmt
index|[
literal|2
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
name|printL
argument_list|(
name|fmt
argument_list|,
operator|*
name|cp
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|fmt
operator|=
operator|&
name|regfmt
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|count
operator|<=
literal|0
condition|)
block|{
name|fmt
operator|=
operator|&
name|regfmt
index|[
literal|0
index|]
expr_stmt|;
name|count
operator|=
literal|16
expr_stmt|;
block|}
block|}
name|printL
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|hywatch
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|hyinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hydevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|hydevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|is
operator|->
name|hy_if
operator|.
name|if_timer
operator|=
name|SCANINTERVAL
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_ntime
operator|>
literal|2
operator|&&
name|is
operator|->
name|hy_state
operator|!=
name|WAITING
operator|&&
name|is
operator|->
name|hy_state
operator|!=
name|STARTUP
operator|&&
name|is
operator|->
name|hy_state
operator|!=
name|IDLE
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: watchdog timer expired\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|hycancel
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PI13
if|if
condition|(
operator|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_POWEROFF
operator|)
operator|!=
literal|0
condition|)
block|{
name|addr
operator|->
name|hyd_csr
operator||=
name|S_POWEROFF
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_POWEROFF
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: adapter power restored\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
name|is
operator|->
name|hy_flags
operator||=
operator|(
name|RQ_MARKUP
operator||
name|RQ_STATISTICS
operator||
name|RQ_ENDOP
operator||
name|RQ_STATUS
operator|)
expr_stmt|;
name|hyact
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HYLOG
end_ifdef

begin_macro
name|hylog
argument_list|(
argument|code
argument_list|,
argument|len
argument_list|,
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|code
decl_stmt|,
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|hy_log
operator|.
name|hyl_self
operator|!=
operator|&
name|hy_log
condition|)
block|{
name|hy_log
operator|.
name|hyl_eptr
operator|=
operator|&
name|hy_log
operator|.
name|hyl_buf
index|[
name|HYL_SIZE
index|]
expr_stmt|;
name|hy_log
operator|.
name|hyl_ptr
operator|=
operator|&
name|hy_log
operator|.
name|hyl_buf
index|[
literal|0
index|]
expr_stmt|;
name|hy_log
operator|.
name|hyl_self
operator|=
operator|&
name|hy_log
expr_stmt|;
name|hy_log
operator|.
name|hyl_enable
operator|=
name|HYL_DISABLED
expr_stmt|;
name|hy_log
operator|.
name|hyl_onerr
operator|=
name|HYL_CATCH1
expr_stmt|;
block|}
if|if
condition|(
name|hy_log
operator|.
name|hyl_enable
operator|==
name|HYL_DISABLED
operator|||
name|hy_log
operator|.
name|hyl_enable
operator|==
name|HYL_CAUGHT1
operator|||
name|hy_log
operator|.
name|hyl_enable
operator|==
name|HYL_CAUGHTSTATUS
operator|||
operator|(
name|hy_log
operator|.
name|hyl_enable
operator|==
name|HYL_CATCHSTATUS
operator|&&
name|code
operator|!=
name|HYL_STATUS
operator|)
condition|)
goto|goto
name|out
goto|;
name|p
operator|=
name|hy_log
operator|.
name|hyl_ptr
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|len
operator|+
literal|2
operator|>=
name|hy_log
operator|.
name|hyl_eptr
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|hy_log
operator|.
name|hyl_eptr
operator|-
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|hy_log
operator|.
name|hyl_buf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|hy_log
operator|.
name|hyl_enable
operator|==
name|HYL_CATCH1
condition|)
block|{
name|hy_log
operator|.
name|hyl_enable
operator|=
name|hy_log
operator|.
name|hyl_onerr
operator|=
name|HYL_CAUGHT1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hy_log
operator|.
name|hyl_enable
operator|==
name|HYL_CATCHSTATUS
condition|)
block|{
name|hy_log
operator|.
name|hyl_enable
operator|=
name|hy_log
operator|.
name|hyl_onerr
operator|=
name|HYL_CAUGHTSTATUS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
operator|*
name|p
operator|++
operator|=
name|code
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
name|hy_log
operator|.
name|hyl_ptr
operator|=
name|p
operator|+
name|len
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|hyioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|if_rtinit
argument_list|(
name|ifp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_addr
expr_stmt|;
name|ifp
operator|->
name|if_net
operator|=
name|in_netof
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifp
operator|->
name|if_addr
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|if_makeaddr
argument_list|(
name|ifp
operator|->
name|if_net
argument_list|,
name|ifp
operator|->
name|if_host
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|if_rtinit
argument_list|(
name|ifp
argument_list|,
name|RTF_UP
argument_list|)
expr_stmt|;
else|else
name|hyinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|HYSETROUTE
case|:
if|if
condition|(
operator|!
name|suser
argument_list|()
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|hy_route
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|=
operator|*
operator|(
expr|struct
name|hyroute
operator|*
operator|)
name|ifr
operator|->
name|ifr_data
expr_stmt|;
name|hy_route
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|hyr_lasttime
operator|=
name|time
expr_stmt|;
break|break;
case|case
name|HYGETROUTE
case|:
operator|*
operator|(
expr|struct
name|hyroute
operator|*
operator|)
name|ifr
operator|->
name|ifr_data
operator|=
name|hy_route
index|[
name|ifp
operator|->
name|if_unit
index|]
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bad
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

