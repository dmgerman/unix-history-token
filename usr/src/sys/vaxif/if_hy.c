begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	@(#)if_hy.c	7.1 (Berkeley) 6/5/86  */
end_comment

begin_comment
comment|/*  * 4.2 BSD Unix Kernel - Vax Network Interface Support  *  * $Header: if_hy.c,v 10.1 84/07/22 21:02:56 steveg Exp $  * $Locker:  $  *  * Modifications from Berkeley 4.2 BSD  * Copyright (c) 1983, Tektronix Inc.  * All Rights Reserved  *  * $Log:	if_hy.c,v $  *	Revision 10.1  84/07/22  21:02:56  steveg  *	define PI13 (moved from if_hyreg.h, somehow got dropped in the process)  *	rework hywatch to check for power fails first  *	  *	Revision 10.0  84/06/30  19:54:27  steveg  *	Big Build  *	  *	Revision 3.17  84/06/20  19:20:28  steveg  *	increment hy_ntime in hywatch  *	print out state name, csr, last command, and hy_flags when watchdog timer  *	expires  *	  *	Revision 3.16  84/06/20  19:09:34  steveg  *	turn on continuous logging by default  *	  *	Revision 3.15  84/05/30  22:19:09  steveg  *	changes to reflect new layout ot statistics data  *	  *	Revision 3.14  84/05/30  19:25:15  steveg  *	move driver states to if_hy.h so log printing programs can use them  *	  *	Revision 3.13  84/05/30  17:13:26  steveg  *	make it compile  *	  *	Revision 3.12  84/05/30  13:46:16  steveg  *	rework logging  *	  *	Revision 3.11  84/05/18  19:35:02  steveg  *	clear IFF_RUNNING and IFF_UP on unibus reset to force resource allocation  *	by the init routine  *	  *	Revision 3.10  84/05/04  12:14:44  steveg  *	more rework to make it actually work under 4.2  *	  *	Revision 3.9  84/05/01  23:34:52  steveg  *	fix typo so it compiles (unit -> ui->ui_unit)  *	  *	Revision 3.8  84/05/01  23:18:30  steveg  *	changes after talking with rickk  *	- check power off more closely  *	- support remote loopback through A710 adapters  *	- IMPLINK -> HYLINK  *	- return EHOSTUNREACH on hyroute failure  *	- bump if_collisions on abnormal interrupts that aren't input or output  *	  *  */
end_comment

begin_include
include|#
directive|include
file|"hy.h"
end_include

begin_if
if|#
directive|if
name|NHY
operator|>
literal|0
end_if

begin_comment
comment|/*  * Network Systems Copropration Hyperchanel interface  */
end_comment

begin_include
include|#
directive|include
file|"machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|"../netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_comment
comment|/*  * configuration specific paramters  *	- change as appropriate for particular installaions  */
end_comment

begin_define
define|#
directive|define
name|HYROUTE
end_define

begin_define
define|#
directive|define
name|HYELOG
end_define

begin_define
define|#
directive|define
name|HYLOG
end_define

begin_define
define|#
directive|define
name|HYMTU
value|1100
end_define

begin_define
define|#
directive|define
name|PI13
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|HYLOG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"if_hy.h"
end_include

begin_include
include|#
directive|include
file|"if_hyreg.h"
end_include

begin_include
include|#
directive|include
file|"if_uba.h"
end_include

begin_decl_stmt
name|int
name|hyprobe
argument_list|()
decl_stmt|,
name|hyattach
argument_list|()
decl_stmt|,
name|hyinit
argument_list|()
decl_stmt|,
name|hyioctl
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hyoutput
argument_list|()
decl_stmt|,
name|hyreset
argument_list|()
decl_stmt|,
name|hywatch
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|hyinfo
index|[
name|NHY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|hystd
index|[]
init|=
block|{
literal|0772410
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|hydriver
init|=
block|{
name|hyprobe
block|,
literal|0
block|,
name|hyattach
block|,
literal|0
block|,
name|hystd
block|,
literal|"hy"
block|,
name|hyinfo
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hyperchannel software status per interface.  *  * Each interface is referenced by a network interface structure,  * hy_if, which the routing code uses to locate the interface.  * This structure contains the output queue for the interface, its address, ...  * We also have, for each interface, a UBA interface structure, which  * contains information about the UNIBUS resources held by the interface:  * map registers, buffered data paths, etc.  Information is cached in this  * structure for use by the if_uba.c routines in running the interface  * efficiently.  */
end_comment

begin_struct
struct|struct
name|hy_softc
block|{
name|struct
name|ifnet
name|hy_if
decl_stmt|;
comment|/* network-visible interface */
name|struct
name|ifuba
name|hy_ifuba
decl_stmt|;
comment|/* UNIBUS resources */
name|short
name|hy_flags
decl_stmt|;
comment|/* flags */
name|short
name|hy_state
decl_stmt|;
comment|/* driver state */
name|u_short
name|hy_host
decl_stmt|;
comment|/* local host number */
name|struct
name|in_addr
name|hy_addr
decl_stmt|;
comment|/* internet address */
name|int
name|hy_olen
decl_stmt|;
comment|/* packet length on output */
name|int
name|hy_lastwcr
decl_stmt|;
comment|/* last command's word count */
name|short
name|hy_savedstate
decl_stmt|;
comment|/* saved for reissue after status */
name|short
name|hy_savedcmd
decl_stmt|;
comment|/* saved command for reissue */
name|int
name|hy_savedcount
decl_stmt|;
comment|/* saved byte count for reissue */
name|int
name|hy_savedaddr
decl_stmt|;
comment|/* saved unibus address for reissue */
name|int
name|hy_ntime
decl_stmt|;
comment|/* number of timeouts since last cmd */
name|int
name|hy_retry
decl_stmt|;
comment|/* retry counter */
name|struct
name|hy_stat
name|hy_stat
decl_stmt|;
comment|/* statistics */
name|struct
name|hy_status
name|hy_status
decl_stmt|;
comment|/* status */
block|}
name|hy_softc
index|[
name|NHY
index|]
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|HYELOG
end_ifdef

begin_decl_stmt
name|u_long
name|hy_elog
index|[
name|HYE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HYLOG
end_ifdef

begin_decl_stmt
name|struct
name|hy_log
name|hy_log
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HYROUTE
end_ifdef

begin_decl_stmt
name|struct
name|hy_route
name|hy_route
index|[
name|NHY
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|printL
value|printf
end_define

begin_define
define|#
directive|define
name|printD
value|if (hy_debug_flag) printf
end_define

begin_decl_stmt
name|int
name|hy_debug_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * hy_nodebug bit 0x01	set hy_debug_flag on hycancel  * hy_nodebug bit 0x02	set hy_debug_flag on command reissue  * hy_nodebug bit 0x04	set hy_debug_flag on abnormal interrupt  */
end_comment

begin_decl_stmt
name|int
name|hy_nodebug
init|=
literal|0x0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SCANINTERVAL
value|10
end_define

begin_comment
comment|/* seconds */
end_comment

begin_define
define|#
directive|define
name|MAXINTERVAL
value|20
end_define

begin_comment
comment|/* seconds (max action) */
end_comment

begin_comment
comment|/*  * Cause a device interrupt.  This code uses a buffer starting at  * location zero on the unibus (which is already mapped by the  * autoconfigure code in the kernel).  */
end_comment

begin_macro
name|hyprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* r11, r10 value-result */
specifier|register
name|struct
name|hydevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|hydevice
operator|*
operator|)
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|hyint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * request adapter status to a buffer starting at unibus location 0 	 */
name|addr
operator|->
name|hyd_bar
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|hyd_wcr
operator|=
operator|-
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|hy_status
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|addr
operator|->
name|hyd_dbuf
operator|=
name|HYF_STATUS
expr_stmt|;
ifdef|#
directive|ifdef
name|PI13
name|addr
operator|->
name|hyd_csr
operator||=
name|S_GO
operator||
name|S_IE
operator||
name|S_IATTN
expr_stmt|;
else|#
directive|else
name|addr
operator|->
name|hyd_csr
operator||=
name|S_GO
operator||
name|S_IE
expr_stmt|;
endif|#
directive|endif
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PI13
name|addr
operator|->
name|hyd_csr
operator||=
name|S_CLRINT
expr_stmt|;
comment|/* clear any stacked interrupts */
endif|#
directive|endif
name|addr
operator|->
name|hyd_csr
operator|&=
operator|~
operator|(
name|S_IE
operator||
name|S_CLRINT
operator|)
expr_stmt|;
comment|/* disable further interrupts */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|hydevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_macro
name|hyattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|is
operator|->
name|hy_if
decl_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|ui
operator|->
name|ui_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"hy"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|HYMTU
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|STARTUP
expr_stmt|;
comment|/* don't allow state transitions yet */
name|ifp
operator|->
name|if_init
operator|=
name|hyinit
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|hyioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|hyoutput
expr_stmt|;
name|ifp
operator|->
name|if_reset
operator|=
name|hyreset
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|hywatch
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
name|SCANINTERVAL
expr_stmt|;
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_flags
operator|=
name|UBA_CANTWAIT
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_flags
operator||=
name|UBA_NEEDBDP
expr_stmt|;
endif|#
directive|endif
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reset of interface after UNIBUS reset.  * If interface is on specified uba, reset its state.  */
end_comment

begin_macro
name|hyreset
argument_list|(
argument|unit
argument_list|,
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NHY
operator|||
operator|(
name|ui
operator|=
name|hyinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_ubanum
operator|!=
name|uban
condition|)
return|return;
name|printf
argument_list|(
literal|" hy%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|is
operator|=
operator|&
name|hy_softc
index|[
name|unit
index|]
expr_stmt|;
comment|/* force unibus resource allocation */
name|is
operator|->
name|hy_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
expr_stmt|;
name|hyinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialization of interface; clear recorded pending  * operations, and reinitialize UNIBUS usage.  */
end_comment

begin_macro
name|hyinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|hyinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_if
operator|.
name|if_addrlist
operator|==
literal|0
condition|)
comment|/* address still unknown */
return|return;
if|if
condition|(
name|is
operator|->
name|hy_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
comment|/* just reset the device */
goto|goto
name|justreset
goto|;
if|if
condition|(
name|if_ubainit
argument_list|(
operator|&
name|is
operator|->
name|hy_ifuba
argument_list|,
name|ui
operator|->
name|ui_ubanum
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|btoc
argument_list|(
name|HYMTU
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hy_nodebug
operator|&
literal|4
condition|)
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"hy%d: can't initialize\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
return|return;
block|}
name|is
operator|->
name|hy_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|justreset
label|:
comment|/* 	 * remove any left over outgoing messages, reset the hardware and 	 * start the state machine 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HYLOG
name|hylog
argument_list|(
name|HYL_RESET
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
name|is
operator|->
name|hy_flags
operator|=
name|RQ_STATUS
operator||
name|RQ_STATISTICS
operator||
name|RQ_MARKUP
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|is
operator|->
name|hy_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|hycancel
argument_list|(
name|ui
argument_list|)
expr_stmt|;
comment|/* also bumps the state machine */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Issue a command to the adapter  */
end_comment

begin_macro
name|hystart
argument_list|(
argument|ui
argument_list|,
argument|cmd
argument_list|,
argument|count
argument_list|,
argument|ubaddr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|,
name|count
decl_stmt|,
name|ubaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hydevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|hydevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: hystart cmd = 0x%x count=%d ubaddr=0x%x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|cmd
argument_list|,
name|count
argument_list|,
name|ubaddr
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|"hy%d: - csr = 0x%b, bar = 0x%x, wcr = 0x%x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|addr
operator|->
name|hyd_csr
argument_list|,
name|HY_CSR_BITS
argument_list|,
name|addr
operator|->
name|hyd_bar
argument_list|,
name|addr
operator|->
name|hyd_wcr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|is
operator|->
name|hy_flags
operator|&
name|RQ_REISSUE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|HYF_STATUS
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|HYF_END_OP
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|HYF_RSTATS
operator|)
condition|)
block|{
name|is
operator|->
name|hy_savedstate
operator|=
name|is
operator|->
name|hy_state
expr_stmt|;
name|is
operator|->
name|hy_savedcmd
operator|=
name|cmd
expr_stmt|;
name|is
operator|->
name|hy_savedcount
operator|=
name|count
expr_stmt|;
name|is
operator|->
name|hy_savedaddr
operator|=
name|ubaddr
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PI13
if|if
condition|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_POWEROFF
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: \"Soft\" Adapter Power Failure (hystart)\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
name|addr
operator|->
name|hyd_csr
operator||=
name|S_POWEROFF
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_POWEROFF
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: \"Hard\" Adapter Power Failure, Network Shutdown (hystart)\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
name|if_down
argument_list|(
operator|&
name|is
operator|->
name|hy_if
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|STARTUP
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"hy%d: Adapter Power Restored (hystart)\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
name|addr
operator|->
name|hyd_bar
operator|=
name|ubaddr
operator|&
literal|0xffff
expr_stmt|;
name|addr
operator|->
name|hyd_wcr
operator|=
name|is
operator|->
name|hy_lastwcr
operator|=
operator|-
operator|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|addr
operator|->
name|hyd_dbuf
operator|=
name|cmd
expr_stmt|;
ifdef|#
directive|ifdef
name|PI13
name|addr
operator|->
name|hyd_csr
operator|=
operator|(
operator|(
name|ubaddr
operator|>>
name|XBASHIFT
operator|)
operator|&
name|S_XBA
operator|)
operator||
name|S_GO
operator||
name|S_IE
operator||
name|S_IATTN
expr_stmt|;
else|#
directive|else
name|addr
operator|->
name|hyd_csr
operator|=
operator|(
operator|(
name|ubaddr
operator|>>
name|XBASHIFT
operator|)
operator|&
name|S_XBA
operator|)
operator||
name|S_GO
operator||
name|S_IE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: exit hystart - csr = 0x%b, bar = 0x%x, wcr = 0x%x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|addr
operator|->
name|hyd_csr
argument_list|,
name|HY_CSR_BITS
argument_list|,
name|addr
operator|->
name|hyd_bar
argument_list|,
name|addr
operator|->
name|hyd_wcr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HYLOG
block|{
struct|struct
block|{
name|u_char
name|hcmd
decl_stmt|;
name|u_char
name|hstate
decl_stmt|;
name|short
name|hcount
decl_stmt|;
block|}
name|hcl
struct|;
name|hcl
operator|.
name|hcmd
operator|=
name|cmd
expr_stmt|;
name|hcl
operator|.
name|hstate
operator|=
name|is
operator|->
name|hy_state
expr_stmt|;
name|hcl
operator|.
name|hcount
operator|=
name|count
expr_stmt|;
name|hylog
argument_list|(
name|HYL_CMD
argument_list|,
sizeof|sizeof
argument_list|(
name|hcl
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hcl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|is
operator|->
name|hy_ntime
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|hyint_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set during hy interrupt */
end_comment

begin_comment
comment|/*  * Hyperchannel interface interrupt.  *  * An interrupt can occur for many reasons.  Examine the status of  * the hyperchannel status bits to determine what to do next.  *  * If input error just drop packet.  * Otherwise purge input buffered data path and examine   * packet to determine type.  Othewise decapsulate  * packet based on type and pass to type specific higher-level  * input routine.  */
end_comment

begin_macro
name|hyint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|hyinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hydevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|hydevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
if|if
condition|(
name|hyint_active
condition|)
name|panic
argument_list|(
literal|"RECURSIVE HYPERCHANNEL INTERRUPT"
argument_list|)
expr_stmt|;
name|hyint_active
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: hyint enter - csr = 0x%b, bar = 0x%x, wcr = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|addr
operator|->
name|hyd_csr
argument_list|,
name|HY_CSR_BITS
argument_list|,
name|addr
operator|->
name|hyd_bar
argument_list|,
name|addr
operator|->
name|hyd_wcr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HYLOG
name|logit
label|:
block|{
struct|struct
block|{
name|u_char
name|hstate
decl_stmt|;
name|u_char
name|hflags
decl_stmt|;
name|short
name|hcsr
decl_stmt|;
name|short
name|hwcr
decl_stmt|;
block|}
name|hil
struct|;
name|hil
operator|.
name|hstate
operator|=
name|is
operator|->
name|hy_state
expr_stmt|;
name|hil
operator|.
name|hflags
operator|=
name|is
operator|->
name|hy_flags
expr_stmt|;
name|hil
operator|.
name|hcsr
operator|=
name|addr
operator|->
name|hyd_csr
expr_stmt|;
name|hil
operator|.
name|hwcr
operator|=
name|addr
operator|->
name|hyd_wcr
expr_stmt|;
name|hylog
argument_list|(
name|HYL_INT
argument_list|,
sizeof|sizeof
argument_list|(
name|hil
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hil
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|HYS_ERROR
argument_list|(
name|addr
argument_list|)
operator|&&
operator|(
operator|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_ATTN
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Error bit set, some sort of error in the interface. 		 * 		 * The adapter sets attn on command completion so that's not 		 * a real error even though the interface considers it one. 		 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hy_nodebug
operator|&
literal|4
condition|)
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"csr = 0x%b\nbar = 0x%x\nwcr = 0x%x\n"
argument_list|,
name|addr
operator|->
name|hyd_csr
argument_list|,
name|HY_CSR_BITS
argument_list|,
name|addr
operator|->
name|hyd_bar
argument_list|,
name|addr
operator|->
name|hyd_wcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_NEX
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: NEX - Non Existant Memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PI13
name|addr
operator|->
name|hyd_csr
operator||=
name|S_NEX
expr_stmt|;
comment|/* as per PI13 manual */
else|#
directive|else
name|addr
operator|->
name|hyd_csr
operator|&=
operator|~
name|S_NEX
expr_stmt|;
endif|#
directive|endif
name|hycancel
argument_list|(
name|ui
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PI13
block|}
elseif|else
if|if
condition|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_POWEROFF
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: \"Soft\" Adapter Power Failure (hyint)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|addr
operator|->
name|hyd_csr
operator||=
name|S_POWEROFF
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_POWEROFF
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: \"Hard\" Adapter Power Failure, Network Shutdown (hyint)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|if_down
argument_list|(
operator|&
name|is
operator|->
name|hy_if
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|STARTUP
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"hy%d: Adapter Power Restored (hyint)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|printf
argument_list|(
literal|"hy%d:  BAR overflow\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|hycancel
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|HYS_NORMAL
argument_list|(
name|addr
argument_list|)
condition|)
block|{
comment|/* 		 * Normal interrupt, bump state machine unless in state 		 * waiting and no data present (assumed to be word count 		 * zero interrupt or other hardware botch). 		 */
if|if
condition|(
name|is
operator|->
name|hy_state
operator|!=
name|WAITING
operator|||
name|HYS_RECVDATA
argument_list|(
name|addr
argument_list|)
condition|)
name|hyact
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HYS_ABNORMAL
argument_list|(
name|addr
argument_list|)
condition|)
block|{
comment|/* 		 * Abnormal termination. 		 * bump error counts, retry the last function 		 * 'MAXRETRY' times before kicking the bucket. 		 * 		 * Don't reissue the cmd if in certain states, abnormal 		 * on a reissued cmd or max retry exceeded. 		 */
ifdef|#
directive|ifdef
name|HYLOG
if|if
condition|(
name|hy_log
operator|.
name|hyl_enable
operator|!=
name|hy_log
operator|.
name|hyl_onerr
condition|)
block|{
name|hy_log
operator|.
name|hyl_enable
operator|=
name|hy_log
operator|.
name|hyl_onerr
expr_stmt|;
goto|goto
name|logit
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hy_nodebug
operator|&
literal|4
condition|)
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
name|printD
argument_list|(
literal|"hy%d: abnormal interrupt, driver state \"%s\" (%d)\n"
argument_list|,
name|unit
argument_list|,
name|hy_state_names
index|[
name|is
operator|->
name|hy_state
index|]
argument_list|,
name|is
operator|->
name|hy_state
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|"\tflags 0x%x olen %d lastwcr %d retry %d\n"
argument_list|,
name|is
operator|->
name|hy_flags
argument_list|,
name|is
operator|->
name|hy_olen
argument_list|,
name|is
operator|->
name|hy_lastwcr
argument_list|,
name|is
operator|->
name|hy_retry
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|"\tsaved: state %d count %d cmd 0x%x ptr 0x%x\n"
argument_list|,
name|is
operator|->
name|hy_savedstate
argument_list|,
name|is
operator|->
name|hy_savedcount
argument_list|,
name|is
operator|->
name|hy_savedaddr
argument_list|,
name|is
operator|->
name|hy_savedcmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PI13
name|addr
operator|->
name|hyd_csr
operator|&=
operator|~
name|S_C
expr_stmt|;
comment|/* clear the damned PI-13 */
endif|#
directive|endif
if|if
condition|(
name|is
operator|->
name|hy_state
operator|==
name|XMITSENT
operator|||
name|is
operator|->
name|hy_state
operator|==
name|XMITDATASENT
condition|)
name|is
operator|->
name|hy_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|is
operator|->
name|hy_state
operator|==
name|RECVSENT
operator|||
name|is
operator|->
name|hy_state
operator|==
name|RECVDATASENT
condition|)
name|is
operator|->
name|hy_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
else|else
name|is
operator|->
name|hy_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
comment|/* other errors */
if|if
condition|(
name|is
operator|->
name|hy_state
operator|==
name|XMITDATASENT
operator|||
name|is
operator|->
name|hy_state
operator|==
name|RECVSENT
operator|||
name|is
operator|->
name|hy_state
operator|==
name|RECVDATASENT
operator|||
operator|(
name|is
operator|->
name|hy_flags
operator|&
name|RQ_REISSUE
operator|)
operator|!=
literal|0
operator|||
name|is
operator|->
name|hy_retry
operator|>
name|MAXRETRY
condition|)
name|hycancel
argument_list|(
name|ui
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hy_nodebug
operator|&
literal|2
condition|)
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|is
operator|->
name|hy_retry
operator|++
expr_stmt|;
name|is
operator|->
name|hy_flags
operator||=
name|RQ_ENDOP
operator||
name|RQ_STATUS
operator||
name|RQ_REISSUE
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
name|hyact
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Interrupt is neither normal, abnormal, or interface error. 		 * Ignore it. It's either stacked or a word count 0. 		 */
ifdef|#
directive|ifdef
name|HYLOG
if|if
condition|(
name|hy_log
operator|.
name|hyl_enable
operator|!=
name|hy_log
operator|.
name|hyl_onerr
condition|)
block|{
name|hy_log
operator|.
name|hyl_enable
operator|=
name|hy_log
operator|.
name|hyl_onerr
expr_stmt|;
goto|goto
name|logit
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: possible stacked interrupt ignored\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: hyint exit\n\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hyint_active
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|hyoutprint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Encapsulate a packet of type family for the local net.  */
end_comment

begin_macro
name|hyoutput
argument_list|(
argument|ifp
argument_list|,
argument|m0
argument_list|,
argument|dst
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hym_hdr
modifier|*
name|hym
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|mp
decl_stmt|;
name|int
name|dlen
decl_stmt|;
comment|/* packet size, incl hardware header, but not sw header */
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Calculate packet length for later deciding whether it will fit 	 * in a message proper or we also need associated data. 	 */
name|dlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|dlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|==
name|AF_HYLINK
condition|)
block|{
comment|/* don't add header */
name|dlen
operator|-=
name|HYM_SWLEN
expr_stmt|;
goto|goto
name|headerexists
goto|;
block|}
comment|/* 	 * Add the software and hardware hyperchannel headers. 	 * If there's not enough space in the first mbuf, allocate another. 	 * If that should fail, drop this sucker. 	 * No extra space for headers is allocated. 	 */
name|mp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* save pointer to real message */
if|if
condition|(
name|m
operator|->
name|m_off
operator|>
name|MMAXOFF
operator|||
name|MMINOFF
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
operator|>
name|m
operator|->
name|m_off
condition|)
block|{
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|m0
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMINOFF
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
expr_stmt|;
block|}
name|dlen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
operator|-
name|HYM_SWLEN
expr_stmt|;
name|hym
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|hym_hdr
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|hym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|int
name|i
decl_stmt|;
comment|/* 		 * if loopback address, swizzle ip header so when 		 * it comes back it looks like it was addressed to us 		 */
name|i
operator|=
name|hyroute
argument_list|(
name|ifp
argument_list|,
operator|(
name|u_long
operator|)
name|in_lnaof
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|hym
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
goto|goto
name|notfound
goto|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|struct
name|in_addr
name|temp
decl_stmt|;
name|temp
operator|.
name|s_addr
operator|=
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|mp
operator|)
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|mp
operator|)
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|mp
operator|)
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|mp
operator|)
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|temp
operator|.
name|s_addr
expr_stmt|;
block|}
comment|/* 		 * If entire packet won't fit in message proper, just 		 * send hyperchannel hardware header and ip header in 		 * message proper. 		 * 		 * This insures that the associated data is at least a 		 * TCP/UDP header in length and thus prevents potential 		 * problems with very short word counts. 		 */
if|if
condition|(
name|dlen
operator|>
name|MPSIZE
condition|)
name|hym
operator|->
name|hym_mplen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|hy_hdr
argument_list|)
operator|+
operator|(
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|mp
operator|)
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|hym
operator|->
name|hym_type
operator|=
name|HYLINK_IP
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"hy%d: can't handle af%d\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|headerexists
label|:
comment|/* 	 * insure message proper is below the maximum 	 */
if|if
condition|(
name|hym
operator|->
name|hym_mplen
operator|>
name|MPSIZE
operator|||
operator|(
name|dlen
operator|>
name|MPSIZE
operator|&&
name|hym
operator|->
name|hym_mplen
operator|==
literal|0
operator|)
condition|)
name|hym
operator|->
name|hym_mplen
operator|=
name|MPSIZE
expr_stmt|;
name|hym
operator|->
name|hym_from
operator|=
name|htons
argument_list|(
name|hy_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|hy_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|hym
operator|->
name|hym_mplen
condition|)
name|hym
operator|->
name|hym_ctl
operator||=
name|H_ASSOC
expr_stmt|;
else|else
name|hym
operator|->
name|hym_ctl
operator|&=
operator|~
name|H_ASSOC
expr_stmt|;
if|if
condition|(
name|hyoutprint
condition|)
name|printf
argument_list|(
literal|"hy%d: output mplen=%x ctl=%x access=%x to=%x from=%x param=%x type=%x\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|hym
operator|->
name|hym_mplen
argument_list|,
name|hym
operator|->
name|hym_ctl
argument_list|,
name|hym
operator|->
name|hym_access
argument_list|,
name|hym
operator|->
name|hym_to
argument_list|,
name|hym
operator|->
name|hym_from
argument_list|,
name|hym
operator|->
name|hym_param
argument_list|,
name|hym
operator|->
name|hym_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: output mplen=%x ctl=%x access=%x to=%x from=%x param=%x type=%x\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|hym
operator|->
name|hym_mplen
argument_list|,
name|hym
operator|->
name|hym_ctl
argument_list|,
name|hym
operator|->
name|hym_access
argument_list|,
name|hym
operator|->
name|hym_to
argument_list|,
name|hym
operator|->
name|hym_from
argument_list|,
name|hym
operator|->
name|hym_param
argument_list|,
name|hym
operator|->
name|hym_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|hy_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|hy_state
operator|==
name|WAITING
condition|)
name|hyact
argument_list|(
name|hyinfo
index|[
name|ifp
operator|->
name|if_unit
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|notfound
label|:
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
name|drop
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_function
name|int
name|hyroute
parameter_list|(
name|ifp
parameter_list|,
name|dest
parameter_list|,
name|hym
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|dest
decl_stmt|;
specifier|register
name|struct
name|hym_hdr
modifier|*
name|hym
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HYROUTE
specifier|register
name|struct
name|hy_route
modifier|*
name|rt
init|=
operator|&
name|hy_route
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hyr_hash
modifier|*
name|rhash
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|hym
operator|->
name|hym_param
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HYROUTE
if|if
condition|(
name|rt
operator|->
name|hyr_lasttime
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|HYRHASH
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|rhash
operator|=
operator|&
name|rt
operator|->
name|hyr_hash
index|[
name|i
index|]
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rhash
operator|->
name|hyr_key
operator|!=
name|dest
condition|)
block|{
if|if
condition|(
name|rhash
operator|->
name|hyr_flags
operator|==
literal|0
operator|||
name|i
operator|>
name|HYRSIZE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|rhash
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|rhash
operator|>=
operator|&
name|rt
operator|->
name|hyr_hash
index|[
name|HYRSIZE
index|]
condition|)
name|rhash
operator|=
operator|&
name|rt
operator|->
name|hyr_hash
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|rhash
operator|->
name|hyr_flags
operator|&
name|HYR_GATE
condition|)
block|{
name|i
operator|=
name|rhash
operator|->
name|hyr_nextgate
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|rhash
operator|->
name|hyr_egate
condition|)
name|rhash
operator|->
name|hyr_nextgate
operator|=
name|rhash
operator|->
name|hyr_pgate
expr_stmt|;
else|else
name|rhash
operator|->
name|hyr_nextgate
operator|++
expr_stmt|;
name|rhash
operator|=
operator|&
name|rt
operator|->
name|hyr_hash
index|[
name|rt
operator|->
name|hyr_gateway
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rhash
operator|->
name|hyr_flags
operator|&
name|HYR_DIR
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|rhash
operator|->
name|hyr_flags
operator|&
name|HYR_LOOP
condition|)
block|{
name|hym
operator|->
name|hym_param
operator|=
name|H_LOOPBK
expr_stmt|;
comment|/* adapter loopback */
block|}
elseif|else
if|if
condition|(
name|rhash
operator|->
name|hyr_flags
operator|&
name|HYR_RLOOP
condition|)
block|{
name|hym
operator|->
name|hym_param
operator|=
name|H_RLOOPBK
expr_stmt|;
comment|/* A710 remote loopback */
block|}
name|hym
operator|->
name|hym_ctl
operator|=
name|rhash
operator|->
name|hyr_ctl
expr_stmt|;
name|hym
operator|->
name|hym_access
operator|=
name|rhash
operator|->
name|hyr_access
expr_stmt|;
name|hym
operator|->
name|hym_to
operator|=
name|rhash
operator|->
name|hyr_dst
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|hym
operator|->
name|hym_ctl
operator|=
name|H_XTRUNKS
operator||
name|H_RTRUNKS
expr_stmt|;
name|hym
operator|->
name|hym_access
operator|=
literal|0
expr_stmt|;
name|hym
operator|->
name|hym_to
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|&
literal|0x010000
condition|)
name|hym
operator|->
name|hym_param
operator|=
name|H_LOOPBK
expr_stmt|;
comment|/* adapter loopback */
elseif|else
if|if
condition|(
name|dest
operator|&
literal|0x020000
condition|)
name|hym
operator|->
name|hym_param
operator|=
name|H_RLOOPBK
expr_stmt|;
comment|/* A710 remote loopback */
ifdef|#
directive|ifdef
name|HYROUTE
block|}
endif|#
directive|endif
if|if
condition|(
name|hym
operator|->
name|hym_param
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|hyact
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hydevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|hydevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
name|actloop
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: hyact, enter state \"%s\"\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|hy_state_names
index|[
name|is
operator|->
name|hy_state
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|is
operator|->
name|hy_state
condition|)
block|{
case|case
name|STARTUP
case|:
goto|goto
name|endintr
goto|;
case|case
name|IDLE
case|:
block|{
specifier|register
name|rq
operator|=
name|is
operator|->
name|hy_flags
expr_stmt|;
if|if
condition|(
name|rq
operator|&
name|RQ_STATUS
condition|)
block|{
name|is
operator|->
name|hy_flags
operator|&=
operator|~
name|RQ_STATUS
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|STATSENT
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_STATUS
argument_list|,
sizeof|sizeof
argument_list|(
name|is
operator|->
name|hy_status
argument_list|)
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|&
name|RQ_ENDOP
condition|)
block|{
name|is
operator|->
name|hy_flags
operator|&=
operator|~
name|RQ_ENDOP
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|ENDOPSENT
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_END_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|&
name|RQ_STATISTICS
condition|)
block|{
name|is
operator|->
name|hy_flags
operator|&=
operator|~
name|RQ_STATISTICS
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|RSTATSENT
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_RSTATS
argument_list|,
sizeof|sizeof
argument_list|(
name|is
operator|->
name|hy_stat
argument_list|)
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HYS_RECVDATA
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|is
operator|->
name|hy_state
operator|=
name|RECVSENT
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_INPUTMSG
argument_list|,
name|MPSIZE
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
operator|+
name|HYM_SWLEN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|&
name|RQ_REISSUE
condition|)
block|{
name|is
operator|->
name|hy_flags
operator|&=
operator|~
name|RQ_REISSUE
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|is
operator|->
name|hy_savedstate
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: reissue cmd=0x%x count=%d"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|is
operator|->
name|hy_savedcmd
argument_list|,
name|is
operator|->
name|hy_savedcount
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|" ubaddr=0x%x retry=%d\n"
argument_list|,
name|is
operator|->
name|hy_savedaddr
argument_list|,
name|is
operator|->
name|hy_retry
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hystart
argument_list|(
name|ui
argument_list|,
name|is
operator|->
name|hy_savedcmd
argument_list|,
name|is
operator|->
name|hy_savedcount
argument_list|,
name|is
operator|->
name|hy_savedaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|is
operator|->
name|hy_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|struct
name|hym_hdr
modifier|*
name|hym
decl_stmt|;
specifier|register
name|int
name|mplen
decl_stmt|;
specifier|register
name|int
name|cmd
decl_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|XMITSENT
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
name|hym
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|hym_hdr
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HYLOG
name|hylog
argument_list|(
name|HYL_XMIT
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hym
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mplen
operator|=
name|hym
operator|->
name|hym_mplen
expr_stmt|;
if|if
condition|(
name|hym
operator|->
name|hym_to_adapter
operator|==
name|hym
operator|->
name|hym_from_adapter
condition|)
name|cmd
operator|=
name|HYF_XMITLOCMSG
expr_stmt|;
else|else
name|cmd
operator|=
name|HYF_XMITMSG
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: hym_hdr = "
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|hy_debug_flag
condition|)
name|hyprintdata
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|is
operator|->
name|hy_olen
operator|=
name|if_wubaput
argument_list|(
operator|&
name|is
operator|->
name|hy_ifuba
argument_list|,
name|m
argument_list|)
operator|-
name|HYM_SWLEN
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_uba
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: sending packet (mplen = %d, hy_olen = %d) data = "
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|mplen
argument_list|,
name|is
operator|->
name|hy_olen
argument_list|)
expr_stmt|;
if|if
condition|(
name|hy_debug_flag
condition|)
name|hyprintdata
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_addr
argument_list|,
name|is
operator|->
name|hy_olen
operator|+
name|HYM_SWLEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mplen
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|hy_flags
operator|&=
operator|~
name|RQ_XASSOC
expr_stmt|;
name|mplen
operator|=
name|is
operator|->
name|hy_olen
expr_stmt|;
block|}
else|else
block|{
name|is
operator|->
name|hy_flags
operator||=
name|RQ_XASSOC
expr_stmt|;
block|}
name|hystart
argument_list|(
name|ui
argument_list|,
name|cmd
argument_list|,
name|mplen
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_info
operator|+
name|HYM_SWLEN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|&
name|RQ_MARKDOWN
condition|)
block|{
name|is
operator|->
name|hy_flags
operator|&=
operator|~
operator|(
name|RQ_MARKUP
operator||
name|RQ_MARKDOWN
operator|)
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|MARKPORT
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Port number is taken from status data 				 */
name|hystart
argument_list|(
name|ui
argument_list|,
call|(
name|int
call|)
argument_list|(
name|HYF_MARKP0
operator||
operator|(
name|PORTNUM
argument_list|(
operator|&
name|is
operator|->
name|hy_status
argument_list|)
operator|<<
literal|2
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rq
operator|&
name|RQ_MARKUP
condition|)
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|is
operator|->
name|hy_if
decl_stmt|;
name|is
operator|->
name|hy_flags
operator|&=
operator|~
name|RQ_MARKUP
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Fill in the host number 				 * from the status buffer 				 */
name|printf
argument_list|(
literal|"hy%d: unit number 0x%x port %d type %x microcode level 0x%x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_uaddr
argument_list|,
name|PORTNUM
argument_list|(
operator|&
name|is
operator|->
name|hy_status
argument_list|)
argument_list|,
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|1
index|]
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_host
operator|=
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_uaddr
operator|<<
literal|8
operator|)
operator||
name|PORTNUM
argument_list|(
operator|&
name|is
operator|->
name|hy_status
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
ifdef|#
directive|ifdef
name|HYLOG
name|hylog
argument_list|(
name|HYL_UP
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|is
operator|->
name|hy_state
operator|=
name|WAITING
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_WAITFORMSG
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|STATSENT
case|:
name|bcopy
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|is
operator|->
name|hy_status
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hy_status
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: status - %x %x %x %x %x %x %x %x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_gen_status
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_last_fcn
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_resp_trunk
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_status_trunk
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_recd_resp
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_error
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_caddr
argument_list|,
name|is
operator|->
name|hy_status
operator|.
name|hys_pad
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
ifdef|#
directive|ifdef
name|HYLOG
name|hylog
argument_list|(
name|HYL_STATUS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hy_status
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|is
operator|->
name|hy_status
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HYELOG
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|is
operator|->
name|hy_status
operator|.
name|hys_error
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|HYE_MAX
condition|)
name|i
operator|=
name|HYE_MAX
expr_stmt|;
switch|switch
condition|(
name|is
operator|->
name|hy_status
operator|.
name|hys_last_fcn
condition|)
block|{
case|case
name|HYF_XMITLOCMSG
case|:
name|i
operator|+=
name|HYE_MAX
operator|+
literal|1
expr_stmt|;
comment|/* fall through */
case|case
name|HYF_XMITLSTDATA
case|:
name|i
operator|+=
name|HYE_MAX
operator|+
literal|1
expr_stmt|;
comment|/* fall through */
case|case
name|HYF_XMITMSG
case|:
name|i
operator|+=
name|HYE_MAX
operator|+
literal|1
expr_stmt|;
block|}
name|hy_elog
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|RSTATSENT
case|:
block|{
specifier|register
name|struct
name|hy_stat
modifier|*
name|p
init|=
operator|(
expr|struct
name|hy_stat
operator|*
operator|)
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|is
operator|->
name|hy_stat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hy_stat
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: statistics - df0 %d df1 %d df2 %d df3 %d\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_df0
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_df0
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|is
operator|->
name|hy_stat
operator|.
name|hyc_df0
index|[
literal|2
index|]
argument_list|,
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_df1
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_df1
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|is
operator|->
name|hy_stat
operator|.
name|hyc_df1
index|[
literal|2
index|]
argument_list|,
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_df2
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_df2
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|is
operator|->
name|hy_stat
operator|.
name|hyc_df2
index|[
literal|2
index|]
argument_list|,
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_df3
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_df3
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|is
operator|->
name|hy_stat
operator|.
name|hyc_df3
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|"	ret0 %d ret1 %d ret2 %d ret3 %d\n"
argument_list|,
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_ret0
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_ret0
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|is
operator|->
name|hy_stat
operator|.
name|hyc_ret0
index|[
literal|2
index|]
argument_list|,
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_ret1
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_ret1
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|is
operator|->
name|hy_stat
operator|.
name|hyc_ret1
index|[
literal|2
index|]
argument_list|,
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_ret2
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_ret2
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|is
operator|->
name|hy_stat
operator|.
name|hyc_ret2
index|[
literal|2
index|]
argument_list|,
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_ret3
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_ret3
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|is
operator|->
name|hy_stat
operator|.
name|hyc_ret3
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|"	cancel %d abort %d atype %x %x %x uaddr %x\n"
argument_list|,
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_cancel
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|is
operator|->
name|hy_stat
operator|.
name|hyc_cancel
index|[
literal|1
index|]
argument_list|,
operator|(
name|is
operator|->
name|hy_stat
operator|.
name|hyc_abort
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|is
operator|->
name|hy_stat
operator|.
name|hyc_abort
index|[
literal|1
index|]
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|0
index|]
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|1
index|]
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_atype
index|[
literal|2
index|]
argument_list|,
name|is
operator|->
name|hy_stat
operator|.
name|hyc_uaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
ifdef|#
directive|ifdef
name|HYLOG
name|hylog
argument_list|(
name|HYL_STATISTICS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hy_stat
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|is
operator|->
name|hy_stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|CLEARSENT
case|:
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
break|break;
case|case
name|ENDOPSENT
case|:
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
break|break;
case|case
name|RECVSENT
case|:
block|{
specifier|register
name|struct
name|hym_hdr
modifier|*
name|hym
decl_stmt|;
specifier|register
name|unsigned
name|len
decl_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_uba
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
name|hym
operator|=
operator|(
expr|struct
name|hym_hdr
operator|*
operator|)
operator|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
operator|)
expr_stmt|;
name|len
operator|=
operator|(
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|hyd_wcr
operator|-
name|is
operator|->
name|hy_lastwcr
operator|)
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MPSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: RECVD MP> MPSIZE (%d)\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
name|printD
argument_list|(
literal|"hy%d: csr = 0x%b, bar = 0x%x, wcr = 0x%x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|addr
operator|->
name|hyd_csr
argument_list|,
name|HY_CSR_BITS
argument_list|,
name|addr
operator|->
name|hyd_bar
argument_list|,
name|addr
operator|->
name|hyd_wcr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|hym
operator|->
name|hym_mplen
operator|=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: recvd mp, len = %d, data = "
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hy_debug_flag
condition|)
name|hyprintdata
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hym
argument_list|,
name|len
operator|+
name|HYM_SWLEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hym
operator|->
name|hym_ctl
operator|&
name|H_ASSOC
condition|)
block|{
name|is
operator|->
name|hy_state
operator|=
name|RECVDATASENT
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_INPUTDATA
argument_list|,
call|(
name|int
call|)
argument_list|(
name|HYMTU
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|hy_hdr
argument_list|)
operator|-
name|len
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|HYM_SWLEN
operator|+
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
operator|+
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hyrecvdata
argument_list|(
name|ui
argument_list|,
name|hym
argument_list|,
operator|(
name|int
operator|)
name|len
operator|+
name|HYM_SWLEN
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
block|}
break|break;
block|}
case|case
name|RECVDATASENT
case|:
block|{
specifier|register
name|struct
name|hym_hdr
modifier|*
name|hym
decl_stmt|;
specifier|register
name|unsigned
name|len
decl_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_uba
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
name|hym
operator|=
operator|(
expr|struct
name|hym_hdr
operator|*
operator|)
operator|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
operator|)
expr_stmt|;
name|len
operator|=
operator|(
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|hyd_wcr
operator|-
name|is
operator|->
name|hy_lastwcr
operator|)
operator|)
operator|<<
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: recvd assoc data, len = %d, data = "
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hy_debug_flag
condition|)
name|hyprintdata
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hym
operator|+
name|hym
operator|->
name|hym_mplen
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hyrecvdata
argument_list|(
name|ui
argument_list|,
name|hym
argument_list|,
call|(
name|int
call|)
argument_list|(
name|len
operator|+
name|hym
operator|->
name|hym_mplen
operator|+
name|HYM_SWLEN
argument_list|)
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
break|break;
block|}
case|case
name|XMITSENT
case|:
if|if
condition|(
name|is
operator|->
name|hy_flags
operator|&
name|RQ_XASSOC
condition|)
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|is
operator|->
name|hy_flags
operator|&=
operator|~
name|RQ_XASSOC
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|XMITDATASENT
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
name|len
operator|=
operator|(
literal|0xffff
operator|&
operator|(
name|addr
operator|->
name|hyd_wcr
operator|-
name|is
operator|->
name|hy_lastwcr
operator|)
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|is
operator|->
name|hy_olen
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: xmit error - len> hy_olen [%d> %d]\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|len
argument_list|,
name|is
operator|->
name|hy_olen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_XMITLSTDATA
argument_list|,
name|is
operator|->
name|hy_olen
operator|-
name|len
argument_list|,
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_info
operator|+
name|HYM_SWLEN
operator|+
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall through to ... */
case|case
name|XMITDATASENT
case|:
name|hyxmitdata
argument_list|(
name|ui
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
break|break;
case|case
name|WAITING
case|:
comment|/* wait for message complete or output requested */
if|if
condition|(
name|HYS_RECVDATA
argument_list|(
name|addr
argument_list|)
condition|)
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
else|else
block|{
name|is
operator|->
name|hy_state
operator|=
name|CLEARSENT
expr_stmt|;
name|is
operator|->
name|hy_retry
operator|=
literal|0
expr_stmt|;
name|hystart
argument_list|(
name|ui
argument_list|,
name|HYF_CLRWFMSG
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MARKPORT
case|:
name|is
operator|->
name|hy_state
operator|=
name|STARTUP
expr_stmt|;
name|if_down
argument_list|(
operator|&
name|is
operator|->
name|hy_if
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
goto|goto
name|endintr
goto|;
default|default:
name|printf
argument_list|(
literal|"hy%d: DRIVER BUG - INVALID STATE %d\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|is
operator|->
name|hy_state
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"HYPERCHANNEL IN INVALID STATE"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|is
operator|->
name|hy_state
operator|==
name|IDLE
condition|)
goto|goto
name|actloop
goto|;
name|endintr
label|:
empty_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: hyact, exit at \"%s\"\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|hy_state_names
index|[
name|is
operator|->
name|hy_state
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_decl_stmt
name|struct
name|sockproto
name|hypproto
init|=
block|{
name|PF_HYLINK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|hypdst
init|=
block|{
name|AF_HYLINK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|hypsrc
init|=
block|{
name|AF_HYLINK
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Called from device interrupt when receiving data.  * Examine packet to determine type.  Decapsulate packet  * based on type and pass to type specific higher-level  * input routine.  */
end_comment

begin_macro
name|hyrecvdata
argument_list|(
argument|ui
argument_list|,
argument|hym
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|hym_hdr
modifier|*
name|hym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|inq
decl_stmt|;
name|is
operator|->
name|hy_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: recieved packet, len = %d\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HYLOG
block|{
struct|struct
block|{
name|short
name|hlen
decl_stmt|;
name|struct
name|hym_hdr
name|hhdr
decl_stmt|;
block|}
name|hh
struct|;
name|hh
operator|.
name|hlen
operator|=
name|len
expr_stmt|;
name|hh
operator|.
name|hhdr
operator|=
operator|*
name|hym
expr_stmt|;
name|hylog
argument_list|(
name|HYL_RECV
argument_list|,
sizeof|sizeof
argument_list|(
name|hh
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hh
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
name|HYMTU
operator|+
name|MPSIZE
operator|||
name|len
operator|==
literal|0
condition|)
return|return;
comment|/* sanity */
comment|/* 	 * Pull packet off interface. 	 */
name|m
operator|=
name|if_rubaget
argument_list|(
operator|&
name|is
operator|->
name|hy_ifuba
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|&
name|is
operator|->
name|hy_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * if normal or adapter loopback response packet believe hym_type, 	 * otherwise, use the raw input queue cause it's a response from an 	 * adapter command. 	 */
if|if
condition|(
name|hym
operator|->
name|hym_param
operator|!=
literal|0
operator|&&
operator|(
name|u_short
operator|)
name|hym
operator|->
name|hym_param
operator|!=
literal|0x80ff
condition|)
goto|goto
name|rawlinkin
goto|;
switch|switch
condition|(
name|hym
operator|->
name|hym_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|HYLINK_IP
case|:
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|rawlinkin
label|:
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|MGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m0
operator|->
name|m_off
operator|=
name|MMINOFF
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|hym
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hym_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
name|hypproto
operator|.
name|sp_protocol
operator|=
literal|0
expr_stmt|;
name|hypdst
operator|.
name|sin_addr
operator|=
name|is
operator|->
name|hy_addr
expr_stmt|;
name|hypsrc
operator|.
name|sin_addr
operator|=
name|is
operator|->
name|hy_addr
expr_stmt|;
name|raw_input
argument_list|(
name|m
argument_list|,
operator|&
name|hypproto
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|hypsrc
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|hypdst
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|IF_QFULL
argument_list|(
name|inq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|inq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|IF_ENQUEUE
argument_list|(
name|inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Transmit done, release resources, bump counters.  */
end_comment

begin_macro
name|hyxmitdata
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
name|is
operator|->
name|hy_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_xtofree
condition|)
block|{
name|m_freem
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_xtofree
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_xtofree
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|hycancel
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
if|if
condition|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_xtofree
condition|)
block|{
name|m_freem
argument_list|(
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_xtofree
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_ifuba
operator|.
name|ifu_xtofree
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HYLOG
name|hylog
argument_list|(
name|HYL_CANCEL
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hy_nodebug
operator|&
literal|1
condition|)
name|hy_debug_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|printD
argument_list|(
literal|"hy%d: cancel from state \"%s\" cmd=0x%x count=%d ptr=0x%x\n"
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|hy_state_names
index|[
name|is
operator|->
name|hy_state
index|]
argument_list|,
name|is
operator|->
name|hy_savedcmd
argument_list|,
name|is
operator|->
name|hy_savedcount
argument_list|,
name|is
operator|->
name|hy_savedaddr
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|"\tflags 0x%x olen %d lastwcr %d retry %d\n"
argument_list|,
name|is
operator|->
name|hy_flags
argument_list|,
name|is
operator|->
name|hy_olen
argument_list|,
name|is
operator|->
name|hy_lastwcr
argument_list|,
name|is
operator|->
name|hy_retry
argument_list|)
expr_stmt|;
name|printD
argument_list|(
literal|"\tsaved: state %d count %d ptr 0x%x cmd 0x%x\n"
argument_list|,
name|is
operator|->
name|hy_savedstate
argument_list|,
name|is
operator|->
name|hy_savedcount
argument_list|,
name|is
operator|->
name|hy_savedaddr
argument_list|,
name|is
operator|->
name|hy_savedcmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
name|is
operator|->
name|hy_flags
operator||=
operator|(
name|RQ_ENDOP
operator||
name|RQ_STATUS
operator|)
expr_stmt|;
name|hyact
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_expr_stmt
name|hyprintdata
argument_list|(
name|cp
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|count
init|=
literal|16
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|static
name|char
name|regfmt
index|[]
init|=
literal|"\n\t %x"
decl_stmt|;
name|fmt
operator|=
operator|&
name|regfmt
index|[
literal|2
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
name|printL
argument_list|(
name|fmt
argument_list|,
operator|*
name|cp
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|fmt
operator|=
operator|&
name|regfmt
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|count
operator|<=
literal|0
condition|)
block|{
name|fmt
operator|=
operator|&
name|regfmt
index|[
literal|0
index|]
expr_stmt|;
name|count
operator|=
literal|16
expr_stmt|;
block|}
block|}
name|printL
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|hywatch
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|hyinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hydevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|hydevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PI13
if|if
condition|(
operator|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_POWEROFF
operator|)
operator|!=
literal|0
condition|)
block|{
name|addr
operator|->
name|hyd_csr
operator||=
name|S_POWEROFF
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|->
name|hyd_csr
operator|&
name|S_POWEROFF
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hy%d: Adapter Power Restored (hywatch)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_state
operator|=
name|IDLE
expr_stmt|;
name|is
operator|->
name|hy_flags
operator||=
operator|(
name|RQ_MARKUP
operator||
name|RQ_STATISTICS
operator||
name|RQ_ENDOP
operator||
name|RQ_STATUS
operator|)
expr_stmt|;
name|hyact
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|++
name|is
operator|->
name|hy_ntime
operator|>=
literal|2
operator|&&
name|is
operator|->
name|hy_state
operator|!=
name|WAITING
operator|&&
name|is
operator|->
name|hy_state
operator|!=
name|STARTUP
operator|&&
name|is
operator|->
name|hy_state
operator|!=
name|IDLE
condition|)
block|{
ifdef|#
directive|ifdef
name|HYLOG
name|printf
argument_list|(
literal|"hy%d: watchdog timer expired in state \"%s\"\n"
argument_list|,
name|unit
argument_list|,
name|hy_state_names
index|[
name|is
operator|->
name|hy_state
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"hy%d: watchdog timer expired in state %d\n"
argument_list|,
name|unit
argument_list|,
name|is
operator|->
name|hy_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"hy%d: last command 0x%x, flags 0x%x, csr 0x%b\n"
argument_list|,
name|unit
argument_list|,
name|is
operator|->
name|hy_savedcmd
argument_list|,
name|is
operator|->
name|hy_flags
argument_list|,
name|addr
operator|->
name|hyd_csr
argument_list|,
name|HY_CSR_BITS
argument_list|)
expr_stmt|;
name|hycancel
argument_list|(
name|ui
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|is
operator|->
name|hy_if
operator|.
name|if_timer
operator|=
name|SCANINTERVAL
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HYLOG
end_ifdef

begin_macro
name|hylog
argument_list|(
argument|code
argument_list|,
argument|len
argument_list|,
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|code
decl_stmt|,
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|hy_log
operator|.
name|hyl_self
operator|!=
operator|&
name|hy_log
condition|)
block|{
name|hy_log
operator|.
name|hyl_eptr
operator|=
operator|&
name|hy_log
operator|.
name|hyl_buf
index|[
name|HYL_SIZE
index|]
expr_stmt|;
name|hy_log
operator|.
name|hyl_ptr
operator|=
operator|&
name|hy_log
operator|.
name|hyl_buf
index|[
literal|0
index|]
expr_stmt|;
name|hy_log
operator|.
name|hyl_self
operator|=
operator|&
name|hy_log
expr_stmt|;
name|hy_log
operator|.
name|hyl_enable
operator|=
name|HYL_CONTINUOUS
expr_stmt|;
name|hy_log
operator|.
name|hyl_onerr
operator|=
name|HYL_CONTINUOUS
expr_stmt|;
name|hy_log
operator|.
name|hyl_count
operator|=
literal|0
expr_stmt|;
name|hy_log
operator|.
name|hyl_icount
operator|=
literal|16
expr_stmt|;
name|hy_log
operator|.
name|hyl_filter
operator|=
literal|0xffff
expr_stmt|;
comment|/* enable all */
block|}
if|if
condition|(
name|hy_log
operator|.
name|hyl_enable
operator|==
name|HYL_DISABLED
operator|||
operator|(
operator|(
literal|1
operator|<<
name|code
operator|)
operator|&
name|hy_log
operator|.
name|hyl_filter
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|p
operator|=
name|hy_log
operator|.
name|hyl_ptr
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|len
operator|+
literal|3
operator|>=
name|hy_log
operator|.
name|hyl_eptr
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|hy_log
operator|.
name|hyl_eptr
operator|-
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|hy_log
operator|.
name|hyl_buf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|hy_log
operator|.
name|hyl_enable
operator|!=
name|HYL_CONTINUOUS
condition|)
block|{
name|hy_log
operator|.
name|hyl_enable
operator|=
name|HYL_DISABLED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
operator|*
name|p
operator|++
operator|=
name|code
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hy_log
operator|.
name|hyl_count
operator|!=
literal|0
operator|&&
operator|--
name|hy_log
operator|.
name|hyl_count
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|hy_log
operator|.
name|hyl_enable
operator|=
name|HYL_DISABLED
expr_stmt|;
name|hy_log
operator|.
name|hyl_count
operator|=
name|hy_log
operator|.
name|hyl_icount
expr_stmt|;
block|}
name|p
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|hy_log
operator|.
name|hyl_wait
operator|!=
literal|0
condition|)
block|{
comment|/* wakeup HYGETLOG if wanted */
if|if
condition|(
name|hy_log
operator|.
name|hyl_wait
operator|<=
name|p
operator|-
name|hy_log
operator|.
name|hyl_ptr
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|hy_log
argument_list|)
expr_stmt|;
name|hy_log
operator|.
name|hyl_wait
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|hy_log
operator|.
name|hyl_wait
operator|-=
name|p
operator|-
name|hy_log
operator|.
name|hyl_ptr
expr_stmt|;
block|}
name|hy_log
operator|.
name|hyl_ptr
operator|=
name|p
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|hyioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|hyrsetget
modifier|*
name|sg
init|=
operator|(
expr|struct
name|hyrsetget
operator|*
operator|)
name|data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HYLOG
argument_list|)
operator|||
name|defined
argument_list|(
name|HYELOG
argument_list|)
name|struct
name|hylsetget
modifier|*
name|sgl
init|=
operator|(
expr|struct
name|hylsetget
operator|*
operator|)
name|data
decl_stmt|;
endif|#
directive|endif
name|struct
name|hy_route
modifier|*
name|r
init|=
operator|(
expr|struct
name|hy_route
operator|*
operator|)
operator|&
name|hy_route
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HYLOG
name|struct
name|hy_softc
modifier|*
name|is
init|=
operator|&
name|hy_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
struct|struct
block|{
name|u_char
name|hstate
decl_stmt|;
name|u_char
name|hflags
decl_stmt|;
name|u_short
name|iflags
decl_stmt|;
name|int
name|hcmd
decl_stmt|;
name|int
name|herror
decl_stmt|;
name|u_long
name|haddr
decl_stmt|;
name|u_long
name|hmisc
decl_stmt|;
block|}
name|hil
struct|;
name|hil
operator|.
name|hmisc
operator|=
operator|-
literal|1
expr_stmt|;
name|hil
operator|.
name|hstate
operator|=
name|is
operator|->
name|hy_state
expr_stmt|;
name|hil
operator|.
name|hflags
operator|=
name|is
operator|->
name|hy_flags
expr_stmt|;
name|hil
operator|.
name|hcmd
operator|=
name|cmd
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|hyinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|hy_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|hy_addr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
ifdef|#
directive|ifdef
name|HYLOG
name|hil
operator|.
name|haddr
operator|=
name|is
operator|->
name|hy_addr
operator|.
name|s_addr
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|HYSETROUTE
case|:
if|if
condition|(
operator|!
name|suser
argument_list|()
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sg
operator|->
name|hyrsg_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|hy_route
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|sg
operator|->
name|hyrsg_ptr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|r
argument_list|,
name|sg
operator|->
name|hyrsg_len
argument_list|)
condition|)
block|{
name|r
operator|->
name|hyr_lasttime
operator|=
literal|0
expr_stmt|;
comment|/* disable further routing if trouble */
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|r
operator|->
name|hyr_lasttime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
ifdef|#
directive|ifdef
name|HYLOG
name|hil
operator|.
name|hmisc
operator|=
name|r
operator|->
name|hyr_lasttime
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|HYGETROUTE
case|:
if|if
condition|(
name|sg
operator|->
name|hyrsg_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|hy_route
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|r
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|sg
operator|->
name|hyrsg_ptr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hy_route
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
ifdef|#
directive|ifdef
name|HYELOG
case|case
name|HYGETELOG
case|:
if|if
condition|(
name|sgl
operator|->
name|hylsg_len
operator|<
sizeof|sizeof
argument_list|(
name|hy_elog
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|hy_elog
argument_list|,
name|sgl
operator|->
name|hylsg_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|hy_elog
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sgl
operator|->
name|hylsg_cmd
condition|)
block|{
if|if
condition|(
operator|!
name|suser
argument_list|()
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|hy_elog
argument_list|,
sizeof|sizeof
argument_list|(
name|hy_elog
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HYLOG
case|case
name|HYSETLOG
case|:
if|if
condition|(
operator|!
name|suser
argument_list|()
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hy_log
operator|.
name|hyl_enable
operator|=
name|HYL_DISABLED
expr_stmt|;
name|hylog
argument_list|(
name|HYL_NOP
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* force log init */
name|hy_log
operator|.
name|hyl_enable
operator|=
name|sgl
operator|->
name|hylsg_cmd
operator|&
literal|0x0f
expr_stmt|;
name|hy_log
operator|.
name|hyl_onerr
operator|=
operator|(
name|sgl
operator|->
name|hylsg_cmd
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
expr_stmt|;
name|hy_log
operator|.
name|hyl_filter
operator|=
operator|(
name|sgl
operator|->
name|hylsg_cmd
operator|>>
literal|8
operator|)
operator|&
literal|0xffffff
expr_stmt|;
name|hy_log
operator|.
name|hyl_count
operator|=
name|hy_log
operator|.
name|hyl_icount
operator|=
name|sgl
operator|->
name|hylsg_len
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|hy_log
argument_list|)
expr_stmt|;
comment|/* wakeup sleeping HYGETLOG */
break|break;
case|case
name|HYGETLOG
case|:
if|if
condition|(
name|sgl
operator|->
name|hylsg_len
operator|<
sizeof|sizeof
argument_list|(
name|hy_log
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sgl
operator|->
name|hylsg_cmd
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hy_log
operator|.
name|hyl_wait
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hy_log
operator|.
name|hyl_wait
operator|=
name|sgl
operator|->
name|hylsg_cmd
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|hy_log
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|hy_log
argument_list|,
name|sgl
operator|->
name|hylsg_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|hy_log
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|out
label|:
ifdef|#
directive|ifdef
name|HYLOG
name|hil
operator|.
name|herror
operator|=
name|error
expr_stmt|;
name|hil
operator|.
name|iflags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|hil
operator|.
name|haddr
operator|=
name|is
operator|->
name|hy_addr
operator|.
name|s_addr
expr_stmt|;
name|hylog
argument_list|(
name|HYL_IOCTL
argument_list|,
sizeof|sizeof
argument_list|(
name|hil
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hil
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

