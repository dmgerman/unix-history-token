begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)if_pcl.c	7.1 (Berkeley) 6/5/86  */
end_comment

begin_include
include|#
directive|include
file|"pcl.h"
end_include

begin_if
if|#
directive|if
name|NPCL
operator|>
literal|0
end_if

begin_comment
comment|/*  * DEC CSS PCL-11B Parallel Communications Interface  *  * Written by Mike Muuss and Jeff Schwab.  */
end_comment

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|"../netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"if_pclreg.h"
end_include

begin_include
include|#
directive|include
file|"if_uba.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_comment
comment|/* The MTU has been carefully selected to prevent fragmentation<-> ArpaNet */
end_comment

begin_define
define|#
directive|define
name|PCLMTU
value|(1006)
end_define

begin_comment
comment|/* Max transmission unit (bytes) */
end_comment

begin_define
define|#
directive|define
name|PCLMAXTDM
value|7
end_define

begin_comment
comment|/* Max unit number on TDM bus */
end_comment

begin_decl_stmt
name|int
name|pclprobe
argument_list|()
decl_stmt|,
name|pclattach
argument_list|()
decl_stmt|,
name|pclrint
argument_list|()
decl_stmt|,
name|pclxint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pclinit
argument_list|()
decl_stmt|,
name|pclioctl
argument_list|()
decl_stmt|,
name|pcloutput
argument_list|()
decl_stmt|,
name|pclreset
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|pclinfo
index|[
name|NPCL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|pclstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PCLUNIT
parameter_list|(
name|x
parameter_list|)
value|minor(x)
end_define

begin_decl_stmt
name|struct
name|uba_driver
name|pcldriver
init|=
block|{
name|pclprobe
block|,
literal|0
block|,
name|pclattach
block|,
literal|0
block|,
name|pclstd
block|,
literal|"pcl"
block|,
name|pclinfo
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PCL software status per interface.  *  * Each interface is referenced by a network interface structure,  * sc_if, which the routing code uses to locate the interface.  * This structure contains the output queue for the interface, its address, ...  * We also have, for each interface, a UBA interface structure, which  * contains information about the UNIBUS resources held by the interface:  * map registers, buffered data paths, etc.  Information is cached in this  * structure for use by the if_uba.c routines in running the interface  * efficiently.  */
end_comment

begin_struct
struct|struct
name|pcl_softc
block|{
name|struct
name|ifnet
name|sc_if
decl_stmt|;
comment|/* network-visible interface */
name|struct
name|ifuba
name|sc_ifuba
decl_stmt|;
comment|/* UNIBUS resources */
name|short
name|sc_oactive
decl_stmt|;
comment|/* is output active? */
name|short
name|sc_olen
decl_stmt|;
comment|/* length of last output */
name|short
name|sc_lastdest
decl_stmt|;
comment|/* previous destination */
name|short
name|sc_odest
decl_stmt|;
comment|/* current xmit destination */
name|short
name|sc_bdest
decl_stmt|;
comment|/* buffer's stated destination */
name|short
name|sc_pattern
decl_stmt|;
comment|/* identification pattern */
block|}
name|pcl_softc
index|[
name|NPCL
index|]
struct|;
end_struct

begin_comment
comment|/*  * Structure of "local header", which only goes between  * pcloutput and pclstart.  */
end_comment

begin_struct
struct|struct
name|pcl_header
block|{
name|short
name|pcl_dest
decl_stmt|;
comment|/* Destination PCL station */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Do non-DMA output of 1 word to determine presence of interface,  * and to find the interupt vector.  1 word messages are a special  * case in the receiver routine, and will be discarded.  */
end_comment

begin_macro
name|pclprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* r11, r10 value-result */
specifier|register
name|struct
name|pcldevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|pcldevice
operator|*
operator|)
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|pclrint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pclxint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|->
name|pcl_rcr
operator|=
name|PCL_RCINIT
expr_stmt|;
name|addr
operator|->
name|pcl_tcr
operator|=
name|PCL_TXINIT
expr_stmt|;
name|addr
operator|->
name|pcl_tsba
operator|=
literal|0xFFFE
expr_stmt|;
comment|/* going for 01777776 */
name|addr
operator|->
name|pcl_tsbc
operator|=
operator|-
literal|4
expr_stmt|;
comment|/* really short */
name|addr
operator|->
name|pcl_tcr
operator|=
operator|(
operator|(
literal|1
operator|&
literal|0xF
operator|)
operator|<<
literal|8
operator|)
operator||
name|PCL_TXNPR
operator||
name|PCL_SNDWD
operator||
name|PCL_STTXM
operator||
name|PCL_IE
operator||
literal|0x0030
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|addr
operator|->
name|pcl_tcr
operator|=
name|PCL_TXINIT
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|pcldevice
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_macro
name|pclattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pcl_softc
modifier|*
name|sc
init|=
operator|&
name|pcl_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
operator|=
name|ui
operator|->
name|ui_unit
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_name
operator|=
literal|"pcl"
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|=
name|PCLMTU
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_init
operator|=
name|pclinit
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_output
operator|=
name|pcloutput
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ioctl
operator|=
name|pclioctl
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_reset
operator|=
name|pclreset
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|=
name|IFF_BROADCAST
expr_stmt|;
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_flags
operator|=
name|UBA_NEEDBDP
expr_stmt|;
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reset of interface after UNIBUS reset.  * If interface is on specified uba, reset its state.  */
end_comment

begin_macro
name|pclreset
argument_list|(
argument|unit
argument_list|,
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NPCL
operator|||
operator|(
name|ui
operator|=
name|pclinfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_ubanum
operator|!=
name|uban
condition|)
return|return;
name|printf
argument_list|(
literal|" pcl%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|pclinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialization of interface; clear recorded pending  * operations, and reinitialize UNIBUS usage.  */
end_comment

begin_macro
name|pclinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pcl_softc
modifier|*
name|sc
init|=
operator|&
name|pcl_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|pclinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|pcldevice
modifier|*
name|addr
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
if|if
condition|(
name|if_ubainit
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifuba
argument_list|,
name|ui
operator|->
name|ui_ubanum
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|btoc
argument_list|(
name|PCLMTU
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pcl%d: can't init\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|pcldevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|addr
operator|->
name|pcl_rcr
operator|=
name|PCL_RCINIT
expr_stmt|;
name|addr
operator|->
name|pcl_tcr
operator|=
name|PCL_TXINIT
expr_stmt|;
comment|/* 	 * Hang a receive and start any 	 * pending writes by faking a transmit complete. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|addr
operator|->
name|pcl_rdba
operator|=
operator|(
name|short
operator|)
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
expr_stmt|;
name|addr
operator|->
name|pcl_rdbc
operator|=
operator|-
name|PCLMTU
expr_stmt|;
name|addr
operator|->
name|pcl_rcr
operator|=
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
operator|>>
literal|12
argument_list|)
operator|)
operator|&
literal|0x0030
operator|)
operator||
name|PCL_RCNPR
operator||
name|PCL_RCVWD
operator||
name|PCL_RCVDAT
operator||
name|PCL_IE
expr_stmt|;
name|sc
operator|->
name|sc_oactive
operator|=
literal|0
expr_stmt|;
name|pclstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * PCL output routine.  */
end_comment

begin_macro
name|pcloutput
argument_list|(
argument|ifp
argument_list|,
argument|m
argument_list|,
argument|dst
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dest
decl_stmt|,
name|s
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|pcl_header
modifier|*
name|pclp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|in_broadcast
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin_addr
argument_list|)
condition|)
name|dest
operator|=
literal|0
expr_stmt|;
else|else
name|dest
operator|=
name|in_lnaof
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|>
name|PCLMAXTDM
condition|)
block|{
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"pcl%d: can't handle af%d\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Add pseudo local net header. 	 * Actually, it does not get transmitted, but merely stripped 	 * off and used by the START routine to route the packet. 	 * If no space in first mbuf, allocate another. 	 */
if|if
condition|(
name|m
operator|->
name|m_off
operator|>
name|MMAXOFF
operator|||
name|MMINOFF
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pcl_header
argument_list|)
operator|>
name|m
operator|->
name|m_off
condition|)
block|{
name|m2
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m2
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m2
operator|->
name|m_off
operator|=
name|MMINOFF
expr_stmt|;
name|m2
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pcl_header
argument_list|)
expr_stmt|;
name|m
operator|=
name|m2
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|pcl_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|pcl_header
argument_list|)
expr_stmt|;
block|}
name|pclp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pcl_header
operator|*
argument_list|)
expr_stmt|;
name|pclp
operator|->
name|pcl_dest
operator|=
name|dest
expr_stmt|;
comment|/* 	 * Queue message on interface, and start output if interface 	 * not yet active. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|qfull
goto|;
block|}
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcl_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|sc_oactive
operator|==
literal|0
condition|)
name|pclstart
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|qfull
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Start or restart output on interface.  * If interface is already active, then this is a retransmit.  * If interface is not already active, get another datagram  * to send off of the interface queue, and map it to the interface  * before starting the output.  */
end_comment

begin_macro
name|pclstart
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|PCLUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|pclinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|pcl_softc
modifier|*
name|sc
init|=
operator|&
name|pcl_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|pcldevice
modifier|*
name|addr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_oactive
condition|)
goto|goto
name|restart
goto|;
comment|/* 	 * Not already active: dequeue another request 	 * and map it to the UNIBUS.  If no more requests, 	 * just return. 	 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_oactive
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * Pull destination node out of pseudo-local net header. 	 * remove it from outbound data. 	 * Note that if_wubaput calls m_bcopy, which is prepared for 	 * m_len to be 0 in the first mbuf in the chain. 	 */
name|sc
operator|->
name|sc_bdest
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pcl_header
operator|*
argument_list|)
operator|->
name|pcl_dest
expr_stmt|;
name|sc
operator|->
name|sc_odest
operator|=
name|sc
operator|->
name|sc_bdest
condition|?
name|sc
operator|->
name|sc_bdest
else|:
literal|1
expr_stmt|;
name|m
operator|->
name|m_off
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|pcl_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|pcl_header
argument_list|)
expr_stmt|;
comment|/* Map out to the DMA area */
name|sc
operator|->
name|sc_olen
operator|=
name|if_wubaput
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifuba
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|restart
label|:
comment|/* 	 * Have request mapped to UNIBUS for transmission. 	 * Purge any stale data from this BDP, and start the output. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_uba
argument_list|,
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|pcldevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|addr
operator|->
name|pcl_tcr
operator|=
name|PCL_TXINIT
expr_stmt|;
name|addr
operator|->
name|pcl_tsba
operator|=
operator|(
name|int
operator|)
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_info
expr_stmt|;
name|addr
operator|->
name|pcl_tsbc
operator|=
operator|-
name|sc
operator|->
name|sc_olen
expr_stmt|;
comment|/* 	 * RIB (retry if busy) is used on the second and subsequent packets 	 * to a single host, because TCP often wants to transmit multiple 	 * buffers in a row, 	 * and if they are all going to the same place, the second and 	 * subsequent ones may be lost due to receiver not ready again yet. 	 * This can cause serious problems, because the TCP will resend the 	 * whole window, which just repeats the problem.  The result is that 	 * a perfectly good link appears not to work unless we take steps here. 	 */
name|addr
operator|->
name|pcl_tcr
operator|=
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_info
operator|>>
literal|12
argument_list|)
operator|)
operator|&
literal|0x0030
operator|)
operator||
operator|(
operator|(
name|sc
operator|->
name|sc_odest
operator|&
literal|0xF
operator|)
operator|<<
literal|8
operator|)
operator||
name|PCL_TXNPR
operator||
name|PCL_SNDWD
operator||
name|PCL_STTXM
operator||
name|PCL_IE
operator||
operator|(
name|sc
operator|->
name|sc_odest
operator|==
name|sc
operator|->
name|sc_lastdest
condition|?
name|PCL_RIB
else|:
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_lastdest
operator|=
name|sc
operator|->
name|sc_odest
expr_stmt|;
name|sc
operator|->
name|sc_oactive
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * PCL transmitter interrupt.  * Start another output if more data to send.  */
end_comment

begin_macro
name|pclxint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|pclinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|pcl_softc
modifier|*
name|sc
init|=
operator|&
name|pcl_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|pcldevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|pcldevice
operator|*
operator|)
name|ui
operator|->
name|ui_addr
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_oactive
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pcl%d: stray interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|addr
operator|->
name|pcl_tsr
operator|&
name|PCL_ERR
condition|)
block|{
name|sc
operator|->
name|sc_lastdest
operator|=
literal|0
expr_stmt|;
comment|/* don't bother with RIB */
if|if
condition|(
name|addr
operator|->
name|pcl_tsr
operator|&
name|PCL_MSTDWN
condition|)
block|{
name|addr
operator|->
name|pcl_tmmr
operator|=
name|PCL_MASTER
operator||
name|PCL_AUTOADDR
expr_stmt|;
name|pclstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* Retry */
name|printf
argument_list|(
literal|"pcl%d: master\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|PCL_TESTING
if|if
condition|(
operator|(
name|addr
operator|->
name|pcl_tsr
operator|&
operator|(
name|PCL_ERR
operator||
name|PCL_RESPB
operator|)
operator|)
operator|==
operator|(
name|PCL_ERR
operator||
literal|0
operator|)
condition|)
block|{
empty_stmt|;
comment|/* Receiver Offline -- not exactly an error */
block|}
else|else
block|{
else|#
directive|else
block|{
endif|#
directive|endif
comment|/* Log as an error */
name|printf
argument_list|(
literal|"pcl%d: send error, tcr=%b tsr=%b\n"
argument_list|,
name|unit
argument_list|,
name|addr
operator|->
name|pcl_tcr
argument_list|,
name|PCL_TCSRBITS
argument_list|,
name|addr
operator|->
name|pcl_tsr
argument_list|,
name|PCL_TERRBITS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
block|}
else|else
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bdest
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_odest
operator|<
name|PCLMAXTDM
condition|)
block|{
name|sc
operator|->
name|sc_odest
operator|++
expr_stmt|;
comment|/* do next host (broadcast) */
block|}
else|else
block|{
name|sc
operator|->
name|sc_oactive
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_xtofree
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_xtofree
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_xtofree
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|pclstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/*  * PCL interface receiver interrupt.  * If input error just drop packet.  */
name|pclrint
argument_list|(
argument|unit
argument_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|pcl_softc
modifier|*
name|sc
init|=
operator|&
name|pcl_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|pcldevice
modifier|*
name|addr
init|=
operator|(
expr|struct
name|pcldevice
operator|*
operator|)
name|pclinfo
index|[
name|unit
index|]
operator|->
name|ui_addr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|inq
decl_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
comment|/* 	 * Purge BDP; drop if input error indicated. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_flags
operator|&
name|UBA_NEEDBDP
condition|)
name|UBAPURGE
argument_list|(
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_uba
argument_list|,
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_bdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|pcl_rsr
operator|&
name|PCL_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"pcl%d: rcv error, rcr=%b rsr=%b\n"
argument_list|,
name|unit
argument_list|,
name|addr
operator|->
name|pcl_rcr
argument_list|,
name|PCL_RCSRBITS
argument_list|,
name|addr
operator|->
name|pcl_rsr
argument_list|,
name|PCL_RERRBITS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|setup
goto|;
block|}
name|len
operator|=
name|PCLMTU
operator|+
name|addr
operator|->
name|pcl_rdbc
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
name|PCLMTU
condition|)
block|{
name|printf
argument_list|(
literal|"pcl%d: bad len=%d.\n"
argument_list|,
name|unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|setup
goto|;
block|}
comment|/* Really short packets will be part of the startup sequence */
if|if
condition|(
name|len
operator|<=
literal|4
condition|)
block|{
comment|/* Later, do comming-up processing here */
goto|goto
name|setup
goto|;
comment|/* drop packet */
block|}
comment|/* 	 * Pull packet off interface. 	 */
name|m
operator|=
name|if_rubaget
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifuba
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|setup
goto|;
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|inq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|inq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|IF_ENQUEUE
argument_list|(
name|inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|setup
label|:
comment|/* 	 * Reset for next packet. 	 */
name|addr
operator|->
name|pcl_rcr
operator|=
name|PCL_RCINIT
expr_stmt|;
name|addr
operator|->
name|pcl_rdba
operator|=
operator|(
name|int
operator|)
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
expr_stmt|;
name|addr
operator|->
name|pcl_rdbc
operator|=
operator|-
name|PCLMTU
expr_stmt|;
name|addr
operator|->
name|pcl_rcr
operator|=
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|sc
operator|->
name|sc_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_info
operator|>>
literal|12
argument_list|)
operator|)
operator|&
literal|0x0030
operator|)
operator||
name|PCL_RCNPR
operator||
name|PCL_RCVWD
operator||
name|PCL_RCVDAT
operator||
name|PCL_IE
expr_stmt|;
block|}
comment|/*  * Process an ioctl request.  */
comment|/* ARGSUSED */
name|pclioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|pclinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

