begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	@(#)if_hdh.c	7.5 (Berkeley) 5/26/88 */
end_comment

begin_comment
comment|/************************************************************************\       ________________________________________________________     /                                                        \    |          AAA          CCCCCCCCCCCCCC    CCCCCCCCCCCCCC   |    |         AAAAA        CCCCCCCCCCCCCCCC  CCCCCCCCCCCCCCCC  |    |        AAAAAAA       CCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCC |    |       AAAA AAAA      CCCC              CCCC              |    |      AAAA   AAAA     CCCC              CCCC              |    |     AAAA     AAAA    CCCC              CCCC              |    |    AAAA       AAAA   CCCC              CCCC              |    |   AAAA  AAAAAAAAAAA  CCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCC |    |  AAAA    AAAAAAAAAAA CCCCCCCCCCCCCCCC  CCCCCCCCCCCCCCCC  |    | AAAA      AAAAAAAAA   CCCCCCCCCCCCCC    CCCCCCCCCCCCCC   |     \________________________________________________________/  	Copyright (c) 1984 by Advanced Computer Communications 	720 Santa Barbara Street, Santa Barbara, California  93101 	(805) 963-9431  	This software may be duplicated and used on systems 	which are licensed to run U.C. Berkeley versions of 	the UNIX operating system.  Any duplication of any 	part of this software must include a copy of ACC's 	copyright notice.   File: 		if_hdh.c  Author: 		Art Berggreen  Project: 		4.2BSD HDH  Function: 		Device specific driver for IF-11/HDH under 4.2BSD     		networking code.  Revision History: 		Converted to 4.3, updated, UCB. 		31-Aug-1984: V1.0 - First Implementation. A.B. 		 6-Nov-1984: V1.1 - Supress extra "LINE DOWN" msgs. A.B. 		13-Jan-1984: V1.2 - Add conditionals for TWG. A.B.  \************************************************************************/
end_comment

begin_comment
comment|/* $Header$ */
end_comment

begin_include
include|#
directive|include
file|"hdh.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NHDH
name|>
name|0
end_ifdef

begin_comment
comment|/*  *  * ACC IF-11/HDH interface  *  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../netimp/if_imp.h"
end_include

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_include
include|#
directive|include
file|"if_hdhreg.h"
end_include

begin_include
include|#
directive|include
file|"if_uba.h"
end_include

begin_decl_stmt
name|int
name|hdhprobe
argument_list|()
decl_stmt|,
name|hdhattach
argument_list|()
decl_stmt|,
name|hdhintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|hdhinfo
index|[
name|NHDH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|hdhstd
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uba_driver
name|hdhdriver
init|=
block|{
name|hdhprobe
block|,
literal|0
block|,
name|hdhattach
block|,
literal|0
block|,
name|hdhstd
block|,
literal|"hdh"
block|,
name|hdhinfo
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HDHUNIT
parameter_list|(
name|x
parameter_list|)
value|minor(x)
end_define

begin_decl_stmt
name|int
name|hdhinit
argument_list|()
decl_stmt|,
name|hdhoutput
argument_list|()
decl_stmt|,
name|hdhreset
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "Lower half" of IMP interface driver.  *  * Each IMP interface is handled by a common module which handles  * the IMP-host protocol and a hardware driver which manages the  * hardware specific details of talking with the IMP.  *  * The hardware portion of the IMP driver handles DMA and related  * management of UNIBUS resources.  The IMP protocol module interprets  * contents of these messages and "controls" the actions of the  * hardware module during IMP resets, but not, for instance, during  * UNIBUS resets.  *  * The two modules are coupled at "attach time", and ever after,  * through the imp interface structure.  Higher level protocols,  * e.g. IP, interact with the IMP driver, rather than the HDH.  */
end_comment

begin_define
define|#
directive|define
name|NHDHCH
value|2
end_define

begin_comment
comment|/* no. of FDX channels for HDH */
end_comment

begin_define
define|#
directive|define
name|SUPR
value|0
end_define

begin_comment
comment|/* supervisor channel */
end_comment

begin_define
define|#
directive|define
name|DATA
value|1
end_define

begin_comment
comment|/* data channel */
end_comment

begin_define
define|#
directive|define
name|HDHSUPR
value|0
end_define

begin_comment
comment|/* supervisor read */
end_comment

begin_define
define|#
directive|define
name|HDHSUPW
value|1
end_define

begin_comment
comment|/* supervisor write */
end_comment

begin_define
define|#
directive|define
name|HDHDATR
value|2
end_define

begin_comment
comment|/* data read */
end_comment

begin_define
define|#
directive|define
name|HDHDATW
value|3
end_define

begin_comment
comment|/* data write */
end_comment

begin_define
define|#
directive|define
name|HDH_UP
value|2
end_define

begin_comment
comment|/* HDH protocol is up */
end_comment

begin_define
define|#
directive|define
name|HDH_STARTED
value|1
end_define

begin_comment
comment|/* HDH has been initialized */
end_comment

begin_define
define|#
directive|define
name|HCBUSY
value|1
end_define

begin_comment
comment|/* HDH HDX channel busy flag */
end_comment

begin_comment
comment|/* /* The IF-11/HDH has four independent dath flow channels between the /* front-end and the host.  Two are used for reading and writing /* control messages and two are used for data flow.  Each IF-11/HDH /* has a device dependent data structure (hdh_softc) which contains /* an array of four channel dependent structures (hdh_chan) to maintain /* the context of each channel.  Channel structures can be linked into /* a queue of I/O requests pending for the hardware interface. /* UNIBUS mapping resources are allocated for each channel pair. */
end_comment

begin_struct
struct|struct
name|hdh_chan
block|{
comment|/* HDH HDX channel structure */
name|struct
name|hdh_chan
modifier|*
name|hc_next
decl_stmt|;
comment|/* link for Start I/O queuing */
name|char
name|hc_chan
decl_stmt|;
comment|/* HDX chan number */
name|char
name|hc_adx
decl_stmt|;
comment|/* extended UNIBUS address bits */
name|short
name|hc_addr
decl_stmt|;
comment|/* lower UNIBUS address bits */
name|short
name|hc_cnt
decl_stmt|;
comment|/* byte count */
name|char
name|hc_func
decl_stmt|;
comment|/* UMC I/O function */
name|char
name|hc_sbfc
decl_stmt|;
comment|/* UMC I/O subfunction */
name|short
name|hc_flags
decl_stmt|;
comment|/* status flags */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hdh_sioq
block|{
comment|/* Start I/O queue head structure */
name|struct
name|hdh_chan
modifier|*
name|sioq_head
decl_stmt|;
comment|/* pointer to queue head */
name|struct
name|hdh_chan
modifier|*
name|sioq_tail
decl_stmt|;
comment|/* pointer to queue tail */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hdh_softc
block|{
comment|/* HDH device dependent structure */
name|struct
name|imp_softc
modifier|*
name|hdh_imp
decl_stmt|;
comment|/* pointer to IMP's imp_softc struct */
name|struct
name|ifuba
name|hdh_ifuba
index|[
name|NHDHCH
index|]
decl_stmt|;
comment|/* UNIBUS resources */
name|struct
name|hdh_chan
name|hdh_chan
index|[
literal|2
operator|*
name|NHDHCH
index|]
decl_stmt|;
comment|/* HDX HDH channels */
name|struct
name|hdh_sioq
name|hdh_sioq
decl_stmt|;
comment|/* start i/o queue */
name|short
name|hdh_flags
decl_stmt|;
comment|/* various status conditions */
block|}
name|hdh_softc
index|[
name|NHDH
index|]
struct|;
end_struct

begin_comment
comment|/*  * Normally, code goes here to cause the device to interrupt to determine its  * interrupt vector.  However, since the UMC must be told its vector in order  * to interrupt, we allocate and return an unused vector and initialize the  * UMC.  */
end_comment

begin_macro
name|hdhprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
name|struct
name|hdhregs
modifier|*
name|addr
init|=
operator|(
expr|struct
name|hdhregs
operator|*
operator|)
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|hdhintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|br
operator|=
literal|0x15
expr_stmt|;
comment|/* priority 21 (5 on UNIBUS) */
ifdef|#
directive|ifdef
name|HDHDEBUG
name|cvec
operator|=
literal|0270
expr_stmt|;
comment|/* use constant for now ... */
else|#
directive|else
ifdef|#
directive|ifdef
name|VAXVMS
comment|/* if VMS */
name|cvec
operator|=
literal|0270
expr_stmt|;
comment|/*   we can't allocate vectors */
else|#
directive|else
name|cvec
operator|=
operator|(
name|uba_hd
index|[
name|numuba
index|]
operator|.
name|uh_lastiv
operator|-=
literal|4
operator|)
expr_stmt|;
comment|/* available vector */
endif|#
directive|endif
endif|VAXVMS
endif|#
directive|endif
endif|HDHDEBUG
name|addr
operator|->
name|ioini
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
comment|/* init UMC regs */
name|addr
operator|->
name|staack
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
comment|/*   pass vector */
name|addr
operator|->
name|ionmi
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
comment|/*     and kick UMC */
name|addr
operator|->
name|iochn
operator|=
call|(
name|char
call|)
argument_list|(
name|cvec
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
operator|(
name|short
operator|)
name|HDH_RST
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
call|(
name|short
call|)
argument_list|(
name|HDH_IEN
operator||
name|HDH_DMA
operator||
name|HDH_WRT
argument_list|)
expr_stmt|;
comment|/* set enables */
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* give the UMC some time */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Call the IMP module to allow it to set up its internal  * state, then tie the two modules together by setting up  * the back pointers to common data structures.  */
end_comment

begin_expr_stmt
name|hdhattach
argument_list|(
name|ui
argument_list|)
specifier|register
expr|struct
name|uba_device
operator|*
name|ui
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|hdh_softc
modifier|*
name|sc
init|=
operator|&
name|hdh_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|impcb
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|hdh_imp
operator|=
name|impattach
argument_list|(
name|ui
operator|->
name|ui_driver
operator|->
name|ud_dname
argument_list|,
name|ui
operator|->
name|ui_unit
argument_list|,
name|hdhreset
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|ip
operator|=
operator|&
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_cb
expr_stmt|;
name|ip
operator|->
name|ic_init
operator|=
name|hdhinit
expr_stmt|;
name|ip
operator|->
name|ic_output
operator|=
name|hdhoutput
expr_stmt|;
name|sc
operator|->
name|hdh_ifuba
index|[
name|ui
operator|->
name|ui_unit
index|]
operator|.
name|ifu_flags
operator|=
name|UBA_CANTWAIT
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reset interface after UNIBUS reset.  */
end_comment

begin_macro
name|hdhreset
argument_list|(
argument|unit
argument_list|,
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|hdhinfo
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hdh_softc
modifier|*
name|sc
init|=
operator|&
name|hdh_softc
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|HDHDEBUG
name|printf
argument_list|(
literal|"HDH RESET\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|HDHDEBUG
if|if
condition|(
operator|(
name|unit
operator|>=
name|NHDH
operator|)
operator|||
operator|(
name|ui
operator|==
literal|0
operator|)
operator|||
operator|(
name|ui
operator|->
name|ui_alive
operator|==
literal|0
operator|)
operator|||
operator|(
name|ui
operator|->
name|ui_ubanum
operator|!=
name|uban
operator|)
condition|)
return|return;
name|printf
argument_list|(
literal|" hdh%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_cb
operator|.
name|ic_oactive
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|hdh_flags
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_if
operator|.
name|if_init
call|)
argument_list|(
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialize the imp interface.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|init_blk
index|[]
init|=
block|{
name|HDHINIT
block|,
comment|/* SYSINIT opcode			*/
name|HDHRQUP
operator|&
literal|0xff
block|,
comment|/* control code (LSB)			*/
operator|(
name|HDHRQUP
operator|>>
literal|8
operator|)
operator|&
literal|0xff
block|,
comment|/* control code (MSB)			*/
literal|10
block|,
comment|/* command extension len		*/
literal|0
block|,
comment|/* loopback mode (off)			*/
literal|3
block|,
comment|/* our address (3=DTE)			*/
literal|1
block|,
comment|/* their address (1=DCE)		*/
literal|3
block|,
comment|/* frame ack t1 timeout			*/
literal|3
block|,
comment|/* poll ack timeout			*/
literal|30
block|,
comment|/* adm wait timeout			*/
literal|3
block|,
comment|/* rej wait timeout			*/
literal|10
block|,
comment|/* max retries				*/
literal|3
block|,
comment|/* watchdog timeout			*/
literal|0xaa
comment|/* baud rate (0xaa=38.4KB)		*/
comment|/*   (output on RS-232 pin 24,		*/
comment|/*    send/receive timing is always	*/
comment|/*    taken from pins 15/17)		*/
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|hdhinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hdh_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HDHDEBUG
name|printf
argument_list|(
literal|"HDH INIT\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|HDHDEBUG
if|if
condition|(
name|unit
operator|>=
name|NHDH
operator|||
operator|(
name|ui
operator|=
name|hdhinfo
index|[
name|unit
index|]
operator|)
operator|==
name|NULL
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hdh%d: not alive\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|=
operator|&
name|hdh_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hdh_flags
operator|&
name|HDH_STARTED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Alloc uba resources 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NHDHCH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|if_ubainit
argument_list|(
operator|&
name|sc
operator|->
name|hdh_ifuba
index|[
name|i
index|]
argument_list|,
name|ui
operator|->
name|ui_ubanum
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|btoc
argument_list|(
name|IMP_RCVBUF
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hdh%d: cannot get chan %d uba resources\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ui
operator|->
name|ui_alive
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|sc
operator|->
name|hdh_flags
operator|=
name|HDH_STARTED
expr_stmt|;
comment|/* 	 * hang a supervisor read (for line status) 	 */
name|hdh_iorq
argument_list|(
name|unit
argument_list|,
name|HDHSUPR
argument_list|,
name|IMP_RCVBUF
argument_list|,
name|HDHRDB
argument_list|)
expr_stmt|;
comment|/* 	 * hang a data read 	 */
name|hdh_iorq
argument_list|(
name|unit
argument_list|,
name|HDHDATR
argument_list|,
name|IMP_RCVBUF
argument_list|,
name|HDHRDB
operator|+
name|HDHSTR
argument_list|)
expr_stmt|;
comment|/* 	 * bring up line to IMP 	 */
name|snd_supr
argument_list|(
name|unit
argument_list|,
name|init_blk
argument_list|,
sizeof|sizeof
argument_list|(
name|init_blk
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Start an output operation on an mbuf.  */
end_comment

begin_macro
name|hdhoutput
argument_list|(
argument|unit
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hdh_softc
modifier|*
name|sc
init|=
operator|&
name|hdh_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* 	 * If output isn't active, attempt to 	 * start sending a new packet. 	 */
if|if
condition|(
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_cb
operator|.
name|ic_oactive
condition|)
block|{
name|printf
argument_list|(
literal|"hdh%d: start on active unit\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|hdh_flags
operator|&
name|HDH_UP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Link not up, can't xmit */
return|return;
block|}
name|len
operator|=
name|if_wubaput
argument_list|(
operator|&
name|sc
operator|->
name|hdh_ifuba
index|[
name|DATA
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* copy data to mapped mem */
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_cb
operator|.
name|ic_oactive
operator|=
literal|1
expr_stmt|;
name|hdh_iorq
argument_list|(
name|unit
argument_list|,
name|HDHDATW
argument_list|,
name|len
argument_list|,
name|HDHWRT
operator|+
name|HDHEOS
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start i/o operation on a UMC logical channel  */
end_comment

begin_macro
name|hdh_iorq
argument_list|(
argument|unit
argument_list|,
argument|lcn
argument_list|,
argument|len
argument_list|,
argument|func
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|lcn
decl_stmt|,
name|len
decl_stmt|,
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hdh_softc
modifier|*
name|sc
init|=
operator|&
name|hdh_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hdh_chan
modifier|*
name|hc
init|=
operator|&
name|sc
operator|->
name|hdh_chan
index|[
name|lcn
index|]
decl_stmt|;
specifier|register
name|int
name|info
decl_stmt|,
name|s
decl_stmt|;
comment|/* 	 * If channel is busy (shouldn't be), drop. 	 */
if|if
condition|(
name|hc
operator|->
name|hc_flags
operator|&
name|HCBUSY
condition|)
block|{
name|printf
argument_list|(
literal|"hdh%d: channel busy lcn=%d\n"
argument_list|,
name|unit
argument_list|,
name|lcn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get appropriate UNIBUS mapping info */
if|if
condition|(
name|lcn
operator|&
literal|1
condition|)
comment|/* read or write? */
name|info
operator|=
name|sc
operator|->
name|hdh_ifuba
index|[
name|lcn
operator|>>
literal|1
index|]
operator|.
name|ifu_w
operator|.
name|ifrw_info
expr_stmt|;
else|else
name|info
operator|=
name|sc
operator|->
name|hdh_ifuba
index|[
name|lcn
operator|>>
literal|1
index|]
operator|.
name|ifu_r
operator|.
name|ifrw_info
expr_stmt|;
comment|/* set channel info */
name|hc
operator|->
name|hc_flags
operator||=
name|HCBUSY
expr_stmt|;
name|hc
operator|->
name|hc_chan
operator|=
name|lcn
expr_stmt|;
name|hc
operator|->
name|hc_adx
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|info
operator|&
literal|0x30000
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|hc
operator|->
name|hc_addr
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|info
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|hc
operator|->
name|hc_cnt
operator|=
name|len
expr_stmt|;
name|hc
operator|->
name|hc_func
operator|=
operator|(
name|char
operator|)
name|func
expr_stmt|;
name|hc
operator|->
name|hc_sbfc
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * If UMC comm regs busy, queue start i/o for later. 	 */
if|if
condition|(
name|sc
operator|->
name|hdh_sioq
operator|.
name|sioq_head
condition|)
block|{
operator|(
name|sc
operator|->
name|hdh_sioq
operator|.
name|sioq_tail
operator|)
operator|->
name|hc_next
operator|=
name|hc
expr_stmt|;
name|sc
operator|->
name|hdh_sioq
operator|.
name|sioq_tail
operator|=
name|hc
expr_stmt|;
name|hc
operator|->
name|hc_next
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* start i/o on channel now */
name|sc
operator|->
name|hdh_sioq
operator|.
name|sioq_head
operator|=
name|hc
expr_stmt|;
name|sc
operator|->
name|hdh_sioq
operator|.
name|sioq_tail
operator|=
name|hc
expr_stmt|;
name|hc
operator|->
name|hc_next
operator|=
literal|0
expr_stmt|;
name|start_chn
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|start_chn
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hdh_softc
modifier|*
name|sc
init|=
operator|&
name|hdh_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hdh_chan
modifier|*
name|hc
init|=
name|sc
operator|->
name|hdh_sioq
operator|.
name|sioq_head
decl_stmt|;
specifier|register
name|struct
name|hdhregs
modifier|*
name|addr
init|=
operator|(
expr|struct
name|hdhregs
operator|*
operator|)
name|hdhinfo
index|[
name|unit
index|]
operator|->
name|ui_addr
decl_stmt|;
comment|/* 	 * Set up comm regs. 	 */
name|addr
operator|->
name|iochn
operator|=
name|hc
operator|->
name|hc_chan
expr_stmt|;
name|addr
operator|->
name|ioadx
operator|=
name|hc
operator|->
name|hc_adx
expr_stmt|;
name|addr
operator|->
name|ioadl
operator|=
name|hc
operator|->
name|hc_addr
expr_stmt|;
name|addr
operator|->
name|iocnt
operator|=
name|hc
operator|->
name|hc_cnt
expr_stmt|;
name|addr
operator|->
name|iofcn
operator|=
name|hc
operator|->
name|hc_func
expr_stmt|;
name|addr
operator|->
name|iosbf
operator|=
name|hc
operator|->
name|hc_sbfc
expr_stmt|;
name|addr
operator|->
name|ioini
operator|=
literal|1
expr_stmt|;
comment|/* signal UMC if necessary */
if|if
condition|(
operator|!
operator|(
name|addr
operator|->
name|ionmi
operator|)
condition|)
block|{
name|addr
operator|->
name|ionmi
operator|=
literal|1
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
name|HDH_DMA
operator||
name|HDH_WRT
operator||
name|HDH_IEN
operator||
name|HDH_NMI
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * IF-11/HDH interrupt handler  */
end_comment

begin_macro
name|hdhintr
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hdh_softc
modifier|*
name|sc
init|=
operator|&
name|hdh_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hdh_chan
modifier|*
name|hc
decl_stmt|;
specifier|register
name|struct
name|hdhregs
modifier|*
name|addr
init|=
operator|(
expr|struct
name|hdhregs
operator|*
operator|)
name|hdhinfo
index|[
name|unit
index|]
operator|->
name|ui_addr
decl_stmt|;
name|int
name|lcn
decl_stmt|,
name|type
decl_stmt|,
name|cc
decl_stmt|,
name|cnt
decl_stmt|;
comment|/* 	 * Check for hardware errors. 	 */
if|if
condition|(
name|addr
operator|->
name|csr
operator|&
name|HDH_UER
condition|)
block|{
name|printf
argument_list|(
literal|"hdh%d: hard error csr=%b\n"
argument_list|,
name|unit
argument_list|,
name|addr
operator|->
name|csr
argument_list|,
name|HDH_BITS
argument_list|)
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
literal|0
expr_stmt|;
comment|/* disable i/f */
return|return;
block|}
comment|/* 	 * Get logical channel info. 	 */
if|if
condition|(
operator|(
name|lcn
operator|=
name|addr
operator|->
name|stachn
operator|)
operator|>=
operator|(
name|NHDHCH
operator|*
literal|2
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"hdh%d: unknown channel lcn=%d\n"
argument_list|,
name|unit
argument_list|,
name|lcn
argument_list|)
expr_stmt|;
return|return;
block|}
name|hc
operator|=
operator|&
name|sc
operator|->
name|hdh_chan
index|[
name|lcn
index|]
expr_stmt|;
name|type
operator|=
name|addr
operator|->
name|statyp
expr_stmt|;
name|cc
operator|=
name|addr
operator|->
name|stacc
expr_stmt|;
name|cnt
operator|=
name|hc
operator|->
name|hc_cnt
operator|-
name|addr
operator|->
name|stacnt
expr_stmt|;
comment|/* Figure out what kind of interrupt it was */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HDHSACK
case|:
comment|/* start i/o accepted */
if|if
condition|(
name|hc
operator|!=
name|sc
operator|->
name|hdh_sioq
operator|.
name|sioq_head
condition|)
block|{
name|printf
argument_list|(
literal|"hdh%d: STARTIO error lcn=%d hc=%x sq=%x\n"
argument_list|,
name|unit
argument_list|,
name|lcn
argument_list|,
name|hc
argument_list|,
name|sc
operator|->
name|hdh_sioq
operator|.
name|sioq_head
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* try to start any queued i/o request */
if|if
condition|(
name|sc
operator|->
name|hdh_sioq
operator|.
name|sioq_head
operator|=
name|sc
operator|->
name|hdh_sioq
operator|.
name|sioq_head
operator|->
name|hc_next
condition|)
block|{
name|start_chn
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HDHDONE
case|:
comment|/* i/o completion */
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
name|HDHIOCABT
case|:
name|printf
argument_list|(
literal|"hdh%d: I/O abort "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|daterr
goto|;
case|case
name|HDHIOCERR
case|:
name|printf
argument_list|(
literal|"hdh%d: program error "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|daterr
goto|;
case|case
name|HDHIOCOVR
case|:
name|printf
argument_list|(
literal|"hdh%d: overrun error "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|daterr
goto|;
case|case
name|HDHIOCUBE
case|:
name|printf
argument_list|(
literal|"hdh%d: NXM timeout or UB parity error "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|daterr
label|:
name|printf
argument_list|(
literal|"lcn=%d func=%x\n"
argument_list|,
name|lcn
argument_list|,
name|hc
operator|->
name|hc_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|hc
operator|->
name|hc_func
operator|&
name|HDHRDB
condition|)
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
else|else
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
name|hc
operator|->
name|hc_flags
operator|&=
operator|~
name|HCBUSY
expr_stmt|;
comment|/* was it supervisor or data traffic? */
if|if
condition|(
name|lcn
operator|>
name|HDHSUPW
condition|)
name|hdh_data
argument_list|(
name|unit
argument_list|,
name|lcn
argument_list|,
name|cc
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
name|hdh_supr
argument_list|(
name|unit
argument_list|,
name|lcn
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Ack the interrupt 	 */
name|addr
operator|->
name|staack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|addr
operator|->
name|ionmi
operator|)
condition|)
block|{
name|addr
operator|->
name|ionmi
operator|=
literal|1
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
name|HDH_DMA
operator||
name|HDH_WRT
operator||
name|HDH_IEN
operator||
name|HDH_NMI
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * data channel interrupt completion handler  */
end_comment

begin_macro
name|hdh_data
argument_list|(
argument|unit
argument_list|,
argument|lcn
argument_list|,
argument|cc
argument_list|,
argument|rcnt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|lcn
decl_stmt|,
name|cc
decl_stmt|,
name|rcnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hdh_softc
modifier|*
name|sc
init|=
operator|&
name|hdh_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hdh_chan
modifier|*
name|hc
init|=
operator|&
name|sc
operator|->
name|hdh_chan
index|[
name|lcn
index|]
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* was it read or write? */
if|if
condition|(
name|hc
operator|->
name|hc_func
operator|&
name|HDHRDB
condition|)
block|{
if|if
condition|(
name|cc
operator|==
name|HDHIOCOK
condition|)
block|{
comment|/* 			 * Queue good packet for input  			 */
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|m
operator|=
name|if_rubaget
argument_list|(
operator|&
name|sc
operator|->
name|hdh_ifuba
index|[
name|lcn
operator|>>
literal|1
index|]
argument_list|,
name|rcnt
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_if
argument_list|)
expr_stmt|;
name|impinput
argument_list|(
name|unit
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* hang a new data read */
name|hdh_iorq
argument_list|(
name|unit
argument_list|,
name|lcn
argument_list|,
name|IMP_RCVBUF
argument_list|,
name|HDHRDB
operator|+
name|HDHSTR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * fire up next output 		 */
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|hdh_imp
operator|->
name|imp_cb
operator|.
name|ic_oactive
operator|=
literal|0
expr_stmt|;
name|impstart
argument_list|(
name|sc
operator|->
name|hdh_imp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * supervisor channel interrupt completion handler  */
end_comment

begin_macro
name|hdh_supr
argument_list|(
argument|unit
argument_list|,
argument|lcn
argument_list|,
argument|cc
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|lcn
decl_stmt|,
name|cc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hdh_softc
modifier|*
name|sc
init|=
operator|&
name|hdh_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hdh_chan
modifier|*
name|hc
init|=
operator|&
name|sc
operator|->
name|hdh_chan
index|[
name|lcn
index|]
decl_stmt|;
name|short
modifier|*
name|p
decl_stmt|;
comment|/* was it read or write? */
if|if
condition|(
name|hc
operator|->
name|hc_func
operator|&
name|HDHRDB
condition|)
block|{
if|if
condition|(
name|cc
operator|==
name|HDHIOCOK
condition|)
block|{
name|p
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|sc
operator|->
name|hdh_ifuba
index|[
name|lcn
operator|>>
literal|1
index|]
operator|.
name|ifu_r
operator|.
name|ifrw_addr
operator|)
expr_stmt|;
comment|/* figure out what kind of supervisor message */
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
name|HDHIACK
case|:
case|case
name|HDHLNACK
case|:
break|break;
case|case
name|HDHLNUP
case|:
name|printf
argument_list|(
literal|"hdh%d: LINE UP\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hdh_flags
operator||=
name|HDH_UP
expr_stmt|;
name|impstart
argument_list|(
name|sc
operator|->
name|hdh_imp
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDHLNDN
case|:
if|if
condition|(
name|sc
operator|->
name|hdh_flags
operator|&
name|HDH_UP
condition|)
name|printf
argument_list|(
literal|"hdh%d: LINE DOWN\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hdh_flags
operator|&=
operator|~
name|HDH_UP
expr_stmt|;
break|break;
case|case
name|HDHLOOP
case|:
break|break;
case|case
name|HDHSQERR
case|:
name|printf
argument_list|(
literal|"hdh%d: HOST SEQUENCE ERROR\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDHSQRCV
case|:
name|printf
argument_list|(
literal|"hdh%d: IMP SEQUENCE ERROR\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDHDTERR
case|:
name|printf
argument_list|(
literal|"hdh%d: HOST DATA ERROR\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDHTIMO
case|:
name|printf
argument_list|(
literal|"hdh%d: TIMEOUT\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"hdh%d: supervisor error, code=%x\n"
argument_list|,
name|unit
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* hang a new supr read */
name|hdh_iorq
argument_list|(
name|unit
argument_list|,
name|HDHSUPR
argument_list|,
name|IMP_RCVBUF
argument_list|,
name|HDHRDB
operator|+
name|HDHSTR
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|snd_supr
argument_list|(
argument|unit
argument_list|,
argument|msg
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hdh_softc
modifier|*
name|sc
init|=
operator|&
name|hdh_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"hdh%d: cannot get supervisor cmnd buffer\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|cnt
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|msg
operator|++
expr_stmt|;
name|cnt
operator|=
name|if_wubaput
argument_list|(
operator|&
name|sc
operator|->
name|hdh_ifuba
index|[
name|SUPR
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|hdh_iorq
argument_list|(
name|unit
argument_list|,
name|HDHSUPW
argument_list|,
name|cnt
argument_list|,
name|HDHWRT
operator|+
name|HDHEOS
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|NHDH
end_endif

end_unit

