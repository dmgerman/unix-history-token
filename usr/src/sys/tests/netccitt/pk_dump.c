begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1991 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1988, 1991 The Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)pk_dump.c	7.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * This is a kernel debugging aid.  * dumps out a cache of mbufs.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/x25.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk_var.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*   *  This procedure decodes the X.25 level 3 packet returning a   *  code to be used in switchs or arrays.  */
end_comment

begin_expr_stmt
name|pk_decode
argument_list|(
name|xp
argument_list|)
specifier|register
expr|struct
name|x25_packet
operator|*
name|xp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|type
decl_stmt|;
if|if
condition|(
name|xp
operator|->
name|fmt_identifier
operator|!=
literal|1
condition|)
return|return
operator|(
name|INVALID_PACKET
operator|)
return|;
ifdef|#
directive|ifdef
name|ancient_history
comment|/*  	 *  Make sure that the logical channel group number is 0. 	 *  This restriction may be removed at some later date. 	 */
if|if
condition|(
name|xp
operator|->
name|lc_group_number
operator|!=
literal|0
condition|)
return|return
operator|(
name|INVALID_PACKET
operator|)
return|;
endif|#
directive|endif
comment|/*  	 *  Test for data packet first. 	 */
if|if
condition|(
operator|!
operator|(
name|xp
operator|->
name|packet_type
operator|&
name|DATA_PACKET_DESIGNATOR
operator|)
condition|)
return|return
operator|(
name|DATA
operator|)
return|;
comment|/*  	 *  Test if flow control packet (RR or RNR). 	 */
if|if
condition|(
operator|!
operator|(
name|xp
operator|->
name|packet_type
operator|&
name|RR_OR_RNR_PACKET_DESIGNATOR
operator|)
condition|)
switch|switch
condition|(
name|xp
operator|->
name|packet_type
operator|&
literal|0x1f
condition|)
block|{
case|case
name|X25_RR
case|:
return|return
operator|(
name|RR
operator|)
return|;
case|case
name|X25_RNR
case|:
return|return
operator|(
name|RNR
operator|)
return|;
case|case
name|X25_REJECT
case|:
return|return
operator|(
name|REJECT
operator|)
return|;
block|}
comment|/*  	 *  Determine the rest of the packet types. 	 */
switch|switch
condition|(
name|xp
operator|->
name|packet_type
condition|)
block|{
case|case
name|X25_CALL
case|:
name|type
operator|=
name|CALL
expr_stmt|;
break|break;
case|case
name|X25_CALL_ACCEPTED
case|:
name|type
operator|=
name|CALL_ACCEPTED
expr_stmt|;
break|break;
case|case
name|X25_CLEAR
case|:
name|type
operator|=
name|CLEAR
expr_stmt|;
break|break;
case|case
name|X25_CLEAR_CONFIRM
case|:
name|type
operator|=
name|CLEAR_CONF
expr_stmt|;
break|break;
case|case
name|X25_INTERRUPT
case|:
name|type
operator|=
name|INTERRUPT
expr_stmt|;
break|break;
case|case
name|X25_INTERRUPT_CONFIRM
case|:
name|type
operator|=
name|INTERRUPT_CONF
expr_stmt|;
break|break;
case|case
name|X25_RESET
case|:
name|type
operator|=
name|RESET
expr_stmt|;
break|break;
case|case
name|X25_RESET_CONFIRM
case|:
name|type
operator|=
name|RESET_CONF
expr_stmt|;
break|break;
case|case
name|X25_RESTART
case|:
name|type
operator|=
name|RESTART
expr_stmt|;
break|break;
case|case
name|X25_RESTART_CONFIRM
case|:
name|type
operator|=
name|RESTART_CONF
expr_stmt|;
break|break;
case|case
name|X25_DIAGNOSTIC
case|:
name|type
operator|=
name|DIAG_TYPE
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|INVALID_PACKET
expr_stmt|;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|pk_state
index|[]
init|=
block|{
literal|"Listen"
block|,
literal|"Ready"
block|,
literal|"Received-Call"
block|,
literal|"Sent-Call"
block|,
literal|"Data-Transfer"
block|,
literal|"Received-Clear"
block|,
literal|"Sent-Clear"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pk_name
index|[]
init|=
block|{
literal|"Call"
block|,
literal|"Call-Conf"
block|,
literal|"Clear"
block|,
literal|"Clear-Conf"
block|,
literal|"Data"
block|,
literal|"Intr"
block|,
literal|"Intr-Conf"
block|,
literal|"Rr"
block|,
literal|"Rnr"
block|,
literal|"Reset"
block|,
literal|"Reset-Conf"
block|,
literal|"Restart"
block|,
literal|"Restart-Conf"
block|,
literal|"Reject"
block|,
literal|"Diagnostic"
block|,
literal|"Invalid"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pk_lengths
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|pk_trace
argument_list|(
name|m
argument_list|,
name|dir
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|x25_packet
modifier|*
name|xp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|x25_packet
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
name|i
operator|=
name|pk_decode
argument_list|(
name|xp
argument_list|)
operator|/
name|MAXSTATES
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|pk_lengths
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|len
operator|=
name|m
operator|->
name|m_len
operator|)
condition|)
if|if
condition|(
name|len
operator|>
literal|5
condition|)
name|len
operator|=
literal|5
expr_stmt|;
name|printf
argument_list|(
literal|"%s LCN=%d: %s ("
argument_list|,
name|dir
argument_list|,
name|LCN
argument_list|(
name|xp
argument_list|)
argument_list|,
name|pk_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|xp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
operator|,
operator|++
name|s
control|)
name|printf
argument_list|(
literal|"%x "
argument_list|,
operator|(
name|int
operator|)
operator|*
name|s
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|bprintf
argument_list|(
name|fp
argument_list|,
name|b
argument_list|,
name|s
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|u_char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|gotsome
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|i
operator|=
operator|*
name|s
operator|++
condition|)
block|{
if|if
condition|(
name|b
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|gotsome
operator|==
literal|0
condition|)
name|i
operator|=
literal|'<'
expr_stmt|;
else|else
name|i
operator|=
literal|','
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|i
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|gotsome
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
operator|(
name|i
operator|=
operator|*
name|s
operator|)
operator|>
literal|32
condition|;
name|s
operator|++
control|)
operator|(
name|void
operator|)
name|putc
argument_list|(
name|i
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|s
operator|>
literal|32
condition|)
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|gotsome
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'>'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* so you can adb -w the binary */
end_comment

begin_decl_stmt
name|int
name|tflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Iflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Aflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|vmunix
init|=
name|_PATH_UNIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|kmemf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
block|{
literal|"_pk_output_cache"
block|}
block|,
block|{
literal|"_pk_input_cache"
block|}
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
if|if
condition|(
name|kvm_openfiles
argument_list|(
name|vmunix
argument_list|,
name|kmemf
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"netstat: kvm_openfiles: %s\n"
argument_list|,
name|kvm_geterr
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kvm_nlist
argument_list|(
name|nl
argument_list|)
operator|<
literal|0
operator|||
name|nl
index|[
literal|0
index|]
operator|.
name|n_type
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no namelist\n"
argument_list|,
name|vmunix
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mbuf_cache_dump
argument_list|(
name|nl
argument_list|)
expr_stmt|;
name|mbuf_cache_dump
argument_list|(
name|nl
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|mbuf_cache
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|mbvec
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|kget
parameter_list|(
name|p
parameter_list|,
name|d
parameter_list|)
define|\
value|(kvm_read((void *)(p),&(d), sizeof (d)))
end_define

begin_macro
name|mbuf_cache_dump
argument_list|(
argument|nl
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|nl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|unsigned
name|cache_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Dumping %s:\n"
argument_list|,
name|nl
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|kget
argument_list|(
name|nl
operator|->
name|n_value
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache_size
operator|=
name|c
operator|.
name|mbc_size
operator|*
sizeof|sizeof
argument_list|(
name|m
argument_list|)
condition|)
name|mbvec
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|cache_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbvec
operator|==
literal|0
operator|||
name|c
operator|.
name|mbc_cache
operator|==
literal|0
condition|)
return|return;
name|kvm_read
argument_list|(
name|c
operator|.
name|mbc_cache
argument_list|,
name|mbvec
argument_list|,
name|cache_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|c
operator|.
name|mbc_num
init|;
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
name|c
operator|.
name|mbc_size
expr_stmt|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|m
operator|=
name|mbvec
index|[
name|i
index|]
condition|)
name|mbuf_dump
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|c
operator|.
name|mbc_num
condition|)
break|break;
block|}
block|}
end_block

begin_expr_stmt
name|mbuf_dump
argument_list|(
name|m
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|virgin
init|=
literal|1
decl_stmt|;
specifier|register
name|struct
name|x25_packet
modifier|*
name|xp
decl_stmt|;
name|struct
name|mbuf
name|n
decl_stmt|;
name|char
name|extbuf
index|[
literal|1024
index|]
decl_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|n
operator|.
name|m_next
control|)
block|{
name|kget
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"m %x"
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|.
name|m_flags
condition|)
block|{
name|printf
argument_list|(
literal|" flags "
argument_list|)
expr_stmt|;
name|bprintf
argument_list|(
name|stdout
argument_list|,
name|n
operator|.
name|m_flags
argument_list|,
literal|"\1M_EXT\2M_PKTHDR\3M_EOR\4M_BCAST\5M_MCAST"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Aflag
condition|)
name|printf
argument_list|(
literal|" chained %x"
argument_list|,
name|n
operator|.
name|m_nextpkt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" next %x len %d"
argument_list|,
name|n
operator|.
name|m_next
argument_list|,
name|n
operator|.
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|.
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|printf
argument_list|(
literal|" total %d"
argument_list|,
name|n
operator|.
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|Iflag
condition|)
name|printf
argument_list|(
literal|" rcvif %x"
argument_list|,
name|n
operator|.
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|.
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|kvm_read
argument_list|(
name|n
operator|.
name|m_ext
operator|.
name|ext_buf
argument_list|,
name|extbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|extbuf
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|.
name|m_data
operator|=
name|extbuf
operator|+
operator|(
name|n
operator|.
name|m_data
operator|-
name|n
operator|.
name|m_ext
operator|.
name|ext_buf
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|.
name|m_data
operator|<
name|m
operator|->
name|m_dat
operator|+
name|MLEN
condition|)
name|n
operator|.
name|m_data
operator|=
name|n
operator|.
name|m_dat
operator|+
operator|(
name|n
operator|.
name|m_data
operator|-
name|m
operator|->
name|m_dat
operator|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"mbuf screwup\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|virgin
condition|)
block|{
name|virgin
operator|=
literal|0
expr_stmt|;
name|pk_trace
argument_list|(
operator|&
name|n
argument_list|,
literal|"  X.25: "
argument_list|)
expr_stmt|;
block|}
name|dumpit
argument_list|(
literal|"data: "
argument_list|,
name|n
operator|.
name|m_data
argument_list|,
name|n
operator|.
name|m_len
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|dumpit
argument_list|(
argument|what
argument_list|,
argument|where
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|what
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|short
modifier|*
name|s
init|=
name|where
decl_stmt|;
name|unsigned
name|short
modifier|*
name|z
init|=
name|where
operator|+
operator|(
name|n
operator|+
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|verbose
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
name|what
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|z
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%x "
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|&
literal|15
operator|)
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&
literal|15
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

