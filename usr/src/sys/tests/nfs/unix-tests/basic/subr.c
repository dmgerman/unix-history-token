begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	@(#)subr.c	1.3 90/01/03 NFS Rev 2 Testsuite  * 	1.6 Lachman ONC Test Suite source  *  * Useful subroutines shared by all tests  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|major
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SVR3
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/nfs/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"tests.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|Myname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Build a directory tree "lev" levels deep  * with "files" number of files in each directory  * and "dirs" fan out.  Starts at the current directory.  * "fname" and "dname" are the base of the names used for  * files and directories.  */
end_comment

begin_macro
name|dirtree
argument_list|(
argument|lev
argument_list|,
argument|files
argument_list|,
argument|dirs
argument_list|,
argument|fname
argument_list|,
argument|dname
argument_list|,
argument|totfiles
argument_list|,
argument|totdirs
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dirs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|totfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|totdirs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|int
name|f
decl_stmt|,
name|d
decl_stmt|;
name|char
name|name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|lev
operator|--
operator|==
literal|0
condition|)
block|{
return|return;
block|}
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|files
condition|;
name|f
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%d"
argument_list|,
name|fname
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|name
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"creat %s failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|totfiles
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"close %d failed"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|dirs
condition|;
name|d
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%d"
argument_list|,
name|dname
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"mkdir %s failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|totdirs
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"chdir %s failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dirtree
argument_list|(
name|lev
argument_list|,
name|files
argument_list|,
name|dirs
argument_list|,
name|fname
argument_list|,
name|dname
argument_list|,
name|totfiles
argument_list|,
name|totdirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|".."
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"chdir .. failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Remove a directory tree starting at the current directory.  * "fname" and "dname" are the base of the names used for  * files and directories to be removed - don't remove anything else!  * "files" and "dirs" are used with fname and dname to generate  * the file names to remove.  *  * This routine will fail if, say after removing known files,  * the directory is not empty.  *  * This is used to test the unlink function and to clean up after tests.  */
end_comment

begin_macro
name|rmdirtree
argument_list|(
argument|lev
argument_list|,
argument|files
argument_list|,
argument|dirs
argument_list|,
argument|fname
argument_list|,
argument|dname
argument_list|,
argument|totfiles
argument_list|,
argument|totdirs
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dirs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|totfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total removed */
end_comment

begin_decl_stmt
name|int
modifier|*
name|totdirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total removed */
end_comment

begin_decl_stmt
name|int
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|f
decl_stmt|,
name|d
decl_stmt|;
name|char
name|name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|lev
operator|--
operator|==
literal|0
condition|)
block|{
return|return;
block|}
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|files
condition|;
name|f
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%d"
argument_list|,
name|fname
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|ignore
condition|)
block|{
name|error
argument_list|(
literal|"unlink %s failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|totfiles
operator|)
operator|++
expr_stmt|;
block|}
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|dirs
condition|;
name|d
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%d"
argument_list|,
name|dname
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ignore
condition|)
continue|continue;
name|error
argument_list|(
literal|"chdir %s failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rmdirtree
argument_list|(
name|lev
argument_list|,
name|files
argument_list|,
name|dirs
argument_list|,
name|fname
argument_list|,
name|dname
argument_list|,
name|totfiles
argument_list|,
name|totdirs
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|".."
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"chdir .. failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rmdir
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"rmdir %s failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|totdirs
operator|)
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|error
argument_list|(
argument|str
argument_list|,
argument|ar1
argument_list|,
argument|ar2
argument_list|,
argument|ar3
argument_list|,
argument|ar4
argument_list|,
argument|ar5
argument_list|,
argument|ar6
argument_list|,
argument|ar7
argument_list|,
argument|ar8
argument_list|,
argument|ar9
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|SVR3
name|char
modifier|*
name|ret
decl_stmt|,
modifier|*
name|getcwd
argument_list|()
decl_stmt|,
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|ret
decl_stmt|,
modifier|*
name|getwd
argument_list|()
decl_stmt|,
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SVR3
if|if
condition|(
operator|(
name|ret
operator|=
name|getcwd
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: getcwd failed\n"
argument_list|,
name|Myname
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s: (%s) "
argument_list|,
name|Myname
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|ret
operator|=
name|getwd
argument_list|(
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: getwd failed\n"
argument_list|,
name|Myname
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s: (%s) "
argument_list|,
name|Myname
argument_list|,
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|str
argument_list|,
name|ar1
argument_list|,
name|ar2
argument_list|,
name|ar3
argument_list|,
name|ar4
argument_list|,
name|ar5
argument_list|,
name|ar6
argument_list|,
name|ar7
argument_list|,
name|ar8
argument_list|,
name|ar9
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|ts
decl_stmt|,
name|te
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * save current time in struct ts  */
end_comment

begin_macro
name|starttime
argument_list|()
end_macro

begin_block
block|{
name|gettimeofday
argument_list|(
operator|&
name|ts
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * sets the struct tv to the difference in time between  * current time and the time in struct ts.  */
end_comment

begin_macro
name|endtime
argument_list|(
argument|tv
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|gettimeofday
argument_list|(
operator|&
name|te
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|.
name|tv_usec
operator|<
name|ts
operator|.
name|tv_usec
condition|)
block|{
name|te
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|te
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
name|tv
operator|->
name|tv_usec
operator|=
name|te
operator|.
name|tv_usec
operator|-
name|ts
operator|.
name|tv_usec
expr_stmt|;
name|tv
operator|->
name|tv_sec
operator|=
name|te
operator|.
name|tv_sec
operator|-
name|ts
operator|.
name|tv_sec
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set up and move to a test directory  */
end_comment

begin_macro
name|testdir
argument_list|(
argument|dir
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|statb
decl_stmt|;
name|char
name|str
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
comment|/* 	 *  If dir is non-NULL, use that dir.  If NULL, first 	 *  check for env variable NFSTESTDIR.  If that is not 	 *  set, use the compiled-in TESTDIR. 	 */
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|dir
operator|=
name|getenv
argument_list|(
literal|"NFSTESTDIR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dir
operator|=
name|TESTDIR
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dir
argument_list|,
operator|&
name|statb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"rm -r %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|str
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"can't remove old test directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mkdir
argument_list|(
name|dir
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"can't create test directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"can't chdir to test directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Move to a test directory  */
end_comment

begin_macro
name|mtestdir
argument_list|(
argument|dir
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|statb
decl_stmt|;
name|char
name|str
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
comment|/* 	 *  If dir is non-NULL, use that dir.  If NULL, first 	 *  check for env variable NFSTESTDIR.  If that is not 	 *  set, use the compiled-in TESTDIR. 	 */
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|dir
operator|=
name|getenv
argument_list|(
literal|"NFSTESTDIR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dir
operator|=
name|TESTDIR
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"can't chdir to test directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  get parameter at parm, convert to int, and make sure that  *  it is at least min.  */
end_comment

begin_macro
name|getparm
argument_list|(
argument|parm
argument_list|,
argument|minimum
argument_list|,
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|parm
decl_stmt|,
modifier|*
name|label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|minimum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|atoi
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
name|minimum
condition|)
block|{
name|error
argument_list|(
literal|"Illegal %s parameter %d, must be at least %d"
argument_list|,
name|label
argument_list|,
name|val
argument_list|,
name|minimum
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  exit point for successful test  */
end_comment

begin_macro
name|complete
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\t%s ok.\n"
argument_list|,
name|Myname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

