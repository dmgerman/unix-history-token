begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_expr_stmt
name|From
name|uucp
name|Thu
name|Jan
literal|10
literal|01
operator|:
literal|37
operator|:
literal|58
literal|1980
operator|>
name|From
name|dmr
name|Thu
name|Jan
literal|10
literal|04
operator|:
literal|25
operator|:
literal|49
literal|1980
name|remote
name|from
name|research
name|The
name|system
name|has
name|been
name|changed
name|so
name|that
end_expr_stmt

begin_if
if|if a file being executed begins with the magic characters #!
operator|,
name|the
name|rest
name|of
name|the
name|line
name|is
name|understood
name|to
name|be
name|the
name|name
name|of
name|an
name|interpreter
end_if

begin_for
for|for the executed file. Previously
control|(
name|and
name|in
name|fact
name|still
control|)
name|the
name|shell
name|did
name|much
name|of
name|this
name|job
decl_stmt|;
end_for

begin_expr_stmt
name|it
name|automatically
name|executed
name|itself
name|on
name|a
name|text
name|file
name|with
name|executable
name|mode
name|when
name|the
name|text
name|file
literal|'s name was typed as a command. Putting the facility into the system gives the following benefits.  1) It makes shell scripts more like real executable files, because they can be the subject of '
name|exec
operator|.
expr|'  2) If you do a '
name|ps
literal|' while such a command is running, its real name appears instead of '
name|sh
literal|'. Likewise, accounting is done on the basis of the real name.  3) Shell scripts can be set-user-ID.  4) It is simpler to have alternate shells available; e.g. if you like the Berkeley csh there is no question about which shell is to interpret a file.  5) It will allow other interpreters to fit in more smoothly.  To take advantage of this wonderful opportunity, put  	#! /bin/sh  at the left margin of the first line of your shell scripts. Blanks after ! are OK.  Use a complete pathname (no search is done). At the moment the whole line is restricted to 16 characters but this limit will be raised.   From uucp Thu Jan 10 01:37:49 1980>From dmr Thu Jan 10 04:23:53 1980 remote from research #include "../h/param.h" #include "../h/systm.h" #include "../h/map.h" #include "../h/dir.h" #include "../h/user.h" #include "../h/proc.h" #include "../h/buf.h" #include "../h/reg.h" #include "../h/inode.h" #include "../h/seg.h" #include "../h/acct.h"   /*  * exec system call, with and without environments.  */ struct execa { 	char	*fname; 	char	**argp; 	char	**envp; };  exec() { 	((struct execa *)u.u_ap)->envp = NULL; 	exece(); }  exece() { 	register nc; 	register char *cp; 	register struct buf *bp; 	register struct execa *uap; 	int na, ne, bno, ucp, ap, c, indir, uid, gid; 	struct inode *ip;  	bno = 0; 	bp = 0; 	indir = 0; 	if ((ip = namei(uchar, 0)) == NULL) 		return; 	uid = u.u_uid; 	gid = u.u_gid; 	if (ip->i_mode&ISUID) 		uid = ip->i_uid; 	if (ip->i_mode&ISGID) 		gid = ip->i_gid; again: 	if(access(ip, IEXEC)) 		goto bad; 	if((ip->i_mode& IFMT) != IFREG || 	   (ip->i_mode& (IEXEC|(IEXEC>>3)|(IEXEC>>6))) == 0) { 		u.u_error = EACCES; 		goto bad; 	} 	/* 	 * read in first few bytes 	 * of file for segment 	 * types and sizes: 	 * ux_mag = 407/410/411/405 	 *  407 is plain executable 	 *  410 is RO text 	 *  411 is separated ID 	 *  405 is overlaid text 	 * 	 * Also, an ascii line beginning 	 * with '
operator|#
operator|!
literal|' is the file name of a shell. 	 */ 	u.u_base = (caddr_t)&u.u_exdata; 	u.u_count = sizeof(u.u_exdata); 	u.u_offset = 0; 	u.u_segflg = 1; 	readi(ip); 	u.u_segflg = 0; 	if(u.u_error) 		goto bad; 	if (u.u_count> sizeof(u.u_exdata) - sizeof(u.u_exdata.A)&& u.u_exdata.S[0] != '
operator|#
literal|') { 		u.u_error = ENOEXEC; 		goto bad; 	} 	if(u.u_exdata.A.ux_mag == 0407) 		; 	else if (u.u_exdata.A.ux_mag == 0411) 		; 	else if (u.u_exdata.A.ux_mag == 0405) 		; 	else if (u.u_exdata.A.ux_mag == 0410) 		; 	else if (u.u_exdata.S[0]=='
operator|#
literal|'&& u.u_exdata.S[1]=='
operator|!
literal|'&& indir==0) { 		cp =&u.u_exdata.S[2]; 		while (*cp=='
literal|'&& cp<&u.u_exdata.S[SHSIZ]) 			cp++; 		u.u_dirp = cp; 		while (cp<&u.u_exdata.S[SHSIZ-1]&& *cp != '
operator|\
name|n
literal|') 			cp++; 		*cp = '
operator|\
literal|0
literal|'; 		indir++; 		iput(ip); 		ip = namei(schar, 0); 		if (ip==NULL) 			return; 		goto again; 	} else { 		u.u_error = ENOEXEC; 		goto bad; 	} 	/* 	 * Collect arguments on "file" in swap space. 	 */ 	na = 0; 	ne = 0; 	nc = 0; 	uap = (struct execa *)u.u_ap; 	while ((bno = malloc(argmap,(NCARGS+BSIZE-1)/BSIZE)) == 0) 		sleep((caddr_t)&argmap, PRIBIO); 	if (uap->argp) for (;;) { 		ap = NULL; 		if (indir&& na==1) 			ap = uap->fname; 		else if (uap->argp) { 			ap = fuword((caddr_t)uap->argp); 			uap->argp++; 		} 		if (ap==NULL&& uap->envp) { 			uap->argp = NULL; 			if ((ap = fuword((caddr_t)uap->envp)) == NULL) 				break; 			uap->envp++; 			ne++; 		} 		if (ap==NULL) 			break; 		na++; 		if(ap == -1) 			u.u_error = EFAULT; 		do { 			if (nc>= NCARGS-1) 				u.u_error = E2BIG; 			if ((c = fubyte((caddr_t)ap++))< 0) 				u.u_error = EFAULT; 			if (u.u_error) 				goto bad; 			if ((nc&BMASK) == 0) { 				if (bp) 					bawrite(bp); 				bp = getblk(swapdev, swplo+bno+(nc>>BSHIFT)); 				cp = bp->b_un.b_addr; 			} 			nc++; 			*cp++ = c; 		} while (c>0); 	} 	if (bp) 		bawrite(bp); 	bp = 0; 	nc = (nc + NBPW-1)& ~(NBPW-1); 	getxfile(ip, nc, uid, gid); 	if (u.u_error || u.u_exdata.A.ux_mag==0405) 		goto bad;  	/* 	 * copy back arglist 	 */ 	ucp = -nc - NBPW; 	ap = ucp - na*NBPW - 3*NBPW; 	u.u_ar0[R6] = ap; 	suword((caddr_t)ap, na-ne); 	nc = 0; 	for (;;) { 		ap += NBPW; 		if (na==ne) { 			suword((caddr_t)ap, 0); 			ap += NBPW; 		} 		if (--na< 0) 			break; 		suword((caddr_t)ap, ucp); 		do { 			if ((nc&BMASK) == 0) { 				if (bp) 					brelse(bp); 				bp = bread(swapdev, swplo+bno+(nc>>BSHIFT)); 				bp->b_flags&= ~B_DELWRI; 				cp = bp->b_un.b_addr; 				if (nc==0&& indir) 					bcopy(cp, (caddr_t)u.u_dbuf, DIRSIZ); 			} 			subyte((caddr_t)ucp++, (c = *cp++)); 			nc++; 		} while(c&0377); 	} 	suword((caddr_t)ap, 0); 	suword((caddr_t)ucp, 0); 	setregs(); bad: 	if (bp) 		brelse(bp); 	if(bno) { 		mfree(argmap, (NCARGS+BSIZE-1)/BSIZE, bno); 		wakeup((caddr_t)&argmap); 	} 	iput(ip); }  /*  * Read in and set up memory for executed file.  */ getxfile(ip, nargc, uid, gid) register struct inode *ip; { 	register unsigned ds; 	register sep; 	register unsigned ts, ss; 	int i; 	long lsize;  	sep = 0; 	if(u.u_exdata.A.ux_mag == 0407) { 		lsize = (long)u.u_exdata.A.ux_dsize + u.u_exdata.A.ux_tsize; 		u.u_exdata.A.ux_dsize = lsize; 		if (lsize != u.u_exdata.A.ux_dsize) {	/* check overflow */ 			u.u_error = ENOMEM; 			return; 		} 		u.u_exdata.A.ux_tsize = 0; 	} else if (u.u_exdata.A.ux_mag == 0411) 		sep++; 	if(u.u_exdata.A.ux_tsize!=0&& (ip->i_flag&ITEXT)==0&& ip->i_count!=1) { 		u.u_error = ETXTBSY; 		return; 	}  	/* 	 * find text and data sizes 	 * try them out for possible 	 * overflow of max sizes 	 */ 	ts = btoc(u.u_exdata.A.ux_tsize); 	lsize = (long)u.u_exdata.A.ux_dsize + u.u_exdata.A.ux_bsize; 	if (lsize != (unsigned)lsize) { 		u.u_error = ENOMEM; 		return; 	} 	ds = btoc(lsize); 	ss = SSIZE + btoc(nargc); 	if (u.u_exdata.A.ux_mag==0405) { 		if (u.u_sep==0&& ctos(ts) != ctos(u.u_tsize) || nargc) { 			u.u_error = ENOMEM; 			return; 		} 		ds = u.u_dsize; 		ss = u.u_ssize; 		sep = u.u_sep; 		xfree(); 		xalloc(ip); 		u.u_ar0[PC] = u.u_exdata.A.ux_entloc& ~01; 	} else { 		if(estabur(ts, ds, ss, sep, RO)) 			return; 	 		/* 		 * allocate and clear core 		 * at this point, committed 		 * to the new image 		 */ 		u.u_prof.pr_scale = 0; 		xfree(); 		i = USIZE+ds+ss; 		expand(i); 		while(--i>= USIZE) 			clearseg(u.u_procp->p_addr+i); 		xalloc(ip); 	 		/* 		 * read in data segment 		 */ 		estabur((unsigned)0, ds, (unsigned)0, 0, RO); 		u.u_base = 0; 		u.u_offset = sizeof(u.u_exdata.A)+u.u_exdata.A.ux_tsize; 		u.u_count = u.u_exdata.A.ux_dsize; 		readi(ip); 		/* 		 * set SUID/SGID protections, if no tracing 		 */ 		if ((u.u_procp->p_flag&STRC)==0) { 			u.u_uid = uid; 			u.u_gid = gid; 		} else 			psignal(u.u_procp, SIGTRC); 	} 	u.u_tsize = ts; 	u.u_dsize = ds; 	u.u_ssize = ss; 	u.u_sep = sep; 	estabur(ts, ds, ss, sep, RO); }  /*  * Clear registers on exec  */ setregs() { 	register int *rp; 	register char *cp; 	register i;  	for(rp =&u.u_signal[0]; rp<&u.u_signal[NSIG]; rp++) 		if((*rp& 1) == 0) 			*rp = 0; 	for(cp =&regloc[0]; cp<&regloc[6];) 		u.u_ar0[*cp++] = 0; 	u.u_ar0[PC] = u.u_exdata.A.ux_entloc& ~01; 	for(rp = (int *)&u.u_fps; rp< (int *)&u.u_fps.u_fpregs[6];) 		*rp++ = 0; 	for(i=0; i<NOFILE; i++) { 		if (u.u_pofile[i]&EXCLOSE) { 			closef(u.u_ofile[i]); 			u.u_ofile[i] = NULL; 			u.u_pofile[i]&= ~EXCLOSE; 		} 	} 	/* 	 * Remember file name for accounting. 	 */ 	u.u_acflag&= ~AFORK; 	bcopy((caddr_t)u.u_dbuf, (caddr_t)u.u_comm, DIRSIZ); }  /*  * exit system call:  * pass back caller'
name|s
name|arg
operator|*
operator|/
name|rexit
argument_list|()
block|{
specifier|register
expr|struct
name|a
block|{
name|int
name|rval
block|; 	}
operator|*
name|uap
block|;
name|uap
operator|=
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
block|;
name|exit
argument_list|(
operator|(
name|uap
operator|->
name|rval
operator|&
literal|0377
operator|)
operator|<<
literal|8
argument_list|)
block|; }
comment|/*  * Release resources.  * Save u. area for parent to look at.  * Enter zombie state.  * Wake up parent and init processes,  * and dispose of children.  */
name|exit
argument_list|(
argument|rv
argument_list|)
block|{
specifier|register
name|int
name|i
block|;
specifier|register
expr|struct
name|proc
operator|*
name|p
block|,
operator|*
name|q
block|;
specifier|register
expr|struct
name|file
operator|*
name|f
block|;
name|p
operator|=
name|u
operator|.
name|u_procp
block|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
operator|(
name|STRC
operator||
name|SULOCK
operator|)
block|;
name|p
operator|->
name|p_clktim
operator|=
literal|0
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
name|u
operator|.
name|u_signal
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOFILE
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|u
operator|.
name|u_ofile
index|[
name|i
index|]
expr_stmt|;
name|u
operator|.
name|u_ofile
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|closef
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|plock
argument_list|(
name|u
operator|.
name|u_cdir
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|iput
argument_list|(
name|u
operator|.
name|u_cdir
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|u
operator|.
name|u_rdir
condition|)
block|{
name|plock
argument_list|(
name|u
operator|.
name|u_rdir
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|u
operator|.
name|u_rdir
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|xfree
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|acct
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mfree
argument_list|(
name|coremap
argument_list|,
name|p
operator|->
name|p_size
argument_list|,
name|p
operator|->
name|p_addr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|p
operator|->
name|p_stat
operator|=
name|SZOMB
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
operator|(
expr|struct
name|xproc
operator|*
operator|)
name|p
operator|)
operator|->
name|xp_xstat
operator|=
name|rv
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
operator|(
expr|struct
name|xproc
operator|*
operator|)
name|p
operator|)
operator|->
name|xp_utime
operator|=
name|u
operator|.
name|u_cutime
operator|+
name|u
operator|.
name|u_utime
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
operator|(
expr|struct
name|xproc
operator|*
operator|)
name|p
operator|)
operator|->
name|xp_stime
operator|=
name|u
operator|.
name|u_cstime
operator|+
name|u
operator|.
name|u_stime
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|q
operator|=
operator|&
name|proc
index|[
literal|0
index|]
init|;
name|q
operator|<
operator|&
name|proc
index|[
name|NPROC
index|]
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|q
operator|->
name|p_ppid
operator|==
name|p
operator|->
name|p_pid
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|proc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|q
operator|->
name|p_ppid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|p_stat
operator|==
name|SSTOP
condition|)
name|setrun
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|q
operator|=
operator|&
name|proc
index|[
literal|0
index|]
init|;
name|q
operator|<
operator|&
name|proc
index|[
name|NPROC
index|]
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|p_ppid
operator|==
name|q
operator|->
name|p_pid
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|q
argument_list|)
expr_stmt|;
name|swtch
argument_list|()
expr_stmt|;
comment|/* no return */
block|}
end_for

begin_expr_stmt
name|swtch
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * Wait system call.  * Search for a terminated (zombie) child,  * finally lay it to rest, and collect its status.  * Look also for stopped (traced) children,  * and pass back status from them.  */
end_comment

begin_expr_stmt
unit|wait
operator|(
operator|)
block|{
specifier|register
name|f
block|;
specifier|register
expr|struct
name|proc
operator|*
name|p
block|;
name|f
operator|=
literal|0
block|;
name|loop
operator|:
for|for
control|(
name|p
operator|=
operator|&
name|proc
index|[
literal|0
index|]
init|;
name|p
operator|<
operator|&
name|proc
index|[
name|NPROC
index|]
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|p_ppid
operator|==
name|u
operator|.
name|u_procp
operator|->
name|p_pid
condition|)
block|{
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
name|SZOMB
condition|)
block|{
name|u
operator|.
name|u_r
operator|.
name|V
operator|.
name|r_val1
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|V
operator|.
name|r_val2
operator|=
operator|(
operator|(
expr|struct
name|xproc
operator|*
operator|)
name|p
operator|)
operator|->
name|xp_xstat
expr_stmt|;
name|u
operator|.
name|u_cutime
operator|+=
operator|(
operator|(
expr|struct
name|xproc
operator|*
operator|)
name|p
operator|)
operator|->
name|xp_utime
expr_stmt|;
name|u
operator|.
name|u_cstime
operator|+=
operator|(
operator|(
expr|struct
name|xproc
operator|*
operator|)
name|p
operator|)
operator|->
name|xp_stime
expr_stmt|;
name|p
operator|->
name|p_pid
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_ppid
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_pgrp
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_sig
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_flag
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_wchan
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_stat
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
name|SSTOP
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SWTED
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|p_flag
operator||=
name|SWTED
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|V
operator|.
name|r_val1
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|u
operator|.
name|u_r
operator|.
name|V
operator|.
name|r_val2
operator|=
operator|(
name|fsig
argument_list|(
name|p
argument_list|)
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
return|return;
block|}
continue|continue;
block|}
end_if

begin_expr_stmt
unit|} 	if
operator|(
name|f
operator|)
block|{
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|u
operator|.
name|u_procp
argument_list|,
name|PWAIT
argument_list|)
block|;
goto|goto
name|loop
goto|;
block|}
end_expr_stmt

begin_expr_stmt
name|u
operator|.
name|u_error
operator|=
name|ECHILD
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * fork system call.  */
end_comment

begin_expr_stmt
unit|fork
operator|(
operator|)
block|{
specifier|register
expr|struct
name|proc
operator|*
name|p1
block|,
operator|*
name|p2
block|;
specifier|register
name|a
block|;
comment|/* 	 * Make sure there's enough swap space for max 	 * core image, thus reducing chances of running out 	 */
if|if
condition|(
operator|(
name|a
operator|=
name|malloc
argument_list|(
name|swapmap
argument_list|,
name|ctod
argument_list|(
name|MAXMEM
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mfree
argument_list|(
name|swapmap
argument_list|,
name|ctod
argument_list|(
name|MAXMEM
argument_list|)
argument_list|,
name|a
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|a
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|p2
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|p1
operator|=
operator|&
name|proc
index|[
literal|0
index|]
init|;
name|p1
operator|<
operator|&
name|proc
index|[
name|NPROC
index|]
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
name|p1
operator|->
name|p_stat
operator|==
name|NULL
operator|&&
name|p2
operator|==
name|NULL
condition|)
name|p2
operator|=
name|p1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p1
operator|->
name|p_uid
operator|==
name|u
operator|.
name|u_uid
operator|&&
name|p1
operator|->
name|p_stat
operator|!=
name|NULL
condition|)
name|a
operator|++
expr_stmt|;
block|}
block|}
end_for

begin_comment
comment|/* 	 * Disallow if 	 *  No processes at all; 	 *  not su and too many procs owned; or 	 *  not su and would take last slot. 	 */
end_comment

begin_if
if|if
condition|(
name|p2
operator|==
name|NULL
operator|||
operator|(
name|u
operator|.
name|u_uid
operator|!=
literal|0
operator|&&
operator|(
name|p2
operator|==
operator|&
name|proc
index|[
name|NPROC
operator|-
literal|1
index|]
operator|||
name|a
operator|>
name|MAXUPRC
operator|)
operator|)
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
end_if

begin_expr_stmt
name|p1
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|newproc
argument_list|()
condition|)
block|{
name|u
operator|.
name|u_r
operator|.
name|V
operator|.
name|r_val1
operator|=
name|p1
operator|->
name|p_pid
expr_stmt|;
name|u
operator|.
name|u_start
operator|=
name|time
expr_stmt|;
name|u
operator|.
name|u_cstime
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|u_stime
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|u_cutime
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|u_utime
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|u_acflag
operator|=
name|AFORK
expr_stmt|;
return|return;
block|}
end_if

begin_expr_stmt
name|u
operator|.
name|u_r
operator|.
name|V
operator|.
name|r_val1
operator|=
name|p2
operator|->
name|p_pid
expr_stmt|;
end_expr_stmt

begin_label
name|out
label|:
end_label

begin_expr_stmt
name|u
operator|.
name|u_ar0
index|[
name|R7
index|]
operator|+=
name|NBPW
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * break system call.  *  -- bad planning: "break" is a dirty word in C.  */
end_comment

begin_expr_stmt
unit|sbreak
operator|(
operator|)
block|{ 	struct
name|a
block|{
name|char
operator|*
name|nsiz
block|; 	}
block|;
specifier|register
name|a
block|,
name|n
block|,
name|d
block|;
name|int
name|i
block|;
comment|/* 	 * set n to new data size 	 * set d to new-old 	 * set n to new total size 	 */
name|n
operator|=
name|btoc
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
expr|struct
name|a
operator|*
operator|)
name|u
operator|.
name|u_ap
argument_list|)
operator|->
name|nsiz
argument_list|)
block|;
if|if
condition|(
operator|!
name|u
operator|.
name|u_sep
condition|)
name|n
operator|-=
name|ctos
argument_list|(
name|u
operator|.
name|u_tsize
argument_list|)
operator|*
name|stoc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|d
operator|=
name|n
operator|-
name|u
operator|.
name|u_dsize
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|n
operator|+=
name|USIZE
operator|+
name|u
operator|.
name|u_ssize
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|estabur
argument_list|(
name|u
operator|.
name|u_tsize
argument_list|,
name|u
operator|.
name|u_dsize
operator|+
name|d
argument_list|,
name|u
operator|.
name|u_ssize
argument_list|,
name|u
operator|.
name|u_sep
argument_list|,
name|RO
argument_list|)
condition|)
return|return;
end_if

begin_expr_stmt
name|u
operator|.
name|u_dsize
operator|+=
name|d
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|d
operator|>
literal|0
condition|)
goto|goto
name|bigger
goto|;
end_if

begin_expr_stmt
name|a
operator|=
name|u
operator|.
name|u_procp
operator|->
name|p_addr
operator|+
name|n
operator|-
name|u
operator|.
name|u_ssize
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|i
operator|=
name|n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|n
operator|=
name|u
operator|.
name|u_ssize
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|copyseg
argument_list|(
name|a
operator|-
name|d
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|a
operator|++
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|expand
argument_list|(
name|i
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return;
end_return

begin_label
name|bigger
label|:
end_label

begin_expr_stmt
name|expand
argument_list|(
name|n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|a
operator|=
name|u
operator|.
name|u_procp
operator|->
name|p_addr
operator|+
name|n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|n
operator|=
name|u
operator|.
name|u_ssize
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|a
operator|--
expr_stmt|;
name|copyseg
argument_list|(
name|a
operator|-
name|d
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_while

begin_while
while|while
condition|(
name|d
operator|--
condition|)
name|clearseg
argument_list|(
operator|--
name|a
argument_list|)
expr_stmt|;
end_while

unit|}
end_unit

