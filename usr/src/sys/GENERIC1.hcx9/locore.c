begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|LOCORE
end_ifdef

begin_define
define|#
directive|define
name|U_PROCP
value|144
end_define

begin_define
define|#
directive|define
name|U_EOSYS
value|273
end_define

begin_define
define|#
directive|define
name|P_LINK
value|0
end_define

begin_define
define|#
directive|define
name|P_RLINK
value|4
end_define

begin_define
define|#
directive|define
name|P_XLINK
value|108
end_define

begin_define
define|#
directive|define
name|P_ADDR
value|16
end_define

begin_define
define|#
directive|define
name|P_PRI
value|21
end_define

begin_define
define|#
directive|define
name|P_STAT
value|23
end_define

begin_define
define|#
directive|define
name|P_WCHAN
value|96
end_define

begin_define
define|#
directive|define
name|P_TSIZE
value|68
end_define

begin_define
define|#
directive|define
name|P_SSIZE
value|76
end_define

begin_define
define|#
directive|define
name|P_P0BR
value|104
end_define

begin_define
define|#
directive|define
name|P_SZPT
value|66
end_define

begin_define
define|#
directive|define
name|P_TEXTP
value|100
end_define

begin_define
define|#
directive|define
name|P_FLAG
value|44
end_define

begin_define
define|#
directive|define
name|P_DKEY
value|164
end_define

begin_define
define|#
directive|define
name|P_CKEY
value|160
end_define

begin_define
define|#
directive|define
name|SSLEEP
value|1
end_define

begin_define
define|#
directive|define
name|SRUN
value|3
end_define

begin_define
define|#
directive|define
name|V_SWTCH
value|0
end_define

begin_define
define|#
directive|define
name|V_TRAP
value|4
end_define

begin_define
define|#
directive|define
name|V_SYSCALL
value|8
end_define

begin_define
define|#
directive|define
name|V_INTR
value|12
end_define

begin_define
define|#
directive|define
name|V_SOFT
value|16
end_define

begin_define
define|#
directive|define
name|V_FPE
value|116
end_define

begin_define
define|#
directive|define
name|V_ALIGN
value|120
end_define

begin_define
define|#
directive|define
name|MCLBYTES
value|1024
end_define

begin_define
define|#
directive|define
name|NBPG
value|1024
end_define

begin_define
define|#
directive|define
name|PGSHIFT
value|10
end_define

begin_define
define|#
directive|define
name|UPAGES
value|6
end_define

begin_define
define|#
directive|define
name|CLSIZE
value|1
end_define

begin_define
define|#
directive|define
name|MAXPHYS
value|65536
end_define

begin_define
define|#
directive|define
name|SYSPTSIZE
value|9216
end_define

begin_define
define|#
directive|define
name|USRPTSIZE
value|1024
end_define

begin_define
define|#
directive|define
name|VBIOSIZE
value|1020
end_define

begin_define
define|#
directive|define
name|MSGBUFPTECNT
value|4
end_define

begin_define
define|#
directive|define
name|NMBCLUSTERS
value|256
end_define

begin_define
define|#
directive|define
name|PCB_KSP
value|0
end_define

begin_define
define|#
directive|define
name|PCB_USP
value|4
end_define

begin_define
define|#
directive|define
name|PCB_R0
value|8
end_define

begin_define
define|#
directive|define
name|PCB_R1
value|12
end_define

begin_define
define|#
directive|define
name|PCB_R2
value|16
end_define

begin_define
define|#
directive|define
name|PCB_R3
value|20
end_define

begin_define
define|#
directive|define
name|PCB_R4
value|24
end_define

begin_define
define|#
directive|define
name|PCB_R5
value|28
end_define

begin_define
define|#
directive|define
name|PCB_R6
value|32
end_define

begin_define
define|#
directive|define
name|PCB_R7
value|36
end_define

begin_define
define|#
directive|define
name|PCB_R8
value|40
end_define

begin_define
define|#
directive|define
name|PCB_R9
value|44
end_define

begin_define
define|#
directive|define
name|PCB_R10
value|48
end_define

begin_define
define|#
directive|define
name|PCB_R11
value|52
end_define

begin_define
define|#
directive|define
name|PCB_R12
value|56
end_define

begin_define
define|#
directive|define
name|PCB_R13
value|60
end_define

begin_define
define|#
directive|define
name|PCB_FP
value|60
end_define

begin_define
define|#
directive|define
name|PCB_PC
value|64
end_define

begin_define
define|#
directive|define
name|PCB_PSL
value|68
end_define

begin_define
define|#
directive|define
name|PCB_P0BR
value|72
end_define

begin_define
define|#
directive|define
name|PCB_P0LR
value|76
end_define

begin_define
define|#
directive|define
name|PCB_P1BR
value|80
end_define

begin_define
define|#
directive|define
name|PCB_P1LR
value|84
end_define

begin_define
define|#
directive|define
name|PCB_P2BR
value|88
end_define

begin_define
define|#
directive|define
name|PCB_P2LR
value|92
end_define

begin_define
define|#
directive|define
name|PCB_ACH
value|96
end_define

begin_define
define|#
directive|define
name|PCB_ACL
value|100
end_define

begin_define
define|#
directive|define
name|PCB_HFS
value|104
end_define

begin_define
define|#
directive|define
name|PCB_SAVACC
value|108
end_define

begin_define
define|#
directive|define
name|PCB_SZPT
value|112
end_define

begin_define
define|#
directive|define
name|PCB_CMAP2
value|116
end_define

begin_define
define|#
directive|define
name|PCB_SSWAP
value|120
end_define

begin_define
define|#
directive|define
name|PCB_SIGC
value|124
end_define

begin_define
define|#
directive|define
name|SCB_DOADUMP
value|8
end_define

begin_define
define|#
directive|define
name|SCB_BUSERR
value|128
end_define

begin_define
define|#
directive|define
name|SCB_DEVBASE
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	@(#)scb.s	7.1 (Berkeley) 5/21/88  */
end_comment

begin_comment
comment|/*  * System control block  */
end_comment

begin_define
define|#
directive|define
name|STRAY
value|.long	_Xstray
end_define

begin_define
define|#
directive|define
name|STRAY8
value|STRAY;STRAY;STRAY;STRAY;STRAY;STRAY;STRAY;STRAY
end_define

begin_define
define|#
directive|define
name|KS
parameter_list|(
name|a
parameter_list|)
value|.long	_X
comment|/**/
value|a
end_define

begin_define
define|#
directive|define
name|IS
parameter_list|(
name|a
parameter_list|)
value|.long	_X
comment|/**/
value|a
end_define

begin_label
name|_scb
label|:
end_label

begin_expr_stmt
operator|.
name|globl
name|_scb
comment|/* 000 */
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IS
argument_list|(
name|powfail
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IS
argument_list|(
name|doadump
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 004 */
end_comment

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IS
argument_list|(
name|hardclock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 008 */
end_comment

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IS
argument_list|(
name|cnrint
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IS
argument_list|(
name|cnxint
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 00c */
end_comment

begin_expr_stmt
name|IS
argument_list|(
name|rmtrint
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IS
argument_list|(
name|rmtxint
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 010 */
end_comment

begin_expr_stmt
name|IS
argument_list|(
name|kdbintr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IS
argument_list|(
name|netintr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 014 */
end_comment

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IS
argument_list|(
name|softclock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 018 */
end_comment

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 01c */
end_comment

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 020 */
end_comment

begin_expr_stmt
name|IS
argument_list|(
name|buserr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 024 */
end_comment

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 028 */
end_comment

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|KS
argument_list|(
name|syscall
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 02c */
end_comment

begin_expr_stmt
name|KS
argument_list|(
name|privinflt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|KS
argument_list|(
name|resopflt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|KS
argument_list|(
name|resadflt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|KS
argument_list|(
name|protflt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 030 */
end_comment

begin_expr_stmt
name|KS
argument_list|(
name|transflt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IS
argument_list|(
name|kspnotval
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|KS
argument_list|(
name|tracep
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|KS
argument_list|(
name|bptflt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 034 */
end_comment

begin_expr_stmt
name|KS
argument_list|(
name|arithtrap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|KS
argument_list|(
name|alignflt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|KS
argument_list|(
name|sfexcep
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|KS
argument_list|(
name|fpm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 038 */
end_comment

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 03c */
end_comment

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* device interrupt vectors */
end_comment

begin_comment
comment|/* 040 */
end_comment

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 060 */
end_comment

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 080 */
end_comment

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 0a0 */
end_comment

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 0c0 */
end_comment

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 0e0 */
end_comment

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRAY8
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|I_CLOCK
value|0
end_define

begin_define
define|#
directive|define
name|I_CNR
value|4
end_define

begin_define
define|#
directive|define
name|I_CNX
value|8
end_define

begin_define
define|#
directive|define
name|I_RMTR
value|12
end_define

begin_define
define|#
directive|define
name|I_RMTX
value|16
end_define

begin_define
define|#
directive|define
name|I_BUSERR
value|20
end_define

begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)locore.s	7.6 (Berkeley) 5/1/89  *	9/8/89 (bostic) -- added delay in wbadaddr from 7.10  *	This had already been patched, but I have no idea by whom; the  *	following lines had been added:  *  *	#if NVX> 0  *		ADDMAP( NVX * 16384/NBPG )  *	#endif  */
end_comment

begin_include
include|#
directive|include
file|"../tahoe/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/trap.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/psl.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/pte.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/cp.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/mem.h"
end_include

begin_include
include|#
directive|include
file|"../tahoe/SYS.h"
end_include

begin_include
include|#
directive|include
file|"../tahoemath/fp.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"syscall.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_expr_stmt
operator|.
name|set
name|HIGH
operator|,
literal|0x1f
operator|#
name|mask
end_expr_stmt

begin_for
for|for total disable 	.set	NISP
operator|,
literal|3
operator|#
name|number
name|of
name|interrupt
name|stack
name|pages
operator|.
name|set
name|SYSTEM
operator|,
literal|0xC0000000
operator|#
name|virtual
name|address
name|of
name|system
name|start
operator|.
name|set
name|PPAGES
operator|,
literal|0x100000
operator|#
name|possible
name|pages
name|in
name|P0
operator|,
name|P1
operator|,
name|etc
operator|.
comment|/* ACBL for non-negative '_add' */
define|#
directive|define
name|ACBL
parameter_list|(
name|_limit
parameter_list|,
name|_add
parameter_list|,
name|_index
parameter_list|,
name|_displ
parameter_list|)
define|\
value|addl2	_add,_index; \ 	cmpl	_index,_limit; \ 	bleq	_displ
comment|/* _ACBL for negative '_add' */
define|#
directive|define
name|_ACBL
parameter_list|(
name|_limit
parameter_list|,
name|_add
parameter_list|,
name|_index
parameter_list|,
name|_displ
parameter_list|)
define|\
value|addl2	_add,_index; \ 	cmpl	_index,_limit; \ 	bgeq	_displ
define|#
directive|define
name|MOVC3
parameter_list|(
name|_srcaddr
parameter_list|,
name|_dstaddr
parameter_list|,
name|_len
parameter_list|)
define|\
value|movl	_srcaddr,r0; \ 	movl	_dstaddr,r1; \ 	movl	_len,r2; \ 	movblk
comment|/* keep address of psl if coming from user mode */
define|#
directive|define
name|CHECK_SFE
parameter_list|(
name|_delta
parameter_list|)
define|\
value|bitl	$PSL_CURMOD,_delta(sp); \ 	jeql	1f; \ 	moval	_delta(sp),_user_psl; \ 1:
comment|/*  * User structure is UPAGES at top of user space.  */
expr|.
name|globl
name|_u
operator|.
name|set
name|_u
operator|,
name|SYSTEM
operator|-
name|UPAGES
operator|*
name|NBPG
comment|/*  * Restart stack. Used on power recovery or panic.  * Takes a core-dump and then halts.  */
operator|.
name|globl
name|_rsstk
operator|.
name|globl
name|pwfl_stk
name|_rsstk
operator|:
operator|.
name|space
literal|1024
operator|-
literal|8
name|pwfl_stk
operator|:
operator|.
name|space
literal|4
name|dumpflag
operator|:
operator|.
name|space
literal|4
operator|.
name|globl
name|_intstack
name|_intstack
operator|:
operator|.
name|space
name|NISP
operator|*
name|NBPG
name|eintstack
operator|:
comment|/*  * Power failure storage block and  * macros for saving and restoring.  */
define|#
directive|define
name|POWERFAIL
parameter_list|(
name|id
parameter_list|,
name|longs
parameter_list|)
define|\
value|.globl	pwfl_
comment|/**/
value|id \ pwfl_
comment|/**/
value|id: .space longs*4
operator|.
name|data
name|POWERFAIL
argument_list|(
name|r0
argument_list|,
literal|14
argument_list|)
operator|#
name|r0
operator|-
name|r13
name|POWERFAIL
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
operator|#
name|r14
name|POWERFAIL
argument_list|(
name|SCBB
argument_list|,
literal|1
argument_list|)
operator|#
name|system
name|control
name|block
name|base
name|POWERFAIL
argument_list|(
name|SBR
argument_list|,
literal|1
argument_list|)
operator|#
name|system
name|pte
name|base
name|POWERFAIL
argument_list|(
name|SLR
argument_list|,
literal|1
argument_list|)
operator|#
name|system
name|pte
name|length
name|POWERFAIL
argument_list|(
name|P0BR
argument_list|,
literal|1
argument_list|)
operator|#
name|p0
name|pte
name|base
name|POWERFAIL
argument_list|(
name|P0LR
argument_list|,
literal|1
argument_list|)
operator|#
name|p0
name|pte
name|length
name|POWERFAIL
argument_list|(
name|P1BR
argument_list|,
literal|1
argument_list|)
operator|#
name|p1
name|pte
name|base
name|POWERFAIL
argument_list|(
name|P1LR
argument_list|,
literal|1
argument_list|)
operator|#
name|p1
name|pte
name|length
name|POWERFAIL
argument_list|(
name|P2BR
argument_list|,
literal|1
argument_list|)
operator|#
name|p2
name|pte
name|base
name|POWERFAIL
argument_list|(
name|P2LR
argument_list|,
literal|1
argument_list|)
operator|#
name|p2
name|pte
name|length
name|POWERFAIL
argument_list|(
name|IPL
argument_list|,
literal|1
argument_list|)
operator|#
name|interrupt
name|priority
name|level
name|POWERFAIL
argument_list|(
name|DCK
argument_list|,
literal|1
argument_list|)
operator|#
name|data
name|cache
name|key
name|POWERFAIL
argument_list|(
name|CCK
argument_list|,
literal|1
argument_list|)
operator|#
name|code
name|cache
name|key
name|POWERFAIL
argument_list|(
name|PCBB
argument_list|,
literal|1
argument_list|)
operator|#
name|process
name|control
name|block
name|base
name|POWERFAIL
argument_list|(
name|ISP
argument_list|,
literal|1
argument_list|)
operator|#
name|interrupt
name|stack
name|pointer
name|POWERFAIL
argument_list|(
name|KSP
argument_list|,
literal|1
argument_list|)
operator|#
name|kernel
name|mode
name|stack
name|pointer
name|POWERFAIL
argument_list|(
name|USP
argument_list|,
literal|1
argument_list|)
operator|#
name|user
name|mode
name|stack
name|pointer
name|POWERFAIL
argument_list|(
name|MME
argument_list|,
literal|1
argument_list|)
operator|#
name|memory
name|management
name|enable
name|POWERFAIL
argument_list|(
name|PSL
argument_list|,
literal|1
argument_list|)
operator|#
name|processor
name|status
name|longword
comment|/*  * Save current state in power fail storage block.  */
define|#
directive|define
name|SAVEpwfl
parameter_list|()
define|\
value|movpsl	pwfl_PSL	# Keeps all flags, etc. \ 	storer	$0x3fff,pwfl_r0	# Saves r0-r13 \ 	moval	0(sp),pwfl_sp	# Saves sp (=r14) \ 	mfpr	$SBR,pwfl_SBR	# Save all re_loadable registers \ 	mfpr	$SLR,pwfl_SLR \ 	mfpr	$P0BR,pwfl_P0BR \ 	mfpr	$P0LR,pwfl_P0LR \ 	mfpr	$P1BR,pwfl_P1BR \ 	mfpr	$P1LR,pwfl_P1LR \ 	mfpr	$P2BR,pwfl_P2BR \ 	mfpr	$P2LR,pwfl_P2LR \ 	mfpr	$IPL,pwfl_IPL \ 	mfpr	$MME,pwfl_MME \ 	mfpr	$DCK,pwfl_DCK \ 	mfpr	$CCK,pwfl_CCK \ 	mfpr	$PCBB,pwfl_PCBB \ 	mfpr	$ISP,pwfl_ISP \ 	mfpr	$SCBB,pwfl_SCBB \ 	mfpr	$KSP,pwfl_KSP \ 	mfpr	$USP,pwfl_USP
comment|/*  * Restore state saved in power fail block and  * jmp to location specified after (possibly)  * enabling memory management.  */
define|#
directive|define
name|RESTOREpwfl
parameter_list|(
name|loc
parameter_list|)
define|\
value|loadr	$0x3fff,pwfl_r0	# Restore r0-r13 \ 	movl	pwfl_sp,sp	# Restore sp (=r14) \ 	mtpr	pwfl_SCBB,$SCBB \ 	mtpr	pwfl_SBR,$SBR	# Restore all re_loadable registers \ 	mtpr	pwfl_SLR,$SLR \ 	mtpr	pwfl_P0BR,$P0BR \ 	mtpr	pwfl_P0LR,$P0LR \ 	mtpr	pwfl_P1BR,$P1BR \ 	mtpr	pwfl_P1LR,$P1LR \ 	mtpr	pwfl_P2BR,$P2BR \ 	mtpr	pwfl_P2LR,$P2LR \ 	mtpr	pwfl_IPL,$IPL \ 	mtpr	pwfl_DCK,$DCK \ 	mtpr	pwfl_CCK,$CCK \ 	mtpr	pwfl_PCBB,$PCBB \ 	mtpr	pwfl_ISP,$ISP \ 	mtpr	pwfl_KSP,$KSP \ 	mtpr	pwfl_USP,$USP \ \ 	bicpsw	$0xff		# Restore PSW. \ 	bispsw	pwfl_PSL+2	# Set original bits back (just in case..) \ # now go to mapped mode \ # Have to change PC to system addresses \ 	mtpr	$1,$PACC	# Thoroughly clean up caches. \ 	mtpr	$1,$PADC \ 	mtpr	$1,$TBIA \ 	mtpr	pwfl_MME,$MME  	# Restore MME. Last thing to be done. \ 	jmp 	loc
comment|/*  * Do a dump.  * Called by auto-restart.  * May be called manually.  */
operator|.
name|align
literal|2
operator|.
name|text
operator|.
name|globl
name|_Xdoadump
operator|.
name|globl
name|_doadump
name|_Xdoadump
operator|:
operator|#
name|CP
name|comes
name|here
name|after
name|power
name|fail
name|RESTOREpwfl
argument_list|(
operator|*
literal|0f
argument_list|)
operator|#
name|restore
name|state
name|_doadump
operator|:
operator|.
name|word
literal|0
literal|0
operator|:
name|mtpr
name|$HIGH
operator|,
name|$IPL
define|#
directive|define
name|_rsstkmap
value|_Sysmap+12	# powerfail storage, scb, rsstk, int stack
name|tstl
name|dumpflag
operator|#
name|dump
name|only
name|once
operator|!
name|bneq
literal|1f
name|andl2
name|$
operator|~
name|PG_PROT
operator|,
name|_rsstkmap
name|orl2
name|$PG_KW
operator|,
name|_rsstkmap
operator|#
name|Make
name|dump
name|stack
name|r
operator|/
name|w
name|mtpr
name|$0
operator|,
name|$TBIA
name|movl
name|$1
operator|,
name|dumpflag
name|movab
name|dumpflag
operator|,
name|sp
name|callf
name|$4
operator|,
name|_dumpsys
literal|1
operator|:
name|halt
comment|/*  * Interrupt vector routines  */
operator|.
name|globl
name|_waittime
define|#
directive|define
name|SCBVEC
parameter_list|(
name|name
parameter_list|)
define|\
value|.align 2; \ 	.globl _X
comment|/**/
value|name; \ _X
comment|/**/
value|name
define|#
directive|define
name|PANIC
parameter_list|(
name|msg
parameter_list|)
define|\
value|clrl _waittime; pushab 1f; callf $8,_panic; 1: .asciz msg
define|#
directive|define
name|PRINTF
parameter_list|(
name|n
parameter_list|,
name|msg
parameter_list|)
define|\
value|pushab 1f; callf $(n+2)*4,_printf; MSG(msg)
define|#
directive|define
name|MSG
parameter_list|(
name|msg
parameter_list|)
value|.data; 1: .asciz msg; .text
comment|/*  * r0-r5 are saved across all faults and interrupts.  * Routines below and those hidden in vbglue.s (device  * interrupts) invoke the PUSHR/POPR macros to execute  * this.  Also, certain stack frame offset calculations  * use this, using the REGSPC definition (and FPSPC defined below).  */
define|#
directive|define
name|REGSPC
value|6*4
define|#
directive|define
name|PUSHR
value|movab -REGSPC(sp),sp; storer $0x3f,(sp)
define|#
directive|define
name|POPR
value|loadr $0x3f,(sp); movab REGSPC(sp),sp
comment|/*  * Floating point state is saved across faults and  * interrupts.  The state occupies 4 longwords on  * the stack:  *	precision indicator (single = 0/double = 1)  *	double representation of accumulator  *	save accumulator status flag (pcb_savacc)  */
define|#
directive|define
name|FPSPC
value|(4*4)
define|#
directive|define
name|SAVE_FPSTAT
parameter_list|(
name|_delta
parameter_list|)
define|\
value|bitl	$PSL_DBL,_delta(sp); \ 	beql	1f; \ 	pushl	$1; \ 	pushd; \ 	jmp	2f; \ 1:	pushl	$0; \ 	pushl	$0; \ 	stf	-(sp); \ 2:	tstl	_u+PCB_SAVACC; \ 	bneq	3f; \ 	moval	0(sp),_u+PCB_SAVACC; \ 	orl2	$2,8(sp);\ 3:	pushl	$0;
define|#
directive|define
name|REST_FPSTAT
define|\
value|tstl	(sp)+; \ 	bitl	$2,8(sp);\ 	beql	1f;\ 	movl	$0,_u+PCB_SAVACC; \ 1:	bitl	$1,8(sp); \ 	beql	2f; \ 	ldd	(sp); \ 	jmp	3f; \ 2:	ldf	(sp); \ 3:	moval	12(sp),sp;
define|#
directive|define
name|REST_ACC
define|\
value|tstl	_u+PCB_SAVACC; \ 	beql	2f; \ 	movl	_u+PCB_SAVACC,r1; \ 	andl3	$(EXPMASK|SIGNBIT),(r1),-(sp); \ 	cmpl	$0x80000000,(sp)+; \ 	bneq	3f; \ 	clrl	(r1); \ 3:	bitl	$1,8(r1); \ 	beql	1f; \ 	ldd	(r1); \ 	jmp	2f; \ 1:	ldf	(r1); \ 2:	;
operator|.
name|data
name|nofault
operator|:
operator|.
name|space
literal|4
operator|#
name|bus
name|error
name|non
operator|-
name|local
end_for

begin_goto
goto|goto
name|label
operator|.
name|text
name|SCBVEC
goto|(
name|buserr
end_goto

begin_macro
unit|):
name|CHECK_SFE
argument_list|(
literal|12
argument_list|)
end_macro

begin_macro
name|SAVE_FPSTAT
argument_list|(
literal|12
argument_list|)
end_macro

begin_expr_stmt
name|incl
name|_intrcnt
operator|+
name|I_BUSERR
operator|#
name|keep
name|stats
operator|...
name|pushl
name|r0
operator|#
name|must
name|save
name|andl3
literal|24
operator|(
name|sp
operator|)
operator|,
name|$ERRCD
operator|,
name|r0
operator|#
name|grab
name|pushed
name|MER
name|value
name|cmpl
name|r0
operator|,
name|$APE
operator|#
name|address
name|parity
name|error
condition|?
name|jneq
literal|1f
name|halt
literal|1
else|:
name|cmpl
name|r0
operator|,
name|$VBE
operator|#
name|versabus
name|error
condition|?
name|jneq
literal|2f
name|halt
literal|2
else|:
name|movl
argument_list|(
name|sp
argument_list|)
operator|+
operator|,
name|r0
operator|#
name|restore
name|r0
name|and
operator|...
name|bitl
name|$PSL_CURMOD
operator|,
literal|4
operator|*
literal|4
operator|+
literal|3
operator|*
literal|4
operator|(
name|sp
operator|)
operator|#
name|check
end_expr_stmt

begin_if
if|if happened in user mode? 	jeql	3f			# yes
operator|,
name|then
name|shift
name|stack
name|up
end_if

begin_for
for|for trap... 	movl	12
control|(
name|sp
control|)
operator|,
literal|16
operator|(
name|sp
operator|)
operator|#
name|sorry
operator|,
name|no
name|space
end_for

begin_for
for|for which-buss... 	movl	8
control|(
name|sp
control|)
operator|,
literal|12
operator|(
name|sp
operator|)
name|movl
literal|4
operator|(
name|sp
operator|)
operator|,
literal|8
operator|(
name|sp
operator|)
name|movl
literal|0
operator|(
name|sp
operator|)
operator|,
literal|4
operator|(
name|sp
operator|)
name|movl
name|$T_BUSERR
operator|,
literal|0
operator|(
name|sp
operator|)
operator|#
name|push
name|trap
name|type
name|code
name|and
operator|...
name|jbr
name|alltraps
operator|#
operator|...
name|merge
name|with
name|all
name|other
name|traps
literal|3
operator|:
operator|#
name|kernel
name|mode
operator|,
name|check
name|to
name|see
end_for

begin_if
if|if... 	tstl	nofault			# ...doing peek/poke? 	jeql	4f			# nofault set? if so
operator|,
name|jump
name|to
name|it
modifier|...
name|movl
name|nofault
decl_stmt|,4
modifier|*
decl_stmt|4+2
modifier|*
decl_stmt|4
argument_list|(
name|sp
argument_list|)
decl_stmt|#
modifier|...
name|setup
decl|for
name|non
decl|-
name|local
decl|goto
name|clrl
name|nofault
name|jbr
decl|5f 4
range|:
name|PUSHR
name|pushab
literal|4
operator|*
literal|4
operator|+
name|REGSPC
argument_list|(
name|sp
argument_list|)
operator|#
name|address
name|of
name|bus
name|error
name|parameters
name|callf
name|$8
decl_stmt|,
name|_buserror
name|POPR
decl|5
range|:
name|REST_FPSTAT
name|movab
literal|8
operator|(
name|sp
operator|)
decl_stmt|,
name|sp
decl|#
name|remove
name|bus
name|error
name|parameters
name|rei
name|SCBVEC
argument_list|(
name|powfail
argument_list|)
range|:
operator|#
name|We
name|should
name|be
name|on
name|interrupt
name|stack
name|now
operator|.
name|SAVEpwfl
argument_list|()
operator|#
name|save
name|machine
name|state
name|moval
name|_Xdoadump
operator|-
name|SYSTEM
decl_stmt|,
name|_scb
decl|+
name|SCB_DOADUMP
name|halt
name|SCBVEC
argument_list|(
name|stray
argument_list|)
range|:
name|incl
name|_cnt
operator|+
name|V_INTR
operator|#
name|add
name|to
name|statistics
name|rei
include|#
directive|include
file|"../net/netisr.h"
operator|.
name|globl
name|_netisr
name|SCBVEC
argument_list|(
name|netintr
argument_list|)
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
name|SAVE_FPSTAT
argument_list|(
literal|4
argument_list|)
decl_stmt|;
end_if

begin_decl_stmt
name|PUSHR
include|#
directive|include
file|"imp.h"
if|#
directive|if
name|NIMP
operator|>
literal|0
name|bbc
name|$NETISR_IMP
decl_stmt|,
name|_netisr
decl_stmt|,1f;
end_decl_stmt

begin_expr_stmt
name|andl2
name|$
operator|~
operator|(
literal|1
operator|<<
name|NETISR_IMP
operator|)
operator|,
name|_netisr
name|callf
name|$4
operator|,
name|_impintr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
literal|1
operator|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
name|bbc
name|$NETISR_IP
operator|,
name|_netisr
operator|,
literal|1f
name|andl2
name|$
operator|~
operator|(
literal|1
operator|<<
name|NETISR_IP
operator|)
operator|,
name|_netisr
name|callf
name|$4
operator|,
name|_ipintr
literal|1
operator|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
name|bbc
name|$NETISR_NS
operator|,
name|_netisr
operator|,
literal|1f
name|andl2
name|$
operator|~
operator|(
literal|1
operator|<<
name|NETISR_NS
operator|)
operator|,
name|_netisr
name|callf
name|$4
operator|,
name|_nsintr
literal|1
operator|:
endif|#
directive|endif
name|bbc
name|$NETISR_RAW
operator|,
name|_netisr
operator|,
literal|1f
name|andl2
name|$
operator|~
operator|(
literal|1
operator|<<
name|NETISR_RAW
operator|)
operator|,
name|_netisr
name|callf
name|$4
operator|,
name|_rawintr
literal|1
operator|:
name|incl
name|_cnt
operator|+
name|V_SOFT
name|POPR
expr_stmt|;
end_expr_stmt

begin_macro
name|REST_FPSTAT
end_macro

begin_macro
name|rei
end_macro

begin_expr_stmt
name|SCBVEC
argument_list|(
name|cnrint
argument_list|)
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
name|SAVE_FPSTAT
argument_list|(
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUSHR
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|pushl
name|$CPCONS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|callf
name|$8
decl_stmt|,
name|_cnrint
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|incl
name|_intrcnt
operator|+
name|I_CNR
name|incl
name|_cnt
operator|+
name|V_INTR
name|POPR
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|REST_FPSTAT
expr_stmt|;
end_expr_stmt

begin_macro
name|rei
end_macro

begin_expr_stmt
name|SCBVEC
argument_list|(
name|cnxint
argument_list|)
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
name|SAVE_FPSTAT
argument_list|(
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUSHR
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|pushl
name|$CPCONS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|callf
name|$8
decl_stmt|,
name|_cnxint
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|incl
name|_intrcnt
operator|+
name|I_CNX
name|incl
name|_cnt
operator|+
name|V_INTR
name|POPR
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|REST_FPSTAT
expr_stmt|;
end_expr_stmt

begin_macro
name|rei
end_macro

begin_expr_stmt
name|SCBVEC
argument_list|(
name|rmtrint
argument_list|)
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
name|SAVE_FPSTAT
argument_list|(
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUSHR
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|pushl
name|$CPREMOT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|callf
name|$8
decl_stmt|,
name|_cnrint
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|incl
name|_intrcnt
operator|+
name|I_RMTR
name|incl
name|_cnt
operator|+
name|V_INTR
name|POPR
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|REST_FPSTAT
expr_stmt|;
end_expr_stmt

begin_macro
name|rei
end_macro

begin_expr_stmt
name|SCBVEC
argument_list|(
name|rmtxint
argument_list|)
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
name|SAVE_FPSTAT
argument_list|(
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUSHR
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|pushl
name|$CPREMOT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|callf
name|$8
decl_stmt|,
name|_cnxint
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|incl
name|_intrcnt
operator|+
name|I_RMTX
name|incl
name|_cnt
operator|+
name|V_INTR
name|POPR
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|REST_FPSTAT
expr_stmt|;
end_expr_stmt

begin_macro
name|rei
end_macro

begin_define
define|#
directive|define
name|PUSHPCPSL
value|pushl 4+FPSPC+REGSPC(sp); pushl 4+FPSPC+REGSPC(sp);
end_define

begin_expr_stmt
name|SCBVEC
argument_list|(
name|hardclock
argument_list|)
operator|:
name|tstl
name|_clk_enable
name|bneq
literal|1f
name|rei
literal|1
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
name|SAVE_FPSTAT
argument_list|(
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUSHR
name|PUSHPCPSL
operator|#
name|push
name|pc
name|and
name|psl
name|callf
name|$12
operator|,
name|_hardclock
operator|#
name|hardclock
argument_list|(
argument|pc
argument_list|,
argument|psl
argument_list|)
name|incl
name|_intrcnt
operator|+
name|I_CLOCK
name|incl
name|_cnt
operator|+
name|V_INTR
operator|#
operator|#
name|temp
name|so
name|not
name|to
end_expr_stmt

begin_break
break|break
name|vmstat
break|-=
name|HZ
name|POPR
break|;
end_break

begin_macro
name|REST_FPSTAT
end_macro

begin_macro
name|rei
end_macro

begin_expr_stmt
name|SCBVEC
argument_list|(
name|softclock
argument_list|)
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
name|SAVE_FPSTAT
argument_list|(
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUSHR
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUSHPCPSL
operator|#
name|push
name|pc
name|and
name|psl
name|callf
name|$12
operator|,
name|_softclock
operator|#
name|softclock
argument_list|(
argument|pc
argument_list|,
argument|psl
argument_list|)
name|incl
name|_cnt
operator|+
name|V_SOFT
name|POPR
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|REST_FPSTAT
name|rei
comment|/*  * Stray VERSAbus interrupt catch routines  */
operator|.
name|data
define|#
directive|define
name|PJ
value|.align 2; callf $4,_Xvstray
operator|.
name|globl
name|_catcher
name|_catcher
range|:
name|PJ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PJ
name|PJ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PJ
name|PJ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PJ
name|PJ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PJ
name|PJ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PJ
name|PJ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PJ
name|PJ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PJ
name|PJ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PJ
name|PJ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PJ
name|PJ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PJ
name|PJ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PJ
name|PJ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PJ
operator|.
name|align
literal|2
operator|.
name|globl
name|_cold
name|_cold
operator|:
operator|.
name|long
literal|0x3
operator|.
name|text
name|SCBVEC
argument_list|(
name|vstray
argument_list|)
operator|:
operator|.
name|word
literal|0
name|bbc
name|$0
operator|,
name|_cold
operator|,
literal|2f
operator|#
name|system
name|running
condition|?
name|bbc
name|$1
operator|,
name|_cold
operator|,
literal|1f
operator|#
name|doing
name|autoconfig
condition|?
name|jbr
literal|3f
operator|#
name|random
name|interrupt
operator|,
name|ignore
literal|1
operator|:
name|mfpr
name|$IPL
operator|,
name|r12
operator|#
operator|...
name|setup
name|br
name|and
name|cvec
name|subl3
name|$_catcher
operator|+
literal|7
operator|,
operator|-
literal|8
operator|(
name|fp
operator|)
operator|,
name|r11
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|shar
name|$3
decl_stmt|,
name|r11
decl_stmt|,
name|r11
name|addl2
name|$SCB_DEVBASE
decl_stmt|,
name|r11
name|jbr
decl|3f 2
range|:
name|PUSHR
name|subl3
name|$_catcher
operator|+
literal|7
decl_stmt|,-8
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|r0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|shar
name|$3
decl_stmt|,
name|r0
decl_stmt|,
name|r0
name|addl3
name|$SCB_DEVBASE
decl_stmt|,
name|r0
decl_stmt|,-
argument_list|(
name|sp
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mfpr
name|$IPL
decl_stmt|,-
argument_list|(
name|sp
argument_list|)
name|PRINTF
argument_list|(
literal|2
argument_list|,
literal|"stray intr ipl %x vec %x\n"
argument_list|)
name|POPR
decl|3
range|:
name|moval
literal|0f
decl_stmt|,-8
argument_list|(
name|fp
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ret
operator|#
name|pop
name|callf
name|frame
operator|...
literal|0
operator|:
name|rei
operator|#
operator|...
name|and
end_expr_stmt

begin_return
return|return
comment|/*  * Trap and fault vector routines  */
define|#
directive|define
name|TRAP
parameter_list|(
name|a
parameter_list|)
value|pushl $T_
comment|/**/
value|a; jbr alltraps
comment|/*  * Ast delivery (profiling and/or reschedule)  */
name|SCBVEC
argument_list|(
name|kspnotval
argument_list|)
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
name|pushl
name|$0
return|;
end_return

begin_macro
name|SAVE_FPSTAT
argument_list|(
literal|8
argument_list|)
end_macro

begin_macro
name|TRAP
argument_list|(
argument|KSPNOTVAL
argument_list|)
end_macro

begin_expr_stmt
name|SCBVEC
argument_list|(
name|privinflt
argument_list|)
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
name|pushl
name|$0
expr_stmt|;
end_expr_stmt

begin_macro
name|SAVE_FPSTAT
argument_list|(
literal|8
argument_list|)
end_macro

begin_macro
name|TRAP
argument_list|(
argument|PRIVINFLT
argument_list|)
end_macro

begin_expr_stmt
name|SCBVEC
argument_list|(
name|resopflt
argument_list|)
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
name|pushl
name|$0
expr_stmt|;
end_expr_stmt

begin_macro
name|SAVE_FPSTAT
argument_list|(
literal|8
argument_list|)
end_macro

begin_macro
name|TRAP
argument_list|(
argument|RESOPFLT
argument_list|)
end_macro

begin_expr_stmt
name|SCBVEC
argument_list|(
name|resadflt
argument_list|)
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
name|pushl
name|$0
expr_stmt|;
end_expr_stmt

begin_macro
name|SAVE_FPSTAT
argument_list|(
literal|8
argument_list|)
end_macro

begin_macro
name|TRAP
argument_list|(
argument|RESADFLT
argument_list|)
end_macro

begin_expr_stmt
name|SCBVEC
argument_list|(
name|bptflt
argument_list|)
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
name|pushl
name|$0
expr_stmt|;
end_expr_stmt

begin_macro
name|SAVE_FPSTAT
argument_list|(
literal|8
argument_list|)
end_macro

begin_macro
name|TRAP
argument_list|(
argument|BPTFLT
argument_list|)
end_macro

begin_expr_stmt
name|SCBVEC
argument_list|(
name|kdbintr
argument_list|)
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|pushl
name|$0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SAVE_FPSTAT
argument_list|(
literal|8
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TRAP
argument_list|(
name|KDBTRAP
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SCBVEC
argument_list|(
name|tracep
argument_list|)
operator|:
name|CHECK_SFE
argument_list|(
literal|4
argument_list|)
name|pushl
name|$0
expr_stmt|;
end_expr_stmt

begin_macro
name|SAVE_FPSTAT
argument_list|(
literal|8
argument_list|)
end_macro

begin_macro
name|TRAP
argument_list|(
argument|TRCTRAP
argument_list|)
end_macro

begin_expr_stmt
name|SCBVEC
argument_list|(
name|alignflt
argument_list|)
operator|:
ifdef|#
directive|ifdef
name|ALIGN
name|bitl
name|$PSL_CURMOD
operator|,
literal|4
operator|(
name|sp
operator|)
name|jeql
name|align_excp
operator|#
name|Can
literal|'t emulate for kernel mode ! 	jbr	non_aligned		# Only emulated for user mode. align_excp: #else 	CHECK_SFE(4) #endif 	pushl $0; 	SAVE_FPSTAT(8) 	TRAP(ALIGNFLT) SCBVEC(arithtrap): 	CHECK_SFE(8) 	SAVE_FPSTAT(8) 	TRAP(ARITHTRAP)  SCBVEC(protflt): 	CHECK_SFE(12) 	bitl	$1,(sp)+ 	jneq	segflt 	SAVE_FPSTAT(8) 	TRAP(PROTFLT) segflt: 	SAVE_FPSTAT(8) 	TRAP(SEGFLT)  SCBVEC(fpm):			# Floating Point Emulation #ifdef FPE 	CHECK_SFE(16) 	SAVE_FPSTAT(16) 	incl	_cnt+V_FPE	# count emulation traps 	callf	$4,_fpemulate 	REST_FPSTAT #endif 	moval	8(sp),sp	# Pop operand 	tstl	(sp)		# Stack= PSL, PC, return_code 	jneq	_Xarithtrap	# If not OK, emulate F.P. exception 	movab	4(sp),sp	# Else remove return_code and 	rei  SCBVEC(sfexcep): 	CHECK_SFE(4) 	pushl $0 	SAVE_FPSTAT(8) 	TRAP(ASTFLT)  SCBVEC(transflt): 	CHECK_SFE(12) 	bitl	$2,(sp)+ 	bneq	tableflt pageflt: 	SAVE_FPSTAT(8) 	TRAP(PAGEFLT) tableflt: 	SAVE_FPSTAT(8) 	TRAP(TABLEFLT)  #define REST_STACK	movab 4(sp), sp; REST_FPSTAT; movab 4(sp), sp  alltraps: 	mfpr	$USP,-(sp);  	callf	$4,_trap; 	mtpr	(sp)+,$USP 	incl	_cnt+V_TRAP 	REST_STACK			# pop type, code, and fp stuff 	mtpr	$HIGH,$IPL		## dont go to a higher IPL (GROT) 	rei  SCBVEC(syscall): 	CHECK_SFE(8) 	SAVE_FPSTAT(8) 	pushl	$T_SYSCALL 	mfpr	$USP,-(sp); 	callf	$4,_syscall; 	mtpr	(sp)+,$USP 	incl	_cnt+V_SYSCALL 	REST_STACK			# pop type, code, and fp stuff 	mtpr	$HIGH,$IPL		## dont go to a higher IPL (GROT) 	rei  /*  * System page table.  *  * Mbmap and Usrptmap are enlarged by CLSIZE entries  * as they are managed by resource maps starting with index 1 or CLSIZE.  */  #define	vaddr(x)	((((x)-_Sysmap)/4)*NBPG+SYSTEM) #define	SYSMAP(mname, vname, npte)			\ _/**/mname:	.globl	_/**/mname;		\ 	.space	(npte)*4;			\ 	.globl	_/**/vname;			\ 	.set	_/**/vname,vaddr(_/**/mname) #define	ADDMAP(npte)	.space	(npte)*4  	.data 	.align	2 	SYSMAP(Sysmap	,Sysbase	,SYSPTSIZE	) 	SYSMAP(Forkmap	,forkutl	,UPAGES		) 	SYSMAP(Xswapmap	,xswaputl	,UPAGES		) 	SYSMAP(Xswap2map,xswap2utl	,UPAGES		) 	SYSMAP(Swapmap	,swaputl	,UPAGES		) 	SYSMAP(Pushmap	,pushutl	,UPAGES		) 	SYSMAP(Vfmap	,vfutl		,UPAGES		) 	SYSMAP(CMAP1	,CADDR1		,1		) 	SYSMAP(CMAP2	,CADDR2		,1		) 	SYSMAP(mmap	,vmmap		,1		) 	SYSMAP(alignmap	,alignutl	,1		)	/* XXX */ 	SYSMAP(msgbufmap,msgbuf		,MSGBUFPTECNT	) 	SYSMAP(Mbmap	,mbutl		,NMBCLUSTERS*MCLBYTES/NBPG+CLSIZE ) 	SYSMAP(kmempt	,kmembase	,300*CLSIZE 	) #ifdef	GPROF 	SYSMAP(profmap	,profbase	,600*CLSIZE	) #endif 	/* 	 * Enlarge kmempt as needed for bounce buffers allocated 	 * by tahoe controllers. 	 */ #include "hd.h" #if NHD> 0 				ADDMAP(	NHDC*(MAXPHYS/NBPG+CLSIZE) ) #endif #include "dk.h" #if NDK> 0 				ADDMAP(	NVD*(MAXPHYS/NBPG+CLSIZE) ) #endif #include "yc.h" #if NYC> 0 				ADDMAP(	NCY*(MAXPHYS/NBPG+CLSIZE) ) #endif #include "mp.h" 				ADDMAP(	NMP*14		) 	SYSMAP(ekmempt	,kmemlimit	,0		)  	SYSMAP(VMEMbeg	,vmembeg	,0		) 	SYSMAP(VMEMmap	,vmem		,VBIOSIZE 	) 	SYSMAP(VMEMmap1	,vmem1		,0		) #include "ace.h" #if NACE> 0 				ADDMAP(	NACE*32	) #endif #if NHD> 0 				ADDMAP( NHDC ) #endif #include "vx.h" #if NVX> 0 				ADDMAP( NVX * 16384/NBPG ) #endif 	SYSMAP(VMEMend	,vmemend	,0		)  	SYSMAP(VBmap	,vbbase		,CLSIZE		) #if NHD> 0 				ADDMAP(	NHDC*(MAXPHYS/NBPG+CLSIZE) ) #endif #if NDK> 0 				ADDMAP(	NVD*(MAXPHYS/NBPG+CLSIZE) ) #endif #if NYC> 0 				ADDMAP(	NCY*(MAXPHYS/NBPG+CLSIZE) ) #endif 				ADDMAP(	NMP*14		) 	SYSMAP(eVBmap	,vbend		,0		)  	SYSMAP(Usrptmap	,usrpt		,USRPTSIZE+CLSIZE ) eSysmap: 	.globl	_Syssize 	.set	_Syssize,(eSysmap-_Sysmap)/4  	.text /*  * Initialization  *  * IPL 0x1f; MME 0; scbb, pcbb, sbr, slr, isp, ksp not set  */ 	.align	2 	.globl	start start: 	.word	0 /* set system control block base and system page table params */ 	mtpr	$_scb-SYSTEM,$SCBB 	mtpr	$_Sysmap-SYSTEM,$SBR 	mtpr	$_Syssize,$SLR /* double map the kernel into the virtual user addresses of phys mem */ 	mtpr	$_Sysmap,$P0BR 	mtpr	$_Syssize,$P0LR 	mtpr	$_Sysmap,$P1BR			# against Murphy 	mtpr	$_Syssize,$P1LR /* set ISP */ 	movl	$_intstack-SYSTEM+NISP*NBPG,sp	# still physical 	mtpr	$_intstack+NISP*NBPG,$ISP /* count up memory */ 	clrl	r7 1:	pushl	$1; pushl r7; callf $12,_badaddr; tstl r0; bneq 9f 	ACBL($MAXMEM*1024-1,$64*1024,r7,1b) 9: /* clear memory from kernel bss and pages for proc 0 u. and page table */ 	movab	_edata,r6; andl2 $~SYSTEM,r6 	movab	_end,r5; andl2 $~SYSTEM,r5 #ifdef KADB 	subl2	$4,r5 1:	clrl	(r6); ACBL(r5,$4,r6,1b)		# clear just bss 	addl2	$4,r5 	bbc	$6,r11,0f			# check RB_KDB 	andl3	$~SYSTEM,r9,r5			# skip symbol& string tables 	andl3	$~SYSTEM,r9,r6 #endif 0:	orl3	$SYSTEM,r5,r9			# convert to virtual address 	addl2	$NBPG-1,r9			# roundup to next page 	addl2	$(UPAGES*NBPG)+NBPG+NBPG,r5 1:	clrl	(r6); ACBL(r5,$4,r6,1b) /* trap(), syscall(), and fpemulate() save r0-r12 in the entry mask */ 	orw2	$0x01fff,_trap 	orw2	$0x01fff,_syscall #ifdef FPE 	orw2	$0x01fff,_fpemulate #endif 	orw2	$0x01ffc,_panic			# for debugging (no r0|r1) 	callf	$4,_fixctlrmask			# setup for autoconfig /* initialize system page table: scb and int stack writeable */ 	clrl	r2 	movab	eintstack,r1  	andl2	$~SYSTEM,r1 	shrl 	$PGSHIFT,r1,r1			# r1-page number of eintstack /* make 1st page processor storage read/only, 2nd read/write */ 	orl3	$PG_V|PG_KR,r2,_Sysmap[r2]; incl r2; 	orl3	$PG_V|PG_KW,r2,_Sysmap[r2]; incl r2; /* other parts of the system are read/write for kernel */ 1:	orl3	$PG_V|PG_KW,r2,_Sysmap[r2];	# data:kernel write+phys=virtual 	aoblss r1,r2,1b /* make rsstk read-only as red zone for interrupt stack */ 	andl2	$~PG_PROT,_rsstkmap 	orl2	$PG_V|PG_KR,_rsstkmap /* make kernel text space read-only */ 	movab	_etext+NBPG-1,r1 	andl2	$~SYSTEM,r1 	shrl 	$PGSHIFT,r1,r1 1:	orl3	$PG_V|PG_KR,r2,_Sysmap[r2] 	aoblss r1,r2,1b /* make kernel data, bss, read-write */ 	andl3	$~SYSTEM,r9,r1 	shrl 	$PGSHIFT,r1,r1 1:	orl3	$PG_V|PG_KW,r2,_Sysmap[r2] 	aoblss r1,r2,1b /* go to mapped mode, have to change both pc and sp to system addresses */ 	mtpr	$1,$TBIA 	mtpr	$1,$PADC			# needed by HW parity&ECC logic 	mtpr	$1,$PACC			# just in case 	mtpr 	$1,$MME 	movab	SYSTEM(sp),sp 	jmp 	*$0f 0: /* disable any interrupts */ 	movl	$0,_intenable /* init mem sizes */ 	shrl	$PGSHIFT,r7,_maxmem 	movl	_maxmem,_physmem 	movl	_maxmem,_freemem /* setup context for proc[0] == scheduler */ 	andl3	$~SYSTEM,r9,r6			# convert to physical 	andl2	$~(NBPG-1),r6			# make page boundary /* setup page table for proc[0] */ 	shrl	$PGSHIFT,r6,r3			# r3 = btoc(r6) 	orl3	$PG_V|PG_KW,r3,_Usrptmap	# init first upt entry 	incl	r3				# r3 - next page 	movab	_usrpt,r0			# r0 - first user page 	mtpr	r0,$TBIS /* init p0br, p0lr */ 	mtpr	r0,$P0BR			# no p0 for proc[0] 	mtpr	$0,$P0LR 	mtpr	r0,$P1BR			# no p1 either 	mtpr	$0,$P1LR /* init p2br, p2lr */ 	movab	NBPG(r0),r0 	movl	$PPAGES-UPAGES,r1 	mtpr	r1,$P2LR 	moval	-4*PPAGES(r0),r2 	mtpr	r2,$P2BR /* setup mapping for UPAGES of _u */ 	clrl	r2 	movl 	$SYSTEM,r1 	addl2 	$UPAGES,r3 	jbr 2f 1:	decl	r3 	moval	-NBPG(r1),r1	# r1 = virtual add of next (downward) _u page 	subl2	$4,r0		# r0 = pte address 	orl3	$PG_V|PG_URKW,r3,(r0) 	mtpr	r1,$TBIS 2:	aobleq	$UPAGES,r2,1b /* initialize (slightly) the pcb */ 	movab	UPAGES*NBPG(r1),PCB_KSP(r1)	# KSP starts at end of _u 	movl	r1,PCB_USP(r1)			# USP starts just below _u 	mfpr	$P0BR,PCB_P0BR(r1) 	mfpr	$P0LR,PCB_P0LR(r1) 	mfpr	$P1BR,PCB_P1BR(r1) 	mfpr	$P1LR,PCB_P1LR(r1) 	mfpr	$P2BR,PCB_P2BR(r1) 	mfpr	$P2LR,PCB_P2LR(r1) 	movl	$CLSIZE,PCB_SZPT(r1)		# init u.u_pcb.pcb_szpt 	movl	r9,PCB_R9(r1)			# r9 obtained from boot 	movl	r10,PCB_R10(r1)			# r10 obtained from boot 	movl	r11,PCB_R11(r1)			# r11 obtained from CP on boot 	movab	1f,PCB_PC(r1)			# initial pc 	clrl	PCB_PSL(r1)			# kernel mode, ipl=0 	shll	$PGSHIFT,r3,r3 	mtpr	r3,$PCBB			# first pcbb (physical) /* go to kernel mode */ 	ldpctx 	rei					# Actually next instruction: /* put signal trampoline code in u. area */ 1:	movab	sigcode,r0 	movab	_u+PCB_SIGC,r1 	movl	$19,r2 	movblk /* save boot device in global _bootdev */ 	movl	r10,_bootdev /* save reboot flags in global _boothowto */ 	movl	r11,_boothowto #ifdef KADB /* save end of symbol& string table in global _bootesym */ 	subl3	$NBPG-1,r9,_bootesym #endif /* calculate firstaddr, and call main() */ 	andl3	$~SYSTEM,r9,r0 	shrl	$PGSHIFT,r0,-(sp) 	addl2	$UPAGES+1,(sp)			# first physical unused page 	callf 	$8,_main /* proc[1] == /etc/init now running here in kernel mode; run icode */ 	pushl	$PSL_CURMOD			# User mode PSL 	pushl $0				# PC = 0 (virtual now) 	rei  /*  * Mask for saving/restoring registers on entry to  * a user signal handler.  Space for the registers  * is reserved in sendsig, so beware if you want  * to change the mask.  */ #define	SIGREGS	(R0|R1|R2|R3|R4|R5) 	.align	2 	.globl	sigcode sigcode: 	storer	$SIGREGS,16(sp)	# save volatile registers 	calls	$4*3+4,*12(sp)	# params pushed by sendsig for handler 	loadr	$SIGREGS,4(sp)	# restore volatile registers 	movab	24(sp),fp	# use parameter list set up in sendsig 	kcall	$SYS_sigreturn	# cleanup mask and onsigstack 	halt			# sigreturn does not return!  	.globl	_icode 	.globl	_initflags 	.globl	_szicode /*  * Icode is copied out to process 1 to exec /etc/init.  * If the exec fails, process 1 exits.  */ 	.align	2 _icode: 	/* try /sbin/init */ 	pushab	b`argv1-l0(pc) l0:	pushab	b`init1-l1(pc) l1:	pushl	$2 	movab	(sp),fp 	kcall	$SYS_execv 	/* try /etc/init */ 	pushab	b`argv2-l2(pc) l2:	pushab	b`init2-l3(pc) l3:	pushl	$2 	movab	(sp),fp 	kcall	$SYS_execv 	/* give up */ 	pushl	r0 	pushl	$1 	movab	(sp),fp 	kcall	$SYS_exit  init1:	.asciz	"/sbin/init" init2:	.asciz	"/etc/init" 	.align	2 _initflags: 	.long	0 argv1:	.long	init1+6-_icode 	.long	_initflags-_icode 	.long	0 argv2:	.long	init2+5-_icode 	.long	_initflags-_icode 	.long	0 _szicode: 	.long	_szicode-_icode  /*  * Primitives  */   /*  * badaddr(addr, len)  *	see if access addr with a len type instruction causes a machine check  *	len is length of access (1=byte, 2=short, 4=long)  *	r0 = 0 means good(exists); r0 =1 means does not exist.  */ ENTRY(badaddr, R3|R4) 	mfpr	$IPL,r1 	mtpr	$HIGH,$IPL 	movl	_scb+SCB_BUSERR,r2 	movl	4(fp),r3 	movl	8(fp),r4 	movab	9f,_scb+SCB_BUSERR 	bbc	$0,r4,1f; tstb	(r3) 1:	bbc	$1,r4,1f; tstw	(r3) 1:	bbc	$2,r4,1f; tstl	(r3) 1:	clrl	r0 2:	movl	r2,_scb+SCB_BUSERR 	mtpr	r1,$IPL 	ret  /*  * wbadaddr(addr, len, value)  *	see if write of value to addr with a len type instruction causes  *	a machine check  *	len is length of access (1=byte, 2=short, 4=long)  *	r0 = 0 means good(exists); r0 =1 means does not exist.  */ ENTRY(wbadaddr, R3|R4) 	mfpr	$IPL,r1 	mtpr	$HIGH,$IPL 	movl	_scb+SCB_BUSERR,r2 	movl	4(fp),r3 	movl	8(fp),r4 	movab	9f,_scb+SCB_BUSERR 	bbc	$0,r4,1f; movb	15(fp), (r3) 1:	bbc	$1,r4,1f; movw	14(fp), (r3) 1:	bbc	$2,r4,1f; movl	12(fp), (r3) 1:	movl	$30000,r0		# delay for error interrupt 1:	decl	r0 	jneq	1b 2:	movl	r2,_scb+SCB_BUSERR	# made it w/o machine checks; r0 is 0 	mtpr	r1,$IPL 	ret  	.align	2 9:				# catch buss error (if it comes) 	andl3	4(sp),$ERRCD,r0 	cmpl	r0,$APE 	jneq	1f 	halt			# address parity error 1:	cmpl	r0,$VBE 	jneq	1f 	halt			# Versabus error 1: 	movl	$1,r0		# Anything else = bad address 	movab	8(sp),sp	# discard buss error trash 	movab	2b,(sp)		# new program counter on stack. 	rei  /*  * badcyaddr(addr)  *	see if access tape master controller addr causes a bus error  *	r0 = 0: no error; r0 = 1: timeout error.  */ ENTRY(badcyaddr, 0) 	mfpr	$IPL,r1 	mtpr	$HIGH,$IPL 	clrl	r2 	movab	2f,nofault 	movob	$-1, *4(fp) 1:	aobleq	$1000, r2, 1b 	clrl	nofault			# made it w/o bus error 	clrl	r0 	jbr	3f 2:	movl	$1,r0 3:	mtpr	r1,$IPL 	ret  /*  * peek(addr)  *	fetch word and catch any bus error  */ ENTRY(peek, 0) 	mfpr	$IPL,r1 	mtpr	$0x18,$IPL	# not reentrant 	movl	4(fp),r2 	movab	1f,nofault 	movw	(r2),r0 	clrl	nofault 	andl2	$0xffff,r0 	jbr	2f 1:	movl	$-1,r0		# bus error 2:	mtpr	r1,$IPL 	ret  /*  * poke(addr, val)  *	write word and catch any bus error  */ ENTRY(poke, R3) 	mfpr	$IPL,r1 	mtpr	$0x18,$IPL	# not reentrant 	movl	4(fp),r2 	movl	8(fp),r3 	clrl	r0 	movab	1f,nofault 	movw	r3,(r2) 	clrl	nofault 	jbr	2f 1:	movl	$-1,r0		# bus error 2:	mtpr	r1,$IPL 	ret  /*  * Copy a potentially overlapping block of memory.  *  * ovbcopy(src, dst, count)  *	caddr_t src, dst; unsigned count;  */ ENTRY(ovbcopy, R3|R4) 	movl	4(fp),r0 	movl	8(fp),r1 	movl	12(fp),r2 	cmpl	r0,r1 	bgtru	1f			# normal forward case 	beql	2f			# equal, nothing to do 	addl2	r2,r0			# may be overlapping 	cmpl	r0,r1 	bgtru	3f 	subl2	r2,r0			# normal forward case 1: 	movblk 2: 	ret 3: 	addl2	r2,r1			# overlapping, must do backwards 	subl3	r0,r1,r3 	movl	r2,r4 	jbr	5f 4: 	subl2	r3,r0 	subl2	r3,r1 	movl	r3,r2 	movblk 	subl2	r3,r0 	subl2	r3,r1 	subl2	r3,r4 5: 	cmpl	r4,r3 	jgtr	4b 	movl	r4,r2 	subl2	r2,r0 	subl2	r2,r1 	movblk 	ret  /*  * Copy a null terminated string from the user address space into  * the kernel address space.  *  * copyinstr(fromaddr, toaddr, maxlength,&lencopied)  */ ENTRY(copyinstr, 0) 	movl	12(fp),r5		# r5 = max length 	jlss	5f 	movl	8(fp),r4		# r4 = kernel address 	movl	4(fp),r0		# r0 = user address 	andl3	$(NBPG*CLSIZE-1),r0,r2	# r2 = bytes on first page 	subl3	r2,$(NBPG*CLSIZE),r2 1: 	cmpl	r5,r2			# r2 = min(bytes on page, length left); 	jgeq	2f 	movl	r5,r2 2: 	prober	$1,(r0),r2		# bytes accessible? 	jeql	5f 	subl2	r2,r5			# update bytes left count 	movl	r2,r3			# r3 = saved count 	movl	r0,r1 	cmps3				# check for null 	tstl	r2 	jneq	3f 	subl2	r3,r0			# back up r0 	movl	r4,r1 	movl	r3,r2 	movblk				# copy in next piece 	movl	r1,r4 	movl	$(NBPG*CLSIZE),r2	# check next page 	tstl	r5			# run out of space? 	jneq	1b 	movl	$ENOENT,r0		# set error code and return 	jbr	6f 3: 	tstl	16(fp)			# return length? 	beql	4f 	subl3	r5,12(fp),r5		# actual len = maxlen - unused pages 	subl2	r2,r5			#	- unused on this page 	addl3	$1,r5,*16(fp)		#	+ the null byte 4: 	movl	r4,r1 	subl3	r2,r3,r2		# calc char cnt 	subl2	r2,r0			# back up r0 	incl	r2			# add on null byte 	movblk				# copy last piece 	clrl	r0 	ret 5: 	movl	$EFAULT,r0 6: 	tstl	16(fp) 	beql	7f 	subl3	r5,12(fp),*16(fp) 7: 	ret  /*  * Copy a null terminated string from the kernel  * address space to the user address space.  *  * copyoutstr(fromaddr, toaddr, maxlength,&lencopied)  */ ENTRY(copyoutstr, 0) 	movl	12(fp),r5		# r5 = max length 	jlss	5f 	movl	4(fp),r0		# r0 = kernel address 	movl	8(fp),r4		# r4 = user address 	andl3	$(NBPG*CLSIZE-1),r4,r2	# r2 = bytes on first page 	subl3	r2,$(NBPG*CLSIZE),r2 1: 	cmpl	r5,r2			# r2 = min(bytes on page, length left); 	jgeq	2f 	movl	r5,r2 2: 	probew	$1,(r4),r2		# bytes accessible? 	jeql	5f 	subl2	r2,r5			# update bytes left count 	movl	r2,r3			# r3 = saved count 	movl	r0,r1 /*  * This is a workaround for a microcode bug that causes  * a trap type 9 when cmps3/movs3 touches the last byte  * on a valid page immediately followed by an invalid page.  */ #ifdef good_cmps3 	cmps3				# check for null 	tstl	r2 	jneq	3b #else 	decl	r2 	beql	9f			# cannot handle case of r2 == 0! 	cmps3				# check for null up to last byte 9: 	incl	r2 	cmpl	$1,r2			# get to last byte on page? 	bneq	3b 	tstb	(r0)			# last byte on page null? 	beql	3b 	incl	r0			# not null, so bump pointer #endif not good_cmps3 	subl2	r3,r0			# back up r0 	movl	r4,r1 	movl	r3,r2 	movblk				# copy out next piece 	movl	r1,r4 	movl	$(NBPG*CLSIZE),r2	# check next page 	tstl	r5			# run out of space? 	jneq	1b 	movl	$ENOENT,r0		# set error code and return 	jbr	6b 5: 	clrl	*$0		# this should never execute, if it does 	movl	$EFAULT,r0	#  save me a core dump (mkm - 9/87) 6: 	tstl	16(fp) 	beql	7f 	subl3	r5,12(fp),*16(fp) 7: 	ret   /*  * Copy a null terminated string from one point to another in  * the kernel address space.  *  * copystr(fromaddr, toaddr, maxlength,&lencopied)  */ ENTRY(copystr, 0) 	movl	12(fp),r3		# r3 = max length 	jlss	5b 	movl	4(fp),r0		# r0 = src address 	movl	8(fp),r4		# r4 = dest address 	clrl	r5			# r5 = bytes left 	movl	r3,r2			# r2 = max bytes to copy 	movl	r0,r1 	cmps3				# check for null 	tstl	r2 	jneq	3b 	subl2	r3,r0			# back up r0 	movl	r4,r1 	movl	r3,r2 	movblk				# copy next piece 	movl	$ENOENT,r0		# set error code and return 	jbr	6b  /*  * Copy a block of data from the user address space into  * the kernel address space.  *  * copyin(fromaddr, toaddr, count)  */ ENTRY(copyin, 0) 	movl	12(fp),r0		# copy length 	blss	9f 	movl	4(fp),r1		# copy user address 	cmpl	$(CLSIZE*NBPG),r0	# probing one page or less ? 	bgeq	2f			# yes 1: 	prober	$1,(r1),$(CLSIZE*NBPG)	# bytes accessible ? 	beql	9f			# no 	addl2	$(CLSIZE*NBPG),r1	# incr user address ptr 	_ACBL($(CLSIZE*NBPG+1),$(-CLSIZE*NBPG),r0,1b)	# reduce count and loop 2: 	prober	$1,(r1),r0		# bytes accessible ? 	beql	9f			# no 	MOVC3(4(fp),8(fp),12(fp)) 	clrl	r0 	ret 9: 	movl	$EFAULT,r0 	ret  /*  * Copy a block of data from the kernel   * address space to the user address space.  *  * copyout(fromaddr, toaddr, count)  */ ENTRY(copyout, 0) 	movl	12(fp),r0		# get count 	blss	9b 	movl	8(fp),r1		# get user address 	cmpl	$(CLSIZE*NBPG),r0	# can do in one probew? 	bgeq	2f			# yes 1: 	probew	$1,(r1),$(CLSIZE*NBPG)	# bytes accessible? 	beql	9b			# no  	addl2	$(CLSIZE*NBPG),r1	# increment user address 	_ACBL($(CLSIZE*NBPG+1),$(-CLSIZE*NBPG),r0,1b)	# reduce count and loop 2: 	probew	$1,(r1),r0		# bytes accessible? 	beql	9b			# no 	MOVC3(4(fp),8(fp),12(fp)) 	clrl	r0 	ret  /*  * non-local goto'
name|s
operator|*
operator|/
ifdef|#
directive|ifdef
name|notdef
name|ENTRY
argument_list|(
argument|setjmp
argument_list|,
literal|0
argument_list|)
name|movl
literal|4
operator|(
name|fp
operator|)
operator|,
name|r0
name|movl
argument_list|(
name|fp
argument_list|)
operator|,
operator|(
name|r0
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|addl2
name|$4
decl_stmt|,
name|r0
decl|#
name|save
name|fp
name|movl
decl|-8
argument_list|(
name|fp
argument_list|)
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|save
name|pc
name|clrl
name|r0
name|ret
endif|#
directive|endif
name|ENTRY
argument_list|(
name|longjmp
argument_list|,
literal|0
argument_list|)
name|movl
decl|4
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|r0
name|movl
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|newfp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|addl2
name|$4
decl_stmt|,
name|r0
decl|#
name|must
name|save
name|parameters
name|in
name|memory
name|movl
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|newpc
decl|#
name|as
name|all
name|regs
name|may
name|be
name|clobbered
operator|.
decl|1
range|:
name|cmpl
name|fp
decl_stmt|,
name|newfp
decl|#
name|are
name|we
name|there
name|yet
decl|?
name|bgequ
decl|2f				#
name|yes
name|moval
decl|1b
decl_stmt|,-8
argument_list|(
name|fp
argument_list|)
decl_stmt|#
name|redirect
decl|return
name|pc
name|to
name|us
decl|!
name|ret
decl|#
name|pop
name|next
name|frame
decl|2
range|:
name|beql
literal|3f
operator|#
name|did
name|we
name|miss
name|our
name|frame
condition|?
name|pushab
literal|4f
operator|#
name|yep
condition|?
operator|!
condition|?
name|callf
name|$8
decl_stmt|,
name|_panic
decl|3
range|:
name|movl
name|newpc
decl_stmt|,
name|r0
decl|#
name|all
name|done
decl_stmt|,
name|just
decl|return
name|jmp
argument_list|(
name|r0
argument_list|)
decl|#
name|to
name|setjmp
decl|`
name|ret
decl|'  	.data newpc:	.space	4 newfp:	.space	4 4:	.asciz	"longjmp" 	.text  /*  * setjmp that saves all registers as the call frame may not  * be available to recover them in the usual manner by longjmp.  * Called before swapping out the u. area, restored by resume()  * below.  */ ENTRY(savectx, 0) 	movl	4(fp),r2 	storer	$0x1ff8,(r2); addl2 $40,r2	# r3-r12 	movl	(fp),(r2); addl2 $4,r2		# fp 	movab	8(fp),(r2); addl2 $4,r2		# sp 	movl	-8(fp),(r2)			# pc 	clrl	r0 	ret  #ifdef KADB /*  * C library -- reset, setexit  *  *	reset(x)  * will generate a "return" from  * the last call to  *	setexit()  * by restoring r2 - r12, fp  * and doing a return.  * The returned value is x; on the original  * call the returned value is 0.  */ ENTRY(setexit, 0) 	movab	setsav,r0 	storer	$0x1ffc, (r0) 	movl	(fp),44(r0)		# fp 	moval	4(fp),48(r0)		# sp 	movl	-8(fp),52(r0)		# pc 	clrl	r0 	ret  ENTRY(reset, 0) 	movl	4(fp),r0	# returned value 	movab	setsav,r1 	loadr	$0x1ffc,(r1) 	movl	44(r1),fp 	movl	48(r1),sp 	jmp 	*52(r1)  	.data 	.align	2 setsav:	.space	14*4 	.text #endif  	.globl	_whichqs 	.globl	_qs 	.globl	_cnt  	.globl	_noproc 	.comm	_noproc,4 	.globl	_runrun 	.comm	_runrun,4 /*  * The following primitives use the fancy TAHOE instructions.  * _whichqs tells which of the 32 queues _qs  * have processes in them.  setrq puts processes into queues, remrq  * removes them from queues.  The running process is on no queue,  * other processes are on a queue related to p->p_pri, divided by 4  * actually to shrink the 0-127 range of priorities into the 32 available  * queues.  */  /*  * setrq(p), using fancy TAHOE instructions.  *  * Call should be made at spl8(), and p->p_stat should be SRUN  */ ENTRY(setrq, 0) 	movl	4(fp),r0 	tstl	P_RLINK(r0)		## firewall: p->p_rlink must be 0 	beql	set1			## 	pushab	set3			## 	callf	$8,_panic		## set1: 	movzbl	P_PRI(r0),r1		# put on queue which is p->p_pri / 4 	shar	$2,r1,r1 	shal	$1,r1,r2 	moval	_qs[r2],r2 	insque	(r0),*4(r2)		# at end of queue 	shal	r1,$1,r1 	orl2	r1,_whichqs		# mark queue non-empty 	ret  set3:	.asciz	"setrq"  /*  * remrq(p), using fancy TAHOE instructions  *  * Call should be made at spl8().  */ ENTRY(remrq, 0) 	movl	4(fp),r0 	movzbl	P_PRI(r0),r1 	shar	$2,r1,r1 	bbs	r1,_whichqs,rem1 	pushab	rem3			# it wasn'
name|t
name|recorded
name|to
name|be
name|on
name|its
name|q
name|callf
name|$8
decl_stmt|,
name|_panic
name|rem1
range|:
name|remque
argument_list|(
argument|r0
argument_list|)
name|bneq
name|rem2
operator|#
name|q
name|not
name|empty
name|yet
name|shal
name|r1
decl_stmt|,
name|$1
decl_stmt|,
name|r1
name|mcoml
name|r1
decl_stmt|,
name|r1
name|andl2
name|r1
decl_stmt|,
name|_whichqs
decl|#
name|mark
name|queue
name|empty
name|rem2
range|:
name|clrl
name|P_RLINK
argument_list|(
name|r0
argument_list|)
operator|#
operator|#
end_decl_stmt

begin_for
for|for firewall checking 	ret  rem3:	.asciz	"remrq"
comment|/*  * Masterpaddr is the p->p_addr of the running process on the master  * processor.  When a multiprocessor system, the slave processors will have  * an array of slavepaddr's.  */
for|.globl	_masterpaddr 	.data 	.align	2 _masterpaddr: .long	0  	.text sw0:	.asciz	"swtch"
comment|/*  * When no processes are on the runq, swtch branches to idle  * to wait for something to come ready.  */
for|.globl  Idle Idle: idle: 	movl	$1
operator|,
name|_noproc
name|mtpr
name|$0
decl_stmt|,
name|$IPL
decl|#
name|must
name|allow
name|interrupts
name|here
decl|1
range|:
name|tstl
name|_whichqs
operator|#
name|look
end_for

begin_for
for|for non-empty queue 	bneq	sw1 	brb	1b  badsw:	pushab	sw0 	callf	$8
operator|,
name|_panic
comment|/* NOTREACHED */
operator|.
name|align
literal|2
comment|/*  * swtch(), using fancy tahoe instructions  */
name|ENTRY
argument_list|(
argument|swtch
argument_list|,
literal|0
argument_list|)
name|movl
argument_list|(
name|fp
argument_list|)
operator|,
name|fp
operator|#
name|prepare
end_for

begin_for
for|for rei 	movl
control|(
name|sp
control|)
operator|,
literal|4
operator|(
name|sp
operator|)
operator|#
name|saved
name|pc
name|tstl
argument_list|(
name|sp
argument_list|)
operator|+
name|movpsl
literal|4
operator|(
name|sp
operator|)
name|incl
name|_cnt
operator|+
name|V_SWTCH
name|sw1
operator|:
name|ffs
name|_whichqs
operator|,
name|r0
operator|#
name|look
end_for

begin_for
for|for non-empty queue 	blss	idle			# if none
operator|,
name|idle
name|mtpr
name|$0x18
decl_stmt|,
name|$IPL
decl|#
name|lock
name|out
name|all
name|so
name|_whichqs
decl|==
name|_qs
name|bbc
name|r0
decl_stmt|,
name|_whichqs
decl_stmt|,
name|sw1
decl|#
name|proc
name|moved
name|via
name|interrupt
name|shal
name|$1
decl_stmt|,
name|r0
decl_stmt|,
name|r1
name|moval
name|_qs
index|[
name|r1
index|]
decl_stmt|,
name|r1
name|movl
argument_list|(
name|r1
argument_list|)
decl_stmt|,
name|r2
decl|#
name|r2
init|=
name|p
operator|=
name|highest
name|pri
name|process
name|remque
operator|*
operator|(
name|r1
operator|)
name|bvs
name|badsw
operator|#
name|make
name|sure
name|something
name|was
name|there
name|bneq
name|sw2
name|shal
name|r0
decl_stmt|,
name|$1
decl_stmt|,
name|r1
name|mcoml
name|r1
decl_stmt|,
name|r1
name|andl2
name|r1
decl_stmt|,
name|_whichqs
decl|#
name|no
name|more
name|procs
name|in
name|this
name|queue
name|sw2
range|:
name|clrl
name|_noproc
name|clrl
name|_runrun
ifdef|#
directive|ifdef
name|notdef
name|tstl
name|P_WCHAN
argument_list|(
name|r2
argument_list|)
operator|#
operator|#
name|firewalls
name|bneq
name|badsw
operator|#
operator|#
name|cmpb
name|P_STAT
argument_list|(
name|r2
argument_list|)
decl_stmt|,
name|$SRUN
decl|##
name|bneq
name|badsw
decl|##
endif|#
directive|endif
name|clrl
name|P_RLINK
argument_list|(
name|r2
argument_list|)
decl|##
name|movl
modifier|*
name|P_ADDR
argument_list|(
name|r2
argument_list|)
decl_stmt|,
name|r0
ifdef|#
directive|ifdef
name|notdef
name|cmpl
name|r0
decl_stmt|,
name|_masterpaddr
decl|#
name|resume
name|of
name|current
name|proc
name|is
name|easy
name|beql
name|res0
endif|#
directive|endif
name|movl
name|r0
decl_stmt|,
name|_masterpaddr
name|shal
name|$PGSHIFT
decl_stmt|,
name|r0
decl_stmt|,
name|r0
decl|#
name|r0
init|=
name|pcbb
argument_list|(
argument|p
argument_list|)
name|brb
name|swresume
comment|/*  * resume(pf)  */
name|ENTRY
argument_list|(
argument|resume
argument_list|,
literal|0
argument_list|)
name|shal
name|$PGSHIFT
decl_stmt|,4
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|r0
decl|#
name|r0
init|=
name|pcbb
argument_list|(
argument|pf
argument_list|)
name|movl
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|fp
decl|#
name|prepare
decl|for
name|rei
name|movl
argument_list|(
name|sp
argument_list|)
decl|+
decl_stmt|,4
argument_list|(
name|sp
argument_list|)
decl_stmt|#
name|saved
name|pc
name|tstl
argument_list|(
name|sp
argument_list|)
decl|+
name|movpsl
decl|4
argument_list|(
name|sp
argument_list|)
name|swresume
range|:
name|mtpr
name|$0x18
decl_stmt|,
name|$IPL
decl|#
name|no
name|interrupts
decl_stmt|,
name|please
name|movl
name|_CMAP2
decl_stmt|,
name|_u
decl|+
name|PCB_CMAP2
decl|#
name|yech
name|REST_ACC
decl|#
name|restore
name|original
name|accumulator
name|svpctx
name|mtpr
name|r0
decl_stmt|,
name|$PCBB
name|ldpctx
name|movl
name|_u
decl|+
name|PCB_CMAP2
decl_stmt|,
name|_CMAP2
decl|#
name|yech
name|mtpr
name|$_CADDR2
decl_stmt|,
name|$TBIS
name|res0
range|:
name|movl
name|_u
operator|+
name|U_PROCP
decl_stmt|,
name|r2
decl|#
name|r2
init|=
name|u
operator|.
name|u_procp
name|tstl
name|P_CKEY
argument_list|(
name|r2
argument_list|)
operator|#
name|does
name|proc
name|have
name|code
name|key
condition|?
name|bneq
literal|1f
name|callf
name|$4
decl_stmt|,
name|_getcodekey
decl|#
name|no
decl_stmt|,
name|give
name|him
name|one
name|movl
name|_u
decl|+
name|U_PROCP
decl_stmt|,
name|r2
decl|#
name|r2
init|=
name|u
operator|.
name|u_procp
name|movl
name|r0
decl_stmt|,
name|P_CKEY
argument_list|(
name|r2
argument_list|)
decl|1
range|:
name|tstl
name|P_DKEY
argument_list|(
name|r2
argument_list|)
operator|#
name|does
name|proc
name|have
name|data
name|key
condition|?
name|bneq
literal|1f
name|callf
name|$4
decl_stmt|,
name|_getdatakey
decl|#
name|no
decl_stmt|,
name|give
name|him
name|one
name|movl
name|_u
decl|+
name|U_PROCP
decl_stmt|,
name|r2
decl|#
name|r2
init|=
name|u
operator|.
name|u_procp
name|movl
name|r0
decl_stmt|,
name|P_DKEY
argument_list|(
name|r2
argument_list|)
decl|1
range|:
name|mtpr
name|P_CKEY
argument_list|(
name|r2
argument_list|)
decl_stmt|,
name|$CCK
decl|#
name|set
name|code
name|cache
name|key
name|mtpr
name|P_DKEY
argument_list|(
name|r2
argument_list|)
decl_stmt|,
name|$DCK
decl|#
name|set
name|data
name|cache
name|key
name|tstl
name|_u
decl|+
name|PCB_SSWAP
name|bneq
name|res1
name|rei
name|res1
range|:
operator|#
name|longjmp
name|to
name|saved
name|context
name|movl
name|_u
operator|+
name|PCB_SSWAP
decl_stmt|,
name|r2
name|clrl
name|_u
decl|+
name|PCB_SSWAP
name|loadr
name|$0x3ff8
decl_stmt|,
argument_list|(
name|r2
argument_list|)
decl_stmt|;
end_for

begin_decl_stmt
name|addl2
name|$44
decl_stmt|,
name|r2
decl|#
name|restore
name|r3
decl|-
name|r13
argument_list|(
name|r13
operator|=
name|fp
argument_list|)
name|movl
argument_list|(
name|r2
argument_list|)
decl_stmt|,
name|r1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|addl2
name|$4
decl_stmt|,
name|r2
decl|#
name|fetch
name|previous
name|sp
modifier|...
name|movab
argument_list|(
name|sp
argument_list|)
decl_stmt|,
name|r0
decl|#
modifier|...
name|and
name|current
name|sp
name|and
name|cmpl
name|r1
decl_stmt|,
name|r0
decl|#
name|check
decl|for
name|credibility
decl_stmt|,
name|bgequ
decl|1f			# if
name|further
name|up
name|stack
modifier|...
name|pushab
decl|2f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|callf
name|$8
decl_stmt|,
name|_panic
decl|#
modifier|...
name|panic
comment|/*NOTREACHED*/
decl|1
range|:
operator|#
name|sp
name|ok
decl_stmt|,
name|complete
decl|return
name|movl
name|r1
decl_stmt|,
name|sp
decl|#
name|restore
name|sp
name|pushl
name|$PSL_PRVMOD
decl|#
name|kernel
name|mode
decl_stmt|,
name|ipl
decl|0
name|pushl
argument_list|(
name|r2
argument_list|)
decl|# return
name|address
name|rei
decl|2
range|:
operator|.
name|asciz
literal|"ldctx"
comment|/*  * {fu,su},{byte,word}  */
name|ENTRY
argument_list|(
argument|fuword
argument_list|,
literal|0
argument_list|)
name|movl
literal|4
operator|(
name|fp
operator|)
decl_stmt|,
name|r1
name|prober
name|$1
decl_stmt|,
argument_list|(
name|r1
argument_list|)
decl_stmt|,
name|$4
decl|#
name|check
name|access
name|beql
name|fserr
decl|#
name|page
name|unreadable
name|bitl
name|$1
decl_stmt|,
name|r1
decl|#
name|check
name|byte
name|alignment
name|bneq
decl|2f			#
name|odd
decl_stmt|, do
name|byte
decl|-
name|word
decl|-
name|byte
name|bitl
name|$2
decl_stmt|,
name|r1
decl|#
name|check
name|word
name|alignment
name|bneq
decl|1f			#
name|odd
decl_stmt|, do
name|in
decl|2
name|words
name|movl
argument_list|(
name|r1
argument_list|)
decl_stmt|,
name|r0
decl|#
name|move
name|longword
name|ret
decl|1
range|:
name|movw
argument_list|(
name|r1
argument_list|)
decl_stmt|,
name|r0
decl|#
name|move
name|two
name|words
name|shal
name|$16
decl_stmt|,
name|r0
decl_stmt|,
name|r0
name|movzwl
decl|2
argument_list|(
name|r1
argument_list|)
decl_stmt|,
name|r1
decl|#
name|orw2
name|sign
name|extends
name|orl2
name|r1
decl_stmt|,
name|r0
name|ret
decl|2
range|:
name|movb
argument_list|(
name|r1
argument_list|)
decl_stmt|,
name|r0
decl|#
name|move
name|byte
decl|-
name|word
decl|-
name|byte
name|shal
name|$24
decl_stmt|,
name|r0
decl_stmt|,
name|r0
name|movzwl
decl|1
argument_list|(
name|r1
argument_list|)
decl_stmt|,
name|r2
decl|#
name|orw2
name|sign
name|extends
name|shal
name|$8
decl_stmt|,
name|r2
decl_stmt|,
name|r2
name|movzbl
decl|3
argument_list|(
name|r1
argument_list|)
decl_stmt|,
name|r1
decl|#
name|orb2
name|sign
name|extends
name|orl2
name|r2
decl_stmt|,
name|r1
name|orl2
name|r1
decl_stmt|,
name|r0
name|ret
name|fserr
range|:
name|mnegl
name|$1
decl_stmt|,
name|r0
name|ret
name|ENTRY
argument_list|(
name|fubyte
argument_list|,
literal|0
argument_list|)
name|prober
name|$1
decl_stmt|,
modifier|*
decl_stmt|4
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|$1
name|beql
name|fserr
name|movzbl
modifier|*
decl|4
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|r0
name|ret
name|ENTRY
argument_list|(
name|suword
argument_list|,
literal|0
argument_list|)
name|movl
decl|4
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|r0
name|probew
name|$1
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|$4
decl|#
name|check
name|access
name|beql
name|fserr
decl|#
name|page
name|unwritable
name|bitl
name|$1
decl_stmt|,
name|r0
decl|#
name|check
name|byte
name|alignment
name|bneq
decl|1f			#
name|odd
name|byte
name|boundary
name|bitl
name|$2
decl_stmt|,
name|r0
decl|#
name|check
name|word
name|alignment
name|beql
decl|2f			#
name|longword
name|aligned
name|movw
decl|8
argument_list|(
name|fp
argument_list|)
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|#
name|move
name|two
name|words
name|movw
decl|10
argument_list|(
name|fp
argument_list|)
decl_stmt|,2
argument_list|(
name|r0
argument_list|)
name|jbr
decl|3f 1
range|:
name|movb
literal|8
operator|(
name|fp
operator|)
decl_stmt|,
argument_list|(
name|r0
argument_list|)
name|movb
decl|9
argument_list|(
name|fp
argument_list|)
decl_stmt|,1
argument_list|(
name|r0
argument_list|)
name|movb
decl|10
argument_list|(
name|fp
argument_list|)
decl_stmt|,2
argument_list|(
name|r0
argument_list|)
name|movb
decl|11
argument_list|(
name|fp
argument_list|)
decl_stmt|,3
argument_list|(
name|r0
argument_list|)
name|jbr
decl|3f 2
range|:
name|movl
literal|8
operator|(
name|fp
operator|)
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|3
range|:
name|clrl
name|r0
name|ret
name|ENTRY
argument_list|(
argument|subyte
argument_list|,
literal|0
argument_list|)
name|probew
name|$1
decl_stmt|,
modifier|*
decl_stmt|4
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|$1
name|beql
name|fserr
name|movb
decl|11
argument_list|(
name|fp
argument_list|)
decl_stmt|,
modifier|*
decl_stmt|4
argument_list|(
name|fp
argument_list|)
name|clrl
name|r0
name|ret
comment|/*  * Copy 1 relocation unit (NBPG bytes)  * from user virtual address to physical address  */
name|ENTRY
argument_list|(
name|copyseg
argument_list|,
literal|0
argument_list|)
name|orl3
name|$PG_V
decl||
name|PG_KW
decl_stmt|,8
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|_CMAP2
name|mtpr
name|$_CADDR2
decl_stmt|,
name|$TBIS
decl|#
name|invalidate
name|entry
decl|for
name|copy
name|MOVC3
argument_list|(
literal|4
operator|(
name|fp
operator|)
argument_list|,
name|$_CADDR2
argument_list|,
name|$NBPG
argument_list|)
name|ret
comment|/*  * Clear a page of memory.  The page frame is specified.  *  * clearseg(pf);  */
name|ENTRY
argument_list|(
name|clearseg
argument_list|,
literal|0
argument_list|)
name|orl3
name|$PG_V
decl||
name|PG_KW
decl_stmt|,4
argument_list|(
name|fp
argument_list|)
decl_stmt|,
name|_CMAP1
decl|#
name|Maps
name|to
name|virtual
name|addr
name|CADDR1
name|mtpr
name|$_CADDR1
decl_stmt|,
name|$TBIS
name|movl
name|$255
decl_stmt|,
name|r0
decl|#
name|r0
init|=
name|limit
name|clrl
name|r1
operator|#
name|r1
operator|=
name|index
name|of
name|cleared
name|long
literal|1
operator|:
name|clrl
name|_CADDR1
index|[
name|r1
index|]
name|aobleq
name|r0
decl_stmt|,
name|r1
decl_stmt|,1b
name|ret
comment|/*  * Check user mode read/write access.  *  * useracc(addr, count, mode)  *	caddr_t addr; int count, mode;  * mode = 0	write access  * mode = 1	read access  */
name|ENTRY
argument_list|(
name|useracc
argument_list|,
literal|0
argument_list|)
name|movl
name|$1
decl_stmt|,
name|r2
decl|#
name|r2
init|=
literal|'user mode'
end_decl_stmt

begin_for
for|for probew/probew probes: 	movl	4
control|(
name|fp
control|)
operator|,
name|r0
operator|#
name|get
name|va
name|movl
literal|8
operator|(
name|fp
operator|)
operator|,
name|r1
operator|#
name|count
name|tstl
literal|12
operator|(
name|fp
operator|)
operator|#
name|test
end_for

begin_for
for|for read access ? 	bneq	userar			# yes 	cmpl	$
control|(
name|CLSIZE
operator|*
name|NBPG
control|)
operator|,
name|r1
operator|#
name|can
name|we
end_for

begin_do
do|do
name|it
name|in
name|one
name|probe
condition|?
name|bgeq
name|uaw2
operator|#
name|yes
name|uaw1
else|:
name|probew
name|r2
operator|,
operator|(
name|r0
operator|)
operator|,
name|$
argument_list|(
argument|CLSIZE*NBPG
argument_list|)
name|beql
name|uaerr
operator|#
name|no
name|access
name|addl2
name|$
argument_list|(
name|CLSIZE
operator|*
name|NBPG
argument_list|)
operator|,
name|r0
name|_ACBL
argument_list|(
argument|$(CLSIZE*NBPG+
literal|1
argument|)
argument_list|,
argument|$(-CLSIZE*NBPG)
argument_list|,
argument|r1
argument_list|,
argument|uaw1
argument_list|)
name|uaw2
operator|:
name|probew
name|r2
operator|,
operator|(
name|r0
operator|)
operator|,
name|r1
name|beql
name|uaerr
name|movl
name|$1
operator|,
name|r0
name|ret
name|userar
operator|:
name|cmpl
name|$
argument_list|(
name|CLSIZE
operator|*
name|NBPG
argument_list|)
operator|,
name|r1
name|bgeq
name|uar2
name|uar1
operator|:
name|prober
name|r2
operator|,
operator|(
name|r0
operator|)
operator|,
name|$
argument_list|(
argument|CLSIZE*NBPG
argument_list|)
name|beql
name|uaerr
name|addl2
name|$
argument_list|(
name|CLSIZE
operator|*
name|NBPG
argument_list|)
operator|,
name|r0
name|_ACBL
argument_list|(
argument|$(CLSIZE*NBPG+
literal|1
argument|)
argument_list|,
argument|$(-CLSIZE*NBPG)
argument_list|,
argument|r1
argument_list|,
argument|uar1
argument_list|)
name|uar2
operator|:
name|prober
name|r2
operator|,
operator|(
name|r0
operator|)
operator|,
name|r1
name|beql
name|uaerr
name|movl
name|$1
operator|,
name|r0
name|ret
name|uaerr
operator|:
name|clrl
name|r0
name|ret
comment|/*  * Check kernel mode read/write access.  *  * kernacc(addr, count, mode)  *	caddr_t addr; int count, mode;  * mode = 0	write access  * mode = 1	read access  */
name|ENTRY
argument_list|(
argument|kernacc
argument_list|,
literal|0
argument_list|)
name|clrl
name|r2
operator|#
name|r2
operator|=
literal|0
name|means
name|kernel
name|mode
name|probe
operator|.
name|jbr
name|probes
operator|#
name|Dijkstra
name|would
name|get
name|gastric
name|distress
name|here
operator|.
comment|/*  * addupc - increment some histogram counter  *	in the profiling buffer  *  * addupc(pc, prof, delta)  *	long pc; short delta; struct uprof *prof;  *   * struct uprof {		# profile arguments   * 	short	*r_base;	# buffer base   * 	unsigned pr_size;	# buffer size   * 	unsigned pr_off;	# pc offset   * 	unsigned pr_scale;	# pc scaling   * }  */
name|ENTRY
argument_list|(
argument|addupc
argument_list|,
literal|0
argument_list|)
name|movl
literal|8
operator|(
name|fp
operator|)
operator|,
name|r2
operator|#
name|r2
name|points
name|to
name|structure
name|subl3
literal|8
operator|(
name|r2
operator|)
operator|,
literal|4
operator|(
name|fp
operator|)
operator|,
name|r0
operator|#
name|r0
operator|=
name|PC
operator|-
name|lowpc
name|jlss
literal|9f
operator|#
name|PC
operator|<
name|lowpc
operator|,
name|out
name|of
name|range
operator|!
name|shrl
name|$1
operator|,
name|r0
operator|,
name|r0
operator|#
name|the
name|unit
name|is
name|words
name|shrl
name|$1
operator|,
literal|12
operator|(
name|r2
operator|)
operator|,
name|r1
operator|#
name|ditto
for|for scale 	emul	r1
operator|,
name|r0
operator|,
name|$0
operator|,
name|r0
name|shrq
name|$14
operator|,
name|r0
operator|,
name|r0
name|tstl
name|r0
operator|#
name|too
name|big
name|jneq
literal|9f
name|cmpl
name|r1
operator|,
literal|4
operator|(
name|r2
operator|)
operator|#
name|Check
name|buffer
name|overflow
name|jgequ
literal|9f
name|probew
name|$1
operator|,
operator|*
literal|0
operator|(
name|r2
operator|)
index|[
name|r1
index|]
operator|,
name|$2
operator|#
name|counter
name|accessible
condition|?
name|jeql
literal|9f
name|shrl
name|$1
operator|,
name|r1
operator|,
name|r1
operator|#
name|make
name|r1
name|word
name|index
name|addw2
literal|14
operator|(
name|fp
operator|)
operator|,
operator|*
literal|0
operator|(
name|r2
operator|)
index|[
name|r1
index|]
literal|9
operator|:
name|ret
comment|/*  * scanc(size, cp, table, mask)  */
name|ENTRY
argument_list|(
argument|scanc
argument_list|,
argument|R3|R4
argument_list|)
name|movl
literal|8
operator|(
name|fp
operator|)
operator|,
name|r0
operator|#
name|r0
operator|=
name|cp
name|addl3
literal|4
operator|(
name|fp
operator|)
operator|,
name|r0
operator|,
name|r2
operator|#
name|end
operator|=
operator|&
name|cp
index|[
name|size
index|]
name|movl
literal|12
operator|(
name|fp
operator|)
operator|,
name|r1
operator|#
name|r1
operator|=
name|table
name|movb
literal|19
operator|(
name|fp
operator|)
operator|,
name|r4
operator|#
name|r4
operator|=
name|mask
name|decl
name|r0
operator|#
operator|--
name|cp
name|jbr
literal|0f
operator|#
name|just
name|like
name|Fortran
operator|...
literal|1
operator|:
operator|#
do|do
block|{
name|movzbl
argument_list|(
name|r0
argument_list|)
operator|,
name|r3
name|bitb
name|r4
operator|,
operator|(
name|r1
operator|)
index|[
name|r3
index|]
operator|#
if|if
condition|(
name|table
index|[
operator|*
name|cp
index|]
operator|&
name|mask
condition|)
name|jneq
literal|2f
operator|#
break|break;
literal|0
operator|:
name|aoblss
name|r2
operator|,
name|r0
operator|,
literal|1b
operator|#
block|}
do|while
condition|(
operator|++
name|cp
operator|<
name|end
condition|)
do|;
do|2: 	subl3	r0
operator|,
do|r2
operator|,
do|r0; ret		# return (end - cp
end_do

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * skpc(mask, size, cp)  */
end_comment

begin_macro
name|ENTRY
argument_list|(
argument|skpc
argument_list|,
literal|0
argument_list|)
end_macro

begin_expr_stmt
name|movl
literal|12
operator|(
name|fp
operator|)
operator|,
name|r0
operator|#
name|r0
operator|=
name|cp
name|addl3
literal|8
operator|(
name|fp
operator|)
operator|,
name|r0
operator|,
name|r1
operator|#
name|r1
operator|=
name|end
operator|=
operator|&
name|cp
index|[
name|size
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|movb
literal|7
operator|(
name|fp
operator|)
operator|,
name|r2
operator|#
name|r2
operator|=
name|mask
name|decl
name|r0
operator|#
operator|--
name|cp
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|jbr
literal|0f
literal|1
operator|:
operator|#
end_expr_stmt

begin_do
do|do
name|cmpb
argument_list|(
name|r0
argument_list|)
operator|,
name|r2
operator|#
if|if
condition|(
operator|*
name|cp
operator|!=
name|mask
condition|)
name|jneq
literal|2f
operator|#
break|break;
do|0:	aoblss	r1
operator|,
do|r0
operator|,
do|1b		# while
condition|(
operator|++
name|cp
operator|<
name|end
condition|)
do|;
end_do

begin_expr_stmt
literal|2
operator|:
name|subl3
name|r0
operator|,
name|r1
operator|,
name|r0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ret
operator|#
end_expr_stmt

begin_return
return|return
operator|(
name|end
operator|-
name|cp
operator|)
return|;
end_return

begin_comment
comment|/*  * locc(mask, size, cp)  */
end_comment

begin_macro
name|ENTRY
argument_list|(
argument|locc
argument_list|,
literal|0
argument_list|)
end_macro

begin_expr_stmt
name|movl
literal|12
operator|(
name|fp
operator|)
operator|,
name|r0
operator|#
name|r0
operator|=
name|cp
name|addl3
literal|8
operator|(
name|fp
operator|)
operator|,
name|r0
operator|,
name|r1
operator|#
name|r1
operator|=
name|end
operator|=
operator|&
name|cp
index|[
name|size
index|]
name|movb
literal|7
operator|(
name|fp
operator|)
operator|,
name|r2
operator|#
name|r2
operator|=
name|mask
name|decl
name|r0
operator|#
operator|--
name|cp
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|jbr
literal|0f
literal|1
operator|:
operator|#
end_expr_stmt

begin_do
do|do
name|cmpb
argument_list|(
name|r0
argument_list|)
operator|,
name|r2
operator|#
if|if
condition|(
operator|*
name|cp
operator|==
name|mask
condition|)
name|jeql
literal|2f
operator|#
break|break;
do|0:	aoblss	r1
operator|,
do|r0
operator|,
do|1b		# while
condition|(
operator|++
name|cp
operator|<
name|end
condition|)
do|;
end_do

begin_expr_stmt
literal|2
operator|:
name|subl3
name|r0
operator|,
name|r1
operator|,
name|r0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ret
operator|#
end_expr_stmt

begin_return
return|return
operator|(
name|end
operator|-
name|cp
operator|)
return|;
end_return

begin_ifdef
ifdef|#
directive|ifdef
name|ALIGN
end_ifdef

begin_include
include|#
directive|include
file|"../tahoealign/align.h"
end_include

begin_expr_stmt
operator|.
name|globl
name|_alignment
comment|/*  * There's an intimate relationship between this piece of code  * and the alignment emulation code (especially the layout  * of local variables in alignment.c! Don't change unless  * you update both this, alignment.h and alignment.c !!  */
name|non_aligned
operator|:
name|orb2
name|$EMULATEALIGN
operator|,
name|_u
operator|+
name|U_EOSYS
name|incl
name|_cnt
operator|+
name|V_TRAP
name|incl
name|_cnt
operator|+
name|V_ALIGN
operator|#
name|count
name|emulated
name|alignment
name|traps
name|moval
literal|4
operator|(
name|sp
operator|)
operator|,
name|_user_psl
name|SAVE_FPSTAT
argument_list|(
literal|4
argument_list|)
operator|#
name|Also
name|zeroes
name|out
name|ret_exception
operator|!
name|pushl
name|$0
operator|#
name|ret_addr
name|pushl
name|$0
operator|#
name|ret_code
name|mfpr
name|$USP
operator|,
operator|-
operator|(
name|sp
operator|)
operator|#
name|user
name|sp
name|callf
name|$4
operator|,
name|_alignment
operator|#
name|call
name|w
operator|/
name|o
name|parms
name|so
name|regs
name|may
name|be
name|modified
comment|/* 	 * We return here after a successful emulation or an exception. 	 * The registers have been restored and we must not alter them 	 * before returning to the user. 	 */
literal|2
operator|:
name|mtpr
argument_list|(
name|sp
argument_list|)
operator|+
operator|,
name|$USP
operator|#
name|restore
name|user
name|sp
name|tstl
literal|8
operator|(
name|sp
operator|)
operator|#
name|Any
name|exception
condition|?
name|bneq
name|got_excp
operator|#
name|Yes
operator|,
name|reflect
name|it
name|back
name|to
name|user
operator|.
name|moval
literal|8
operator|(
name|sp
operator|)
operator|,
name|sp
operator|#
name|pop
literal|2
name|zeroes
name|pushed
name|above
name|REST_FPSTAT
name|xorb2
name|$EMULATEALIGN
operator|,
name|_u
operator|+
name|U_EOSYS
name|bitl
name|$PSL_T
operator|,
literal|4
operator|(
name|sp
operator|)
operator|#
name|check
end_expr_stmt

begin_for
for|for trace bit set 	beql	9f 	CHECK_SFE
control|(
literal|4
control|)
name|pushl
name|$0
name|SAVE_FPSTAT
argument_list|(
literal|8
argument_list|)
name|TRAP
argument_list|(
name|TRCTRAP
argument_list|)
decl|9
range|:
name|rei
name|got_excp
operator|:
operator|#
name|decode
name|exception
name|casel
literal|8
operator|(
name|sp
operator|)
decl_stmt|,
name|$ILL_ADDRMOD
decl_stmt|,
name|$ALIGNMENT
operator|.
name|align
decl|1
name|L1
range|:
operator|.
name|word
name|ill_addrmod
operator|-
name|L1
operator|.
name|word
name|ill_access
operator|-
name|L1
operator|.
name|word
name|ill_oprnd
operator|-
name|L1
operator|.
name|word
name|arithmetic
operator|-
name|L1
operator|.
name|word
name|alignment
operator|-
name|L1
name|brw
name|alignment
operator|#
expr|default
operator|-
name|shouldn
literal|'
end_for

unit|t come here at all !  ill_addrmod:				# No other parameters. Set up stack as 	moval	8(sp),sp		# the HW would do it in a real case. 	REST_FPSTAT 	jbr	_Xresadflt ill_oprnd: 	moval	8(sp),sp 	REST_FPSTAT 	jbr	_Xresopflt alignment: 	moval	8(sp),sp 	REST_FPSTAT 	jbr	align_excp	# NB: going to _Xalignflt would cause loop ill_access: 	/* 	 * Must restore accumulator w/o modifying sp and w/o using 	 * registers.  Solution: copy things needed by REST_FPSTAT. 	 */ 	pushl	20(sp)			# The flags longword 	pushl	20(sp)			# acc_low 	pushl	20(sp)			# acc_high 	pushl	20(sp)			# ret_exception ignored by REST_FPSTAT  	REST_FPSTAT			# Back where we were with the sp ! 	movl	(sp),16(sp)		# code for illegal access 	movl	4(sp),20(sp)		# original virtual address 	moval	16(sp),sp		# Just like the HW would set it up 	jbr	_Xprotflt arithmetic:				# same trickery as above 	pushl	20(sp)			# The flags longword 	pushl	20(sp)			# acc_low 	pushl	20(sp)			# acc_high 	pushl	20(sp)			# ret_exception ignored by REST_FPSTAT  	REST_FPSTAT			# Back where we were with the sp ! 	movl	(sp),20(sp)		# code for arithmetic exception 	moval	20(sp),sp		# Just like the HW would set it up 	jbr	_Xarithtrap #endif SCBVEC(hdintr0): 	CHECK_SFE(4) 	SAVE_FPSTAT(4) 	PUSHR 	incl	_fltintrcnt+(4*0) 	pushl	$0 	callf	$8,_hdintr 	incl	_cnt+V_INTR 	POPR 	REST_FPSTAT 	rei  SCBVEC(hdintr1): 	CHECK_SFE(4) 	SAVE_FPSTAT(4) 	PUSHR 	incl	_fltintrcnt+(4*1) 	pushl	$1 	callf	$8,_hdintr 	incl	_cnt+V_INTR 	POPR 	REST_FPSTAT 	rei  SCBVEC(hdintr2): 	CHECK_SFE(4) 	SAVE_FPSTAT(4) 	PUSHR 	incl	_fltintrcnt+(4*2) 	pushl	$2 	callf	$8,_hdintr 	incl	_cnt+V_INTR 	POPR 	REST_FPSTAT 	rei  SCBVEC(vdintr0): 	CHECK_SFE(4) 	SAVE_FPSTAT(4) 	PUSHR 	incl	_fltintrcnt+(4*3) 	pushl	$0 	callf	$8,_vdintr 	incl	_cnt+V_INTR 	POPR 	REST_FPSTAT 	rei  SCBVEC(vdintr1): 	CHECK_SFE(4) 	SAVE_FPSTAT(4) 	PUSHR 	incl	_fltintrcnt+(4*4) 	pushl	$1 	callf	$8,_vdintr 	incl	_cnt+V_INTR 	POPR 	REST_FPSTAT 	rei  SCBVEC(vdintr2): 	CHECK_SFE(4) 	SAVE_FPSTAT(4) 	PUSHR 	incl	_fltintrcnt+(4*5) 	pushl	$2 	callf	$8,_vdintr 	incl	_cnt+V_INTR 	POPR 	REST_FPSTAT 	rei  SCBVEC(vackint0): 	CHECK_SFE(4) 	SAVE_FPSTAT(4) 	PUSHR 	incl	_fltintrcnt+(4*6) 	pushl	$0 	callf	$8,_vackint 	incl	_cnt+V_INTR 	POPR 	REST_FPSTAT 	rei  SCBVEC(vcmdrsp0): 	CHECK_SFE(4) 	SAVE_FPSTAT(4) 	PUSHR 	incl	_fltintrcnt+(4*7) 	pushl	$0 	callf	$8,_vcmdrsp 	incl	_cnt+V_INTR 	POPR 	REST_FPSTAT 	rei  SCBVEC(vunsol0): 	CHECK_SFE(4) 	SAVE_FPSTAT(4) 	PUSHR 	incl	_fltintrcnt+(4*8) 	pushl	$0 	callf	$8,_vunsol 	incl	_cnt+V_INTR 	POPR 	REST_FPSTAT 	rei  SCBVEC(vackint1): 	CHECK_SFE(4) 	SAVE_FPSTAT(4) 	PUSHR 	incl	_fltintrcnt+(4*9) 	pushl	$1 	callf	$8,_vackint 	incl	_cnt+V_INTR 	POPR 	REST_FPSTAT 	rei  SCBVEC(vcmdrsp1): 	CHECK_SFE(4) 	SAVE_FPSTAT(4) 	PUSHR 	incl	_fltintrcnt+(4*10) 	pushl	$1 	callf	$8,_vcmdrsp 	incl	_cnt+V_INTR 	POPR 	REST_FPSTAT 	rei  SCBVEC(vunsol1): 	CHECK_SFE(4) 	SAVE_FPSTAT(4) 	PUSHR 	incl	_fltintrcnt+(4*11) 	pushl	$1 	callf	$8,_vunsol 	incl	_cnt+V_INTR 	POPR 	REST_FPSTAT 	rei  SCBVEC(exintr0): 	CHECK_SFE(4) 	SAVE_FPSTAT(4) 	PUSHR 	incl	_fltintrcnt+(4*12) 	pushl	$0 	callf	$8,_exintr 	incl	_cnt+V_INTR 	POPR 	REST_FPSTAT 	rei   	.globl	_intrnames  	.globl	_eintrnames 	.data _intrnames: 	.asciz	"clock" 	.asciz	"cnr" 	.asciz	"cnx" 	.asciz	"rmtr" 	.asciz	"rmtx" 	.asciz	"buserr" 	.asciz	"hd0" 	.asciz	"hd1" 	.asciz	"hd2" 	.asciz	"vd0" 	.asciz	"vd1" 	.asciz	"vd2" 	.asciz	"vack0" 	.asciz	"vcmdrsp0" 	.asciz	"vunsol0" 	.asciz	"vack1" 	.asciz	"vcmdrsp1" 	.asciz	"vunsol1" 	.asciz	"ex0" _eintrnames:  	.globl	_intrcnt  	.globl	_eintrcnt 	.align 2 _intrcnt: 	.space	4 * 6 _fltintrcnt: 	.space	4 * 13 _eintrcnt:  	.text
end_unit

