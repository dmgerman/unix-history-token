begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * %sccs.include.redist.c%  *  *	@(#)fdbootblk.c	7.3 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Initial block boot for AT/386 with typical stupid NEC controller.  Works  * only with 3.5 inch diskettes that have 16 or greater sectors/side.  Goal  * is to read in sucessive 7.5Kbytes of bootstrap to execute.  No attempt  * is made to handle disk errors.  */
end_comment

begin_define
define|#
directive|define
name|NOP
value|jmp 1f ; nop ; 1:
end_define

begin_define
define|#
directive|define
name|BIOSRELOC
value|0x7c00
end_define

begin_define
define|#
directive|define
name|start
value|0x70400
end_define

begin_comment
comment|/* Gas does not know about 16 bit opcodes... */
end_comment

begin_comment
comment|/* step 0 force descriptors to bottom of address space */
end_comment

begin_expr_stmt
operator|.
name|byte
literal|0xfa
operator|#
name|cli
operator|.
name|byte
literal|0xb8
operator|,
literal|0x30
operator|,
literal|0x00
operator|#
name|mov
name|$0x0030
operator|,
operator|%
name|ax
operator|.
name|byte
literal|0x8e
operator|,
literal|0xd0
operator|#
name|mov
operator|%
name|ax
operator|,
operator|%
name|ss
operator|.
name|byte
literal|0xbc
operator|,
literal|0x00
operator|,
literal|0x01
operator|#
name|mov
name|$0x0100
operator|,
operator|%
name|sp
name|xorl
operator|%
name|eax
operator|,
operator|%
name|eax
name|movl
operator|%
name|ax
operator|,
operator|%
name|ds
name|movl
operator|%
name|ax
operator|,
operator|%
name|es
comment|/* step 1 load new descriptor table */
operator|.
name|byte
literal|0x2e
operator|#
name|seg
name|cs
operator|.
name|byte
literal|0x0f
operator|,
literal|0x01
operator|,
literal|0x16
operator|#
name|lgdt
name|DS
operator|:
name|d16
operator|.
name|word
name|BIOSRELOC
operator|+
literal|0x4a
operator|#
index|[
name|BIOSRELOC
operator|+
name|GDTptr
index|]
comment|/* step 2 turn on protected mode */
name|smsw
operator|%
name|ax
name|orb
name|$1
operator|,
operator|%
name|al
name|lmsw
operator|%
name|ax
name|jmp
literal|1f
name|nop
literal|1
operator|:
comment|/* step 3  reload segment descriptors */
name|xorl
operator|%
name|eax
operator|,
operator|%
name|eax
name|movb
name|$0x10
operator|,
operator|%
name|al
name|movl
operator|%
name|ax
operator|,
operator|%
name|ds
name|movl
operator|%
name|ax
operator|,
operator|%
name|es
name|movl
operator|%
name|ax
operator|,
operator|%
name|ss
name|word
name|ljmp
name|$0x8
operator|,
name|$
name|BIOSRELOC
operator|+
literal|0x59
operator|#
index|[
name|BIOSRELOC
operator|+
name|reloc
index|]
comment|/*    * Global Descriptor Table contains three descriptors:   * 0x00: Null: not used   * 0x08: Code: code segment starts at 0 and extents for 4 gigabytes   * 0x10: Data: data segment starts at 0 and extends for 4 gigabytes   *		(overlays code)   */
name|GDT
operator|:
name|NullDsc
operator|:
operator|.
name|word
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|#
name|null
name|descriptor
operator|-
name|not
name|used
name|CodeDsc
operator|:
operator|.
name|word
literal|0xFFFF
operator|#
name|limit
name|at
name|maximum
operator|:
operator|(
name|bits
literal|15
operator|:
literal|0
operator|)
operator|.
name|byte
literal|0
operator|,
literal|0
operator|,
literal|0
operator|#
name|base
name|at
literal|0
operator|:
operator|(
name|bits
literal|23
operator|:
literal|0
operator|)
operator|.
name|byte
literal|0x9f
operator|#
name|present
operator|/
name|priv
name|level
literal|0
operator|/
name|code
operator|/
name|conforming
operator|/
name|readable
operator|.
name|byte
literal|0xcf
operator|#
name|page
name|granular
operator|/
expr|default
literal|32
operator|-
name|bit
operator|/
name|limit
argument_list|(
name|bits
literal|19
operator|:
literal|16
argument_list|)
operator|.
name|byte
literal|0
operator|#
name|base
name|at
literal|0
operator|:
operator|(
name|bits
literal|31
operator|:
literal|24
operator|)
name|DataDsc
operator|:
operator|.
name|word
literal|0xFFFF
operator|#
name|limit
name|at
name|maximum
operator|:
operator|(
name|bits
literal|15
operator|:
literal|0
operator|)
operator|.
name|byte
literal|0
operator|,
literal|0
operator|,
literal|0
operator|#
name|base
name|at
literal|0
operator|:
operator|(
name|bits
literal|23
operator|:
literal|0
operator|)
operator|.
name|byte
literal|0x93
operator|#
name|present
operator|/
name|priv
name|level
literal|0
operator|/
name|data
operator|/
name|expand
operator|-
name|up
operator|/
name|writeable
operator|.
name|byte
literal|0xcf
operator|#
name|page
name|granular
operator|/
expr|default
literal|32
operator|-
name|bit
operator|/
name|limit
argument_list|(
name|bits
literal|19
operator|:
literal|16
argument_list|)
operator|.
name|byte
literal|0
operator|#
name|base
name|at
literal|0
operator|:
operator|(
name|bits
literal|31
operator|:
literal|24
operator|)
comment|/*   * Global Descriptor Table pointer  *  contains 6-byte pointer information for LGDT  */
name|GDTptr
operator|:
operator|.
name|word
literal|0x17
operator|#
name|limit
name|to
name|three
literal|8
name|byte
name|selectors
argument_list|(
name|null
argument_list|,
name|code
argument_list|,
name|data
argument_list|)
operator|.
name|long
name|BIOSRELOC
operator|+
literal|0x32
operator|#
index|[
name|BIOSRELOC
operator|+
name|GDT
index|]
name|readcmd
operator|:
operator|.
name|byte
literal|0xe6
operator|,
literal|0x00
operator|,
literal|0x00
operator|,
literal|0x00
operator|,
literal|0x00
operator|,
literal|0x02
operator|,
literal|18
operator|,
literal|0x1b
operator|,
literal|0xff
comment|/* step 4 relocate to final bootstrap address. */
name|reloc
operator|:
name|movl
name|$
name|BIOSRELOC
operator|,
operator|%
name|esi
name|movl
name|$
name|RELOC
operator|,
operator|%
name|edi
name|movl
name|$512
operator|,
operator|%
name|ecx
name|rep
name|movsb
name|pushl
name|$dodisk
name|ret
comment|/* step 5 load remaining 15 sectors off disk */
name|dodisk
operator|:
name|movl
name|$0x70200
operator|,
operator|%
name|edi
name|xorl
operator|%
name|ebx
operator|,
operator|%
name|ebx
name|incb
operator|%
name|bl
name|incb
operator|%
name|bl
name|movb
name|$0x20
operator|,
operator|%
name|al
operator|#
end_expr_stmt

begin_do
do|do
name|a
name|eoi
name|outb
operator|%
name|al
operator|,
name|$0x20
name|NOP
name|movb
name|$0x07
operator|,
operator|%
name|al
name|outb
operator|%
name|al
operator|,
name|$0x21
name|NOP
literal|8
operator|:
name|movb
operator|%
name|bl
operator|,
name|readcmd
operator|+
literal|4
name|movl
operator|%
name|edi
operator|,
operator|%
name|ecx
comment|/* Set read/write bytes */
name|xorl
operator|%
name|edx
operator|,
operator|%
name|edx
name|movb
name|$0x0c
operator|,
operator|%
name|dl
operator|#
name|outb
argument_list|(
literal|0xC
argument_list|,
literal|0x46
argument_list|)
expr_stmt|;
do|outb(0xB
operator|,
do|0x46
end_do

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|movb
name|$0x46
decl_stmt|,%
name|al
name|outb
decl|%
name|al
decl_stmt|,%
name|dx
name|NOP
name|decb
decl|%
name|dx
name|outb
decl|%
name|al
decl_stmt|,%
name|dx
comment|/* Send start address */
name|movb
name|$0x04
decl_stmt|,%
name|dl
decl|#
name|outb
argument_list|(
literal|0x4
argument_list|,
name|addr
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|movb
operator|%
name|cl
operator|,
operator|%
name|al
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
name|movb
operator|%
name|ch
operator|,
operator|%
name|al
operator|#
name|outb
argument_list|(
literal|0x4
argument_list|,
name|addr
operator|>>
literal|8
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
name|rorl
name|$8
operator|,
operator|%
name|ecx
operator|#
name|outb
argument_list|(
literal|0x81
argument_list|,
name|addr
operator|>>
literal|16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|movb
operator|%
name|ch
operator|,
operator|%
name|al
name|outb
operator|%
name|al
operator|,
name|$0x81
name|NOP
comment|/* Send count */
name|movb
name|$0x05
operator|,
operator|%
name|dl
operator|#
name|outb
argument_list|(
literal|0x5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xorl
operator|%
name|eax
operator|,
operator|%
name|eax
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
name|movb
name|$2
operator|,
operator|%
name|al
operator|#
name|outb
argument_list|(
literal|0x5
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
comment|/* set channel 2 */
empty|# movb	$2,%al		# outb(0x0A,2);
name|outb
operator|%
name|al
operator|,
name|$0x0A
name|NOP
comment|/* issue read command to fdc */
name|movw
name|$0x3f4
operator|,
operator|%
name|dx
name|movl
name|$readcmd
operator|,
operator|%
name|esi
name|xorl
operator|%
name|ecx
operator|,
operator|%
name|ecx
name|movb
name|$9
operator|,
operator|%
name|cl
literal|2
operator|:
name|inb
operator|%
name|dx
operator|,
operator|%
name|al
name|NOP
name|testb
name|$0x80
operator|,
operator|%
name|al
name|jz
literal|2b
name|incb
operator|%
name|dx
name|movl
argument_list|(
operator|%
name|esi
argument_list|)
operator|,
operator|%
name|al
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
name|incl
operator|%
name|esi
name|decb
operator|%
name|dx
name|loop
literal|2b
comment|/* watch the icu looking for an interrupt signalling completion */
name|xorl
operator|%
name|edx
operator|,
operator|%
name|edx
name|movb
name|$0x20
operator|,
operator|%
name|dl
literal|2
operator|:
name|movb
name|$0xc
operator|,
operator|%
name|al
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
name|inb
operator|%
name|dx
operator|,
operator|%
name|al
name|NOP
name|andb
name|$0x7f
operator|,
operator|%
name|al
name|cmpb
name|$6
operator|,
operator|%
name|al
name|jne
literal|2b
name|movb
name|$0x20
operator|,
operator|%
name|al
operator|#
end_expr_stmt

begin_do
do|do
name|a
name|eoi
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
name|movl
name|$0x3f4
operator|,
operator|%
name|edx
name|xorl
operator|%
name|ecx
operator|,
operator|%
name|ecx
name|movb
name|$7
operator|,
operator|%
name|cl
literal|2
operator|:
name|inb
operator|%
name|dx
operator|,
operator|%
name|al
name|NOP
name|andb
name|$0xC0
operator|,
operator|%
name|al
name|cmpb
name|$0xc0
operator|,
operator|%
name|al
name|jne
literal|2b
name|incb
operator|%
name|dx
name|inb
operator|%
name|dx
operator|,
operator|%
name|al
name|decb
operator|%
name|dx
name|loop
literal|2b
comment|/* extract the status bytes after the read. must we do this? */
name|addw
name|$0x200
operator|,
operator|%
name|edi
operator|#
name|next
name|addr
name|to
name|load
name|to
name|incb
operator|%
name|bl
name|cmpb
name|$16
operator|,
operator|%
name|bl
name|jle
literal|8b
comment|/* for clever bootstrap, dig out boot unit and cylinder */
name|pushl
name|$0
name|pushl
name|$0
comment|/* fd controller is major device 2 */
name|pushl
name|$2
comment|/* dev */
comment|/* sorry, no flags at this point! */
name|pushl
name|$
name|start
name|ret
comment|/* main (dev, unit, off) */
name|ebootblkcode
operator|:
comment|/* remaining space usable for a disk label */
operator|.
name|space
literal|510
operator|-
literal|310
comment|/* would be nice if .space 512-2-. worked */
operator|.
name|word
literal|0xaa55
comment|/* signature -- used by BIOS ROM */
name|ebootblk
operator|:
end_do

begin_comment
comment|/* MUST BE EXACTLY 0x200 BIG FOR SURE */
end_comment

end_unit

