begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Tim L. Tucker  *  * %sccs.include.noredist.c%  *  *	@(#)if_we.c	5.1 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Modification history  *  * 8/28/89 - Initial version, Tim L Tucker  */
end_comment

begin_include
include|#
directive|include
file|"wd.h"
end_include

begin_if
if|#
directive|if
name|NWD
operator|>
literal|0
end_if

begin_comment
comment|/*  * Western Digital 8003 ethernet/starlan adapter  *  * Supports the following interface cards:  * WD8003E, WD8003EBT, WD8003S, WD8003SBT  *  * The Western Digital card is one of many AT/MCA ethernet interfaces  * based on the National N8390/NS32490 Network Interface chip set.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|"../netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/if_ether.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|"../netns/ns.h"
end_include

begin_include
include|#
directive|include
file|"../netns/ns_if.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"if_wdreg.h"
end_include

begin_include
include|#
directive|include
file|"../isa/isavar.h"
end_include

begin_comment
comment|/*  * This constant should really be 60 because the wd adds 4 bytes of crc.  * However when set to 60 our packets are ignored by deuna's , 3coms are  * okay ??????????????????????????????????????????  */
end_comment

begin_define
define|#
directive|define
name|ETHER_MIN_LEN
value|64
end_define

begin_define
define|#
directive|define
name|ETHER_ADDR_LEN
value|6
end_define

begin_define
define|#
directive|define
name|ETHER_HDR_SIZE
value|14
end_define

begin_comment
comment|/*  * Ethernet software status per interface.  *  * Each interface is referenced by a network interface structure,  * qe_if, which the routing code uses to locate the interface.  * This structure contains the output queue for the interface, its address, ...  */
end_comment

begin_struct
struct|struct
name|wd_softc
block|{
name|struct
name|arpcom
name|wd_ac
decl_stmt|;
comment|/* Ethernet common part 	*/
define|#
directive|define
name|wd_if
value|wd_ac.ac_if
comment|/* network-visible interface 	*/
define|#
directive|define
name|wd_addr
value|wd_ac.ac_enaddr
comment|/* hardware Ethernet address 	*/
name|u_char
name|wd_flags
decl_stmt|;
comment|/* software state		*/
define|#
directive|define
name|WDF_RUNNING
value|0x01
define|#
directive|define
name|WDF_TXBUSY
value|0x02
name|u_char
name|wd_type
decl_stmt|;
comment|/* interface type code		*/
name|u_short
name|wd_vector
decl_stmt|;
comment|/* interrupt vector 		*/
name|caddr_t
name|wd_io_ctl_addr
decl_stmt|;
comment|/* i/o bus address, control	*/
name|caddr_t
name|wd_io_nic_addr
decl_stmt|;
comment|/* i/o bus address, NS32490	*/
name|caddr_t
name|wd_vmem_addr
decl_stmt|;
comment|/* card RAM virtual memory base */
name|u_long
name|wd_vmem_size
decl_stmt|;
comment|/* card RAM bytes		*/
name|caddr_t
name|wd_vmem_ring
decl_stmt|;
comment|/* receive ring RAM vaddress	*/
block|}
name|wd_softc
index|[
name|NWD
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|wdprobe
argument_list|()
decl_stmt|,
name|wdattach
argument_list|()
decl_stmt|,
name|wdintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wdinit
argument_list|()
decl_stmt|,
name|wdoutput
argument_list|()
decl_stmt|,
name|wdioctl
argument_list|()
decl_stmt|,
name|wdreset
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Probe the WD8003 to see if it's there  */
end_comment

begin_macro
name|wdprobe
argument_list|(
argument|reg
argument_list|,
argument|is
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|is
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|wd_softc
modifier|*
name|sc
init|=
operator|&
name|wd_softc
index|[
name|is
operator|->
name|is_unit
index|]
decl_stmt|;
name|union
name|wd_mem_sel
name|wdm
decl_stmt|;
name|u_char
name|sum
decl_stmt|;
comment|/* 	 * Here we check the card ROM, if the checksum passes, and the 	 * type code and ethernet address check out, then we know we have 	 * a wd8003 card. 	 * 	 * Autoconfiguration: No warning message is printed on error. 	 */
for|for
control|(
name|sum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|sum
operator|+=
name|INB
argument_list|(
name|reg
operator|+
name|WD_ROM_OFFSET
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
name|WD_CHECKSUM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|wd_type
operator|=
name|INB
argument_list|(
name|reg
operator|+
name|WD_ROM_OFFSET
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|wd_type
operator|!=
name|WD_ETHER
operator|)
operator|&&
operator|(
name|sc
operator|->
name|wd_type
operator|!=
name|WD_STARLAN
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Setup card RAM area and i/o addresses 	 * Kernel Virtual to segment C0000-DFFFF????? 	 */
name|sc
operator|->
name|wd_io_ctl_addr
operator|=
name|reg
expr_stmt|;
name|sc
operator|->
name|wd_io_nic_addr
operator|=
name|sc
operator|->
name|wd_io_ctl_addr
operator|+
name|WD_NIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|wd_vector
operator|=
name|is
operator|->
name|is_vector
expr_stmt|;
name|sc
operator|->
name|wd_vmem_addr
operator|=
operator|(
name|caddr_t
operator|)
name|is
operator|->
name|is_mem
expr_stmt|;
name|sc
operator|->
name|wd_vmem_size
operator|=
name|is
operator|->
name|is_memsize
expr_stmt|;
name|sc
operator|->
name|wd_vmem_ring
operator|=
name|sc
operator|->
name|wd_vmem_addr
operator|+
operator|(
name|WD_PAGE_SIZE
operator|*
name|WD_TXBUF_SIZE
operator|)
expr_stmt|;
comment|/* 	 * Save board ROM station address 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|wd_addr
index|[
name|i
index|]
operator|=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_ctl_addr
operator|+
name|WD_ROM_OFFSET
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Mapin interface memory, setup memory select register 	 */
name|wdm
operator|.
name|ms_addr
operator|=
operator|(
name|u_long
operator|)
name|sc
operator|->
name|wd_vmem_addr
operator|>>
literal|13
expr_stmt|;
name|wdm
operator|.
name|ms_enable
operator|=
literal|1
expr_stmt|;
name|wdm
operator|.
name|ms_reset
operator|=
literal|0
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_ctl_addr
argument_list|,
name|wdm
operator|.
name|ms_byte
argument_list|)
expr_stmt|;
comment|/* 	 * clear interface memory, then sum to make sure its valid 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|wd_vmem_size
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|wd_vmem_addr
index|[
name|i
index|]
operator|=
literal|0x0
expr_stmt|;
for|for
control|(
name|sum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|wd_vmem_size
condition|;
operator|++
name|i
control|)
name|sum
operator|+=
name|sc
operator|->
name|wd_vmem_addr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
literal|0x0
condition|)
block|{
name|printf
argument_list|(
literal|"wd%d: wd8003 dual port RAM address error\n"
argument_list|,
name|is
operator|->
name|is_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|WD_IO_PORTS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_macro
name|wdattach
argument_list|(
argument|is
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|is
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|wd_softc
modifier|*
name|sc
init|=
operator|&
name|wd_softc
index|[
name|is
operator|->
name|is_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|wd_if
decl_stmt|;
comment|/* 	 * Initialize ifnet structure 	 */
name|ifp
operator|->
name|if_unit
operator|=
name|is
operator|->
name|is_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"wd"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_NOTRAILERS
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|wdinit
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|wdoutput
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|wdioctl
expr_stmt|;
name|ifp
operator|->
name|if_reset
operator|=
name|wdreset
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
literal|0
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Banner... 	 */
name|printf
argument_list|(
literal|"wd%d: %s, hardware address %s\n"
argument_list|,
name|is
operator|->
name|is_unit
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|wd_type
operator|==
name|WD_ETHER
operator|)
condition|?
literal|"ethernet"
else|:
literal|"starlan"
operator|)
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|wd_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reset of interface.  */
end_comment

begin_macro
name|wdreset
argument_list|(
argument|unit
argument_list|,
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|unit
operator|>=
name|NWD
condition|)
return|return;
name|printf
argument_list|(
literal|"wd%d: reset\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|wd_softc
index|[
name|unit
index|]
operator|.
name|wd_flags
operator|&=
operator|~
name|WDF_RUNNING
expr_stmt|;
name|wdinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Take interface offline.  */
end_comment

begin_macro
name|wdstop
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|wd_softc
modifier|*
name|sc
init|=
operator|&
name|wd_softc
index|[
name|unit
index|]
decl_stmt|;
name|union
name|wd_command
name|wdcmd
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Shutdown NS32490 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|wdcmd
operator|.
name|cs_byte
operator|=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wdcmd
operator|.
name|cs_stp
operator|=
literal|1
expr_stmt|;
name|wdcmd
operator|.
name|cs_sta
operator|=
literal|0
expr_stmt|;
name|wdcmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wdcmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialization of interface (really just NS32490).   */
end_comment

begin_macro
name|wdinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|wd_softc
modifier|*
name|sc
init|=
operator|&
name|wd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|wd_if
decl_stmt|;
name|union
name|wd_command
name|wdcmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
comment|/* address not known */
if|if
condition|(
name|ifp
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* already running */
if|if
condition|(
name|sc
operator|->
name|wd_flags
operator|&
name|WDF_RUNNING
condition|)
return|return;
comment|/* 	 * Initialize NS32490 in order given in NSC NIC manual. 	 * this is stock code...please see the National manual for details. 	 */
name|s
operator|=
name|splhi
argument_list|()
expr_stmt|;
name|wdcmd
operator|.
name|cs_byte
operator|=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wdcmd
operator|.
name|cs_stp
operator|=
literal|1
expr_stmt|;
name|wdcmd
operator|.
name|cs_sta
operator|=
literal|0
expr_stmt|;
name|wdcmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wdcmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_DCR
argument_list|,
name|WD_D_CONFIG
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_RBCR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_RBCR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_RCR
argument_list|,
name|WD_R_MON
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_TCR
argument_list|,
name|WD_T_CONFIG
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_TPSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_PSTART
argument_list|,
name|WD_TXBUF_SIZE
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_PSTOP
argument_list|,
name|sc
operator|->
name|wd_vmem_size
operator|/
name|WD_PAGE_SIZE
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|,
name|WD_TXBUF_SIZE
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_IMR
argument_list|,
name|WD_I_CONFIG
argument_list|)
expr_stmt|;
name|wdcmd
operator|.
name|cs_ps
operator|=
literal|1
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wdcmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P1_PAR0
operator|+
name|i
argument_list|,
name|sc
operator|->
name|wd_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
comment|/* == broadcast addr */
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P1_MAR0
operator|+
name|i
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P1_CURR
argument_list|,
name|WD_TXBUF_SIZE
argument_list|)
expr_stmt|;
name|wdcmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|wdcmd
operator|.
name|cs_stp
operator|=
literal|0
expr_stmt|;
name|wdcmd
operator|.
name|cs_sta
operator|=
literal|1
expr_stmt|;
name|wdcmd
operator|.
name|cs_rd
operator|=
literal|0x4
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P1_COMMAND
argument_list|,
name|wdcmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_RCR
argument_list|,
name|WD_R_CONFIG
argument_list|)
expr_stmt|;
comment|/* 	 * Take the interface out of reset, program the vector,  	 * enable interrupts, and tell the world we are up. 	 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
operator||
name|IFF_RUNNING
expr_stmt|;
name|sc
operator|->
name|wd_flags
operator||=
name|WDF_RUNNING
expr_stmt|;
name|sc
operator|->
name|wd_flags
operator|&=
operator|~
name|WDF_TXBUSY
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start output on interface.  */
end_comment

begin_macro
name|wdstart
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|wd_softc
modifier|*
name|sc
init|=
operator|&
name|wd_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
specifier|register
name|caddr_t
name|buffer
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|,
name|s
decl_stmt|;
name|union
name|wd_command
name|wdcmd
decl_stmt|;
comment|/* 	 * The NS32490 has only one transmit buffer, if it is busy we 	 * must wait until the transmit interrupt completes. 	 */
name|s
operator|=
name|splhi
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wd_flags
operator|&
name|WDF_TXBUSY
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|wd_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|wd_flags
operator||=
name|WDF_TXBUSY
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the mbuf chain into the transmit buffer 	 */
name|buffer
operator|=
name|sc
operator|->
name|wd_vmem_addr
expr_stmt|;
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
comment|/* 	 * If this was a broadcast packet loop it 	 * back because the hardware can't hear its own 	 * transmits. 	 */
if|if
condition|(
name|bcmp
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
operator|->
name|ether_dhost
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|etherbroadcastaddr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wdread
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Init transmit length registers, and set transmit start flag. 	 */
name|s
operator|=
name|splhi
argument_list|()
expr_stmt|;
name|len
operator|=
name|MAX
argument_list|(
name|len
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
name|wdcmd
operator|.
name|cs_byte
operator|=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wdcmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wdcmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_TBCR0
argument_list|,
name|len
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_TBCR1
argument_list|,
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|wdcmd
operator|.
name|cs_txp
operator|=
literal|1
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wdcmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Ethernet interface interrupt processor  */
end_comment

begin_macro
name|wdintr
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|wd_softc
modifier|*
name|sc
init|=
operator|&
name|wd_softc
index|[
name|unit
index|]
decl_stmt|;
name|union
name|wd_command
name|wdcmd
decl_stmt|;
name|union
name|wd_interrupt
name|wdisr
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* disable onboard interrupts, then get interrupt status */
name|s
operator|=
name|splhi
argument_list|()
expr_stmt|;
name|wdcmd
operator|.
name|cs_byte
operator|=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wdcmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wdcmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_IMR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wdisr
operator|.
name|is_byte
operator|=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_ISR
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* transmit error */
if|if
condition|(
name|wdisr
operator|.
name|is_txe
condition|)
block|{
comment|/* need to read these registers to clear status */
name|sc
operator|->
name|wd_if
operator|.
name|if_collisions
operator|+=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_TBCR0
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|wd_if
operator|.
name|if_oerrors
expr_stmt|;
block|}
comment|/* receiver error */
if|if
condition|(
name|wdisr
operator|.
name|is_rxe
condition|)
block|{
comment|/* need to read these registers to clear status */
operator|(
name|void
operator|)
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
literal|0xD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
literal|0xE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
literal|0xF
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|wd_if
operator|.
name|if_ierrors
expr_stmt|;
block|}
comment|/* normal transmit complete */
if|if
condition|(
name|wdisr
operator|.
name|is_ptx
condition|)
name|wdtint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* normal receive notification */
if|if
condition|(
name|wdisr
operator|.
name|is_prx
condition|)
name|wdrint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* try to start transmit */
name|wdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* re-enable onboard interrupts */
name|wdcmd
operator|.
name|cs_byte
operator|=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wdcmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wdcmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_IMR
argument_list|,
name|WD_I_CONFIG
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Ethernet interface transmit interrupt.  */
end_comment

begin_macro
name|wdtint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|wd_softc
modifier|*
name|sc
init|=
operator|&
name|wd_softc
index|[
name|unit
index|]
decl_stmt|;
comment|/* 	 * Do some statistics (assume page zero of NIC mapped in) 	 */
name|sc
operator|->
name|wd_flags
operator|&=
operator|~
name|WDF_TXBUSY
expr_stmt|;
name|sc
operator|->
name|wd_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
operator|++
name|sc
operator|->
name|wd_if
operator|.
name|if_opackets
expr_stmt|;
name|sc
operator|->
name|wd_if
operator|.
name|if_collisions
operator|+=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_TBCR0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  */
end_comment

begin_macro
name|wdrint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|wd_softc
modifier|*
name|sc
init|=
operator|&
name|wd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|m
decl_stmt|;
name|int
name|mlen
decl_stmt|,
name|len
decl_stmt|,
name|count
decl_stmt|;
name|u_char
name|bnry
decl_stmt|,
name|curr
decl_stmt|;
name|union
name|wd_command
name|wdcmd
decl_stmt|;
name|struct
name|wd_ring
modifier|*
name|wdr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|caddr_t
name|pkt
decl_stmt|,
name|endp
decl_stmt|;
comment|/* 	 * Traverse the receive ring looking for packets to pass back. 	 * The search is complete when we find a descriptor not in use. 	 */
name|wdcmd
operator|.
name|cs_byte
operator|=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wdcmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wdcmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|bnry
operator|=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|)
expr_stmt|;
name|wdcmd
operator|.
name|cs_ps
operator|=
literal|1
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wdcmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|curr
operator|=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P1_CURR
argument_list|)
expr_stmt|;
while|while
condition|(
name|bnry
operator|!=
name|curr
condition|)
block|{
comment|/* get pointer to this buffer header structure */
name|wdr
operator|=
operator|(
expr|struct
name|wd_ring
operator|*
operator|)
operator|(
name|sc
operator|->
name|wd_vmem_addr
operator|+
operator|(
name|bnry
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
name|len
operator|=
name|wdr
operator|->
name|wd_count
operator|-
literal|4
expr_stmt|;
comment|/* count includes CRC */
name|pkt
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|wdr
operator|+
literal|1
argument_list|)
operator|-
literal|2
expr_stmt|;
comment|/* 2 - word align pkt data */
name|count
operator|=
name|len
operator|+
literal|2
expr_stmt|;
comment|/* copy two extra bytes */
name|endp
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|sc
operator|->
name|wd_vmem_addr
operator|+
name|sc
operator|->
name|wd_vmem_size
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|wd_if
operator|.
name|if_ipackets
expr_stmt|;
comment|/* pull packet out of dual ported RAM */
name|m
operator|=
operator|&
name|m0
expr_stmt|;
name|m0
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/* drop chain if can't get another buffer */
name|MGET
argument_list|(
operator|*
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
goto|goto
name|outofbufs
goto|;
block|}
comment|/* fill mbuf and attach to packet list */
name|mlen
operator|=
name|MIN
argument_list|(
name|MLEN
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|mlen
operator|=
name|MIN
argument_list|(
name|mlen
argument_list|,
name|endp
operator|-
name|pkt
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|pkt
argument_list|,
name|mtod
argument_list|(
operator|*
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|m
operator|)
operator|->
name|m_len
operator|=
name|mlen
expr_stmt|;
name|m
operator|=
operator|&
operator|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_next
operator|)
expr_stmt|;
name|pkt
operator|+=
name|mlen
expr_stmt|;
name|count
operator|-=
name|mlen
expr_stmt|;
comment|/* wrap memory pointer around circ buffer */
if|if
condition|(
name|pkt
operator|==
name|endp
condition|)
name|pkt
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|wd_vmem_ring
expr_stmt|;
block|}
comment|/* skip aligment bytes, send packet up to higher levels */
if|if
condition|(
name|m0
operator|!=
literal|0
condition|)
block|{
name|m0
operator|->
name|m_off
operator|+=
literal|2
expr_stmt|;
name|wdread
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
name|outofbufs
label|:
comment|/* advance on chip Boundry register */
name|bnry
operator|=
name|wdr
operator|->
name|wd_next_packet
expr_stmt|;
name|wdcmd
operator|.
name|cs_byte
operator|=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wdcmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wdcmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
comment|/* watch out for NIC overflow, reset Boundry if invalid */
if|if
condition|(
operator|(
name|bnry
operator|-
literal|1
operator|)
operator|<
name|WD_TXBUF_SIZE
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
name|wdreset
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|,
operator|(
name|sc
operator|->
name|wd_vmem_size
operator|/
name|WD_PAGE_SIZE
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|,
name|bnry
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* refresh our copy of CURR */
name|wdcmd
operator|.
name|cs_ps
operator|=
literal|1
expr_stmt|;
name|OUTB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wdcmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|curr
operator|=
name|INB
argument_list|(
name|sc
operator|->
name|wd_io_nic_addr
operator|+
name|WD_P1_CURR
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Ethernet output routine.  * Encapsulate a packet of type family for the local net.  */
end_comment

begin_macro
name|wdoutput
argument_list|(
argument|ifp
argument_list|,
argument|m0
argument_list|,
argument|dst
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|,
name|s
decl_stmt|,
name|error
decl_stmt|;
name|u_char
name|edst
index|[
literal|6
index|]
decl_stmt|;
name|struct
name|in_addr
name|idst
decl_stmt|;
specifier|register
name|struct
name|wd_softc
modifier|*
name|sc
init|=
operator|&
name|wd_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
specifier|register
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|usetrailers
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
operator|)
operator|!=
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
condition|)
block|{
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
comment|/* Note: we ignore usetrailers */
name|idst
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin_addr
expr_stmt|;
if|if
condition|(
operator|!
name|arpresolve
argument_list|(
operator|&
name|sc
operator|->
name|wd_ac
argument_list|,
name|m
argument_list|,
operator|&
name|idst
argument_list|,
name|edst
argument_list|,
operator|&
name|usetrailers
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* if not yet resolved */
name|type
operator|=
name|ETHERTYPE_IP
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
name|type
operator|=
name|ETHERTYPE_NS
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_ns
operator|*
operator|)
name|dst
operator|)
operator|->
name|sns_addr
operator|.
name|x_host
operator|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|edst
argument_list|,
sizeof|sizeof
argument_list|(
name|edst
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_UNSPEC
case|:
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|dst
operator|->
name|sa_data
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|eh
operator|->
name|ether_dhost
argument_list|,
operator|(
name|caddr_t
operator|)
name|edst
argument_list|,
sizeof|sizeof
argument_list|(
name|edst
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"wd%d: can't handle af%d\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Add local net header.  If no space in first mbuf, 	 * allocate another. 	 */
if|if
condition|(
name|m
operator|->
name|m_off
operator|>
name|MMAXOFF
operator|||
name|MMINOFF
operator|+
name|ETHER_HDR_SIZE
operator|>
name|m
operator|->
name|m_off
condition|)
block|{
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|m
operator|->
name|m_off
operator|=
name|MMINOFF
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|ETHER_HDR_SIZE
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_off
operator|-=
name|ETHER_HDR_SIZE
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|ETHER_HDR_SIZE
expr_stmt|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|type
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|edst
argument_list|,
operator|(
name|caddr_t
operator|)
name|eh
operator|->
name|ether_dhost
argument_list|,
sizeof|sizeof
argument_list|(
name|edst
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|wd_addr
argument_list|,
operator|(
name|caddr_t
operator|)
name|eh
operator|->
name|ether_shost
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wd_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Queue message on interface, and start output if interface 	 * not yet active. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wdstart
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_expr_stmt
name|wdioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|wd_softc
modifier|*
name|sc
init|=
operator|&
name|wd_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|wdinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|wd_addr
operator|)
expr_stmt|;
else|else
name|wdsetaddr
argument_list|(
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|wd_flags
operator|&
name|WDF_RUNNING
operator|)
condition|)
block|{
name|wdstop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
name|IFF_UP
operator|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|wd_flags
operator|&
name|WDF_RUNNING
operator|)
operator|==
literal|0
operator|)
condition|)
name|wdinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * set ethernet address for unit  */
end_comment

begin_macro
name|wdsetaddr
argument_list|(
argument|physaddr
argument_list|,
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|physaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|wd_softc
modifier|*
name|sc
init|=
operator|&
name|wd_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Rewrite ethernet address, and then force restart of NIC 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|wd_addr
index|[
name|i
index|]
operator|=
name|physaddr
index|[
name|i
index|]
expr_stmt|;
name|sc
operator|->
name|wd_flags
operator|&=
operator|~
name|WDF_RUNNING
expr_stmt|;
name|wdinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Pass a packet to the higher levels.  * NO TRAILER PROTOCOL!  */
end_comment

begin_expr_stmt
name|wdread
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
specifier|register
expr|struct
name|wd_softc
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|scn
decl_stmt|,
name|type
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|inq
decl_stmt|;
comment|/* 	 * Get ethernet protocol type out of ether header 	 */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|type
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
comment|/* 	 * Drop ethernet header 	 */
name|m
operator|->
name|m_off
operator|+=
name|ETHER_HDR_SIZE
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|ETHER_HDR_SIZE
expr_stmt|;
comment|/* 	 * Insert ifp pointer at start of packet 	 */
name|m
operator|->
name|m_off
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ifnet
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ifnet
operator|*
argument_list|)
expr_stmt|;
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ifnet
operator|*
operator|*
argument_list|)
operator|)
operator|=
operator|&
name|sc
operator|->
name|wd_if
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
name|scn
operator|=
name|NETISR_IP
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_ARP
case|:
name|arpinput
argument_list|(
operator|&
name|sc
operator|->
name|wd_ac
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|ETHERTYPE_NS
case|:
name|scn
operator|=
name|NETISR_NS
expr_stmt|;
name|inq
operator|=
operator|&
name|nsintrq
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|inq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|inq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|IF_ENQUEUE
argument_list|(
name|inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|scn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

