begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * %sccs.include.redist.c%  *  *	@(#)wd.c	7.4 (Berkeley) %G%  */
end_comment

begin_comment
comment|/* TODO:peel out buffer at low ipl,    speed improvement, rewrite to clean code from garbage artifacts */
end_comment

begin_include
include|#
directive|include
file|"wd.h"
end_include

begin_if
if|#
directive|if
name|NWD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkbad.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/wdreg.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_define
define|#
directive|define
name|RETRIES
value|5
end_define

begin_comment
comment|/* number of retries before giving up */
end_comment

begin_define
define|#
directive|define
name|MAXTRANSFER
value|32
end_define

begin_comment
comment|/* max size of transfer in page clusters */
end_comment

begin_define
define|#
directive|define
name|wdctlr
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev)& 0x80)>> 7)
end_define

begin_define
define|#
directive|define
name|wdunit
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev)& 0x60)>> 5)
end_define

begin_define
define|#
directive|define
name|wdpart
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev)& 0x1f))
end_define

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_comment
comment|/* cylinder number for doing IO to */
end_comment

begin_comment
comment|/* shares an entry in the buf struct */
end_comment

begin_comment
comment|/*  * Drive states.  Used for open and format operations.  * States< OPEN (> 0) are transient, during an open operation.  * OPENRAW is used for unlabeled disks, and for floppies, to inhibit  * bad-sector forwarding.  */
end_comment

begin_define
define|#
directive|define
name|RAWDISK
value|8
end_define

begin_comment
comment|/* raw disk operation, no translation*/
end_comment

begin_define
define|#
directive|define
name|ISRAWSTATE
parameter_list|(
name|s
parameter_list|)
value|(RAWDISK&(s))
end_define

begin_comment
comment|/* are we in a raw state? */
end_comment

begin_define
define|#
directive|define
name|DISKSTATE
parameter_list|(
name|s
parameter_list|)
value|(~RAWDISK&(s))
end_define

begin_comment
comment|/* are we in a given state regardless 					   of raw or cooked mode? */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|0
end_define

begin_comment
comment|/* disk is closed. */
end_comment

begin_comment
comment|/* "cooked" disk states */
end_comment

begin_define
define|#
directive|define
name|WANTOPEN
value|1
end_define

begin_comment
comment|/* open requested, not started */
end_comment

begin_define
define|#
directive|define
name|RECAL
value|2
end_define

begin_comment
comment|/* doing restore */
end_comment

begin_define
define|#
directive|define
name|RDLABEL
value|3
end_define

begin_comment
comment|/* reading pack label */
end_comment

begin_define
define|#
directive|define
name|RDBADTBL
value|4
end_define

begin_comment
comment|/* reading bad-sector table */
end_comment

begin_define
define|#
directive|define
name|OPEN
value|5
end_define

begin_comment
comment|/* done with open */
end_comment

begin_define
define|#
directive|define
name|WANTOPENRAW
value|(WANTOPEN|RAWDISK)
end_define

begin_comment
comment|/* raw WANTOPEN */
end_comment

begin_define
define|#
directive|define
name|RECALRAW
value|(RECAL|RAWDISK)
end_define

begin_comment
comment|/* raw open, doing restore */
end_comment

begin_define
define|#
directive|define
name|OPENRAW
value|(OPEN|RAWDISK)
end_define

begin_comment
comment|/* open, but unlabeled disk or floppy */
end_comment

begin_comment
comment|/*  * The structure of a disk drive.  */
end_comment

begin_struct
struct|struct
name|disk
block|{
name|struct
name|disklabel
name|dk_dd
decl_stmt|;
comment|/* device configuration data */
name|long
name|dk_bc
decl_stmt|;
comment|/* byte count left */
name|short
name|dk_skip
decl_stmt|;
comment|/* blocks already transferred */
name|char
name|dk_unit
decl_stmt|;
comment|/* physical unit number */
name|char
name|dk_state
decl_stmt|;
comment|/* control state */
name|u_char
name|dk_status
decl_stmt|;
comment|/* copy of status reg. */
name|u_char
name|dk_error
decl_stmt|;
comment|/* copy of error reg. */
name|short
name|dk_open
decl_stmt|;
comment|/* open/closed refcnt */
name|u_long
name|dk_copenpart
decl_stmt|;
comment|/* character units open on this drive */
name|u_long
name|dk_bopenpart
decl_stmt|;
comment|/* block units open on this drive */
name|u_long
name|dk_openpart
decl_stmt|;
comment|/* all units open on this drive */
name|short
name|dk_wlabel
decl_stmt|;
comment|/* label writable? */
block|}
struct|;
end_struct

begin_comment
comment|/*  * This label is used as a default when initializing a new or raw disk.  * It really only lets us access the first track until we know more.  */
end_comment

begin_decl_stmt
name|struct
name|disklabel
name|dflt_sizes
init|=
block|{
name|DISKMAGIC
block|,
name|DTYPE_ST506
block|,
literal|0
block|,
literal|"default"
block|,
literal|""
block|,
literal|512
block|,
comment|/* sector size */
literal|17
block|,
comment|/* # of sectors per track */
literal|8
block|,
comment|/* # of tracks per cylinder */
literal|766
block|,
comment|/* # of cylinders per unit */
literal|17
operator|*
literal|8
block|,
comment|/* # of sectors per cylinder */
literal|766
operator|*
literal|8
operator|*
literal|17
block|,
comment|/* # of sectors per unit */
literal|0
block|,
comment|/* # of spare sectors per track */
literal|0
block|,
comment|/* # of spare sectors per cylinder */
literal|0
block|,
comment|/* # of alt. cylinders per unit */
literal|3600
block|,
comment|/* rotational speed */
literal|1
block|,
comment|/* hardware sector interleave */
literal|0
block|,
comment|/* sector 0 skew, per track */
literal|0
block|,
comment|/* sector 0 skew, per cylinder */
literal|0
block|,
comment|/* head switch time, usec */
literal|0
block|,
comment|/* track-to-track seek, usec */
literal|0
block|,
comment|/* generic flags */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|DISKMAGIC
block|,
literal|0
block|,
literal|8
block|,
literal|8192
block|,
literal|8192
block|,
block|{
block|{
literal|21600
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* A=root filesystem */
block|{
literal|21600
block|,
literal|40
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|660890
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* C=whole disk */
block|{
literal|216000
block|,
literal|80
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|399600
block|,
literal|480
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dkbad
name|dkbad
index|[
name|NWD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|disk
name|wddrives
index|[
name|NWD
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of units */
end_comment

begin_decl_stmt
name|struct
name|buf
name|wdtab
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|wdutab
index|[
name|NWD
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of queue per drive */
end_comment

begin_decl_stmt
name|struct
name|buf
name|rwdbuf
index|[
name|NWD
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers for raw IO */
end_comment

begin_decl_stmt
name|long
name|wdxfer
index|[
name|NWD
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of transfers */
end_comment

begin_decl_stmt
name|int
name|writeprotected
index|[
name|NWD
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wdprobe
argument_list|()
decl_stmt|,
name|wdattach
argument_list|()
decl_stmt|,
name|wdintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|wddriver
init|=
block|{
name|wdprobe
block|,
name|wdattach
block|,
literal|"wd"
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_expr_stmt
specifier|static
name|wdc
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Probe routine  */
end_comment

begin_macro
name|wdprobe
argument_list|(
argument|dvp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|wdc
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|wdintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX sorry, needs to be better */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|,
literal|0x5a
argument_list|)
expr_stmt|;
comment|/* error register not writable */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
literal|0xa5
argument_list|)
expr_stmt|;
comment|/* but all of cyllo are implemented */
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
operator|!=
literal|0x5a
operator|&&
name|inb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|)
operator|==
literal|0xa5
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * attach each drive if possible.  */
end_comment

begin_macro
name|wdattach
argument_list|(
argument|dvp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read/write routine for a buffer.  Finds the proper unit, range checks  * arguments, and schedules the transfer.  Does not wait for the transfer  * to complete.  Multi-page transfers are supported.  All I/O requests must  * be a multiple of a sector in length.  */
end_comment

begin_expr_stmt
name|wdstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* IO operation to perform */
end_comment

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
comment|/* Disk unit to do the IO.	*/
specifier|register
name|struct
name|partition
modifier|*
name|p
decl_stmt|;
name|long
name|maxsz
decl_stmt|,
name|sz
decl_stmt|;
name|int
name|unit
init|=
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|unit
operator|>=
name|NWD
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"wdstrat: unit = %d, blkno = %d, bcount = %d\n"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|pg
argument_list|(
literal|"wd:error in wdstrategy"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|writeprotected
index|[
name|unit
index|]
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"wd%d: write protected\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|du
operator|=
operator|&
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|DISKSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
operator|!=
name|OPEN
condition|)
goto|goto
name|q
goto|;
ifdef|#
directive|ifdef
name|old
comment|/* 	 * Convert DEV_BSIZE "blocks" to sectors. 	 * Note: doing the conversions this way limits the partition size 	 * to about 8 million sectors (1-8 Gb). 	 */
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|u_long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|%
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|!=
literal|0
operator|)
operator|||
name|bp
operator|->
name|b_bcount
operator|>=
name|MAXTRANSFER
operator|*
name|CLBYTES
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|nblocks
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
expr_stmt|;
name|cyloff
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
expr_stmt|;
if|if
condition|(
name|blknum
operator|+
operator|(
name|bp
operator|->
name|b_bcount
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|)
operator|>
name|nblocks
condition|)
block|{
if|if
condition|(
name|blknum
operator|==
name|nblocks
condition|)
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
else|else
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bp
operator|->
name|b_cylin
operator|=
name|blknum
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|+
name|cyloff
expr_stmt|;
else|#
directive|else
comment|/*          * Determine the size of the transfer, and make sure it is          * within the boundaries of the partition.          */
name|p
operator|=
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|wdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|maxsz
operator|=
name|p
operator|->
name|p_size
expr_stmt|;
name|sz
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|>>
name|DEV_BSHIFT
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|+
name|p
operator|->
name|p_offset
operator|<=
name|LABELSECTOR
operator|&&
if|#
directive|if
name|LABELSECTOR
operator|!=
literal|0
name|bp
operator|->
name|b_blkno
operator|+
name|p
operator|->
name|p_offset
operator|+
name|sz
operator|>
name|LABELSECTOR
operator|&&
endif|#
directive|endif
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|&&
name|du
operator|->
name|dk_wlabel
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|||
name|bp
operator|->
name|b_blkno
operator|+
name|sz
operator|>
name|maxsz
condition|)
block|{
comment|/* if exactly at end of disk, return an EOF */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|maxsz
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* or truncate if part of it fits */
name|sz
operator|=
name|maxsz
operator|-
name|bp
operator|->
name|b_blkno
expr_stmt|;
if|if
condition|(
name|sz
operator|<=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|bp
operator|->
name|b_bcount
operator|=
name|sz
operator|<<
name|DEV_BSHIFT
expr_stmt|;
block|}
name|bp
operator|->
name|b_cylin
operator|=
operator|(
name|bp
operator|->
name|b_blkno
operator|+
name|p
operator|->
name|p_offset
operator|)
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
expr_stmt|;
endif|#
directive|endif
name|q
label|:
name|dp
operator|=
operator|&
name|wdutab
index|[
name|unit
index|]
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
name|wdustart
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* start drive if idle */
if|if
condition|(
name|wdtab
operator|.
name|b_active
operator|==
literal|0
condition|)
name|wdstart
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* start IO if controller idle */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Routine to queue a read or write command to the controller.  The request is  * linked into the active list for the controller.  If the controller is idle,  * the transfer is started.  */
end_comment

begin_expr_stmt
name|wdustart
argument_list|(
name|du
argument_list|)
specifier|register
expr|struct
name|disk
operator|*
name|du
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
operator|&
name|wdutab
index|[
name|du
operator|->
name|dk_unit
index|]
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
condition|)
return|return;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return;
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|wdtab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
comment|/* link unit into active list */
name|wdtab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|wdtab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|wdtab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
comment|/* mark the drive as busy */
block|}
end_block

begin_comment
comment|/*  * Controller startup routine.  This does the calculation, and starts  * a single-sector read or write operation.  Called to start a transfer,  * or from the interrupt routine to continue a multi-sector transfer.  * RESTRICTIONS:  * 1.	The transfer length must be an exact multiple of the sector size.  */
end_comment

begin_expr_stmt
specifier|static
name|wd_sebyse
expr_stmt|;
end_expr_stmt

begin_macro
name|wdstart
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
comment|/* disk unit for IO */
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|bt_bad
modifier|*
name|bt_ptr
decl_stmt|;
name|long
name|blknum
decl_stmt|,
name|pagcnt
decl_stmt|,
name|cylin
decl_stmt|,
name|head
decl_stmt|,
name|sector
decl_stmt|;
name|long
name|secpertrk
decl_stmt|,
name|secpercyl
decl_stmt|,
name|addr
decl_stmt|,
name|i
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|s
decl_stmt|;
name|loop
label|:
name|dp
operator|=
name|wdtab
operator|.
name|b_actf
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|wdtab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|unit
operator|=
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|du
operator|=
operator|&
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|DISKSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
operator|<=
name|RDLABEL
condition|)
block|{
if|if
condition|(
name|wdcontrol
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* done */
block|}
return|return;
block|}
name|secpertrk
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
expr_stmt|;
comment|/* 	 * Convert DEV_BSIZE "blocks" to sectors. 	 */
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|+
name|du
operator|->
name|dk_skip
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
condition|)
block|{
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"\nwdstart %d: %s %d@%d; map "
argument_list|,
name|unit
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|" %d)%x"
argument_list|,
name|du
operator|->
name|dk_skip
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_altsts
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|addr
operator|=
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
condition|)
name|du
operator|->
name|dk_bc
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
if|if
condition|(
name|DISKSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
operator|==
name|OPEN
condition|)
name|cylin
operator|+=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|wdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|p_offset
operator|/
name|secpercyl
expr_stmt|;
comment|/*  	 * See if the current block is in the bad block list. 	 * (If we have one, and not formatting.) 	 */
if|if
condition|(
name|DISKSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
operator|==
name|OPEN
operator|&&
name|wd_sebyse
condition|)
for|for
control|(
name|bt_ptr
operator|=
name|dkbad
index|[
name|unit
index|]
operator|.
name|bt_bad
init|;
name|bt_ptr
operator|->
name|bt_cyl
operator|!=
operator|-
literal|1
condition|;
name|bt_ptr
operator|++
control|)
block|{
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|>
name|cylin
condition|)
comment|/* Sorted list, and we passed our cylinder. quit. */
break|break;
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|==
name|cylin
operator|&&
name|bt_ptr
operator|->
name|bt_trksec
operator|==
operator|(
name|head
operator|<<
literal|8
operator|)
operator|+
name|sector
condition|)
block|{
comment|/* 			 * Found bad block.  Calculate new block addr. 			 * This starts at the end of the disk (skip the 			 * last track which is used for the bad block list), 			 * and works backwards to the front of the disk. 			 */
ifdef|#
directive|ifdef
name|WDDEBUG
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"--- badblock code -> Old = %d; "
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|blknum
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|-
operator|(
name|bt_ptr
operator|-
name|dkbad
index|[
name|unit
index|]
operator|.
name|bt_bad
operator|)
operator|-
literal|1
expr_stmt|;
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"new = %d\n"
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
name|sector
operator|+=
literal|1
expr_stmt|;
comment|/* sectors begin with 1, not 0 */
name|wdtab
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
comment|/* mark controller active */
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
operator|||
name|wd_sebyse
condition|)
block|{
if|if
condition|(
name|wdtab
operator|.
name|b_errcnt
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
name|du
operator|->
name|dk_bc
operator|+=
literal|512
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_BUSY
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
comment|/*while ((inb(wdc+wd_status)& WDCS_DRQ)) inb(wdc+wd_data);*/
name|outb
argument_list|(
name|wdc
operator|+
name|wd_precomp
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/*wr(wdc+wd_precomp, du->dk_dd.dk_precompcyl / 4);*/
comment|/*if (bp->b_flags& B_FORMAT) { 		wr(wdc+wd_sector, du->dk_dd.dk_gap3); 		wr(wdc+wd_seccnt, du->dk_dd.dk_nsectors); 	} else {*/
if|if
condition|(
name|wd_sebyse
condition|)
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
operator|(
operator|(
name|du
operator|->
name|dk_bc
operator|+
literal|511
operator|)
operator|/
literal|512
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
name|cylin
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|,
name|cylin
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* Set up the SDH register (select drive).     */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
operator||
operator|(
name|head
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_READY
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/*if (bp->b_flags& B_FORMAT) 		wr(wdc+wd_command, WDCC_FORMAT); 	else*/
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|WDCC_READ
else|:
name|WDCC_WRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"sector %d cylin %d head %d addr %x sts %x\n"
argument_list|,
name|sector
argument_list|,
name|cylin
argument_list|,
name|head
argument_list|,
name|addr
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_altsts
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If this is a read operation, just go away until it's done.	*/
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
return|return;
comment|/* Ready to send data?	*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_DRQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* ASSUMES CONTIGUOUS MEMORY */
name|outsw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
name|addr
operator|+
name|du
operator|->
name|dk_skip
operator|*
literal|512
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_bc
operator|-=
literal|512
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * these are globally defined so they can be found  * by the debugger easily in the case of a system crash  */
end_comment

begin_decl_stmt
name|daddr_t
name|wd_errsector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|wd_errbn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|wd_errstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interrupt routine for the controller.  Acknowledge the interrupt, check for  * errors on the current operation, mark it done if necessary, and start  * the next request.  Also check for a partially done transfer, and  * continue with the next chunk if so.  */
end_comment

begin_macro
name|wdintr
argument_list|(
argument|unit
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
name|partch
decl_stmt|;
specifier|static
name|wd_haderror
expr_stmt|;
comment|/* Shouldn't need this, but it may be a slow controller.	*/
while|while
condition|(
operator|(
name|status
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|)
operator|&
name|WDCS_BUSY
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|wdtab
operator|.
name|b_active
condition|)
block|{
name|printf
argument_list|(
literal|"wd: extra interrupt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|WDDEBUG
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"I "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
name|wdtab
operator|.
name|b_actf
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|du
operator|=
operator|&
name|wddrives
index|[
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|partch
operator|=
name|wdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|+
literal|'a'
expr_stmt|;
if|if
condition|(
name|DISKSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
operator|<=
name|RDLABEL
condition|)
block|{
if|if
condition|(
name|wdcontrol
argument_list|(
name|bp
argument_list|)
condition|)
goto|goto
name|done
goto|;
return|return;
block|}
if|if
condition|(
name|status
operator|&
operator|(
name|WDCS_ERR
operator||
name|WDCS_ECCCOR
operator|)
condition|)
block|{
name|wd_errstat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
expr_stmt|;
comment|/* save error status */
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"status %x error %x\n"
argument_list|,
name|status
argument_list|,
name|wd_errstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wd_sebyse
operator|==
literal|0
condition|)
block|{
name|wd_haderror
operator|=
literal|1
expr_stmt|;
goto|goto
name|outt
goto|;
block|}
comment|/*if (bp->b_flags& B_FORMAT) { 			du->dk_status = status; 			du->dk_error = wdp->wd_error; 			bp->b_flags |= B_ERROR; 			goto done; 		}*/
name|wd_errsector
operator|=
operator|(
name|bp
operator|->
name|b_cylin
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|)
operator|+
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|)
operator|%
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|)
operator|+
name|du
operator|->
name|dk_skip
expr_stmt|;
name|wd_errbn
operator|=
name|bp
operator|->
name|b_blkno
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|/
name|DEV_BSIZE
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|WDCS_ERR
condition|)
block|{
if|if
condition|(
operator|++
name|wdtab
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
block|{
name|wdtab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"wd%d%c: "
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|partch
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"hard %s error, sn %d bn %d status %b error %b\n"
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|wd_errsector
argument_list|,
name|wd_errbn
argument_list|,
name|status
argument_list|,
name|WDCS_BITS
argument_list|,
name|wd_errstat
argument_list|,
name|WDERR_BITS
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* flag the error */
block|}
block|}
else|else
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wd%d%c: soft ecc sn %d bn %d\n"
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|partch
argument_list|,
name|wd_errsector
argument_list|,
name|wd_errbn
argument_list|)
expr_stmt|;
block|}
name|outt
label|:
comment|/* 	 * If this was a successful read operation, fetch the data. 	 */
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_READ
operator||
name|B_ERROR
operator|)
operator|)
operator|==
name|B_READ
operator|)
operator|&&
name|wdtab
operator|.
name|b_active
condition|)
block|{
name|int
name|chk
decl_stmt|,
name|dummy
decl_stmt|;
name|chk
operator|=
name|min
argument_list|(
literal|256
argument_list|,
name|du
operator|->
name|dk_bc
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* Ready to receive data?	*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_DRQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/*dprintf(DDSK,"addr %x\n", (int)bp->b_un.b_addr + du->dk_skip * 512);*/
name|insw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|du
operator|->
name|dk_skip
operator|*
literal|512
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_bc
operator|-=
literal|2
operator|*
name|chk
expr_stmt|;
while|while
condition|(
name|chk
operator|++
operator|<
literal|256
condition|)
name|insw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|wdxfer
index|[
name|du
operator|->
name|dk_unit
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|wdtab
operator|.
name|b_active
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_skip
operator|++
expr_stmt|;
comment|/* Add to successful sectors. */
if|if
condition|(
name|wdtab
operator|.
name|b_errcnt
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wd%d%c: "
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|partch
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"soft %s error, sn %d bn %d error %b retries %d\n"
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|wd_errsector
argument_list|,
name|wd_errbn
argument_list|,
name|wd_errstat
argument_list|,
name|WDERR_BITS
argument_list|,
name|wdtab
operator|.
name|b_errcnt
argument_list|)
expr_stmt|;
block|}
name|wdtab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
comment|/* see if more to transfer */
comment|/*if (du->dk_skip< (bp->b_bcount + 511) / 512) {*/
if|if
condition|(
name|du
operator|->
name|dk_bc
operator|>
literal|0
operator|&&
name|wd_haderror
operator|==
literal|0
condition|)
block|{
name|wdstart
argument_list|()
expr_stmt|;
return|return;
comment|/* next chunk is started */
block|}
elseif|else
if|if
condition|(
name|wd_haderror
operator|&&
name|wd_sebyse
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_skip
operator|=
literal|0
expr_stmt|;
name|wd_haderror
operator|=
literal|0
expr_stmt|;
name|wd_sebyse
operator|=
literal|1
expr_stmt|;
name|wdstart
argument_list|()
expr_stmt|;
return|return;
comment|/* redo xfer sector by sector */
block|}
block|}
name|done
label|:
name|wd_sebyse
operator|=
literal|0
expr_stmt|;
comment|/* done with this transfer, with or without error */
name|wdtab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
name|wdtab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_skip
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|dp
operator|->
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|wdtab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
name|wdustart
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* requeue disk if more io to do */
if|if
condition|(
name|wdtab
operator|.
name|b_actf
condition|)
name|wdstart
argument_list|()
expr_stmt|;
comment|/* start IO on next drive */
block|}
end_block

begin_comment
comment|/*  * Initialize a drive.  */
end_comment

begin_macro
name|wdopen
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|,
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|,
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|part
init|=
name|wdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|mask
init|=
literal|1
operator|<<
name|part
decl_stmt|;
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
name|struct
name|dkbad
modifier|*
name|db
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|unit
operator|=
name|wdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NWD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|du
operator|=
operator|&
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|du
operator|->
name|dk_open
condition|)
block|{
name|du
operator|->
name|dk_open
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already is open, don't mess with it */
block|}
endif|#
directive|endif
name|du
operator|->
name|dk_unit
operator|=
name|unit
expr_stmt|;
name|wdutab
index|[
name|unit
index|]
operator|.
name|b_actf
operator|=
name|NULL
expr_stmt|;
comment|/*if (flags& O_NDELAY) 		du->dk_state = WANTOPENRAW; 	else*/
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
comment|/* 	 * Use the default sizes until we've read the label, 	 * or longer if there isn't one there. 	 */
name|du
operator|->
name|dk_dd
operator|=
name|dflt_sizes
expr_stmt|;
comment|/* 	 * Recal, read of disk label will be done in wdcontrol 	 * during first read operation. 	 */
name|bp
operator|=
name|geteblk
argument_list|(
literal|512
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
operator|&
literal|0xff00
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|LABELSECTOR
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_READ
expr_stmt|;
name|wdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|CLOSED
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|du
operator|->
name|dk_state
operator|==
name|OPENRAW
condition|)
block|{
name|du
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Read bad sector table into memory. 	 */
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|>
name|DEV_BSIZE
condition|)
name|bp
operator|->
name|b_blkno
operator|*=
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|/
name|DEV_BSIZE
expr_stmt|;
else|else
name|bp
operator|->
name|b_blkno
operator|/=
name|DEV_BSIZE
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
name|bp
operator|->
name|b_cylin
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|-
literal|1
expr_stmt|;
name|wdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|&&
operator|(
name|i
operator|+=
literal|2
operator|)
operator|<
literal|10
operator|&&
name|i
operator|<
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
condition|)
do|;
name|db
operator|=
operator|(
expr|struct
name|dkbad
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|)
expr_stmt|;
define|#
directive|define
name|DKBAD_MAGIC
value|0x4321
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
operator|&&
name|db
operator|->
name|bt_mbz
operator|==
literal|0
operator|&&
name|db
operator|->
name|bt_flag
operator|==
name|DKBAD_MAGIC
condition|)
block|{
name|dkbad
index|[
name|unit
index|]
operator|=
operator|*
name|db
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"wd%d: %s bad-sector file\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
condition|?
literal|"can't read"
else|:
literal|"format error in"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
block|}
name|done
label|:
name|bp
operator|->
name|b_flags
operator|=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|du
operator|->
name|dk_open
operator|=
literal|1
expr_stmt|;
comment|/*          * Warn if a partion is opened          * that overlaps another partition which is open          * unless one is the "raw" partition (whole disk).          */
define|#
directive|define
name|RAWPART
value|8
comment|/* 'x' partition */
comment|/* XXX */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_openpart
operator|&
name|mask
operator|)
operator|==
literal|0
operator|&&
name|part
operator|!=
name|RAWPART
condition|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|pp
operator|=
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
expr_stmt|;
name|start
operator|=
name|pp
operator|->
name|p_offset
expr_stmt|;
name|end
operator|=
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
init|;
name|pp
operator|<
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|du
operator|->
name|dk_dd
operator|.
name|d_npartitions
index|]
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
operator|<=
name|start
operator|||
name|pp
operator|->
name|p_offset
operator|>=
name|end
condition|)
continue|continue;
if|if
condition|(
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|==
name|RAWPART
condition|)
continue|continue;
if|if
condition|(
name|du
operator|->
name|dk_openpart
operator|&
operator|(
literal|1
operator|<<
operator|(
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wd%d%c: overlaps open partition (%c)\n"
argument_list|,
name|unit
argument_list|,
name|part
operator|+
literal|'a'
argument_list|,
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|part
operator|>=
name|du
operator|->
name|dk_dd
operator|.
name|d_npartitions
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|du
operator|->
name|dk_openpart
operator||=
name|mask
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|du
operator|->
name|dk_copenpart
operator||=
name|mask
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|du
operator|->
name|dk_bopenpart
operator||=
name|mask
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Implement operations other than read/write.  * Called from wdstart or wdintr during opens and formats.  * Uses finite-state-machine to track progress of operation in progress.  * Returns 0 if operation still in progress, 1 if completed.  */
end_comment

begin_expr_stmt
name|wdcontrol
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|unit
expr_stmt|;
name|unsigned
name|char
name|stat
decl_stmt|;
name|int
name|s
decl_stmt|,
name|cnt
decl_stmt|;
specifier|extern
name|int
name|bootdev
decl_stmt|,
name|cyloffset
decl_stmt|;
name|du
operator|=
operator|&
name|wddrives
index|[
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|unit
operator|=
name|du
operator|->
name|dk_unit
expr_stmt|;
switch|switch
condition|(
name|DISKSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
condition|)
block|{
name|tryagainrecal
label|:
case|case
name|WANTOPEN
case|:
comment|/* set SDH, step rate, do restore */
ifdef|#
directive|ifdef
name|WDDEBUG
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"wd%d: recal "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* not called from intr level ... */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|wdtab
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RECAL
case|:
if|if
condition|(
operator|(
name|stat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|)
operator|&
name|WDCS_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"wd%d: recal"
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|": status %b error %b\n"
argument_list|,
name|stat
argument_list|,
name|WDCS_BITS
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
argument_list|,
name|WDERR_BITS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|wdtab
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
goto|goto
name|tryagainrecal
goto|;
block|}
goto|goto
name|badopen
goto|;
block|}
comment|/* some compaq controllers require this ... */
name|wdsetctlr
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|,
name|du
argument_list|)
expr_stmt|;
name|wdtab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISRAWSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
condition|)
block|{
name|du
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|retry
label|:
ifdef|#
directive|ifdef
name|WDDEBUG
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"rdlabel "
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cyloffset
operator|<
literal|0
operator|||
name|cyloffset
operator|>
literal|8192
condition|)
name|cyloffset
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Read in sector LABELSECTOR to get the pack label 		 * and geometry. 		 */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_precomp
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* sometimes this is head bit 3 */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|,
name|LABELSECTOR
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*if (bp->b_dev == bootdev) { 			(wdc+wd_cyl_lo = cyloffset& 0xff; 			(wdc+wd_cyl_hi = cyloffset>> 8; 		} else { 			(wdc+wd_cyl_lo = 0; 			(wdc+wd_cyl_hi = 0; 		}*/
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
operator|(
name|cyloffset
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|,
operator|(
name|cyloffset
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|WDCC_READ
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|RDLABEL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RDLABEL
case|:
if|if
condition|(
operator|(
name|stat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|)
operator|&
name|WDCS_ERR
condition|)
block|{
if|if
condition|(
operator|++
name|wdtab
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
goto|goto
name|retry
goto|;
name|printf
argument_list|(
literal|"wd%d: read label"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|badopen
goto|;
block|}
name|insw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|disklabel
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|LABELOFFSET
operator|)
operator|)
operator|->
name|d_magic
operator|==
name|DISKMAGIC
condition|)
block|{
name|du
operator|->
name|dk_dd
operator|=
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|LABELOFFSET
operator|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"wd%d: bad disk label\n"
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* not called from intr level ... */
while|while
condition|(
operator|(
name|stat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|)
operator|&
name|WDCS_BUSY
condition|)
empty_stmt|;
name|wdsetctlr
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|,
name|du
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_state
operator|==
name|RDLABEL
condition|)
name|du
operator|->
name|dk_state
operator|=
name|RDBADTBL
expr_stmt|;
comment|/* 		 * The rest of the initialization can be done 		 * by normal means. 		 */
return|return
operator|(
literal|1
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"wdcontrol"
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
name|badopen
label|:
name|printf
argument_list|(
literal|": status %b error %b\n"
argument_list|,
name|stat
argument_list|,
name|WDCS_BITS
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
argument_list|,
name|WDERR_BITS
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|wdsetctlr
argument_list|(
argument|dev
argument_list|,
argument|du
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|stat
decl_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|,
operator|(
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|wdunit
argument_list|(
name|dev
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
literal|0x91
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|stat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|)
operator|&
name|WDCS_BUSY
condition|)
empty_stmt|;
name|stat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|wdclose
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|,
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|,
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|du
operator|=
operator|&
name|wddrives
index|[
name|wdunit
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|du
operator|->
name|dk_open
operator|--
expr_stmt|;
comment|/*if (du->dk_open == 0) du->dk_state = CLOSED ; does not work */
block|}
end_block

begin_macro
name|wdioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|addr
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|wdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
comment|/*int wdformat();*/
name|du
operator|=
operator|&
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
operator|=
name|du
operator|->
name|dk_dd
expr_stmt|;
break|break;
case|case
name|DIOCGPART
case|:
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|disklab
operator|=
operator|&
name|du
operator|->
name|dk_dd
expr_stmt|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|part
operator|=
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|wdpart
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|DIOCSDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|error
operator|=
name|setdisklabel
argument_list|(
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
argument_list|,
literal|0
comment|/*(dk->dk_state == OPENRAW) ? 0 : dk->dk_openpart*/
argument_list|)
expr_stmt|;
comment|/*if (error == 0&& dk->dk_state == OPENRAW&&                     vdreset_drive(vddinfo[unit]))                         dk->dk_state = OPEN;*/
name|wdsetctlr
argument_list|(
name|dev
argument_list|,
name|du
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIOCWLABEL
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|du
operator|->
name|dk_wlabel
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|DIOCWDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|setdisklabel
argument_list|(
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
argument_list|,
literal|0
comment|/*(dk->dk_state == OPENRAW) ? 0 : dk->dk_openpart*/
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|wlab
decl_stmt|;
comment|/*if (error == 0&& dk->dk_state == OPENRAW&&                             vdreset_drive(vddinfo[unit]))                                 dk->dk_state = OPEN; */
name|wdsetctlr
argument_list|(
name|dev
argument_list|,
name|du
argument_list|)
expr_stmt|;
comment|/* simulate opening partition 0 so write succeeds */
comment|/* dk->dk_openpart |= (1<< 0);            /* XXX */
name|wlab
operator|=
name|du
operator|->
name|dk_wlabel
expr_stmt|;
name|du
operator|->
name|dk_wlabel
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|writedisklabel
argument_list|(
name|dev
argument_list|,
name|wdstrategy
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
name|wdpart
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/*dk->dk_openpart = dk->dk_copenpart | dk->dk_bopenpart;*/
name|du
operator|->
name|dk_wlabel
operator|=
name|wlab
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|notyet
case|case
name|DIOCGDINFOP
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|*
operator|)
name|addr
operator|=
operator|&
operator|(
name|du
operator|->
name|dk_dd
operator|)
expr_stmt|;
break|break;
case|case
name|DIOCWFORMAT
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|format_op
modifier|*
name|fop
decl_stmt|;
name|fop
operator|=
operator|(
expr|struct
name|format_op
operator|*
operator|)
name|addr
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|fop
operator|->
name|df_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|fop
operator|->
name|df_startblk
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
name|error
operator|=
name|physio
argument_list|(
name|wdformat
argument_list|,
operator|&
name|rwdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
name|fop
operator|->
name|df_count
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|fop
operator|->
name|df_reg
index|[
literal|0
index|]
operator|=
name|du
operator|->
name|dk_status
expr_stmt|;
name|fop
operator|->
name|df_reg
index|[
literal|1
index|]
operator|=
name|du
operator|->
name|dk_error
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*wdformat(bp) 	struct buf *bp; {  	bp->b_flags |= B_FORMAT; 	return (wdstrategy(bp)); }*/
end_comment

begin_comment
comment|/*  * Routines to do raw IO for a unit.  */
end_comment

begin_macro
name|wdread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_comment
comment|/* character read routine */
end_comment

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|wdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NWD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|physio
argument_list|(
name|wdstrategy
argument_list|,
operator|&
name|rwdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|wdwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_comment
comment|/* character write routine */
end_comment

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|wdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NWD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|physio
argument_list|(
name|wdstrategy
argument_list|,
operator|&
name|rwdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|wdsize
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unit
operator|=
name|wdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
specifier|register
name|part
operator|=
name|wdpart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|val
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NWD
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|wddrives
index|[
name|unit
index|]
operator|.
name|dk_state
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|wdopen
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|du
operator|=
operator|&
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|u_long
operator|)
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|/
literal|512
argument_list|)
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|vmmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* poor name! */
end_comment

begin_macro
name|wddump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_comment
comment|/* dump core after a system crash */
end_comment

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
comment|/* disk unit to do the IO */
specifier|register
name|struct
name|bt_bad
modifier|*
name|bt_ptr
decl_stmt|;
name|long
name|num
decl_stmt|;
comment|/* number of sectors to write */
name|int
name|unit
decl_stmt|,
name|part
decl_stmt|;
name|long
name|cyloff
decl_stmt|,
name|blknum
decl_stmt|,
name|blkcnt
decl_stmt|;
name|long
name|cylin
decl_stmt|,
name|head
decl_stmt|,
name|sector
decl_stmt|,
name|stat
decl_stmt|;
name|long
name|secpertrk
decl_stmt|,
name|secpercyl
decl_stmt|,
name|nblocks
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
specifier|extern
name|int
name|Maxmem
decl_stmt|;
specifier|static
name|wddoingadump
operator|=
literal|0
expr_stmt|;
extern|extern CMAP1;
specifier|extern
name|char
name|CADDR1
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|ARGO
name|outb
argument_list|(
literal|0x461
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable failsafe timer */
endif|#
directive|endif
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* starting address */
comment|/* size of memory to dump */
name|num
operator|=
name|Maxmem
expr_stmt|;
name|unit
operator|=
name|wdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* eventually support floppies? */
name|part
operator|=
name|wdpart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* file system */
comment|/* check for acceptable drive number */
if|if
condition|(
name|unit
operator|>=
name|NWD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|du
operator|=
operator|&
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
comment|/* was it ever initialized ? */
if|if
condition|(
name|du
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Convert to disk sectors */
name|num
operator|=
operator|(
name|u_long
operator|)
name|num
operator|*
name|NBPG
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
comment|/* check if controller active */
comment|/*if (wdtab.b_active) return(EFAULT); */
if|if
condition|(
name|wddoingadump
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|secpertrk
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
expr_stmt|;
name|nblocks
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
expr_stmt|;
name|cyloff
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
operator|/
name|secpercyl
expr_stmt|;
comment|/*pg("xunit %x, nblocks %d, dumplo %d num %d\n", part,nblocks,dumplo,num);*/
comment|/* check transfer bounds against partition size */
if|if
condition|(
operator|(
name|dumplo
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|dumplo
operator|+
name|num
operator|)
operator|>
name|nblocks
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*wdtab.b_active = 1;		/* mark controller active for if we 					   panic during the dump */
name|wddoingadump
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|100000
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_BUSY
operator|)
operator|&&
operator|(
name|i
operator|--
operator|>
literal|0
operator|)
condition|)
empty_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_BUSY
condition|)
empty_stmt|;
comment|/* some compaq controllers require this ... */
name|wdsetctlr
argument_list|(
name|dev
argument_list|,
name|du
argument_list|)
expr_stmt|;
name|blknum
operator|=
name|dumplo
expr_stmt|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|blkcnt
operator|>
name|MAXTRANSFER
condition|)
name|blkcnt
operator|=
name|MAXTRANSFER
expr_stmt|;
if|if
condition|(
operator|(
name|blknum
operator|+
name|blkcnt
operator|-
literal|1
operator|)
operator|/
name|secpercyl
operator|!=
name|blknum
operator|/
name|secpercyl
condition|)
name|blkcnt
operator|=
name|secpercyl
operator|-
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
expr_stmt|;
comment|/* keep transfer within current cylinder */
endif|#
directive|endif
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
name|vmmap
argument_list|,
name|addr
argument_list|,
name|VM_PROT_READ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* compute disk address */
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
name|cylin
operator|+=
name|cyloff
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/*  		 * See if the current block is in the bad block list. 		 * (If we have one.) 		 */
for|for
control|(
name|bt_ptr
operator|=
name|dkbad
index|[
name|unit
index|]
operator|.
name|bt_bad
init|;
name|bt_ptr
operator|->
name|bt_cyl
operator|!=
operator|-
literal|1
condition|;
name|bt_ptr
operator|++
control|)
block|{
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|>
name|cylin
condition|)
comment|/* Sorted list, and we passed our cylinder. 					quit. */
break|break;
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|==
name|cylin
operator|&&
name|bt_ptr
operator|->
name|bt_trksec
operator|==
operator|(
name|head
operator|<<
literal|8
operator|)
operator|+
name|sector
condition|)
block|{
comment|/* 			 * Found bad block.  Calculate new block addr. 			 * This starts at the end of the disk (skip the 			 * last track which is used for the bad block list), 			 * and works backwards to the front of the disk. 			 */
name|blknum
operator|=
operator|(
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|)
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|-
operator|(
name|bt_ptr
operator|-
name|dkbad
index|[
name|unit
index|]
operator|.
name|bt_bad
operator|)
operator|-
literal|1
expr_stmt|;
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|sector
operator|++
expr_stmt|;
comment|/* origin 1 */
comment|/* select drive.     */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
operator||
operator|(
name|head
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_READY
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* transfer some blocks */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
name|cylin
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|,
name|cylin
operator|>>
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* lets just talk about this first...*/
name|pg
argument_list|(
literal|"sdh 0%o sector %d cyl %d addr 0x%x"
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|)
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|)
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|)
operator|*
literal|256
operator|+
name|inb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ODYSSEUS
if|if
condition|(
name|cylin
operator|<
literal|46
operator|||
name|cylin
operator|>
literal|91
condition|)
name|pg
argument_list|(
literal|"oops"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PRIAM
if|if
condition|(
name|cylin
operator|<
literal|40
operator|||
name|cylin
operator|>
literal|79
condition|)
name|pg
argument_list|(
literal|"oops"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|WDCC_WRITE
argument_list|)
expr_stmt|;
comment|/* Ready to send data?	*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_DRQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_ERR
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|outsw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
name|CADDR1
operator|+
operator|(
operator|(
name|int
operator|)
name|addr
operator|&
operator|(
name|NBPG
operator|-
literal|1
operator|)
operator|)
argument_list|,
literal|256
argument_list|)
expr_stmt|;
operator|(
name|int
operator|)
name|addr
operator|+=
literal|512
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_ERR
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Check data request (should be done).         */
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_DRQ
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* wait for completion */
for|for
control|(
name|i
operator|=
literal|1000000
init|;
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_BUSY
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* error check the xfer */
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_ERR
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* update block count */
name|num
operator|--
expr_stmt|;
name|blknum
operator|++
expr_stmt|;
if|if
condition|(
name|num
operator|%
literal|100
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

