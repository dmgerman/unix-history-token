begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * %sccs.include.386.c%  *  *	@(#)wd.c	5.2 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"wd.h"
end_include

begin_if
if|#
directive|if
name|NWD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"dkbad.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"disk.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"machine/device.h"
end_include

begin_include
include|#
directive|include
file|"atio.h"
end_include

begin_include
include|#
directive|include
file|"icu.h"
end_include

begin_include
include|#
directive|include
file|"wdreg.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_define
define|#
directive|define
name|RETRIES
value|5
end_define

begin_comment
comment|/* number of retries before giving up */
end_comment

begin_define
define|#
directive|define
name|MAXTRANSFER
value|256
end_define

begin_comment
comment|/* max size of transfer in page clusters */
end_comment

begin_define
define|#
directive|define
name|WDUNIT
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev)& 070)>> 3)
end_define

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_comment
comment|/* cylinder number for doing IO to */
end_comment

begin_comment
comment|/* shares an entry in the buf struct */
end_comment

begin_comment
comment|/*  * Drive states.  Used for open and format operations.  * States< OPEN (> 0) are transient, during an open operation.  * OPENRAW is used for unlabeled disks, and for floppies, to inhibit  * bad-sector forwarding.  */
end_comment

begin_define
define|#
directive|define
name|RAWDISK
value|8
end_define

begin_comment
comment|/* raw disk operation, no translation*/
end_comment

begin_define
define|#
directive|define
name|ISRAWSTATE
parameter_list|(
name|s
parameter_list|)
value|(RAWDISK&(s))
end_define

begin_comment
comment|/* are we in a raw state? */
end_comment

begin_define
define|#
directive|define
name|DISKSTATE
parameter_list|(
name|s
parameter_list|)
value|(~RAWDISK&(s))
end_define

begin_comment
comment|/* are we in a given state regardless 					   of raw or cooked mode? */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|0
end_define

begin_comment
comment|/* disk is closed. */
end_comment

begin_comment
comment|/* "cooked" disk states */
end_comment

begin_define
define|#
directive|define
name|WANTOPEN
value|1
end_define

begin_comment
comment|/* open requested, not started */
end_comment

begin_define
define|#
directive|define
name|RECAL
value|2
end_define

begin_comment
comment|/* doing restore */
end_comment

begin_define
define|#
directive|define
name|RDLABEL
value|3
end_define

begin_comment
comment|/* reading pack label */
end_comment

begin_define
define|#
directive|define
name|RDBADTBL
value|4
end_define

begin_comment
comment|/* reading bad-sector table */
end_comment

begin_define
define|#
directive|define
name|OPEN
value|5
end_define

begin_comment
comment|/* done with open */
end_comment

begin_define
define|#
directive|define
name|WANTOPENRAW
value|(WANTOPEN|RAWDISK)
end_define

begin_comment
comment|/* raw WANTOPEN */
end_comment

begin_define
define|#
directive|define
name|RECALRAW
value|(RECAL|RAWDISK)
end_define

begin_comment
comment|/* raw open, doing restore */
end_comment

begin_define
define|#
directive|define
name|OPENRAW
value|(OPEN|RAWDISK)
end_define

begin_comment
comment|/* open, but unlabeled disk or floppy */
end_comment

begin_comment
comment|/*  * The structure of a disk drive.  */
end_comment

begin_struct
struct|struct
name|disk
block|{
name|struct
name|disklabel
name|dk_dd
decl_stmt|;
comment|/* device configuration data */
name|long
name|dk_bc
decl_stmt|;
comment|/* byte count left */
name|short
name|dk_skip
decl_stmt|;
comment|/* blocks already transferred */
name|char
name|dk_unit
decl_stmt|;
comment|/* physical unit number */
name|char
name|dk_sdh
decl_stmt|;
comment|/* sdh prototype */
name|char
name|dk_state
decl_stmt|;
comment|/* control state */
name|u_char
name|dk_status
decl_stmt|;
comment|/* copy of status reg. */
name|u_char
name|dk_error
decl_stmt|;
comment|/* copy of error reg. */
name|short
name|dk_open
decl_stmt|;
comment|/* open/closed refcnt */
block|}
struct|;
end_struct

begin_comment
comment|/*  * This label is used as a default when initializing a new or raw disk.  * It really only lets us access the first track until we know more.  */
end_comment

begin_decl_stmt
name|struct
name|disklabel
name|dflt_sizes
init|=
block|{
name|DISKMAGIC
block|,
name|DTYPE_ST506
block|,
block|{
literal|512
block|,
comment|/* sector size */
literal|17
block|,
comment|/* # of sectors per track */
literal|15
block|,
comment|/* # of tracks per cylinder */
literal|918
block|,
comment|/* # of cylinders per unit */
literal|17
operator|*
literal|15
block|,
comment|/* # of sectors per cylinder */
literal|918
operator|*
literal|15
operator|*
literal|17
block|,
comment|/* # of sectors per unit */
literal|0
comment|/* write precomp cylinder (none) */
block|}
block|,
literal|7560
block|,
literal|0
block|,
comment|/* A=root filesystem */
literal|7560
block|,
literal|56
block|,
literal|123930
block|,
literal|0
block|,
comment|/* C=whole disk */
literal|0
block|,
literal|0
block|,
literal|7560
block|,
literal|861
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|101115
block|,
literal|112
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dkbad
name|dkbad
index|[
name|NWD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|disk
name|wddrives
index|[
name|NWD
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of units */
end_comment

begin_decl_stmt
name|struct
name|buf
name|wdtab
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|wdutab
index|[
name|NWD
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of queue per drive */
end_comment

begin_decl_stmt
name|struct
name|buf
name|rwdbuf
index|[
name|NWD
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers for raw IO */
end_comment

begin_decl_stmt
name|long
name|wdxfer
index|[
name|NWD
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of transfers */
end_comment

begin_decl_stmt
name|int
name|writeprotected
index|[
name|NWD
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wdprobe
argument_list|()
decl_stmt|,
name|wdattach
argument_list|()
decl_stmt|,
name|wdintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|driver
name|wddriver
init|=
block|{
name|wdprobe
block|,
name|wdattach
block|,
literal|"wd"
block|, }
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"dbg.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  * Probe routine  */
end_comment

begin_macro
name|wdprobe
argument_list|(
argument|dvp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|device
modifier|*
name|dvp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|wdc
operator|=
name|dvp
operator|->
name|ioa
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|wdintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|,
literal|0x5a
argument_list|)
expr_stmt|;
comment|/* error register not writable */
comment|/*wdp->wd_cyl_hi = 0xff ;/* only two bits of cylhi are implemented */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
literal|0xa5
argument_list|)
expr_stmt|;
comment|/* but all of cyllo are implemented */
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
operator|!=
literal|0x5a
comment|/*&& wdp->wd_cyl_hi == 3*/
operator|&&
name|inb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|)
operator|==
literal|0xa5
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * attach each drive if possible.  */
end_comment

begin_macro
name|wdattach
argument_list|(
argument|dvp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|device
modifier|*
name|dvp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|unit
decl_stmt|;
name|INTREN
argument_list|(
operator|(
name|IRQ14
operator||
literal|4
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x3f6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read/write routine for a buffer.  Finds the proper unit, range checks  * arguments, and schedules the transfer.  Does not wait for the transfer  * to complete.  Multi-page transfers are supported.  All I/O requests must  * be a multiple of a sector in length.  */
end_comment

begin_expr_stmt
name|wdstrategy
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* IO operation to perform */
end_comment

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
comment|/* Disk unit to do the IO.	*/
name|long
name|nblocks
decl_stmt|,
name|cyloff
decl_stmt|,
name|blknum
decl_stmt|;
name|int
name|unit
init|=
name|WDUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|,
name|xunit
init|=
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
literal|7
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|unit
operator|>=
name|NWD
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"wdstrat: unit = %d, blkno = %d, bcount = %d\n"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|pg
argument_list|(
literal|"wd:error in wdstrategy"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|writeprotected
index|[
name|unit
index|]
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"wd%d: write protected\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|du
operator|=
operator|&
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|DISKSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
operator|!=
name|OPEN
condition|)
goto|goto
name|q
goto|;
comment|/* 	 * Convert DEV_BSIZE "blocks" to sectors. 	 * Note: doing the conversions this way limits the partition size 	 * to about 8 million sectors (1-8 Gb). 	 */
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|dk_secsize
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|u_long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|%
name|du
operator|->
name|dk_dd
operator|.
name|dk_secsize
operator|!=
literal|0
operator|)
operator|||
name|bp
operator|->
name|b_bcount
operator|>=
name|MAXTRANSFER
operator|*
name|CLBYTES
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|nblocks
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|dk_partition
index|[
name|xunit
index|]
operator|.
name|nblocks
expr_stmt|;
name|cyloff
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|dk_partition
index|[
name|xunit
index|]
operator|.
name|cyloff
expr_stmt|;
if|if
condition|(
name|blknum
operator|+
operator|(
name|bp
operator|->
name|b_bcount
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|dk_secsize
operator|)
operator|>
name|nblocks
condition|)
block|{
if|if
condition|(
name|blknum
operator|==
name|nblocks
condition|)
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
else|else
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bp
operator|->
name|b_cylin
operator|=
name|blknum
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|dk_secpercyl
operator|+
name|cyloff
expr_stmt|;
name|q
label|:
name|dp
operator|=
operator|&
name|wdutab
index|[
name|unit
index|]
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
name|wdustart
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* start drive if idle */
if|if
condition|(
name|wdtab
operator|.
name|b_active
operator|==
literal|0
condition|)
name|wdstart
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* start IO if controller idle */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Routine to queue a read or write command to the controller.  The request is  * linked into the active list for the controller.  If the controller is idle,  * the transfer is started.  */
end_comment

begin_expr_stmt
name|wdustart
argument_list|(
name|du
argument_list|)
specifier|register
expr|struct
name|disk
operator|*
name|du
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
operator|&
name|wdutab
index|[
name|du
operator|->
name|dk_unit
index|]
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
condition|)
return|return;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return;
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|wdtab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
comment|/* link unit into active list */
name|wdtab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|wdtab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|wdtab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
comment|/* mark the drive as busy */
block|}
end_block

begin_comment
comment|/*  * Controller startup routine.  This does the calculation, and starts  * a single-sector read or write operation.  Called to start a transfer,  * or from the interrupt routine to continue a multi-sector transfer.  * RESTRICTIONS:  * 1.	The transfer length must be an exact multiple of the sector size.  */
end_comment

begin_macro
name|wdstart
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
comment|/* disk unit for IO */
specifier|register
name|wdc
operator|=
name|IO_WD0
expr_stmt|;
comment|/*XXX*/
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|bt_bad
modifier|*
name|bt_ptr
decl_stmt|;
name|long
name|blknum
decl_stmt|,
name|pagcnt
decl_stmt|,
name|cylin
decl_stmt|,
name|head
decl_stmt|,
name|sector
decl_stmt|;
name|long
name|secpertrk
decl_stmt|,
name|secpercyl
decl_stmt|,
name|addr
decl_stmt|,
name|i
decl_stmt|;
name|int
name|minor_dev
decl_stmt|,
name|unit
decl_stmt|,
name|s
decl_stmt|;
name|loop
label|:
name|dp
operator|=
name|wdtab
operator|.
name|b_actf
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|wdtab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|unit
operator|=
name|WDUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|du
operator|=
operator|&
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|DISKSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
operator|<=
name|RDLABEL
condition|)
block|{
if|if
condition|(
name|wdcontrol
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* done */
block|}
return|return;
block|}
name|minor_dev
operator|=
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
literal|7
expr_stmt|;
name|secpertrk
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|dk_nsectors
expr_stmt|;
name|secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|dk_secpercyl
expr_stmt|;
comment|/* 	 * Convert DEV_BSIZE "blocks" to sectors. 	 */
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|dk_secsize
operator|+
name|du
operator|->
name|dk_skip
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
condition|)
block|{
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"\nwdstart %d: %s %d@%d; map "
argument_list|,
name|unit
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|" %d)"
argument_list|,
name|du
operator|->
name|dk_skip
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|addr
operator|=
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
condition|)
name|du
operator|->
name|dk_bc
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|DISKSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
operator|==
name|OPEN
condition|)
name|cylin
operator|+=
name|du
operator|->
name|dk_dd
operator|.
name|dk_partition
index|[
name|minor_dev
index|]
operator|.
name|cyloff
expr_stmt|;
comment|/*  	 * See if the current block is in the bad block list. 	 * (If we have one, and not formatting.) 	 */
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|du
operator|->
name|dk_state
operator|==
name|OPEN
condition|)
for|for
control|(
name|bt_ptr
operator|=
name|dkbad
index|[
name|unit
index|]
operator|.
name|bt_bad
init|;
name|bt_ptr
operator|->
name|bt_cyl
operator|!=
operator|-
literal|1
condition|;
name|bt_ptr
operator|++
control|)
block|{
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|>
name|cylin
condition|)
comment|/* Sorted list, and we passed our cylinder. quit. */
break|break;
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|==
name|cylin
operator|&&
name|bt_ptr
operator|->
name|bt_trksec
operator|==
operator|(
name|head
operator|<<
literal|8
operator|)
operator|+
name|sector
condition|)
block|{
comment|/* 			 * Found bad block.  Calculate new block addr. 			 * This starts at the end of the disk (skip the 			 * last track which is used for the bad block list), 			 * and works backwards to the front of the disk. 			 */
ifdef|#
directive|ifdef
name|WDDEBUG
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"--- badblock code -> Old = %d; "
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|blknum
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|dk_secperunit
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|dk_nsectors
operator|-
operator|(
name|bt_ptr
operator|-
name|dkbad
index|[
name|unit
index|]
operator|.
name|bt_bad
operator|)
operator|-
literal|1
expr_stmt|;
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"new = %d\n"
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
endif|#
directive|endif
name|wdtab
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
comment|/* mark controller active */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_precomp
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/*wr(wdc+wd_precomp, du->dk_dd.dk_precompcyl / 4);*/
comment|/*if (bp->b_flags& B_FORMAT) { 		wr(wdc+wd_sector, du->dk_dd.dk_gap3); 		wr(wdc+wd_seccnt, du->dk_dd.dk_nsectors); 	} else {*/
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
name|cylin
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|,
name|cylin
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* Set up the SDH register (select drive).     */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
operator||
operator|(
name|head
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_altsts
argument_list|)
operator|&
name|WDCS_READY
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/*if (bp->b_flags& B_FORMAT) 		wr(wdc+wd_command, WDCC_FORMAT); 	else*/
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|WDCC_READ
else|:
name|WDCC_WRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
condition|)
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"sector %d cylin %d head %d addr %x\n"
argument_list|,
name|sector
argument_list|,
name|cylin
argument_list|,
name|head
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this is a read operation, just go away until it's done.	*/
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
return|return;
comment|/* Ready to send data?	*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_altsts
argument_list|)
operator|&
name|WDCS_DRQ
operator|)
operator|==
literal|0
condition|)
name|nulldev
argument_list|()
expr_stmt|;
comment|/* So compiler won't optimize out */
comment|/* ASSUMES CONTIGUOUS MEMORY */
block|{
specifier|register
name|buff_addr
expr_stmt|;
name|buff_addr
operator|=
name|addr
expr_stmt|;
name|buff_addr
operator|+=
operator|(
name|du
operator|->
name|dk_skip
operator|*
literal|512
operator|)
comment|/*& CLOFSET*/
expr_stmt|;
name|outsw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
name|buff_addr
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
name|du
operator|->
name|dk_bc
operator|-=
literal|512
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * these are globally defined so they can be found  * by the debugger easily in the case of a system crash  */
end_comment

begin_decl_stmt
name|daddr_t
name|wd_errsector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|wd_errbn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|wd_errstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interrupt routine for the controller.  Acknowledge the interrupt, check for  * errors on the current operation, mark it done if necessary, and start  * the next request.  Also check for a partially done transfer, and  * continue with the next chunk if so.  */
end_comment

begin_macro
name|wdintr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|wdc
operator|=
name|IO_WD0
expr_stmt|;
comment|/*XXX*/
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
name|partch
decl_stmt|;
comment|/* Shouldn't need this, but it may be a slow controller.	*/
while|while
condition|(
operator|(
name|status
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_altsts
argument_list|)
operator|)
operator|&
name|WDCS_BUSY
condition|)
name|nulldev
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|wdtab
operator|.
name|b_active
condition|)
block|{
name|printf
argument_list|(
literal|"wd: extra interrupt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|WDDEBUGx
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"I "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
name|wdtab
operator|.
name|b_actf
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|du
operator|=
operator|&
name|wddrives
index|[
name|WDUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|partch
operator|=
literal|"abcdefgh"
index|[
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
literal|7
index|]
expr_stmt|;
if|if
condition|(
name|DISKSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
operator|<=
name|RDLABEL
condition|)
block|{
if|if
condition|(
name|wdcontrol
argument_list|(
name|bp
argument_list|)
condition|)
goto|goto
name|done
goto|;
return|return;
block|}
if|if
condition|(
name|status
operator|&
operator|(
name|WDCS_ERR
operator||
name|WDCS_ECCCOR
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"error %x\n"
argument_list|,
name|wd_errstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*if (bp->b_flags& B_FORMAT) { 			du->dk_status = status; 			du->dk_error = wdp->wd_error; 			bp->b_flags |= B_ERROR; 			goto done; 		}*/
name|wd_errstat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
expr_stmt|;
comment|/* save error status */
name|wd_errsector
operator|=
operator|(
name|bp
operator|->
name|b_cylin
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|dk_secpercyl
operator|)
operator|+
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|dk_secsize
operator|)
operator|%
name|du
operator|->
name|dk_dd
operator|.
name|dk_secpercyl
operator|)
operator|+
name|du
operator|->
name|dk_skip
expr_stmt|;
name|wd_errbn
operator|=
name|bp
operator|->
name|b_blkno
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|dk_secsize
operator|/
name|DEV_BSIZE
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|WDCS_ERR
condition|)
block|{
if|if
condition|(
operator|++
name|wdtab
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
name|wdtab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"wd%d%c: "
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|partch
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"hard %s error, sn %d bn %d status %b error %b\n"
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|wd_errsector
argument_list|,
name|wd_errbn
argument_list|,
name|status
argument_list|,
name|WDCS_BITS
argument_list|,
name|wd_errstat
argument_list|,
name|WDERR_BITS
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* flag the error */
block|}
block|}
else|else
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wd%d%c: soft ecc sn %d bn %d\n"
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|partch
argument_list|,
name|wd_errsector
argument_list|,
name|wd_errbn
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this was a successful read operation, fetch the data. 	 */
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_READ
operator||
name|B_ERROR
operator|)
operator|)
operator|==
name|B_READ
operator|)
operator|&&
name|wdtab
operator|.
name|b_active
condition|)
block|{
name|int
name|chk
decl_stmt|,
name|dummy
decl_stmt|;
name|chk
operator|=
name|min
argument_list|(
literal|256
argument_list|,
operator|(
name|du
operator|->
name|dk_bc
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* Ready to receive data?	*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_DRQ
operator|)
operator|==
literal|0
condition|)
name|nulldev
argument_list|()
expr_stmt|;
comment|/*dprintf(DDSK,"addr %x\n", (int)bp->b_un.b_addr + du->dk_skip * 512);*/
name|insw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|du
operator|->
name|dk_skip
operator|*
literal|512
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_bc
operator|-=
literal|2
operator|*
name|chk
expr_stmt|;
while|while
condition|(
name|chk
operator|++
operator|<
literal|256
condition|)
name|insw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|wdxfer
index|[
name|du
operator|->
name|dk_unit
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|wdtab
operator|.
name|b_active
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_skip
operator|++
expr_stmt|;
comment|/* Add to successful sectors. */
if|if
condition|(
name|wdtab
operator|.
name|b_errcnt
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wd%d%c: "
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|partch
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"soft %s error, sn %d bn %d error %b retries %d\n"
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|wd_errsector
argument_list|,
name|wd_errbn
argument_list|,
name|wd_errstat
argument_list|,
name|WDERR_BITS
argument_list|,
name|wdtab
operator|.
name|b_errcnt
argument_list|)
expr_stmt|;
block|}
name|wdtab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
comment|/* see if more to transfer */
comment|/*if (du->dk_skip< (bp->b_bcount + 511) / 512) {*/
if|if
condition|(
name|du
operator|->
name|dk_bc
operator|>
literal|0
condition|)
block|{
name|wdstart
argument_list|()
expr_stmt|;
return|return;
comment|/* next chunk is started */
block|}
block|}
name|done
label|:
comment|/* done with this transfer, with or without error */
name|wdtab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
name|wdtab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_skip
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|dp
operator|->
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|wdtab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
name|wdustart
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* requeue disk if more io to do */
if|if
condition|(
name|wdtab
operator|.
name|b_actf
condition|)
name|wdstart
argument_list|()
expr_stmt|;
comment|/* start IO on next drive */
block|}
end_block

begin_comment
comment|/*  * Initialize a drive.  */
end_comment

begin_macro
name|wdopen
argument_list|(
argument|dev
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|struct
name|dkbad
modifier|*
name|db
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|unit
operator|=
name|WDUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/*dprintf(DDSK,"wdopen %x\n",unit);*/
if|if
condition|(
name|unit
operator|>=
name|NWD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|du
operator|=
operator|&
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_open
condition|)
block|{
name|du
operator|->
name|dk_open
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already is open, don't mess with it */
block|}
ifdef|#
directive|ifdef
name|THE_BUG
if|if
condition|(
name|du
operator|->
name|dk_state
operator|&&
name|DISKSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
operator|<=
name|OPEN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
name|du
operator|->
name|dk_unit
operator|=
name|unit
expr_stmt|;
name|wdutab
index|[
name|unit
index|]
operator|.
name|b_actf
operator|=
name|NULL
expr_stmt|;
comment|/*if (flags& O_NDELAY) 		du->dk_state = WANTOPENRAW; 	else*/
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
comment|/* 	 * Use the default sizes until we've read the label, 	 * or longer if there isn't one there. 	 */
name|du
operator|->
name|dk_dd
operator|=
name|dflt_sizes
expr_stmt|;
comment|/* 	 * Recal, read of disk label will be done in wdcontrol 	 * during first read operation. 	 */
name|bp
operator|=
name|geteblk
argument_list|(
literal|512
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|bp
operator|->
name|b_bcount
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_READ
expr_stmt|;
name|wdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|error
operator|=
name|ENXIO
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|CLOSED
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|du
operator|->
name|dk_state
operator|==
name|OPENRAW
condition|)
block|{
name|du
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * Read bad sector table into memory. 	 */
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|dk_secperunit
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|dk_nsectors
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_dd
operator|.
name|dk_secsize
operator|>
name|DEV_BSIZE
condition|)
name|bp
operator|->
name|b_blkno
operator|*=
name|du
operator|->
name|dk_dd
operator|.
name|dk_secsize
operator|/
name|DEV_BSIZE
expr_stmt|;
else|else
name|bp
operator|->
name|b_blkno
operator|/=
name|DEV_BSIZE
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|dk_secsize
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|dk_secsize
expr_stmt|;
name|bp
operator|->
name|b_cylin
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|dk_ncylinders
operator|-
literal|1
expr_stmt|;
name|wdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|&&
operator|(
name|i
operator|+=
literal|2
operator|)
operator|<
literal|10
operator|&&
name|i
operator|<
name|du
operator|->
name|dk_dd
operator|.
name|dk_nsectors
condition|)
do|;
name|db
operator|=
operator|(
expr|struct
name|dkbad
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
operator|&&
name|db
operator|->
name|bt_mbz
operator|==
literal|0
operator|&&
name|db
operator|->
name|bt_flag
operator|==
name|DKBAD_MAGIC
condition|)
block|{
name|dkbad
index|[
name|unit
index|]
operator|=
operator|*
name|db
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"wd%d: %s bad-sector file\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
condition|?
literal|"can't read"
else|:
literal|"format error in"
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
comment|/*error = ENXIO ;*/
name|du
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
block|}
else|#
directive|else
name|du
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
endif|#
directive|endif
name|done
label|:
name|bp
operator|->
name|b_flags
operator|=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|du
operator|->
name|dk_open
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Implement operations other than read/write.  * Called from wdstart or wdintr during opens and formats.  * Uses finite-state-machine to track progress of operation in progress.  * Returns 0 if operation still in progress, 1 if completed.  */
end_comment

begin_expr_stmt
name|wdcontrol
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|wdc
operator|=
name|IO_WD0
expr_stmt|;
comment|/*XXX*/
specifier|register
name|unit
expr_stmt|;
name|unsigned
name|char
name|stat
decl_stmt|;
name|int
name|s
decl_stmt|,
name|cnt
decl_stmt|;
specifier|extern
name|int
name|bootdev
decl_stmt|,
name|cyloffset
decl_stmt|;
name|cyloffset
operator|=
literal|0
expr_stmt|;
name|du
operator|=
operator|&
name|wddrives
index|[
name|WDUNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|unit
operator|=
name|du
operator|->
name|dk_unit
expr_stmt|;
switch|switch
condition|(
name|DISKSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
condition|)
block|{
name|tryagainrecal
label|:
case|case
name|WANTOPEN
case|:
comment|/* set SDH, step rate, do restore */
ifdef|#
directive|ifdef
name|WDDEBUG
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"wd%d: recal "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* not called from intr level ... */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|wdtab
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RECAL
case|:
if|if
condition|(
operator|(
name|stat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_altsts
argument_list|)
operator|)
operator|&
name|WDCS_ERR
condition|)
block|{
name|printf
argument_list|(
literal|"wd%d: recal"
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|": status %b error %b\n"
argument_list|,
name|stat
argument_list|,
name|WDCS_BITS
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
argument_list|,
name|WDERR_BITS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|wdtab
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
goto|goto
name|tryagainrecal
goto|;
block|}
goto|goto
name|badopen
goto|;
block|}
name|wdtab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISRAWSTATE
argument_list|(
name|du
operator|->
name|dk_state
argument_list|)
condition|)
block|{
name|du
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|retry
label|:
ifdef|#
directive|ifdef
name|WDDEBUG
name|dprintf
argument_list|(
name|DDSK
argument_list|,
literal|"rdlabel "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Read in sector 0 to get the pack label and geometry. 		 */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_precomp
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* sometimes this is head bit 3 */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*if (bp->b_dev == bootdev) { 			(wdc+wd_cyl_lo = cyloffset& 0xff; 			(wdc+wd_cyl_hi = cyloffset>> 8; 		} else { 			(wdc+wd_cyl_lo = 0; 			(wdc+wd_cyl_hi = 0; 		}*/
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
operator|(
name|cyloffset
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|,
operator|(
name|cyloffset
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|WDCC_READ
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|RDLABEL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RDLABEL
case|:
if|if
condition|(
operator|(
name|stat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|)
operator|&
name|WDCS_ERR
condition|)
block|{
if|if
condition|(
operator|++
name|wdtab
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
goto|goto
name|retry
goto|;
name|printf
argument_list|(
literal|"wd%d: read label"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|badopen
goto|;
block|}
name|insw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|disklabel
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|LABELOFFSET
operator|)
operator|)
operator|->
name|dk_magic
operator|==
name|DISKMAGIC
condition|)
block|{
name|du
operator|->
name|dk_dd
operator|=
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|LABELOFFSET
operator|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"wd%d: bad disk label\n"
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
block|}
if|if
condition|(
name|du
operator|->
name|dk_state
operator|==
name|RDLABEL
condition|)
name|du
operator|->
name|dk_state
operator|=
name|RDBADTBL
expr_stmt|;
comment|/* 		 * The rest of the initialization can be done 		 * by normal means. 		 */
return|return
operator|(
literal|1
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"wdcontrol %x"
argument_list|,
name|du
operator|->
name|dk_state
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
name|badopen
label|:
name|printf
argument_list|(
literal|": status %b error %b\n"
argument_list|,
name|stat
argument_list|,
name|WDCS_BITS
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
argument_list|,
name|WDERR_BITS
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|OPENRAW
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|wdclose
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|du
operator|=
operator|&
name|wddrives
index|[
name|WDUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|du
operator|->
name|dk_open
operator|--
expr_stmt|;
comment|/*if (du->dk_open == 0) du->dk_state = CLOSED ; does not work */
block|}
end_block

begin_macro
name|wdioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|addr
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|WDUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
comment|/*int wdformat();*/
name|du
operator|=
operator|&
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
operator|=
name|du
operator|->
name|dk_dd
expr_stmt|;
break|break;
case|case
name|DIOCGDINFOP
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|*
operator|)
name|addr
operator|=
operator|&
operator|(
name|du
operator|->
name|dk_dd
operator|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|notyet
case|case
name|DIOCWFORMAT
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|format_op
modifier|*
name|fop
decl_stmt|;
name|fop
operator|=
operator|(
expr|struct
name|format_op
operator|*
operator|)
name|addr
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|fop
operator|->
name|df_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|fop
operator|->
name|df_startblk
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|dk_secsize
expr_stmt|;
name|error
operator|=
name|physio
argument_list|(
name|wdformat
argument_list|,
operator|&
name|rwdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
name|fop
operator|->
name|df_count
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|fop
operator|->
name|df_reg
index|[
literal|0
index|]
operator|=
name|du
operator|->
name|dk_status
expr_stmt|;
name|fop
operator|->
name|df_reg
index|[
literal|1
index|]
operator|=
name|du
operator|->
name|dk_error
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*wdformat(bp) 	struct buf *bp; {  	bp->b_flags |= B_FORMAT; 	return (wdstrategy(bp)); }*/
end_comment

begin_comment
comment|/*  * Routines to do raw IO for a unit.  */
end_comment

begin_macro
name|wdread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_comment
comment|/* character read routine */
end_comment

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|WDUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NWD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|physio
argument_list|(
name|wdstrategy
argument_list|,
operator|&
name|rwdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|wdwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_comment
comment|/* character write routine */
end_comment

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|WDUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NWD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|physio
argument_list|(
name|wdstrategy
argument_list|,
operator|&
name|rwdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|wdsize
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unit
operator|=
name|WDUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
specifier|register
name|xunit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|07
expr_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|val
expr_stmt|;
return|return
operator|(
literal|12144
operator|)
return|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|unit
operator|>=
name|NWD
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|wddrives
index|[
name|unit
index|]
operator|.
name|dk_state
operator|==
literal|0
condition|)
comment|/*{ 		val = wdopen (dev, 0) ; 		if (val< 0) return (val) ; 	}*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|du
operator|=
operator|&
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|u_long
operator|)
name|du
operator|->
name|dk_dd
operator|.
name|dk_partition
index|[
name|xunit
index|]
operator|.
name|nblocks
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|dk_secsize
operator|/
literal|512
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|wddump
argument_list|(
argument|dev
argument_list|)
end_macro

begin_comment
comment|/* dump core after a system crash */
end_comment

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|notyet
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
comment|/* disk unit to do the IO */
specifier|register
name|struct
name|wd1010
modifier|*
name|wdp
init|=
operator|(
expr|struct
name|wd1010
operator|*
operator|)
name|VA_WD
decl_stmt|;
specifier|register
name|struct
name|bt_bad
modifier|*
name|bt_ptr
decl_stmt|;
name|long
name|num
decl_stmt|;
comment|/* number of sectors to write */
name|int
name|unit
decl_stmt|,
name|xunit
decl_stmt|;
name|long
name|cyloff
decl_stmt|,
name|blknum
decl_stmt|,
name|blkcnt
decl_stmt|;
name|long
name|cylin
decl_stmt|,
name|head
decl_stmt|,
name|sector
decl_stmt|;
name|long
name|secpertrk
decl_stmt|,
name|secpercyl
decl_stmt|,
name|nblocks
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
specifier|extern
name|int
name|dumplo
decl_stmt|,
name|totalclusters
decl_stmt|;
specifier|static
name|wddoingadump
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|PA_RAM
expr_stmt|;
comment|/* starting address */
comment|/* size of memory to dump */
name|num
operator|=
name|totalclusters
operator|*
name|CLSIZE
operator|-
name|PA_RAM
operator|/
name|PGSIZE
expr_stmt|;
name|unit
operator|=
name|WDUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* eventually support floppies? */
name|xunit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|7
expr_stmt|;
comment|/* file system */
comment|/* check for acceptable drive number */
if|if
condition|(
name|unit
operator|>=
name|NWD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|du
operator|=
operator|&
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
comment|/* was it ever initialized ? */
if|if
condition|(
name|du
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Convert to disk sectors */
name|num
operator|=
operator|(
name|u_long
operator|)
name|num
operator|*
name|PGSIZE
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|dk_secsize
expr_stmt|;
comment|/* check if controller active */
comment|/*if (wdtab.b_active) return(EFAULT); */
if|if
condition|(
name|wddoingadump
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|secpertrk
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|dk_nsectors
expr_stmt|;
name|secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|dk_secpercyl
expr_stmt|;
name|nblocks
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|dk_partition
index|[
name|xunit
index|]
operator|.
name|nblocks
expr_stmt|;
name|cyloff
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|dk_partition
index|[
name|xunit
index|]
operator|.
name|cyloff
expr_stmt|;
comment|/* check transfer bounds against partition size */
if|if
condition|(
operator|(
name|dumplo
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|dumplo
operator|+
name|num
operator|)
operator|>=
name|nblocks
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*wdtab.b_active = 1;		/* mark controller active for if we 					   panic during the dump */
name|wddoingadump
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|100000
expr_stmt|;
while|while
condition|(
operator|(
name|wdp
operator|->
name|wd_status
operator|&
name|WDCS_BUSY
operator|)
operator|&&
operator|(
name|i
operator|--
operator|>
literal|0
operator|)
condition|)
name|nulldev
argument_list|()
expr_stmt|;
name|inb
argument_list|(
argument|wdc+wd_sdh = du->dk_sdh ; 	inb(wdc+wd_command = WDCC_RESTORE | WD_STEP; 	while (inb(wdc+wd_status& WDCS_BUSY) nulldev() ; 	 	blknum = dumplo; 	while (num>
literal|0
argument|) {
ifdef|#
directive|ifdef
name|notdef
argument|if (blkcnt> MAXTRANSFER) blkcnt = MAXTRANSFER; 		if ((blknum + blkcnt -
literal|1
argument|) / secpercyl != blknum / secpercyl) 			blkcnt = secpercyl - (blknum % secpercyl);
comment|/* keep transfer within current cylinder */
endif|#
directive|endif
comment|/* compute disk address */
argument|cylin = blknum / secpercyl; 		head = (blknum % secpercyl) / secpertrk; 		sector = blknum % secpertrk; 		sector++;
comment|/* origin 1 */
argument|cylin += cyloff;
comment|/*  		 * See if the current block is in the bad block list. 		 * (If we have one.) 		 */
argument|for (bt_ptr = dkbad[unit].bt_bad; 				bt_ptr->bt_cyl != -
literal|1
argument|; bt_ptr++) { 			if (bt_ptr->bt_cyl> cylin)
comment|/* Sorted list, and we passed our cylinder. 					quit. */
argument|break; 			if (bt_ptr->bt_cyl == cylin&& 				bt_ptr->bt_trksec == (head<<
literal|8
argument|) + sector) {
comment|/* 			 * Found bad block.  Calculate new block addr. 			 * This starts at the end of the disk (skip the 			 * last track which is used for the bad block list), 			 * and works backwards to the front of the disk. 			 */
argument|blknum = (du->dk_dd.dk_secperunit) 					- du->dk_dd.dk_nsectors 					- (bt_ptr - dkbad[unit].bt_bad) -
literal|1
argument|; 				cylin = blknum / secpercyl; 				head = (blknum % secpercyl) / secpertrk; 				sector = blknum % secpertrk; 				break; 			}
comment|/* select drive.     */
argument|inb(wdc+wd_sdh = du->dk_sdh | (head&
literal|07
argument|); 		while ((inb(wdc+wd_status& WDCS_READY) ==
literal|0
argument|) nulldev();
comment|/* transfer some blocks */
argument|inb(wdc+wd_sector = sector; 		inb(wdc+wd_seccnt =
literal|1
argument|; 		inb(wdc+wd_cyl_lo = cylin; 		if (du->dk_dd.dk_ntracks>
literal|8
argument|) {  			if (head>
literal|7
argument|) 				inb(wdc+wd_precomp =
literal|0
argument|;
comment|/* set 3rd head bit */
argument|else 				inb(wdc+wd_precomp =
literal|0xff
argument|;
comment|/* set 3rd head bit */
argument|} 		inb(wdc+wd_cyl_hi = cylin>>
literal|8
argument|;
ifdef|#
directive|ifdef
name|notdef
comment|/* lets just talk about this first...*/
argument|printf (
literal|"sdh 0%o sector %d cyl %d addr 0x%x\n"
argument|, 			wdp->wd_sdh, wdp->wd_sector, 			wdp->wd_cyl_hi*
literal|256
argument|+wdp->wd_cyl_lo, addr) ; 		for (i=
literal|10000
argument|; i>
literal|0
argument|; i--) 			; 		continue;
endif|#
directive|endif
argument|inb(wdc+wd_command = WDCC_WRITE;
comment|/* Ready to send data?	*/
argument|while ((inb(wdc+wd_status& WDCS_DRQ) ==
literal|0
argument|) nulldev(); 		if (inb(wdc+wd_status& WDCS_ERR) return(EIO) ;  		end = (char *)addr + du->dk_dd.dk_secsize; 		for (; addr< end; addr +=
literal|8
argument|) { 			wdp->wd_data = addr[
literal|0
argument|]; 			wdp->wd_data = addr[
literal|1
argument|]; 			wdp->wd_data = addr[
literal|2
argument|]; 			wdp->wd_data = addr[
literal|3
argument|]; 			wdp->wd_data = addr[
literal|4
argument|]; 			wdp->wd_data = addr[
literal|5
argument|]; 			wdp->wd_data = addr[
literal|6
argument|]; 			wdp->wd_data = addr[
literal|7
argument|]; 		} 		if (inb(wdc+wd_status& WDCS_ERR) return(EIO) ;
comment|/* Check data request (should be done).         */
argument|if (inb(wdc+wd_status& WDCS_DRQ) return(EIO) ;
comment|/* wait for completion */
argument|for ( i =
literal|1000000
argument|; inb(wdc+wd_status& WDCS_BUSY ; i--) { 				if (i<
literal|0
argument|) return (EIO) ; 				nulldev () ; 		}
comment|/* error check the xfer */
argument|if (inb(wdc+wd_status& WDCS_ERR) return(EIO) ;
comment|/* update block count */
argument|num--; 		blknum++ ;
ifdef|#
directive|ifdef
name|WDDEBUG
argument|if (num %
literal|100
argument|==
literal|0
argument|) printf(
literal|"."
argument|) ;
endif|#
directive|endif
argument|} 	return(
literal|0
argument|);
endif|#
directive|endif
argument|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

