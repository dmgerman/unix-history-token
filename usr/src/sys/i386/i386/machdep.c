begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1987, 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * %sccs.include.386.c%  *  *	@(#)machdep.c	5.3 (Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"vm.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"reboot.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"inode.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"text.h"
end_include

begin_include
include|#
directive|include
file|"clist.h"
end_include

begin_include
include|#
directive|include
file|"callout.h"
end_include

begin_include
include|#
directive|include
file|"cmap.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"msgbuf.h"
end_include

begin_include
include|#
directive|include
file|"quota.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../i386/frame.h"
end_include

begin_include
include|#
directive|include
file|"../i386/reg.h"
end_include

begin_include
include|#
directive|include
file|"../i386/segments.h"
end_include

begin_include
include|#
directive|include
file|"../i386/pte.h"
end_include

begin_include
include|#
directive|include
file|"../i386/psl.h"
end_include

begin_include
include|#
directive|include
file|"../i386/isa/rtc.h"
end_include

begin_comment
comment|/*  * Declare these as initialized data so we can patch them.  */
end_comment

begin_decl_stmt
name|int
name|nswbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NBUF
end_ifdef

begin_decl_stmt
name|int
name|nbuf
init|=
name|NBUF
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|nbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BUFPAGES
end_ifdef

begin_decl_stmt
name|int
name|bufpages
init|=
name|BUFPAGES
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|bufpages
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|kernmem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Machine-dependent startup code  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|Sysbase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|sbase
init|=
block|{
operator|&
name|Sysbase
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* extern struct pte	EMCmap[]; extern char		EMCbase[]; */
end_comment

begin_decl_stmt
name|int
name|boothowto
init|=
literal|0
decl_stmt|,
name|Maxmem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bootdev
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMALL
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|forcemaxmem
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|biosmem
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern cyloffset;
end_extern

begin_function
name|caddr_t
name|bypasshole
parameter_list|(
name|b
parameter_list|,
name|t
parameter_list|)
name|caddr_t
name|b
decl_stmt|,
name|t
decl_stmt|;
block|{
if|if
condition|(
name|b
operator|<=
name|sbase
operator|+
literal|0xa0000
operator|&&
name|t
operator|>
name|sbase
operator|+
literal|0xa0000
condition|)
return|return
operator|(
name|sbase
operator|+
literal|0x100000
operator|)
return|;
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_macro
name|startup
argument_list|(
argument|firstaddr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|firstaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unixsize
decl_stmt|;
specifier|register
name|unsigned
name|i
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
name|int
name|mapaddr
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|caddr_t
name|v
decl_stmt|;
name|int
name|maxbufs
decl_stmt|,
name|base
decl_stmt|,
name|residual
decl_stmt|;
specifier|extern
name|struct
name|map
modifier|*
name|useriomap
decl_stmt|;
comment|/* 	 * Initialize the console before we print anything out. 	 */
comment|/*cninit();*/
comment|/* 	 * Bounds check memory size information against bios values 	 * use the lesser of the two 	 */
name|biosmem
operator|=
name|rtcin
argument_list|(
name|RTC_BASELO
argument_list|)
operator|+
operator|(
name|rtcin
argument_list|(
name|RTC_BASEHI
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Maxmem %x howto %x bootdev %x cyloff %x firstaddr %x bios %d %d\n"
argument_list|,
name|Maxmem
argument_list|,
name|boothowto
argument_list|,
name|bootdev
argument_list|,
name|cyloffset
argument_list|,
name|firstaddr
argument_list|,
name|biosmem
argument_list|,
name|rtcin
argument_list|(
name|RTC_EXTLO
argument_list|)
operator|+
operator|(
name|rtcin
argument_list|(
name|RTC_EXTHI
argument_list|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|maxmem
operator|=
name|Maxmem
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|biosmem
operator|!=
literal|640
condition|)
name|panic
argument_list|(
literal|"does not have 640K of base memory"
argument_list|)
expr_stmt|;
name|biosmem
operator|=
literal|1024
expr_stmt|;
name|biosmem
operator|+=
name|rtcin
argument_list|(
name|RTC_EXTLO
argument_list|)
operator|+
operator|(
name|rtcin
argument_list|(
name|RTC_EXTHI
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|biosmem
operator|=
name|biosmem
operator|/
literal|4
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|biosmem
operator|<
name|maxmem
condition|)
name|maxmem
operator|=
name|biosmem
expr_stmt|;
ifdef|#
directive|ifdef
name|SMALL
if|if
condition|(
name|forcemaxmem
operator|&&
name|maxmem
operator|>
name|forcemaxmem
condition|)
name|maxmem
operator|=
name|forcemaxmem
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* maxmem = 0xA00;*/
comment|/* 	 * Initialize error message buffer (at end of core). 	 */
comment|/* Problem to resolve. AT's have memory that is not contigous, as I/O address space for video adapters and network cards fall into a range of 0xa0000 - 0x100000 . Note that the cmap really expects contigous memory. For the moment, use the bottom of memory for kernel and run-time configured storage (e.g. valloc), using memory above 0x100000 for the cmap, and wasting the stuff left over after valloc-end up to 0xa0000 (640K). Will have to fix this before beta, and will have to somehow move this out into per bus adapter directory (e.g. configurable). For now, punt  How about starting cmap normally following valloc space, and then write a routine than allocs only phys pages in the 0xa0000-0x100000 hole?  */
name|maxmem
operator|-=
name|btoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
name|pte
operator|=
name|msgbufmap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|btoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msgbuf
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|++
operator|=
name|PG_V
operator||
name|PG_KW
operator||
name|ctob
argument_list|(
name|maxmem
operator|+
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* XXX EMC */
name|pte
operator|=
name|EMCmap
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|=
name|PG_V
operator||
name|PG_UW
operator||
literal|0xc0000000
expr_stmt|;
name|printf
argument_list|(
literal|"EMC at %x\n"
argument_list|,
name|EMCbase
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|freemem
operator|=
name|physmem
operator|=
name|maxmem
expr_stmt|;
name|load_cr3
argument_list|(
name|_cr3
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDB
name|kdb_init
argument_list|()
expr_stmt|;
comment|/* startup kernel debugger */
endif|#
directive|endif
comment|/* 	 * Good {morning,afternoon,evening,night}. 	 */
name|printf
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"real mem  = %d\n"
argument_list|,
name|ctob
argument_list|(
name|physmem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space for system data structures. 	 * The first available real memory address is in "firstaddr". 	 * The first available kernel virtual address is in "v". 	 * As pages of kernel virtual memory are allocated, "v" is incremented. 	 * As pages of memory are allocated and cleared, 	 * "firstaddr" is incremented. 	 * An index into the kernel page table corresponding to the 	 * virtual memory address maintained in "v" is kept in "mapaddr". 	 */
name|v
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|sbase
operator|+
operator|(
name|firstaddr
operator|*
name|NBPG
operator|)
argument_list|)
expr_stmt|;
comment|/*v = sbase + (firstaddr * NBPG);*/
define|#
directive|define
name|valloc
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|num
parameter_list|)
define|\
value|v = bypasshole (v, v + (int) ((name)+(num))) ; \ 	    (name) = (type *)v; v = (caddr_t)((name)+(num))
define|#
directive|define
name|valloclim
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|num
parameter_list|,
name|lim
parameter_list|)
define|\
value|v = bypasshole (v, v + (int) ((name)+(num))) ; \ 	    (name) = (type *)v; v = (caddr_t)((lim) = ((name)+(num)))
name|valloclim
argument_list|(
name|inode
argument_list|,
expr|struct
name|inode
argument_list|,
name|ninode
argument_list|,
name|inodeNINODE
argument_list|)
expr_stmt|;
name|valloclim
argument_list|(
name|file
argument_list|,
expr|struct
name|file
argument_list|,
name|nfile
argument_list|,
name|fileNFILE
argument_list|)
expr_stmt|;
name|valloclim
argument_list|(
name|proc
argument_list|,
expr|struct
name|proc
argument_list|,
name|nproc
argument_list|,
name|procNPROC
argument_list|)
expr_stmt|;
name|valloclim
argument_list|(
name|text
argument_list|,
expr|struct
name|text
argument_list|,
name|ntext
argument_list|,
name|textNTEXT
argument_list|)
expr_stmt|;
name|valloc
argument_list|(
name|cfree
argument_list|,
expr|struct
name|cblock
argument_list|,
name|nclist
argument_list|)
expr_stmt|;
name|valloc
argument_list|(
name|callout
argument_list|,
expr|struct
name|callout
argument_list|,
name|ncallout
argument_list|)
expr_stmt|;
name|valloc
argument_list|(
name|swapmap
argument_list|,
expr|struct
name|map
argument_list|,
name|nswapmap
operator|=
name|nproc
operator|*
literal|2
argument_list|)
expr_stmt|;
name|valloc
argument_list|(
name|argmap
argument_list|,
expr|struct
name|map
argument_list|,
name|ARGMAPSIZE
argument_list|)
expr_stmt|;
name|valloc
argument_list|(
name|kernelmap
argument_list|,
expr|struct
name|map
argument_list|,
name|nproc
argument_list|)
expr_stmt|;
name|valloc
argument_list|(
name|useriomap
argument_list|,
expr|struct
name|map
argument_list|,
name|nproc
argument_list|)
expr_stmt|;
name|valloc
argument_list|(
name|mbmap
argument_list|,
expr|struct
name|map
argument_list|,
name|nmbclusters
operator|/
literal|4
argument_list|)
expr_stmt|;
name|valloc
argument_list|(
name|namecache
argument_list|,
expr|struct
name|namecache
argument_list|,
name|nchsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
name|valloclim
argument_list|(
name|quota
argument_list|,
expr|struct
name|quota
argument_list|,
name|nquota
argument_list|,
name|quotaNQUOTA
argument_list|)
expr_stmt|;
name|valloclim
argument_list|(
name|dquot
argument_list|,
expr|struct
name|dquot
argument_list|,
name|ndquot
argument_list|,
name|dquotNDQUOT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Determine how many buffers to allocate. 	 * Use 10% of memory for the first 2 Meg, 5% of the remaining 	 * memory. Insure a minimum of 16 buffers. 	 * We allocate 1/2 as many swap buffer headers as file i/o buffers. 	 */
if|if
condition|(
name|bufpages
operator|==
literal|0
condition|)
if|if
condition|(
name|physmem
operator|<
operator|(
literal|2
operator|*
literal|1024
operator|*
literal|1024
operator|)
condition|)
name|bufpages
operator|=
name|physmem
operator|/
literal|10
operator|/
name|CLSIZE
expr_stmt|;
else|else
name|bufpages
operator|=
operator|(
operator|(
literal|2
operator|*
literal|1024
operator|*
literal|1024
operator|+
name|physmem
operator|)
operator|/
literal|20
operator|)
operator|/
name|CLSIZE
expr_stmt|;
if|if
condition|(
name|nbuf
operator|==
literal|0
condition|)
block|{
name|nbuf
operator|=
name|bufpages
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|nbuf
operator|<
literal|16
condition|)
name|nbuf
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|nswbuf
operator|==
literal|0
condition|)
block|{
name|nswbuf
operator|=
operator|(
name|nbuf
operator|/
literal|2
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
comment|/* force even */
if|if
condition|(
name|nswbuf
operator|>
literal|256
condition|)
name|nswbuf
operator|=
literal|256
expr_stmt|;
comment|/* sanity */
block|}
name|valloc
argument_list|(
name|swbuf
argument_list|,
expr|struct
name|buf
argument_list|,
name|nswbuf
argument_list|)
expr_stmt|;
comment|/* 	 * Now the amount of virtual memory remaining for buffers 	 * can be calculated, estimating needs for the cmap. 	 */
name|ncmap
operator|=
operator|(
name|maxmem
operator|*
name|NBPG
operator|-
operator|(
call|(
name|int
call|)
argument_list|(
name|v
operator|-
name|sbase
argument_list|)
operator|)
operator|)
operator|/
operator|(
name|CLBYTES
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cmap
argument_list|)
operator|)
operator|+
literal|2
expr_stmt|;
name|maxbufs
operator|=
operator|(
operator|(
name|SYSPTSIZE
operator|*
name|NBPG
operator|)
operator|-
operator|(
call|(
name|int
call|)
argument_list|(
name|v
operator|-
name|sbase
operator|+
name|ncmap
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cmap
argument_list|)
argument_list|)
operator|)
operator|)
operator|/
operator|(
name|MAXBSIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|buf
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|maxbufs
operator|<
literal|16
condition|)
name|panic
argument_list|(
literal|"sys pt too small"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbuf
operator|>
name|maxbufs
condition|)
block|{
name|printf
argument_list|(
literal|"SYSPTSIZE limits number of buffers to %d\n"
argument_list|,
name|maxbufs
argument_list|)
expr_stmt|;
name|nbuf
operator|=
name|maxbufs
expr_stmt|;
block|}
if|if
condition|(
name|bufpages
operator|>
name|nbuf
operator|*
operator|(
name|MAXBSIZE
operator|/
name|CLBYTES
operator|)
condition|)
name|bufpages
operator|=
name|nbuf
operator|*
operator|(
name|MAXBSIZE
operator|/
name|CLBYTES
operator|)
expr_stmt|;
name|valloc
argument_list|(
name|buf
argument_list|,
expr|struct
name|buf
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space for core map. 	 * Allow space for all of physical memory minus the amount  	 * dedicated to the system. The amount of physical memory 	 * dedicated to the system is the total virtual memory of 	 * the system thus far, plus core map, buffer pages, 	 * and buffer headers not yet allocated. 	 * Add 2: 1 because the 0th entry is unused, 1 for rounding. 	 */
comment|/*ncmap = (maxmem*NBPG - ((int)((v - sbase) + bufpages*CLBYTES))) /*/
name|ncmap
operator|=
operator|(
name|maxmem
operator|*
name|NBPG
operator|-
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|v
operator|-
name|sbase
operator|)
operator|+
name|bufpages
operator|*
name|CLBYTES
argument_list|)
operator|)
operator|)
operator|/
operator|(
name|CLBYTES
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cmap
argument_list|)
operator|)
operator|+
literal|2
expr_stmt|;
name|valloclim
argument_list|(
name|cmap
argument_list|,
expr|struct
name|cmap
argument_list|,
name|ncmap
argument_list|,
name|ecmap
argument_list|)
expr_stmt|;
comment|/* 	 * Clear space allocated thus far, and make r/w entries 	 * for the space in the kernel map. 	 */
name|unixsize
operator|=
name|btoc
argument_list|(
call|(
name|int
call|)
argument_list|(
name|v
operator|-
name|sbase
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|firstaddr
operator|<
name|unixsize
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|Sysmap
index|[
name|firstaddr
index|]
operator|)
operator|=
name|PG_V
operator||
name|PG_KW
operator||
name|ctob
argument_list|(
name|firstaddr
argument_list|)
expr_stmt|;
name|clearseg
argument_list|(
operator|(
name|unsigned
operator|)
name|firstaddr
argument_list|)
expr_stmt|;
name|firstaddr
operator|++
expr_stmt|;
block|}
comment|/* 	 * Now allocate buffers proper.  They are different than the above 	 * in that they usually occupy more virtual memory than physical. 	 */
name|v
operator|=
name|bypasshole
argument_list|(
name|v
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|v
operator|+
name|PGOFSET
argument_list|)
operator|&
operator|~
name|PGOFSET
operator|+
name|MAXBSIZE
operator|*
name|nbuf
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
call|(
name|caddr_t
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|v
operator|+
name|PGOFSET
argument_list|)
operator|&
operator|~
name|PGOFSET
argument_list|)
expr_stmt|;
name|valloc
argument_list|(
name|buffers
argument_list|,
name|char
argument_list|,
name|MAXBSIZE
operator|*
name|nbuf
argument_list|)
expr_stmt|;
name|base
operator|=
name|bufpages
operator|/
name|nbuf
expr_stmt|;
name|residual
operator|=
name|bufpages
operator|%
name|nbuf
expr_stmt|;
name|mapaddr
operator|=
name|firstaddr
operator|=
name|btoc
argument_list|(
operator|(
name|unsigned
operator|)
name|buffers
operator|-
operator|(
name|unsigned
operator|)
name|sbase
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|residual
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|base
operator|+
literal|1
operator|)
operator|*
name|CLSIZE
condition|;
name|j
operator|++
control|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|Sysmap
index|[
name|mapaddr
operator|+
name|j
index|]
operator|)
operator|=
name|PG_V
operator||
name|PG_KW
operator||
name|ctob
argument_list|(
name|firstaddr
argument_list|)
expr_stmt|;
name|clearseg
argument_list|(
operator|(
name|unsigned
operator|)
name|firstaddr
argument_list|)
expr_stmt|;
name|firstaddr
operator|++
expr_stmt|;
block|}
name|mapaddr
operator|+=
name|MAXBSIZE
operator|/
name|NBPG
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|residual
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|base
operator|*
name|CLSIZE
condition|;
name|j
operator|++
control|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|Sysmap
index|[
name|mapaddr
operator|+
name|j
index|]
operator|)
operator|=
name|PG_V
operator||
name|PG_KW
operator||
name|ctob
argument_list|(
name|firstaddr
argument_list|)
expr_stmt|;
name|clearseg
argument_list|(
operator|(
name|unsigned
operator|)
name|firstaddr
argument_list|)
expr_stmt|;
name|firstaddr
operator|++
expr_stmt|;
block|}
name|mapaddr
operator|+=
name|MAXBSIZE
operator|/
name|NBPG
expr_stmt|;
block|}
name|unixsize
operator|=
name|btoc
argument_list|(
call|(
name|int
call|)
argument_list|(
name|v
operator|-
name|sbase
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstaddr
operator|>=
name|physmem
operator|-
literal|8
operator|*
name|UPAGES
condition|)
name|panic
argument_list|(
literal|"no memory"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize callouts 	 */
name|callfree
operator|=
name|callout
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ncallout
condition|;
name|i
operator|++
control|)
name|callout
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|c_next
operator|=
operator|&
name|callout
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Initialize memory allocator and swap 	 * and user page table maps. 	 * 	 * THE USER PAGE TABLE MAP IS CALLED ``kernelmap'' 	 * WHICH IS A VERY UNDESCRIPTIVE AND INCONSISTENT NAME. 	 */
comment|/* 	 *  cmap must not allocate the hole, so toss memory 	 */
if|if
condition|(
name|firstaddr
operator|<
literal|640
operator|/
literal|4
operator|&&
name|maxmem
operator|>
literal|1024
operator|/
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"[not using %dK due to hole]\n"
argument_list|,
literal|4
operator|*
operator|(
literal|640
operator|/
literal|4
operator|-
name|firstaddr
operator|)
argument_list|)
expr_stmt|;
name|firstaddr
operator|=
literal|0x100
expr_stmt|;
block|}
if|if
condition|(
name|maxmem
operator|<
literal|2048
operator|/
literal|4
operator|-
literal|10
condition|)
name|printf
argument_list|(
literal|"WARNING: NOT ENOUGH RAM MEMORY - RUNNING IN DEGRADED MODE\n"
argument_list|)
expr_stmt|;
name|meminit
argument_list|(
name|firstaddr
argument_list|,
name|maxmem
argument_list|)
expr_stmt|;
name|maxmem
operator|=
name|freemem
expr_stmt|;
name|printf
argument_list|(
literal|"avail mem = %d\n"
argument_list|,
name|ctob
argument_list|(
name|maxmem
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"using %d buffers containing %d bytes of memory\n"
argument_list|,
name|nbuf
argument_list|,
name|bufpages
operator|*
name|CLBYTES
argument_list|)
expr_stmt|;
name|rminit
argument_list|(
name|kernelmap
argument_list|,
operator|(
name|long
operator|)
name|USRPTSIZE
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|"usrpt"
argument_list|,
name|nproc
argument_list|)
expr_stmt|;
comment|/*  * PTEs for mapping user space into kernel for phyio operations.  * One page is enough to handle 4Mb of simultaneous raw IO operations.  */
name|rminit
argument_list|(
name|useriomap
argument_list|,
operator|(
name|long
operator|)
name|USRIOSIZE
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|,
literal|"usrio"
argument_list|,
name|nproc
argument_list|)
expr_stmt|;
name|rminit
argument_list|(
name|mbmap
argument_list|,
call|(
name|long
call|)
argument_list|(
name|nmbclusters
operator|*
name|CLSIZE
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|CLSIZE
argument_list|,
literal|"mbclusters"
argument_list|,
name|nmbclusters
operator|/
literal|4
argument_list|)
expr_stmt|;
comment|/*intenable = 1;		/* Enable interrupts from now on */
comment|/* 	 * Set up CPU-specific registers, cache, etc. 	 */
name|initcpu
argument_list|()
expr_stmt|;
comment|/* 	 * Set up buffers, so they can be used to read disk labels. 	 */
name|bhinit
argument_list|()
expr_stmt|;
name|binit
argument_list|()
expr_stmt|;
comment|/* 	 * Configure the system. 	 */
name|configure
argument_list|()
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|PGINPROF
end_ifdef

begin_comment
comment|/*  * Return the difference (in microseconds)  * between the  current time and a previous  * time as represented  by the arguments.  * If there is a pending clock interrupt  * which has not been serviced due to high  * ipl, return error code.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|vmtime
argument_list|(
name|otime
argument_list|,
name|olbolt
argument_list|,
name|oicr
argument_list|)
specifier|register
name|int
name|otime
operator|,
name|olbolt
operator|,
name|oicr
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
operator|(
operator|(
name|time
operator|.
name|tv_sec
operator|-
name|otime
operator|)
operator|*
literal|60
operator|+
name|lbolt
operator|-
name|olbolt
operator|)
operator|*
literal|16667
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|sigframe
block|{
name|int
name|sf_signum
decl_stmt|;
name|int
name|sf_code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|sf_scp
decl_stmt|;
name|int
function_decl|(
modifier|*
name|sf_handler
function_decl|)
parameter_list|()
function_decl|;
name|int
name|sf_eax
decl_stmt|;
name|int
name|sf_edx
decl_stmt|;
name|int
name|sf_ecx
decl_stmt|;
name|struct
name|save87
name|sf_fsave
decl_stmt|;
comment|/* fpu coproc */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Send an interrupt to process.  *  * Stack is set up to allow sigcode stored  * in u. to call routine, followed by kcall  * to sigreturn routine below.  After sigreturn  * resets the signal mask, the stack, and the  * frame pointer, it returns to the user  * specified pc, psl.  */
end_comment

begin_macro
name|sendsig
argument_list|(
argument|p
argument_list|,
argument|sig
argument_list|,
argument|mask
argument_list|,
argument|frmtrp
argument_list|)
end_macro

begin_decl_stmt
name|int
argument_list|(
operator|*
name|p
argument_list|)
argument_list|()
decl_stmt|,
name|sig
decl_stmt|,
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
specifier|register
name|int
modifier|*
name|regs
decl_stmt|;
specifier|register
name|struct
name|sigframe
modifier|*
name|fp
decl_stmt|;
name|int
name|oonstack
decl_stmt|;
include|#
directive|include
file|"dbg.h"
name|dprintf
argument_list|(
name|DSIGNAL
argument_list|,
literal|"sendsig %d code %d to pid %d frmtrp %d to locn %x\n"
argument_list|,
name|sig
argument_list|,
name|u
operator|.
name|u_code
argument_list|,
name|u
operator|.
name|u_procp
operator|->
name|p_pid
argument_list|,
name|frmtrp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|regs
operator|=
name|u
operator|.
name|u_ar0
expr_stmt|;
name|oonstack
operator|=
name|u
operator|.
name|u_onstack
expr_stmt|;
comment|/* 	 * Allocate and validate space for the signal handler 	 * context. Note that if the stack is in P0 space, the 	 * call to grow() is a nop, and the useracc() check 	 * will fail if the process has not already allocated 	 * the space with a `brk'. 	 */
if|if
condition|(
operator|!
name|u
operator|.
name|u_onstack
operator|&&
operator|(
name|u
operator|.
name|u_sigonstack
operator|&
name|sigmask
argument_list|(
name|sig
argument_list|)
operator|)
condition|)
block|{
name|scp
operator|=
operator|(
expr|struct
name|sigcontext
operator|*
operator|)
name|u
operator|.
name|u_sigsp
operator|-
literal|1
expr_stmt|;
name|u
operator|.
name|u_onstack
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|frmtrp
condition|)
name|scp
operator|=
operator|(
expr|struct
name|sigcontext
operator|*
operator|)
name|regs
index|[
name|tESP
index|]
operator|-
literal|1
expr_stmt|;
else|else
name|scp
operator|=
operator|(
expr|struct
name|sigcontext
operator|*
operator|)
name|regs
index|[
name|sESP
index|]
operator|-
literal|1
expr_stmt|;
block|}
name|fp
operator|=
operator|(
expr|struct
name|sigframe
operator|*
operator|)
name|scp
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|fp
operator|<=
name|USRSTACK
operator|-
name|ctob
argument_list|(
name|u
operator|.
name|u_ssize
argument_list|)
condition|)
operator|(
name|void
operator|)
name|grow
argument_list|(
operator|(
name|unsigned
operator|)
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|,
name|B_WRITE
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Process has trashed its stack; give it an illegal 		 * instruction to halt it in its tracks. 		 */
name|printf
argument_list|(
literal|"sendsig: failed to grow stack down to %x\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_signal
index|[
name|SIGILL
index|]
operator|=
name|SIG_DFL
expr_stmt|;
name|sig
operator|=
name|sigmask
argument_list|(
name|SIGILL
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_sigignore
operator|&=
operator|~
name|sig
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_sigcatch
operator|&=
operator|~
name|sig
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_sigmask
operator|&=
operator|~
name|sig
expr_stmt|;
name|psignal
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  	 * Build the argument list for the signal handler. 	 */
name|fp
operator|->
name|sf_signum
operator|=
name|sig
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|SIGILL
operator|||
name|sig
operator|==
name|SIGFPE
condition|)
block|{
name|fp
operator|->
name|sf_code
operator|=
name|u
operator|.
name|u_code
expr_stmt|;
name|u
operator|.
name|u_code
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fp
operator|->
name|sf_code
operator|=
literal|0
expr_stmt|;
comment|/* indicate trap occured from system call */
if|if
condition|(
operator|!
name|frmtrp
condition|)
name|fp
operator|->
name|sf_code
operator||=
literal|0x80
expr_stmt|;
name|fp
operator|->
name|sf_scp
operator|=
name|scp
expr_stmt|;
name|fp
operator|->
name|sf_handler
operator|=
name|p
expr_stmt|;
comment|/* save scratch registers */
if|if
condition|(
name|frmtrp
condition|)
block|{
name|fp
operator|->
name|sf_eax
operator|=
name|regs
index|[
name|tEAX
index|]
expr_stmt|;
name|fp
operator|->
name|sf_edx
operator|=
name|regs
index|[
name|tEDX
index|]
expr_stmt|;
name|fp
operator|->
name|sf_ecx
operator|=
name|regs
index|[
name|tECX
index|]
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|sf_eax
operator|=
name|regs
index|[
name|sEAX
index|]
expr_stmt|;
name|fp
operator|->
name|sf_edx
operator|=
name|regs
index|[
name|sEDX
index|]
expr_stmt|;
name|fp
operator|->
name|sf_ecx
operator|=
name|regs
index|[
name|sECX
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX FPU state? */
endif|#
directive|endif
comment|/* 	 * Build the signal context to be used by sigreturn. 	 */
name|scp
operator|->
name|sc_onstack
operator|=
name|oonstack
expr_stmt|;
name|scp
operator|->
name|sc_mask
operator|=
name|mask
expr_stmt|;
if|if
condition|(
name|frmtrp
condition|)
block|{
name|scp
operator|->
name|sc_sp
operator|=
name|regs
index|[
name|tESP
index|]
expr_stmt|;
name|scp
operator|->
name|sc_fp
operator|=
name|regs
index|[
name|tEBP
index|]
expr_stmt|;
name|scp
operator|->
name|sc_pc
operator|=
name|regs
index|[
name|tEIP
index|]
expr_stmt|;
name|scp
operator|->
name|sc_ps
operator|=
name|regs
index|[
name|tEFLAGS
index|]
expr_stmt|;
name|regs
index|[
name|tESP
index|]
operator|=
operator|(
name|int
operator|)
name|fp
expr_stmt|;
name|regs
index|[
name|tEIP
index|]
operator|=
operator|(
name|int
operator|)
name|u
operator|.
name|u_pcb
operator|.
name|pcb_sigc
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|sc_sp
operator|=
name|regs
index|[
name|sESP
index|]
expr_stmt|;
name|scp
operator|->
name|sc_fp
operator|=
name|regs
index|[
name|sEBP
index|]
expr_stmt|;
name|scp
operator|->
name|sc_pc
operator|=
name|regs
index|[
name|sEIP
index|]
expr_stmt|;
name|scp
operator|->
name|sc_ps
operator|=
name|regs
index|[
name|sEFLAGS
index|]
expr_stmt|;
name|regs
index|[
name|sESP
index|]
operator|=
operator|(
name|int
operator|)
name|fp
expr_stmt|;
name|regs
index|[
name|sEIP
index|]
operator|=
operator|(
name|int
operator|)
name|u
operator|.
name|u_pcb
operator|.
name|pcb_sigc
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * System call to cleanup state after a signal  * has been taken.  Reset signal mask and  * stack state from context left by sendsig (above).  * Return to previous pc and psl as specified by  * context left by sendsig. Check carefully to  * make sure that the user has not modified the  * psl to gain improper priviledges or to cause  * a machine fault.  */
end_comment

begin_macro
name|sigreturn
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|sigframe
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
specifier|register
name|int
modifier|*
name|regs
init|=
name|u
operator|.
name|u_ar0
decl_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|sigframe
operator|*
operator|)
name|regs
index|[
name|sESP
index|]
expr_stmt|;
if|if
condition|(
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
comment|/* restore scratch registers */
name|regs
index|[
name|sEAX
index|]
operator|=
name|fp
operator|->
name|sf_eax
expr_stmt|;
name|regs
index|[
name|sEDX
index|]
operator|=
name|fp
operator|->
name|sf_edx
expr_stmt|;
name|regs
index|[
name|sECX
index|]
operator|=
name|fp
operator|->
name|sf_ecx
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX FPU state? */
endif|#
directive|endif
name|scp
operator|=
name|fp
operator|->
name|sf_scp
expr_stmt|;
if|if
condition|(
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|scp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
operator|(
name|scp
operator|->
name|sc_ps
operator|&
name|PSL_MBZ
operator|)
operator|!=
literal|0
operator|||
operator|(
name|scp
operator|->
name|sc_ps
operator|&
name|PSL_MBO
operator|)
operator|!=
name|PSL_MBO
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|u
operator|.
name|u_eosys
operator|=
name|JUSTRETURN
expr_stmt|;
name|u
operator|.
name|u_onstack
operator|=
name|scp
operator|->
name|sc_onstack
operator|&
literal|01
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_sigmask
operator|=
name|scp
operator|->
name|sc_mask
operator|&
operator|~
operator|(
name|sigmask
argument_list|(
name|SIGKILL
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGCONT
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGSTOP
argument_list|)
operator|)
expr_stmt|;
name|regs
index|[
name|sEBP
index|]
operator|=
name|scp
operator|->
name|sc_fp
expr_stmt|;
name|regs
index|[
name|sESP
index|]
operator|=
name|scp
operator|->
name|sc_sp
expr_stmt|;
name|regs
index|[
name|sEIP
index|]
operator|=
name|scp
operator|->
name|sc_pc
expr_stmt|;
name|regs
index|[
name|sEFLAGS
index|]
operator|=
name|scp
operator|->
name|sc_ps
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|waittime
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_macro
name|boot
argument_list|(
argument|arghowto
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arghowto
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|dummy
decl_stmt|;
comment|/* r12 is reserved */
specifier|register
name|int
name|howto
decl_stmt|;
comment|/* r11 == how to boot */
specifier|register
name|int
name|devtype
decl_stmt|;
comment|/* r10 == major of root dev */
specifier|extern
name|char
modifier|*
name|panicstr
decl_stmt|;
name|howto
operator|=
name|arghowto
expr_stmt|;
if|if
condition|(
operator|(
name|howto
operator|&
name|RB_NOSYNC
operator|)
operator|==
literal|0
operator|&&
name|waittime
operator|<
literal|0
operator|&&
name|bfreelist
index|[
literal|0
index|]
operator|.
name|b_forw
condition|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|iter
decl_stmt|,
name|nbusy
decl_stmt|;
name|waittime
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|splnet
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"syncing disks... "
argument_list|)
expr_stmt|;
comment|/* 		 * Release inodes held by texts before update. 		 */
if|if
condition|(
name|panicstr
operator|==
literal|0
condition|)
name|xumount
argument_list|(
name|NODEV
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
for|for
control|(
name|iter
operator|=
literal|0
init|;
name|iter
operator|<
literal|20
condition|;
name|iter
operator|++
control|)
block|{
name|nbusy
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bp
operator|=
operator|&
name|buf
index|[
name|nbuf
index|]
init|;
operator|--
name|bp
operator|>=
name|buf
condition|;
control|)
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_BUSY
operator||
name|B_INVAL
operator|)
operator|)
operator|==
name|B_BUSY
condition|)
name|nbusy
operator|++
expr_stmt|;
if|if
condition|(
name|nbusy
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|nbusy
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40000
operator|*
name|iter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbusy
condition|)
name|printf
argument_list|(
literal|"giving up\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* wait for printf to finish */
block|}
name|splhigh
argument_list|()
expr_stmt|;
name|devtype
operator|=
name|major
argument_list|(
name|rootdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|&
name|RB_HALT
condition|)
block|{
name|printf
argument_list|(
literal|"halting (in tight loop); hit reset\n\n"
argument_list|)
expr_stmt|;
name|reset_cpu
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|howto
operator|&
name|RB_DUMP
condition|)
block|{
name|doadump
argument_list|()
expr_stmt|;
comment|/* CPBOOT's itsself */
comment|/*NOTREACHED*/
block|}
block|}
ifdef|#
directive|ifdef
name|lint
name|dummy
operator|=
literal|0
expr_stmt|;
name|dummy
operator|=
name|dummy
expr_stmt|;
name|printf
argument_list|(
literal|"howto %d, devtype %d\n"
argument_list|,
name|arghowto
argument_list|,
name|devtype
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reset_cpu
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
comment|/*asm("hlt")*/
empty_stmt|;
comment|/*NOTREACHED*/
block|}
end_block

begin_decl_stmt
name|int
name|dumpmag
init|=
literal|0x8fca0101
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* magic number for savecore */
end_comment

begin_decl_stmt
name|int
name|dumpsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* also for savecore */
end_comment

begin_comment
comment|/*  * Doadump comes here after turning off memory management and  * getting on the dump stack, either when called above, or by  * the auto-restart code.  */
end_comment

begin_macro
name|dumpsys
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|dumpdev
operator|==
name|NODEV
condition|)
return|return;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|(
name|minor
argument_list|(
name|dumpdev
argument_list|)
operator|&
literal|07
operator|)
operator|!=
literal|1
condition|)
return|return;
endif|#
directive|endif
name|dumpsize
operator|=
name|physmem
expr_stmt|;
name|printf
argument_list|(
literal|"\ndumping to dev %x, offset %d\n"
argument_list|,
name|dumpdev
argument_list|,
name|dumplo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dump "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|bdevsw
index|[
name|major
argument_list|(
name|dumpdev
argument_list|)
index|]
operator|.
name|d_dump
operator|)
operator|(
name|dumpdev
operator|)
condition|)
block|{
case|case
name|ENXIO
case|:
name|printf
argument_list|(
literal|"device bad\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFAULT
case|:
name|printf
argument_list|(
literal|"device not ready\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
name|printf
argument_list|(
literal|"area improper\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EIO
case|:
name|printf
argument_list|(
literal|"i/o error\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"succeeded\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|microtime
argument_list|(
name|tvp
argument_list|)
specifier|register
expr|struct
name|timeval
operator|*
name|tvp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
operator|*
name|tvp
operator|=
name|time
expr_stmt|;
name|tvp
operator|->
name|tv_usec
operator|+=
name|tick
expr_stmt|;
while|while
condition|(
name|tvp
operator|->
name|tv_usec
operator|>
literal|1000000
condition|)
block|{
name|tvp
operator|->
name|tv_sec
operator|++
expr_stmt|;
name|tvp
operator|->
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|physstrat
argument_list|(
argument|bp
argument_list|,
argument|strat
argument_list|,
argument|prio
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
argument_list|(
operator|*
name|strat
argument_list|)
argument_list|()
decl_stmt|,
name|prio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|;
name|caddr_t
name|baddr
decl_stmt|;
comment|/* 	 * vmapbuf clobbers b_addr so we must remember it so that it 	 * can be restored after vunmapbuf.  This is truely rude, we 	 * should really be storing this in a field in the buf struct 	 * but none are available and I didn't want to add one at 	 * this time.  Note that b_addr for dirty page pushes is  	 * restored in vunmapbuf. (ugh!) 	 */
name|baddr
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|vmapbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|strat
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* pageout daemon doesn't wait for pushed pages */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DIRTY
condition|)
return|return;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|prio
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vunmapbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
name|baddr
expr_stmt|;
block|}
end_block

begin_macro
name|initcpu
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|&
name|proc
index|[
literal|0
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Clear registers on exec  */
end_comment

begin_macro
name|setregs
argument_list|(
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|u_long
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|notdef
comment|/* should pass args to init on the stack */
for|for
control|(
name|rp
operator|=
operator|&
name|u
operator|.
name|u_ar0
index|[
literal|0
index|]
init|;
name|rp
operator|<
operator|&
name|u
operator|.
name|u_ar0
index|[
literal|16
index|]
condition|;
control|)
operator|*
name|rp
operator|++
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|u
operator|.
name|u_ar0
index|[
name|sEBP
index|]
operator|=
literal|0
expr_stmt|;
comment|/* bottom of the fp chain */
name|u
operator|.
name|u_ar0
index|[
name|sEIP
index|]
operator|=
name|entry
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialize 386 and configure to run kernel  */
end_comment

begin_comment
comment|/*  * Initialize segments& interrupt table  */
end_comment

begin_define
define|#
directive|define
name|GNULL_SEL
value|0
end_define

begin_comment
comment|/* Null Descriptor */
end_comment

begin_define
define|#
directive|define
name|GCODE_SEL
value|1
end_define

begin_comment
comment|/* Kernel Code Descriptor */
end_comment

begin_define
define|#
directive|define
name|GDATA_SEL
value|2
end_define

begin_comment
comment|/* Kernel Data Descriptor */
end_comment

begin_define
define|#
directive|define
name|GLDT_SEL
value|3
end_define

begin_comment
comment|/* LDT - eventually one per process */
end_comment

begin_define
define|#
directive|define
name|GTGATE_SEL
value|4
end_define

begin_comment
comment|/* Process task switch gate */
end_comment

begin_define
define|#
directive|define
name|GPANIC_SEL
value|5
end_define

begin_comment
comment|/* Task state to consider panic from */
end_comment

begin_define
define|#
directive|define
name|GPROC0_SEL
value|6
end_define

begin_comment
comment|/* Task state process slot zero and up */
end_comment

begin_decl_stmt
name|union
name|descriptor
name|gdt
index|[
name|GPROC0_SEL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interrupt descriptor table */
end_comment

begin_decl_stmt
name|struct
name|gate_descriptor
name|idt
index|[
literal|32
operator|+
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local descriptor table */
end_comment

begin_decl_stmt
name|union
name|descriptor
name|ldt
index|[
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LSYS5CALLS_SEL
value|0
end_define

begin_comment
comment|/* forced by intel BCS */
end_comment

begin_define
define|#
directive|define
name|LSYS5SIGR_SEL
value|1
end_define

begin_define
define|#
directive|define
name|L43BSDCALLS_SEL
value|2
end_define

begin_comment
comment|/* notyet */
end_comment

begin_define
define|#
directive|define
name|LUCODE_SEL
value|3
end_define

begin_define
define|#
directive|define
name|LUDATA_SEL
value|4
end_define

begin_comment
comment|/* seperate stack, es,fs,gs sels ? */
end_comment

begin_comment
comment|/* #define	LPOSIXCALLS_SEL	5	/* notyet */
end_comment

begin_decl_stmt
name|struct
name|i386tss
name|tss
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* software prototypes -- in more palitable form */
end_comment

begin_decl_stmt
name|struct
name|soft_segment_descriptor
name|gdt_segs
index|[]
init|=
block|{
comment|/* Null Descriptor */
block|{
literal|0x0
block|,
comment|/* segment base address  */
literal|0x0
block|,
comment|/* length - all address space */
literal|0
block|,
comment|/* segment type */
literal|0
block|,
comment|/* segment descriptor priority level */
literal|0
block|,
comment|/* segment descriptor present */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* default 32 vs 16 bit size */
literal|0
comment|/* limit granularity (byte/page units)*/
block|}
block|,
comment|/* Code Descriptor for kernel */
block|{
literal|0x0
block|,
comment|/* segment base address  */
literal|0xfffff
block|,
comment|/* length - all address space */
name|SDT_MEMERA
block|,
comment|/* segment type */
literal|0
block|,
comment|/* segment descriptor priority level */
literal|1
block|,
comment|/* segment descriptor present */
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* default 32 vs 16 bit size */
literal|1
comment|/* limit granularity (byte/page units)*/
block|}
block|,
comment|/* Data Descriptor for kernel */
block|{
literal|0x0
block|,
comment|/* segment base address  */
literal|0xfffff
block|,
comment|/* length - all address space */
name|SDT_MEMRWA
block|,
comment|/* segment type */
literal|0
block|,
comment|/* segment descriptor priority level */
literal|1
block|,
comment|/* segment descriptor present */
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* default 32 vs 16 bit size */
literal|1
comment|/* limit granularity (byte/page units)*/
block|}
block|,
comment|/* LDT Descriptor */
block|{
operator|(
name|int
operator|)
name|ldt
block|,
comment|/* segment base address  */
sizeof|sizeof
argument_list|(
name|ldt
argument_list|)
operator|-
literal|1
block|,
comment|/* length - all address space */
name|SDT_SYSLDT
block|,
comment|/* segment type */
literal|0
block|,
comment|/* segment descriptor priority level */
literal|1
block|,
comment|/* segment descriptor present */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* unused - default 32 vs 16 bit size */
literal|0
comment|/* limit granularity (byte/page units)*/
block|}
block|,
comment|/* Null Descriptor - Placeholder */
block|{
literal|0x0
block|,
comment|/* segment base address  */
literal|0x0
block|,
comment|/* length - all address space */
literal|0
block|,
comment|/* segment type */
literal|0
block|,
comment|/* segment descriptor priority level */
literal|0
block|,
comment|/* segment descriptor present */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* default 32 vs 16 bit size */
literal|0
comment|/* limit granularity (byte/page units)*/
block|}
block|,
comment|/* Panic Tss Descriptor */
block|{
operator|(
name|int
operator|)
operator|&
name|u
block|,
comment|/* segment base address  */
sizeof|sizeof
argument_list|(
name|tss
argument_list|)
operator|-
literal|1
block|,
comment|/* length - all address space */
name|SDT_SYS386TSS
block|,
comment|/* segment type */
literal|0
block|,
comment|/* segment descriptor priority level */
literal|1
block|,
comment|/* segment descriptor present */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* unused - default 32 vs 16 bit size */
literal|0
comment|/* limit granularity (byte/page units)*/
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|soft_segment_descriptor
name|ldt_segs
index|[]
init|=
block|{
comment|/* Null Descriptor - overwritten by call gate */
block|{
literal|0x0
block|,
comment|/* segment base address  */
literal|0x0
block|,
comment|/* length - all address space */
literal|0
block|,
comment|/* segment type */
literal|0
block|,
comment|/* segment descriptor priority level */
literal|0
block|,
comment|/* segment descriptor present */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* default 32 vs 16 bit size */
literal|0
comment|/* limit granularity (byte/page units)*/
block|}
block|,
comment|/* Null Descriptor - overwritten by call gate */
block|{
literal|0x0
block|,
comment|/* segment base address  */
literal|0x0
block|,
comment|/* length - all address space */
literal|0
block|,
comment|/* segment type */
literal|0
block|,
comment|/* segment descriptor priority level */
literal|0
block|,
comment|/* segment descriptor present */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* default 32 vs 16 bit size */
literal|0
comment|/* limit granularity (byte/page units)*/
block|}
block|,
comment|/* Null Descriptor - overwritten by call gate */
block|{
literal|0x0
block|,
comment|/* segment base address  */
literal|0x0
block|,
comment|/* length - all address space */
literal|0
block|,
comment|/* segment type */
literal|0
block|,
comment|/* segment descriptor priority level */
literal|0
block|,
comment|/* segment descriptor present */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* default 32 vs 16 bit size */
literal|0
comment|/* limit granularity (byte/page units)*/
block|}
block|,
comment|/* Code Descriptor for user */
block|{
literal|0x0
block|,
comment|/* segment base address  */
literal|0xfffff
block|,
comment|/* length - all address space */
name|SDT_MEMERA
block|,
comment|/* segment type */
name|SEL_UPL
block|,
comment|/* segment descriptor priority level */
literal|1
block|,
comment|/* segment descriptor present */
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* default 32 vs 16 bit size */
literal|1
comment|/* limit granularity (byte/page units)*/
block|}
block|,
comment|/* Data Descriptor for user */
block|{
literal|0x0
block|,
comment|/* segment base address  */
literal|0xfffff
block|,
comment|/* length - all address space */
name|SDT_MEMRWA
block|,
comment|/* segment type */
name|SEL_UPL
block|,
comment|/* segment descriptor priority level */
literal|1
block|,
comment|/* segment descriptor present */
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* default 32 vs 16 bit size */
literal|1
comment|/* limit granularity (byte/page units)*/
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table descriptors - used to load tables by microp */
end_comment

begin_decl_stmt
name|struct
name|region_descriptor
name|r_gdt
init|=
block|{
sizeof|sizeof
argument_list|(
name|gdt
argument_list|)
operator|-
literal|1
block|,
operator|(
name|char
operator|*
operator|)
name|gdt
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|region_descriptor
name|r_idt
init|=
block|{
sizeof|sizeof
argument_list|(
name|idt
argument_list|)
operator|-
literal|1
block|,
operator|(
name|char
operator|*
operator|)
name|idt
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|setidt
argument_list|(
argument|idx
argument_list|,
argument|func
argument_list|,
argument|typ
argument_list|,
argument|dpl
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|gate_descriptor
modifier|*
name|ip
init|=
name|idt
operator|+
name|idx
decl_stmt|;
name|ip
operator|->
name|gd_looffset
operator|=
operator|(
name|int
operator|)
name|func
expr_stmt|;
name|ip
operator|->
name|gd_selector
operator|=
literal|8
expr_stmt|;
name|ip
operator|->
name|gd_stkcpy
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|gd_xx
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|gd_type
operator|=
name|typ
expr_stmt|;
name|ip
operator|->
name|gd_dpl
operator|=
name|dpl
expr_stmt|;
name|ip
operator|->
name|gd_p
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|gd_hioffset
operator|=
operator|(
operator|(
name|int
operator|)
name|func
operator|)
operator|>>
literal|16
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|IDTVEC
parameter_list|(
name|name
parameter_list|)
value|X
comment|/**/
value|name
end_define

begin_extern
extern|extern IDTVEC(div
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|IDTVEC
argument_list|(
name|dbg
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|nmi
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|bpt
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|ofl
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|bnd
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|ill
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|dna
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|dble
argument_list|)
operator|,
comment|/* XXX needs to be handled by task gate */
name|IDTVEC
argument_list|(
name|fpusegm
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|tss
argument_list|)
operator|,
comment|/* XXX needs to be handled by task gate */
name|IDTVEC
argument_list|(
name|missing
argument_list|)
operator|,
comment|/* XXX needs to be handled by task gate */
name|IDTVEC
argument_list|(
name|stk
argument_list|)
operator|,
comment|/* XXX needs to be handled by task gate */
name|IDTVEC
argument_list|(
name|prot
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|page
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|fpu
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd0
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd1
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd2
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd3
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd4
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd5
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd6
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd7
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd8
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd9
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd10
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd11
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd12
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd13
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd14
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|rsvd14
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr0
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr1
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr3
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr4
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr5
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr6
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr7
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr8
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr9
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr10
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr11
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr12
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr13
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr14
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|intr15
argument_list|)
operator|,
name|IDTVEC
argument_list|(
name|syscall
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|lcr0
argument_list|()
decl_stmt|,
name|lcr3
argument_list|()
decl_stmt|,
name|rcr0
argument_list|()
decl_stmt|,
name|rcr2
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_udatasel
decl_stmt|,
name|_ucodesel
decl_stmt|,
name|_gsel_tss
decl_stmt|;
end_decl_stmt

begin_macro
name|init386
argument_list|(
argument|first
argument_list|)
end_macro

begin_block
block|{
extern|extern ssdtosd(
block|)
end_block

begin_operator
operator|,
end_operator

begin_expr_stmt
name|lgdt
argument_list|()
operator|,
name|lidt
argument_list|()
operator|,
name|lldt
argument_list|()
operator|,
name|etext
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|x
decl_stmt|,
modifier|*
name|pi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|gate_descriptor
modifier|*
name|gdp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* make gdt memory segments */
end_comment

begin_expr_stmt
name|gdt_segs
index|[
name|GCODE_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|btoc
argument_list|(
operator|(
name|int
operator|)
operator|&
name|etext
operator|+
name|NBPG
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|6
condition|;
name|x
operator|++
control|)
name|ssdtosd
argument_list|(
name|gdt_segs
operator|+
name|x
argument_list|,
name|gdt
operator|+
name|x
argument_list|)
expr_stmt|;
end_for

begin_comment
comment|/* make ldt memory segments */
end_comment

begin_expr_stmt
name|ldt_segs
index|[
name|LUCODE_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|btoc
argument_list|(
operator|(
name|int
operator|)
operator|&
name|Sysbase
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*ldt_segs[LUDATA_SEL].ssd_limit = btoc((int)&Sysbase); */
end_comment

begin_expr_stmt
name|ldt_segs
index|[
name|LUDATA_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|btoc
argument_list|(
literal|0xfffff000
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|5
condition|;
name|x
operator|++
control|)
name|ssdtosd
argument_list|(
name|ldt_segs
operator|+
name|x
argument_list|,
name|ldt
operator|+
name|x
argument_list|)
expr_stmt|;
end_for

begin_comment
comment|/* Note. eventually want private ldts per process */
end_comment

begin_comment
comment|/* exceptions */
end_comment

begin_expr_stmt
name|setidt
argument_list|(
literal|0
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|div
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|1
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|dbg
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|2
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|nmi
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|3
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|bpt
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_UPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|4
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|ofl
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|5
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|bnd
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|6
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|ill
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|7
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|dna
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|8
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|dble
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|9
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|fpusegm
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|10
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|tss
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|11
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|missing
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|12
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|stk
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|13
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|prot
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|14
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|page
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|15
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|16
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|fpu
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|17
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd0
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|18
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd1
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|19
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd2
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|20
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd3
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|21
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd4
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|22
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd5
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|23
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd6
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|24
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd7
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|25
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd8
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|26
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd9
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|27
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd10
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|28
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd11
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|29
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd12
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|30
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd13
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|31
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd14
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* first icu */
end_comment

begin_expr_stmt
name|setidt
argument_list|(
literal|32
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr0
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|33
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr1
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|34
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr9
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* note: never happens */
end_comment

begin_expr_stmt
name|setidt
argument_list|(
literal|35
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr3
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|36
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr4
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|37
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr5
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|38
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr6
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|39
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr7
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* second icu */
end_comment

begin_expr_stmt
name|setidt
argument_list|(
literal|40
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr8
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|41
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr9
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|42
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr10
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|43
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr11
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|44
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr12
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|45
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr13
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|46
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr14
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setidt
argument_list|(
literal|47
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|intr15
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|lgdt
argument_list|(
name|gdt
argument_list|,
sizeof|sizeof
argument_list|(
name|gdt
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|lidt
argument_list|(
name|idt
argument_list|,
sizeof|sizeof
argument_list|(
name|idt
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|lldt
argument_list|(
name|GSEL
argument_list|(
name|GLDT_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* make a initial tss so microp can get interrupt stack on syscall! */
end_comment

begin_expr_stmt
name|u
operator|.
name|u_pcb
operator|.
name|pcbtss
operator|.
name|tss_esp0
operator|=
operator|(
name|int
operator|)
operator|&
name|u
operator|+
name|UPAGES
operator|*
name|NBPG
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|u
operator|.
name|u_pcb
operator|.
name|pcbtss
operator|.
name|tss_ss0
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_gsel_tss
operator|=
name|GSEL
argument_list|(
name|GPANIC_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ltr
argument_list|(
name|_gsel_tss
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* make a call gate to reenter kernel with */
end_comment

begin_expr_stmt
name|gdp
operator|=
operator|&
name|ldt
index|[
name|LSYS5CALLS_SEL
index|]
operator|.
name|gd
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|x
operator|=
operator|(
name|int
operator|)
operator|&
name|IDTVEC
argument_list|(
name|syscall
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gdp
operator|->
name|gd_looffset
operator|=
name|x
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gdp
operator|->
name|gd_selector
operator|=
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gdp
operator|->
name|gd_stkcpy
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gdp
operator|->
name|gd_type
operator|=
name|SDT_SYS386CGT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gdp
operator|->
name|gd_dpl
operator|=
name|SEL_UPL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gdp
operator|->
name|gd_p
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gdp
operator|->
name|gd_hioffset
operator|=
operator|(
operator|(
name|int
operator|)
operator|&
name|IDTVEC
argument_list|(
name|syscall
argument_list|)
operator|)
operator|>>
literal|16
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* transfer to user mode */
end_comment

begin_expr_stmt
name|_ucodesel
operator|=
name|LSEL
argument_list|(
name|LUCODE_SEL
argument_list|,
name|SEL_UPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_udatasel
operator|=
name|LSEL
argument_list|(
name|LUDATA_SEL
argument_list|,
name|SEL_UPL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* initialize 8259's */
end_comment

begin_expr_stmt
name|outb
argument_list|(
literal|0xf1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
argument_list|(
literal|0x20
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
argument_list|(
literal|0x21
argument_list|,
literal|32
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
argument_list|(
literal|0x21
argument_list|,
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
argument_list|(
literal|0x21
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
argument_list|(
literal|0x21
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
argument_list|(
literal|0xa0
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
argument_list|(
literal|0xa1
argument_list|,
literal|40
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
argument_list|(
literal|0xa1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
argument_list|(
literal|0xa1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
argument_list|(
literal|0xa1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * zero out physical memory  * specified in relocation units (NBPG bytes)  */
end_comment

begin_expr_stmt
unit|clearseg
operator|(
name|n
operator|)
block|{
specifier|extern
name|CMAP1
block|,
name|CADDR1
block|;
name|CMAP1
operator|=
name|PG_V
operator||
name|PG_KW
operator||
name|ctob
argument_list|(
name|n
argument_list|)
block|;
name|load_cr3
argument_list|(
name|_cr3
argument_list|()
argument_list|)
block|;
name|bzero
argument_list|(
operator|&
name|CADDR1
argument_list|,
name|NBPG
argument_list|)
block|; }
comment|/*  * copy a page of physical memory  * specified in relocation units (NBPG bytes)  */
name|copyseg
argument_list|(
argument|frm
argument_list|,
argument|n
argument_list|)
block|{
specifier|extern
name|CMAP2
block|,
name|CADDR2
block|;
name|CMAP2
operator|=
name|PG_V
operator||
name|PG_KW
operator||
name|ctob
argument_list|(
name|n
argument_list|)
block|;
name|load_cr3
argument_list|(
name|_cr3
argument_list|()
argument_list|)
block|;
name|bcopy
argument_list|(
name|frm
argument_list|,
operator|&
name|CADDR2
argument_list|,
name|NBPG
argument_list|)
block|; }
name|strayintr
argument_list|(
argument|d
argument_list|)
block|{
specifier|static
name|x
block|;
comment|/* for some reason, get bursts of intr #7, though not enabled! */
name|pg
argument_list|(
literal|"%d strayintr %x"
argument_list|,
name|x
operator|++
argument_list|,
name|d
argument_list|)
block|; }
name|aston
argument_list|()
block|{
name|schednetisr
argument_list|(
name|NETISR_AST
argument_list|)
block|; }
comment|/*  * insert an element into a queue   */
undef|#
directive|undef
name|insque
name|_insque
argument_list|(
name|element
argument_list|,
name|head
argument_list|)
specifier|register
expr|struct
name|prochd
operator|*
name|element
operator|,
operator|*
name|head
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|element
operator|->
name|ph_link
operator|=
name|head
operator|->
name|ph_link
expr_stmt|;
name|head
operator|->
name|ph_link
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|element
expr_stmt|;
name|element
operator|->
name|ph_rlink
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|head
expr_stmt|;
operator|(
operator|(
expr|struct
name|prochd
operator|*
operator|)
operator|(
name|element
operator|->
name|ph_link
operator|)
operator|)
operator|->
name|ph_rlink
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|element
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * remove an element from a queue  */
end_comment

begin_undef
undef|#
directive|undef
name|remque
end_undef

begin_expr_stmt
name|_remque
argument_list|(
name|element
argument_list|)
specifier|register
expr|struct
name|prochd
operator|*
name|element
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|(
operator|(
expr|struct
name|prochd
operator|*
operator|)
operator|(
name|element
operator|->
name|ph_link
operator|)
operator|)
operator|->
name|ph_rlink
operator|=
name|element
operator|->
name|ph_rlink
expr_stmt|;
operator|(
operator|(
expr|struct
name|prochd
operator|*
operator|)
operator|(
name|element
operator|->
name|ph_rlink
operator|)
operator|)
operator|->
name|ph_link
operator|=
name|element
operator|->
name|ph_link
expr_stmt|;
name|element
operator|->
name|ph_rlink
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|vmunaccess
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_comment
comment|/*  * Below written in C to allow access to debugging code  */
end_comment

begin_macro
name|copyinstr
argument_list|(
argument|fromaddr
argument_list|,
argument|toaddr
argument_list|,
argument|maxlength
argument_list|,
argument|lencopied
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|lencopied
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|toaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|tally
decl_stmt|;
name|tally
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|maxlength
operator|--
condition|)
block|{
name|c
operator|=
name|fubyte
argument_list|(
name|fromaddr
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|lencopied
condition|)
operator|*
name|lencopied
operator|=
name|tally
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|tally
operator|++
expr_stmt|;
operator|*
name|toaddr
operator|++
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lencopied
condition|)
operator|*
name|lencopied
operator|=
name|tally
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|lencopied
condition|)
operator|*
name|lencopied
operator|=
name|tally
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_block

begin_macro
name|copyoutstr
argument_list|(
argument|fromaddr
argument_list|,
argument|toaddr
argument_list|,
argument|maxlength
argument_list|,
argument|lencopied
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|lencopied
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|fromaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|int
name|tally
decl_stmt|;
name|tally
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|maxlength
operator|--
condition|)
block|{
name|c
operator|=
name|subyte
argument_list|(
name|toaddr
operator|++
argument_list|,
operator|*
name|fromaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|tally
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fromaddr
operator|++
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lencopied
condition|)
operator|*
name|lencopied
operator|=
name|tally
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|lencopied
condition|)
operator|*
name|lencopied
operator|=
name|tally
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_block

begin_macro
name|copystr
argument_list|(
argument|fromaddr
argument_list|,
argument|toaddr
argument_list|,
argument|maxlength
argument_list|,
argument|lencopied
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|lencopied
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|fromaddr
decl_stmt|,
modifier|*
name|toaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|tally
decl_stmt|;
name|tally
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|maxlength
operator|--
condition|)
block|{
operator|*
name|toaddr
operator|=
operator|*
name|fromaddr
operator|++
expr_stmt|;
name|tally
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|toaddr
operator|++
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lencopied
condition|)
operator|*
name|lencopied
operator|=
name|tally
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|lencopied
condition|)
operator|*
name|lencopied
operator|=
name|tally
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_block

begin_comment
comment|/*   * ovbcopy - like bcopy, but recognizes overlapping ranges and handles   *           them correctly.  */
end_comment

begin_macro
name|ovbcopy
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|,
argument|bytes
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* num bytes to copy */
end_comment

begin_block
block|{
comment|/* Assume that bcopy copies left-to-right (low addr first). */
if|if
condition|(
name|from
operator|+
name|bytes
operator|<=
name|to
operator|||
name|to
operator|+
name|bytes
operator|<=
name|from
operator|||
name|to
operator|==
name|from
condition|)
name|bcopy
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/* non-overlapping or no-op*/
elseif|else
if|if
condition|(
name|from
operator|>
name|to
condition|)
name|bcopy
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/* overlapping but OK */
else|else
block|{
comment|/* to> from: overlapping, and must copy right-to-left. */
name|from
operator|+=
name|bytes
operator|-
literal|1
expr_stmt|;
name|to
operator|+=
name|bytes
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|bytes
operator|--
operator|>
literal|0
condition|)
operator|*
name|to
operator|--
operator|=
operator|*
name|from
operator|--
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|redstack
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
operator|&
name|u
operator|+
sizeof|sizeof
argument_list|(
name|u
argument_list|)
operator|+
literal|100
operator|>=
operator|(
name|u_int
operator|)
operator|&
name|i
condition|)
name|pg
argument_list|(
literal|"redstack"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

