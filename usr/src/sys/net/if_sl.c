begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1987, 1989, 1992 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  *  *	@(#)if_sl.c	7.28 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Serial Line interface  *  * Rick Adams  * Center for Seismic Studies  * 1300 N 17th Street, Suite 1450  * Arlington, Virginia 22209  * (703)276-7900  * rick@seismo.ARPA  * seismo!rick  *  * Pounded on heavily by Chris Torek (chris@mimsy.umd.edu, umcp-cs!chris).  * N.B.: this belongs in netinet, not net, the way it stands now.  * Should have a link-layer type designation, but wouldn't be  * backwards-compatible.  *  * Converted to 4.3BSD Beta by Chris Torek.  * Other changes made at Berkeley, based in part on code by Kirk Smith.  * W. Jolitz added slip abort.  *  * Hacked almost beyond recognition by Van Jacobson (van@helios.ee.lbl.gov).  * Added priority queuing for "interactive" traffic; hooks for TCP  * header compression; ICMP filtering (at 2400 baud, some cretin  * pinging you can use up all your bandwidth).  Made low clist behavior  * more robust and slightly less likely to hang serial line.  * Sped up a bunch of things.  *   * Note that splimp() is used throughout to block both (tty) input  * interrupts and network activity; thus, splimp must be>= spltty.  */
end_comment

begin_include
include|#
directive|include
file|"sl.h"
end_include

begin_if
if|#
directive|if
name|NSL
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"dk.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"if.h"
end_include

begin_include
include|#
directive|include
file|"if_types.h"
end_include

begin_include
include|#
directive|include
file|"netisr.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_if
if|#
directive|if
name|INET
end_if

begin_include
include|#
directive|include
file|"netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip.h"
end_include

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|Huh
condition|?
name|Slip
name|without
name|inet
condition|?
endif|#
directive|endif
include|#
directive|include
file|"slcompress.h"
include|#
directive|include
file|"if_slvar.h"
comment|/*  * SLMAX is a hard limit on input packet size.  To simplify the code  * and improve performance, we require that packets fit in an mbuf  * cluster, and if we get a compressed packet, there's enough extra  * room to expand the header into a max length tcp/ip header (128  * bytes).  So, SLMAX can be at most  *	MCLBYTES - 128  *  * SLMTU is a hard limit on output packet size.  To insure good  * interactive response, SLMTU wants to be the smallest size that  * amortizes the header cost.  (Remember that even with  * type-of-service queuing, we have to wait for any in-progress  * packet to finish.  I.e., we wait, on the average, 1/2 * mtu /  * cps, where cps is the line speed in characters per second.  * E.g., 533ms wait for a 1024 byte MTU on a 9600 baud line.  The  * average compressed header size is 6-8 bytes so any MTU> 90  * bytes will give us 90% of the line bandwidth.  A 100ms wait is  * tolerable (500ms is not), so want an MTU around 296.  (Since TCP  * will send 256 byte segments (to allow for 40 byte headers), the  * typical packet size on the wire will be around 260 bytes).  In  * 4.3tahoe+ systems, we can set an MTU in a route so we do that&  * leave the interface MTU relatively high (so we don't IP fragment  * when acting as a gateway to someone using a stupid MTU).  *  * Similar considerations apply to SLIP_HIWAT:  It's the amount of  * data that will be queued 'downstream' of us (i.e., in clists  * waiting to be picked up by the tty output interrupt).  If we  * queue a lot of data downstream, it's immune to our t.o.s. queuing.  * E.g., if SLIP_HIWAT is 1024, the interactive traffic in mixed  * telnet/ftp will see a 1 sec wait, independent of the mtu (the  * wait is dependent on the ftp window size but that's typically  * 1k - 4k).  So, we want SLIP_HIWAT just big enough to amortize  * the cost (in idle time on the wire) of the tty driver running  * off the end of its clists& having to call back slstart for a  * new packet.  For a tty interface with any buffering at all, this  * cost will be zero.  Even with a totally brain dead interface (like  * the one on a typical workstation), the cost will be<= 1 character  * time.  So, setting SLIP_HIWAT to ~100 guarantees that we'll lose  * at most 1% while maintaining good interactive response.  */
define|#
directive|define
name|BUFOFFSET
value|128
define|#
directive|define
name|SLMAX
value|(MCLBYTES - BUFOFFSET)
define|#
directive|define
name|SLBUFSIZE
value|(SLMAX + BUFOFFSET)
define|#
directive|define
name|SLMTU
value|296
define|#
directive|define
name|SLIP_HIWAT
value|roundup(50,CBSIZE)
define|#
directive|define
name|CLISTRESERVE
value|1024
comment|/* Can't let clists get too low */
comment|/*  * SLIP ABORT ESCAPE MECHANISM:  *	(inspired by HAYES modem escape arrangement)  *	1sec escape 1sec escape 1sec escape { 1sec escape 1sec escape }  *	within window time signals a "soft" exit from slip mode by remote end  *	if the IFF_DEBUG flag is on.  */
define|#
directive|define
name|ABT_ESC
value|'\033'
comment|/* can't be t_intr - distant host must know it*/
define|#
directive|define
name|ABT_IDLE
value|1
comment|/* in seconds - idle before an escape */
define|#
directive|define
name|ABT_COUNT
value|3
comment|/* count of escapes for abort */
define|#
directive|define
name|ABT_WINDOW
value|(ABT_COUNT*2+2)
comment|/* in seconds - time to count */
then|struct
name|sl_softc
name|sl_softc
index|[
name|NSL
index|]
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|FRAME_END
value|0xc0
end_define

begin_comment
comment|/* Frame End */
end_comment

begin_define
define|#
directive|define
name|FRAME_ESCAPE
value|0xdb
end_define

begin_comment
comment|/* Frame Esc */
end_comment

begin_define
define|#
directive|define
name|TRANS_FRAME_END
value|0xdc
end_define

begin_comment
comment|/* transposed frame end */
end_comment

begin_define
define|#
directive|define
name|TRANS_FRAME_ESCAPE
value|0xdd
end_define

begin_comment
comment|/* transposed frame esc */
end_comment

begin_define
define|#
directive|define
name|t_sc
value|T_LINEP
end_define

begin_decl_stmt
name|int
name|sloutput
argument_list|()
decl_stmt|,
name|slioctl
argument_list|()
decl_stmt|,
name|ttrstrt
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|timeval
name|time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Called from boot code to establish sl interfaces.  */
end_comment

begin_macro
name|slattach
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sc
operator|=
name|sl_softc
init|;
name|i
operator|<
name|NSL
condition|;
name|sc
operator|++
control|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_name
operator|=
literal|"sl"
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_next
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
operator|=
name|i
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|=
name|SLMTU
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|=
name|IFF_POINTOPOINT
operator||
name|SC_AUTOCOMP
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_type
operator|=
name|IFT_SLIP
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ioctl
operator|=
name|slioctl
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_output
operator|=
name|sloutput
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|=
literal|50
expr_stmt|;
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_maxlen
operator|=
literal|32
expr_stmt|;
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|int
name|slinit
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|caddr_t
name|p
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ep
operator|==
operator|(
name|u_char
operator|*
operator|)
literal|0
condition|)
block|{
name|MCLALLOC
argument_list|(
name|p
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|sc
operator|->
name|sc_ep
operator|=
operator|(
name|u_char
operator|*
operator|)
name|p
operator|+
name|SLBUFSIZE
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"sl%d: can't allocate buffer\n"
argument_list|,
name|sc
operator|-
name|sl_softc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|sc_buf
operator|=
name|sc
operator|->
name|sc_ep
operator|-
name|SLMAX
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|sl_compress_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific open routine.  * Attach the given tty to the first available sl unit.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|slopen
argument_list|(
argument|dev
argument_list|,
argument|tp
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|nsl
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_line
operator|==
name|SLIPDISC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|nsl
operator|=
name|NSL
operator|,
name|sc
operator|=
name|sl_softc
init|;
operator|--
name|nsl
operator|>=
literal|0
condition|;
name|sc
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|slinit
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|tp
operator|->
name|t_sc
operator|=
operator|(
name|caddr_t
operator|)
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_ttyp
operator|=
name|tp
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_baudrate
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Line specific close routine.  * Detach the tty from the sl unit.  * Mimics part of ttyclose().  */
end_comment

begin_macro
name|slclose
argument_list|(
argument|tp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ttywflush
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* actually, max(spltty, splnet) */
name|tp
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|if_down
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ttyp
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_sc
operator|=
name|NULL
expr_stmt|;
name|MCLFREE
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|sc
operator|->
name|sc_ep
operator|-
name|SLBUFSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ep
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_buf
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Line specific (tty) ioctl routine.  * Provide a way to get the sl unit number.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|sltioctl
argument_list|(
argument|tp
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sl_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
name|int
name|s
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SLIOCGUNIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Queue a packet.  Start transmission if not active.  */
end_comment

begin_macro
name|sloutput
argument_list|(
argument|ifp
argument_list|,
argument|m
argument_list|,
argument|dst
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
init|=
operator|&
name|sl_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
specifier|register
name|int
name|p
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * `Cannot happen' (see slioctl).  Someday we will extend 	 * the line protocol to support other address families. 	 */
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|printf
argument_list|(
literal|"sl%d: af%d not supported\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_noproto
operator|++
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* sort of */
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ttyp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
name|ifq
operator|=
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_tos
operator|&
name|IPTOS_LOWDELAY
condition|)
block|{
name|ifq
operator|=
operator|&
name|sc
operator|->
name|sc_fastq
expr_stmt|;
name|p
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|SC_COMPRESS
condition|)
block|{
comment|/* 			 * The last parameter turns off connection id 			 * compression for background traffic:  Since 			 * fastq traffic can jump ahead of the background 			 * traffic, we don't know what order packets will 			 * go on the line. 			 */
name|p
operator|=
name|sl_compress_tcp
argument_list|(
name|m
argument_list|,
name|ip
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator||=
name|p
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|SC_NOICMP
operator|&&
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETRESET
operator|)
return|;
comment|/* XXX ? */
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|ifq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_lastchange
operator|=
name|time
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
name|slstart
argument_list|(
name|sc
operator|->
name|sc_ttyp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Start output on interface.  Get another datagram  * to send from the interface queue and map it to  * the interface before starting output.  */
end_comment

begin_expr_stmt
name|slstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
specifier|extern
name|int
name|cfreecount
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * If there is more in the output queue, just send it now. 		 * We are being called in lieu of ttstart and must do what 		 * it would. 		 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|>
name|SLIP_HIWAT
condition|)
return|return;
block|}
comment|/* 		 * This happens briefly when the line shuts down. 		 */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
comment|/* 		 * Get a packet and send it to the interface. 		 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_omcasts
operator|++
expr_stmt|;
comment|/* XXX */
else|else
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|->
name|sc_if
operator|.
name|if_lastchange
operator|=
name|time
expr_stmt|;
comment|/* 		 * If system is getting low on clists, just flush our 		 * output queue (if the stuff was important, it'll get 		 * retransmitted). 		 */
if|if
condition|(
name|cfreecount
operator|<
name|CLISTRESERVE
operator|+
name|SLMTU
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * The extra FRAME_END will start up a new packet, and thus 		 * will flush any accumulated garbage.  We do this whenever 		 * the line may have been idle for some time. 		 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
operator|++
name|sc
operator|->
name|sc_if
operator|.
name|if_obytes
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|m
condition|)
block|{
specifier|register
name|u_char
modifier|*
name|ep
decl_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|ep
operator|=
name|cp
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
comment|/* 				 * Find out how many bytes in the string we can 				 * handle without doing something special. 				 */
specifier|register
name|u_char
modifier|*
name|bp
init|=
name|cp
decl_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
name|FRAME_ESCAPE
case|:
case|case
name|FRAME_END
case|:
operator|--
name|cp
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|cp
operator|>
name|bp
condition|)
block|{
comment|/* 					 * Put n characters at once 					 * into the tty output queue. 					 */
if|if
condition|(
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|,
name|cp
operator|-
name|bp
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
break|break;
name|sc
operator|->
name|sc_if
operator|.
name|if_obytes
operator|+=
name|cp
operator|-
name|bp
expr_stmt|;
block|}
comment|/* 				 * If there are characters left in the mbuf, 				 * the first one must be special.. 				 * Put it out in a different form. 				 */
if|if
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
if|if
condition|(
name|putc
argument_list|(
name|FRAME_ESCAPE
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
break|break;
if|if
condition|(
name|putc
argument_list|(
operator|*
name|cp
operator|++
operator|==
name|FRAME_ESCAPE
condition|?
name|TRANS_FRAME_ESCAPE
else|:
name|TRANS_FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unputc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_if
operator|.
name|if_obytes
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|MFREE
argument_list|(
name|m
argument_list|,
name|m2
argument_list|)
expr_stmt|;
name|m
operator|=
name|m2
expr_stmt|;
block|}
if|if
condition|(
name|putc
argument_list|(
name|FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
comment|/* 			 * Not enough room.  Remove a char to make room 			 * and end the packet normally. 			 * If you get many collisions (more than one or two 			 * a day) you probably do not have enough clists 			 * and you should increase "nclist" in param.c. 			 */
operator|(
name|void
operator|)
name|unputc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|++
name|sc
operator|->
name|sc_if
operator|.
name|if_obytes
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Copy data buffer to mbuf chain; add ifnet pointer.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sl_btom
parameter_list|(
name|sc
parameter_list|,
name|len
parameter_list|)
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * If we have more than MHLEN bytes, it's cheaper to 	 * queue the cluster we just filled& allocate a new one 	 * for the input buffer.  Otherwise, fill the mbuf we 	 * allocated above.  Note that code in the input routine 	 * guarantees that packet will fit in a cluster. 	 */
if|if
condition|(
name|len
operator|>=
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * we couldn't get a cluster - if memory's this 			 * low, it's time to start dropping packets. 			 */
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sc
operator|->
name|sc_ep
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|SLBUFSIZE
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|sc
operator|->
name|sc_buf
operator|&
operator|~
name|MCLOFSET
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_buf
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tty interface receiver interrupt.  */
end_comment

begin_expr_stmt
name|slinput
argument_list|(
name|c
argument_list|,
name|tp
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|s
decl_stmt|;
name|tk_nin
operator|++
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
comment|/* XXX */
return|return;
operator|++
name|sc
operator|->
name|sc_if
operator|.
name|if_ibytes
expr_stmt|;
name|c
operator|&=
literal|0xff
expr_stmt|;
comment|/* XXX */
ifdef|#
directive|ifdef
name|ABT_ESC
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|ABT_ESC
condition|)
block|{
comment|/* 			 * If we have a previous abort, see whether 			 * this one is within the time limit. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_abortcount
operator|&&
name|time
operator|.
name|tv_sec
operator|>=
name|sc
operator|->
name|sc_starttime
operator|+
name|ABT_WINDOW
condition|)
name|sc
operator|->
name|sc_abortcount
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If we see an abort after "idle" time, count it; 			 * record when the first abort escape arrived. 			 */
if|if
condition|(
name|time
operator|.
name|tv_sec
operator|>=
name|sc
operator|->
name|sc_lasttime
operator|+
name|ABT_IDLE
condition|)
block|{
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_abortcount
operator|==
literal|1
condition|)
name|sc
operator|->
name|sc_starttime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_abortcount
operator|>=
name|ABT_COUNT
condition|)
block|{
name|slclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
name|sc
operator|->
name|sc_abortcount
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_lasttime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TRANS_FRAME_ESCAPE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_escape
condition|)
name|c
operator|=
name|FRAME_ESCAPE
expr_stmt|;
break|break;
case|case
name|TRANS_FRAME_END
case|:
if|if
condition|(
name|sc
operator|->
name|sc_escape
condition|)
name|c
operator|=
name|FRAME_END
expr_stmt|;
break|break;
case|case
name|FRAME_ESCAPE
case|:
name|sc
operator|->
name|sc_escape
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|FRAME_END
case|:
name|len
operator|=
name|sc
operator|->
name|sc_mp
operator|-
name|sc
operator|->
name|sc_buf
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|3
condition|)
comment|/* less than min length packet - ignore */
goto|goto
name|newpack
goto|;
if|if
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
name|sc
operator|->
name|sc_buf
operator|&
literal|0xf0
operator|)
operator|)
operator|!=
operator|(
name|IPVERSION
operator|<<
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
name|c
operator|=
name|TYPE_COMPRESSED_TCP
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|TYPE_UNCOMPRESSED_TCP
condition|)
operator|*
name|sc
operator|->
name|sc_buf
operator|&=
literal|0x4f
expr_stmt|;
comment|/* XXX */
comment|/* 			 * We've got something that's not an IP packet. 			 * If compression is enabled, try to decompress it. 			 * Otherwise, if `auto-enable' compression is on and 			 * it's a reasonable packet, decompress it and then 			 * enable compression.  Otherwise, drop it. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|SC_COMPRESS
condition|)
block|{
name|len
operator|=
name|sl_uncompress_tcp
argument_list|(
operator|&
name|sc
operator|->
name|sc_buf
argument_list|,
name|len
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|SC_AUTOCOMP
operator|)
operator|&&
name|c
operator|==
name|TYPE_UNCOMPRESSED_TCP
operator|&&
name|len
operator|>=
literal|40
condition|)
block|{
name|len
operator|=
name|sl_uncompress_tcp
argument_list|(
operator|&
name|sc
operator|->
name|sc_buf
argument_list|,
name|len
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
goto|goto
name|error
goto|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|SC_COMPRESS
expr_stmt|;
block|}
else|else
goto|goto
name|error
goto|;
block|}
name|m
operator|=
name|sl_btom
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_lastchange
operator|=
name|time
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ipintrq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ipintrq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_iqdrops
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_ENQUEUE
argument_list|(
operator|&
name|ipintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|newpack
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_mp
operator|<
name|sc
operator|->
name|sc_ep
condition|)
block|{
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|c
expr_stmt|;
name|sc
operator|->
name|sc_escape
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|error
label|:
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|newpack
label|:
name|sc
operator|->
name|sc_mp
operator|=
name|sc
operator|->
name|sc_buf
operator|=
name|sc
operator|->
name|sc_ep
operator|-
name|SLMAX
expr_stmt|;
name|sc
operator|->
name|sc_escape
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_expr_stmt
name|slioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
else|else
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
case|case
name|SIOCSIFDSTADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

